
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>acl: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/openshift-pipelines/pipelines-as-code/pkg/acl/owners.go (97.1%)</option>
				
				<option value="file1">github.com/openshift-pipelines/pipelines-as-code/pkg/acl/regexp.go (100.0%)</option>
				
				<option value="file2">github.com/openshift-pipelines/pipelines-as-code/pkg/action/patch.go (76.2%)</option>
				
				<option value="file3">github.com/openshift-pipelines/pipelines-as-code/pkg/adapter/adapter.go (62.6%)</option>
				
				<option value="file4">github.com/openshift-pipelines/pipelines-as-code/pkg/adapter/incoming.go (91.0%)</option>
				
				<option value="file5">github.com/openshift-pipelines/pipelines-as-code/pkg/adapter/sinker.go (36.4%)</option>
				
				<option value="file6">github.com/openshift-pipelines/pipelines-as-code/pkg/adapter/tls.go (92.3%)</option>
				
				<option value="file7">github.com/openshift-pipelines/pipelines-as-code/pkg/apis/incoming/incoming.go (100.0%)</option>
				
				<option value="file8">github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1/register.go (0.0%)</option>
				
				<option value="file9">github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1/types.go (100.0%)</option>
				
				<option value="file10">github.com/openshift-pipelines/pipelines-as-code/pkg/cel/cel.go (80.8%)</option>
				
				<option value="file11">github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles/changedfiles.go (100.0%)</option>
				
				<option value="file12">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/browser/browser.go (0.0%)</option>
				
				<option value="file13">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/cli.go (0.0%)</option>
				
				<option value="file14">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/color.go (34.3%)</option>
				
				<option value="file15">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/info/configmap.go (88.2%)</option>
				
				<option value="file16">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/iostreams.go (74.4%)</option>
				
				<option value="file17">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/prompt/select_repo.go (78.3%)</option>
				
				<option value="file18">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/prompt/stubber.go (77.3%)</option>
				
				<option value="file19">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/status/status.go (95.2%)</option>
				
				<option value="file20">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/webhook/bitbucket_cloud.go (74.1%)</option>
				
				<option value="file21">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/webhook/github.go (63.8%)</option>
				
				<option value="file22">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/webhook/gitlab.go (66.7%)</option>
				
				<option value="file23">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/webhook/secret.go (83.3%)</option>
				
				<option value="file24">github.com/openshift-pipelines/pipelines-as-code/pkg/cli/webhook/webhook.go (0.0%)</option>
				
				<option value="file25">github.com/openshift-pipelines/pipelines-as-code/pkg/configutil/config.go (90.0%)</option>
				
				<option value="file26">github.com/openshift-pipelines/pipelines-as-code/pkg/consoleui/custom.go (95.3%)</option>
				
				<option value="file27">github.com/openshift-pipelines/pipelines-as-code/pkg/consoleui/interface.go (40.0%)</option>
				
				<option value="file28">github.com/openshift-pipelines/pipelines-as-code/pkg/consoleui/openshift.go (100.0%)</option>
				
				<option value="file29">github.com/openshift-pipelines/pipelines-as-code/pkg/consoleui/tektondashboard.go (100.0%)</option>
				
				<option value="file30">github.com/openshift-pipelines/pipelines-as-code/pkg/customparams/customparams.go (100.0%)</option>
				
				<option value="file31">github.com/openshift-pipelines/pipelines-as-code/pkg/customparams/standard.go (83.3%)</option>
				
				<option value="file32">github.com/openshift-pipelines/pipelines-as-code/pkg/events/emit.go (70.6%)</option>
				
				<option value="file33">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/age.go (100.0%)</option>
				
				<option value="file34">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/array.go (100.0%)</option>
				
				<option value="file35">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/emoji.go (88.2%)</option>
				
				<option value="file36">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/k8labels.go (100.0%)</option>
				
				<option value="file37">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/k8names.go (100.0%)</option>
				
				<option value="file38">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/pipelinerun.go (100.0%)</option>
				
				<option value="file39">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/repository.go (100.0%)</option>
				
				<option value="file40">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/starting.go (100.0%)</option>
				
				<option value="file41">github.com/openshift-pipelines/pipelines-as-code/pkg/formatting/vcs.go (96.2%)</option>
				
				<option value="file42">github.com/openshift-pipelines/pipelines-as-code/pkg/git/git.go (88.6%)</option>
				
				<option value="file43">github.com/openshift-pipelines/pipelines-as-code/pkg/hub/artifacthub.go (100.0%)</option>
				
				<option value="file44">github.com/openshift-pipelines/pipelines-as-code/pkg/hub/get.go (100.0%)</option>
				
				<option value="file45">github.com/openshift-pipelines/pipelines-as-code/pkg/hub/hub.go (88.9%)</option>
				
				<option value="file46">github.com/openshift-pipelines/pipelines-as-code/pkg/hub/tektonhub.go (3.0%)</option>
				
				<option value="file47">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/cleanups.go (86.4%)</option>
				
				<option value="file48">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/events.go (0.0%)</option>
				
				<option value="file49">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/kubeinteraction.go (100.0%)</option>
				
				<option value="file50">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/labels.go (63.0%)</option>
				
				<option value="file51">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/pod_logs.go (0.0%)</option>
				
				<option value="file52">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/resultsannotation.go (83.3%)</option>
				
				<option value="file53">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/secrets.go (56.0%)</option>
				
				<option value="file54">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/status/task_status.go (76.3%)</option>
				
				<option value="file55">github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/wait.go (75.0%)</option>
				
				<option value="file56">github.com/openshift-pipelines/pipelines-as-code/pkg/matcher/annotation_matcher.go (93.4%)</option>
				
				<option value="file57">github.com/openshift-pipelines/pipelines-as-code/pkg/matcher/annotation_tasks_install.go (89.0%)</option>
				
				<option value="file58">github.com/openshift-pipelines/pipelines-as-code/pkg/matcher/cel.go (82.5%)</option>
				
				<option value="file59">github.com/openshift-pipelines/pipelines-as-code/pkg/matcher/errors.go (85.7%)</option>
				
				<option value="file60">github.com/openshift-pipelines/pipelines-as-code/pkg/matcher/repo_runinfo_matcher.go (70.0%)</option>
				
				<option value="file61">github.com/openshift-pipelines/pipelines-as-code/pkg/metrics/injection.go (0.0%)</option>
				
				<option value="file62">github.com/openshift-pipelines/pipelines-as-code/pkg/metrics/metrics.go (0.0%)</option>
				
				<option value="file63">github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments/args.go (100.0%)</option>
				
				<option value="file64">github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments/comments.go (98.2%)</option>
				
				<option value="file65">github.com/openshift-pipelines/pipelines-as-code/pkg/params/cli.go (0.0%)</option>
				
				<option value="file66">github.com/openshift-pipelines/pipelines-as-code/pkg/params/clients/clients.go (14.8%)</option>
				
				<option value="file67">github.com/openshift-pipelines/pipelines-as-code/pkg/params/config_sync.go (0.0%)</option>
				
				<option value="file68">github.com/openshift-pipelines/pipelines-as-code/pkg/params/info/controller_info.go (100.0%)</option>
				
				<option value="file69">github.com/openshift-pipelines/pipelines-as-code/pkg/params/info/events.go (100.0%)</option>
				
				<option value="file70">github.com/openshift-pipelines/pipelines-as-code/pkg/params/info/info.go (6.7%)</option>
				
				<option value="file71">github.com/openshift-pipelines/pipelines-as-code/pkg/params/info/kube.go (63.6%)</option>
				
				<option value="file72">github.com/openshift-pipelines/pipelines-as-code/pkg/params/info/ns.go (0.0%)</option>
				
				<option value="file73">github.com/openshift-pipelines/pipelines-as-code/pkg/params/info/pac.go (8.3%)</option>
				
				<option value="file74">github.com/openshift-pipelines/pipelines-as-code/pkg/params/install.go (100.0%)</option>
				
				<option value="file75">github.com/openshift-pipelines/pipelines-as-code/pkg/params/run.go (0.0%)</option>
				
				<option value="file76">github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings/config.go (84.4%)</option>
				
				<option value="file77">github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings/default.go (100.0%)</option>
				
				<option value="file78">github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype/types.go (0.0%)</option>
				
				<option value="file79">github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode/cancel_pipelineruns.go (94.8%)</option>
				
				<option value="file80">github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode/concurrency.go (93.9%)</option>
				
				<option value="file81">github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode/errors.go (100.0%)</option>
				
				<option value="file82">github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode/match.go (82.9%)</option>
				
				<option value="file83">github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode/pipelineascode.go (71.3%)</option>
				
				<option value="file84">github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode/secret.go (81.8%)</option>
				
				<option value="file85">github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode/template.go (100.0%)</option>
				
				<option value="file86">github.com/openshift-pipelines/pipelines-as-code/pkg/policy/policy.go (90.5%)</option>
				
				<option value="file87">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/acl.go (85.5%)</option>
				
				<option value="file88">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/bitbucket.go (80.9%)</option>
				
				<option value="file89">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/detect.go (90.6%)</option>
				
				<option value="file90">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/parse_payload.go (88.2%)</option>
				
				<option value="file91">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter/acl.go (86.0%)</option>
				
				<option value="file92">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter/bitbucketdatacenter.go (85.2%)</option>
				
				<option value="file93">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter/detect.go (92.9%)</option>
				
				<option value="file94">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter/parse_payload.go (98.4%)</option>
				
				<option value="file95">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea/acl.go (82.2%)</option>
				
				<option value="file96">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea/detect.go (100.0%)</option>
				
				<option value="file97">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea/gitea.go (62.3%)</option>
				
				<option value="file98">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea/parse_payload.go (0.0%)</option>
				
				<option value="file99">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea/webhook.go (60.0%)</option>
				
				<option value="file100">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/acl.go (88.6%)</option>
				
				<option value="file101">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/app/token.go (81.5%)</option>
				
				<option value="file102">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/detect.go (91.7%)</option>
				
				<option value="file103">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/github.go (87.7%)</option>
				
				<option value="file104">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/parse_payload.go (92.8%)</option>
				
				<option value="file105">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/profiler.go (93.0%)</option>
				
				<option value="file106">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/repository.go (83.0%)</option>
				
				<option value="file107">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/scope.go (87.2%)</option>
				
				<option value="file108">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/status.go (68.3%)</option>
				
				<option value="file109">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab/acl.go (97.9%)</option>
				
				<option value="file110">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab/detect.go (90.0%)</option>
				
				<option value="file111">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab/gitlab.go (83.6%)</option>
				
				<option value="file112">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab/parse_payload.go (83.4%)</option>
				
				<option value="file113">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab/task.go (59.5%)</option>
				
				<option value="file114">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/metrics/metrics.go (80.0%)</option>
				
				<option value="file115">github.com/openshift-pipelines/pipelines-as-code/pkg/provider/provider.go (66.2%)</option>
				
				<option value="file116">github.com/openshift-pipelines/pipelines-as-code/pkg/random/random.go (100.0%)</option>
				
				<option value="file117">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/cleanup.go (83.3%)</option>
				
				<option value="file118">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/controller.go (31.2%)</option>
				
				<option value="file119">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/emit_metrics.go (89.7%)</option>
				
				<option value="file120">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/event.go (77.8%)</option>
				
				<option value="file121">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/finalizer.go (58.1%)</option>
				
				<option value="file122">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/queue_pipelineruns.go (78.0%)</option>
				
				<option value="file123">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/reconciler.go (45.6%)</option>
				
				<option value="file124">github.com/openshift-pipelines/pipelines-as-code/pkg/reconciler/status.go (82.6%)</option>
				
				<option value="file125">github.com/openshift-pipelines/pipelines-as-code/pkg/resolve/remote.go (88.3%)</option>
				
				<option value="file126">github.com/openshift-pipelines/pipelines-as-code/pkg/resolve/resolve.go (94.5%)</option>
				
				<option value="file127">github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/basic_auth.go (94.1%)</option>
				
				<option value="file128">github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/secrets.go (93.9%)</option>
				
				<option value="file129">github.com/openshift-pipelines/pipelines-as-code/pkg/sort/pipelinerun.go (100.0%)</option>
				
				<option value="file130">github.com/openshift-pipelines/pipelines-as-code/pkg/sort/repository.go (100.0%)</option>
				
				<option value="file131">github.com/openshift-pipelines/pipelines-as-code/pkg/sort/repository_status.go (83.3%)</option>
				
				<option value="file132">github.com/openshift-pipelines/pipelines-as-code/pkg/sort/runtime_sort.go (30.2%)</option>
				
				<option value="file133">github.com/openshift-pipelines/pipelines-as-code/pkg/sort/task_log_snippets.go (100.0%)</option>
				
				<option value="file134">github.com/openshift-pipelines/pipelines-as-code/pkg/sort/task_status.go (88.9%)</option>
				
				<option value="file135">github.com/openshift-pipelines/pipelines-as-code/pkg/sync/priority_queue.go (100.0%)</option>
				
				<option value="file136">github.com/openshift-pipelines/pipelines-as-code/pkg/sync/queue_manager.go (82.6%)</option>
				
				<option value="file137">github.com/openshift-pipelines/pipelines-as-code/pkg/sync/queue_manager_interface.go (100.0%)</option>
				
				<option value="file138">github.com/openshift-pipelines/pipelines-as-code/pkg/sync/semaphore.go (91.4%)</option>
				
				<option value="file139">github.com/openshift-pipelines/pipelines-as-code/pkg/templates/templating.go (88.9%)</option>
				
				<option value="file140">github.com/openshift-pipelines/pipelines-as-code/pkg/webhook/controller.go (0.0%)</option>
				
				<option value="file141">github.com/openshift-pipelines/pipelines-as-code/pkg/webhook/reconciler.go (10.8%)</option>
				
				<option value="file142">github.com/openshift-pipelines/pipelines-as-code/pkg/webhook/validation.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package acl

import (
        "fmt"

        "sigs.k8s.io/yaml"
)

type aliases = map[string][]string

type simpleConfig struct {
        Approvers []string `json:"approvers,omitempty"`
        Reviewers []string `json:"reviewers,omitempty"`
}

type filtersConfig struct {
        Filters map[string]simpleConfig `json:"filters,omitempty"`
}

type aliasesConfig struct {
        Aliases aliases `json:"aliases,omitempty"`
}

// UserInOwnerFile Parse OWNERS and OWNERS_ALIASES files and return true if the sender is in
// there. Support OWNERS simple configs (approvers, reviewers) and filters. When filters are used,
// only match against the ".*" filter.
func UserInOwnerFile(ownersContent, ownersAliasesContent, sender string) (bool, error) <span class="cov8" title="1">{
        sc := simpleConfig{}
        fc := filtersConfig{}
        ac := aliasesConfig{}
        err := yaml.Unmarshal([]byte(ownersContent), &amp;sc)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("cannot parse OWNERS file Approvers and Reviewers: %w", err)
        }</span>
        <span class="cov8" title="1">err = yaml.Unmarshal([]byte(ownersContent), &amp;fc)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("cannot parse OWNERS file Filters: %w", err)
        }</span>
        <span class="cov8" title="1">err = yaml.Unmarshal([]byte(ownersAliasesContent), &amp;ac)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("cannot parse OWNERS_ALIASES: %w", err)
        }</span>

        <span class="cov8" title="1">var approvers, reviewers []string
        if len(sc.Approvers) &gt; 0 || len(sc.Reviewers) &gt; 0 </span><span class="cov8" title="1">{
                approvers, reviewers = sc.Approvers, sc.Reviewers
                // Simple config (approvers/reviewers) and filters can't exist together.
                // We only check for the ".*" filter (matching all files in the repo).
        }</span> else<span class="cov8" title="1"> if filter, ok := fc.Filters[".*"]; ok </span><span class="cov8" title="1">{
                if len(filter.Approvers) &gt; 0 || len(filter.Reviewers) &gt; 0 </span><span class="cov8" title="1">{
                        approvers, reviewers = filter.Approvers, filter.Reviewers
                }</span>
        }
        <span class="cov8" title="1">owners := expandAliases(append(approvers, reviewers...), ac.Aliases)
        for _, owner := range owners </span><span class="cov8" title="1">{
                if owner == sender </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// Expand aliases into the list of owners removing the duplicates.
// Due to the use of map for deduplication, the order is not guaranteed.
func expandAliases(owners []string, aliases aliases) []string <span class="cov8" title="1">{
        dedups := make(map[string]bool)
        for _, owner := range owners </span><span class="cov8" title="1">{
                if _, ok := dedups[owner]; !ok </span><span class="cov8" title="1">{
                        // check if owner is an alias
                        if alias, ok := aliases[owner]; ok </span><span class="cov8" title="1">{
                                for _, name := range alias </span><span class="cov8" title="1">{
                                        dedups[name] = true
                                }</span>
                        } else<span class="cov8" title="1"> {
                                dedups[owner] = true
                        }</span>
                }
        }
        <span class="cov8" title="1">expanded := make([]string, 0, len(dedups))
        for o := range dedups </span><span class="cov8" title="1">{
                expanded = append(expanded, o)
        }</span>
        <span class="cov8" title="1">return expanded</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package acl

import (
        "regexp"
)

const OKToTestCommentRegexp = `(^|\n)\/ok-to-test(\r\n|\r|\n|$)`

// MatchRegexp Match a regexp to a string.
func MatchRegexp(reg, comment string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(reg)
        return string(re.Find([]byte(comment))) != ""
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package action

import (
        "context"
        "encoding/json"
        "fmt"

        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/util/retry"
)

// PatchPipelineRun patches a Tekton PipelineRun resource with the provided merge patch.
// It retries the patch operation on conflict, doubling the default retry parameters.
//
// Parameters:
// - ctx: The context for the patch operation.
// - logger: A SugaredLogger instance for logging information.
// - whatPatching: A string describing what is being patched, used for logging purposes.
// - tekton: A Tekton client interface for interacting with Tekton resources.
// - pr: The PipelineRun resource to be patched. If nil, the function returns nil.
// - mergePatch: A map representing the JSON merge patch to apply to the PipelineRun.
//
// Returns:
// - *tektonv1.PipelineRun: The patched PipelineRun resource, or the original PipelineRun if an error occurs.
// - error: An error if the patch operation fails after retries, or nil if successful.
//
// The function doubles the default retry parameters (steps, duration, factor, jitter) to handle conflicts more robustly.
// If the patch operation fails after retries, the original PipelineRun is returned along with the error.
func PatchPipelineRun(ctx context.Context, logger *zap.SugaredLogger, whatPatching string, tekton versioned.Interface, pr *tektonv1.PipelineRun, mergePatch map[string]any) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        if pr == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">var patchedPR *tektonv1.PipelineRun
        // double the retry; see https://issues.redhat.com/browse/SRVKP-3134
        doubleRetry := retry.DefaultRetry
        doubleRetry.Steps *= 2
        doubleRetry.Duration *= 2
        doubleRetry.Factor *= 2
        doubleRetry.Jitter *= 2
        err := retry.RetryOnConflict(doubleRetry, func() error </span><span class="cov8" title="1">{
                patch, err := json.Marshal(mergePatch)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">patchedPR, err = tekton.TektonV1().PipelineRuns(pr.GetNamespace()).Patch(ctx, pr.GetName(), types.MergePatchType, patch, metav1.PatchOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Infof("could not patch Pipelinerun with %v, retrying %v/%v: %v", whatPatching, pr.GetNamespace(), pr.GetName(), err)
                        return err
                }</span>
                <span class="cov8" title="1">logger.Infof("patched pipelinerun with %v: %v/%v", whatPatching, patchedPR.Namespace, patchedPR.Name)
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // return the original PipelineRun, let the caller decide what to do with it after the error is processed
                return pr, fmt.Errorf("failed to patch pipelinerun %v/%v with %v: %w", pr.Namespace, whatPatching, pr.Name, err)
        }</span>
        <span class="cov8" title="1">return patchedPR, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package adapter

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/version"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/eventing/pkg/adapter/v2"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/system"
)

const globalAdapterPort = "8082"

// For incoming webhook requests and GitHub Apps with many installations the handler takes long
// e.g GitHub App with ~400 installations, it takes ~180s. For OpenShift deployments this also
// requires matching timeout on the pipelines-as-code-controller route (default is 30s).
const httpTimeoutHandler = 600 * time.Second

type envConfig struct {
        adapter.EnvConfig
}

func NewEnvConfig() adapter.EnvConfigAccessor <span class="cov0" title="0">{
        return &amp;envConfig{
                adapter.EnvConfig{
                        Namespace: system.Namespace(),
                },
        }
}</span>

type listener struct {
        run    *params.Run
        kint   kubeinteraction.Interface
        logger *zap.SugaredLogger
        event  *info.Event
}

type Response struct {
        Status  int    `json:"status"`
        Message string `json:"message"`
}

var _ adapter.Adapter = (*listener)(nil)

func New(run *params.Run, k *kubeinteraction.Interaction) adapter.AdapterConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, _ adapter.EnvConfigAccessor, _ cloudevents.Client) adapter.Adapter </span><span class="cov0" title="0">{
                return &amp;listener{
                        logger: logging.FromContext(ctx),
                        run:    run,
                        kint:   k,
                }
        }</span>
}

func (l *listener) Start(ctx context.Context) error <span class="cov0" title="0">{
        adapterPort := globalAdapterPort
        envAdapterPort := os.Getenv("PAC_CONTROLLER_PORT")
        if envAdapterPort != "" </span><span class="cov0" title="0">{
                adapterPort = envAdapterPort
        }</span>

        // Start pac config syncer
        <span class="cov0" title="0">go params.StartConfigSync(ctx, l.run)

        l.logger.Infof("Starting Pipelines as Code version: %s", strings.TrimSpace(version.Version))
        mux := http.NewServeMux()

        // for handling probes
        mux.HandleFunc("/live", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                _, _ = fmt.Fprint(w, "ok")
        }</span>)

        <span class="cov0" title="0">mux.HandleFunc("/", l.handleEvent(ctx))

        srv := &amp;http.Server{
                Addr: ":" + adapterPort,
                Handler: http.TimeoutHandler(mux,
                        httpTimeoutHandler, "Listener Timeout!\n"),
                ReadHeaderTimeout: 5 * time.Second,
                ReadTimeout:       10 * time.Second,
                IdleTimeout:       30 * time.Second,
        }

        enabled, tlsCertFile, tlsKeyFile := l.isTLSEnabled()
        if enabled </span><span class="cov0" title="0">{
                if err := srv.ListenAndServeTLS(tlsCertFile, tlsKeyFile); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (l listener) handleEvent(ctx context.Context) http.HandlerFunc <span class="cov8" title="1">{
        return func(response http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                if request.Method != http.MethodPost </span><span class="cov8" title="1">{
                        l.writeResponse(response, http.StatusOK, "ok")
                        return
                }</span>

                // event body
                <span class="cov8" title="1">payload, err := io.ReadAll(request.Body)
                if err != nil </span><span class="cov0" title="0">{
                        l.logger.Errorf("failed to read body : %v", err)
                        response.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">var event map[string]any
                if string(payload) != "" </span><span class="cov8" title="1">{
                        if err := json.Unmarshal(payload, &amp;event); err != nil </span><span class="cov8" title="1">{
                                l.logger.Errorf("Invalid event body format format: %s", err)
                                response.WriteHeader(http.StatusBadRequest)
                                return
                        }</span>
                }

                <span class="cov8" title="1">var gitProvider provider.Interface
                var logger *zap.SugaredLogger

                l.event = info.NewEvent()
                pacInfo := l.run.Info.GetPacOpts()

                globalRepo, err := l.run.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(l.run.Info.Kube.Namespace).Get(
                        ctx, l.run.Info.Controller.GlobalRepository, metav1.GetOptions{},
                )
                if err == nil &amp;&amp; globalRepo != nil </span><span class="cov8" title="1">{
                        l.logger.Infof("detected global repository settings named %s in namespace %s", l.run.Info.Controller.GlobalRepository, l.run.Info.Kube.Namespace)
                }</span> else<span class="cov0" title="0"> {
                        globalRepo = &amp;v1alpha1.Repository{}
                }</span>

                <span class="cov8" title="1">detected, configuring, err := github.ConfigureRepository(ctx, l.run, request, string(payload), &amp;pacInfo, l.logger)
                if detected </span><span class="cov0" title="0">{
                        if configuring &amp;&amp; err == nil </span><span class="cov0" title="0">{
                                l.writeResponse(response, http.StatusCreated, "configured")
                                return
                        }</span>
                        <span class="cov0" title="0">if configuring &amp;&amp; err != nil </span><span class="cov0" title="0">{
                                l.logger.Errorf("repository auto-configure has failed, err: %v", err)
                                l.writeResponse(response, http.StatusOK, "failed to configure")
                                return
                        }</span>
                        <span class="cov0" title="0">l.writeResponse(response, http.StatusOK, "skipped event")
                        return</span>
                }

                <span class="cov8" title="1">isIncoming, targettedRepo, err := l.detectIncoming(ctx, request, payload)
                if err != nil </span><span class="cov0" title="0">{
                        l.logger.Errorf("error processing incoming webhook: %v", err)
                        return
                }</span>

                <span class="cov8" title="1">if isIncoming </span><span class="cov0" title="0">{
                        gitProvider, logger, err = l.processIncoming(targettedRepo)
                }</span> else<span class="cov8" title="1"> {
                        gitProvider, logger, err = l.detectProvider(request, string(payload))
                }</span>

                // figure out which provider request coming from
                <span class="cov8" title="1">if err != nil || gitProvider == nil </span><span class="cov8" title="1">{
                        l.writeResponse(response, http.StatusOK, err.Error())
                        return
                }</span>
                <span class="cov8" title="1">gitProvider.SetPacInfo(&amp;pacInfo)

                s := sinker{
                        run:        l.run,
                        vcx:        gitProvider,
                        kint:       l.kint,
                        event:      l.event,
                        logger:     logger,
                        payload:    payload,
                        pacInfo:    &amp;pacInfo,
                        globalRepo: globalRepo,
                }

                // clone the request to use it further
                localRequest := request.Clone(request.Context())

                go func() </span><span class="cov8" title="1">{
                        err := s.processEvent(ctx, localRequest)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("an error occurred: %v", err)
                        }</span>
                }()

                <span class="cov8" title="1">l.writeResponse(response, http.StatusAccepted, "accepted")</span>
        }
}

func (l listener) processRes(processEvent bool, provider provider.Interface, logger *zap.SugaredLogger, skipReason string, err error) (provider.Interface, *zap.SugaredLogger, error) <span class="cov8" title="1">{
        if processEvent </span><span class="cov8" title="1">{
                provider.SetLogger(logger)
                return provider, logger, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                errStr := fmt.Sprintf("got error while processing : %v", err)
                logger.Error(errStr)
                return nil, logger, fmt.Errorf("%s", errStr)
        }</span>

        <span class="cov8" title="1">if skipReason != "" </span><span class="cov8" title="1">{
                logger.Debugf("skipping non supported event: %s", skipReason)
        }</span>
        <span class="cov8" title="1">return nil, logger, fmt.Errorf("skipping non supported event")</span>
}

func (l listener) detectProvider(req *http.Request, reqBody string) (provider.Interface, *zap.SugaredLogger, error) <span class="cov8" title="1">{
        log := *l.logger

        // payload validation
        var event map[string]any
        if err := json.Unmarshal([]byte(reqBody), &amp;event); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;log, fmt.Errorf("invalid event body format: %w", err)
        }</span>

        <span class="cov8" title="1">gitHub := github.New()
        gitHub.Run = l.run
        isGH, processReq, logger, reason, err := gitHub.Detect(req, reqBody, &amp;log)
        if isGH </span><span class="cov8" title="1">{
                return l.processRes(processReq, gitHub, logger, reason, err)
        }</span>

        <span class="cov8" title="1">zegitea := &amp;gitea.Provider{}
        isGitea, processReq, logger, reason, err := zegitea.Detect(req, reqBody, &amp;log)
        if isGitea </span><span class="cov0" title="0">{
                return l.processRes(processReq, zegitea, logger, reason, err)
        }</span>

        <span class="cov8" title="1">bitServer := &amp;bitbucketdatacenter.Provider{}
        isBitServer, processReq, logger, reason, err := bitServer.Detect(req, reqBody, &amp;log)
        if isBitServer </span><span class="cov0" title="0">{
                return l.processRes(processReq, bitServer, logger, reason, err)
        }</span>

        <span class="cov8" title="1">gitLab := &amp;gitlab.Provider{}
        isGitLab, processReq, logger, reason, err := gitLab.Detect(req, reqBody, &amp;log)
        if isGitLab </span><span class="cov0" title="0">{
                return l.processRes(processReq, gitLab, logger, reason, err)
        }</span>

        <span class="cov8" title="1">bitCloud := &amp;bitbucketcloud.Provider{}

        isBitCloud, processReq, logger, reason, err := bitCloud.Detect(req, reqBody, &amp;log)
        if isBitCloud </span><span class="cov0" title="0">{
                return l.processRes(processReq, bitCloud, logger, reason, err)
        }</span>

        <span class="cov8" title="1">return l.processRes(false, nil, logger, "", fmt.Errorf("no supported Git provider has been detected"))</span>
}

func (l listener) writeResponse(response http.ResponseWriter, statusCode int, message string) <span class="cov8" title="1">{
        response.WriteHeader(statusCode)
        response.Header().Set("Content-Type", "application/json")
        body := Response{
                Status:  statusCode,
                Message: message,
        }
        if err := json.NewEncoder(response).Encode(body); err != nil </span><span class="cov0" title="0">{
                l.logger.Errorf("failed to write back sink response: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package adapter

import (
        "context"
        "crypto/subtle"
        "encoding/json"
        "fmt"
        "net/http"

        apincoming "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/incoming"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/matcher"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github/app"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab"
        ktypes "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/types"
        "go.uber.org/zap"
)

func compareSecret(incomingSecret, secretValue string) bool <span class="cov8" title="1">{
        return subtle.ConstantTimeCompare([]byte(incomingSecret), []byte(secretValue)) != 0
}</span>

func applyIncomingParams(req *http.Request, payloadBody []byte, params []string) (apincoming.Payload, error) <span class="cov8" title="1">{
        if req.Header.Get("Content-Type") != "application/json" </span><span class="cov8" title="1">{
                return apincoming.Payload{}, fmt.Errorf("invalid content type, only application/json is accepted when posting a body")
        }</span>
        <span class="cov8" title="1">payload, err := apincoming.ParseIncomingPayload(payloadBody)
        if err != nil </span><span class="cov8" title="1">{
                return apincoming.Payload{}, fmt.Errorf("error parsing incoming payload, not the expected format?: %w", err)
        }</span>
        <span class="cov8" title="1">for k := range payload.Params </span><span class="cov8" title="1">{
                allowed := false
                for _, allowedP := range params </span><span class="cov8" title="1">{
                        if k == allowedP </span><span class="cov8" title="1">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                        return apincoming.Payload{}, fmt.Errorf("param %s is not allowed in incoming webhook CR", k)
                }</span>
        }
        <span class="cov8" title="1">return payload, nil</span>
}

func (l *listener) detectIncoming(ctx context.Context, req *http.Request, payloadBody []byte) (bool, *v1alpha1.Repository, error) <span class="cov8" title="1">{
        // Support both legacy (URL query) and new (POST body) secret passing
        repository := req.URL.Query().Get("repository")
        branch := req.URL.Query().Get("branch")
        pipelineRun := req.URL.Query().Get("pipelinerun")
        querySecret := req.URL.Query().Get("secret")
        legacyMode := false

        if req.URL.Path != "/incoming" </span><span class="cov8" title="1">{
                return false, nil, nil
        }</span>

        // If not all required query params are present, try to parse from JSON body
        <span class="cov8" title="1">if repository == "" || branch == "" || pipelineRun == "" || querySecret == "" </span><span class="cov8" title="1">{
                if req.Method == http.MethodPost &amp;&amp; req.Header.Get("Content-Type") == "application/json" &amp;&amp; len(payloadBody) &gt; 0 </span><span class="cov8" title="1">{
                        var body struct {
                                Repository  string         `json:"repository"`
                                Branch      string         `json:"branch"`
                                PipelineRun string         `json:"pipelinerun"`
                                Secret      string         `json:"secret"`
                                Params      map[string]any `json:"params"`
                        }
                        if err := json.Unmarshal(payloadBody, &amp;body); err == nil </span><span class="cov8" title="1">{
                                repository = body.Repository
                                branch = body.Branch
                                pipelineRun = body.PipelineRun
                                querySecret = body.Secret
                        }</span> else<span class="cov0" title="0"> {
                                return false, nil, fmt.Errorf("invalid JSON body for incoming webhook: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        return false, nil, fmt.Errorf("missing query URL argument: pipelinerun, branch, repository, secret: '%s' '%s' '%s' '%s'", pipelineRun, branch, repository, querySecret)
                }</span>
        } else<span class="cov8" title="1"> {
                legacyMode = true
        }</span>

        <span class="cov8" title="1">if legacyMode </span><span class="cov8" title="1">{
                l.logger.Warnf("[SECURITY] Incoming webhook used legacy URL-based secret passing. This is insecure and will be deprecated. Please use POST body instead.")
        }</span>

        <span class="cov8" title="1">l.logger.Infof("incoming request has been requested: %v", req.URL)
        if pipelineRun == "" || repository == "" || querySecret == "" || branch == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("missing query URL argument: pipelinerun, branch, repository, secret: '%s' '%s' '%s' '%s'", pipelineRun, branch, repository, querySecret)
                return false, nil, err
        }</span>

        <span class="cov8" title="1">repo, err := matcher.GetRepo(ctx, l.run, repository)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, fmt.Errorf("error getting repo: %w", err)
        }</span>
        <span class="cov8" title="1">if repo == nil </span><span class="cov8" title="1">{
                return false, nil, fmt.Errorf("cannot find repository %s", repository)
        }</span>

        <span class="cov8" title="1">if repo.Spec.Incomings == nil </span><span class="cov8" title="1">{
                return false, nil, fmt.Errorf("you need to have incoming webhooks rules in your repo spec, repo: %s", repository)
        }</span>

        <span class="cov8" title="1">hook := matcher.IncomingWebhookRule(branch, *repo.Spec.Incomings)
        if hook == nil </span><span class="cov8" title="1">{
                return false, nil, fmt.Errorf("branch '%s' has not matched any rules in repo incoming webhooks spec: %+v", branch, *repo.Spec.Incomings)
        }</span>

        // log incoming request
        <span class="cov8" title="1">l.logger.Infof("incoming request targeting pipelinerun %s on branch %s for repository %s has been accepted", pipelineRun, branch, repository)

        secretOpts := ktypes.GetSecretOpt{
                Namespace: repo.Namespace,
                Name:      hook.Secret.Name,
                Key:       hook.Secret.Key,
        }
        secretValue, err := l.kint.GetSecret(ctx, secretOpts)
        if err != nil </span><span class="cov8" title="1">{
                return false, nil, fmt.Errorf("error getting secret referenced in incoming-webhook: %w", err)
        }</span>
        <span class="cov8" title="1">if secretValue == "" </span><span class="cov8" title="1">{
                return false, nil, fmt.Errorf("secret referenced in incoming-webhook %s is empty or key %s is not existent", hook.Secret.Name, hook.Secret.Key)
        }</span>

        // TODO: move to somewhere common to share between gitlab and here
        <span class="cov8" title="1">if !compareSecret(querySecret, secretValue) </span><span class="cov8" title="1">{
                return false, nil, fmt.Errorf("secret passed to the webhook does not match the incoming webhook secret set on repository CR in secret %s", hook.Secret.Name)
        }</span>

        <span class="cov8" title="1">if repo.Spec.GitProvider == nil || repo.Spec.GitProvider.Type == "" </span><span class="cov8" title="1">{
                gh := github.New()
                gh.Run = l.run
                ns := info.GetNS(ctx)
                ip := app.NewInstallation(req, l.run, repo, gh, ns)
                enterpriseURL, token, installationID, err := ip.GetAndUpdateInstallationID(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">l.event.Provider.URL = enterpriseURL
                l.event.Provider.Token = token
                l.event.InstallationID = installationID
                // Github app is not installed for provided repository url
                if l.event.InstallationID == 0 </span><span class="cov0" title="0">{
                        return false, nil, fmt.Errorf("GithubApp is not installed for the provided repository url %s ", repo.Spec.URL)
                }</span>
        }

        // make sure accepted is json
        <span class="cov8" title="1">if string(payloadBody) != "" </span><span class="cov8" title="1">{
                if l.event.Event, err = applyIncomingParams(req, payloadBody, hook.Params); err != nil </span><span class="cov8" title="1">{
                        return false, nil, err
                }</span>
        }

        // TODO: more than i think about it and more i think triggertarget should be
        // eventType and vice versa, but keeping as is for now.
        <span class="cov8" title="1">l.event.EventType = "incoming"
        l.event.TriggerTarget = "push"
        l.event.TargetPipelineRun = pipelineRun
        l.event.HeadBranch = branch
        l.event.BaseBranch = branch
        l.event.Request.Header = req.Header
        l.event.Request.Payload = payloadBody
        l.event.URL = repo.Spec.URL
        l.event.Sender = "incoming"
        return true, repo, nil</span>
}

func (l *listener) processIncoming(targetRepo *v1alpha1.Repository) (provider.Interface, *zap.SugaredLogger, error) <span class="cov8" title="1">{
        // can a git ssh URL be a Repo URL? I don't think this will even ever work
        org, repo, err := formatting.GetRepoOwnerSplitted(targetRepo.Spec.URL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">l.event.Organization = org
        l.event.Repository = repo

        var provider provider.Interface
        if targetRepo.Spec.GitProvider == nil || targetRepo.Spec.GitProvider.Type == "" </span><span class="cov8" title="1">{
                provider = github.New()
        }</span> else<span class="cov8" title="1"> {
                switch targetRepo.Spec.GitProvider.Type </span>{
                case "github":<span class="cov8" title="1">
                        provider = github.New()</span>
                case "gitlab":<span class="cov8" title="1">
                        provider = &amp;gitlab.Provider{}</span>
                case "gitea":<span class="cov8" title="1">
                        provider = &amp;gitea.Provider{}</span>
                case "bitbucket-cloud":<span class="cov8" title="1">
                        provider = &amp;bitbucketcloud.Provider{}</span>
                case "bitbucket-datacenter":<span class="cov8" title="1">
                        provider = &amp;bitbucketdatacenter.Provider{}</span>
                default:<span class="cov8" title="1">
                        return l.processRes(false, nil, l.logger.With("namespace", targetRepo.Namespace), "", fmt.Errorf("no supported Git provider has been detected"))</span>
                }
        }

        <span class="cov8" title="1">return l.processRes(true, provider, l.logger.With("provider", "incoming", "namespace", targetRepo.Namespace), "", nil)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package adapter

import (
        "bytes"
        "context"
        "net/http"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "go.uber.org/zap"
)

type sinker struct {
        run        *params.Run
        vcx        provider.Interface
        kint       kubeinteraction.Interface
        event      *info.Event
        logger     *zap.SugaredLogger
        payload    []byte
        pacInfo    *info.PacOpts
        globalRepo *v1alpha1.Repository
}

func (s *sinker) processEventPayload(ctx context.Context, request *http.Request) error <span class="cov8" title="1">{
        var err error
        s.event, err = s.vcx.ParsePayload(ctx, s.run, request, string(s.payload))
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Errorf("failed to parse event: %v", err)
                return err
        }</span>

        // Enhanced structured logging with source repository context for operators
        <span class="cov0" title="0">logFields := []interface{}{
                "event-sha", s.event.SHA,
                "event-type", s.event.EventType,
                "source-repo-url", s.event.URL,
        }

        // Add branch information if available
        if s.event.BaseBranch != "" </span><span class="cov0" title="0">{
                logFields = append(logFields, "target-branch", s.event.BaseBranch)
        }</span>
        // For PRs, also include source branch if different
        <span class="cov0" title="0">if s.event.HeadBranch != "" &amp;&amp; s.event.HeadBranch != s.event.BaseBranch </span><span class="cov0" title="0">{
                logFields = append(logFields, "source-branch", s.event.HeadBranch)
        }</span>

        <span class="cov0" title="0">s.logger = s.logger.With(logFields...)
        s.vcx.SetLogger(s.logger)

        s.event.Request = &amp;info.Request{
                Header:  request.Header,
                Payload: bytes.TrimSpace(s.payload),
        }
        return nil</span>
}

func (s *sinker) processEvent(ctx context.Context, request *http.Request) error <span class="cov8" title="1">{
        if s.event.EventType == "incoming" </span><span class="cov0" title="0">{
                if request.Header.Get("X-GitHub-Enterprise-Host") != "" </span><span class="cov0" title="0">{
                        s.event.Provider.URL = request.Header.Get("X-GitHub-Enterprise-Host")
                        s.event.GHEURL = request.Header.Get("X-GitHub-Enterprise-Host")
                }</span>
        } else<span class="cov8" title="1"> {
                if err := s.processEventPayload(ctx, request); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">p := pipelineascode.NewPacs(s.event, s.vcx, s.run, s.pacInfo, s.kint, s.logger, s.globalRepo)
        return p.Run(ctx)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package adapter

import (
        "context"
        "os"
        "path/filepath"

        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/system"
)

const tlsMountPath = "/etc/pipelines-as-code/tls"

// isTLSEnabled validates if tls secret exist and if the required fields are defined
// this is used to enable tls on the listener.
func (l listener) isTLSEnabled() (bool, string, string) <span class="cov8" title="1">{
        tlsSecret := os.Getenv("TLS_SECRET_NAME")
        tlsKey := os.Getenv("TLS_KEY")
        tlsCert := os.Getenv("TLS_CERT")

        // TODO: Should we make different TLS by controller?
        tls, err := l.run.Clients.Kube.CoreV1().Secrets(system.Namespace()).
                Get(context.Background(), tlsSecret, v1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return false, "", ""
        }</span>
        <span class="cov8" title="1">_, ok := tls.Data[tlsKey]
        if !ok </span><span class="cov8" title="1">{
                return false, "", ""
        }</span>
        <span class="cov8" title="1">_, ok = tls.Data[tlsCert]
        if !ok </span><span class="cov0" title="0">{
                return false, "", ""
        }</span>

        <span class="cov8" title="1">return true,
                filepath.Join(tlsMountPath, tlsCert),
                filepath.Join(tlsMountPath, tlsKey)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package incoming

import "encoding/json"

type (
        Params  map[string]any
        Payload struct {
                Params Params `json:"params"`
        }
)

// ParseIncomingPayload parses the payload from the incoming webhook, in json format and has only one key params.
func ParseIncomingPayload(payload []byte) (Payload, error) <span class="cov8" title="1">{
        var incomingPayload Payload
        err := json.Unmarshal(payload, &amp;incomingPayload)
        if err != nil </span><span class="cov8" title="1">{
                return Payload{}, err
        }</span>
        <span class="cov8" title="1">return incomingPayload, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2021 Red Hat

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects.
var SchemeGroupVersion = schema.GroupVersion{Group: pipelinesascode.GroupName, Version: "v1alpha1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind.
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource.
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        // SchemeBuilder initializes a scheme builder.
        SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
        // AddToScheme is a global function that registers this API group &amp; version to a scheme.
        AddToScheme = SchemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov0" title="0">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;Repository{},
                &amp;RepositoryList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Repository is the representation of a Git repository from a Git provider platform.
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Namespaced,shortName=repo
// +kubebuilder:printcolumn:name="URL",type=string,JSONPath=`.spec.url`
// +kubebuilder:printcolumn:name="Succeeded",type=string,JSONPath=`.pipelinerun_status[-1].conditions[?(@.type=="Succeeded")].status`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.pipelinerun_status[-1].conditions[?(@.type=="Succeeded")].reason`
// +kubebuilder:printcolumn:name="StartTime",type=date,JSONPath=`.pipelinerun_status[-1].startTime`
// +kubebuilder:printcolumn:name="CompletionTime",type=date,JSONPath=`.pipelinerun_status[-1].completionTime`
type Repository struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   RepositorySpec        `json:"spec"`
        Status []RepositoryRunStatus `json:"pipelinerun_status,omitempty"`
}

type RepositoryRunStatus struct {
        duckv1.Status `json:",inline"`

        // PipelineRunName is the name of the PipelineRun
        // +optional
        PipelineRunName string `json:"pipelineRunName,omitempty"`

        // StartTime is the time the PipelineRun is actually started.
        // +optional
        StartTime *metav1.Time `json:"startTime,omitempty"`

        // CompletionTime is the time the PipelineRun completed.
        // +optional
        CompletionTime *metav1.Time `json:"completionTime,omitempty"`

        // SHA is the name of the SHA that has been tested
        // +optional
        SHA *string `json:"sha,omitempty"`

        // SHA the URL of the SHA to view it
        // +optional
        SHAURL *string `json:"sha_url,omitempty"`

        // Title is the title of the commit SHA that has been tested
        // +optional
        Title *string `json:"title,omitempty"`

        // LogURL is the full URL to the log for this run.
        // +optional
        LogURL *string `json:"logurl,omitempty"`

        // TargetBranch is the target branch of that run
        // +optional
        TargetBranch *string `json:"target_branch,omitempty"`

        // EventType is the event type of that run
        // +optional
        EventType *string `json:"event_type,omitempty"`

        // CollectedTaskInfos is the information about tasks
        CollectedTaskInfos *map[string]TaskInfos `json:"failure_reason,omitempty"`
}

// TaskInfos contains information about a task.
type TaskInfos struct {
        Name           string       `json:"name"`
        Message        string       `json:"message,omitempty"`
        LogSnippet     string       `json:"log_snippet,omitempty"`
        Reason         string       `json:"reason,omitempty"`
        DisplayName    string       `json:"display_name,omitempty"`
        CompletionTime *metav1.Time `json:"completion_time,omitempty"`
}

// RepositorySpec defines the desired state of a Repository, including its URL,
// Git provider configuration, and operational settings.
type RepositorySpec struct {
        // ConcurrencyLimit defines the maximum number of concurrent pipelineruns that can
        // run for this repository. This helps prevent resource exhaustion when many events trigger
        // pipelines simultaneously.
        // +optional
        // +kubebuilder:validation:Minimum=1
        ConcurrencyLimit *int `json:"concurrency_limit,omitempty"` // move it to settings in further version of the spec

        // URL of the repository we are building. Must be a valid HTTP/HTTPS Git repository URL
        // that PAC will use to clone and fetch pipeline definitions from.
        // +optional
        URL string `json:"url"`

        // GitProvider details specific to a git provider configuration. Contains authentication,
        // API endpoints, and provider type information needed to interact with the Git service.
        // +optional
        GitProvider *GitProvider `json:"git_provider,omitempty"`

        // Incomings defines incoming webhook configurations. Each configuration specifies how to
        // handle external webhook requests that don't come directly from the primary Git provider.
        // +optional
        Incomings *[]Incoming `json:"incoming,omitempty"`

        // Params defines repository level parameters that can be referenced in PipelineRuns.
        // These parameters can be used as default values or configured for specific events.
        // +optional
        Params *[]Params `json:"params,omitempty"`

        // Settings contains the configuration settings for the repository, including
        // authorization policies, provider-specific configuration, and provenance settings.
        // +optional
        Settings *Settings `json:"settings,omitempty"`
}

func (r *RepositorySpec) Merge(newRepo RepositorySpec) <span class="cov8" title="1">{
        if newRepo.ConcurrencyLimit != nil &amp;&amp; r.ConcurrencyLimit == nil </span><span class="cov8" title="1">{
                r.ConcurrencyLimit = newRepo.ConcurrencyLimit
        }</span>
        <span class="cov8" title="1">if newRepo.Settings != nil &amp;&amp; r.Settings != nil </span><span class="cov8" title="1">{
                r.Settings.Merge(newRepo.Settings)
        }</span>
        <span class="cov8" title="1">if r.GitProvider != nil &amp;&amp; newRepo.GitProvider != nil </span><span class="cov8" title="1">{
                r.GitProvider.Merge(newRepo.GitProvider)
        }</span>

        // TODO(chmouel): maybe let it merges those between the user Repo Incomings and Params with the global ones?
        // we need to gather feedback first with users to know what they want.
        <span class="cov8" title="1">if newRepo.Incomings != nil &amp;&amp; r.Incomings == nil </span><span class="cov8" title="1">{
                r.Incomings = newRepo.Incomings
        }</span>
        <span class="cov8" title="1">if newRepo.Params != nil &amp;&amp; r.Params == nil </span><span class="cov8" title="1">{
                r.Params = newRepo.Params
        }</span>
}

type Settings struct {
        // GithubAppTokenScopeRepos lists repositories that can access the GitHub App token when using the
        // GitHub App authentication method. This allows specific repositories to use tokens generated for
        // the GitHub App installation, useful for cross-repository access.
        // +optional
        GithubAppTokenScopeRepos []string `json:"github_app_token_scope_repos,omitempty"`

        // PipelineRunProvenance configures how PipelineRun definitions are fetched.
        // Options:
        // - 'source': Fetch definitions from the event source branch/SHA (default)
        // - 'default_branch': Fetch definitions from the repository default branch
        // +optional
        // +kubebuilder:validation:Enum=source;default_branch
        PipelineRunProvenance string `json:"pipelinerun_provenance,omitempty"`

        // Policy defines authorization policies for the repository, controlling who can
        // trigger PipelineRuns under different conditions.
        // +optional
        Policy *Policy `json:"policy,omitempty"`

        // Gitlab contains GitLab-specific settings for repositories hosted on GitLab.
        // +optional
        Gitlab *GitlabSettings `json:"gitlab,omitempty"`

        Github *GithubSettings `json:"github,omitempty"`
}

type GitlabSettings struct {
        // CommentStrategy defines how GitLab comments are handled for pipeline results.
        // Options:
        // - 'disable_all': Disables all comments on merge requests
        // +optional
        // +kubebuilder:validation:Enum="";disable_all
        CommentStrategy string `json:"comment_strategy,omitempty"`
}

type GithubSettings struct {
        // CommentStrategy defines how GitLab comments are handled for pipeline results.
        // Options:
        // - 'disable_all': Disables all comments on merge requests
        // +optional
        // +kubebuilder:validation:Enum="";disable_all
        CommentStrategy string `json:"comment_strategy,omitempty"`
}

func (s *Settings) Merge(newSettings *Settings) <span class="cov8" title="1">{
        if newSettings.PipelineRunProvenance != "" &amp;&amp; s.PipelineRunProvenance == "" </span><span class="cov8" title="1">{
                s.PipelineRunProvenance = newSettings.PipelineRunProvenance
        }</span>
        <span class="cov8" title="1">if newSettings.Policy != nil &amp;&amp; s.Policy == nil </span><span class="cov8" title="1">{
                s.Policy = newSettings.Policy
        }</span>
        <span class="cov8" title="1">if newSettings.GithubAppTokenScopeRepos != nil &amp;&amp; s.GithubAppTokenScopeRepos == nil </span><span class="cov8" title="1">{
                s.GithubAppTokenScopeRepos = newSettings.GithubAppTokenScopeRepos
        }</span>
}

type Policy struct {
        // OkToTest defines a list of usernames that are allowed to trigger pipeline runs on pull requests
        // from external contributors by commenting "/ok-to-test" on the PR. These users are typically
        // repository maintainers or trusted contributors who can vouch for external contributions.
        // +optional
        OkToTest []string `json:"ok_to_test,omitempty"`

        // PullRequest defines a list of usernames that are explicitly allowed to execute
        // pipelines on their pull requests, even if they wouldn't normally have permission.
        // This is useful for allowing specific external contributors to trigger pipeline runs.
        // +optional
        PullRequest []string `json:"pull_request,omitempty"`
}

type Params struct {
        // Name of the parameter. This is the key that will be used to reference this parameter
        // in PipelineRun definitions through via the {{ name }} syntax.
        // +kubebuilder:validation:Required
        Name string `json:"name"`

        // Value of the parameter. The literal value to be provided to the PipelineRun.
        // This field is mutually exclusive with SecretRef.
        // +optional
        Value string `json:"value,omitempty"`

        // SecretRef references a secret for the parameter value. Use this when the parameter
        // contains sensitive information that should not be stored directly in the Repository CR.
        // This field is mutually exclusive with Value.
        // +optional
        SecretRef *Secret `json:"secret_ref,omitempty"`

        // Filter defines when this parameter applies. It can be used to conditionally
        // apply parameters based on the event type, branch name, or other attributes.
        // +optional
        Filter string `json:"filter,omitempty"`
}

type Incoming struct {
        // Type of the incoming webhook. Currently only 'webhook-url' is supported, which allows
        // external systems to trigger PipelineRuns via generic webhook requests.
        // +kubebuilder:validation:Required
        // +kubebuilder:validation:Enum=webhook-url
        Type string `json:"type"`

        // Secret for the incoming webhook authentication. This secret is used to validate
        // that webhook requests are coming from authorized sources.
        // +kubebuilder:validation:Required
        Secret Secret `json:"secret"`

        // Params defines parameter names to extract from the webhook payload. These parameters
        // will be made available to the PipelineRuns triggered by this webhook.
        // +optional
        Params []string `json:"params,omitempty"`

        // Targets defines target branches for this webhook. When specified, only webhook
        // events targeting these branches will trigger PipelineRuns.
        // +optional
        Targets []string `json:"targets,omitempty"`
}

type GitProvider struct {
        // URL of the git provider API endpoint. This is the base URL for API requests to the
        // Git provider (e.g., 'https://api.github.com' for GitHub or a custom GitLab instance URL).
        // +optional
        URL string `json:"url,omitempty"`

        // User of the git provider. Username to use for authentication when using basic auth
        // or token-based authentication methods. Not used for GitHub Apps authentication.
        // +optional
        User string `json:"user,omitempty"`

        // Secret reference for authentication with the Git provider. Contains the token,
        // password, or private key used to authenticate requests to the Git provider API.
        // +optional
        Secret *Secret `json:"secret,omitempty"`

        // WebhookSecret reference for webhook validation. Contains the shared secret used to
        // validate that incoming webhooks are legitimate and coming from the Git provider.
        // +optional
        WebhookSecret *Secret `json:"webhook_secret,omitempty"`

        // Type of git provider. Determines which Git provider API and authentication flow to use.
        // Supported values:
        // - 'github': GitHub.com or GitHub Enterprise
        // - 'gitlab': GitLab.com or self-hosted GitLab
        // - 'bitbucket-datacenter': Bitbucket Data Center (self-hosted)
        // - 'bitbucket-cloud': Bitbucket Cloud (bitbucket.org)
        // - 'gitea': Gitea instances
        // +optional
        // +kubebuilder:validation:Enum=github;gitlab;bitbucket-datacenter;bitbucket-cloud;gitea
        Type string `json:"type,omitempty"`
}

func (g *GitProvider) Merge(newGitProvider *GitProvider) <span class="cov8" title="1">{
        // only merge of the same type
        if newGitProvider.Type != "" &amp;&amp; g.Type != "" &amp;&amp; g.Type != newGitProvider.Type </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if newGitProvider.URL != "" &amp;&amp; g.URL == "" </span><span class="cov8" title="1">{
                g.URL = newGitProvider.URL
        }</span>
        <span class="cov8" title="1">if newGitProvider.User != "" &amp;&amp; g.User == "" </span><span class="cov8" title="1">{
                g.User = newGitProvider.User
        }</span>
        <span class="cov8" title="1">if newGitProvider.Type != "" &amp;&amp; g.Type == "" </span><span class="cov8" title="1">{
                g.Type = newGitProvider.Type
        }</span>
        <span class="cov8" title="1">if newGitProvider.Secret != nil &amp;&amp; g.Secret == nil </span><span class="cov8" title="1">{
                g.Secret = newGitProvider.Secret
        }</span>
        <span class="cov8" title="1">if newGitProvider.WebhookSecret != nil &amp;&amp; g.WebhookSecret == nil </span><span class="cov8" title="1">{
                g.WebhookSecret = newGitProvider.WebhookSecret
        }</span>
}

type Secret struct {
        // Name of the secret
        // +kubebuilder:validation:Required
        Name string `json:"name"`

        // Key in the secret
        // +optional
        Key string `json:"key"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// RepositoryList is the list of Repositories.
// +kubebuilder:object:root=true
type RepositoryList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`

        Items []Repository `json:"items"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package cel

import (
        "encoding/json"
        "fmt"

        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/decls"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
)

func evaluate(expr string, env *cel.Env, data map[string]any) (ref.Val, error) <span class="cov8" title="1">{
        parsed, issues := env.Parse(expr)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse expression %#v: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">checked, issues := env.Check(parsed)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v check failed: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">prg, err := env.Program(checked, cel.EvalOptions(cel.OptOptimize))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v failed to create a Program: %w", expr, err)
        }</span>

        <span class="cov8" title="1">out, _, err := prg.Eval(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v failed to evaluate: %w", expr, err)
        }</span>

        <span class="cov8" title="1">return out, nil</span>
}

// Value evaluates a CEL expression with the given body, headers and
// / pacParams, it will output a Cel value or an error if selectedjm.
func Value(query string, body any, headers, pacParams map[string]string, changedFiles map[string]any) (ref.Val, error) <span class="cov8" title="1">{
        // Marshal/Unmarshal the body to a map[string]any so we can access it from the CEL
        nbody, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var jsonMap map[string]any
        err = json.Unmarshal(nbody, &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mapStrDyn := types.NewMapType(types.StringType, types.DynType)
        celDec, _ := cel.NewEnv(
                cel.VariableDecls(
                        decls.NewVariable("body", mapStrDyn),
                        decls.NewVariable("headers", mapStrDyn),
                        decls.NewVariable("pac", mapStrDyn),
                        decls.NewVariable("files", mapStrDyn),
                        // Direct variables as per documentation
                        decls.NewVariable("event", types.StringType),
                        decls.NewVariable("event_type", types.StringType),
                        decls.NewVariable("target_branch", types.StringType),
                        decls.NewVariable("source_branch", types.StringType),
                        decls.NewVariable("target_url", types.StringType),
                        decls.NewVariable("source_url", types.StringType),
                        decls.NewVariable("event_title", types.StringType),
                        decls.NewVariable("revision", types.StringType),
                        decls.NewVariable("repo_owner", types.StringType),
                        decls.NewVariable("repo_name", types.StringType),
                        decls.NewVariable("sender", types.StringType),
                        decls.NewVariable("repo_url", types.StringType),
                        decls.NewVariable("git_tag", types.StringType),
                        decls.NewVariable("target_namespace", types.StringType),
                        decls.NewVariable("trigger_comment", types.StringType),
                        decls.NewVariable("pull_request_labels", types.StringType),
                        decls.NewVariable("pull_request_number", types.StringType),
                        decls.NewVariable("git_auth_secret", types.StringType),
                ))
        val, err := evaluate(query, celDec, map[string]any{
                "body":    jsonMap,
                "pac":     pacParams,
                "headers": headers,
                "files":   changedFiles,
                // Direct variables - all from pacParams
                "event":               pacParams["event"],
                "event_type":          pacParams["event_type"],
                "target_branch":       pacParams["target_branch"],
                "source_branch":       pacParams["source_branch"],
                "target_url":          pacParams["target_url"],
                "source_url":          pacParams["source_url"],
                "event_title":         pacParams["event_title"],
                "revision":            pacParams["revision"],
                "repo_owner":          pacParams["repo_owner"],
                "repo_name":           pacParams["repo_name"],
                "sender":              pacParams["sender"],
                "repo_url":            pacParams["repo_url"],
                "git_tag":             pacParams["git_tag"],
                "target_namespace":    pacParams["target_namespace"],
                "trigger_comment":     pacParams["trigger_comment"],
                "pull_request_labels": pacParams["pull_request_labels"],
                "pull_request_number": pacParams["pull_request_number"],
                "git_auth_secret":     pacParams["git_auth_secret"],
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return val, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package changedfiles

type ChangedFiles struct {
        All      []string
        Added    []string
        Deleted  []string
        Modified []string
        Renamed  []string
}

// removeDuplicates removes duplicates from a slice of strings.
func removeDuplicates(s []string) []string <span class="cov8" title="1">{
        holdit := make(map[string]struct{})
        result := make([]string, 0, len(s))
        for _, str := range s </span><span class="cov8" title="1">{
                if _, ok := holdit[str]; !ok </span><span class="cov8" title="1">{
                        holdit[str] = struct{}{}
                        result = append(result, str)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

func (c *ChangedFiles) RemoveDuplicates() <span class="cov8" title="1">{
        c.All = removeDuplicates(c.All)
        c.Added = removeDuplicates(c.Added)
        c.Deleted = removeDuplicates(c.Deleted)
        c.Modified = removeDuplicates(c.Modified)
        c.Renamed = removeDuplicates(c.Renamed)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package browser

import (
        "context"
        "os/exec"
        "runtime"
)

// OpenWebBrowser opens the specified URL in the default browser of the user.
func OpenWebBrowser(ctx context.Context, url string) error <span class="cov0" title="0">{
        var cmd string

        args := []string{}
        switch runtime.GOOS </span>{
        case "windows":<span class="cov0" title="0">
                cmd = "cmd"
                args = []string{"/c", "start"}</span>
        case "darwin":<span class="cov0" title="0">
                cmd = "open"</span>
        default:<span class="cov0" title="0"> // "linux", "freebsd", "openbsd", "netbsd"
                cmd = "xdg-open"</span>
        }

        <span class="cov0" title="0">args = append(args, url)
        return exec.CommandContext(ctx, cmd, args...).Start()</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package cli

import (
        "os"

        "github.com/AlecAivazis/survey/v2"
        "github.com/AlecAivazis/survey/v2/terminal"
)

// PacCliOpts is the struct that holds all the options for the CLI
// TODO: Pass this to a context.
type PacCliOpts struct {
        NoColoring    bool
        AllNameSpaces bool
        Namespace     string
        UseRealTime   bool
        AskOpts       survey.AskOpt
        NoHeaders     bool
}

func NewAskopts(opt *survey.AskOptions) error <span class="cov0" title="0">{
        opt.Stdio = terminal.Stdio{
                In:  os.Stdin,
                Out: os.Stdout,
                Err: os.Stderr,
        }
        return nil
}</span>

func NewCliOptions() *PacCliOpts <span class="cov0" title="0">{
        return &amp;PacCliOpts{
                AskOpts: NewAskopts,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package cli

import (
        "fmt"
        "os"
        "strings"

        "github.com/mgutz/ansi"
)

var (
        magenta    = ansi.ColorFunc("magenta")
        cyan       = ansi.ColorFunc("cyan")
        red        = ansi.ColorFunc("red")
        redBold    = ansi.ColorFunc("red+b")
        yellow     = ansi.ColorFunc("yellow")
        blue       = ansi.ColorFunc("blue")
        blueBold   = ansi.ColorFunc("blue+b")
        green      = ansi.ColorFunc("green")
        greenBold  = ansi.ColorFunc("green+b")
        gray       = ansi.ColorFunc("black+i")
        bold       = ansi.ColorFunc("default+b")
        dimmed     = ansi.ColorFunc("246")
        underline  = ansi.ColorFunc("default+u")
        cyanBold   = ansi.ColorFunc("cyan+b")
        orangeBold = ansi.ColorFunc("208")

        gray256 = func(t string) string <span class="cov8" title="1">{
                return fmt.Sprintf("\x1b[%d;5;%dm%s\x1b[m", 38, 242, t)
        }</span>
        hyperLink = func(title, href string) string <span class="cov0" title="0">{
                return fmt.Sprintf("\x1b]8;;%s\x1b\\%s\x1b]8;;\x1b\\", href, title)
        }</span>
)

func EnvColorDisabled() bool <span class="cov8" title="1">{
        return os.Getenv("NO_COLOR") != "" || os.Getenv("CLICOLOR") == "0"
}</span>

func EnvColorForced() bool <span class="cov8" title="1">{
        return os.Getenv("CLICOLOR_FORCE") != "" &amp;&amp; os.Getenv("CLICOLOR_FORCE") != "0"
}</span>

func Is256ColorSupported() bool <span class="cov8" title="1">{
        term := os.Getenv("TERM")
        colorterm := os.Getenv("COLORTERM")

        return strings.Contains(term, "256") ||
                strings.Contains(term, "24bit") ||
                strings.Contains(term, "truecolor") ||
                strings.Contains(colorterm, "256") ||
                strings.Contains(colorterm, "24bit") ||
                strings.Contains(colorterm, "truecolor")
}</span>

func NewColorScheme(enabled, is256enabled bool) *ColorScheme <span class="cov8" title="1">{
        return &amp;ColorScheme{
                enabled:      enabled,
                is256enabled: is256enabled,
        }
}</span>

type ColorScheme struct {
        enabled      bool
        is256enabled bool
}

func (c *ColorScheme) ColorStatus(status string) string <span class="cov8" title="1">{
        switch strings.ToLower(status) </span>{
        case "succeeded":<span class="cov8" title="1">
                return c.Green(status)</span>
        case "failed":<span class="cov8" title="1">
                return c.Red(status)</span>
        case "pipelineruntimeout":<span class="cov8" title="1">
                return c.Yellow("Timeout")</span>
        case "norun":<span class="cov8" title="1">
                return c.Dimmed(status)</span>
        case "running":<span class="cov8" title="1">
                return c.Blue(status)</span>
        }
        <span class="cov0" title="0">return status</span>
}

func (c *ColorScheme) Orange(t string) string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov0" title="0">return orangeBold(t)</span>
}

func (c *ColorScheme) Bold(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return bold(t)</span>
}

func (c *ColorScheme) Dimmed(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return dimmed(t)</span>
}

func (c *ColorScheme) Boldf(t string, args ...any) string <span class="cov0" title="0">{
        return c.Bold(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) Red(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return red(t)</span>
}

func (c *ColorScheme) RedBold(t string) string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov0" title="0">return redBold(t)</span>
}

func (c *ColorScheme) Bullet() string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return " "</span>
}

func (c *ColorScheme) BulletSpace() string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return "  "</span>
}

func (c *ColorScheme) Redf(t string, args ...any) string <span class="cov0" title="0">{
        return c.Red(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) Yellow(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return yellow(t)</span>
}

func (c *ColorScheme) Yellowf(t string, args ...any) string <span class="cov0" title="0">{
        return c.Yellow(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) Green(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return green(t)</span>
}

func (c *ColorScheme) Underline(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return underline(t)</span>
}

func (c *ColorScheme) Greenf(t string, args ...any) string <span class="cov0" title="0">{
        return c.Green(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) Gray(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">if c.is256enabled </span><span class="cov8" title="1">{
                return gray256(t)
        }</span>
        <span class="cov0" title="0">return gray(t)</span>
}

func (c *ColorScheme) Grayf(t string, args ...any) string <span class="cov0" title="0">{
        return c.Gray(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) Magenta(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return magenta(t)</span>
}

func (c *ColorScheme) Magentaf(t string, args ...any) string <span class="cov0" title="0">{
        return c.Magenta(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) Cyan(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return cyan(t)</span>
}

func (c *ColorScheme) Cyanf(t string, args ...any) string <span class="cov0" title="0">{
        return c.Cyan(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) CyanBold(t string) string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov0" title="0">return cyanBold(t)</span>
}

func (c *ColorScheme) Blue(t string) string <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov8" title="1">return blue(t)</span>
}

func (c *ColorScheme) BlueBold(t string) string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return t
        }</span>
        <span class="cov0" title="0">return blueBold(t)</span>
}

func (c *ColorScheme) Bluef(t string, args ...any) string <span class="cov0" title="0">{
        return c.Blue(fmt.Sprintf(t, args...))
}</span>

func (c *ColorScheme) SuccessIcon() string <span class="cov0" title="0">{
        return c.SuccessIconWithColor(c.Green)
}</span>

func (c *ColorScheme) InfoIcon() string <span class="cov0" title="0">{
        return c.BlueBold("")
}</span>

func (c *ColorScheme) SuccessIconWithColor(colo func(string) string) string <span class="cov0" title="0">{
        return colo("")
}</span>

func (c *ColorScheme) WarningIcon() string <span class="cov0" title="0">{
        return c.Yellow("!")
}</span>

func (c *ColorScheme) FailureIcon() string <span class="cov0" title="0">{
        return c.FailureIconWithColor(c.Red)
}</span>

func (c *ColorScheme) FailureIconWithColor(colo func(string) string) string <span class="cov0" title="0">{
        return colo("X")
}</span>

func (c *ColorScheme) ColorFromString(s string) func(string) string <span class="cov0" title="0">{
        s = strings.ToLower(s)
        var fn func(string) string
        switch s </span>{
        case "bold":<span class="cov0" title="0">
                fn = c.Bold</span>
        case "red":<span class="cov0" title="0">
                fn = c.Red</span>
        case "yellow":<span class="cov0" title="0">
                fn = c.Yellow</span>
        case "green":<span class="cov0" title="0">
                fn = c.Green</span>
        case "gray":<span class="cov0" title="0">
                fn = c.Gray</span>
        case "magenta":<span class="cov0" title="0">
                fn = c.Magenta</span>
        case "cyan":<span class="cov0" title="0">
                fn = c.Cyan</span>
        case "blue":<span class="cov0" title="0">
                fn = c.Blue</span>
        default:<span class="cov0" title="0">
                fn = func(s string) string </span><span class="cov0" title="0">{
                        return s
                }</span>
        }

        <span class="cov0" title="0">return fn</span>
}

func (c *ColorScheme) GreenBold(s string) string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return greenBold(s)</span>
}

func (c *ColorScheme) HyperLink(title, href string) string <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return title
        }</span>
        <span class="cov0" title="0">return hyperLink(title, href)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package info

import (
        "context"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const infoConfigMap = "pipelines-as-code-info"

type Options struct {
        TargetNamespace string
        ControllerURL   string
        Provider        string
}

func IsGithubAppInstalled(ctx context.Context, run *params.Run, targetNamespace string) bool <span class="cov8" title="1">{
        if _, err := run.Clients.Kube.CoreV1().Secrets(targetNamespace).Get(ctx, info.DefaultPipelinesAscodeSecretName, metav1.GetOptions{}); err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func GetPACInfo(ctx context.Context, run *params.Run, targetNamespace string) (*Options, error) <span class="cov8" title="1">{
        cm, err := run.Clients.Kube.CoreV1().ConfigMaps(targetNamespace).Get(ctx, infoConfigMap, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Options{
                ControllerURL: cm.Data["controller-url"],
                Provider:      cm.Data["provider"],
        }, nil</span>
}

func UpdateInfoConfigMap(ctx context.Context, run *params.Run, opts *Options) error <span class="cov8" title="1">{
        cm, err := run.Clients.Kube.CoreV1().ConfigMaps(opts.TargetNamespace).Get(ctx, infoConfigMap, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">cm.Data["controller-url"] = opts.ControllerURL
        cm.Data["provider"] = opts.Provider

        // the user will have read access to configmap
        // but it might be the case, user is not admin and don't have access to update
        // so don't error out, continue with printing a warning
        _, err = run.Clients.Kube.CoreV1().ConfigMaps(opts.TargetNamespace).Update(ctx, cm, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                run.Clients.Log.Warnf("failed to update pipelines-as-code-info configmap: %v", err)
                return nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package cli

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "runtime"

        surveyCore "github.com/AlecAivazis/survey/v2/core"
        "github.com/mattn/go-colorable"
        "github.com/mattn/go-isatty"
        "github.com/mgutz/ansi"
)

type IOStreams struct {
        In     io.ReadCloser
        Out    io.Writer
        ErrOut io.Writer

        colorEnabled             bool
        progressIndicatorEnabled bool
        stdoutTTYOverride        bool
        stderrTTYOverride        bool
        stderrIsTTY              bool
        stdoutIsTTY              bool
        is256enabled             bool
}

func (s *IOStreams) ColorScheme() *ColorScheme <span class="cov0" title="0">{
        return NewColorScheme(s.ColorEnabled(), s.ColorSupport256())
}</span>

func (s *IOStreams) ColorEnabled() bool <span class="cov8" title="1">{
        return s.colorEnabled
}</span>

func (s *IOStreams) SetColorEnabled(colorEnabled bool) <span class="cov8" title="1">{
        s.colorEnabled = colorEnabled
        s.setSurveyColor()
        s.progressIndicatorEnabled = colorEnabled
}</span>

func (s *IOStreams) setSurveyColor() <span class="cov8" title="1">{
        if !s.colorEnabled </span><span class="cov8" title="1">{
                surveyCore.DisableColor = true
        }</span> else<span class="cov0" title="0"> {
                // override survey's poor choice of color
                surveyCore.TemplateFuncsWithColor["color"] = func(style string) string </span><span class="cov0" title="0">{
                        switch style </span>{
                        case "white":<span class="cov0" title="0">
                                if s.ColorSupport256() </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("\x1b[%d;5;%dm", 38, 242)
                                }</span>
                                <span class="cov0" title="0">return ansi.ColorCode("default")</span>
                        default:<span class="cov0" title="0">
                                return ansi.ColorCode(style)</span>
                        }
                }
        }
}

func (s *IOStreams) ColorSupport256() bool <span class="cov8" title="1">{
        return s.is256enabled
}</span>

func NewIOStreams() *IOStreams <span class="cov8" title="1">{
        stdoutIsTTY := isTerminal(os.Stdout)
        stderrIsTTY := isTerminal(os.Stderr)

        ios := &amp;IOStreams{
                In:           os.Stdin,
                Out:          colorable.NewColorable(os.Stdout),
                ErrOut:       colorable.NewColorable(os.Stderr),
                colorEnabled: EnvColorForced() || (!EnvColorDisabled() &amp;&amp; stdoutIsTTY),
                is256enabled: Is256ColorSupported(),
        }

        // the colours are not working on windows, let's disable it
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                ios.colorEnabled = false
        }</span>

        <span class="cov8" title="1">if stdoutIsTTY &amp;&amp; stderrIsTTY </span><span class="cov0" title="0">{
                ios.progressIndicatorEnabled = true
        }</span>

        <span class="cov8" title="1">ios.setSurveyColor()

        // prevent duplicate isTerminal queries now that we know the answer
        ios.SetStdoutTTY(stdoutIsTTY)
        ios.SetStderrTTY(stderrIsTTY)
        return ios</span>
}

func (s *IOStreams) SetStdoutTTY(isTTY bool) <span class="cov8" title="1">{
        s.stdoutTTYOverride = true
        s.stdoutIsTTY = isTTY
}</span>

func (s *IOStreams) SetStderrTTY(isTTY bool) <span class="cov8" title="1">{
        s.stderrTTYOverride = true
        s.stderrIsTTY = isTTY
}</span>

func (s *IOStreams) IsStdoutTTY() bool <span class="cov8" title="1">{
        if s.stdoutTTYOverride </span><span class="cov8" title="1">{
                return s.stdoutIsTTY
        }</span>
        <span class="cov8" title="1">if stdout, ok := s.Out.(*os.File); ok </span><span class="cov8" title="1">{
                return isTerminal(stdout)
        }</span>
        <span class="cov0" title="0">return false</span>
}

func isTerminal(f *os.File) bool <span class="cov8" title="1">{
        return isatty.IsTerminal(f.Fd()) || isatty.IsCygwinTerminal(f.Fd())
}</span>

func IOTest() (*IOStreams, *bytes.Buffer, *bytes.Buffer, *bytes.Buffer) <span class="cov8" title="1">{
        in := &amp;bytes.Buffer{}
        out := &amp;bytes.Buffer{}
        errOut := &amp;bytes.Buffer{}
        return &amp;IOStreams{
                In:     io.NopCloser(in),
                Out:    out,
                ErrOut: errOut,
        }, in, out, errOut
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package prompt

import (
        "context"
        "fmt"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func SelectRepo(ctx context.Context, cs *params.Run, namespace string) (*v1alpha1.Repository, error) <span class="cov8" title="1">{
        repositories, err := cs.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(namespace).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(repositories.Items) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no repo found")
        }</span>
        <span class="cov8" title="1">if len(repositories.Items) == 1 </span><span class="cov8" title="1">{
                return &amp;repositories.Items[0], nil
        }</span>

        <span class="cov8" title="1">allRepositories := []string{}
        for _, repository := range repositories.Items </span><span class="cov8" title="1">{
                repoOwner, err := formatting.GetRepoOwnerFromURL(repository.Spec.URL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">allRepositories = append(allRepositories,
                        fmt.Sprintf("%s - %s",
                                repository.GetName(),
                                repoOwner))</span>
        }

        <span class="cov8" title="1">var replyString string
        if err := SurveyAskOne(&amp;survey.Select{
                Message: "Select a repository",
                Options: allRepositories,
        }, &amp;replyString); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if replyString == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("you need to choose a repository")
        }</span>
        <span class="cov8" title="1">replyName := strings.Fields(replyString)[0]

        for _, repository := range repositories.Items </span><span class="cov8" title="1">{
                if repository.GetName() == replyName </span><span class="cov8" title="1">{
                        return &amp;repository, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("cannot match repository")</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package prompt

import (
        "fmt"
        "reflect"

        "github.com/AlecAivazis/survey/v2"
        "github.com/AlecAivazis/survey/v2/core"
)

type AskStubber struct {
        Asks     [][]*survey.Question
        AskOnes  []*survey.Prompt
        Count    int
        OneCount int
        Stubs    [][]*QuestionStub
        StubOnes []*StubPrompt
}

func InitAskStubber() (*AskStubber, func()) <span class="cov8" title="1">{
        origSurveyAsk := SurveyAsk
        origSurveyAskOne := SurveyAskOne
        as := AskStubber{}

        SurveyAskOne = func(p survey.Prompt, response any, _ ...survey.AskOpt) error </span><span class="cov8" title="1">{
                as.AskOnes = append(as.AskOnes, &amp;p)
                count := as.OneCount
                as.OneCount++
                if count &gt;= len(as.StubOnes) </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("more asks than stubs. most recent call: %v", p))</span>
                }
                <span class="cov8" title="1">stubbedPrompt := as.StubOnes[count]
                if stubbedPrompt.Default </span><span class="cov0" title="0">{
                        // TODO this is failing for basic AskOne invocations with a string result.
                        defaultValue := reflect.ValueOf(p).Elem().FieldByName("Default")
                        _ = core.WriteAnswer(response, "", defaultValue)
                }</span> else<span class="cov8" title="1"> {
                        _ = core.WriteAnswer(response, "", stubbedPrompt.Value)
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">teardown := func() </span><span class="cov8" title="1">{
                SurveyAsk = origSurveyAsk
                SurveyAskOne = origSurveyAskOne
        }</span>
        <span class="cov8" title="1">return &amp;as, teardown</span>
}

type StubPrompt struct {
        Value   any
        Default bool
}

type QuestionStub struct {
        Name    string
        Value   any
        Default bool
}

func (as *AskStubber) StubOne(value any) <span class="cov8" title="1">{
        as.StubOnes = append(as.StubOnes, &amp;StubPrompt{
                Value: value,
        })
}</span>

func (as *AskStubber) StubOneDefault() <span class="cov0" title="0">{
        as.StubOnes = append(as.StubOnes, &amp;StubPrompt{
                Default: true,
        })
}</span>

func (as *AskStubber) Stub(stubbedQuestions []*QuestionStub) <span class="cov0" title="0">{
        // A call to .Ask takes a list of questions; a stub is then a list of questions in the same order.
        as.Stubs = append(as.Stubs, stubbedQuestions)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package status

import (
        "context"
        "regexp"

        "github.com/google/go-github/v74/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        pacv1alpha1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        kstatus "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/status"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        sortrepostatus "github.com/openshift-pipelines/pipelines-as-code/pkg/sort"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// snatched from prow
// https://github.com/kubernetes/test-infra/blob/3c8cbed65c421670a7d37239b8ffceb91e0eb16b/prow/spyglass/lenses/buildlog/lens.go#L95
var (
        ErorrRE                                       = regexp.MustCompile(`timed out|ERROR:|(FAIL|Failure \[)\b|panic\b|^E\d{4} \d\d:\d\d:\d\d\.\d\d\d]`)
        defaultNumLinesOfLogsInContainersToGrabForErr = int64(10)
)

// RepositoryRunStatusRemoveSameSHA remove an existing status with the same
// SHA. This would come from repo pipelinerun_status. We don't want the doublons
// and we rather use the ones from the live PR on cluster.
func RepositoryRunStatusRemoveSameSHA(rs []pacv1alpha1.RepositoryRunStatus, livePrSHA string) []pacv1alpha1.RepositoryRunStatus <span class="cov8" title="1">{
        newRepositoryStatus := []pacv1alpha1.RepositoryRunStatus{}
        for _, value := range rs </span><span class="cov8" title="1">{
                if value.SHA != nil &amp;&amp; *value.SHA == livePrSHA </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">newRepositoryStatus = append(newRepositoryStatus, value)</span>
        }
        <span class="cov8" title="1">return newRepositoryStatus</span>
}

func convertPrStatusToRepositoryStatus(ctx context.Context, cs *params.Run, pr tektonv1.PipelineRun, logurl string) pacv1alpha1.RepositoryRunStatus <span class="cov8" title="1">{
        kinteract, _ := kubeinteraction.NewKubernetesInteraction(cs)
        failurereasons := kstatus.CollectFailedTasksLogSnippet(ctx, cs, kinteract, &amp;pr, defaultNumLinesOfLogsInContainersToGrabForErr)
        prSHA := pr.GetAnnotations()[keys.SHA]
        return pacv1alpha1.RepositoryRunStatus{
                Status:             pr.Status.Status,
                LogURL:             &amp;logurl,
                PipelineRunName:    pr.GetName(),
                CollectedTaskInfos: &amp;failurereasons,
                StartTime:          pr.Status.StartTime,
                SHA:                github.Ptr(prSHA),
                SHAURL:             github.Ptr(pr.GetAnnotations()[keys.ShaURL]),
                Title:              github.Ptr(pr.GetAnnotations()[keys.ShaTitle]),
                TargetBranch:       github.Ptr(pr.GetAnnotations()[keys.Branch]),
                EventType:          github.Ptr(pr.GetAnnotations()[keys.EventType]),
        }
}</span>

func MixLivePRandRepoStatus(ctx context.Context, cs *params.Run, repository pacv1alpha1.Repository) []pacv1alpha1.RepositoryRunStatus <span class="cov8" title="1">{
        repositorystatus := repository.Status
        label := keys.Repository + "=" + repository.Name
        prs, err := cs.Clients.Tekton.TektonV1().PipelineRuns(repository.Namespace).List(ctx, metav1.ListOptions{
                LabelSelector: label,
        })
        if err != nil </span><span class="cov0" title="0">{
                return sortrepostatus.RepositorySortRunStatus(repositorystatus)
        }</span>

        <span class="cov8" title="1">for i := range prs.Items </span><span class="cov8" title="1">{
                pr := prs.Items[i]
                repositorystatus = RepositoryRunStatusRemoveSameSHA(repositorystatus, pr.GetAnnotations()[keys.SHA])
                logurl := cs.Clients.ConsoleUI().DetailURL(&amp;pr)
                repositorystatus = append(repositorystatus, convertPrStatusToRepositoryStatus(ctx, cs, pr, logurl))
        }</span>
        <span class="cov8" title="1">return sortrepostatus.RepositorySortRunStatus(repositorystatus)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package webhook

import (
        "context"
        "fmt"
        "net/url"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/ktrysmt/go-bitbucket"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli/prompt"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud"
)

type bitbucketCloudConfig struct {
        Client              *bitbucket.Client
        IOStream            *cli.IOStreams
        controllerURL       string
        repoOwner           string
        repoName            string
        personalAccessToken string
        username            string
        APIURL              string
}

func (bb *bitbucketCloudConfig) Run(_ context.Context, opts *Options) (*response, error) <span class="cov0" title="0">{
        err := bb.askBBWebhookConfig(opts.RepositoryURL, opts.ControllerURL, opts.ProviderAPIURL, opts.PersonalAccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;response{
                ControllerURL:       bb.controllerURL,
                PersonalAccessToken: bb.personalAccessToken,
                WebhookSecret:       "",
                APIURL:              bb.APIURL,
                UserName:            bb.username,
        }, bb.create()</span>
}

func (bb *bitbucketCloudConfig) askBBWebhookConfig(repositoryURL, controllerURL, apiURL, personalAccessToken string) error <span class="cov8" title="1">{
        if repositoryURL == "" </span><span class="cov8" title="1">{
                msg := "Please enter the git repository url you want to be configured: "
                if err := prompt.SurveyAskOne(&amp;survey.Input{Message: msg}, &amp;repositoryURL,
                        survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(bb.IOStream.Out, " Setting up Bitbucket Webhook for Repository %s\n", repositoryURL)
        }</span>

        <span class="cov8" title="1">defaultRepo, err := formatting.GetRepoOwnerFromURL(repositoryURL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">repoArr := strings.Split(defaultRepo, "/")
        if len(repoArr) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository, needs to be of format 'org-name/repo-name'")
        }</span>
        <span class="cov8" title="1">bb.repoOwner = repoArr[0]
        bb.repoName = repoArr[1]

        if err := prompt.SurveyAskOne(&amp;survey.Input{
                Message: "Please enter your bitbucket cloud username: ",
        }, &amp;bb.username, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if personalAccessToken == "" </span><span class="cov8" title="1">{
                fmt.Fprintln(bb.IOStream.Out, " You now need to create a Bitbucket Cloud app password, please checkout the docs at https://is.gd/fqMHiJ for the required permissions")
                if err := prompt.SurveyAskOne(&amp;survey.Password{
                        Message: "Please enter the Bitbucket Cloud app password: ",
                }, &amp;bb.personalAccessToken, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                bb.personalAccessToken = personalAccessToken
        }</span>

        <span class="cov8" title="1">bb.controllerURL = controllerURL

        // confirm whether to use the detected url
        if bb.controllerURL != "" </span><span class="cov8" title="1">{
                var answer bool
                fmt.Fprintf(bb.IOStream.Out, " I have detected a controller url: %s\n", bb.controllerURL)
                err := prompt.SurveyAskOne(&amp;survey.Confirm{
                        Message: "Do you want me to use it?",
                        Default: true,
                }, &amp;answer)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !answer </span><span class="cov8" title="1">{
                        bb.controllerURL = ""
                }</span>
        }

        <span class="cov8" title="1">if bb.controllerURL == "" </span><span class="cov8" title="1">{
                if err := prompt.SurveyAskOne(&amp;survey.Input{
                        Message: "Please enter your controller public route URL: ",
                }, &amp;bb.controllerURL, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if apiURL == "" &amp;&amp; !strings.HasPrefix(repositoryURL, "https://bitbucket.org") </span><span class="cov0" title="0">{
                if err := prompt.SurveyAskOne(&amp;survey.Input{
                        Message: "Please enter your Bitbucket enterprise API URL:: ",
                }, &amp;bb.APIURL, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                bb.APIURL = apiURL
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (bb *bitbucketCloudConfig) create() error <span class="cov8" title="1">{
        if bb.Client == nil </span><span class="cov0" title="0">{
                bb.Client = bitbucket.NewBasicAuth(bb.repoOwner, bb.personalAccessToken)
        }</span>
        <span class="cov8" title="1">if bb.APIURL != "" </span><span class="cov8" title="1">{
                parsedURL, err := url.Parse(bb.APIURL)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">bb.Client.SetApiBaseURL(*parsedURL)</span>
        }

        <span class="cov8" title="1">opts := &amp;bitbucket.WebhooksOptions{
                Owner:    bb.repoOwner,
                RepoSlug: bb.repoName,
                Url:      bb.controllerURL,
                Active:   true,
                Events:   bitbucketcloud.PullRequestAllEvents,
        }
        _, err := bb.Client.Repositories.Webhooks.Create(opts)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(bb.IOStream.Out, " Webhook has been created on repository %v/%v\n", bb.repoOwner, bb.repoName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package webhook

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/google/go-github/v74/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli/prompt"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/random"
        "golang.org/x/oauth2"
)

type gitHubConfig struct {
        Client              *github.Client
        IOStream            *cli.IOStreams
        controllerURL       string
        repoOwner           string
        repoName            string
        webhookSecret       string
        personalAccessToken string
        APIURL              string
}

func (gh *gitHubConfig) Run(ctx context.Context, opts *Options) (*response, error) <span class="cov0" title="0">{
        err := gh.askGHWebhookConfig(opts.RepositoryURL, opts.ControllerURL, opts.ProviderAPIURL, opts.PersonalAccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;response{
                ControllerURL:       gh.controllerURL,
                PersonalAccessToken: gh.personalAccessToken,
                WebhookSecret:       gh.webhookSecret,
                APIURL:              gh.APIURL,
        }, gh.create(ctx)</span>
}

func (gh *gitHubConfig) askGHWebhookConfig(repoURL, controllerURL, apiURL, personalAccessToken string) error <span class="cov8" title="1">{
        if repoURL == "" </span><span class="cov8" title="1">{
                msg := "Please enter the git repository url you want to be configured: "
                if err := prompt.SurveyAskOne(&amp;survey.Input{Message: msg}, &amp;repoURL,
                        survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(gh.IOStream.Out, " Setting up GitHub Webhook for Repository %s\n", repoURL)
        }</span>

        <span class="cov8" title="1">defaultRepo, err := formatting.GetRepoOwnerFromURL(repoURL)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">defaultRepo = strings.TrimSuffix(defaultRepo, "/")
        repoArr := strings.Split(defaultRepo, "/")
        if len(repoArr) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid repository, needs to be of format 'org-name/repo-name'")
        }</span>

        <span class="cov8" title="1">gh.repoOwner = repoArr[0]
        gh.repoName = repoArr[1]

        // set controller url
        gh.controllerURL = controllerURL

        // confirm whether to use the detected url
        if gh.controllerURL != "" </span><span class="cov8" title="1">{
                var answer bool
                fmt.Fprintf(gh.IOStream.Out, " I have detected a controller url: %s\n", gh.controllerURL)
                err := prompt.SurveyAskOne(&amp;survey.Confirm{
                        Message: "Do you want me to use it?",
                        Default: true,
                }, &amp;answer)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !answer </span><span class="cov0" title="0">{
                        gh.controllerURL = ""
                }</span>
        }

        <span class="cov8" title="1">if gh.controllerURL == "" </span><span class="cov8" title="1">{
                if err := prompt.SurveyAskOne(&amp;survey.Input{
                        Message: "Please enter your controller public route URL: ",
                }, &amp;gh.controllerURL, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">data := random.AlphaString(12)
        msg := fmt.Sprintf("Please enter the secret to configure the webhook for payload validation (default: %s): ", data)
        var webhookSecret string
        if err := prompt.SurveyAskOne(&amp;survey.Input{Message: msg, Default: data}, &amp;webhookSecret); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">gh.webhookSecret = webhookSecret

        if personalAccessToken == "" </span><span class="cov8" title="1">{
                fmt.Fprintln(gh.IOStream.Out, " You now need to create a GitHub personal access token, please checkout the docs at https://is.gd/KJ1dDH for the required scopes")
                if err := prompt.SurveyAskOne(&amp;survey.Password{
                        Message: "Please enter the GitHub access token: ",
                }, &amp;gh.personalAccessToken, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                gh.personalAccessToken = personalAccessToken
        }</span>

        <span class="cov8" title="1">if apiURL == "" &amp;&amp; !strings.HasPrefix(repoURL, "https://github.com") </span><span class="cov0" title="0">{
                if err := prompt.SurveyAskOne(&amp;survey.Input{
                        Message: "Please enter your GitHub enterprise API URL: ",
                }, &amp;gh.APIURL, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                gh.APIURL = apiURL
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (gh *gitHubConfig) create(ctx context.Context) error <span class="cov8" title="1">{
        hook := &amp;github.Hook{
                Name:   github.Ptr("web"),
                Active: github.Ptr(true),
                Events: []string{
                        "issue_comment",
                        triggertype.PullRequest.String(),
                        "push",
                },
                Config: &amp;github.HookConfig{
                        URL:         github.Ptr(gh.controllerURL),
                        ContentType: github.Ptr("json"),
                        InsecureSSL: github.Ptr("0"),
                        Secret:      github.Ptr(gh.webhookSecret),
                },
        }

        ghClient, err := gh.newGHClientByToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, res, err := ghClient.Repositories.CreateHook(ctx, gh.repoOwner, gh.repoName, hook)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if res.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                payload, err := io.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read response body: %w", err)
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("failed to create webhook on repository %v/%v, status code: %v, error : %v",
                        gh.repoOwner, gh.repoName, res.StatusCode, payload)</span>
        }

        <span class="cov8" title="1">fmt.Fprintf(gh.IOStream.Out, " Webhook has been created on repository %v/%v\n", gh.repoOwner, gh.repoName)
        return nil</span>
}

func (gh *gitHubConfig) newGHClientByToken(ctx context.Context) (*github.Client, error) <span class="cov8" title="1">{
        if gh.Client != nil </span><span class="cov8" title="1">{
                return gh.Client, nil
        }</span>
        <span class="cov0" title="0">ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: gh.personalAccessToken},
        )

        if gh.APIURL == "" || gh.APIURL == keys.PublicGithubAPIURL </span><span class="cov0" title="0">{
                return github.NewClient(oauth2.NewClient(ctx, ts)), nil
        }</span>

        <span class="cov0" title="0">gprovider, err := github.NewClient(oauth2.NewClient(ctx, ts)).WithEnterpriseURLs(gh.APIURL, gh.APIURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return gprovider, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package webhook

import (
        "context"
        "fmt"
        "io"
        "net/http"

        "github.com/AlecAivazis/survey/v2"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli/prompt"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/random"
        gitlab "gitlab.com/gitlab-org/api/client-go"
)

type gitLabConfig struct {
        Client              *gitlab.Client
        IOStream            *cli.IOStreams
        controllerURL       string
        projectID           string
        webhookSecret       string
        personalAccessToken string
        APIURL              string
}

func (gl *gitLabConfig) Run(_ context.Context, opts *Options) (*response, error) <span class="cov0" title="0">{
        err := gl.askGLWebhookConfig(opts.RepositoryURL, opts.ControllerURL, opts.ProviderAPIURL, opts.PersonalAccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;response{
                ControllerURL:       gl.controllerURL,
                PersonalAccessToken: gl.personalAccessToken,
                WebhookSecret:       gl.webhookSecret,
                APIURL:              gl.APIURL,
        }, gl.create()</span>
}

// Changes in askGLWebhookConfig function.
func (gl *gitLabConfig) askGLWebhookConfig(repoURL, controllerURL, apiURL, personalAccessToken string) error <span class="cov8" title="1">{
        if repoURL == "" </span><span class="cov8" title="1">{
                msg := "Enter the GitLab repository URL to configure: "
                if err := prompt.SurveyAskOne(&amp;survey.Input{Message: msg}, &amp;repoURL,
                        survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                fmt.Fprintf(gl.IOStream.Out, " Setting up GitLab Webhook for Repository %s\n", repoURL)
        }</span>

        <span class="cov8" title="1">msg := "Enter the project ID of your GitLab repository.\nThe project ID is a unique number (e.g. 34405323) shown at the top of your GitLab project page: "
        if err := prompt.SurveyAskOne(&amp;survey.Input{Message: msg}, &amp;gl.projectID,
                survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">gl.controllerURL = controllerURL

        if gl.controllerURL != "" </span><span class="cov8" title="1">{
                var answer bool
                fmt.Fprintf(gl.IOStream.Out, " Controller URL detected: %s\n", gl.controllerURL)
                err := prompt.SurveyAskOne(&amp;survey.Confirm{
                        Message: "Do you want me to use it?",
                        Default: true,
                }, &amp;answer)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !answer </span><span class="cov0" title="0">{
                        gl.controllerURL = ""
                }</span>
        }

        <span class="cov8" title="1">if gl.controllerURL == "" </span><span class="cov8" title="1">{
                if err := prompt.SurveyAskOne(&amp;survey.Input{
                        Message: "Enter your controller's public route URL: ",
                }, &amp;gl.controllerURL, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">data := random.AlphaString(12)
        msg = fmt.Sprintf("Enter a secret for webhook payload validation (default: %s): ", data)
        var webhookSecret string
        if err := prompt.SurveyAskOne(&amp;survey.Input{Message: msg, Default: data}, &amp;webhookSecret); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">gl.webhookSecret = webhookSecret

        if personalAccessToken == "" </span><span class="cov8" title="1">{
                fmt.Fprintln(gl.IOStream.Out, " You need to create a GitLab personal access token with 'api' scope")
                fmt.Fprintln(gl.IOStream.Out, " Generate one at https://gitlab.com/-/profile/personal_access_tokens (see documentation: https://is.gd/rOEo9B)")
                if err := prompt.SurveyAskOne(&amp;survey.Password{
                        Message: "Enter your GitLab access token: ",
                }, &amp;gl.personalAccessToken, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                gl.personalAccessToken = personalAccessToken
        }</span>

        <span class="cov8" title="1">if apiURL == "" </span><span class="cov8" title="1">{
                if err := prompt.SurveyAskOne(&amp;survey.Input{
                        Message: "Enter your GitLab API URL: ",
                }, &amp;gl.APIURL, survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                gl.APIURL = apiURL
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// create function.
func (gl *gitLabConfig) create() error <span class="cov8" title="1">{
        glClient, err := gl.newClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">hookOpts := &amp;gitlab.AddProjectHookOptions{
                EnableSSLVerification: gitlab.Ptr(true),
                MergeRequestsEvents:   gitlab.Ptr(true),
                NoteEvents:            gitlab.Ptr(true),
                PushEvents:            gitlab.Ptr(true),
                TagPushEvents:         gitlab.Ptr(true),
                Token:                 gitlab.Ptr(gl.webhookSecret),
                URL:                   gitlab.Ptr(gl.controllerURL),
        }

        _, resp, err := glClient.Projects.AddProjectHook(gl.projectID, hookOpts)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                payload, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read response body: %w", err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to create webhook, status code: %v, error : %v",
                        resp.StatusCode, payload)</span>
        }

        <span class="cov8" title="1">fmt.Fprintln(gl.IOStream.Out, " Webhook successfully created on your repository")
        return nil</span>
}

func (gl *gitLabConfig) newClient() (*gitlab.Client, error) <span class="cov8" title="1">{
        if gl.Client != nil </span><span class="cov8" title="1">{
                return gl.Client, nil
        }</span>

        <span class="cov0" title="0">if gl.APIURL == "" </span><span class="cov0" title="0">{
                return gitlab.NewClient(gl.personalAccessToken)
        }</span>
        <span class="cov0" title="0">return gitlab.NewClient(gl.personalAccessToken, gitlab.WithBaseURL(gl.APIURL))</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package webhook

import (
        "context"
        "fmt"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (w *Options) createWebhookSecret(ctx context.Context, response *response) error <span class="cov8" title="1">{
        _, err := w.Run.Clients.Kube.CoreV1().Secrets(w.RepositoryNamespace).Create(ctx, &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name: w.RepositoryName,
                },
                Data: map[string][]byte{
                        pipelineascode.DefaultGitProviderSecretKey:        []byte(response.PersonalAccessToken),
                        pipelineascode.DefaultGitProviderWebhookSecretKey: []byte(response.WebhookSecret),
                },
        }, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(w.IOStreams.Out, " Webhook Secret %s has been created in the %s namespace.\n", w.RepositoryName, w.RepositoryNamespace)
        return nil</span>
}

func (w *Options) updateWebhookSecret(ctx context.Context, response *response) error <span class="cov8" title="1">{
        secretInfo, err := w.Run.Clients.Kube.CoreV1().Secrets(w.RepositoryNamespace).Get(ctx, w.SecretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">secretInfo.Data[pipelineascode.DefaultGitProviderWebhookSecretKey] = []byte(response.WebhookSecret)

        _, err = w.Run.Clients.Kube.CoreV1().Secrets(w.RepositoryNamespace).Update(ctx, secretInfo, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(w.IOStreams.Out, " Secret %s has been updated with webhook secret in the %s namespace.\n", w.SecretName, w.RepositoryNamespace)
        return nil</span>
}

func (w *Options) updateRepositoryCR(ctx context.Context, res *response) error <span class="cov8" title="1">{
        repo, err := w.Run.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(w.RepositoryNamespace).
                Get(ctx, w.RepositoryName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if repo.Spec.GitProvider == nil </span><span class="cov8" title="1">{
                repo.Spec.GitProvider = &amp;v1alpha1.GitProvider{}
        }</span>

        <span class="cov8" title="1">repo.Spec.GitProvider.Secret = &amp;v1alpha1.Secret{
                Name: w.RepositoryName,
                Key:  pipelineascode.DefaultGitProviderSecretKey,
        }
        repo.Spec.GitProvider.WebhookSecret = &amp;v1alpha1.Secret{
                Name: w.RepositoryName,
                Key:  pipelineascode.DefaultGitProviderWebhookSecretKey,
        }

        if res.UserName != "" </span><span class="cov8" title="1">{
                repo.Spec.GitProvider.User = res.UserName
        }</span>

        <span class="cov8" title="1">if res.APIURL != "" </span><span class="cov8" title="1">{
                repo.Spec.GitProvider.URL = res.APIURL
        }</span>

        <span class="cov8" title="1">_, err = w.Run.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(w.RepositoryNamespace).
                Update(ctx, repo, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">fmt.Fprintf(w.IOStreams.Out, " Repository CR %s has been updated with webhook secret in the %s namespace\n", w.RepositoryName, w.RepositoryNamespace)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package webhook

import (
        "context"
        "fmt"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli/prompt"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cmd/tknpac/bootstrap"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
)

type Interface interface {
        Run(context.Context, *Options) (*response, error)
}

type Options struct {
        Run                      *params.Run
        IOStreams                *cli.IOStreams
        PACNamespace             string
        RepositoryURL            string
        RepositoryName           string
        RepositoryNamespace      string
        ProviderAPIURL           string
        ControllerURL            string
        PersonalAccessToken      string
        RepositoryCreateORUpdate bool
        SecretName               string
        ProviderSecretKey        string
}

type response struct {
        UserName            string
        ControllerURL       string
        WebhookSecret       string
        PersonalAccessToken string
        APIURL              string
}

func (w *Options) Install(ctx context.Context, providerType string) error <span class="cov0" title="0">{
        // figure out pac installation namespace
        installed, installationNS, err := bootstrap.DetectPacInstallation(ctx, w.PACNamespace, w.Run)
        if !installed </span><span class="cov0" title="0">{
                return fmt.Errorf("pipelines as code not installed")
        }</span>
        <span class="cov0" title="0">if installed &amp;&amp; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // fetch configmap to get controller url
        <span class="cov0" title="0">pacInfo, err := info.GetPACInfo(ctx, w.Run, installationNS)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // check if info configmap has url then use that otherwise try to detect
        <span class="cov0" title="0">if pacInfo.ControllerURL != "" &amp;&amp; w.ControllerURL == "" </span><span class="cov0" title="0">{
                w.ControllerURL = pacInfo.ControllerURL
        }</span> else<span class="cov0" title="0"> {
                w.ControllerURL, _ = bootstrap.DetectOpenShiftRoute(ctx, w.Run, w.PACNamespace)
        }</span>

        <span class="cov0" title="0">if w.RepositoryURL == "" </span><span class="cov0" title="0">{
                q := "Please enter the Git repository url: "
                if err := prompt.SurveyAskOne(&amp;survey.Input{Message: q}, &amp;w.RepositoryURL,
                        survey.WithValidator(survey.Required)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">var webhookProvider Interface
        switch providerType </span>{
        case "github":<span class="cov0" title="0">
                webhookProvider = &amp;gitHubConfig{IOStream: w.IOStreams}</span>
        case "gitlab":<span class="cov0" title="0">
                webhookProvider = &amp;gitLabConfig{IOStream: w.IOStreams}</span>
        case "bitbucket-cloud":<span class="cov0" title="0">
                webhookProvider = &amp;bitbucketCloudConfig{IOStream: w.IOStreams}</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("invalid webhook provider")</span>
        }

        <span class="cov0" title="0">response, err := webhookProvider.Run(ctx, w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // RepositoryCreateORUpdate is false for tkn-pac webhook add command
        <span class="cov0" title="0">if !w.RepositoryCreateORUpdate </span><span class="cov0" title="0">{
                return w.updateWebhookSecret(ctx, response)
        }</span>

        // create webhook secret in namespace where repository CR is created
        <span class="cov0" title="0">if err := w.createWebhookSecret(ctx, response); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update repo cr with webhook secret
        <span class="cov0" title="0">return w.updateRepositoryCR(ctx, response)</span>
}

func GetProviderName(url string) (string, error) <span class="cov0" title="0">{
        var (
                err          error
                providerName string
        )
        switch </span>{
        case strings.Contains(url, "github"):<span class="cov0" title="0">
                providerName = "github"</span>
        case strings.Contains(url, "gitlab"):<span class="cov0" title="0">
                providerName = "gitlab"</span>
        case strings.Contains(url, "bitbucket-cloud"):<span class="cov0" title="0">
                providerName = "bitbucket-cloud"</span>
        default:<span class="cov0" title="0">
                msg := "Please select the type of the git platform to setup webhook:"
                if err = prompt.SurveyAskOne(
                        &amp;survey.Select{
                                Message: msg,
                                Options: []string{"github", "gitlab", "bitbucket-cloud"},
                                Default: 0,
                        }, &amp;providerName); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov0" title="0">return providerName, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package configutil

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "go.uber.org/zap"
)

func ValidateAndAssignValues(logger *zap.SugaredLogger, configData map[string]string, configStruct any, customValidations map[string]func(string) error, logUpdates bool) error <span class="cov8" title="1">{
        structValue := reflect.ValueOf(configStruct).Elem()
        structType := reflect.TypeOf(configStruct).Elem()

        var errors []error

        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov8" title="1">{
                field := structType.Field(i)
                fieldName := field.Name

                jsonTag := field.Tag.Get("json")
                // Skip field which doesn't have json tag
                if jsonTag == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Read value from ConfigMap
                <span class="cov8" title="1">fieldValue := configData[strings.ToLower(jsonTag)]

                // If value is missing in ConfigMap, use default value from struct tag
                if fieldValue == "" </span><span class="cov8" title="1">{
                        fieldValue = field.Tag.Get("default")
                }</span>

                <span class="cov8" title="1">fieldValueKind := field.Type.Kind()

                //nolint
                switch fieldValueKind </span>{
                case reflect.String:<span class="cov8" title="1">
                        // if fieldvalue is empty, skip validation and set the field as empty string
                        if validator, ok := customValidations[fieldName]; ok &amp;&amp; fieldValue != "" </span><span class="cov8" title="1">{
                                if err := validator(fieldValue); err != nil </span><span class="cov8" title="1">{
                                        errors = append(errors, fmt.Errorf("custom validation failed for field %s: %w", fieldName, err))
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">oldValue := structValue.FieldByName(fieldName).String()
                        if oldValue != fieldValue &amp;&amp; logUpdates </span><span class="cov8" title="1">{
                                logger.Infof("updating value for field %s: from '%s' to '%s'", fieldName, oldValue, fieldValue)
                        }</span>
                        <span class="cov8" title="1">structValue.FieldByName(fieldName).SetString(fieldValue)</span>

                case reflect.Bool:<span class="cov8" title="1">
                        // if fieldvalue is empty, set the field as false
                        if fieldValue == "" </span><span class="cov0" title="0">{
                                fieldValue = "false"
                        }</span>
                        <span class="cov8" title="1">newValue, err := strconv.ParseBool(fieldValue)
                        if err != nil </span><span class="cov8" title="1">{
                                errors = append(errors, fmt.Errorf("invalid value for bool field %s: %w", fieldName, err))
                                continue</span>
                        }
                        <span class="cov8" title="1">oldValue := structValue.FieldByName(fieldName).Bool()
                        if oldValue != newValue &amp;&amp; logUpdates </span><span class="cov8" title="1">{
                                logger.Infof("updating value for field %s: from '%v' to '%v'", fieldName, oldValue, newValue)
                        }</span>
                        <span class="cov8" title="1">structValue.FieldByName(fieldName).SetBool(newValue)</span>

                case reflect.Int:<span class="cov8" title="1">
                        // if fieldvalue is empty, skip validation and set the field as 0
                        if validator, ok := customValidations[fieldName]; ok &amp;&amp; fieldValue != "" </span><span class="cov0" title="0">{
                                if err := validator(fieldValue); err != nil </span><span class="cov0" title="0">{
                                        errors = append(errors, fmt.Errorf("custom validation failed for field %s: %w", fieldName, err))
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">if fieldValue == "" </span><span class="cov8" title="1">{
                                fieldValue = "0"
                        }</span>
                        <span class="cov8" title="1">newValue, err := strconv.ParseInt(fieldValue, 10, 64)
                        if err != nil </span><span class="cov8" title="1">{
                                errors = append(errors, fmt.Errorf("invalid value for int field %s: %w", fieldName, err))
                                continue</span>
                        }
                        <span class="cov8" title="1">oldValue := structValue.FieldByName(fieldName).Int()
                        if oldValue != newValue &amp;&amp; logUpdates </span><span class="cov8" title="1">{
                                logger.Infof("updating value for field %s: from '%d' to '%d'", fieldName, oldValue, newValue)
                        }</span>
                        <span class="cov8" title="1">structValue.FieldByName(fieldName).SetInt(newValue)</span>

                default:<span class="cov0" title="0">
                        // Skip unsupported field types
                        continue</span>
                }
        }

        <span class="cov8" title="1">if len(errors) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("validation errors: %v", errors)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package consoleui

import (
        "context"
        "fmt"
        "net/url"
        "strings"
        "sync"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/templates"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/client-go/dynamic"
)

type CustomConsole struct {
        pacInfo              *info.PacOpts
        namespace, pr, task  string
        pod, firstFailedStep string
        extraParams          map[string]string
        mu                   sync.RWMutex
}

func NewCustomConsole(pacInfo *info.PacOpts) *CustomConsole <span class="cov8" title="1">{
        return &amp;CustomConsole{pacInfo: pacInfo}
}</span>

func (o *CustomConsole) GetName() string <span class="cov8" title="1">{
        if o.pacInfo.CustomConsoleName == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("https://url.setting.%s.is.not.configured", settings.CustomConsoleNameKey)
        }</span>
        <span class="cov8" title="1">return o.pacInfo.CustomConsoleName</span>
}

func (o *CustomConsole) URL() string <span class="cov8" title="1">{
        if o.pacInfo.CustomConsoleURL == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("https://url.setting.%s.is.not.configured", settings.CustomConsoleURLKey)
        }</span>
        <span class="cov8" title="1">return o.pacInfo.CustomConsoleURL</span>
}

func (o *CustomConsole) SetParams(mt map[string]string) <span class="cov8" title="1">{
        o.extraParams = mt
}</span>

// generateURL will generate a URL from a template, trim some of the spaces and
// \n we get from yaml
// return the default URL if there it's not become a proper url or that it has
// some of the templates like {{}} left.
func (o *CustomConsole) generateURL(urlTmpl string) string <span class="cov8" title="1">{
        o.mu.RLock()
        defer o.mu.RUnlock()
        dict := map[string]string{
                "namespace":       o.namespace,
                "pr":              o.pr,
                "task":            o.task,
                "pod":             o.pod,
                "firstFailedStep": o.firstFailedStep,
        }
        for k, v := range o.extraParams </span><span class="cov8" title="1">{
                dict[k] = v
        }</span>

        <span class="cov8" title="1">newurl := templates.ReplacePlaceHoldersVariables(urlTmpl, dict, nil, nil, nil)
        // trim new line because yaml parser adds new line at the end of the string
        newurl = strings.TrimSpace(strings.TrimSuffix(newurl, "\n"))
        if _, err := url.ParseRequestURI(newurl); err != nil </span><span class="cov8" title="1">{
                return o.URL()
        }</span>
        // detect if there is still some {{}} in the url
        <span class="cov8" title="1">if keys.ParamsRe.MatchString(newurl) </span><span class="cov0" title="0">{
                return o.URL()
        }</span>
        <span class="cov8" title="1">return newurl</span>
}

func (o *CustomConsole) DetailURL(pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        if o.pacInfo.CustomConsolePRdetail == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("https://detailurl.setting.%s.is.not.configured", settings.CustomConsolePRDetailKey)
        }</span>
        <span class="cov8" title="1">o.namespace = pr.GetNamespace()
        o.pr = pr.GetName()
        return o.generateURL(o.pacInfo.CustomConsolePRdetail)</span>
}

func (o *CustomConsole) NamespaceURL(pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        if o.pacInfo.CustomConsoleNamespaceURL == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("https://detailurl.setting.%s.is.not.configured", settings.CustomConsoleNamespaceURLKey)
        }</span>
        <span class="cov8" title="1">o.namespace = pr.GetNamespace()
        return o.generateURL(o.pacInfo.CustomConsoleNamespaceURL)</span>
}

func (o *CustomConsole) TaskLogURL(pr *tektonv1.PipelineRun, taskRunStatus *tektonv1.PipelineRunTaskRunStatus) string <span class="cov8" title="1">{
        if o.pacInfo.CustomConsolePRTaskLog == "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("https://tasklogurl.setting.%s.is.not.configured", settings.CustomConsolePRTaskLogKey)
        }</span>
        <span class="cov8" title="1">firstFailedStep := ""
        // search for the first failed steps in taskrunstatus
        for _, step := range taskRunStatus.Status.Steps </span><span class="cov8" title="1">{
                if step.Terminated != nil &amp;&amp; step.Terminated.ExitCode != 0 </span><span class="cov8" title="1">{
                        firstFailedStep = step.Name
                        break</span>
                }
        }

        <span class="cov8" title="1">o.namespace = pr.GetNamespace()
        o.pr = pr.GetName()
        o.task = taskRunStatus.PipelineTaskName
        o.pod = taskRunStatus.Status.PodName
        o.firstFailedStep = firstFailedStep

        return o.generateURL(o.pacInfo.CustomConsolePRTaskLog)</span>
}

func (o *CustomConsole) UI(_ context.Context, _ dynamic.Interface) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package consoleui

import (
        "context"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/client-go/dynamic"
)

const consoleIsnotConfiguredURL = "https://dashboard.is.not.configured"

type Interface interface {
        DetailURL(pr *tektonv1.PipelineRun) string
        TaskLogURL(pr *tektonv1.PipelineRun, taskRunStatusstatus *tektonv1.PipelineRunTaskRunStatus) string
        NamespaceURL(pr *tektonv1.PipelineRun) string
        UI(ctx context.Context, kdyn dynamic.Interface) error
        URL() string
        GetName() string
        SetParams(mt map[string]string)
}

type FallBackConsole struct{}

func (f FallBackConsole) GetName() string <span class="cov0" title="0">{
        return "Not configured"
}</span>

func (f FallBackConsole) DetailURL(_ *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        return consoleIsnotConfiguredURL
}</span>

func (f FallBackConsole) TaskLogURL(_ *tektonv1.PipelineRun, _ *tektonv1.PipelineRunTaskRunStatus) string <span class="cov8" title="1">{
        return consoleIsnotConfiguredURL
}</span>

func (f FallBackConsole) NamespaceURL(_ *tektonv1.PipelineRun) string <span class="cov0" title="0">{
        return consoleIsnotConfiguredURL
}</span>

func (f FallBackConsole) UI(_ context.Context, _ dynamic.Interface) error <span class="cov8" title="1">{
        return nil
}</span>

func (f FallBackConsole) URL() string <span class="cov8" title="1">{
        return consoleIsnotConfiguredURL
}</span>

func (f FallBackConsole) SetParams(_ map[string]string) {<span class="cov0" title="0">
}</span>

func New(ctx context.Context, kdyn dynamic.Interface, _ *info.Info) Interface <span class="cov0" title="0">{
        oc := &amp;OpenshiftConsole{}
        if err := oc.UI(ctx, kdyn); err == nil </span><span class="cov0" title="0">{
                return oc
        }</span>

        // TODO: Try to detect TektonDashboard somehow by ingress?
        <span class="cov0" title="0">return FallBackConsole{}</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package consoleui

import (
        "context"
        "fmt"

        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/dynamic"
)

const (
        openShiftConsoleNS                = "openshift-console"
        openShiftConsoleRouteName         = "console"
        openShiftPipelineNamespaceViewURL = "https://%s/pipelines/ns/%s/pipeline-runs"
        openShiftPipelineDetailViewURL    = "https://%s/k8s/ns/%s/tekton.dev~v1~PipelineRun/%s"
        openShiftPipelineTaskLogURL       = "%s/logs/%s"
        openShiftRouteGroup               = "route.openshift.io"
        openShiftRouteVersion             = "v1"
        openShiftRouteResource            = "routes"
        openshiftConsoleName              = "OpenShift Console"
)

type OpenshiftConsole struct {
        host string
}

func (o *OpenshiftConsole) SetParams(_ map[string]string) {<span class="cov0" title="0">
}</span>

func (o *OpenshiftConsole) GetName() string <span class="cov8" title="1">{
        return openshiftConsoleName
}</span>

func (o *OpenshiftConsole) URL() string <span class="cov8" title="1">{
        return "https://" + o.host
}</span>

func (o *OpenshiftConsole) DetailURL(pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        return fmt.Sprintf(openShiftPipelineDetailViewURL, o.host, pr.GetNamespace(), pr.GetName())
}</span>

func (o *OpenshiftConsole) TaskLogURL(pr *tektonv1.PipelineRun, taskRunStatus *tektonv1.PipelineRunTaskRunStatus) string <span class="cov8" title="1">{
        return fmt.Sprintf(openShiftPipelineTaskLogURL, o.DetailURL(pr), taskRunStatus.PipelineTaskName)
}</span>

func (o *OpenshiftConsole) NamespaceURL(pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        return fmt.Sprintf(openShiftPipelineNamespaceViewURL, o.host, pr.GetNamespace())
}</span>

// UI use dynamic client to get the route of the openshift
// console where we can point to.
func (o *OpenshiftConsole) UI(ctx context.Context, kdyn dynamic.Interface) error <span class="cov8" title="1">{
        gvr := schema.GroupVersionResource{
                Group: openShiftRouteGroup, Version: openShiftRouteVersion, Resource: openShiftRouteResource,
        }

        route, err := kdyn.Resource(gvr).Namespace(openShiftConsoleNS).Get(ctx, openShiftConsoleRouteName,
                metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">spec, ok := route.Object["spec"].(map[string]any)
        if !ok </span><span class="cov8" title="1">{
                // this condition is satisfied if there's no metadata at all in the provided CR
                return fmt.Errorf("couldn't find spec in the OpenShift Console route")
        }</span>

        <span class="cov8" title="1">if o.host, ok = spec["host"].(string); !ok </span><span class="cov8" title="1">{
                // this condition is satisfied if there's no metadata at all in the provided CR
                return fmt.Errorf("couldn't find spec.host in the OpenShift Console route")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package consoleui

import (
        "context"
        "fmt"

        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/client-go/dynamic"
)

type TektonDashboard struct {
        BaseURL string
}

const tektonDashboardName = "Tekton Dashboard"

func (t *TektonDashboard) GetName() string <span class="cov8" title="1">{
        return tektonDashboardName
}</span>

func (t *TektonDashboard) DetailURL(pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/#/namespaces/%s/pipelineruns/%s", t.BaseURL, pr.GetNamespace(), pr.GetName())
}</span>

func (t *TektonDashboard) NamespaceURL(pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/#/namespaces/%s/pipelineruns", t.BaseURL, pr.GetNamespace())
}</span>

func (t *TektonDashboard) TaskLogURL(pr *tektonv1.PipelineRun, taskRunStatus *tektonv1.PipelineRunTaskRunStatus) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s?pipelineTask=%s", t.DetailURL(pr), taskRunStatus.PipelineTaskName)
}</span>

func (t *TektonDashboard) URL() string <span class="cov8" title="1">{
        return t.BaseURL
}</span>

func (t *TektonDashboard) UI(_ context.Context, _ dynamic.Interface) error <span class="cov8" title="1">{
        return nil
}</span>

func (t *TektonDashboard) SetParams(_ map[string]string) {<span class="cov8" title="1">
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package customparams

import (
        "context"
        "fmt"

        celTypes "github.com/google/cel-go/common/types"
        "go.uber.org/zap"

        apincoming "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/incoming"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        pacCel "github.com/openshift-pipelines/pipelines-as-code/pkg/cel"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        sectypes "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/types"
)

type CustomParams struct {
        event        *info.Event
        run          *params.Run
        k8int        kubeinteraction.Interface
        eventEmitter *events.EventEmitter
        repo         *v1alpha1.Repository
        vcx          provider.Interface
}

func NewCustomParams(event *info.Event, repo *v1alpha1.Repository, run *params.Run, k8int kubeinteraction.Interface, eventEmitter *events.EventEmitter, prov provider.Interface) CustomParams <span class="cov8" title="1">{
        return CustomParams{
                event:        event,
                repo:         repo,
                run:          run,
                k8int:        k8int,
                eventEmitter: eventEmitter,
                vcx:          prov,
        }
}</span>

// applyIncomingParams apply incoming params to an existing map (overwriting existing keys).
func (p *CustomParams) applyIncomingParams(ret map[string]string) map[string]string <span class="cov8" title="1">{
        if p.event.Request == nil </span><span class="cov8" title="1">{
                return ret
        }</span>
        <span class="cov8" title="1">if incomingParams, err := apincoming.ParseIncomingPayload(p.event.Request.Payload); err == nil </span><span class="cov8" title="1">{
                for k, v := range incomingParams.Params </span><span class="cov8" title="1">{
                        if vs, ok := v.(string); ok </span><span class="cov8" title="1">{
                                ret[k] = vs
                        }</span> else<span class="cov8" title="1"> {
                                p.eventEmitter.EmitMessage(p.repo, zap.WarnLevel, "IncomingParamsNotString", fmt.Sprintf("cannot convert incoming param key: %s value: %v as string", k, v))
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

// GetParams will process the parameters as set in the repo.Spec CR.
// value can come from a string or from a secretKeyRef or from a string value
// if both is set we pick the value and issue a warning in the user namespace
// we let the user specify a cel filter. If false then we skip the parameters.
// if multiple params name has a filter we pick up the first one that has
// matched true.
func (p *CustomParams) GetParams(ctx context.Context) (map[string]string, map[string]any, error) <span class="cov8" title="1">{
        stdParams, changedFiles := p.makeStandardParamsFromEvent(ctx)
        resolvedParams, mapFilters, parsedFromComment := map[string]string{}, map[string]string{}, map[string]string{}
        if p.event.TriggerComment != "" </span><span class="cov8" title="1">{
                parsedFromComment = opscomments.ParseKeyValueArgs(p.event.TriggerComment)
                for k, v := range parsedFromComment </span><span class="cov8" title="1">{
                        if _, ok := stdParams[k]; ok </span><span class="cov8" title="1">{
                                stdParams[k] = v
                        }</span>
                }
        }

        <span class="cov8" title="1">if p.repo.Spec.Params == nil </span><span class="cov8" title="1">{
                return p.applyIncomingParams(stdParams), changedFiles, nil
        }</span>

        <span class="cov8" title="1">for index, value := range *p.repo.Spec.Params </span><span class="cov8" title="1">{
                // if the name is empty we skip it
                if value.Name == "" </span><span class="cov8" title="1">{
                        p.eventEmitter.EmitMessage(p.repo, zap.ErrorLevel,
                                "ParamsFilterSkipped", fmt.Sprintf("no name has been set in params[%d] of repo %s", index, p.repo.GetName()))
                        continue</span>
                }
                <span class="cov8" title="1">if value.Filter != "" </span><span class="cov8" title="1">{
                        // if we already have a filter that has matched we skip it
                        if _, ok := mapFilters[value.Name]; ok </span><span class="cov8" title="1">{
                                p.eventEmitter.EmitMessage(p.repo, zap.WarnLevel,
                                        "ParamsFilterSkipped", fmt.Sprintf("skipping params name %s, filter has already been matched previously", value.Name))
                                continue</span>
                        }

                        // if the cel filter condition is false we skip it
                        // TODO: add headers to customparams?
                        <span class="cov8" title="1">cond, err := pacCel.Value(value.Filter, p.event.Event, nil, stdParams, changedFiles)
                        if err != nil </span><span class="cov8" title="1">{
                                p.eventEmitter.EmitMessage(p.repo, zap.ErrorLevel,
                                        "ParamsFilterError", fmt.Sprintf("there is an error on the cel filter: %s: %s", value.Name, err.Error()))
                                return map[string]string{}, changedFiles, err
                        }</span>
                        <span class="cov8" title="1">switch cond.(type) </span>{
                        case celTypes.Bool:<span class="cov8" title="1">
                                if cond == celTypes.False </span><span class="cov8" title="1">{
                                        p.eventEmitter.EmitMessage(p.repo, zap.InfoLevel,
                                                "ParamsFilterSkipped", fmt.Sprintf("skipping params name %s, filter condition is false", value.Name))
                                        continue</span>
                                }
                        default:<span class="cov8" title="1">
                                p.eventEmitter.EmitMessage(p.repo, zap.InfoLevel,
                                        "ParamsFilterSkipped", fmt.Sprintf("skipping params name %s, filter condition is not a boolean reply: %s", value.Name, cond.Type().TypeName()))
                                continue</span>
                        }
                        <span class="cov8" title="1">mapFilters[value.Name] = value.Value</span>
                }

                <span class="cov8" title="1">if value.SecretRef != nil &amp;&amp; value.Value != "" </span><span class="cov8" title="1">{
                        p.eventEmitter.EmitMessage(p.repo, zap.InfoLevel,
                                "ParamsFilterUsedValue",
                                fmt.Sprintf("repo %s, param name %s has a value and secretref, picking value", p.repo.GetName(), value.Name))
                }</span>

                <span class="cov8" title="1">_, paramIsStd := stdParams[value.Name]
                _, paramParsedFromContent := parsedFromComment[value.Name]

                switch </span>{
                case value.Value != "":<span class="cov8" title="1">
                        resolvedParams[value.Name] = value.Value</span>
                case paramParsedFromContent &amp;&amp; !paramIsStd:<span class="cov8" title="1">
                        // If the param is standard, it's initial value will be set later so we don't set it here.
                        // Setting to empty string allows the parsedFromComment overrides to set the overridden value below.
                        resolvedParams[value.Name] = ""</span>
                case value.SecretRef != nil:<span class="cov8" title="1">
                        secretValue, err := p.k8int.GetSecret(ctx, sectypes.GetSecretOpt{
                                Namespace: p.repo.GetNamespace(),
                                Name:      value.SecretRef.Name,
                                Key:       value.SecretRef.Key,
                        })
                        if err != nil </span><span class="cov8" title="1">{
                                return resolvedParams, changedFiles, err
                        }</span>
                        <span class="cov8" title="1">resolvedParams[value.Name] = secretValue</span>
                }
        }

        // TODO: Should we let the user override the standard params?
        // we don't let them here
        <span class="cov8" title="1">for k, v := range stdParams </span><span class="cov8" title="1">{
                // check if not already there
                if _, ok := resolvedParams[k]; !ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                        resolvedParams[k] = v
                }</span>
        }

        // overwrite stdParams with parsed ones from the trigger comment
        <span class="cov8" title="1">for k, v := range parsedFromComment </span><span class="cov8" title="1">{
                if _, ok := resolvedParams[k]; ok &amp;&amp; v != "" </span><span class="cov8" title="1">{
                        resolvedParams[k] = v
                }</span>
        }

        <span class="cov8" title="1">return p.applyIncomingParams(resolvedParams), changedFiles, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package customparams

import (
        "context"
        "fmt"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "go.uber.org/zap"
)

func (p *CustomParams) getChangedFiles(ctx context.Context) changedfiles.ChangedFiles <span class="cov8" title="1">{
        if p.vcx == nil </span><span class="cov0" title="0">{
                return changedfiles.ChangedFiles{}
        }</span>
        <span class="cov8" title="1">changedFiles, err := p.vcx.GetFiles(ctx, p.event)
        if err != nil </span><span class="cov0" title="0">{
                p.eventEmitter.EmitMessage(p.repo, zap.ErrorLevel, "ParamsError", fmt.Sprintf("error getting changed files: %s", err.Error()))
                return changedfiles.ChangedFiles{}
        }</span>
        <span class="cov8" title="1">changedFiles.RemoveDuplicates()
        return changedFiles</span>
}

// makeStandardParamsFromEvent will create a map of standard params out of the event.
func (p *CustomParams) makeStandardParamsFromEvent(ctx context.Context) (map[string]string, map[string]any) <span class="cov8" title="1">{
        repoURL := p.event.URL
        // On bitbucket data center you are have a special url for checking it out, they
        // seemed to fix it in 2.0 but i guess we have to live with this until then.
        if p.event.CloneURL != "" </span><span class="cov8" title="1">{
                repoURL = p.event.CloneURL
        }</span>
        <span class="cov8" title="1">changedFiles := p.getChangedFiles(ctx)
        triggerCommentAsSingleLine := strings.ReplaceAll(strings.ReplaceAll(p.event.TriggerComment, "\r\n", "\\n"), "\n", "\\n")
        pullRequestLabels := strings.Join(p.event.PullRequestLabel, "\\n")

        gitTag := ""
        if strings.HasPrefix(p.event.BaseBranch, "refs/tags/") </span><span class="cov8" title="1">{
                gitTag = strings.TrimPrefix(p.event.BaseBranch, "refs/tags/")
        }</span>

        <span class="cov8" title="1">return map[string]string{
                        "revision":            p.event.SHA,
                        "repo_url":            repoURL,
                        "repo_owner":          strings.ToLower(p.event.Organization),
                        "repo_name":           strings.ToLower(p.event.Repository),
                        "target_branch":       formatting.SanitizeBranch(p.event.BaseBranch),
                        "source_branch":       formatting.SanitizeBranch(p.event.HeadBranch),
                        "git_tag":             gitTag,
                        "source_url":          p.event.HeadURL,
                        "sender":              strings.ToLower(p.event.Sender),
                        "target_namespace":    p.repo.GetNamespace(),
                        "event_type":          opscomments.EventTypeBackwardCompat(p.eventEmitter, p.repo, p.event.EventType),
                        "trigger_comment":     triggerCommentAsSingleLine,
                        "pull_request_labels": pullRequestLabels,
                }, map[string]any{
                        "all":      changedFiles.All,
                        "added":    changedFiles.Added,
                        "deleted":  changedFiles.Deleted,
                        "modified": changedFiles.Modified,
                        "renamed":  changedFiles.Renamed,
                }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package events

import (
        "context"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

func NewEventEmitter(client kubernetes.Interface, logger *zap.SugaredLogger) *EventEmitter <span class="cov8" title="1">{
        return &amp;EventEmitter{
                client: client,
                logger: logger,
        }
}</span>

type EventEmitter struct {
        client kubernetes.Interface
        logger *zap.SugaredLogger
}

func (e *EventEmitter) SetLogger(logger *zap.SugaredLogger) <span class="cov0" title="0">{
        e.logger = logger
}</span>

func (e *EventEmitter) EmitMessage(repo *v1alpha1.Repository, loggerLevel zapcore.Level, reason, message string) <span class="cov8" title="1">{
        if repo != nil </span><span class="cov8" title="1">{
                event := makeEvent(repo, loggerLevel, reason, message)
                if _, err := e.client.CoreV1().Events(event.Namespace).Create(context.Background(), event, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        if e.logger != nil </span><span class="cov0" title="0">{
                                e.logger.Infof("Cannot create event: %s", err.Error())
                        }</span>
                }
        }

        <span class="cov8" title="1">if e.logger != nil </span><span class="cov8" title="1">{
                //nolint
                switch loggerLevel </span>{
                case zapcore.DebugLevel:<span class="cov0" title="0">
                        e.logger.Debug(message)</span>
                case zapcore.ErrorLevel:<span class="cov8" title="1">
                        e.logger.Error(message)</span>
                case zapcore.InfoLevel:<span class="cov8" title="1">
                        e.logger.Info(message)</span>
                case zapcore.WarnLevel:<span class="cov0" title="0">
                        e.logger.Warn(message)</span>
                }
        }
}

func makeEvent(repo *v1alpha1.Repository, loggerLevel zapcore.Level, reason, message string) *v1.Event <span class="cov8" title="1">{
        event := &amp;v1.Event{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: repo.Name + "-",
                        Namespace:    repo.Namespace,
                        Labels: map[string]string{
                                keys.Repository: formatting.CleanValueKubernetes(repo.Name),
                        },
                        Annotations: map[string]string{
                                keys.Repository: repo.Name,
                        },
                },
                Message: message,
                Reason:  reason,
                Type:    v1.EventTypeWarning,
                InvolvedObject: v1.ObjectReference{
                        APIVersion:      pipelinesascode.V1alpha1Version,
                        Kind:            pipelinesascode.RepositoryKind,
                        Namespace:       repo.Namespace,
                        Name:            repo.Name,
                        UID:             repo.UID,
                        ResourceVersion: repo.ResourceVersion,
                },
                Source: v1.EventSource{
                        Component: "Pipelines As Code",
                },
        }
        if loggerLevel == zap.InfoLevel </span><span class="cov8" title="1">{
                event.Type = v1.EventTypeNormal
        }</span>
        <span class="cov8" title="1">return event</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package formatting

import (
        "github.com/hako/durafmt"
        "github.com/jonboulle/clockwork"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func Age(t *metav1.Time, c clockwork.Clock) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov8" title="1">{
                return nonAttributedStr
        }</span>
        <span class="cov8" title="1">return durafmt.ParseShort(c.Since(t.Time)).String() + " ago"</span>
}

func Duration(t1, t2 *metav1.Time) string <span class="cov8" title="1">{
        if t1.IsZero() || t2.IsZero() </span><span class="cov8" title="1">{
                return nonAttributedStr
        }</span>
        <span class="cov8" title="1">return durafmt.ParseShort(t2.Sub(t1.Time)).String()</span>
}

// PRDuration calculates the duration of a repository run, given its status.
// It takes a RepositoryRunStatus object as input.
// It returns a string with the duration of the run, or nonAttributedStr if the run has not started or completed.
func PRDuration(runStatus v1alpha1.RepositoryRunStatus) string <span class="cov8" title="1">{
        if runStatus.StartTime == nil </span><span class="cov8" title="1">{
                return nonAttributedStr
        }</span>

        <span class="cov8" title="1">lasttime := runStatus.CompletionTime
        if lasttime == nil </span><span class="cov8" title="1">{
                if len(runStatus.Conditions) == 0 </span><span class="cov8" title="1">{
                        return nonAttributedStr
                }</span>
                <span class="cov8" title="1">lasttime = &amp;runStatus.Conditions[0].LastTransitionTime.Inner</span>
        }

        <span class="cov8" title="1">return Duration(runStatus.StartTime, lasttime)</span>
}

func Timeout(t *metav1.Duration) string <span class="cov8" title="1">{
        if t == nil </span><span class="cov8" title="1">{
                return nonAttributedStr
        }</span>
        <span class="cov8" title="1">return durafmt.Parse(t.Duration).String()</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package formatting

import "sort"

func UniqueStringArray(slice []string) []string <span class="cov8" title="1">{
        keys := make(map[string]bool)
        list := []string{}
        for _, entry := range slice </span><span class="cov8" title="1">{
                if _, value := keys[entry]; !value </span><span class="cov8" title="1">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov8" title="1">sort.Strings(list)
        return list</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package formatting

import (
        "fmt"

        corev1 "k8s.io/api/core/v1"
        knative1 "knative.dev/pkg/apis/duck/v1"
)

const nonAttributedStr = "---"

// formatCondition knative formatcondition with emoji or not.
func formatCondition(c knative1.Conditions, skipemoji bool) string <span class="cov8" title="1">{
        var status, emoji string
        if len(c) == 0 </span><span class="cov8" title="1">{
                return nonAttributedStr
        }</span>

        <span class="cov8" title="1">switch c[0].Status </span>{
        case corev1.ConditionFalse:<span class="cov8" title="1">
                emoji = ""
                status = "Failed"</span>
        case corev1.ConditionTrue:<span class="cov8" title="1">
                emoji = ""
                status = "Succeeded"</span>
        case corev1.ConditionUnknown:<span class="cov8" title="1">
                emoji = ""
                status = "Running"</span>
        default:<span class="cov0" title="0">
                emoji = ""
                status = "Pending"</span>
        }

        <span class="cov8" title="1">if !skipemoji </span><span class="cov8" title="1">{
                status = fmt.Sprintf("%s %s", emoji, status)
        }</span>

        <span class="cov8" title="1">return status</span>
}

func ConditionEmoji(c knative1.Conditions) string <span class="cov8" title="1">{
        return formatCondition(c, false)
}</span>

func ConditionSad(c knative1.Conditions) string <span class="cov8" title="1">{
        return formatCondition(c, true)
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package formatting

import (
        "strings"
)

// CleanValueKubernetes conform a string to kubernetes naming convention
// see https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names
// rules are:
//  contain at most 63 characters
//  contain only lowercase alphanumeric characters or '-'
//  start with an alphanumeric character
//  end with an alphanumeric character.
func CleanValueKubernetes(s string) string <span class="cov8" title="1">{
        if len(s) &gt;= 63 </span><span class="cov8" title="1">{
                // keep the last 62 characters
                s = s[len(s)-62:]
        }</span>

        <span class="cov8" title="1">replasoeur := strings.NewReplacer(":", "-", "/", "-", " ", "_", "[", "__", "]", "__")
        s = strings.TrimRight(s, " -_[]")
        s = strings.TrimLeft(s, " -_[]")
        replaced := replasoeur.Replace(s)
        return strings.TrimSpace(replaced)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package formatting

import (
        "regexp"
        "strings"
)

// CleanKubernetesName takes a string and performs the following actions to make it a valid
// Kubernetes resource name:
//
// 1. Converts the string to lowercase.
// 2. Trims leading and trailing whitespace.
// 3. Replaces any characters that are not lowercase alphanumeric characters, '-', or '.' with '-'.
//
// The resulting string is a valid Kubernetes resource name.
// Reference https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#dns-subdomain-names

func CleanKubernetesName(s string) string <span class="cov8" title="1">{
        regex := regexp.MustCompile(`[^a-z0-9\.-]`)
        s = strings.TrimSpace(strings.ToLower(s))
        replaced := regex.ReplaceAllString(s, "-")
        return replaced
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package formatting

import (
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/apis"
)

// PipelineRunStatus return status of PR  success failed or skipped.
func PipelineRunStatus(pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        if len(pr.Status.Conditions) == 0 </span><span class="cov8" title="1">{
                return "neutral"
        }</span>
        <span class="cov8" title="1">if pr.Status.GetCondition(apis.ConditionSucceeded).GetReason() == tektonv1.PipelineRunSpecStatusCancelled </span><span class="cov8" title="1">{
                return "cancelled"
        }</span>
        <span class="cov8" title="1">if pr.Status.Conditions[0].Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                return "failure"
        }</span>
        <span class="cov8" title="1">return "success"</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package formatting

import (
        "github.com/jonboulle/clockwork"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cli"
)

var shortShaLength = 7

func ShowLastSHA(repository v1alpha1.Repository) string <span class="cov8" title="1">{
        if len(repository.Status) == 0 </span><span class="cov8" title="1">{
                return nonAttributedStr
        }</span>
        <span class="cov8" title="1">return ShortSHA(*repository.Status[len(repository.Status)-1].SHA)</span>
}

func ShowStatus(repository v1alpha1.Repository, cs *cli.ColorScheme) string <span class="cov8" title="1">{
        if len(repository.Status) == 0 </span><span class="cov8" title="1">{
                return cs.ColorStatus("NoRun")
        }</span>
        <span class="cov8" title="1">status := repository.Status[len(repository.Status)-1].Status.Conditions[0].GetReason()
        logurl := repository.Status[len(repository.Status)-1].LogURL
        return cs.HyperLink(cs.ColorStatus(status), *logurl)</span>
}

func ShowLastAge(repository v1alpha1.Repository, cw clockwork.Clock) string <span class="cov8" title="1">{
        if len(repository.Status) == 0 </span><span class="cov8" title="1">{
                return nonAttributedStr
        }</span>
        <span class="cov8" title="1">return Age(repository.Status[len(repository.Status)-1].CompletionTime, cw)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package formatting

import (
        "bytes"
        _ "embed"
        "text/template"
)

//go:embed templates/starting.go.tmpl
var StartingPipelineRunHTML string

//go:embed templates/starting.markdown.go.tmpl
var StartingPipelineRunMarkdown string

//go:embed templates/queuing.go.tmpl
var QueuingPipelineRunHTML string

//go:embed templates/queuing.markdown.go.tmpl
var QueuingPipelineRunMarkdown string

//go:embed templates/pipelinerunstatus.tmpl
var PipelineRunStatusHTML string

//go:embed templates/pipelinerunstatus_markdown.tmpl
var PipelineRunStatusMarkDown string

type MessageTemplate struct {
        PipelineRunName string
        Namespace       string
        NamespaceURL    string
        ConsoleName     string
        ConsoleURL      string
        TknBinary       string
        TknBinaryURL    string
        TaskStatus      string
        FailureSnippet  string
}

func (mt MessageTemplate) MakeTemplate(tmpl string) (string, error) <span class="cov8" title="1">{
        outputBuffer := bytes.Buffer{}
        t := template.Must(template.New("Message").Parse(tmpl))
        data := struct{ Mt MessageTemplate }{Mt: mt}
        if err := t.Execute(&amp;outputBuffer, data); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return outputBuffer.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package formatting

import (
        "fmt"
        "net/url"
        "path/filepath"
        "strings"

        "golang.org/x/text/cases"
        "golang.org/x/text/language"
)

// SanitizeBranch remove refs/heads from string, only removing the first prefix
// in case we have branch that are actually called refs-heads .
func SanitizeBranch(s string) string <span class="cov8" title="1">{
        if strings.HasPrefix(s, "refs/heads/") </span><span class="cov8" title="1">{
                return strings.TrimPrefix(s, "refs/heads/")
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(s, "refs-heads-") </span><span class="cov8" title="1">{
                return strings.TrimPrefix(s, "refs-heads-")
        }</span>
        <span class="cov8" title="1">return s</span>
}

// ShortSHA returns a shortsha.
func ShortSHA(sha string) string <span class="cov8" title="1">{
        if sha == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if shortShaLength &gt;= len(sha)+1 </span><span class="cov8" title="1">{
                return sha
        }</span>
        <span class="cov8" title="1">return sha[0:shortShaLength]</span>
}

func GetRepoOwnerFromURL(ghURL string) (string, error) <span class="cov8" title="1">{
        org, repo, err := GetRepoOwnerSplitted(ghURL)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">repo = strings.TrimSuffix(repo, "/")
        return strings.ToLower(fmt.Sprintf("%s/%s", org, repo)), nil</span>
}

func GetRepoOwnerSplitted(u string) (string, string, error) <span class="cov8" title="1">{
        uparse, err := url.Parse(u)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">parts := strings.Split(uparse.Path, "/")
        if len(parts) &lt; 3 </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid repo url at least a organization/project and a repo needs to be specified: %s", u)
        }</span>
        <span class="cov8" title="1">org := filepath.Join(parts[0 : len(parts)-1]...)
        repo := parts[len(parts)-1]
        return org, repo, nil</span>
}

// CamelCasit pull_request &gt; PullRequest.
func CamelCasit(s string) string <span class="cov8" title="1">{
        c := cases.Title(language.AmericanEnglish)
        return strings.ReplaceAll(c.String(strings.ReplaceAll(s, "_", " ")), " ", "")
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package git

import (
        "bytes"
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"
)

type Info struct {
        URL          string
        TopLevelPath string
        SHA          string
        Branch       string
}

func RunGit(dir string, args ...string) (string, error) <span class="cov8" title="1">{
        gitPath, err := exec.LookPath("git")
        if err != nil </span><span class="cov0" title="0">{
                //nolint: nilerr
                return "", nil
        }</span>
        // insert in args "-c", "gitcommit.gpgsign=false" at the beginning gpg sign when set in user
        <span class="cov8" title="1">args = append([]string{"-c", "commit.gpgsign=false"}, args...)

        c := exec.CommandContext(context.Background(), gitPath, args...)
        c.Env = []string{
                "PATH=" + os.Getenv("PATH"),
                "HOME=" + os.Getenv("HOME"),
                "LC_ALL=C",
                "LANG=C",
        }
        var output bytes.Buffer
        c.Stderr = &amp;output
        c.Stdout = &amp;output
        // This is the optional working directory. If not set, it defaults to the current
        // working directory of the process.
        if dir != "" </span><span class="cov8" title="1">{
                c.Dir = dir
        }</span>
        <span class="cov8" title="1">if err := c.Run(); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("error running, %s, output: %s error: %w", args, output.String(), err)
        }</span>
        <span class="cov8" title="1">return output.String(), nil</span>
}

// GetGitInfo try to detect the current remote for this URL return the origin url transformed and the topdir.
func GetGitInfo(dir string) *Info <span class="cov8" title="1">{
        brootdir, err := RunGit(dir, "rev-parse", "--show-toplevel")
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Info{}
        }</span>

        <span class="cov8" title="1">sha, err := RunGit(dir, "rev-parse", "HEAD")
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Info{}
        }</span>

        <span class="cov8" title="1">headbranch, err := RunGit(dir, "rev-parse", "--abbrev-ref", "HEAD")
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Info{}
        }</span>

        <span class="cov8" title="1">gitURL, err := RunGit(dir, "remote", "get-url", "origin")
        if err != nil </span><span class="cov8" title="1">{
                gitURL, err = RunGit(dir, "remote", "get-url", "upstream")
                if err != nil </span><span class="cov8" title="1">{
                        // use top dir name as fallback
                        gitURL = brootdir
                }</span>
        }
        <span class="cov8" title="1">gitURL = strings.TrimSpace(gitURL)
        gitURL = strings.TrimSuffix(gitURL, ".git")

        // convert github and probably others ssh access format into https
        // i think it only fails with bitbucket data center
        if strings.HasPrefix(gitURL, "git@") </span><span class="cov8" title="1">{
                sp := strings.Split(gitURL, ":")
                prefix := strings.ReplaceAll(sp[0], "git@", "https://")
                gitURL = fmt.Sprintf("%s/%s", prefix, strings.Join(sp[1:], ":"))
        }</span>

        <span class="cov8" title="1">return &amp;Info{
                URL:          gitURL,
                TopLevelPath: strings.TrimSpace(brootdir),
                SHA:          strings.TrimSpace(sha),
                Branch:       strings.TrimSpace(headbranch),
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright  2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hub

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
)

const (
        artifactHubTaskType                   = "tekton-task"
        artifactHubPipelineType               = "tekton-pipeline"
        defaultArtifactHubCatalogTaskName     = "tekton-catalog-tasks"
        defaultArtifactHubCatalogPipelineName = "tekton-catalog-pipelines"
)

// artifactHubClient is a client for the Artifact Hub.
type artifactHubClient struct {
        params *params.Run
        url    string
        name   string
}

// newArtifactHubClient returns a new Artifact Hub client.
func newArtifactHubClient(params *params.Run, url, name string) Client <span class="cov8" title="1">{
        url = strings.TrimSuffix(url, "/") // Trim any trailing slash
        if !strings.HasSuffix(url, "/api/v1") </span><span class="cov8" title="1">{
                url = fmt.Sprintf("%s/api/v1", url)
        }</span>
        <span class="cov8" title="1">return &amp;artifactHubClient{params: params, url: url, name: name}</span>
}

// GetResource gets a resource from the Artifact Hub.
func (a *artifactHubClient) GetResource(ctx context.Context, _, resource, kind string) (string, error) <span class="cov8" title="1">{
        var data string
        var err error

        if strings.Contains(resource, ":") </span><span class="cov8" title="1">{
                data, err = a.getSpecificVersion(ctx, a.name, resource, kind)
        }</span> else<span class="cov8" title="1"> {
                data, err = a.getLatestVersion(ctx, a.name, resource, kind)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("could not fetch remote %s %s, artifacthub API returned: %w", kind, resource, err)
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

func getArtifactHubTypeByKind(catalogName, kind string) (string, string) <span class="cov8" title="1">{
        var pkgType string
        switch kind </span>{
        case "task":<span class="cov8" title="1">
                pkgType = artifactHubTaskType
                if catalogName == "default" || catalogName == "" </span><span class="cov8" title="1">{
                        catalogName = defaultArtifactHubCatalogTaskName
                }</span>
        case "pipeline":<span class="cov8" title="1">
                pkgType = artifactHubPipelineType
                if catalogName == "default" || catalogName == "" </span><span class="cov8" title="1">{
                        catalogName = defaultArtifactHubCatalogPipelineName
                }</span>
                // For other kinds, no changes are made.
        }

        <span class="cov8" title="1">return pkgType, catalogName</span>
}

// getLatestVersion gets the latest version of a resource from the Artifact Hub.
// url is like:
// https://artifacthub.io/api/v1/packages/tekton-task/tekton-catalog-tasks/git-clone
func (a *artifactHubClient) getLatestVersion(ctx context.Context, catalogName, resource, kind string) (string, error) <span class="cov8" title="1">{
        pkgType, catalogName := getArtifactHubTypeByKind(catalogName, kind)
        url := fmt.Sprintf("%s/packages/%s/%s/%s", a.url, pkgType, catalogName, resource)
        resp := new(artifactHubPkgResponse)
        data, err := a.params.Clients.GetURL(ctx, url)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("could not fetch %s %s from hub, url: %s: %w", kind, resource, url, err)
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;resp)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("could not unmarshal response from hub, url: %s: %w", url, err)
        }</span>
        <span class="cov8" title="1">if resp.Data.ManifestRaw == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("manifest is empty in hub response for, url: %s %s", url, resource)
        }</span>
        <span class="cov8" title="1">return resp.Data.ManifestRaw, nil</span>
}

// getSpecificVersion gets a specific version of a resource from the Artifact Hub.
// url is like:
// https://artifacthub.io/api/v1/packages/tekton-task/tekton-catalog-tasks/git-clone/0.9.0
func (a *artifactHubClient) getSpecificVersion(ctx context.Context, catalogName, resource, kind string) (string, error) <span class="cov8" title="1">{
        pkgType, catalogName := getArtifactHubTypeByKind(catalogName, kind)

        split := strings.Split(resource, ":")
        version := split[len(split)-1]
        resourceName := split[0]

        url := fmt.Sprintf("%s/packages/%s/%s/%s/%s", a.url, pkgType, catalogName, resourceName, version)
        resp := new(artifactHubPkgResponse)
        data, err := a.params.Clients.GetURL(ctx, url)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("could not fetch %s %s from hub, url: %s: %w", kind, resource, url, err)
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;resp)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("could not unmarshal response from hub, url: %s: %w", url, err)
        }</span>
        <span class="cov8" title="1">if resp.Data.ManifestRaw == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("manifest is empty in hub response for, url: %s %s", url, resource)
        }</span>
        <span class="cov8" title="1">return resp.Data.ManifestRaw, nil</span>
}

// artifactHubPkgResponse is the response from the Artifact Hub API.
// It contains a `data` field, which holds the package data, including the raw manifest.
// The JSON structure is as follows:
//
//        {
//          "data": {
//            "manifestRaw": "&lt;raw manifest content&gt;"
//          }
//        }
type artifactHubPkgResponse struct {
        Data artifactHubPkgData `json:"data,omitempty"`
}

// artifactHubPkgData represents the data field in the response from the Artifact Hub API.
// It contains the raw manifest of a Tekton resource (e.g., task or pipeline) as a string.
// The JSON structure it maps to is:
//
//        {
//          "manifestRaw": "&lt;raw manifest content&gt;"
//        }
type artifactHubPkgData struct {
        ManifestRaw string `json:"manifestRaw"`
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright  2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hub

import (
        "context"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
)

// GetResource returns a resource from the hub.
func GetResource(ctx context.Context, cs *params.Run, catalogName, resource, kind string) (string, error) <span class="cov8" title="1">{
        client, err := NewClient(ctx, cs, catalogName)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return client.GetResource(ctx, catalogName, resource, kind)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright  2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hub

import (
        "context"
        "fmt"

        hubtypes "github.com/openshift-pipelines/pipelines-as-code/pkg/hub/vars"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
)

// Client is an interface for a hub client.
type Client interface {
        GetResource(ctx context.Context, catalogName, resource, kind string) (string, error)
}

// NewClient returns a new hub client.
func NewClient(_ context.Context, cs *params.Run, catalogName string) (Client, error) <span class="cov8" title="1">{
        value, ok := cs.Info.Pac.HubCatalogs.Load(catalogName)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not get details for catalog name: %s", catalogName)
        }</span>
        <span class="cov8" title="1">catalogValue, ok := value.(settings.HubCatalog)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not get details for catalog name: %s", catalogName)
        }</span>

        <span class="cov8" title="1">switch catalogValue.Type </span>{
        case hubtypes.TektonHubType:<span class="cov8" title="1">
                return newTektonHubClient(cs, catalogValue.URL, catalogValue.Name), nil</span>
        default:<span class="cov8" title="1">
                // defaulting to Artifact Hub
                return newArtifactHubClient(cs, catalogValue.URL, catalogValue.Name), nil</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright  2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hub

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
)

// tektonHubClient is a client for the Tekton Hub.
type tektonHubClient struct {
        params *params.Run
        url    string
        name   string
}

// newTektonHubClient returns a new Tekton Hub client.
func newTektonHubClient(params *params.Run, url, name string) Client <span class="cov8" title="1">{
        return &amp;tektonHubClient{params: params, url: url, name: name}
}</span>

type resourceVersionDataResponseBody struct {
        // ID is the unique id of resource's version
        ID *uint `json:"id,omitempty"`
        // Version of resource
        Version *string `json:"version,omitempty"`
        // Display name of version
        DisplayName *string `json:"displayName,omitempty"`
        // Description of version
        Description *string `json:"description,omitempty"`
        // Minimum pipelines version the resource's version is compatible with
        MinPipelinesVersion *string `json:"minPipelinesVersion,omitempty"`
        // Raw URL of resource's yaml file of the version
        RawURL *string `json:"rawURL,omitempty"`
        // Web URL of resource's yaml file of the version
        WebURL *string `json:"webURL,omitempty"`
        // Timestamp when version was last updated
        UpdatedAt *string `json:"updatedAt,omitempty"`
}

type hubResourceResponseBody struct {
        // ID is the unique id of the resource
        ID *uint `json:"id,omitempty"`
        // Name of resource
        Name *string `json:"name,omitempty"`
        // Kind of resource
        Kind *string `json:"kind,omitempty"`
        // Latest version of resource
        LatestVersion *resourceVersionDataResponseBody `json:"latestVersion,omitempty"`
        // List of all versions of a resource
        Versions []*resourceVersionDataResponseBody `json:"versions,omitempty"`
}

type hubResource struct {
        Data *hubResourceResponseBody `json:"data,omitempty"`
}

type hubResourceVersion struct {
        Data *resourceVersionDataResponseBody `json:"data,omitempty"`
}

// GetResource gets a resource from the Tekton Hub.
func (t *tektonHubClient) GetResource(ctx context.Context, _, resource, kind string) (string, error) <span class="cov0" title="0">{
        var rawURL string
        var err error

        if strings.Contains(resource, ":") </span><span class="cov0" title="0">{
                rawURL, err = t.getSpecificVersion(ctx, t.name, resource, kind)
        }</span> else<span class="cov0" title="0"> {
                rawURL, err = t.getLatestVersion(ctx, t.name, resource, kind)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not fetch remote %s %s, hub API returned: %w", kind, resource, err)
        }</span>

        <span class="cov0" title="0">data, err := t.params.Clients.GetURL(ctx, rawURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not fetch remote %s %s, hub API returned: %w", kind, resource, err)
        }</span>
        <span class="cov0" title="0">return string(data), err</span>
}

func (t *tektonHubClient) getSpecificVersion(ctx context.Context, catalogName, resource, kind string) (string, error) <span class="cov0" title="0">{
        split := strings.Split(resource, ":")
        version := split[len(split)-1]
        resourceName := split[0]
        url := fmt.Sprintf("%s/resource/%s/%s/%s/%s", t.url, catalogName, kind, resourceName, version)
        hr := hubResourceVersion{}
        data, err := t.params.Clients.GetURL(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not fetch specific %s version from the hub %s:%s: %w", kind, resource, version, err)
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;hr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s/raw", url), nil</span>
}

func (t *tektonHubClient) getLatestVersion(ctx context.Context, catalogName, resource, kind string) (string, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/resource/%s/%s/%s", t.url, catalogName, kind, resource)
        hr := new(hubResource)
        data, err := t.params.Clients.GetURL(ctx, url)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">err = json.Unmarshal(data, &amp;hr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s/%s/raw", url, *hr.Data.LatestVersion.Version), nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package kubeinteraction

import (
        "context"
        "fmt"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        psort "github.com/openshift-pipelines/pipelines-as-code/pkg/sort"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

func (k Interaction) CleanupPipelines(ctx context.Context, logger *zap.SugaredLogger, repo *v1alpha1.Repository, pr *tektonv1.PipelineRun, maxKeep int) error <span class="cov8" title="1">{
        if _, ok := pr.GetAnnotations()[keys.OriginalPRName]; !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("generated pipelinerun should have had the %s label for selection set but we could not find it", keys.OriginalPRName)
        }</span>

        // Select PR by repository and by its true pipelineRun name (not auto generated one)
        <span class="cov8" title="1">labelSelector := fmt.Sprintf("%s=%s,%s=%s,%s=%s",
                keys.Repository, formatting.CleanValueKubernetes(repo.GetName()), keys.OriginalPRName,
                formatting.CleanValueKubernetes(pr.GetLabels()[keys.OriginalPRName]),
                keys.State, StateCompleted)
        logger.Infof("selecting pipelineruns by labels \"%s\" for deletion", labelSelector)

        pruns, err := k.Run.Clients.Tekton.TektonV1().PipelineRuns(repo.GetNamespace()).List(ctx,
                metav1.ListOptions{LabelSelector: labelSelector})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for c, prun := range psort.PipelineRunSortByCompletionTime(pruns.Items) </span><span class="cov8" title="1">{
                prReason := prun.GetStatusCondition().GetCondition(apis.ConditionSucceeded).GetReason()
                if prReason == tektonv1.PipelineRunReasonRunning.String() || prReason == tektonv1.PipelineRunReasonPending.String() </span><span class="cov8" title="1">{
                        logger.Infof("skipping cleaning PipelineRun %s since the conditions.reason is %s", prun.GetName(), prReason)
                        continue</span>
                }

                <span class="cov8" title="1">if c &gt;= maxKeep </span><span class="cov8" title="1">{
                        logger.Infof("cleaning old PipelineRun: %s", prun.GetName())
                        err := k.Run.Clients.Tekton.TektonV1().PipelineRuns(repo.GetNamespace()).Delete(
                                ctx, prun.GetName(), metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Try to Delete the secret created for git-clone basic-auth, it should have been created with a ownerRef on the pipelinerun and due being deleted when the pipelinerun is deleted
                        // but in some cases of conflicts and the ownerRef not being set, the secret is not deleted, and we need to delete it manually.
                        <span class="cov8" title="1">if secretName, ok := prun.GetAnnotations()[keys.GitAuthSecret]; ok </span><span class="cov8" title="1">{
                                err = k.Run.Clients.Kube.CoreV1().Secrets(repo.GetNamespace()).Delete(ctx, secretName, metav1.DeleteOptions{})
                                if err == nil </span><span class="cov8" title="1">{
                                        logger.Infof("secret %s attached to pipelinerun %s has been deleted", secretName, prun.GetName())
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package kubeinteraction

import (
        "context"

        "github.com/google/go-github/v74/github"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (k Interaction) GetEvents(ctx context.Context, ns, objtype, name string) (*corev1.EventList, error) <span class="cov0" title="0">{
        kclient := k.Run.Clients.Kube.CoreV1()
        selector := kclient.Events(ns).GetFieldSelector(github.Ptr(name), github.Ptr(ns), github.Ptr(objtype), nil)
        events, err := kclient.Events(ns).List(ctx, metav1.ListOptions{FieldSelector: selector.String()})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return events, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package kubeinteraction

import (
        "context"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        ktypes "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/types"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
)

type Interface interface {
        CleanupPipelines(context.Context, *zap.SugaredLogger, *v1alpha1.Repository, *pipelinev1.PipelineRun, int) error
        CreateSecret(ctx context.Context, ns string, secret *corev1.Secret) error
        DeleteSecret(context.Context, *zap.SugaredLogger, string, string) error
        UpdateSecretWithOwnerRef(context.Context, *zap.SugaredLogger, string, string, *pipelinev1.PipelineRun) error
        GetSecret(context.Context, ktypes.GetSecretOpt) (string, error)
        GetPodLogs(context.Context, string, string, string, int64) (string, error)
}

type Interaction struct {
        Run *params.Run
}

// validate the interface implementation.
var _ Interface = (*Interaction)(nil)

func NewKubernetesInteraction(c *params.Run) (*Interaction, error) <span class="cov8" title="1">{
        return &amp;Interaction{
                Run: c,
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package kubeinteraction

import (
        "fmt"
        "strconv"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/version"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

const (
        StateStarted   = "started"
        StateQueued    = "queued"
        StateCompleted = "completed"
        StateFailed    = "failed"
)

func AddLabelsAndAnnotations(event *info.Event, pipelineRun *tektonv1.PipelineRun, repo *apipac.Repository, providerConfig *info.ProviderConfig, paramsRun *params.Run) error <span class="cov8" title="1">{
        if event == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("event should not be nil")
        }</span>
        <span class="cov8" title="1">paramsinfo := paramsRun.Info
        // Add labels on the soon-to-be created pipelinerun so UI/CLI can easily
        // query them.
        labels := map[string]string{
                // These keys are used in LabelSelector query, so we are keeping in Labels as it is.
                // But adding same keys to Annotations so UI/CLI can fetch the actual value instead of modified value
                "app.kubernetes.io/managed-by": pipelinesascode.GroupName,
                "app.kubernetes.io/version":    formatting.CleanValueKubernetes(version.Version),
                keys.URLOrg:                    formatting.CleanValueKubernetes(event.Organization),
                keys.URLRepository:             formatting.CleanValueKubernetes(event.Repository),
                keys.SHA:                       formatting.CleanValueKubernetes(event.SHA),
                keys.Repository:                formatting.CleanValueKubernetes(repo.GetName()),
                keys.State:                     StateStarted,
                keys.EventType:                 formatting.CleanValueKubernetes(event.EventType),
        }

        annotations := map[string]string{
                keys.ShaTitle:      event.SHATitle,
                keys.ShaURL:        event.SHAURL,
                keys.RepoURL:       event.URL,
                keys.SourceRepoURL: event.HeadURL,
                keys.URLOrg:        event.Organization,
                keys.URLRepository: event.Repository,
                keys.SHA:           event.SHA,
                keys.Sender:        event.Sender,
                keys.EventType:     event.EventType,
                keys.Branch:        event.BaseBranch,
                keys.SourceBranch:  event.HeadBranch,
                keys.Repository:    repo.GetName(),
                keys.GitProvider:   providerConfig.Name,
                keys.ControllerInfo: fmt.Sprintf(`{"name":"%s","configmap":"%s","secret":"%s", "gRepo": "%s"}`,
                        paramsinfo.Controller.Name, paramsinfo.Controller.Configmap, paramsinfo.Controller.Secret, paramsinfo.Controller.GlobalRepository),
        }

        if event.PullRequestNumber != 0 </span><span class="cov0" title="0">{
                labels[keys.PullRequest] = strconv.Itoa(event.PullRequestNumber)
                annotations[keys.PullRequest] = strconv.Itoa(event.PullRequestNumber)
        }</span>

        // TODO: move to provider specific function
        <span class="cov8" title="1">if providerConfig.Name == "github" || providerConfig.Name == "github-enterprise" </span><span class="cov0" title="0">{
                if event.InstallationID != -1 </span><span class="cov0" title="0">{
                        annotations[keys.InstallationID] = strconv.FormatInt(event.InstallationID, 10)
                }</span>
                <span class="cov0" title="0">if event.GHEURL != "" </span><span class="cov0" title="0">{
                        annotations[keys.GHEURL] = event.GHEURL
                }</span>
        }

        // GitLab
        <span class="cov8" title="1">if event.SourceProjectID != 0 </span><span class="cov0" title="0">{
                annotations[keys.SourceProjectID] = strconv.Itoa(event.SourceProjectID)
        }</span>
        <span class="cov8" title="1">if event.TargetProjectID != 0 </span><span class="cov0" title="0">{
                annotations[keys.TargetProjectID] = strconv.Itoa(event.TargetProjectID)
        }</span>

        <span class="cov8" title="1">if value, ok := pipelineRun.GetObjectMeta().GetAnnotations()[keys.CancelInProgress]; ok </span><span class="cov8" title="1">{
                labels[keys.CancelInProgress] = value
        }</span>

        <span class="cov8" title="1">for k, v := range labels </span><span class="cov8" title="1">{
                pipelineRun.Labels[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range annotations </span><span class="cov8" title="1">{
                pipelineRun.Annotations[k] = v
        }</span>

        // Add annotations to PipelineRuns to integrate with Tekton Results
        <span class="cov8" title="1">err := AddResultsAnnotation(event, pipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add results annotations with error: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package kubeinteraction

import (
        "context"
        "io"

        "github.com/google/go-github/v74/github"
        corev1 "k8s.io/api/core/v1"
)

// GetPodLogs of a ns on a podname and container, tailLines is the number of
// line to tail -1 mean unlimited.
func (k Interaction) GetPodLogs(ctx context.Context, ns, podName, containerName string, tailLines int64) (string, error) <span class="cov0" title="0">{
        kclient := k.Run.Clients.Kube.CoreV1()
        pdOpts := &amp;corev1.PodLogOptions{
                Container: containerName,
        }
        if tailLines &gt; 0 </span><span class="cov0" title="0">{
                pdOpts.TailLines = github.Ptr(tailLines)
        }</span>
        <span class="cov0" title="0">ios, err := kclient.Pods(ns).GetLogs(podName, pdOpts).Stream(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">log, err := io.ReadAll(ios)
        return string(log), err</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package kubeinteraction

import (
        "encoding/json"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

type ResultAnnotation struct {
        Repo          string `json:"repo"`
        Commit        string `json:"commit"`
        EventType     string `json:"eventType"`
        PullRequestID int    `json:"pull_request-id,omitempty"`
}

// Add annotation to PipelineRuns produced by PaC for capturing additional
// data specific for TektonResults.
func AddResultsAnnotation(event *info.Event, pipelineRun *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        resultAnnotation := ResultAnnotation{
                Repo:          event.Repository,
                Commit:        event.SHA,
                EventType:     event.EventType,
                PullRequestID: event.PullRequestNumber,
        }

        resAnnotationJSON, err := json.Marshal(resultAnnotation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // append the result annotation
        <span class="cov8" title="1">pipelineRun.Annotations[keys.ResultsRecordSummary] = string(resAnnotationJSON)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package kubeinteraction

import (
        "context"
        "fmt"

        ktypes "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/types"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/util/retry"
)

func (k Interaction) GetSecret(ctx context.Context, secretopt ktypes.GetSecretOpt) (string, error) <span class="cov0" title="0">{
        secret, err := k.Run.Clients.Kube.CoreV1().Secrets(secretopt.Namespace).Get(
                ctx, secretopt.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(secret.Data[secretopt.Key]), nil</span>
}

// DeleteSecret deletes the secret created for git-clone basic-auth.
func (k Interaction) DeleteSecret(ctx context.Context, _ *zap.SugaredLogger, targetNamespace, secretName string) error <span class="cov8" title="1">{
        err := k.Run.Clients.Kube.CoreV1().Secrets(targetNamespace).Delete(ctx, secretName, metav1.DeleteOptions{})
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UpdateSecretWithOwnerRef updates the secret with ownerReference.
func (k Interaction) UpdateSecretWithOwnerRef(ctx context.Context, logger *zap.SugaredLogger, targetNamespace, secretName string, pr *pipelinev1.PipelineRun) error <span class="cov8" title="1">{
        controllerOwned := false
        ownerRef := &amp;metav1.OwnerReference{
                APIVersion:         pr.GetGroupVersionKind().GroupVersion().String(),
                Kind:               pr.GetGroupVersionKind().Kind,
                Name:               pr.GetName(),
                UID:                pr.GetUID(),
                BlockOwnerDeletion: &amp;controllerOwned,
                Controller:         &amp;controllerOwned,
        }
        err := retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov8" title="1">{
                secret, err := k.Run.Clients.Kube.CoreV1().Secrets(targetNamespace).Get(ctx, secretName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">secret.OwnerReferences = []metav1.OwnerReference{*ownerRef}

                _, err = k.Run.Clients.Kube.CoreV1().Secrets(targetNamespace).Update(ctx, secret, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Infof("failed to update secret, retrying  %v/%v: %v", targetNamespace, secretName, err)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update secret with ownerRef %v/%v: %w", targetNamespace, secretName, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (k Interaction) CreateSecret(ctx context.Context, ns string, secret *corev1.Secret) error <span class="cov0" title="0">{
        _, err := k.Run.Clients.Kube.CoreV1().Secrets(ns).Create(ctx, secret, metav1.CreateOptions{})
        return err
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package status

import (
        "context"
        "fmt"
        "regexp"
        "strings"
        "unicode/utf8"

        pacv1alpha1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

var reasonMessageReplacementRegexp = regexp.MustCompile(`\(image: .*`)

const maxErrorSnippetCharacterLimit = 65535 // This is the maximum size allowed by Github check run logs and may apply to all other providers

// GetTaskRunStatusForPipelineTask takes a minimal embedded status child reference and returns the actual TaskRunStatus
// for the PipelineTask. It returns an error if the child reference's kind isn't TaskRun.
func GetTaskRunStatusForPipelineTask(ctx context.Context, client versioned.Interface, ns string, childRef tektonv1.ChildStatusReference) (*tektonv1.TaskRunStatus, error) <span class="cov8" title="1">{
        if childRef.Kind != "TaskRun" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("could not fetch status for PipelineTask %s: should have kind TaskRun, but is %s", childRef.PipelineTaskName, childRef.Kind)
        }</span>

        <span class="cov8" title="1">tr, err := client.TektonV1().TaskRuns(ns).Get(ctx, childRef.Name, metav1.GetOptions{})
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if tr == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return &amp;tr.Status, nil</span>
}

// GetStatusFromTaskStatusOrFromAsking will return the status of the taskruns,
// it would use the embedded one if it's available (pre tekton 0.44.0) or try
// to get it from the child references.
func GetStatusFromTaskStatusOrFromAsking(ctx context.Context, pr *tektonv1.PipelineRun, run *params.Run) map[string]*tektonv1.PipelineRunTaskRunStatus <span class="cov8" title="1">{
        trStatus := map[string]*tektonv1.PipelineRunTaskRunStatus{}
        for _, cr := range pr.Status.ChildReferences </span><span class="cov8" title="1">{
                ts, err := GetTaskRunStatusForPipelineTask(
                        ctx, run.Clients.Tekton, pr.GetNamespace(), cr,
                )
                if err != nil </span><span class="cov8" title="1">{
                        run.Clients.Log.Warnf("cannot get taskrun status pr %s ns: %s err: %w", pr.GetName(), pr.GetNamespace(), err)
                        continue</span>
                }
                <span class="cov8" title="1">if ts == nil </span><span class="cov0" title="0">{
                        run.Clients.Log.Warnf("cannot get taskrun status pr %s ns: %s, ts come back nil?", pr.GetName(), pr.GetNamespace(), err)
                        continue</span>
                }
                // search in taskSpecs if there is a displayName for that status
                <span class="cov8" title="1">if pr.Spec.PipelineSpec != nil &amp;&amp; pr.Spec.PipelineSpec.Tasks != nil </span><span class="cov8" title="1">{
                        for _, taskSpec := range pr.Spec.PipelineSpec.Tasks </span><span class="cov8" title="1">{
                                if ts.TaskSpec != nil &amp;&amp; taskSpec.Name == cr.PipelineTaskName </span><span class="cov8" title="1">{
                                        ts.TaskSpec.DisplayName = taskSpec.DisplayName
                                }</span>
                        }
                }
                <span class="cov8" title="1">trStatus[cr.Name] = &amp;tektonv1.PipelineRunTaskRunStatus{
                        PipelineTaskName: cr.PipelineTaskName,
                        Status:           ts,
                }</span>
        }
        <span class="cov8" title="1">return trStatus</span>
}

// CollectFailedTasksLogSnippet collects all tasks information we are interested in.
// should really be in a tektoninteractions package but i lack imagination at the moment.
func CollectFailedTasksLogSnippet(ctx context.Context, cs *params.Run, kinteract kubeinteraction.Interface, pr *tektonv1.PipelineRun, numLines int64) map[string]pacv1alpha1.TaskInfos <span class="cov8" title="1">{
        failureReasons := map[string]pacv1alpha1.TaskInfos{}
        if pr == nil </span><span class="cov0" title="0">{
                return failureReasons
        }</span>

        <span class="cov8" title="1">trStatus := GetStatusFromTaskStatusOrFromAsking(ctx, pr, cs)
        for _, task := range trStatus </span><span class="cov8" title="1">{
                if task.Status == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(task.Status.Conditions) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">ti := pacv1alpha1.TaskInfos{
                        Name:           task.PipelineTaskName,
                        Message:        reasonMessageReplacementRegexp.ReplaceAllString(task.Status.Conditions[0].Message, ""),
                        CompletionTime: task.Status.CompletionTime,
                        Reason:         task.Status.Conditions[0].Reason,
                }
                if task.Status.TaskSpec != nil </span><span class="cov8" title="1">{
                        ti.DisplayName = task.Status.TaskSpec.DisplayName
                }</span>
                // don't check for pod logs into those
                <span class="cov8" title="1">if ti.Reason == "TaskRunValidationFailed" || ti.Reason == tektonv1.TaskRunReasonCancelled.String() || ti.Reason == tektonv1.TaskRunReasonTimedOut.String() || ti.Reason == tektonv1.TaskRunReasonImagePullFailed.String() </span><span class="cov0" title="0">{
                        failureReasons[task.PipelineTaskName] = ti
                        continue</span>
                } else<span class="cov8" title="1"> if ti.Reason != tektonv1.PipelineRunReasonFailed.String() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if kinteract != nil </span><span class="cov8" title="1">{
                        for _, step := range task.Status.Steps </span><span class="cov8" title="1">{
                                if step.Terminated != nil &amp;&amp; step.Terminated.ExitCode != 0 </span><span class="cov8" title="1">{
                                        log, err := kinteract.GetPodLogs(ctx, pr.GetNamespace(), task.Status.PodName, step.Container, numLines)
                                        if err != nil </span><span class="cov0" title="0">{
                                                cs.Clients.Log.Errorf("cannot get pod logs: %w", err)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">trimmed := strings.TrimSpace(log)
                                        if strings.HasSuffix(trimmed, " Skipping step because a previous step failed") </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        // GitHub's character limit is actually in bytes, not unicode characters
                                        // Truncate to maxErrorSnippetCharacterLimit bytes, then trim to last valid UTF-8 boundary
                                        <span class="cov8" title="1">if len(trimmed) &gt; maxErrorSnippetCharacterLimit </span><span class="cov8" title="1">{
                                                trimmed = trimmed[:maxErrorSnippetCharacterLimit]
                                                // Trim further to last valid rune boundary to ensure valid UTF-8
                                                r, size := utf8.DecodeLastRuneInString(trimmed)
                                                for r == utf8.RuneError &amp;&amp; size &gt; 0 </span><span class="cov0" title="0">{
                                                        trimmed = trimmed[:len(trimmed)-size]
                                                        r, size = utf8.DecodeLastRuneInString(trimmed)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">ti.LogSnippet = trimmed</span>
                                }
                        }
                }
                <span class="cov8" title="1">failureReasons[task.PipelineTaskName] = ti</span>
        }
        <span class="cov8" title="1">return failureReasons</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package kubeinteraction

import (
        "context"
        "fmt"
        "time"

        "k8s.io/apimachinery/pkg/util/wait"
)

const (
        interval = 1 * time.Second
)

func PollImmediateWithContext(ctx context.Context, pollTimeout time.Duration, fn func() (bool, error)) error <span class="cov8" title="1">{
        //nolint: staticcheck
        return wait.PollImmediate(interval, pollTimeout, func() (bool, error) </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return true, fmt.Errorf("polling timed out, pipelinerun has exceeded its timeout: %v", pollTimeout)</span>
                default:<span class="cov8" title="1"></span>
                }
                <span class="cov8" title="1">return fn()</span>
        })
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package matcher

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        pacerrors "github.com/openshift-pipelines/pipelines-as-code/pkg/errors"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"

        "github.com/gobwas/glob"
        "github.com/google/cel-go/common/types"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

const (
        // regex allows array of string or a single string
        // eg. ["foo", "bar"], ["foo"] or "foo".
        reValidateTag = `^\[(.*)\]$|^[^[\]\s]*$`
        // maximum number of characters to display in logs for gitops comments.
        maxCommentLogLength = 160
)

// prunBranch is value from annotations and baseBranch is event.Base value from event.
func branchMatch(prunBranch, baseBranch string) bool <span class="cov8" title="1">{
        // Helper function to match glob pattern
        matchGlob := func(pattern, branch string) bool </span><span class="cov8" title="1">{
                g := glob.MustCompile(pattern)
                return g.Match(branch)
        }</span>

        // Case: target is refs/heads/..
        <span class="cov8" title="1">if strings.HasPrefix(prunBranch, "refs/heads/") </span><span class="cov8" title="1">{
                ref := baseBranch
                if !strings.HasPrefix(baseBranch, "refs/heads/") &amp;&amp; !strings.HasPrefix(baseBranch, "refs/tags/") </span><span class="cov8" title="1">{
                        // If base is without refs/heads/.. and not refs/tags/.. prefix, add it
                        ref = "refs/heads/" + baseBranch
                }</span>
                <span class="cov8" title="1">return matchGlob(prunBranch, ref)</span>
        }

        // Case: target is not refs/heads/.. and not refs/tags/..
        <span class="cov8" title="1">if !strings.HasPrefix(prunBranch, "refs/heads/") &amp;&amp; !strings.HasPrefix(prunBranch, "refs/tags/") </span><span class="cov8" title="1">{
                prunRef := "refs/heads/" + prunBranch
                ref := baseBranch
                if !strings.HasPrefix(baseBranch, "refs/heads/") &amp;&amp; !strings.HasPrefix(baseBranch, "refs/tags/") </span><span class="cov8" title="1">{
                        // If base is without refs/heads/.. and not refs/tags/.. prefix, add it
                        ref = "refs/heads/" + baseBranch
                }</span>
                <span class="cov8" title="1">return matchGlob(prunRef, ref)</span>
        }

        // Match the prunRef pattern with the baseBranch
        // this will cover the scenarios of match globs like refs/tags/0.* and any other if any
        <span class="cov8" title="1">return matchGlob(prunBranch, baseBranch)</span>
}

// TODO: move to another file since it's common to all annotations_* files.
func getAnnotationValues(annotation string) ([]string, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(reValidateTag)
        annotation = strings.TrimSpace(annotation)
        match := re.MatchString(annotation)
        if !match </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("annotations in pipeline are in wrong format: %s", annotation)
        }</span>

        // if it's not an array then it would be a single string
        <span class="cov8" title="1">if !strings.HasPrefix(annotation, "[") </span><span class="cov8" title="1">{
                // replace &amp;#44; with comma so users can have comma in the annotation
                annot := strings.ReplaceAll(annotation, "&amp;#44;", ",")
                return []string{annot}, nil
        }</span>

        // Split all tasks by comma and make sure to trim spaces in there
        <span class="cov8" title="1">split := strings.Split(re.FindStringSubmatch(annotation)[1], ",")
        for i := range split </span><span class="cov8" title="1">{
                split[i] = strings.TrimSpace(strings.ReplaceAll(split[i], "&amp;#44;", ","))
        }</span>

        <span class="cov8" title="1">if split[0] == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("annotation \"%s\" has empty values", annotation)
        }</span>

        <span class="cov8" title="1">return split, nil</span>
}

func getTargetBranch(prun *tektonv1.PipelineRun, event *info.Event) (bool, string, string, error) <span class="cov8" title="1">{
        var targetEvent, targetBranch string
        if key, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnEvent]; ok </span><span class="cov8" title="1">{
                if key == "[]" </span><span class="cov8" title="1">{
                        return false, "", "", fmt.Errorf("annotation %s is empty", keys.OnEvent)
                }</span>
                <span class="cov8" title="1">targetEvents := []string{event.TriggerTarget.String()}
                if event.EventType == triggertype.Incoming.String() </span><span class="cov8" title="1">{
                        // if we have a incoming event, we want to match pipelineruns on both incoming and push
                        targetEvents = []string{triggertype.Incoming.String(), triggertype.Push.String()}
                }</span>
                <span class="cov8" title="1">matched, err := matchOnAnnotation(key, targetEvents, false)
                targetEvent = key
                if err != nil </span><span class="cov0" title="0">{
                        return false, "", "", err
                }</span>
                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        return false, "", "", nil
                }</span>
        }
        <span class="cov8" title="1">if key, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnTargetBranch]; ok </span><span class="cov8" title="1">{
                if key == "[]" </span><span class="cov8" title="1">{
                        return false, "", "", fmt.Errorf("annotation %s is empty", keys.OnTargetBranch)
                }</span>
                <span class="cov8" title="1">targetEvents := []string{event.BaseBranch}
                matched, err := matchOnAnnotation(key, targetEvents, true)
                targetBranch = key
                if err != nil </span><span class="cov0" title="0">{
                        return false, "", "", err
                }</span>
                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        return false, "", "", nil
                }</span>
        }

        <span class="cov8" title="1">if targetEvent == "" || targetBranch == "" </span><span class="cov8" title="1">{
                return false, "", "", nil
        }</span>
        <span class="cov8" title="1">return true, targetEvent, targetBranch, nil</span>
}

type Match struct {
        PipelineRun *tektonv1.PipelineRun
        Repo        *apipac.Repository
        Config      map[string]string
}

// getName returns the name of the PipelineRun, if GenerateName is not set, it
// returns the name generateName takes precedence over name since it will be
// generated when applying the PipelineRun by the tekton controller.
func getName(prun *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        name := prun.GetGenerateName()
        if name == "" </span><span class="cov8" title="1">{
                name = prun.GetName()
        }</span>
        <span class="cov8" title="1">return name</span>
}

// checkPipelineRunAnnotation checks if the Pipelinerun has
// `on-event`/`on-target-branch annotations` with `on-cel-expression`
// and if present then warns the user that `on-cel-expression` will take precedence.
func checkPipelineRunAnnotation(prun *tektonv1.PipelineRun, eventEmitter *events.EventEmitter, repo *apipac.Repository) <span class="cov8" title="1">{
        // Define the annotations to check in a slice for easy iteration
        checks := []struct {
                key   string
                value string
        }{
                {"on-event", prun.GetObjectMeta().GetAnnotations()[keys.OnEvent]},
                {"on-target-branch", prun.GetObjectMeta().GetAnnotations()[keys.OnTargetBranch]},
        }

        // Preallocate the annotations slice with the exact capacity needed
        annotations := make([]string, 0, len(checks))

        // Iterate through each check and append the key if the value is non-empty
        for _, check := range checks </span><span class="cov8" title="1">{
                if check.value != "" </span><span class="cov8" title="1">{
                        annotations = append(annotations, check.key)
                }</span>
        }

        <span class="cov8" title="1">prName := getName(prun)
        if len(annotations) &gt; 0 </span><span class="cov8" title="1">{
                ignoredAnnotations := strings.Join(annotations, ", ")
                msg := fmt.Sprintf(
                        "Warning: The PipelineRun '%s' has 'on-cel-expression' defined along with [%s] annotation(s). The 'on-cel-expression' will take precedence and these annotations will be ignored",
                        prName,
                        ignoredAnnotations,
                )
                eventEmitter.EmitMessage(repo, zap.WarnLevel, "RepositoryTakesOnCelExpressionPrecedence", msg)
        }</span>
}

func MatchPipelinerunByAnnotation(ctx context.Context, logger *zap.SugaredLogger, pruns []*tektonv1.PipelineRun, cs *params.Run, event *info.Event, vcx provider.Interface, eventEmitter *events.EventEmitter, repo *apipac.Repository) ([]Match, error) <span class="cov8" title="1">{
        matchedPRs := []Match{}
        infomsg := fmt.Sprintf("matching pipelineruns to event: URL=%s, target-branch=%s, source-branch=%s, target-event=%s",
                event.URL,
                event.BaseBranch,
                event.HeadBranch,
                event.TriggerTarget,
        )

        if len(event.PullRequestLabel) &gt; 0 </span><span class="cov8" title="1">{
                infomsg += fmt.Sprintf(", labels=%s", strings.Join(event.PullRequestLabel, "|"))
        }</span>

        <span class="cov8" title="1">if event.EventType == triggertype.Incoming.String() </span><span class="cov8" title="1">{
                infomsg = fmt.Sprintf("%s, target-pipelinerun=%s", infomsg, event.TargetPipelineRun)
        }</span> else<span class="cov8" title="1"> if event.EventType == triggertype.PullRequest.String() </span><span class="cov8" title="1">{
                infomsg = fmt.Sprintf("%s, pull-request=%d", infomsg, event.PullRequestNumber)
        }</span>
        <span class="cov8" title="1">logger.Info(infomsg)

        celValidationErrors := []*pacerrors.PacYamlValidations{}
        for _, prun := range pruns </span><span class="cov8" title="1">{
                prMatch := Match{
                        PipelineRun: prun,
                        Config:      map[string]string{},
                }

                prName := getName(prun)
                if event.TargetPipelineRun != "" &amp;&amp; event.TargetPipelineRun == strings.TrimSuffix(prName, "-") </span><span class="cov8" title="1">{
                        logger.Infof("matched target pipelinerun with name: %s, target pipelinerun: %s", prName, event.TargetPipelineRun)
                        matchedPRs = append(matchedPRs, prMatch)
                        continue</span>
                }

                <span class="cov8" title="1">if prun.GetObjectMeta().GetAnnotations() == nil </span><span class="cov8" title="1">{
                        logger.Debugf("PipelineRun %s does not have any annotations", prName)
                        continue</span>
                }

                <span class="cov8" title="1">if maxPrNumber, ok := prun.GetObjectMeta().GetAnnotations()[keys.MaxKeepRuns]; ok </span><span class="cov8" title="1">{
                        prMatch.Config["max-keep-runs"] = maxPrNumber
                }</span>

                <span class="cov8" title="1">if targetNS, ok := prun.GetObjectMeta().GetAnnotations()[keys.TargetNamespace]; ok </span><span class="cov8" title="1">{
                        prMatch.Config["target-namespace"] = targetNS
                        prMatch.Repo, _ = MatchEventURLRepo(ctx, cs, event, targetNS)
                        if prMatch.Repo == nil </span><span class="cov8" title="1">{
                                logger.Warnf("could not find Repository CRD in branch %s, the pipelineRun %s has a label that explicitly targets it", targetNS, prName)
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if targetComment, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnComment]; ok </span><span class="cov8" title="1">{
                        re, err := regexp.Compile(targetComment)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("could not compile regexp %s from pipelineRun %s", targetComment, prName)
                                continue</span>
                        }

                        <span class="cov8" title="1">strippedComment := strings.TrimSpace(
                                strings.TrimPrefix(strings.TrimSuffix(event.TriggerComment, "\r\n"), "\r\n"))
                        if re.MatchString(strippedComment) </span><span class="cov8" title="1">{
                                event.EventType = opscomments.OnCommentEventType.String()

                                comment := event.TriggerComment
                                if len(comment) &gt; maxCommentLogLength </span><span class="cov0" title="0">{
                                        comment = comment[:maxCommentLogLength] + "..."
                                }</span>
                                <span class="cov8" title="1">logger.Infof("matched pipelinerun with name: %s on gitops comment: %q", prName, comment)

                                matchedPRs = append(matchedPRs, prMatch)
                                continue</span>
                        }
                }
                // if the event is a comment event, but we don't have any match from the keys.OnComment then skip the other evaluations
                <span class="cov8" title="1">if event.EventType == opscomments.NoOpsCommentEventType.String() || event.EventType == opscomments.OnCommentEventType.String() </span><span class="cov8" title="1">{
                        continue</span>
                }

                // If the event is a pull_request and the event type is label_update, but the PipelineRun
                // does not contain an 'on-label' annotation, do not match this PipelineRun, as it is not intended for this event.
                <span class="cov8" title="1">_, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnLabel]
                if event.TriggerTarget == triggertype.PullRequest &amp;&amp; event.EventType == string(triggertype.PullRequestLabeled) &amp;&amp; !ok </span><span class="cov8" title="1">{
                        logger.Infof("label update event, PipelineRun %s does not have a on-label for any of those labels: %s", prName, strings.Join(event.PullRequestLabel, "|"))
                        continue</span>
                }

                <span class="cov8" title="1">if celExpr, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnCelExpression]; ok </span><span class="cov8" title="1">{
                        checkPipelineRunAnnotation(prun, eventEmitter, repo)

                        out, err := celEvaluate(ctx, celExpr, event, vcx)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("there was an error evaluating the CEL expression, skipping: %v", err)
                                if checkIfCELEvaluateError(err) </span><span class="cov8" title="1">{
                                        celValidationErrors = append(celValidationErrors, &amp;pacerrors.PacYamlValidations{
                                                Name: prName,
                                                Err:  fmt.Errorf("CEL expression evaluation error: %s", sanitizeErrorAsMarkdown(err)),
                                        })
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }
                        <span class="cov8" title="1">if out != types.True </span><span class="cov8" title="1">{
                                logger.Infof("CEL expression for PipelineRun %s is not matching, skipping", prName)
                                continue</span>
                        }
                        <span class="cov8" title="1">logger.Infof("CEL expression has been evaluated and matched")</span>
                } else<span class="cov8" title="1"> {
                        matched, targetEvent, targetBranch, err := getTargetBranch(prun, event)
                        if err != nil </span><span class="cov8" title="1">{
                                return matchedPRs, err
                        }</span>
                        <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">prMatch.Config["target-branch"] = targetBranch
                        prMatch.Config["target-event"] = targetEvent

                        if key, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnPathChange]; ok </span><span class="cov8" title="1">{
                                changedFiles, err := vcx.GetFiles(ctx, event)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("error getting changed files: %v", err)
                                        continue</span>
                                }
                                // // TODO(chmou): we use the matchOnAnnotation function, it's
                                // really made to match git branches but we can still use it for
                                // our own path changes. we may split up if needed to refine.
                                <span class="cov8" title="1">matched, err := matchOnAnnotation(key, changedFiles.All, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return matchedPRs, err
                                }</span>
                                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">logger.Infof("matched PipelineRun with name: %s, annotation PathChange: %q", prName, key)
                                prMatch.Config["path-change"] = key</span>
                        }

                        <span class="cov8" title="1">if key, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnLabel]; ok </span><span class="cov8" title="1">{
                                matched, err := matchOnAnnotation(key, event.PullRequestLabel, false)
                                if err != nil </span><span class="cov0" title="0">{
                                        return matchedPRs, err
                                }</span>
                                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">logger.Infof("matched PipelineRun with name: %s, annotation Label: %q", prName, key)
                                prMatch.Config["label"] = key</span>
                        }

                        <span class="cov8" title="1">if key, ok := prun.GetObjectMeta().GetAnnotations()[keys.OnPathChangeIgnore]; ok </span><span class="cov8" title="1">{
                                changedFiles, err := vcx.GetFiles(ctx, event)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("error getting changed files: %v", err)
                                        continue</span>
                                }
                                // // TODO(chmou): we use the matchOnAnnotation function, it's
                                // really made to match git branches but we can still use it for
                                // our own path changes. we may split up if needed to refine.
                                <span class="cov8" title="1">matched, err := matchOnAnnotation(key, changedFiles.All, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        return matchedPRs, err
                                }</span>
                                <span class="cov8" title="1">if matched </span><span class="cov8" title="1">{
                                        logger.Infof("Skipping pipelinerun with name: %s, annotation PathChangeIgnore: %q", prName, key)
                                        continue</span>
                                }
                                <span class="cov8" title="1">prMatch.Config["path-change-ignore"] = key</span>
                        }
                }

                <span class="cov8" title="1">logger.Infof("matched pipelinerun with name: %s, annotation Config: %q", prName, prMatch.Config)
                matchedPRs = append(matchedPRs, prMatch)</span>
        }

        <span class="cov8" title="1">if len(celValidationErrors) &gt; 0 </span><span class="cov8" title="1">{
                reportCELValidationErrors(ctx, repo, celValidationErrors, eventEmitter, vcx, event)
        }</span>

        <span class="cov8" title="1">if len(matchedPRs) &gt; 0 </span><span class="cov8" title="1">{
                // Filter out templates that already have successful PipelineRuns for /retest and /ok-to-test
                if event.EventType == opscomments.RetestAllCommentEventType.String() ||
                        event.EventType == opscomments.OkToTestCommentEventType.String() </span><span class="cov0" title="0">{
                        return filterSuccessfulTemplates(ctx, logger, cs, event, repo, matchedPRs), nil
                }</span>
                <span class="cov8" title="1">return matchedPRs, nil</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("%s", buildAvailableMatchingAnnotationErr(event, pruns))</span>
}

// filterSuccessfulTemplates filters out templates that already have successful PipelineRuns
// when executing /ok-to-test or /retest gitops commands, implementing per-template checking.
func filterSuccessfulTemplates(ctx context.Context, logger *zap.SugaredLogger, cs *params.Run, event *info.Event, repo *apipac.Repository, matchedPRs []Match) []Match <span class="cov8" title="1">{
        if event.SHA == "" </span><span class="cov8" title="1">{
                return matchedPRs
        }</span>

        // Get all existing PipelineRuns for this SHA
        <span class="cov8" title="1">labelSelector := fmt.Sprintf("%s=%s", keys.SHA, formatting.CleanValueKubernetes(event.SHA))
        existingPRs, err := cs.Clients.Tekton.TektonV1().PipelineRuns(repo.GetNamespace()).List(ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to list existing PipelineRuns for SHA %s: %v", event.SHA, err)
                return matchedPRs // Return all templates if we can't check
        }</span>

        // Create a map of template names to their most recent successful run
        <span class="cov8" title="1">successfulTemplates := make(map[string]*tektonv1.PipelineRun)

        for i := range existingPRs.Items </span><span class="cov8" title="1">{
                pr := &amp;existingPRs.Items[i]

                // Get the original template name this PipelineRun came from
                originalPRName, ok := pr.GetAnnotations()[keys.OriginalPRName]
                if !ok </span><span class="cov8" title="1">{
                        originalPRName, ok = pr.GetLabels()[keys.OriginalPRName]
                }</span>
                <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                        continue</span> // Skip PipelineRuns without template identification
                }

                // Check if this PipelineRun succeeded
                <span class="cov8" title="1">if pr.Status.GetCondition(apis.ConditionSucceeded).IsTrue() </span><span class="cov8" title="1">{
                        // Keep the most recent successful run for each template
                        if existing, exists := successfulTemplates[originalPRName]; !exists ||
                                pr.CreationTimestamp.After(existing.CreationTimestamp.Time) </span><span class="cov8" title="1">{
                                successfulTemplates[originalPRName] = pr
                        }</span>
                }
        }

        // Filter out templates that have successful runs
        <span class="cov8" title="1">var filteredPRs []Match

        for _, match := range matchedPRs </span><span class="cov8" title="1">{
                templateName := getName(match.PipelineRun)

                if successfulPR, hasSuccessfulRun := successfulTemplates[templateName]; hasSuccessfulRun </span><span class="cov8" title="1">{
                        logger.Infof("skipping template '%s' for sha %s as it already has a successful pipelinerun '%s'",
                                templateName, event.SHA, successfulPR.Name)
                }</span> else<span class="cov8" title="1"> {
                        filteredPRs = append(filteredPRs, match)
                }</span>
        }

        // Return the filtered list (which may be empty if all templates were skipped)
        <span class="cov8" title="1">return filteredPRs</span>
}

func buildAvailableMatchingAnnotationErr(event *info.Event, pruns []*tektonv1.PipelineRun) string <span class="cov8" title="1">{
        errmsg := "available annotations of the PipelineRuns annotations in .tekton/ dir:"
        for _, prun := range pruns </span><span class="cov8" title="1">{
                name := getName(prun)
                errmsg += fmt.Sprintf(" [PipelineRun: %s, annotations:", name)
                for annotation, value := range prun.GetAnnotations() </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(annotation, pipelinesascode.GroupName+"/on-") </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">errmsg += fmt.Sprintf(" %s: ", strings.Replace(annotation, pipelinesascode.GroupName+"/", "", 1))
                        if annotation == keys.OnCelExpression </span><span class="cov8" title="1">{
                                errmsg += "celexpression"
                        }</span> else<span class="cov8" title="1"> {
                                errmsg += value
                        }</span>
                        <span class="cov8" title="1">errmsg += ", "</span>
                }
                <span class="cov8" title="1">errmsg = strings.TrimSuffix(errmsg, ", ")
                errmsg += "],"</span>
        }
        <span class="cov8" title="1">errmsg = strings.TrimSpace(errmsg)
        errmsg = strings.TrimSuffix(errmsg, ",")
        nopsevent := ""
        if event.EventType != opscomments.NoOpsCommentEventType.String() </span><span class="cov8" title="1">{
                nopsevent = fmt.Sprintf(" payload target event is %s with", event.EventType)
        }</span>
        <span class="cov8" title="1">errmsg = fmt.Sprintf("cannot match the event to any pipelineruns in the .tekton/ directory,%s source branch %s and target branch %s. %s", nopsevent, event.HeadBranch, event.BaseBranch, errmsg)
        return errmsg</span>
}

func matchOnAnnotation(annotations string, eventType []string, branchMatching bool) (bool, error) <span class="cov8" title="1">{
        targets, err := getAnnotationValues(annotations)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">var gotit string
        for _, v := range targets </span><span class="cov8" title="1">{
                for _, e := range eventType </span><span class="cov8" title="1">{
                        if v == e </span><span class="cov8" title="1">{
                                gotit = v
                        }</span>

                        <span class="cov8" title="1">if branchMatching &amp;&amp; branchMatch(v, e) </span><span class="cov8" title="1">{
                                gotit = v
                        }</span>
                }
        }
        <span class="cov8" title="1">if gotit == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

func MatchRunningPipelineRunForIncomingWebhook(eventType, incomingPipelineRun string, prs []*tektonv1.PipelineRun) []*tektonv1.PipelineRun <span class="cov8" title="1">{
        // return all pipelineruns if EventType is not incoming or TargetPipelineRun is ""
        if eventType != "incoming" || incomingPipelineRun == "" </span><span class="cov8" title="1">{
                return prs
        }</span>

        <span class="cov8" title="1">for _, pr := range prs </span><span class="cov8" title="1">{
                // check incomingPipelineRun with pr name or generateName
                if incomingPipelineRun == pr.GetName() || incomingPipelineRun == pr.GetGenerateName() </span><span class="cov8" title="1">{
                        return []*tektonv1.PipelineRun{pr}
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package matcher

import (
        "context"
        "errors"
        "fmt"
        "os"
        "regexp"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/hub"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        tektonv1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "go.uber.org/zap"
        k8scheme "k8s.io/client-go/kubernetes/scheme"
)

const (
        taskAnnotationsRegexp     = `task(-[0-9]+)?$`
        pipelineAnnotationsRegexp = `pipeline$`
)

type RemoteTasks struct {
        Run               *params.Run
        ProviderInterface provider.Interface
        Event             *info.Event
        Logger            *zap.SugaredLogger
}

// nolint: dupl
func (rt RemoteTasks) convertToPipeline(ctx context.Context, uri, data string) (*tektonv1.Pipeline, error) <span class="cov8" title="1">{
        decoder := k8scheme.Codecs.UniversalDeserializer()
        obj, _, err := decoder.Decode([]byte(data), nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("remote pipeline from URI %s cannot be parsed as a Kubernetes resource: %w", uri, err)
        }</span>

        <span class="cov8" title="1">var pipeline *tektonv1.Pipeline
        switch o := obj.(type) </span>{
        case *tektonv1.Pipeline:<span class="cov0" title="0">
                pipeline = o</span>
        case *tektonv1beta1.Pipeline:<span class="cov8" title="1"> //nolint: staticcheck
                c := &amp;tektonv1.Pipeline{}
                // TODO: figure ou the issue we have with setdefault setting defaults SA
                // and then don't let pipeline do its job to automatically set a
                // pipeline on configuration
                // o.SetDefaults(ctx)
                // ctx2 := features.SetFeatureFlag(context.Background())
                // if err := o.Validate(ctx2); err != nil {
                // return nil, fmt.Errorf("remote pipeline from uri: %s with name %s cannot be validated: %w", uri, o.GetName(), err)
                // }
                if err := o.ConvertTo(ctx, c); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("remote pipeline from URI %s with name %s cannot be converted to v1beta1: %w", uri, o.GetName(), err)
                }</span>
                <span class="cov8" title="1">pipeline = c</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("remote pipeline from URI %s has not been recognized as a Tekton pipeline: %v", uri, o)</span>
        }

        <span class="cov8" title="1">return pipeline, nil</span>
}

// nolint: dupl
// golint has decided that this is a duplication with convertToPipeline but I swear it isn't - these two are different functions
// and not even sure this is possible to do with generic complexity.
func (rt RemoteTasks) convertTotask(ctx context.Context, uri, data string) (*tektonv1.Task, error) <span class="cov8" title="1">{
        decoder := k8scheme.Codecs.UniversalDeserializer()
        obj, _, err := decoder.Decode([]byte(data), nil, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("remote task from URI %s cannot be parsed as a Kubernetes resource: %w", uri, err)
        }</span>

        <span class="cov8" title="1">var task *tektonv1.Task
        switch o := obj.(type) </span>{
        case *tektonv1.Task:<span class="cov0" title="0">
                task = o</span>
        case *tektonv1beta1.Task:<span class="cov8" title="1"> //nolint: staticcheck // we need to support v1beta1
                c := &amp;tektonv1.Task{}
                // o.SetDefaults(ctx)
                // if err := o.Validate(ctx); err != nil {
                //         return nil, fmt.Errorf("remote task %s cannot be validated properly: err: %w", o.GetName(), err)
                // return nil, fmt.Errorf("remote task from uri: %s with name %s cannot be validated: %w", uri, o.GetName(), err)
                // }
                if err := o.ConvertTo(ctx, c); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("remote task from URI %s with name %s cannot be converted to v1beta1: %w", uri, o.GetName(), err)
                }</span>
                <span class="cov8" title="1">task = c</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("remote task from URI %s has not been recognized as a Tekton task: %v", uri, o)</span>
        }

        <span class="cov8" title="1">return task, nil</span>
}

func (rt RemoteTasks) getRemote(ctx context.Context, uri string, fromHub bool, kind string) (string, error) <span class="cov8" title="1">{
        if fetchedFromURIFromProvider, task, err := rt.ProviderInterface.GetTaskURI(ctx, rt.Event, uri); fetchedFromURIFromProvider </span><span class="cov8" title="1">{
                return task, err
        }</span>

        <span class="cov8" title="1">switch </span>{
        case strings.HasPrefix(uri, "https://"), strings.HasPrefix(uri, "http://"):<span class="cov8" title="1"> // if it starts with http(s)://, it is a remote resource
                data, err := rt.Run.Clients.GetURL(ctx, uri)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">rt.Logger.Infof("successfully fetched %s from remote HTTPS URL", uri)
                return string(data), nil</span>
        case fromHub &amp;&amp; strings.Contains(uri, "://"):<span class="cov8" title="1"> // if it contains ://, it is a remote custom catalog
                split := strings.Split(uri, "://")
                catalogID := split[0]
                value, _ := rt.Run.Info.Pac.HubCatalogs.Load(catalogID)
                if _, ok := rt.Run.Info.Pac.HubCatalogs.Load(catalogID); !ok </span><span class="cov8" title="1">{
                        rt.Logger.Infof("custom catalog %s is not found, skipping", catalogID)
                        return "", nil
                }</span>
                <span class="cov8" title="1">uri = strings.TrimPrefix(uri, fmt.Sprintf("%s://", catalogID))
                data, err := hub.GetResource(ctx, rt.Run, catalogID, uri, kind)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">catalogValue, ok := value.(settings.HubCatalog)
                if !ok </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("could not get details for catalog name: %s", catalogID)
                }</span>
                <span class="cov8" title="1">rt.Logger.Infof("successfully fetched %s %s from custom catalog Hub %s on URL %s", kind, uri, catalogID, catalogValue.URL)
                return data, nil</span>
        case strings.Contains(uri, "/"):<span class="cov8" title="1"> // if it contains a slash, it is a file inside a repository
                var data string
                var err error
                if rt.Event.SHA != "" </span><span class="cov8" title="1">{
                        data, err = rt.ProviderInterface.GetFileInsideRepo(ctx, rt.Event, uri, "")
                        if err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                } else<span class="cov8" title="1"> {
                        data, err = getFileFromLocalFS(uri, rt.Logger)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if data == "" </span><span class="cov8" title="1">{
                                return "", nil
                        }</span>
                }

                <span class="cov8" title="1">rt.Logger.Infof("successfully fetched %s inside repository", uri)
                return data, nil</span>
        case fromHub:<span class="cov8" title="1"> // finally a simple word will fetch from the default catalog (if enabled)
                data, err := hub.GetResource(ctx, rt.Run, "default", uri, kind)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">value, _ := rt.Run.Info.Pac.HubCatalogs.Load("default")
                catalogValue, ok := value.(settings.HubCatalog)
                if !ok </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("could not get details for catalog name: %s", "default")
                }</span>
                <span class="cov8" title="1">rt.Logger.Infof("successfully fetched %s %s from default configured catalog Hub on URL %s", uri, kind, catalogValue.URL)
                return data, nil</span>
        }
        <span class="cov0" title="0">return "", fmt.Errorf(`cannot find "%s" anywhere`, uri)</span>
}

func grabValuesFromAnnotations(annotations map[string]string, annotationReg string) ([]string, error) <span class="cov8" title="1">{
        rtareg := regexp.MustCompile(fmt.Sprintf("%s/%s", pipelinesascode.GroupName, annotationReg))
        var ret []string
        for annotationK, annotationV := range annotations </span><span class="cov8" title="1">{
                if !rtareg.MatchString(annotationK) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">items, err := getAnnotationValues(annotationV)
                if err != nil </span><span class="cov8" title="1">{
                        return ret, err
                }</span>
                <span class="cov8" title="1">ret = append(items, ret...)</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}

func GrabTasksFromAnnotations(annotations map[string]string) ([]string, error) <span class="cov8" title="1">{
        return grabValuesFromAnnotations(annotations, taskAnnotationsRegexp)
}</span>

func GrabPipelineFromAnnotations(annotations map[string]string) (string, error) <span class="cov8" title="1">{
        pipelinesAnnotation, err := grabValuesFromAnnotations(annotations, pipelineAnnotationsRegexp)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(pipelinesAnnotation) &gt; 1 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("only one pipeline is allowed on remote resolution, we have received multiple of them: %+v", pipelinesAnnotation)
        }</span>
        <span class="cov8" title="1">if len(pipelinesAnnotation) == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return pipelinesAnnotation[0], nil</span>
}

func (rt RemoteTasks) GetTaskFromAnnotationName(ctx context.Context, name string) (*tektonv1.Task, error) <span class="cov8" title="1">{
        data, err := rt.getRemote(ctx, name, true, "task")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting remote task \"%s\": %w", name, err)
        }</span>
        <span class="cov8" title="1">if data == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("remote task \"%s\" not found", name)
        }</span>

        <span class="cov8" title="1">task, err := rt.convertTotask(ctx, name, data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return task, nil</span>
}

func (rt RemoteTasks) GetPipelineFromAnnotationName(ctx context.Context, name string) (*tektonv1.Pipeline, error) <span class="cov8" title="1">{
        data, err := rt.getRemote(ctx, name, true, "pipeline")
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting remote pipeline \"%s\": %w", name, err)
        }</span>
        <span class="cov8" title="1">if data == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("remote pipeline \"%s\" not found", name)
        }</span>

        <span class="cov8" title="1">pipeline, err := rt.convertToPipeline(ctx, name, data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return pipeline, nil</span>
}

// getFileFromLocalFS get task locally if file exist
// TODO: may want to try chroot to the git root dir first as well if we are able so.
func getFileFromLocalFS(fileName string, logger *zap.SugaredLogger) (string, error) <span class="cov8" title="1">{
        var data string
        // We are most probably running with tkn pac resolve -f here, so
        // let's try by any chance to check locally if the task is here on
        // the filesystem
        if _, err := os.Stat(fileName); errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                logger.Warnf("could not find remote file %s inside Repo", fileName)
                return "", nil
        }</span>

        <span class="cov8" title="1">b, err := os.ReadFile(fileName)
        data = string(b)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package matcher

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"

        "github.com/gobwas/glob"
        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/decls"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
)

const (
        reChangedFilesTags = `files\.`
)

func celEvaluate(ctx context.Context, expr string, event *info.Event, vcx provider.Interface) (ref.Val, error) <span class="cov8" title="1">{
        eventTitle := event.PullRequestTitle
        if event.TriggerTarget == triggertype.Push </span><span class="cov8" title="1">{
                eventTitle = event.SHATitle
                // For push event the target_branch &amp; source_branch info coming from payload have refs/heads/
                // but user may or mayn't provide refs/heads/ info while giving target_branch or source_branch in CEL expression
                // ex:  pipelinesascode.tekton.dev/on-cel-expression: |
                //        event == "push" &amp;&amp; target_branch == "main" &amp;&amp; "frontend/***".pathChanged()
                // This logic will handle such case.
                splittedValue := strings.Split(expr, "&amp;&amp;")
                for i := range splittedValue </span><span class="cov8" title="1">{
                        if strings.Contains(splittedValue[i], "target_branch") </span><span class="cov8" title="1">{
                                if !strings.Contains(splittedValue[i], "refs/heads/") </span><span class="cov8" title="1">{
                                        event.BaseBranch = strings.TrimPrefix(event.BaseBranch, "refs/heads/")
                                }</span>
                        }
                        <span class="cov8" title="1">if strings.Contains(splittedValue[i], "source_branch") </span><span class="cov0" title="0">{
                                if !strings.Contains(splittedValue[i], "refs/heads/") </span><span class="cov0" title="0">{
                                        event.HeadBranch = strings.TrimPrefix(event.HeadBranch, "refs/heads/")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">nbody, err := json.Marshal(event.Event)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var jsonMap map[string]any
        err = json.Unmarshal(nbody, &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">headerMap := make(map[string]string)
        for k, v := range event.Request.Header </span><span class="cov8" title="1">{
                headerMap[strings.ToLower(k)] = v[0]
        }</span>

        <span class="cov8" title="1">r := regexp.MustCompile(reChangedFilesTags)
        changedFiles := changedfiles.ChangedFiles{}

        if r.MatchString(expr) </span><span class="cov8" title="1">{
                changedFiles, err = vcx.GetFiles(ctx, event)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">data := map[string]any{
                "event":         event.TriggerTarget.String(),
                "event_title":   eventTitle,
                "target_branch": event.BaseBranch,
                "source_branch": event.HeadBranch,
                "target_url":    event.BaseURL,
                "source_url":    event.HeadURL,
                "body":          jsonMap,
                "headers":       headerMap,
                "files": map[string]any{
                        "all":      changedFiles.All,
                        "added":    changedFiles.Added,
                        "deleted":  changedFiles.Deleted,
                        "modified": changedFiles.Modified,
                        "renamed":  changedFiles.Renamed,
                },
        }
        env, err := cel.NewEnv(
                cel.Lib(celPac{vcx, ctx, event}),
                cel.VariableDecls(
                        decls.NewVariable("event", types.StringType),
                        decls.NewVariable("headers", types.NewMapType(types.StringType, types.DynType)),
                        decls.NewVariable("body", types.NewMapType(types.StringType, types.DynType)),
                        decls.NewVariable("event_title", types.StringType),
                        decls.NewVariable("target_branch", types.StringType),
                        decls.NewVariable("source_branch", types.StringType),
                        decls.NewVariable("target_url", types.StringType),
                        decls.NewVariable("source_url", types.StringType),
                        decls.NewVariable("files", types.NewMapType(types.StringType, types.DynType)),
                ))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">parsed, issues := env.Parse(expr)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse expression %#v: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">checked, issues := env.Check(parsed)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v check failed: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">prg, err := env.Program(checked)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v failed to create a Program: %w", expr, err)
        }</span>

        <span class="cov8" title="1">out, _, err := prg.Eval(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v failed to evaluate: %w", expr, err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

type celPac struct {
        vcx   provider.Interface
        ctx   context.Context
        event *info.Event
}

func (t celPac) ProgramOptions() []cel.ProgramOption <span class="cov8" title="1">{
        return []cel.ProgramOption{}
}</span>

func (t celPac) pathChanged(vals ref.Val) ref.Val <span class="cov8" title="1">{
        var match types.Bool
        changedFiles, err := t.vcx.GetFiles(t.ctx, t.event)
        if err != nil </span><span class="cov0" title="0">{
                return types.Bool(false)
        }</span>
        <span class="cov8" title="1">for i := range changedFiles.All </span><span class="cov8" title="1">{
                if v, ok := vals.Value().(string); ok </span><span class="cov8" title="1">{
                        g := glob.MustCompile(v)
                        if g.Match(changedFiles.All[i]) </span><span class="cov8" title="1">{
                                return types.Bool(true)
                        }</span>
                }
                <span class="cov8" title="1">match = types.Bool(false)</span>
        }

        <span class="cov8" title="1">return match</span>
}

func (t celPac) CompileOptions() []cel.EnvOption <span class="cov8" title="1">{
        return []cel.EnvOption{
                cel.Function("pathChanged",
                        cel.MemberOverload("pathChanged", []*cel.Type{cel.StringType}, cel.BoolType,
                                cel.UnaryBinding(t.pathChanged))),
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package matcher

import (
        "context"
        "fmt"
        "strings"

        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        pacerrors "github.com/openshift-pipelines/pipelines-as-code/pkg/errors"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"

        "go.uber.org/zap"
)

// checkCELEvaluateError checks if error is from CEL evaluation stages.
func checkIfCELEvaluateError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">errMsg := err.Error()

        patterns := []string{
                `failed to parse expression`,
                `check failed`,
                `failed to create a Program`,
                `failed to evaluate`,
        }

        for _, pattern := range patterns </span><span class="cov8" title="1">{
                if strings.Contains(errMsg, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func reportCELValidationErrors(ctx context.Context, repo *apipac.Repository, validationErrors []*pacerrors.PacYamlValidations, eventEmitter *events.EventEmitter, vcx provider.Interface, event *info.Event) <span class="cov8" title="1">{
        errorRows := make([]string, 0, len(validationErrors))
        for _, err := range validationErrors </span><span class="cov8" title="1">{
                errorRows = append(errorRows, fmt.Sprintf("| %s | `%s` |", err.Name, err.Err.Error()))
        }</span>
        <span class="cov8" title="1">if len(errorRows) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">markdownErrMessage := fmt.Sprintf(`%s
%s`, provider.ValidationErrorTemplate, strings.Join(errorRows, "\n"))
        if err := vcx.CreateComment(ctx, event, markdownErrMessage, provider.ValidationErrorTemplate); err != nil </span><span class="cov8" title="1">{
                eventEmitter.EmitMessage(repo, zap.ErrorLevel, "PipelineRunCommentCreationError",
                        fmt.Sprintf("failed to create comment: %s", err.Error()))
        }</span>
}

// sanitizeErrorAsMarkdown prepares a CEL evaluation error string to be rendered
// inside a GitHub / GitLab markdown table without breaking its layout.
//
// Markdown tables use the vertical bar character (`|`) as a column delimiter. If
// the original error message contains an un-escaped pipe the markdown renderer
// interprets it as the start of a new column or row which distorts the table
// produced by Pipelines-as-Code when reporting validation errors.
//
// To avoid this we escape every pipe with a backslash (\|). We also replace any
// newline or carriage-return characters with a single space so that the whole
// error is kept on one row, preserving readability in the rendered comment.
func sanitizeErrorAsMarkdown(err error) string <span class="cov8" title="1">{
        errStr := err.Error()
        errStr = strings.ReplaceAll(errStr, "|", "\\|")
        errStr = strings.ReplaceAll(errStr, "\n", " ")
        errStr = strings.ReplaceAll(errStr, "\r", " ")
        return errStr
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package matcher

import (
        "context"
        "fmt"
        "strings"

        "github.com/gobwas/glob"
        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/sort"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func MatchEventURLRepo(ctx context.Context, cs *params.Run, event *info.Event, ns string) (*apipac.Repository, error) <span class="cov8" title="1">{
        repositories, err := cs.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(ns).List(
                ctx, metav1.ListOptions{})
        sort.RepositorySortByCreationOldestTime(repositories.Items)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, repo := range repositories.Items </span><span class="cov8" title="1">{
                repo.Spec.URL = strings.TrimSuffix(repo.Spec.URL, "/")
                if repo.Spec.URL == event.URL </span><span class="cov8" title="1">{
                        return &amp;repo, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

// GetRepo get a repo by name anywhere on a cluster.
func GetRepo(ctx context.Context, cs *params.Run, repoName string) (*apipac.Repository, error) <span class="cov0" title="0">{
        repositories, err := cs.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories("").List(
                ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for i := len(repositories.Items) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                repo := repositories.Items[i]
                if repo.GetName() == repoName </span><span class="cov0" title="0">{
                        return &amp;repo, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

// IncomingWebhookRule will match a rule to an incoming rule, currently a rule is a target branch.
// Supports both exact string matching and glob patterns.
// Uses first-match-wins strategy: returns the first webhook with a matching target.
func IncomingWebhookRule(branch string, incomingWebhooks []apipac.Incoming) *apipac.Incoming <span class="cov8" title="1">{
        // TODO: one day we will match the hook.Type here when we get something else than the dumb one (ie: slack)
        for i := range incomingWebhooks </span><span class="cov8" title="1">{
                hook := &amp;incomingWebhooks[i]

                // Check each target in this webhook
                for _, target := range hook.Targets </span><span class="cov8" title="1">{
                        matched, err := matchTarget(branch, target)
                        if err != nil </span><span class="cov8" title="1">{
                                // Skip invalid glob patterns and continue to next target
                                continue</span>
                        }

                        <span class="cov8" title="1">if matched </span><span class="cov8" title="1">{
                                // First match wins - return immediately
                                return hook
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// matchTarget checks if a branch matches a target pattern using glob matching.
// Supports both exact string matching and glob patterns.
func matchTarget(branch, target string) (bool, error) <span class="cov8" title="1">{
        g, err := glob.Compile(target)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("invalid glob pattern %q: %w", target, err)
        }</span>

        <span class="cov8" title="1">return g.Match(branch), nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"

        pipelineruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

// nolint: gochecknoinits
func init() <span class="cov0" title="0">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return WithClient(ctx) }</span>)
        <span class="cov0" title="0">injection.Default.RegisterInformer(WithInformer)</span>
}

// RecorderKey is used for associating the Recorder inside the context.Context.
type RecorderKey struct{}

// WithClient adds a metrics recorder to the given context.
func WithClient(ctx context.Context) context.Context <span class="cov0" title="0">{
        rec, err := NewRecorder()
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Failed to create pipelinerun metrics recorder %v", err)
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, RecorderKey{}, rec)</span>
}

// Get extracts the pipelinerunmetrics.Recorder from the context.
func Get(ctx context.Context) *Recorder <span class="cov0" title="0">{
        untyped := ctx.Value(RecorderKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic("Unable to fetch *pipelinerunmetrics.Recorder from context.")
        }</span>
        // nolint: forcetypeassert
        <span class="cov0" title="0">return untyped.(*Recorder)</span>
}

// InformerKey is used for associating the Informer inside the context.Context.
type InformerKey struct{}

// WithInformer returns the given context, and a configured informer.
func WithInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        return ctx, &amp;recorderInformer{
                ctx:     ctx,
                metrics: Get(ctx),
                lister:  pipelineruninformer.Get(ctx).Lister(),
        }
}</span>

type recorderInformer struct {
        ctx     context.Context
        metrics *Recorder
        lister  listers.PipelineRunLister
}

var _ controller.Informer = (*recorderInformer)(nil)

// Run starts the recorder informer in a goroutine.
func (ri *recorderInformer) Run(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        // Turn the stopCh into a context for reporting metrics.
        ctx, cancel := context.WithCancel(ri.ctx)
        go func() </span><span class="cov0" title="0">{
                &lt;-stopCh
                cancel()
        }</span>()

        <span class="cov0" title="0">go ri.metrics.ReportRunningPipelineRuns(ctx, ri.lister)</span>
}

// HasSynced returns whether the informer has synced, which in this case will always be true.
func (ri *recorderInformer) HasSynced() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package metrics

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "k8s.io/apimachinery/pkg/labels"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/metrics"
)

var prCount = stats.Float64("pipelines_as_code_pipelinerun_count",
        "number of pipelineruns by pipelines as code",
        stats.UnitDimensionless)

var prDurationCount = stats.Float64("pipelines_as_code_pipelinerun_duration_seconds_sum",
        "number of seconds all pipelineruns completed in by pipelines as code",
        stats.UnitDimensionless)

var runningPRCount = stats.Float64("pipelines_as_code_running_pipelineruns_count",
        "number of running pipelineruns by pipelines as code",
        stats.UnitDimensionless)

var gitProviderAPIRequestCount = stats.Int64(
        "pipelines_as_code_git_provider_api_request_count",
        "number of API requests from pipelines as code to git providers",
        stats.UnitDimensionless,
)

// Recorder holds keys for metrics.
type Recorder struct {
        initialized     bool
        provider        tag.Key
        eventType       tag.Key
        namespace       tag.Key
        repository      tag.Key
        status          tag.Key
        reason          tag.Key
        ReportingPeriod time.Duration
}

var (
        Once           sync.Once
        R              *Recorder
        ErrRegistering error
)

// NewRecorder creates a new metrics recorder instance
// to log the PAC PipelineRun related metrics.
func NewRecorder() (*Recorder, error) <span class="cov0" title="0">{
        Once.Do(func() </span><span class="cov0" title="0">{
                R = &amp;Recorder{
                        initialized: true,

                        // Default to 30s intervals.
                        ReportingPeriod: 30 * time.Second,
                }

                provider, errRegistering := tag.NewKey("provider")
                if errRegistering != nil </span><span class="cov0" title="0">{
                        ErrRegistering = errRegistering
                        return
                }</span>
                <span class="cov0" title="0">R.provider = provider

                eventType, errRegistering := tag.NewKey("event-type")
                if errRegistering != nil </span><span class="cov0" title="0">{
                        ErrRegistering = errRegistering
                        return
                }</span>
                <span class="cov0" title="0">R.eventType = eventType

                namespace, errRegistering := tag.NewKey("namespace")
                if errRegistering != nil </span><span class="cov0" title="0">{
                        ErrRegistering = errRegistering
                        return
                }</span>
                <span class="cov0" title="0">R.namespace = namespace

                repository, errRegistering := tag.NewKey("repository")
                if errRegistering != nil </span><span class="cov0" title="0">{
                        ErrRegistering = errRegistering
                        return
                }</span>
                <span class="cov0" title="0">R.repository = repository

                status, errRegistering := tag.NewKey("status")
                if errRegistering != nil </span><span class="cov0" title="0">{
                        ErrRegistering = errRegistering
                        return
                }</span>
                <span class="cov0" title="0">R.status = status

                reason, errRegistering := tag.NewKey("reason")
                if errRegistering != nil </span><span class="cov0" title="0">{
                        ErrRegistering = errRegistering
                        return
                }</span>
                <span class="cov0" title="0">R.reason = reason

                var (
                        prCountView = &amp;view.View{
                                Description: prCount.Description(),
                                Measure:     prCount,
                                Aggregation: view.Count(),
                                TagKeys:     []tag.Key{R.provider, R.eventType, R.namespace, R.repository},
                        }

                        prDurationView = &amp;view.View{
                                Description: prDurationCount.Description(),
                                Measure:     prDurationCount,
                                Aggregation: view.Sum(),
                                TagKeys:     []tag.Key{R.namespace, R.repository, R.status, R.reason},
                        }

                        runningPRView = &amp;view.View{
                                Description: runningPRCount.Description(),
                                Measure:     runningPRCount,
                                Aggregation: view.LastValue(),
                                TagKeys:     []tag.Key{R.namespace, R.repository},
                        }
                        gitProviderAPIRequestView = &amp;view.View{
                                Description: gitProviderAPIRequestCount.Description(),
                                Measure:     gitProviderAPIRequestCount,
                                Aggregation: view.Count(),
                                TagKeys:     []tag.Key{R.provider, R.eventType, R.namespace, R.repository},
                        }
                )

                view.Unregister(prCountView, prDurationView, runningPRView, gitProviderAPIRequestView)
                errRegistering = view.Register(prCountView, prDurationView, runningPRView, gitProviderAPIRequestView)
                if errRegistering != nil </span><span class="cov0" title="0">{
                        ErrRegistering = errRegistering
                        R.initialized = false
                        return
                }</span>
        })

        <span class="cov0" title="0">return R, ErrRegistering</span>
}

func (r Recorder) assertInitialized() error <span class="cov0" title="0">{
        if !r.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "ignoring the metrics recording for pipelineruns, failed to initialize the metrics recorder")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Count logs number of times a pipelinerun is ran for a provider.
func (r *Recorder) Count(provider, event, namespace, repository string) error <span class="cov0" title="0">{
        if err := r.assertInitialized(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.provider, provider),
                tag.Insert(r.eventType, event),
                tag.Insert(r.namespace, namespace),
                tag.Insert(r.repository, repository),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metrics.Record(ctx, prCount.M(1))
        return nil</span>
}

// CountPRDuration collects duration taken by a pipelinerun in seconds accumulate them in prDurationCount.
func (r *Recorder) CountPRDuration(namespace, repository, status, reason string, duration time.Duration) error <span class="cov0" title="0">{
        if err := r.assertInitialized(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.namespace, namespace),
                tag.Insert(r.repository, repository),
                tag.Insert(r.status, status),
                tag.Insert(r.reason, reason),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metrics.Record(ctx, prDurationCount.M(duration.Seconds()))
        return nil</span>
}

// RunningPipelineRuns emits the number of running PipelineRuns for a repository and namespace.
func (r *Recorder) RunningPipelineRuns(namespace, repository string, runningPRs float64) error <span class="cov0" title="0">{
        if err := r.assertInitialized(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.namespace, namespace),
                tag.Insert(r.repository, repository),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metrics.Record(ctx, runningPRCount.M(runningPRs))
        return nil</span>
}

func (r *Recorder) EmitRunningPRsMetrics(prl []*tektonv1.PipelineRun) error <span class="cov0" title="0">{
        if len(prl) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // bifurcate PipelineRuns based on their namespace and repository
        <span class="cov0" title="0">runningPRs := map[string]int{}
        completedPRsKeys := map[string]struct{}{}
        for _, pr := range prl </span><span class="cov0" title="0">{
                // Check if PipelineRun has Repository annotation it means PR is created by PAC.
                if repository, ok := pr.GetAnnotations()[keys.Repository]; ok </span><span class="cov0" title="0">{
                        key := fmt.Sprintf("%s/%s", pr.GetNamespace(), repository)
                        // check if PipelineRun is running.
                        if !pr.IsDone() </span><span class="cov0" title="0">{
                                runningPRs[key]++
                        }</span> else<span class="cov0" title="0"> {
                                // add it in completed, and we don't want completed PipelineRuns count.
                                completedPRsKeys[key] = struct{}{}
                        }</span>
                }
        }

        <span class="cov0" title="0">for k, v := range runningPRs </span><span class="cov0" title="0">{
                nsKeys := strings.Split(k, "/")
                if err := r.RunningPipelineRuns(nsKeys[0], nsKeys[1], float64(v)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // report zero for the keys which aren't in runningPRs.
        <span class="cov0" title="0">for key := range completedPRsKeys </span><span class="cov0" title="0">{
                // if key isn't there in runningPRs then it should be reported 0
                // otherwise it was reported in previous loop.
                if _, ok := runningPRs[key]; !ok </span><span class="cov0" title="0">{
                        nsKeys := strings.Split(key, "/")
                        if err := r.RunningPipelineRuns(nsKeys[0], nsKeys[1], 0); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ReportRunningPipelineRuns reports running PipelineRuns on our configured ReportingPeriod
// until the context is cancelled.
func (r *Recorder) ReportRunningPipelineRuns(ctx context.Context, lister listers.PipelineRunLister) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        for </span><span class="cov0" title="0">{
                delay := time.NewTimer(r.ReportingPeriod)
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // When the context is cancelled, stop reporting.
                        if !delay.Stop() </span><span class="cov0" title="0">{
                                &lt;-delay.C
                        }</span>
                        <span class="cov0" title="0">return</span>

                case &lt;-delay.C:<span class="cov0" title="0">
                        prl, err := lister.List(labels.Everything())
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Failed to list PipelineRuns : %v", err)
                                continue</span>
                        }
                        // Every 30s surface a metric for the number of running pipelines.
                        <span class="cov0" title="0">if err := r.EmitRunningPRsMetrics(prl); err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Failed to log the metrics : %v", err)
                        }</span>
                }
        }
}

func (r *Recorder) ReportGitProviderAPIUsage(provider, event, namespace, repository string) error <span class="cov0" title="0">{
        if err := r.assertInitialized(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.provider, provider),
                tag.Insert(r.eventType, event),
                tag.Insert(r.namespace, namespace),
                tag.Insert(r.repository, repository),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metrics.Record(ctx, gitProviderAPIRequestCount.M(1))
        return nil</span>
}

func ResetRecorder() <span class="cov0" title="0">{
        Once = sync.Once{}
        R = nil
        ErrRegistering = nil
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package opscomments

import (
        "regexp"
        "strings"
)

// ParseKeyValueArgs will parse things like key=value key="value" key="value1 value2"
// key="value1 \"value2\"" key=value1=value2.
func ParseKeyValueArgs(input string) map[string]string <span class="cov8" title="1">{
        if !strings.HasPrefix(input, "/") </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">keyValueRegex := regexp.MustCompile(`(\w+)=(?:"([^"\\]*(?:\\.[^"\\]*)*)"|([^"'\s]+))`)
        matches := keyValueRegex.FindAllStringSubmatch(input, -1)
        keyValuePairs := make(map[string]string)

        for _, match := range matches </span><span class="cov8" title="1">{
                key := match[1]
                var value string
                if match[2] != "" </span><span class="cov8" title="1">{
                        value = strings.ReplaceAll(match[2], `\"`, `"`)
                }</span> else<span class="cov8" title="1"> {
                        value = match[3]
                }</span>
                <span class="cov8" title="1">keyValuePairs[key] = value</span>
        }

        <span class="cov8" title="1">return keyValuePairs</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package opscomments

import (
        "fmt"
        "regexp"
        "strings"

        "go.uber.org/zap"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
)

var (
        testAllRegex      = regexp.MustCompile(`(?m)^/test\s*$`)
        retestAllRegex    = regexp.MustCompile(`(?m)^/retest\s*$`)
        testSingleRegex   = regexp.MustCompile(`(?m)^/test[ \t]+\S+`)
        retestSingleRegex = regexp.MustCompile(`(?m)^/retest[ \t]+\S+`)
        oktotestRegex     = regexp.MustCompile(`(?m)^/ok-to-test\s*$`)
        cancelAllRegex    = regexp.MustCompile(`(?m)^(/cancel)\s*$`)
        cancelSingleRegex = regexp.MustCompile(`(?m)^(/cancel)[ \t]+\S+`)
)

type EventType string

func (e EventType) String() string <span class="cov8" title="1">{
        return string(e)
}</span>

var (
        NoOpsCommentEventType        = EventType("no-ops-comment")
        TestAllCommentEventType      = EventType("test-all-comment")
        TestSingleCommentEventType   = EventType("test-comment")
        RetestSingleCommentEventType = EventType("retest-comment")
        RetestAllCommentEventType    = EventType("retest-all-comment")
        OnCommentEventType           = EventType("on-comment")
        CancelCommentSingleEventType = EventType("cancel-comment")
        CancelCommentAllEventType    = EventType("cancel-all-comment")
        OkToTestCommentEventType     = EventType("ok-to-test-comment")
)

const (
        testComment   = "/test"
        retestComment = "/retest"
        cancelComment = "/cancel"
)

func CommentEventType(comment string) EventType <span class="cov8" title="1">{
        switch </span>{
        case retestAllRegex.MatchString(comment):<span class="cov8" title="1">
                return RetestAllCommentEventType</span>
        case retestSingleRegex.MatchString(comment):<span class="cov8" title="1">
                return RetestSingleCommentEventType</span>
        case testAllRegex.MatchString(comment):<span class="cov8" title="1">
                return TestAllCommentEventType</span>
        case testSingleRegex.MatchString(comment):<span class="cov8" title="1">
                return TestSingleCommentEventType</span>
        case oktotestRegex.MatchString(comment):<span class="cov8" title="1">
                return OkToTestCommentEventType</span>
        case cancelAllRegex.MatchString(comment):<span class="cov8" title="1">
                return CancelCommentAllEventType</span>
        case cancelSingleRegex.MatchString(comment):<span class="cov8" title="1">
                return CancelCommentSingleEventType</span>
        default:<span class="cov8" title="1">
                return NoOpsCommentEventType</span>
        }
}

// SetEventTypeAndTargetPR function will set the event type and target test pipeline run in an event.
func SetEventTypeAndTargetPR(event *info.Event, comment string) <span class="cov8" title="1">{
        commentType := CommentEventType(comment)
        if commentType == RetestSingleCommentEventType || commentType == TestSingleCommentEventType </span><span class="cov8" title="1">{
                event.TargetTestPipelineRun = GetPipelineRunFromTestComment(comment)
        }</span>
        <span class="cov8" title="1">if commentType == CancelCommentAllEventType || commentType == CancelCommentSingleEventType </span><span class="cov8" title="1">{
                event.CancelPipelineRuns = true
        }</span>
        <span class="cov8" title="1">if commentType == CancelCommentSingleEventType </span><span class="cov8" title="1">{
                event.TargetCancelPipelineRun = GetPipelineRunFromCancelComment(comment)
        }</span>
        <span class="cov8" title="1">event.EventType = commentType.String()
        event.TriggerComment = comment</span>
}

func IsOkToTestComment(comment string) bool <span class="cov8" title="1">{
        return oktotestRegex.MatchString(comment)
}</span>

// EventTypeBackwardCompat handle the backward compatibility we need to keep until
// we have done the deprecated notice
//
// 2024-07-01 chmouel
//
//        set anyOpsComments to pull_request see https://issues.redhat.com/browse/SRVKP-5775
//        we keep on-comment to the "on-comment" type
func EventTypeBackwardCompat(eventEmitter *events.EventEmitter, repo *v1alpha1.Repository, label string) string <span class="cov8" title="1">{
        if label == OnCommentEventType.String() </span><span class="cov8" title="1">{
                return label
        }</span>
        <span class="cov8" title="1">if IsAnyOpsEventType(label) </span><span class="cov8" title="1">{
                eventEmitter.EmitMessage(repo, zap.WarnLevel, "DeprecatedOpsComment",
                        fmt.Sprintf("the %s event type is deprecated, this will be changed to %s in the future",
                                label, triggertype.PullRequest.String()))
                return triggertype.PullRequest.String()
        }</span>
        <span class="cov8" title="1">return label</span>
}

func IsAnyOpsEventType(eventType string) bool <span class="cov8" title="1">{
        return eventType == TestSingleCommentEventType.String() ||
                eventType == TestAllCommentEventType.String() ||
                eventType == RetestAllCommentEventType.String() ||
                eventType == RetestSingleCommentEventType.String() ||
                eventType == CancelCommentSingleEventType.String() ||
                eventType == CancelCommentAllEventType.String() ||
                eventType == OkToTestCommentEventType.String() ||
                eventType == OnCommentEventType.String()
}</span>

// AnyOpsKubeLabelInSelector will output a Kubernetes label out of all possible
// CommentEvent Type for selection.
func AnyOpsKubeLabelInSelector() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s,%s,%s,%s,%s,%s,%s,%s",
                TestSingleCommentEventType.String(),
                TestAllCommentEventType.String(),
                RetestAllCommentEventType.String(),
                RetestSingleCommentEventType.String(),
                CancelCommentSingleEventType.String(),
                CancelCommentAllEventType.String(),
                OkToTestCommentEventType.String(),
                OnCommentEventType.String())
}</span>

func GetPipelineRunFromTestComment(comment string) string <span class="cov8" title="1">{
        if strings.Contains(comment, testComment) </span><span class="cov8" title="1">{
                return getNameFromComment(testComment, comment)
        }</span>
        <span class="cov8" title="1">return getNameFromComment(retestComment, comment)</span>
}

func GetPipelineRunFromCancelComment(comment string) string <span class="cov8" title="1">{
        return getNameFromComment(cancelComment, comment)
}</span>

func getNameFromComment(typeOfComment, comment string) string <span class="cov8" title="1">{
        splitTest := strings.Split(strings.TrimSpace(comment), typeOfComment)
        if len(splitTest) &lt; 2 </span><span class="cov0" title="0">{
                return ""
        }</span>
        // now get the first line
        <span class="cov8" title="1">getFirstLine := strings.Split(splitTest[1], "\n")

        // and the first argument
        firstArg := strings.Split(getFirstLine[0], " ")
        if len(firstArg) &lt; 2 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // trim spaces
        <span class="cov8" title="1">return strings.TrimSpace(firstArg[1])</span>
}

func GetPipelineRunAndBranchNameFromTestComment(comment string) (string, string, error) <span class="cov8" title="1">{
        if strings.Contains(comment, testComment) </span><span class="cov8" title="1">{
                return getPipelineRunAndBranchNameFromComment(testComment, comment)
        }</span>
        <span class="cov8" title="1">return getPipelineRunAndBranchNameFromComment(retestComment, comment)</span>
}

func GetPipelineRunAndBranchNameFromCancelComment(comment string) (string, string, error) <span class="cov8" title="1">{
        return getPipelineRunAndBranchNameFromComment(cancelComment, comment)
}</span>

// getPipelineRunAndBranchNameFromComment function will take GitOps comment and split the comment
// by /test, /retest or /cancel to return branch name and pipelinerun name.
func getPipelineRunAndBranchNameFromComment(typeOfComment, comment string) (string, string, error) <span class="cov8" title="1">{
        var prName, branchName string
        splitTest := strings.Split(comment, typeOfComment)

        // after the split get the second part of the typeOfComment (/test, /retest or /cancel)
        // as second part can be branch name or pipelinerun name and branch name
        // ex: /test branch:nightly, /test prname branch:nightly
        if splitTest[1] != "" &amp;&amp; strings.Contains(splitTest[1], ":") </span><span class="cov8" title="1">{
                branchData := strings.Split(splitTest[1], ":")

                // make sure no other word is supported other than branch word
                if !strings.Contains(branchData[0], "branch") </span><span class="cov8" title="1">{
                        return prName, branchName, fmt.Errorf("the GitOps comment%s does not contain a branch word", branchData[0])
                }</span>
                <span class="cov8" title="1">branchName = strings.Split(strings.TrimSpace(branchData[1]), " ")[0]

                // if data after the split contains prname then fetch that
                prData := strings.Split(strings.TrimSpace(branchData[0]), " ")
                if len(prData) &gt; 1 </span><span class="cov8" title="1">{
                        prName = strings.TrimSpace(prData[0])
                }</span>
        } else<span class="cov8" title="1"> {
                // get the second part of the typeOfComment (/test, /retest or /cancel)
                // as second part contains pipelinerun name
                // ex: /test prname
                getFirstLine := strings.Split(splitTest[1], "\n")
                // trim spaces
                prName = strings.TrimSpace(getFirstLine[0])
        }</span>
        <span class="cov8" title="1">return prName, branchName, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package params

import (
        "os"

        "github.com/AlecAivazis/survey/v2"
        "github.com/AlecAivazis/survey/v2/terminal"
)

type PacCliOpts struct {
        NoColoring    bool
        AllNameSpaces bool
        Namespace     string
        AskOpts       survey.AskOpt
}

func NewCliOptions() *PacCliOpts <span class="cov0" title="0">{
        return &amp;PacCliOpts{
                AskOpts: func(opt *survey.AskOptions) error </span><span class="cov0" title="0">{
                        opt.Stdio = terminal.Stdio{
                                In:  os.Stdin,
                                Out: os.Stdout,
                                Err: os.Stderr,
                        }
                        return nil
                }</span>,
        }
}

func (c *PacCliOpts) Ask(qss []*survey.Question, answer any) error <span class="cov0" title="0">{
        return survey.Ask(qss, answer, c.AskOpts)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package clients

import (
        "context"
        "fmt"
        "io"
        "net"
        "net/http"
        "sync"
        "time"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/consoleui"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/clientset/versioned"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/pkg/errors"
        versioned2 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "go.uber.org/zap"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
)

const (
        // most programming languages  do not have a timeout, but c# does a default
        // of 100 seconds so using that value.
        ConnectMaxWaitTime = 100 * time.Second
        RequestMaxWaitTime = 100 * time.Second
)

type Clients struct {
        ClientInitialized bool
        PipelineAsCode    versioned.Interface
        Tekton            versioned2.Interface
        Kube              kubernetes.Interface
        HTTP              http.Client
        Log               *zap.SugaredLogger
        Dynamic           dynamic.Interface
        consoleUIMutex    *sync.Mutex
        consoleUI         consoleui.Interface
}

func (c *Clients) InitClients() <span class="cov0" title="0">{
        c.consoleUIMutex = &amp;sync.Mutex{}
}</span>

func (c *Clients) GetURL(ctx context.Context, url string) ([]byte, error) <span class="cov8" title="1">{
        nctx, cancel := context.WithTimeout(ctx, RequestMaxWaitTime)
        defer cancel()

        req, err := http.NewRequestWithContext(nctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov8" title="1">res, err := c.HTTP.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        statusOK := res.StatusCode &gt;= 200 &amp;&amp; res.StatusCode &lt; 300
        if !statusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Non-OK HTTP status: %d", res.StatusCode)
        }</span>

        <span class="cov8" title="1">data, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov8" title="1">return data, nil</span>
}

// Set kube client based on config.
func (c *Clients) kubeClient(config *rest.Config) (kubernetes.Interface, error) <span class="cov0" title="0">{
        k8scs, err := kubernetes.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create k8s client from config")
        }</span>

        <span class="cov0" title="0">return k8scs, nil</span>
}

func (c *Clients) dynamicClient(config *rest.Config) (dynamic.Interface, error) <span class="cov0" title="0">{
        dynamicClient, err := dynamic.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create dynamic client from config")
        }</span>
        <span class="cov0" title="0">return dynamicClient, err</span>
}

func (c *Clients) kubeConfig(info *info.Info) (*rest.Config, error) <span class="cov0" title="0">{
        loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
        if info.Kube.ConfigPath != "" </span><span class="cov0" title="0">{
                loadingRules.ExplicitPath = info.Kube.ConfigPath
        }</span>
        <span class="cov0" title="0">configOverrides := &amp;clientcmd.ConfigOverrides{}
        if info.Kube.Context != "" </span><span class="cov0" title="0">{
                configOverrides.CurrentContext = info.Kube.Context
        }</span>
        <span class="cov0" title="0">kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
        if info.Kube.Namespace == "" </span><span class="cov0" title="0">{
                namespace, _, err := kubeConfig.Namespace()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "Couldn't get kubeConfiguration namespace")
                }</span>
                <span class="cov0" title="0">info.Kube.Namespace = namespace</span>
        }
        <span class="cov0" title="0">config, err := kubeConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Parsing kubeconfig failed")
        }</span>
        <span class="cov0" title="0">return config, nil</span>
}

func (c *Clients) tektonClient(config *rest.Config) (versioned2.Interface, error) <span class="cov0" title="0">{
        cs, err := versioned2.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cs, nil</span>
}

func (c *Clients) pacClient(config *rest.Config) (versioned.Interface, error) <span class="cov0" title="0">{
        cs, err := versioned.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cs, nil</span>
}

func (c *Clients) consoleUIClient(ctx context.Context, dynamic dynamic.Interface, info *info.Info) consoleui.Interface <span class="cov0" title="0">{
        return consoleui.New(ctx, dynamic, info)
}</span>

func (c *Clients) NewClients(ctx context.Context, info *info.Info) error <span class="cov0" title="0">{
        if c.consoleUIMutex == nil </span><span class="cov0" title="0">{
                c.consoleUIMutex = &amp;sync.Mutex{}
        }</span>
        <span class="cov0" title="0">if c.ClientInitialized </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">prod, _ := zap.NewProduction()
        logger := prod.Sugar()
        defer func() </span><span class="cov0" title="0">{
                _ = logger.Sync() // flushes buffer, if any
        }</span>()
        <span class="cov0" title="0">c.Log = logger

        c.HTTP = http.Client{
                Timeout: RequestMaxWaitTime,
                Transport: &amp;http.Transport{
                        DialContext: (&amp;net.Dialer{
                                Timeout: ConnectMaxWaitTime,
                        }).DialContext,
                },
        }
        config, err := c.kubeConfig(info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">config.QPS = 50
        config.Burst = 50

        c.Kube, err = c.kubeClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.Tekton, err = c.tektonClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.PipelineAsCode, err = c.pacClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.Dynamic, err = c.dynamicClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.SetConsoleUI(c.consoleUIClient(ctx, c.Dynamic, info))
        c.ClientInitialized = true

        return nil</span>
}

func (c *Clients) ConsoleUI() consoleui.Interface <span class="cov0" title="0">{
        c.consoleUIMutex.Lock()
        defer c.consoleUIMutex.Unlock()
        return c.consoleUI
}</span>

func (c *Clients) SetConsoleUI(consoleUI consoleui.Interface) <span class="cov0" title="0">{
        if c.consoleUIMutex == nil </span><span class="cov0" title="0">{
                c.consoleUIMutex = &amp;sync.Mutex{}
        }</span>
        <span class="cov0" title="0">c.consoleUIMutex.Lock()
        defer c.consoleUIMutex.Unlock()
        c.consoleUI = consoleUI</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package params

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/informers"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/system"
)

func StartConfigSync(ctx context.Context, run *Run) <span class="cov0" title="0">{
        // init pac config
        _ = run.UpdatePacConfig(ctx)

        informerFactory := informers.NewSharedInformerFactoryWithOptions(run.Clients.Kube, 0,
                informers.WithNamespace(system.Namespace()),
                informers.WithTweakListOptions(func(opts *metav1.ListOptions) </span><span class="cov0" title="0">{
                        opts.FieldSelector = fmt.Sprintf("metadata.name=%s", run.Info.Controller.Configmap)
                }</span>))
        <span class="cov0" title="0">informer := informerFactory.Core().V1().ConfigMaps().Informer()
        _, _ = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
                AddFunc: func(_ any) </span>{<span class="cov0" title="0">
                        // nothing to do
                }</span>,
                UpdateFunc: func(_, _ any) <span class="cov0" title="0">{
                        _ = run.UpdatePacConfig(ctx)
                }</span>,
                DeleteFunc: func(_ any) {<span class="cov0" title="0">
                        // nothing to do
                }</span>,
        })

        <span class="cov0" title="0">stopCh := make(chan struct{})
        defer close(stopCh)

        // start the informer
        informer.Run(stopCh)

        // Wait for termination signal to stop the informer
        sig := make(chan os.Signal, 1)
        signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
        &lt;-sig</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package info

import (
        "context"
        "os"
)

var currentControllerName = contextKey("current-controller-name")

const (
        DefaultPipelinesAscodeSecretName = "pipelines-as-code-secret"

        DefaultPipelinesAscodeConfigmapName = "pipelines-as-code"
        DefaultGlobalRepoName               = "pipelines-as-code"
        defaultControllerLabel              = "default"
)

var InstallNamespaces = []string{"openshift-pipelines", "pipelines-as-code"}

type ControllerInfo struct {
        Name             string `json:"name"`
        Configmap        string `json:"configmap"`
        Secret           string `json:"secret"`
        GlobalRepository string `json:"gRepo"`
}

// GetControllerInfoFromEnvOrDefault retrieves controller info from the env or use the defaults
// TODO: handles doublons when fallbacking in case there is multiple
// controllers but no env variable.
func GetControllerInfoFromEnvOrDefault() *ControllerInfo <span class="cov8" title="1">{
        controllerlabel, ok := os.LookupEnv("PAC_CONTROLLER_LABEL")
        if !ok </span><span class="cov8" title="1">{
                controllerlabel = defaultControllerLabel
        }</span>
        <span class="cov8" title="1">controllerSecret, ok := os.LookupEnv("PAC_CONTROLLER_SECRET")
        if !ok </span><span class="cov8" title="1">{
                controllerSecret = DefaultPipelinesAscodeSecretName
        }</span>
        <span class="cov8" title="1">controllerConfigMap, ok := os.LookupEnv("PAC_CONTROLLER_CONFIGMAP")
        if !ok </span><span class="cov8" title="1">{
                controllerConfigMap = DefaultPipelinesAscodeConfigmapName
        }</span>
        <span class="cov8" title="1">globalRepo, ok := os.LookupEnv("PAC_CONTROLLER_GLOBAL_REPOSITORY")
        if !ok </span><span class="cov8" title="1">{
                globalRepo = DefaultGlobalRepoName
        }</span>
        <span class="cov8" title="1">return &amp;ControllerInfo{
                Name:             controllerlabel,
                Secret:           controllerSecret,
                Configmap:        controllerConfigMap,
                GlobalRepository: globalRepo,
        }</span>
}

// StoreCurrentControllerName stores current controller name in the context.
func StoreCurrentControllerName(ctx context.Context, name string) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, currentControllerName, name)
}</span>

// GetCurrentControllerName retrieves current controller name from the context.
func GetCurrentControllerName(ctx context.Context) string <span class="cov8" title="1">{
        if val := ctx.Value(currentControllerName); val != nil </span><span class="cov8" title="1">{
                if name, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return name
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package info

import (
        "net/http"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
)

type Event struct {
        State
        Event any

        // EventType is what coming from the provider header, i.e:
        // GitHub -&gt; pull_request
        // GitLab -&gt; Merge Request Hook
        // Incoming Webhook  -&gt; incoming (always a push)
        // Usually used for payload filtering passed from trigger directly
        EventType string

        // Full request
        Request *Request

        // TriggerTarget stable field across providers, ie: on GitLab, Github and
        // others it would be always be pull_request we can rely on to know if it's
        // a push or a pull_request
        TriggerTarget triggertype.Trigger

        // Target PipelineRun, the target PipelineRun user request. Used in incoming webhook
        TargetPipelineRun string

        BaseBranch    string // branch against where we are making the PR
        DefaultBranch string // master/main branches to know where things like the OWNERS file is located.
        HeadBranch    string // branch from where our SHA get tested
        BaseURL       string // url against where we are making the PR
        HeadURL       string // url from where our SHA get tested
        SHA           string
        Sender        string
        URL           string // WEB url not the git URL, which would match to the repo.spec
        SHAURL        string // pretty URL for web browsing for UIs (cli/web)
        SHATitle      string // commit title for UIs

        PullRequestNumber int      // Pull or Merge Request number
        PullRequestTitle  string   // Title of the pull Request
        PullRequestLabel  []string // Labels of the pull Request
        TriggerComment    string   // The comment triggering the pipelinerun when using on-comment annotation

        // TODO: move forge specifics to each driver
        // Github
        Organization   string
        Repository     string
        InstallationID int64
        GHEURL         string

        // TODO: move out inside the provider
        // Bitbucket Cloud
        AccountID string

        // TODO: move out inside the provider
        // Bitbucket Data Center
        CloneURL string // bitbucket data center has a different url for cloning the repo than normal public html url
        Provider *Provider

        // GitLab
        SourceProjectID int
        TargetProjectID int
}

type State struct {
        TargetTestPipelineRun   string
        CancelPipelineRuns      bool
        TargetCancelPipelineRun string
}

type Provider struct {
        Token                 string
        URL                   string
        User                  string
        WebhookSecret         string
        WebhookSecretFromRepo bool
}

type Request struct {
        Header  http.Header
        Payload []byte
}

// DeepCopyInto deep copy runinfo in another instance.
func (r *Event) DeepCopyInto(out *Event) <span class="cov8" title="1">{
        *out = *r
}</span>

// NewEvent returns a new Event.
func NewEvent() *Event <span class="cov8" title="1">{
        return &amp;Event{
                Provider: &amp;Provider{},
                Request:  &amp;Request{},
        }
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package info

import (
        "sync"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "go.uber.org/zap"
)

type Info struct {
        pacMutex   *sync.Mutex
        Pac        *PacOpts
        Kube       *KubeOpts
        Controller *ControllerInfo
}

func NewInfo() Info <span class="cov8" title="1">{
        return Info{
                pacMutex:   &amp;sync.Mutex{},
                Pac:        NewPacOpts(),
                Kube:       &amp;KubeOpts{},
                Controller: GetControllerInfoFromEnvOrDefault(),
        }
}</span>

func (i *Info) InitInfo() <span class="cov0" title="0">{
        i.pacMutex = &amp;sync.Mutex{}
}</span>

func (i *Info) GetPacOpts() PacOpts <span class="cov0" title="0">{
        if i.pacMutex == nil </span><span class="cov0" title="0">{
                i.pacMutex = &amp;sync.Mutex{}
        }</span>
        <span class="cov0" title="0">i.pacMutex.Lock()
        defer i.pacMutex.Unlock()
        return *i.Pac</span>
}

func (i *Info) UpdatePacOpts(logger *zap.SugaredLogger, configData map[string]string) (*settings.Settings, error) <span class="cov0" title="0">{
        if i.pacMutex == nil </span><span class="cov0" title="0">{
                i.pacMutex = &amp;sync.Mutex{}
        }</span>
        <span class="cov0" title="0">i.pacMutex.Lock()
        defer i.pacMutex.Unlock()

        if err := settings.SyncConfig(logger, &amp;i.Pac.Settings, configData, settings.DefaultValidators()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;i.Pac.Settings, nil</span>
}

func (i *Info) DeepCopy(out *Info) <span class="cov0" title="0">{
        *out = *i
}</span>

type (
        contextKey string
)
</pre>
		
		<pre class="file" id="file71" style="display: none">package info

import (
        "fmt"
        "os"
        "runtime"

        "github.com/spf13/cobra"
)

type KubeOpts struct {
        ConfigPath string
        Context    string
        Namespace  string
}

func userHomeDir() string <span class="cov8" title="1">{
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                home := os.Getenv("HOMEDRIVE") + os.Getenv("HOMEPATH")
                if home == "" </span><span class="cov0" title="0">{
                        home = os.Getenv("USERPROFILE")
                }</span>
                <span class="cov0" title="0">return home</span>
        }
        <span class="cov8" title="1">return os.Getenv("HOME")</span>
}

func (k *KubeOpts) AddFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        envkconfig := os.Getenv("KUBECONFIG")
        if envkconfig == "" </span><span class="cov8" title="1">{
                envkconfig = fmt.Sprintf("%s/.kube/config", userHomeDir())
        }</span>
        <span class="cov8" title="1">cmd.PersistentFlags().StringVarP(
                &amp;k.ConfigPath,
                "kubeconfig", "k", envkconfig,
                fmt.Sprintf("Path to the kubeconfig file to use for CLI requests (default: %s)", envkconfig))

        cmd.PersistentFlags().StringVarP(
                &amp;k.Namespace,
                "namespace", "n", "",
                "If present, the namespace scope for this CLI request")</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package info

import "context"

var nsContextKey = contextKey("namespace")

// StoreNS stores namespace in context.
func StoreNS(ctx context.Context, ns string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, nsContextKey, ns)
}</span>

// GetNS gets namespace from context.
func GetNS(ctx context.Context) string <span class="cov0" title="0">{
        if val := ctx.Value(nsContextKey); val != nil </span><span class="cov0" title="0">{
                if ns, ok := val.(string); ok </span><span class="cov0" title="0">{
                        return ns
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package info

import (
        "os"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "github.com/spf13/cobra"
)

type PacOpts struct {
        settings.Settings
        WebhookType        string
        PayloadFile        string
        TektonDashboardURL string
}

func NewPacOpts() *PacOpts <span class="cov8" title="1">{
        return &amp;PacOpts{
                Settings: settings.DefaultSettings(),
        }
}</span>

func (p *PacOpts) DeepCopy(out *PacOpts) <span class="cov0" title="0">{
        *out = *p
}</span>

func (p *PacOpts) AddFlags(cmd *cobra.Command) error <span class="cov0" title="0">{
        cmd.PersistentFlags().StringVarP(&amp;p.WebhookType, "git-provider-type", "",
                os.Getenv("PAC_GIT_PROVIDER_TYPE"),
                "Webhook type")

        cmd.PersistentFlags().StringVarP(&amp;p.PayloadFile,
                "payload-file", "", os.Getenv("PAC_PAYLOAD_FILE"), "A file containing the webhook payload")

        applicationName := os.Getenv("PAC_APPLICATION_NAME")
        cmd.Flags().StringVar(&amp;p.ApplicationName,
                "application-name", applicationName,
                "The name of the application.")

        secretAutoCreation := false
        secretAutoCreationEnv := os.Getenv("PAC_SECRET_AUTO_CREATE")
        if strings.ToLower(secretAutoCreationEnv) == "true" ||
                strings.ToLower(secretAutoCreationEnv) == "yes" || secretAutoCreationEnv == "1" </span><span class="cov0" title="0">{
                secretAutoCreation = true
        }</span>
        <span class="cov0" title="0">cmd.Flags().BoolVar(&amp;p.SecretAutoCreation,
                "secret-auto-creation",
                secretAutoCreation,
                "Whether to create automatically secrets.")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package params

import (
        "context"
        "fmt"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const pipelineAsCodeControllerName = "pipelines-as-code-controller"

func GetInstallLocation(ctx context.Context, run *Run) (string, string, error) <span class="cov8" title="1">{
        for _, ns := range info.InstallNamespaces </span><span class="cov8" title="1">{
                version := "unknown"
                deployment, err := run.Clients.Kube.AppsV1().Deployments(ns).Get(ctx, pipelineAsCodeControllerName, metav1.GetOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if val, ok := deployment.GetLabels()["app.kubernetes.io/version"]; ok </span><span class="cov8" title="1">{
                        version = val
                }</span>
                <span class="cov8" title="1">return ns, version, nil</span>
        }
        <span class="cov8" title="1">return "", "", fmt.Errorf("cannot find your pipelines-as-code installation, check that it is installed and you have access")</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package params

import (
        "context"
        "fmt"
        "os"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/consoleui"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/clients"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type Run struct {
        Clients clients.Clients
        Info    info.Info
}

func (r *Run) UpdatePacConfig(ctx context.Context) error <span class="cov0" title="0">{
        ns := info.GetNS(ctx)
        if ns == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find namespace")
        }</span>

        // TODO: move this to kubeinteractions class so we can add unittests.
        <span class="cov0" title="0">cfg, err := r.Clients.Kube.CoreV1().ConfigMaps(ns).Get(ctx, r.Info.Controller.Configmap, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">updatedPacInfo, err := r.Info.UpdatePacOpts(r.Clients.Log, cfg.Data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if updatedPacInfo.TektonDashboardURL != "" &amp;&amp; updatedPacInfo.TektonDashboardURL != r.Clients.ConsoleUI().URL() </span><span class="cov0" title="0">{
                r.Clients.Log.Infof("updating console url to: %s", updatedPacInfo.TektonDashboardURL)
                r.Clients.SetConsoleUI(&amp;consoleui.TektonDashboard{BaseURL: updatedPacInfo.TektonDashboardURL})
        }</span>
        <span class="cov0" title="0">if os.Getenv("PAC_TEKTON_DASHBOARD_URL") != "" </span><span class="cov0" title="0">{
                r.Clients.Log.Infof("using tekton dashboard url on: %s", os.Getenv("PAC_TEKTON_DASHBOARD_URL"))
                r.Clients.SetConsoleUI(&amp;consoleui.TektonDashboard{BaseURL: os.Getenv("PAC_TEKTON_DASHBOARD_URL")})
        }</span>
        <span class="cov0" title="0">if updatedPacInfo.CustomConsoleURL != "" </span><span class="cov0" title="0">{
                r.Clients.Log.Infof("updating console url to: %s", updatedPacInfo.CustomConsoleURL)
                pacInfo := r.Info.GetPacOpts()
                r.Clients.SetConsoleUI(consoleui.NewCustomConsole(&amp;pacInfo))
        }</span>

        // This is the case when reverted settings for CustomConsole and TektonDashboard then URL should point to OpenshiftConsole for Openshift platform
        <span class="cov0" title="0">if updatedPacInfo.CustomConsoleURL == "" &amp;&amp;
                (updatedPacInfo.TektonDashboardURL == "" &amp;&amp; os.Getenv("PAC_TEKTON_DASHBOARD_URL") == "") </span><span class="cov0" title="0">{
                r.Clients.SetConsoleUI(&amp;consoleui.OpenshiftConsole{})
                _ = r.Clients.ConsoleUI().UI(ctx, r.Clients.Dynamic)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func New() *Run <span class="cov0" title="0">{
        return &amp;Run{
                Info: info.NewInfo(),
        }
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package settings

import (
        "fmt"
        "net/url"
        "regexp"
        "strings"
        "sync"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/configutil"
        hubType "github.com/openshift-pipelines/pipelines-as-code/pkg/hub/vars"
        "go.uber.org/zap"
)

const (
        PACApplicationNameDefaultValue = "Pipelines as Code CI"

        HubURLKey                          = "hub-url"
        HubCatalogNameKey                  = "hub-catalog-name"
        HubCatalogTypeKey                  = "hub-catalog-type"
        TektonHubURLDefaultValue           = "https://api.hub.tekton.dev/v1"
        TektonHubCatalogNameDefaultValue   = "tekton"
        ArtifactHubCatalogNameDefaultValue = "artifacthub"
        ArtifactHubURLDefaultValue         = "https://artifacthub.io/api/v1"

        CustomConsoleNameKey         = "custom-console-name"
        CustomConsoleURLKey          = "custom-console-url"
        CustomConsolePRDetailKey     = "custom-console-url-pr-details"
        CustomConsolePRTaskLogKey    = "custom-console-url-pr-tasklog"
        CustomConsoleNamespaceURLKey = "custom-console-url-namespace"

        SecretGhAppTokenRepoScopedKey = "secret-github-app-token-scoped" //nolint: gosec
)

var (
        TknBinaryName       = `tkn`
        TknBinaryURL        = `https://tekton.dev/docs/cli/#installation`
        hubCatalogNameRegex = regexp.MustCompile(`^catalog-(\d+)-`)
)

type HubCatalog struct {
        Index string
        Name  string
        URL   string
        Type  string
}

// if there is a change performed on the default value,
// update the same on "config/302-pac-configmap.yaml".
type Settings struct {
        ApplicationName                     string `default:"Pipelines as Code CI" json:"application-name"`
        HubCatalogs                         *sync.Map
        RemoteTasks                         bool   `default:"true"                                 json:"remote-tasks"`
        MaxKeepRunsUpperLimit               int    `json:"max-keep-run-upper-limit"`
        DefaultMaxKeepRuns                  int    `json:"default-max-keep-runs"`
        BitbucketCloudCheckSourceIP         bool   `default:"true"                                 json:"bitbucket-cloud-check-source-ip"`
        BitbucketCloudAdditionalSourceIP    string `json:"bitbucket-cloud-additional-source-ip"`
        TektonDashboardURL                  string `json:"tekton-dashboard-url"`
        AutoConfigureNewGitHubRepo          bool   `default:"false"                                json:"auto-configure-new-github-repo"`
        AutoConfigureRepoNamespaceTemplate  string `json:"auto-configure-repo-namespace-template"`
        AutoConfigureRepoRepositoryTemplate string `json:"auto-configure-repo-repository-template"`

        SecretAutoCreation               bool   `default:"true"                             json:"secret-auto-create"`
        SecretGHAppRepoScoped            bool   `default:"true"                             json:"secret-github-app-token-scoped"`
        SecretGhAppTokenScopedExtraRepos string `json:"secret-github-app-scope-extra-repos"`

        ErrorLogSnippet              bool   `default:"true"                                                                          json:"error-log-snippet"`
        ErrorLogSnippetNumberOfLines int    `default:"3"                                                                             json:"error-log-snippet-number-of-lines"`
        ErrorDetection               bool   `default:"true"                                                                          json:"error-detection-from-container-logs"`
        ErrorDetectionNumberOfLines  int    `default:"50"                                                                            json:"error-detection-max-number-of-lines"`
        ErrorDetectionSimpleRegexp   string `default:"^(?P&lt;filename&gt;[^:]*):(?P&lt;line&gt;[0-9]+):(?P&lt;column&gt;[0-9]+)?([ ]*)?(?P&lt;error&gt;.*)" json:"error-detection-simple-regexp"`

        EnableCancelInProgressOnPullRequests bool `json:"enable-cancel-in-progress-on-pull-requests"`
        EnableCancelInProgressOnPush         bool `json:"enable-cancel-in-progress-on-push"`

        SkipPushEventForPRCommits bool `json:"skip-push-event-for-pr-commits" default:"true"` // nolint:tagalign

        CustomConsoleName         string `json:"custom-console-name"`
        CustomConsoleURL          string `json:"custom-console-url"`
        CustomConsolePRdetail     string `json:"custom-console-url-pr-details"`
        CustomConsolePRTaskLog    string `json:"custom-console-url-pr-tasklog"`
        CustomConsoleNamespaceURL string `json:"custom-console-url-namespace"`

        RememberOKToTest bool `json:"remember-ok-to-test"`
}

func (s *Settings) DeepCopy(out *Settings) <span class="cov0" title="0">{
        *out = *s
}</span>

func DefaultSettings() Settings <span class="cov8" title="1">{
        newSettings := &amp;Settings{}
        hubCatalog := &amp;sync.Map{}
        hubCatalog.Store("default", HubCatalog{
                Index: "default",
                URL:   ArtifactHubURLDefaultValue,
                Type:  hubType.ArtifactHubType,
        })
        newSettings.HubCatalogs = hubCatalog

        _ = configutil.ValidateAndAssignValues(nil, map[string]string{}, newSettings, map[string]func(string) error{}, false)

        return *newSettings
}</span>

func DefaultValidators() map[string]func(string) error <span class="cov8" title="1">{
        return map[string]func(string) error{
                "ErrorDetectionSimpleRegexp": isValidRegex,
                "TektonDashboardURL":         isValidURL,
                "CustomConsoleURL":           isValidURL,
                "CustomConsolePRTaskLog":     startWithHTTPorHTTPS,
                "CustomConsolePRDetail":      startWithHTTPorHTTPS,
        }
}</span>

func SyncConfig(logger *zap.SugaredLogger, setting *Settings, config map[string]string, validators map[string]func(string) error) error <span class="cov8" title="1">{
        setting.HubCatalogs = getHubCatalogs(logger, setting.HubCatalogs, config)

        err := configutil.ValidateAndAssignValues(logger, config, setting, validators, true)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to validate and assign values: %w", err)
        }</span>

        <span class="cov8" title="1">value, _ := setting.HubCatalogs.Load("default")
        catalogDefault, ok := value.(HubCatalog)
        if ok </span><span class="cov8" title="1">{
                if catalogDefault.URL != config[HubURLKey] </span><span class="cov0" title="0">{
                        logger.Infof("CONFIG: hub URL set to %v", config[HubURLKey])
                        catalogDefault.URL = config[HubURLKey]
                }</span>
                <span class="cov8" title="1">if catalogDefault.Name != config[HubCatalogNameKey] </span><span class="cov0" title="0">{
                        logger.Infof("CONFIG: hub catalog name set to %v", config[HubCatalogNameKey])
                        catalogDefault.Name = config[HubCatalogNameKey]
                }</span>
        }
        <span class="cov8" title="1">setting.HubCatalogs.Store("default", catalogDefault)
        // TODO: detect changes in extra hub catalogs

        return nil</span>
}

func isValidURL(rawURL string) error <span class="cov8" title="1">{
        if _, err := url.ParseRequestURI(rawURL); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid value for URL, error: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func isValidRegex(regex string) error <span class="cov8" title="1">{
        if _, err := regexp.Compile(regex); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid regex: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func startWithHTTPorHTTPS(url string) error <span class="cov8" title="1">{
        if !strings.HasPrefix(url, "http://") &amp;&amp; !strings.HasPrefix(url, "https://") </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid value, must start with http:// or https://")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package settings

import (
        "fmt"
        "net/url"
        "sync"

        hubtypes "github.com/openshift-pipelines/pipelines-as-code/pkg/hub/vars"
        "go.uber.org/zap"
)

func getHubCatalogs(logger *zap.SugaredLogger, catalogs *sync.Map, config map[string]string) *sync.Map <span class="cov8" title="1">{
        if catalogs == nil </span><span class="cov8" title="1">{
                catalogs = &amp;sync.Map{}
        }</span>
        <span class="cov8" title="1">if hubURL, ok := config[HubURLKey]; !ok || hubURL == "" </span><span class="cov8" title="1">{
                config[HubURLKey] = ArtifactHubURLDefaultValue
                logger.Infof("CONFIG: using default hub url %s", ArtifactHubURLDefaultValue)
        }</span>

        <span class="cov8" title="1">if hubType, ok := config[HubCatalogTypeKey]; !ok || hubType == "" </span><span class="cov8" title="1">{
                config[HubCatalogTypeKey] = hubtypes.ArtifactHubType
        }</span> else<span class="cov8" title="1"> if hubType != hubtypes.ArtifactHubType &amp;&amp; hubType != hubtypes.TektonHubType </span><span class="cov8" title="1">{
                logger.Warnf("CONFIG: invalid hub type %s, defaulting to %s", hubType, hubtypes.ArtifactHubType)
                config[HubCatalogTypeKey] = hubtypes.ArtifactHubType
        }</span>
        <span class="cov8" title="1">hc := HubCatalog{
                Index: "default",
                Name:  config[HubCatalogNameKey],
                URL:   config[HubURLKey],
                Type:  config[HubCatalogTypeKey],
        }
        catalogs.Store("default", hc)

        exists := false
        catalogs.Range(func(_, value interface{}) bool </span><span class="cov8" title="1">{
                if catalog, ok := value.(HubCatalog); ok &amp;&amp; catalog.Type == hubtypes.TektonHubType </span><span class="cov8" title="1">{
                        exists = true
                        return false // Stop iteration
                }</span>
                <span class="cov8" title="1">return true</span> // Continue iteration
        })
        <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                catalogs.Store(hubtypes.TektonHubType, HubCatalog{
                        Index: hubtypes.TektonHubType,
                        Name:  TektonHubCatalogNameDefaultValue,
                        URL:   TektonHubURLDefaultValue,
                        Type:  hubtypes.TektonHubType,
                })
        }</span>

        <span class="cov8" title="1">for k := range config </span><span class="cov8" title="1">{
                m := hubCatalogNameRegex.FindStringSubmatch(k)
                if len(m) &gt; 0 </span><span class="cov8" title="1">{
                        index := m[1]
                        cPrefix := fmt.Sprintf("catalog-%s", index)
                        skip := false
                        for _, kk := range []string{"id", "name", "url"} </span><span class="cov8" title="1">{
                                cKey := fmt.Sprintf("%s-%s", cPrefix, kk)
                                // check if key exist in config
                                if _, ok := config[cKey]; !ok </span><span class="cov8" title="1">{
                                        logger.Warnf("CONFIG: hub %v should have the key %s, skipping catalog configuration", index, cKey)
                                        skip = true
                                        break</span>
                                } else<span class="cov8" title="1"> if config[cKey] == "" </span><span class="cov8" title="1">{
                                        logger.Warnf("CONFIG: hub %v catalog configuration have empty value for key %s, skipping catalog configuration", index, cKey)
                                        skip = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !skip </span><span class="cov8" title="1">{
                                catalogID := config[fmt.Sprintf("%s-id", cPrefix)]
                                if catalogID == "http" || catalogID == "https" </span><span class="cov8" title="1">{
                                        logger.Warnf("CONFIG: custom hub catalog name cannot be %s, skipping catalog configuration", catalogID)
                                        break</span>
                                }
                                <span class="cov8" title="1">catalogURL := config[fmt.Sprintf("%s-url", cPrefix)]
                                u, err := url.Parse(catalogURL)
                                if err != nil || u.Scheme == "" || u.Host == "" </span><span class="cov8" title="1">{
                                        logger.Warnf("CONFIG: custom hub %s, catalog url %s is not valid, skipping catalog configuration", catalogID, catalogURL)
                                        break</span>
                                }
                                <span class="cov8" title="1">catalogName := config[fmt.Sprintf("%s-name", cPrefix)]
                                catalogType := config[fmt.Sprintf("%s-type", cPrefix)]
                                if catalogType == "" </span><span class="cov8" title="1">{
                                        catalogType = hubtypes.ArtifactHubType // default to artifact hub if not specified
                                }</span>

                                <span class="cov8" title="1">value, ok := catalogs.Load(catalogID)
                                if ok </span><span class="cov8" title="1">{
                                        catalogValues, ok := value.(HubCatalog)
                                        if ok &amp;&amp; (catalogValues.Name == catalogName) &amp;&amp; (catalogValues.URL == catalogURL) &amp;&amp; (catalogValues.Index == index) &amp;&amp; (catalogValues.Type == catalogType) </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">logger.Infof("CONFIG: setting custom hub %s, catalog %s", catalogID, catalogURL)
                                catalogs.Store(catalogID, HubCatalog{
                                        Index: index,
                                        Name:  catalogName,
                                        URL:   catalogURL,
                                        Type:  catalogType,
                                })</span>
                        }
                }
        }
        <span class="cov8" title="1">return catalogs</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package triggertype

type (
        Trigger string
)

// IsPullRequestType all Triggertype that are actually a pull request.
func IsPullRequestType(s string) Trigger <span class="cov0" title="0">{
        eventType := s
        switch s </span>{
        case PullRequest.String(), OkToTest.String(), Retest.String(), Cancel.String(), PullRequestLabeled.String():<span class="cov0" title="0">
                eventType = PullRequest.String()</span>
        }
        <span class="cov0" title="0">return Trigger(eventType)</span>
}

func (t Trigger) String() string <span class="cov0" title="0">{
        return string(t)
}</span>

func StringToType(s string) Trigger <span class="cov0" title="0">{
        switch s </span>{
        case OkToTest.String():<span class="cov0" title="0">
                return OkToTest</span>
        case Retest.String():<span class="cov0" title="0">
                return Retest</span>
        case Push.String():<span class="cov0" title="0">
                return Push</span>
        case PullRequest.String():<span class="cov0" title="0">
                return PullRequest</span>
        case Cancel.String():<span class="cov0" title="0">
                return Cancel</span>
        case CheckSuiteRerequested.String():<span class="cov0" title="0">
                return CheckSuiteRerequested</span>
        case CheckRunRerequested.String():<span class="cov0" title="0">
                return CheckRunRerequested</span>
        case Incoming.String():<span class="cov0" title="0">
                return Incoming</span>
        case Comment.String():<span class="cov0" title="0">
                return Comment</span>
        case PullRequestLabeled.String():<span class="cov0" title="0">
                return PullRequestLabeled</span>
        }
        <span class="cov0" title="0">return ""</span>
}

const (
        Cancel                Trigger = "cancel"
        CheckRunRerequested   Trigger = "check-run-rerequested"
        CheckSuiteRerequested Trigger = "check-suite-rerequested"
        Comment               Trigger = "comment"
        Incoming              Trigger = "incoming"
        PullRequestLabeled    Trigger = "pull_request_labeled"
        OkToTest              Trigger = "ok-to-test"
        PullRequestClosed     Trigger = "pull_request_closed"
        PullRequest           Trigger = "pull_request" // it's should be "pull_request_opened_updated" but let's keep it simple.
        Push                  Trigger = "push"
        Retest                Trigger = "retest"
)
</pre>
		
		<pre class="file" id="file79" style="display: none">package pipelineascode

import (
        "context"
        "fmt"
        "strconv"
        "strings"
        "sync"

        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/action"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
)

type matchingCond func(pr tektonv1.PipelineRun) bool

var cancelMergePatch = map[string]any{
        "spec": map[string]any{
                "status": tektonv1.PipelineRunSpecStatusCancelledRunFinally,
        },
}

// cancelAllInProgressBelongingToClosedPullRequest cancels all in-progress PipelineRuns
// that belong to a specific pull request in the given repository.
func (p *PacRun) cancelAllInProgressBelongingToClosedPullRequest(ctx context.Context, repo *v1alpha1.Repository) error <span class="cov8" title="1">{
        labelsMap := map[string]string{
                keys.URLRepository: formatting.CleanValueKubernetes(p.event.Repository),
                keys.PullRequest:   strconv.Itoa(p.event.PullRequestNumber),
        }
        operator := selection.Equals
        cancelInProgress := fmt.Sprintf("%t", p.pacInfo.EnableCancelInProgressOnPullRequests)

        // First, build the label selector based on the URLRepository and PullRequest fields,
        // followed by applying filtering logic for the 'cancel-in-progress' annotation.
        labelSelector := getLabelSelector(labelsMap, operator)
        labelSelector += fmt.Sprintf(",%s in (pull_request, Merge_Request, %s)", keys.EventType, opscomments.AnyOpsKubeLabelInSelector())

        if cancelInProgress == "true" </span><span class="cov8" title="1">{
                // When the 'cancel-in-progress' setting is enabled globally via the Pipelines-as-Code ConfigMap,
                // then exclude those PipelineRuns that explicitly override this setting by having the
                // 'cancel-in-progress' annotation set to 'false' and continue cancelling others which are having
                // 'cancel-in-progress' annotation set to 'true' or with no annotation specified at all and are
                // subjected to cancellation under the global setting.
                //
                // Note: The 'selection.NotIn' operator is used to exclude PipelineRuns that have the
                // 'cancel-in-progress' annotation explicitly set to 'false', effectively opting them out of cancellation.
                labelsMap = map[string]string{keys.CancelInProgress: "false"}
                operator = selection.NotIn //codespell:ignore 'NotIn'
        }</span> else<span class="cov8" title="1"> {
                // When the 'cancel-in-progress' setting is disabled globally via the Pipelines-as-Code ConfigMap,
                // filter and list only those PipelineRuns that explicitly override the global setting by having the
                // 'cancel-in-progress' annotation set to 'true'.
                labelsMap = map[string]string{keys.CancelInProgress: "true"}
        }</span>
        // Append the label selector filter for the 'cancel-in-progress' annotation.
        <span class="cov8" title="1">labelSelector += fmt.Sprintf(",%s", getLabelSelector(labelsMap, operator))

        prs, err := p.run.Clients.Tekton.TektonV1().PipelineRuns(repo.Namespace).List(ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list pipelineRuns : %w", err)
        }</span>

        <span class="cov8" title="1">if len(prs.Items) == 0 </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("no pipelinerun found for repository: %v and pullRequest %v",
                        p.event.Repository, p.event.PullRequestNumber)
                p.eventEmitter.EmitMessage(repo, zap.InfoLevel, "CancelInProgress", msg)
                return nil
        }</span>

        <span class="cov8" title="1">p.cancelPipelineRuns(ctx, prs, repo, func(_ tektonv1.PipelineRun) bool </span><span class="cov8" title="1">{
                return true
        }</span>)

        <span class="cov8" title="1">return nil</span>
}

// cancelInProgressMatchingPR cancels all PipelineRuns associated with a given repository and pull request,
// except for the one that triggered the cancellation. It first checks if the cancellation is in progress
// and if the repository has a concurrency limit. If a concurrency limit is set, it returns an error as
// cancellation is not supported with concurrency limits. It then retrieves the original pull request name
// from the annotations and lists all PipelineRuns with matching labels. For each PipelineRun that is not
// already done, cancelled, or gracefully stopped, it patches the PipelineRun to cancel it.
func (p *PacRun) cancelInProgressMatchingPipelineRun(ctx context.Context, matchPR *tektonv1.PipelineRun, repo *v1alpha1.Repository) error <span class="cov8" title="1">{
        if matchPR == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">cancelInProgress := ""
        cancellingVia := "globally via Pipelines-as-Code ConfigMap"
        // First, check value from Pipelines-as-Code ConfigMap for the event type
        if p.event.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{ //nolint: staticcheck
                cancelInProgress = fmt.Sprintf("%t", p.pacInfo.EnableCancelInProgressOnPullRequests)
        }</span> else<span class="cov8" title="1"> if p.event.TriggerTarget == triggertype.Push </span><span class="cov8" title="1">{
                cancelInProgress = fmt.Sprintf("%t", p.pacInfo.EnableCancelInProgressOnPush)
        }</span>

        // As per feature behavior, PipelineRun annotation should override setting of Pipelines-as-Code ConfigMap
        <span class="cov8" title="1">if value, ok := matchPR.GetAnnotations()[keys.CancelInProgress]; ok </span><span class="cov8" title="1">{
                cancelInProgress = value
                cancellingVia = "via PipelineRun annotation"
        }</span>

        <span class="cov8" title="1">if cancelInProgress != "true" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">p.run.Clients.Log.Infof("cancel-in-progress for event %s is enabled %s", string(p.event.TriggerTarget), cancellingVia)

        // As PipelineRuns are filtered by name, OriginalPRName should be taken from
        // labels instead of annotations because of constraints imposed by kube API.
        prName, ok := matchPR.GetLabels()[keys.OriginalPRName]
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if repo.Spec.ConcurrencyLimit != nil &amp;&amp; *repo.Spec.ConcurrencyLimit &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("cancel in progress is not supported with concurrency limit")
        }</span>

        <span class="cov8" title="1">labelMap := map[string]string{
                keys.URLRepository:  formatting.CleanValueKubernetes(p.event.Repository),
                keys.OriginalPRName: prName,
        }
        if p.event.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                labelMap[keys.PullRequest] = strconv.Itoa(p.event.PullRequestNumber)
        }</span>
        <span class="cov8" title="1">labelSelector := getLabelSelector(labelMap, selection.Equals)
        if p.event.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                // "Merge_Request" included since EventType is not normalized to "Pull Request" like TriggerTarget
                labelSelector += fmt.Sprintf(",%s in (pull_request, Merge_Request, %s)", keys.EventType, opscomments.AnyOpsKubeLabelInSelector())
        }</span>
        <span class="cov8" title="1">p.run.Clients.Log.Infof("cancel-in-progress: selecting pipelineRuns to cancel with labels: %v", labelSelector)
        prs, err := p.run.Clients.Tekton.TektonV1().PipelineRuns(matchPR.GetNamespace()).List(ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list pipelineRuns : %w", err)
        }</span>

        <span class="cov8" title="1">p.cancelPipelineRuns(ctx, prs, repo, func(pr tektonv1.PipelineRun) bool </span><span class="cov8" title="1">{
                // skip our own for cancellation
                if sourceBranch, ok := pr.GetAnnotations()[keys.SourceBranch]; ok </span><span class="cov8" title="1">{
                        // NOTE(chmouel): Every PR has their own branch and so is every push to different branch
                        // it means we only cancel pipelinerun of the same name that runs to
                        // the unique branch. Note: HeadBranch is the branch from where the PR
                        // comes from in git jargon.
                        if strings.TrimPrefix(sourceBranch, "refs/heads/") != strings.TrimPrefix(p.event.HeadBranch, "refs/heads/") </span><span class="cov8" title="1">{
                                p.logger.Infof("cancel-in-progress: skipping pipelinerun %v/%v as it is not from the same branch, annotation source-branch: %s event headbranch: %s", pr.GetNamespace(), pr.GetName(), sourceBranch, p.event.HeadBranch)
                                return false
                        }</span>
                }

                <span class="cov8" title="1">return pr.GetName() != matchPR.GetName()</span>
        })
        <span class="cov8" title="1">return nil</span>
}

// cancelPipelineRunsOpsComment cancels all PipelineRuns associated with a given repository and pull request.
// when the user issue a cancel comment.
func (p *PacRun) cancelPipelineRunsOpsComment(ctx context.Context, repo *v1alpha1.Repository) error <span class="cov8" title="1">{
        labelSelector := getLabelSelector(map[string]string{
                keys.URLRepository: formatting.CleanValueKubernetes(p.event.Repository),
                keys.SHA:           formatting.CleanValueKubernetes(p.event.SHA),
        }, selection.Equals)

        if p.event.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                labelSelector = getLabelSelector(map[string]string{
                        keys.PullRequest: strconv.Itoa(p.event.PullRequestNumber),
                }, selection.Equals)
        }</span>

        <span class="cov8" title="1">prs, err := p.run.Clients.Tekton.TektonV1().PipelineRuns(repo.Namespace).List(ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to list pipelineRuns : %w", err)
        }</span>

        <span class="cov8" title="1">if len(prs.Items) == 0 </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("no pipelinerun found for repository: %v , sha: %v and pulRequest %v",
                        p.event.Repository, p.event.SHA, p.event.PullRequestNumber)
                p.eventEmitter.EmitMessage(repo, zap.InfoLevel, "CancelInProgress", msg)
                return nil
        }</span>

        <span class="cov8" title="1">p.cancelPipelineRuns(ctx, prs, repo, func(pr tektonv1.PipelineRun) bool </span><span class="cov8" title="1">{
                if p.event.TargetCancelPipelineRun != "" </span><span class="cov8" title="1">{
                        if prName, ok := pr.GetAnnotations()[keys.OriginalPRName]; !ok || prName != p.event.TargetCancelPipelineRun </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        })

        <span class="cov8" title="1">return nil</span>
}

func (p *PacRun) cancelPipelineRuns(ctx context.Context, prs *tektonv1.PipelineRunList, repo *v1alpha1.Repository, condition matchingCond) <span class="cov8" title="1">{
        var wg sync.WaitGroup
        for _, pr := range prs.Items </span><span class="cov8" title="1">{
                if !condition(pr) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if pr.IsCancelled() || pr.IsGracefullyCancelled() || pr.IsGracefullyStopped() </span><span class="cov8" title="1">{
                        p.logger.Infof("cancel-in-progress: skipping cancelling pipelinerun %v/%v, already in %v state", pr.GetNamespace(), pr.GetName(), pr.Spec.Status)
                        continue</span>
                }

                <span class="cov8" title="1">if pr.IsDone() </span><span class="cov8" title="1">{
                        p.logger.Infof("cancel-in-progress: skipping cancelling pipelinerun %v/%v, already done", pr.GetNamespace(), pr.GetName())
                        continue</span>
                }

                <span class="cov8" title="1">p.logger.Infof("cancel-in-progress: cancelling pipelinerun %v/%v", pr.GetNamespace(), pr.GetName())
                wg.Add(1)
                go func(ctx context.Context, pr tektonv1.PipelineRun) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        if _, err := action.PatchPipelineRun(ctx, p.logger, "cancel patch", p.run.Clients.Tekton, &amp;pr, cancelMergePatch); err != nil </span><span class="cov0" title="0">{
                                errMsg := fmt.Sprintf("failed to cancel pipelineRun %s/%s: %s", pr.GetNamespace(), pr.GetName(), err.Error())
                                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "CancelInProgress", errMsg)
                        }</span>
                }(ctx, pr)
        }
        <span class="cov8" title="1">wg.Wait()</span>
}

func getLabelSelector(labelsMap map[string]string, operator selection.Operator) string <span class="cov8" title="1">{
        labelSelector := labels.NewSelector()
        for k, v := range labelsMap </span><span class="cov8" title="1">{
                req, _ := labels.NewRequirement(k, operator, []string{v})
                if req != nil </span><span class="cov8" title="1">{
                        labelSelector = labelSelector.Add(*req)
                }</span>
        }
        <span class="cov8" title="1">return labelSelector.String()</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package pipelineascode

import (
        "fmt"
        "sync"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/sort"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/apimachinery/pkg/runtime"
)

const namePath = "{.metadata.name}"

type ConcurrencyManager struct {
        enabled      bool
        pipelineRuns []*v1.PipelineRun
        mutex        *sync.Mutex
}

func NewConcurrencyManager() *ConcurrencyManager <span class="cov8" title="1">{
        return &amp;ConcurrencyManager{
                pipelineRuns: []*v1.PipelineRun{},
                mutex:        &amp;sync.Mutex{},
        }
}</span>

func (c *ConcurrencyManager) AddPipelineRun(pr *v1.PipelineRun) <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if pr == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">c.mutex.Lock()
        defer c.mutex.Unlock()

        c.pipelineRuns = append(c.pipelineRuns, pr)</span>
}

func (c *ConcurrencyManager) Enable() <span class="cov8" title="1">{
        c.enabled = true
}</span>

func (c *ConcurrencyManager) GetExecutionOrder() (string, []*v1.PipelineRun) <span class="cov8" title="1">{
        if !c.enabled </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if len(c.pipelineRuns) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">runtimeObjs := []runtime.Object{}
        for _, pr := range c.pipelineRuns </span><span class="cov8" title="1">{
                if pr != nil &amp;&amp; pr.Name != "" </span><span class="cov8" title="1">{
                        runtimeObjs = append(runtimeObjs, pr)
                }</span>
        }

        <span class="cov8" title="1">if len(runtimeObjs) == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        // sort runs by name
        <span class="cov8" title="1">sort.ByField(namePath, runtimeObjs)

        sortedPipelineRuns := []*v1.PipelineRun{}
        for _, run := range runtimeObjs </span><span class="cov8" title="1">{
                pr, _ := run.(*v1.PipelineRun)
                sortedPipelineRuns = append(sortedPipelineRuns, pr)
        }</span>
        <span class="cov8" title="1">c.pipelineRuns = sortedPipelineRuns

        return getOrderByName(c.pipelineRuns), c.pipelineRuns</span>
}

func getOrderByName(runs []*v1.PipelineRun) string <span class="cov8" title="1">{
        var order string
        for _, run := range runs </span><span class="cov8" title="1">{
                if order == "" </span><span class="cov8" title="1">{
                        order = fmt.Sprintf("%s/%s", run.GetNamespace(), run.GetName())
                        continue</span>
                }
                <span class="cov8" title="1">order = order + "," + fmt.Sprintf("%s/%s", run.GetNamespace(), run.GetName())</span>
        }
        <span class="cov8" title="1">return order</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package pipelineascode

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        pacerrors "github.com/openshift-pipelines/pipelines-as-code/pkg/errors"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
)

const (
        tektonDirMissingError = ".tekton/ directory doesn't exist in repository's root directory"
)

var regexpIgnoreErrors = regexp.MustCompile(`.*no kind.*is registered for version.*in scheme.*`)

func (p *PacRun) checkAccessOrError(ctx context.Context, repo *v1alpha1.Repository, status provider.StatusOpts, viamsg string) (bool, error) <span class="cov8" title="1">{
        allowed, err := p.vcx.IsAllowed(ctx, p.event)
        if err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("unable to verify event authorization: %w", err)
        }</span>
        <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov8" title="1">msg := fmt.Sprintf("User %s is not allowed to trigger CI %s in this repo.", p.event.Sender, viamsg)
        if p.event.AccountID != "" </span><span class="cov8" title="1">{
                msg = fmt.Sprintf("User: %s AccountID: %s is not allowed to trigger CI %s in this repo.", p.event.Sender, p.event.AccountID, viamsg)
        }</span>
        <span class="cov8" title="1">p.eventEmitter.EmitMessage(repo, zap.InfoLevel, "RepositoryPermissionDenied", msg)
        status.Text = msg

        if err := p.vcx.CreateStatus(ctx, p.event, status); err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("failed to run create status, user is not allowed to run the CI:: %w", err)
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

// reportValidationErrors reports validation errors found in PipelineRuns by:
// 1. Creating error messages for each validation error
// 2. Emitting error messages to the event system
// 3. Creating a markdown formatted comment on the repository with all errors.
func (p *PacRun) reportValidationErrors(ctx context.Context, repo *v1alpha1.Repository, validationErrors []*pacerrors.PacYamlValidations) <span class="cov8" title="1">{
        errorRows := make([]string, 0, len(validationErrors))
        for _, err := range validationErrors </span><span class="cov8" title="1">{
                // if the error is a TektonConversionError, we don't want to report it since it may be a file that is not a tekton resource
                // and we don't want to report it as a validation error.
                if !regexpIgnoreErrors.MatchString(err.Err.Error()) &amp;&amp; (strings.HasPrefix(err.Schema, tektonv1.SchemeGroupVersion.Group) || err.Schema == pacerrors.GenericBadYAMLValidation) </span><span class="cov8" title="1">{
                        errorRows = append(errorRows, fmt.Sprintf("| %s | `%s` |", err.Name, err.Err.Error()))
                }</span>
                <span class="cov8" title="1">p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "PipelineRunValidationErrors",
                        fmt.Sprintf("cannot read the PipelineRun: %s, error: %s", err.Name, err.Err.Error()))</span>
        }
        <span class="cov8" title="1">if len(errorRows) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">markdownErrMessage := fmt.Sprintf(`%s
%s`, provider.ValidationErrorTemplate, strings.Join(errorRows, "\n"))
        if err := p.vcx.CreateComment(ctx, p.event, markdownErrMessage, provider.ValidationErrorTemplate); err != nil </span><span class="cov8" title="1">{
                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "PipelineRunCommentCreationError",
                        fmt.Sprintf("failed to create comment: %s", err.Error()))
        }</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package pipelineascode

import (
        "context"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"

        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        pacerrors "github.com/openshift-pipelines/pipelines-as-code/pkg/errors"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/matcher"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/resolve"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/templates"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
)

func (p *PacRun) matchRepoPR(ctx context.Context) ([]matcher.Match, *v1alpha1.Repository, error) <span class="cov8" title="1">{
        repo, err := p.verifyRepoAndUser(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">if repo == nil </span><span class="cov8" title="1">{
                return nil, nil, nil
        }</span>

        <span class="cov8" title="1">if p.event.CancelPipelineRuns </span><span class="cov0" title="0">{
                return nil, repo, p.cancelPipelineRunsOpsComment(ctx, repo)
        }</span>

        <span class="cov8" title="1">matchedPRs, err := p.getPipelineRunsFromRepo(ctx, repo)
        if err != nil </span><span class="cov8" title="1">{
                return nil, repo, err
        }</span>

        <span class="cov8" title="1">return matchedPRs, repo, nil</span>
}

// verifyRepoAndUser verifies if the Repo CR exists for the Git Repository,
// if the user has permission to run CI  and also initialise provider client.
func (p *PacRun) verifyRepoAndUser(ctx context.Context) (*v1alpha1.Repository, error) <span class="cov8" title="1">{
        // Match the Event URL to a Repository URL,
        repo, err := matcher.MatchEventURLRepo(ctx, p.run, p.event, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error matching Repository for event: %w", err)
        }</span>

        <span class="cov8" title="1">if repo == nil </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("cannot find a repository match for %s", p.event.URL)
                p.eventEmitter.EmitMessage(nil, zap.WarnLevel, "RepositoryNamespaceMatch", msg)
                return nil, nil
        }</span>

        <span class="cov8" title="1">secretNS := repo.GetNamespace()
        if repo.Spec.GitProvider != nil &amp;&amp; repo.Spec.GitProvider.Secret == nil &amp;&amp; p.globalRepo.Spec.GitProvider != nil &amp;&amp; p.globalRepo.Spec.GitProvider.Secret != nil </span><span class="cov0" title="0">{
                secretNS = p.globalRepo.GetNamespace()
        }</span>
        <span class="cov8" title="1">if p.globalRepo != nil </span><span class="cov0" title="0">{
                repo.Spec.Merge(p.globalRepo.Spec)
        }</span>

        <span class="cov8" title="1">p.logger = p.logger.With("namespace", repo.Namespace)
        p.vcx.SetLogger(p.logger)
        p.eventEmitter.SetLogger(p.logger)
        // If we have a git_provider field in repository spec, then get all the
        // information from there, including the webhook secret.
        // otherwise get the secret from the current ns (i.e: pipelines-as-code/openshift-pipelines.)
        //
        // TODO: there is going to be some improvements later we may want to do if
        // they are use cases for it :
        // allow webhook providers users to have a global webhook secret to be used,
        // so instead of having to specify their in Repo each time, they use a
        // shared one from pac.
        if p.event.InstallationID &gt; 0 </span><span class="cov8" title="1">{
                p.event.Provider.WebhookSecret, _ = GetCurrentNSWebhookSecret(ctx, p.k8int, p.run)
        }</span> else<span class="cov8" title="1"> {
                scm := SecretFromRepository{
                        K8int:       p.k8int,
                        Config:      p.vcx.GetConfig(),
                        Event:       p.event,
                        Repo:        repo,
                        WebhookType: p.pacInfo.WebhookType,
                        Logger:      p.logger,
                        Namespace:   secretNS,
                }
                if err := scm.Get(ctx); err != nil </span><span class="cov8" title="1">{
                        return repo, fmt.Errorf("cannot get secret from repository: %w", err)
                }</span>
        }

        // validate payload  for webhook secret
        // we don't need to validate it in incoming since we already do this
        <span class="cov8" title="1">if p.event.EventType != "incoming" </span><span class="cov8" title="1">{
                if err := p.vcx.Validate(ctx, p.run, p.event); err != nil </span><span class="cov8" title="1">{
                        // check that webhook secret has no /n or space into it
                        if strings.ContainsAny(p.event.Provider.WebhookSecret, "\n ") </span><span class="cov8" title="1">{
                                msg := `we have failed to validate the payload with the webhook secret,
it seems that we have detected a \n or a space at the end of your webhook secret, 
is that what you want? make sure you use -n when generating the secret, eg: echo -n secret|base64`
                                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositorySecretValidation", msg)
                        }</span>
                        <span class="cov8" title="1">return repo, fmt.Errorf("could not validate payload, check your webhook secret?: %w", err)</span>
                }
        }

        // Set the client, we should error out if there is a problem with
        // token or secret or we won't be able to do much.
        <span class="cov8" title="1">err = p.vcx.SetClient(ctx, p.run, p.event, repo, p.eventEmitter)
        if err != nil </span><span class="cov0" title="0">{
                return repo, err
        }</span>

        <span class="cov8" title="1">if p.event.InstallationID &gt; 0 </span><span class="cov8" title="1">{
                token, err := github.ScopeTokenToListOfRepos(ctx, p.vcx, p.pacInfo, repo, p.run, p.event, p.eventEmitter, p.logger)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // If Global and Repo level configurations are not provided then lets not override the provider token.
                <span class="cov8" title="1">if token != "" </span><span class="cov0" title="0">{
                        p.event.Provider.Token = token
                }</span>
        }

        // Get the SHA commit info, we want to get the URL and commit title
        <span class="cov8" title="1">err = p.vcx.GetCommitInfo(ctx, p.event)
        if err != nil </span><span class="cov8" title="1">{
                return repo, fmt.Errorf("could not find commit info: %w", err)
        }</span>

        // Verify whether the sender of the GitOps command (e.g., /test) has the appropriate permissions to
        // trigger CI on the repository, as any user is able to comment on a pushed commit in open-source repositories.
        <span class="cov8" title="1">if p.event.TriggerTarget == triggertype.Push &amp;&amp; opscomments.IsAnyOpsEventType(p.event.EventType) </span><span class="cov8" title="1">{
                status := provider.StatusOpts{
                        Status:       CompletedStatus,
                        Title:        "Permission denied",
                        Conclusion:   failureConclusion,
                        DetailsURL:   p.event.URL,
                        AccessDenied: true,
                }
                if allowed, err := p.checkAccessOrError(ctx, repo, status, "by GitOps comment on push commit"); !allowed </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        // Check if the submitter is allowed to run this.
        // on push we don't need to check the policy since the user has pushed to the repo so it has access to it.
        // on comment we skip it for now, we are going to check later on
        <span class="cov8" title="1">if p.event.TriggerTarget != triggertype.Push &amp;&amp; p.event.EventType != opscomments.NoOpsCommentEventType.String() </span><span class="cov8" title="1">{
                status := provider.StatusOpts{
                        Status:       queuedStatus,
                        Title:        "Pending approval, waiting for an /ok-to-test",
                        Conclusion:   pendingConclusion,
                        DetailsURL:   p.event.URL,
                        AccessDenied: true,
                }
                if allowed, err := p.checkAccessOrError(ctx, repo, status, "via "+p.event.TriggerTarget.String()); !allowed </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return repo, nil</span>
}

// getPipelineRunsFromRepo fetches pipelineruns from git repository and prepare them for creation.
func (p *PacRun) getPipelineRunsFromRepo(ctx context.Context, repo *v1alpha1.Repository) ([]matcher.Match, error) <span class="cov8" title="1">{
        provenance := "source"
        if repo.Spec.Settings != nil &amp;&amp; repo.Spec.Settings.PipelineRunProvenance != "" </span><span class="cov0" title="0">{
                provenance = repo.Spec.Settings.PipelineRunProvenance
        }</span>
        <span class="cov8" title="1">rawTemplates, err := p.vcx.GetTektonDir(ctx, p.event, tektonDir, provenance)
        if err != nil &amp;&amp; p.event.TriggerTarget == triggertype.PullRequest &amp;&amp; strings.Contains(err.Error(), "error unmarshalling yaml file") </span><span class="cov8" title="1">{
                // make the error a bit more friendly for users who don't know what marshalling or intricacies of the yaml parser works
                // format is "error unmarshalling yaml file pr-bad-format.yaml: yaml: line 3: could not find expected ':'"
                // get the filename with a regexp
                reg := regexp.MustCompile(`error unmarshalling yaml file\s([^:]*):\s*(yaml:\s*)?(.*)`)
                matches := reg.FindStringSubmatch(err.Error())
                if len(matches) == 4 </span><span class="cov8" title="1">{
                        p.reportValidationErrors(ctx, repo,
                                []*pacerrors.PacYamlValidations{
                                        {
                                                Name:   matches[1],
                                                Err:    fmt.Errorf("yaml validation error: %s", matches[3]),
                                                Schema: pacerrors.GenericBadYAMLValidation,
                                        },
                                },
                        )
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if rawTemplates == "" &amp;&amp; p.event.EventType == opscomments.OkToTestCommentEventType.String() </span><span class="cov8" title="1">{
                err = p.createNeutralStatus(ctx, ".tekton directory not found", tektonDirMissingError)
                if err != nil </span><span class="cov8" title="1">{
                        p.eventEmitter.EmitMessage(nil, zap.ErrorLevel, "RepositoryCreateStatus", err.Error())
                }</span>
        }

        // This is for push event error logging because we can't create comment for yaml validation errors on push
        <span class="cov8" title="1">if err != nil || rawTemplates == "" </span><span class="cov8" title="1">{
                msg := ""
                reason := "RepositoryPipelineRunNotFound"
                logLevel := zap.InfoLevel
                if err != nil </span><span class="cov8" title="1">{
                        reason = "RepositoryInvalidPipelineRunTemplate"
                        logLevel = zap.ErrorLevel
                        if strings.Contains(err.Error(), "error unmarshalling yaml file") </span><span class="cov0" title="0">{
                                msg = "PipelineRun YAML validation"
                        }</span>
                        <span class="cov8" title="1">msg += fmt.Sprintf(" err: %s", err.Error())</span>
                } else<span class="cov0" title="0"> {
                        msg = fmt.Sprintf("cannot locate templates in %s/ directory for this repository in %s", tektonDir, p.event.HeadBranch)
                }</span>
                <span class="cov8" title="1">p.eventEmitter.EmitMessage(nil, logLevel, reason, msg)
                return nil, nil</span>
        }

        // check for condition if need update the pipelinerun with regexp from the
        // "raw" pipelinerun string
        <span class="cov8" title="1">if msg, needUpdate := p.checkNeedUpdate(rawTemplates); needUpdate </span><span class="cov0" title="0">{
                p.eventEmitter.EmitMessage(repo, zap.InfoLevel, "RepositoryNeedUpdate", msg)
                return nil, fmt.Errorf("%s", msg)
        }</span>

        // This is for bitbucket
        <span class="cov8" title="1">if p.event.CloneURL == "" </span><span class="cov8" title="1">{
                p.event.AccountID = ""
        }</span>

        // NOTE(chmouel): Initially, matching is performed here to accurately
        // expand dynamic matching in events. This expansion is crucial for
        // applying dynamic variables, such as setting the `event_type` to
        // `on-comment` when matching a git provider's issue comment event with a
        // comment in an annotation. Although matching occurs three times within
        // this loop, which might seem inefficient, it's essential to maintain
        // current functionality without introducing potential errors or behavior
        // changes. Refactoring for optimization could lead to significant
        // challenges in tracking down issues. Despite the repetition, the
        // performance impact is minimal, involving only a loop and a few
        // conditions.
        <span class="cov8" title="1">if p.event.TargetTestPipelineRun == "" </span><span class="cov8" title="1">{
                rtypes, err := resolve.ReadTektonTypes(ctx, p.logger, rawTemplates)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Don't fail or do anything if we don't have a match yet, we will do it properly later in this function
                <span class="cov8" title="1">_, _ = matcher.MatchPipelinerunByAnnotation(ctx, p.logger, rtypes.PipelineRuns, p.run, p.event, p.vcx, p.eventEmitter, repo)</span>
        }
        // Replace those {{var}} placeholders user has in her template to the run.Info variable
        <span class="cov8" title="1">allTemplates := p.makeTemplate(ctx, repo, rawTemplates)

        types, err := resolve.ReadTektonTypes(ctx, p.logger, allTemplates)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(types.ValidationErrors) &gt; 0 &amp;&amp; p.event.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                p.reportValidationErrors(ctx, repo, types.ValidationErrors)
        }</span>
        <span class="cov8" title="1">pipelineRuns := types.PipelineRuns
        if len(pipelineRuns) == 0 </span><span class="cov8" title="1">{
                msg := fmt.Sprintf("cannot locate valid templates in %s/ directory for this repository in %s", tektonDir, p.event.HeadBranch)
                p.eventEmitter.EmitMessage(nil, zap.InfoLevel, "RepositoryCannotLocatePipelineRun", msg)
                return nil, nil
        }</span>
        <span class="cov8" title="1">pipelineRuns, err = resolve.MetadataResolve(pipelineRuns)
        if err != nil &amp;&amp; len(pipelineRuns) == 0 </span><span class="cov0" title="0">{
                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "FailedToResolvePipelineRunMetadata", err.Error())
                return nil, err
        }</span>

        // Match the PipelineRun with annotation
        <span class="cov8" title="1">var matchedPRs []matcher.Match
        if p.event.TargetTestPipelineRun == "" </span><span class="cov8" title="1">{
                if matchedPRs, err = matcher.MatchPipelinerunByAnnotation(ctx, p.logger, pipelineRuns, p.run, p.event, p.vcx, p.eventEmitter, repo); err != nil </span><span class="cov8" title="1">{
                        // Don't fail when you don't have a match between pipeline and annotations
                        p.eventEmitter.EmitMessage(nil, zap.WarnLevel, "RepositoryNoMatch", err.Error())
                        // In a scenario where an external user submits a pull request and the repository owner uses the
                        // GitOps command `/ok-to-test` to trigger CI, but no matching pull request is found,
                        // a neutral check-run will be created on the pull request to indicate that no PipelineRun was triggered
                        if p.event.EventType == opscomments.OkToTestCommentEventType.String() &amp;&amp; len(matchedPRs) == 0 </span><span class="cov8" title="1">{
                                text := fmt.Sprintf("No matching PipelineRun found for the '%s' event in .tekton/ directory. Please ensure that PipelineRun is configured for '%s' event.", p.event.TriggerTarget.String(), p.event.TriggerTarget.String())
                                err = p.createNeutralStatus(ctx, "No PipelineRun matched", text)
                                if err != nil </span><span class="cov8" title="1">{
                                        p.eventEmitter.EmitMessage(nil, zap.WarnLevel, "RepositoryCreateStatus", err.Error())
                                }</span>
                                <span class="cov8" title="1">p.eventEmitter.EmitMessage(nil, zap.InfoLevel, "RepositoryNoMatch", text)</span>
                        }
                        <span class="cov8" title="1">return nil, nil</span>
                }
        }

        // if the event is a comment event, but we don't have any match from the keys.OnComment then do the ACL checks again
        // we skipped previously so we can get the match from the event to the pipelineruns
        <span class="cov8" title="1">if p.event.EventType == opscomments.NoOpsCommentEventType.String() || p.event.EventType == opscomments.OnCommentEventType.String() </span><span class="cov0" title="0">{
                status := provider.StatusOpts{
                        Status:       queuedStatus,
                        Title:        "Pending approval, waiting for an /ok-to-test",
                        Conclusion:   pendingConclusion,
                        DetailsURL:   p.event.URL,
                        AccessDenied: true,
                }
                if allowed, err := p.checkAccessOrError(ctx, repo, status, "by GitOps comment on push commit"); !allowed </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // if event type is incoming then filter out the pipelineruns related to incoming event
        <span class="cov8" title="1">pipelineRuns = matcher.MatchRunningPipelineRunForIncomingWebhook(p.event.EventType, p.event.TargetPipelineRun, pipelineRuns)
        if pipelineRuns == nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("cannot find pipelinerun %s for matching an incoming event in this repository", p.event.TargetPipelineRun)
                p.eventEmitter.EmitMessage(repo, zap.InfoLevel, "RepositoryCannotLocatePipelineRunForIncomingEvent", msg)
                return nil, nil
        }</span>

        // if /test command is used then filter out the pipelinerun
        <span class="cov8" title="1">if p.event.TargetTestPipelineRun != "" </span><span class="cov8" title="1">{
                targetPR := filterRunningPipelineRunOnTargetTest(p.event.TargetTestPipelineRun, pipelineRuns)
                if targetPR == nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("cannot find the targeted pipelinerun %s in this repository", p.event.TargetTestPipelineRun)
                        p.eventEmitter.EmitMessage(repo, zap.InfoLevel, "RepositoryCannotLocatePipelineRun", msg)
                        return nil, nil
                }</span>
                <span class="cov8" title="1">pipelineRuns = []*tektonv1.PipelineRun{targetPR}</span>
        }

        // finally resolve with fetching the remote tasks (if enabled)
        <span class="cov8" title="1">if p.pacInfo.RemoteTasks </span><span class="cov8" title="1">{
                // only resolve on the matched pipelineruns if we don't do explicit /test of unmatched pipelineruns
                if p.event.TargetTestPipelineRun == "" </span><span class="cov8" title="1">{
                        types.PipelineRuns = nil
                        for _, match := range matchedPRs </span><span class="cov8" title="1">{
                                for pr := range pipelineRuns </span><span class="cov8" title="1">{
                                        if match.PipelineRun.GetName() == "" &amp;&amp; match.PipelineRun.GetGenerateName() == pipelineRuns[pr].GenerateName ||
                                                match.PipelineRun.GetName() != "" &amp;&amp; match.PipelineRun.GetName() == pipelineRuns[pr].Name </span><span class="cov8" title="1">{
                                                types.PipelineRuns = append(types.PipelineRuns, pipelineRuns[pr])
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">pipelineRuns, err = resolve.Resolve(ctx, p.run, p.logger, p.vcx, types, p.event, &amp;resolve.Opts{
                        GenerateName: true,
                        RemoteTasks:  true,
                })
                if err != nil </span><span class="cov8" title="1">{
                        p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryFailedToMatch", fmt.Sprintf("failed to match pipelineRuns: %s", err.Error()))
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">err = p.changePipelineRun(ctx, repo, pipelineRuns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // if we are doing explicit /test command then we only want to run the one that has matched the /test
        <span class="cov8" title="1">if p.event.TargetTestPipelineRun != "" </span><span class="cov8" title="1">{
                p.eventEmitter.EmitMessage(repo, zap.InfoLevel, "RepositoryMatchedPipelineRun", fmt.Sprintf("explicit testing via /test of PipelineRun %s", p.event.TargetTestPipelineRun))
                selectedPr := filterRunningPipelineRunOnTargetTest(p.event.TargetTestPipelineRun, pipelineRuns)
                return []matcher.Match{{
                        PipelineRun: selectedPr,
                        Repo:        repo,
                }}, nil
        }</span>

        <span class="cov8" title="1">matchedPRs, err = matcher.MatchPipelinerunByAnnotation(ctx, p.logger, pipelineRuns, p.run, p.event, p.vcx, p.eventEmitter, repo)
        if err != nil </span><span class="cov0" title="0">{
                // Don't fail when you don't have a match between pipeline and annotations
                p.eventEmitter.EmitMessage(nil, zap.WarnLevel, "RepositoryNoMatch", err.Error())
                return nil, nil
        }</span>

        <span class="cov8" title="1">return matchedPRs, nil</span>
}

func filterRunningPipelineRunOnTargetTest(testPipeline string, prs []*tektonv1.PipelineRun) *tektonv1.PipelineRun <span class="cov8" title="1">{
        for _, pr := range prs </span><span class="cov8" title="1">{
                if prName, ok := pr.GetAnnotations()[apipac.OriginalPRName]; ok </span><span class="cov8" title="1">{
                        if prName == testPipeline </span><span class="cov8" title="1">{
                                return pr
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// changePipelineRun go over each pipelineruns and modify things into it.
//
// - the secret template variable with a random one as generated from GetBasicAuthSecretName
// - the template variable with the one from the event (this includes the remote pipeline that has template variables).
func (p *PacRun) changePipelineRun(ctx context.Context, repo *v1alpha1.Repository, prs []*tektonv1.PipelineRun) error <span class="cov8" title="1">{
        for k, pr := range prs </span><span class="cov8" title="1">{
                b, err := json.Marshal(pr)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">name := secrets.GenerateBasicAuthSecretName()
                processed := templates.ReplacePlaceHoldersVariables(string(b), map[string]string{
                        "git_auth_secret": name,
                }, nil, nil, map[string]any{})
                processed = p.makeTemplate(ctx, repo, processed)

                var np *tektonv1.PipelineRun
                err = json.Unmarshal([]byte(processed), &amp;np)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // don't crash when we don't have any annotations
                <span class="cov8" title="1">if np.Annotations == nil </span><span class="cov8" title="1">{
                        np.Annotations = map[string]string{}
                }</span>
                <span class="cov8" title="1">np.Annotations[apipac.GitAuthSecret] = name

                prs[k] = np</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// checkNeedUpdate checks if the template needs an update form the user, try to
// match some patterns for some issues in a template to let the user know they need to
// update.
//
// We otherwise fail with a descriptive error message to the user (check run
// interface on as comment for other providers) on how to update.
//
// Checks are deprecated/removed to n+2 release of OSP.
func (p *PacRun) checkNeedUpdate(_ string) (string, bool) <span class="cov8" title="1">{
        return "", false
}</span>

func (p *PacRun) createNeutralStatus(ctx context.Context, title, text string) error <span class="cov8" title="1">{
        status := provider.StatusOpts{
                Status:     CompletedStatus,
                Title:      title,
                Text:       text,
                Conclusion: neutralConclusion,
                DetailsURL: p.event.URL,
        }
        if err := p.vcx.CreateStatus(ctx, p.event, status); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to run create status, user is not allowed to run the CI:: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package pipelineascode

import (
        "context"
        "fmt"
        "sync"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/action"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/customparams"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/matcher"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        tektonDir         = ".tekton"
        CompletedStatus   = "completed"
        inProgressStatus  = "in_progress"
        queuedStatus      = "queued"
        failureConclusion = "failure"
        pendingConclusion = "pending"
        neutralConclusion = "neutral"
)

type PacRun struct {
        event        *info.Event
        vcx          provider.Interface
        run          *params.Run
        k8int        kubeinteraction.Interface
        logger       *zap.SugaredLogger
        eventEmitter *events.EventEmitter
        manager      *ConcurrencyManager
        pacInfo      *info.PacOpts
        globalRepo   *v1alpha1.Repository
}

func NewPacs(event *info.Event, vcx provider.Interface, run *params.Run, pacInfo *info.PacOpts, k8int kubeinteraction.Interface, logger *zap.SugaredLogger, globalRepo *v1alpha1.Repository) PacRun <span class="cov8" title="1">{
        return PacRun{
                event: event, run: run, vcx: vcx, k8int: k8int, pacInfo: pacInfo, logger: logger, globalRepo: globalRepo,
                eventEmitter: events.NewEventEmitter(run.Clients.Kube, logger),
                manager:      NewConcurrencyManager(),
        }
}</span>

func (p *PacRun) Run(ctx context.Context) error <span class="cov8" title="1">{
        // For PullRequestClosed events, skip matching logic and go straight to cancellation
        if p.event.TriggerTarget == triggertype.PullRequestClosed </span><span class="cov0" title="0">{
                repo, err := p.verifyRepoAndUser(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if repo != nil </span><span class="cov0" title="0">{
                        if err := p.cancelAllInProgressBelongingToClosedPullRequest(ctx, repo); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error cancelling in progress pipelineRuns belonging to pull request %d: %w", p.event.PullRequestNumber, err)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">matchedPRs, repo, err := p.matchRepoPR(ctx)
        if err != nil </span><span class="cov8" title="1">{
                createStatusErr := p.vcx.CreateStatus(ctx, p.event, provider.StatusOpts{
                        Status:     CompletedStatus,
                        Conclusion: failureConclusion,
                        Text:       fmt.Sprintf("There was an issue validating the commit: %q", err),
                        DetailsURL: p.run.Clients.ConsoleUI().URL(),
                })
                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryCreateStatus", fmt.Sprintf("an error occurred: %s", err))
                if createStatusErr != nil </span><span class="cov0" title="0">{
                        p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryCreateStatus", fmt.Sprintf("cannot create status: %s: %s", err, createStatusErr))
                }</span>
        }
        <span class="cov8" title="1">if len(matchedPRs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if repo.Spec.ConcurrencyLimit != nil &amp;&amp; *repo.Spec.ConcurrencyLimit != 0 </span><span class="cov8" title="1">{
                p.manager.Enable()
        }</span>

        // set params for the console driver, only used for the custom console ones
        <span class="cov8" title="1">cp := customparams.NewCustomParams(p.event, repo, p.run, p.k8int, p.eventEmitter, p.vcx)
        maptemplate, _, err := cp.GetParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "ParamsError",
                        fmt.Sprintf("error processing repository CR custom params: %s", err.Error()))
        }</span>
        <span class="cov8" title="1">p.run.Clients.ConsoleUI().SetParams(maptemplate)

        var wg sync.WaitGroup
        for i, match := range matchedPRs </span><span class="cov8" title="1">{
                if match.Repo == nil </span><span class="cov8" title="1">{
                        match.Repo = repo
                }</span>

                // After matchRepo func fetched repo from k8s api repo is updated and
                // need to merge global repo again
                <span class="cov8" title="1">if p.globalRepo != nil </span><span class="cov0" title="0">{
                        match.Repo.Spec.Merge(p.globalRepo.Spec)
                }</span>

                <span class="cov8" title="1">wg.Add(1)

                go func(match matcher.Match, i int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        pr, err := p.startPR(ctx, match)
                        if err != nil </span><span class="cov8" title="1">{
                                errMsg := fmt.Sprintf("There was an error starting the PipelineRun %s, %s", match.PipelineRun.GetGenerateName(), err.Error())
                                errMsgM := fmt.Sprintf("There was an error creating the PipelineRun: &lt;b&gt;%s&lt;/b&gt;\n\n%s", match.PipelineRun.GetGenerateName(), err.Error())
                                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryPipelineRun", errMsg)
                                createStatusErr := p.vcx.CreateStatus(ctx, p.event, provider.StatusOpts{
                                        Status:                   CompletedStatus,
                                        Conclusion:               failureConclusion,
                                        Text:                     errMsgM,
                                        DetailsURL:               p.run.Clients.ConsoleUI().URL(),
                                        InstanceCountForCheckRun: i,
                                })
                                if createStatusErr != nil </span><span class="cov0" title="0">{
                                        p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryCreateStatus", fmt.Sprintf("Cannot create status: %s: %s", err, createStatusErr))
                                }</span>
                        }
                        <span class="cov8" title="1">p.manager.AddPipelineRun(pr)
                        if err := p.cancelInProgressMatchingPipelineRun(ctx, pr, repo); err != nil </span><span class="cov0" title="0">{
                                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryPipelineRun", fmt.Sprintf("error cancelling in progress pipelineRuns: %s", err))
                        }</span>
                }(match, i)
        }
        <span class="cov8" title="1">wg.Wait()

        order, prs := p.manager.GetExecutionOrder()
        if order != "" </span><span class="cov0" title="0">{
                for _, pr := range prs </span><span class="cov0" title="0">{
                        wg.Add(1)

                        go func(order string, pr tektonv1.PipelineRun) </span><span class="cov0" title="0">{
                                defer wg.Done()
                                if _, err := action.PatchPipelineRun(ctx, p.logger, "execution order", p.run.Clients.Tekton, &amp;pr, getExecutionOrderPatch(order)); err != nil </span><span class="cov0" title="0">{
                                        errMsg := fmt.Sprintf("Failed to patch pipelineruns %s execution order: %s", pr.GetGenerateName(), err.Error())
                                        p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryPipelineRun", errMsg)
                                        return
                                }</span>
                        }(order, *pr)
                }
        }
        <span class="cov8" title="1">wg.Wait()
        return nil</span>
}

func (p *PacRun) startPR(ctx context.Context, match matcher.Match) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        var gitAuthSecretName string

        // Automatically create a secret with the token to be reused by git-clone task
        if p.pacInfo.SecretAutoCreation </span><span class="cov8" title="1">{
                if annotation, ok := match.PipelineRun.GetAnnotations()[keys.GitAuthSecret]; ok </span><span class="cov8" title="1">{
                        gitAuthSecretName = annotation
                }</span> else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("cannot get annotation %s as set on PR", keys.GitAuthSecret)
                }</span>

                <span class="cov8" title="1">authSecret, err := secrets.MakeBasicAuthSecret(p.event, gitAuthSecretName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("making basic auth secret: %s has failed: %w ", gitAuthSecretName, err)
                }</span>

                <span class="cov8" title="1">if err = p.k8int.CreateSecret(ctx, match.Repo.GetNamespace(), authSecret); err != nil </span><span class="cov8" title="1">{
                        // NOTE: Handle AlreadyExists errors due to etcd/API server timing issues.
                        // Investigation found: slow etcd response causes API server retry, resulting in
                        // duplicate secret creation attempts for the same PR. This is a workaround, not
                        // designed behavior - reuse existing secret to prevent PipelineRun failure.
                        if errors.IsAlreadyExists(err) </span><span class="cov8" title="1">{
                                msg := fmt.Sprintf("Secret %s already exists in namespace %s, reusing existing secret",
                                        authSecret.GetName(), match.Repo.GetNamespace())
                                p.eventEmitter.EmitMessage(match.Repo, zap.WarnLevel, "RepositorySecretReused", msg)
                        }</span> else<span class="cov8" title="1"> {
                                return nil, fmt.Errorf("creating basic auth secret: %s has failed: %w ", authSecret.GetName(), err)
                        }</span>
                }
        }

        // Add labels and annotations to pipelinerun
        <span class="cov8" title="1">err := kubeinteraction.AddLabelsAndAnnotations(p.event, match.PipelineRun, match.Repo, p.vcx.GetConfig(), p.run)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.Errorf("Error adding labels/annotations to PipelineRun '%s' in namespace '%s': %v", match.PipelineRun.GetName(), match.Repo.GetNamespace(), err)
        }</span>

        // if concurrency is defined then start the pipelineRun in pending state
        <span class="cov8" title="1">if match.Repo.Spec.ConcurrencyLimit != nil &amp;&amp; *match.Repo.Spec.ConcurrencyLimit != 0 </span><span class="cov8" title="1">{
                // pending status
                match.PipelineRun.Spec.Status = tektonv1.PipelineRunSpecStatusPending
        }</span>

        // Create the actual pipelineRun
        <span class="cov8" title="1">pr, err := p.run.Clients.Tekton.TektonV1().PipelineRuns(match.Repo.GetNamespace()).Create(ctx,
                match.PipelineRun, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                // cleanup the gitauth secret because ownerRef isn't set when the pipelineRun creation failed
                if p.pacInfo.SecretAutoCreation </span><span class="cov0" title="0">{
                        if errDelSec := p.k8int.DeleteSecret(ctx, p.logger, match.Repo.GetNamespace(), gitAuthSecretName); errDelSec != nil </span><span class="cov0" title="0">{
                                // don't overshadow the pipelineRun creation error, just log
                                p.logger.Errorf("removing auto created secret: %s in namespace %s has failed: %w ", gitAuthSecretName, match.Repo.GetNamespace(), errDelSec)
                        }</span>
                }
                // we need to make difference between markdown error and normal error that goes to namespace/controller stream
                <span class="cov0" title="0">return nil, fmt.Errorf("creating pipelinerun %s in namespace %s has failed.\n\nTekton Controller has reported this error: ```%w``` ", match.PipelineRun.GetGenerateName(),
                        match.Repo.GetNamespace(), err)</span>
        }

        // update ownerRef of secret with pipelineRun, so that it gets cleanedUp with pipelineRun
        <span class="cov8" title="1">if p.pacInfo.SecretAutoCreation </span><span class="cov8" title="1">{
                err := p.k8int.UpdateSecretWithOwnerRef(ctx, p.logger, pr.Namespace, gitAuthSecretName, pr)
                if err != nil </span><span class="cov0" title="0">{
                        // we still return the created PR with error, and allow caller to decide what to do with the PR, and avoid
                        // unneeded SIGSEGV's
                        return pr, fmt.Errorf("cannot update pipelinerun %s with ownerRef: %w", pr.GetGenerateName(), err)
                }</span>
        }

        // Create status with the log url
        <span class="cov8" title="1">p.logger.Infof("PipelineRun %s has been created in namespace %s with status %s for SHA: %s Target Branch: %s",
                pr.GetName(), match.Repo.GetNamespace(), pr.Spec.Status, p.event.SHA, p.event.BaseBranch)

        consoleURL := p.run.Clients.ConsoleUI().DetailURL(pr)
        mt := formatting.MessageTemplate{
                PipelineRunName: pr.GetName(),
                Namespace:       match.Repo.GetNamespace(),
                ConsoleName:     p.run.Clients.ConsoleUI().GetName(),
                ConsoleURL:      consoleURL,
                TknBinary:       settings.TknBinaryName,
                TknBinaryURL:    settings.TknBinaryURL,
        }

        msg, err := mt.MakeTemplate(p.vcx.GetTemplate(provider.StartingPipelineType))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create message template: %w", err)
        }</span>
        <span class="cov8" title="1">status := provider.StatusOpts{
                Status:                  inProgressStatus,
                Conclusion:              pendingConclusion,
                Text:                    msg,
                DetailsURL:              consoleURL,
                PipelineRunName:         pr.GetName(),
                PipelineRun:             pr,
                OriginalPipelineRunName: pr.GetAnnotations()[keys.OriginalPRName],
        }

        // Patch the pipelineRun with the appropriate annotations and labels.
        // Set the state so the watcher will continue with reconciling the pipelineRun
        // The watcher reconciles only pipelineRuns that has the state annotation.
        patchAnnotations := map[string]string{}
        patchLabels := map[string]string{}
        whatPatching := ""
        // if pipelineRun is in pending state then report status as queued
        // The pipelineRun can be pending because of PAC's concurrency limit or because of an external mutatingwebhook
        if pr.Spec.Status == tektonv1.PipelineRunSpecStatusPending </span><span class="cov8" title="1">{
                status.Status = queuedStatus
                if status.Text, err = mt.MakeTemplate(p.vcx.GetTemplate(provider.QueueingPipelineType)); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot create message template: %w", err)
                }</span>
                <span class="cov8" title="1">whatPatching = "annotations.state and labels.state"
                patchAnnotations[keys.State] = kubeinteraction.StateQueued
                patchLabels[keys.State] = kubeinteraction.StateQueued</span>
        } else<span class="cov8" title="1"> {
                // Mark that the start will be reported to the Git provider
                patchAnnotations[keys.SCMReportingPLRStarted] = "true"
                patchAnnotations[keys.State] = kubeinteraction.StateStarted
                patchLabels[keys.State] = kubeinteraction.StateStarted
                whatPatching = fmt.Sprintf(
                        "annotation.%s and annotations.state and labels.state",
                        keys.SCMReportingPLRStarted,
                )
        }</span>

        <span class="cov8" title="1">if err := p.vcx.CreateStatus(ctx, p.event, status); err != nil </span><span class="cov0" title="0">{
                // we still return the created PR with error, and allow caller to decide what to do with the PR, and avoid
                // unneeded SIGSEGV's
                return pr, fmt.Errorf("cannot use the API on the provider platform to create a in_progress status: %w", err)
        }</span>

        // Patch pipelineRun with logURL annotation, skips for GitHub App as we patch logURL while patching CheckrunID
        <span class="cov8" title="1">if _, ok := pr.Annotations[keys.InstallationID]; !ok </span><span class="cov0" title="0">{
                patchAnnotations[keys.LogURL] = p.run.Clients.ConsoleUI().DetailURL(pr)
                whatPatching = "annotations.logURL, " + whatPatching
        }</span>

        <span class="cov8" title="1">if len(patchAnnotations) &gt; 0 || len(patchLabels) &gt; 0 </span><span class="cov8" title="1">{
                pr, err = action.PatchPipelineRun(ctx, p.logger, whatPatching, p.run.Clients.Tekton, pr, getMergePatch(patchAnnotations, patchLabels))
                if err != nil </span><span class="cov0" title="0">{
                        // we still return the created PR with error, and allow caller to decide what to do with the PR, and avoid
                        // unneeded SIGSEGV's
                        return pr, fmt.Errorf("cannot patch pipelinerun %s: %w", pr.GetGenerateName(), err)
                }</span>
                <span class="cov8" title="1">currentReason := ""
                if len(pr.Status.GetConditions()) &gt; 0 </span><span class="cov0" title="0">{
                        currentReason = pr.Status.GetConditions()[0].GetReason()
                }</span>

                <span class="cov8" title="1">p.logger.Infof("PipelineRun %s/%s patched successfully - Spec.Status: %s, State annotation: '%s', SCMReportingPLRStarted annotation: '%s', Status reason: '%s', Git provider status: '%s', Patched: %s",
                        pr.GetNamespace(),
                        pr.GetName(),
                        pr.Spec.Status,
                        pr.GetAnnotations()[keys.State],
                        pr.GetAnnotations()[keys.SCMReportingPLRStarted],
                        currentReason,
                        status.Status,
                        whatPatching)</span>
        }

        <span class="cov8" title="1">return pr, nil</span>
}

func getMergePatch(annotations, labels map[string]string) map[string]any <span class="cov8" title="1">{
        return map[string]any{
                "metadata": map[string]any{
                        "annotations": annotations,
                        "labels":      labels,
                },
        }
}</span>

func getExecutionOrderPatch(order string) map[string]any <span class="cov8" title="1">{
        return map[string]any{
                "metadata": map[string]any{
                        "annotations": map[string]string{
                                keys.ExecutionOrder: order,
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package pipelineascode

import (
        "context"
        "fmt"
        "strings"

        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        ktypes "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/types"
        "go.uber.org/zap"
)

const (
        DefaultGitProviderSecretKey                  = "provider.token"
        DefaultGitProviderWebhookSecretKey           = "webhook.secret"
        defaultPipelinesAscodeSecretWebhookSecretKey = "webhook.secret"
)

type SecretFromRepository struct {
        K8int       kubeinteraction.Interface
        Config      *info.ProviderConfig
        Event       *info.Event
        Repo        *apipac.Repository
        WebhookType string
        Namespace   string
        Logger      *zap.SugaredLogger
}

// Get grab the secret from the repository CRD.
func (s *SecretFromRepository) Get(ctx context.Context) error <span class="cov8" title="1">{
        var err error
        if s.Repo.Spec.GitProvider == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to find git_provider details in repository spec: %v/%v", s.Repo.Namespace, s.Repo.Name)
        }</span>
        <span class="cov8" title="1">if s.Repo.Spec.GitProvider.URL == "" </span><span class="cov8" title="1">{
                s.Repo.Spec.GitProvider.URL = s.Config.APIURL
        }</span> else<span class="cov8" title="1"> {
                s.Event.Provider.URL = s.Repo.Spec.GitProvider.URL
        }</span>

        <span class="cov8" title="1">if s.Repo.Spec.GitProvider.Secret == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find secret in git_provider section in repository spec: %v/%v", s.Repo.Namespace, s.Repo.Name)
        }</span>
        <span class="cov8" title="1">gitProviderSecretKey := s.Repo.Spec.GitProvider.Secret.Key
        if gitProviderSecretKey == "" </span><span class="cov8" title="1">{
                gitProviderSecretKey = DefaultGitProviderSecretKey
        }</span>

        <span class="cov8" title="1">if s.Event.Provider.Token, err = s.K8int.GetSecret(ctx, ktypes.GetSecretOpt{
                Namespace: s.Namespace,
                Name:      s.Repo.Spec.GitProvider.Secret.Name,
                Key:       gitProviderSecretKey,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // if we don't have a provider token in repo crd we won't be able to do much with it
        // let it go and it will fail later on when doing SetClients or success if it was done from a github app
        <span class="cov8" title="1">if s.Event.Provider.Token == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">s.Event.Provider.User = s.Repo.Spec.GitProvider.User

        if s.Repo.Spec.GitProvider.WebhookSecret == nil </span><span class="cov0" title="0">{
                // repo.Spec.GitProvider.url/token without a webhook secret is probably going to be bitbucket cloud which
                // doesn't have webhook support 
                return nil
        }</span>

        <span class="cov8" title="1">gitProviderWebhookSecretKey := s.Repo.Spec.GitProvider.WebhookSecret.Key
        if gitProviderWebhookSecretKey == "" </span><span class="cov8" title="1">{
                gitProviderWebhookSecretKey = DefaultGitProviderWebhookSecretKey
        }</span>
        <span class="cov8" title="1">logmsg := fmt.Sprintf("Using git provider %s: apiurl=%s user=%s token-secret=%s token-key=%s",
                s.WebhookType,
                s.Repo.Spec.GitProvider.URL,
                s.Repo.Spec.GitProvider.User,
                s.Repo.Spec.GitProvider.Secret.Name,
                gitProviderSecretKey)
        if s.Event.Provider.WebhookSecret, err = s.K8int.GetSecret(ctx, ktypes.GetSecretOpt{
                Namespace: s.Namespace,
                Name:      s.Repo.Spec.GitProvider.WebhookSecret.Name,
                Key:       gitProviderWebhookSecretKey,
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if s.Event.Provider.WebhookSecret != "" </span><span class="cov8" title="1">{
                s.Event.Provider.WebhookSecretFromRepo = true
                logmsg += fmt.Sprintf(" webhook-secret=%s webhook-key=%s",
                        s.Repo.Spec.GitProvider.WebhookSecret.Name,
                        gitProviderWebhookSecretKey)
        }</span> else<span class="cov0" title="0"> {
                logmsg += " webhook-secret=NOTFOUND"
        }</span>
        <span class="cov8" title="1">s.Logger.Infof(logmsg)
        return nil</span>
}

// GetCurrentNSWebhookSecret get secret from namespace as stored on context.
func GetCurrentNSWebhookSecret(ctx context.Context, k8int kubeinteraction.Interface, run *params.Run) (string, error) <span class="cov8" title="1">{
        ns := info.GetNS(ctx)
        s, err := k8int.GetSecret(ctx, ktypes.GetSecretOpt{
                Namespace: ns,
                Name:      run.Info.Controller.Secret,
                Key:       defaultPipelinesAscodeSecretWebhookSecretKey,
        })
        // a lot of people have problem with this secret, when encoding it to base64 which add a \n when we do :
        // echo secret|base64 -w0
        // so cleanup, if someone wants to have a \n or a space in the secret, well then they can't :p
        return strings.TrimSpace(s), err
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package pipelineascode

import (
        "context"
        "fmt"
        "net/http"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/customparams"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/templates"
        "go.uber.org/zap"
)

// makeTemplate will process all templates replacing the value from the event and from the
// params as set on Repo CR.
func (p *PacRun) makeTemplate(ctx context.Context, repo *v1alpha1.Repository, template string) string <span class="cov8" title="1">{
        cp := customparams.NewCustomParams(p.event, repo, p.run, p.k8int, p.eventEmitter, p.vcx)
        maptemplate, changedFiles, err := cp.GetParams(ctx)
        if err != nil </span><span class="cov8" title="1">{
                p.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "ParamsError",
                        fmt.Sprintf("error processing repository CR custom params: %s", err.Error()))
        }</span>

        // convert pull request number to string
        <span class="cov8" title="1">if p.event.PullRequestNumber != 0 </span><span class="cov8" title="1">{
                maptemplate["pull_request_number"] = fmt.Sprintf("%d", p.event.PullRequestNumber)
        }</span>

        // replace placeholders variable as well as evaluate cel expressions
        <span class="cov8" title="1">headers := http.Header{}
        if p.event.Request != nil &amp;&amp; p.event.Request.Header != nil </span><span class="cov8" title="1">{
                headers = p.event.Request.Header
        }</span>

        <span class="cov8" title="1">return templates.ReplacePlaceHoldersVariables(template, maptemplate, p.event.Event, headers, changedFiles)</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package policy

import (
        "context"
        "fmt"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "go.uber.org/zap"
)

type Result int

const (
        ResultNotSet     Result = 0
        ResultAllowed    Result = 1
        ResultDisallowed Result = 2
)

type Policy struct {
        Repository   *v1alpha1.Repository
        Event        *info.Event
        VCX          provider.Interface
        Logger       *zap.SugaredLogger
        EventEmitter *events.EventEmitter
}

// checkAllowed checks if the policy is set and allows the event to be processed.
func (p *Policy) checkAllowed(ctx context.Context, tType triggertype.Trigger) (Result, string) <span class="cov8" title="1">{
        if p.Repository == nil </span><span class="cov8" title="1">{
                return ResultNotSet, ""
        }</span>
        <span class="cov8" title="1">settings := p.Repository.Spec.Settings
        if settings == nil || settings.Policy == nil </span><span class="cov0" title="0">{
                return ResultNotSet, ""
        }</span>

        <span class="cov8" title="1">var sType []string
        switch tType </span>{
        // NOTE: This make /retest /ok-to-test /test bound to the same policy, which is fine from a security standpoint but maybe we want to refine this in the future.
        case triggertype.OkToTest, triggertype.Retest:<span class="cov8" title="1">
                sType = settings.Policy.OkToTest</span>
        // apply the same policy for PullRequest and comment
        // we don't support comments on PRs yet but if we do on the future we will need our own policy
        case triggertype.PullRequest, triggertype.Comment, triggertype.PullRequestLabeled, triggertype.PullRequestClosed:<span class="cov8" title="1">
                sType = settings.Policy.PullRequest</span>
        // NOTE: not supported yet, will imp if it gets requested and reasonable to implement
        case triggertype.Push, triggertype.Cancel, triggertype.CheckSuiteRerequested, triggertype.CheckRunRerequested, triggertype.Incoming:<span class="cov8" title="1">
                return ResultNotSet, ""</span>
        default:<span class="cov8" title="1">
                return ResultNotSet, ""</span>
        }

        // if policy is set but empty then it mean disallow everything
        <span class="cov8" title="1">if len(sType) == 0 </span><span class="cov0" title="0">{
                return ResultDisallowed, "no policy set"
        }</span>

        // remove empty values from sType
        <span class="cov8" title="1">temp := []string{}
        for _, val := range sType </span><span class="cov8" title="1">{
                if val != "" </span><span class="cov8" title="1">{
                        temp = append(temp, val)
                }</span>
        }
        <span class="cov8" title="1">sType = temp

        // if policy is set but with empty values then bail out.
        if len(sType) == 0 </span><span class="cov8" title="1">{
                return ResultDisallowed, "policy set and empty with no groups"
        }</span>

        <span class="cov8" title="1">allowed, reason := p.VCX.CheckPolicyAllowing(ctx, p.Event, sType)
        if allowed </span><span class="cov8" title="1">{
                return ResultAllowed, ""
        }</span>
        <span class="cov8" title="1">return ResultDisallowed, fmt.Sprintf("policy check: %s, %s", string(tType), reason)</span>
}

func (p *Policy) IsAllowed(ctx context.Context, tType triggertype.Trigger) (Result, string) <span class="cov8" title="1">{
        var reason string
        policyRes, reason := p.checkAllowed(ctx, tType)
        switch policyRes </span>{
        case ResultAllowed:<span class="cov8" title="1">
                reason = fmt.Sprintf("policy check: policy is set for sender %s has been allowed to run CI via policy", p.Event.Sender)
                p.EventEmitter.EmitMessage(p.Repository, zap.InfoLevel, "PolicySetAllowed", reason)
                return ResultAllowed, ""</span>
        case ResultDisallowed:<span class="cov8" title="1">
                allowed, err := p.VCX.IsAllowedOwnersFile(ctx, p.Event)
                if err != nil </span><span class="cov0" title="0">{
                        return ResultDisallowed, err.Error()
                }</span>
                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        reason = fmt.Sprintf("policy check: policy is set, sender %s not in the allowed policy but allowed via OWNERS file", p.Event.Sender)
                        p.EventEmitter.EmitMessage(p.Repository, zap.InfoLevel, "PolicySetAllowed", reason)
                        return ResultAllowed, ""
                }</span>
                <span class="cov8" title="1">if reason == "" </span><span class="cov0" title="0">{
                        reason = fmt.Sprintf("policy check: policy is set but sender %s is not in the allowed groups", p.Event.Sender)
                }</span>
                <span class="cov8" title="1">p.EventEmitter.EmitMessage(p.Repository, zap.InfoLevel, "PolicySetDisallowed", reason)
                return ResultDisallowed, ""</span>
        case ResultNotSet:<span class="cov8" title="1"></span> // this is to make golangci-lint happy
        }
        <span class="cov8" title="1">return ResultNotSet, reason</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package bitbucketcloud

import (
        "context"
        "strconv"
        "strings"

        "github.com/ktrysmt/go-bitbucket"
        "github.com/mitchellh/mapstructure"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/acl"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/types"
)

func (v *Provider) IsAllowed(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        // Check first if the user is in the owner file or part of the workspace
        allowed, err := v.checkMember(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // Check then from comment if there is a approved user that has done a /ok-to-test
        <span class="cov8" title="1">return v.checkOkToTestCommentFromApprovedMember(ctx, event)</span>
}

func (v *Provider) isWorkspaceMember(event *info.Event) (bool, error) <span class="cov8" title="1">{
        members, err := v.Client().Workspaces.Members(event.Organization)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, member := range members.Members </span><span class="cov8" title="1">{
                if member.AccountId == event.AccountID </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// IsAllowedOwnersFile get the owner files (OWNERS, OWNERS_ALIASES) from main branch
// and check if we have explicitly allowed the user in there.
func (v *Provider) IsAllowedOwnersFile(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        ownerContent, err := v.GetFileInsideRepo(ctx, event, "OWNERS", event.DefaultBranch)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "cannot find") </span><span class="cov8" title="1">{
                        // no owner file, skipping
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        // If there is OWNERS file, check for OWNERS_ALIASES
        <span class="cov8" title="1">ownerAliasesContent, err := v.GetFileInsideRepo(ctx, event, "OWNERS_ALIASES", event.DefaultBranch)
        if err != nil </span><span class="cov8" title="1">{
                if !strings.Contains(err.Error(), "cannot find") </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">return acl.UserInOwnerFile(ownerContent, ownerAliasesContent, event.AccountID)</span>
}

func (v *Provider) checkMember(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        // If sender is a member that can write to the workspace then allow it.
        allowed, err := v.isWorkspaceMember(event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span> else<span class="cov8" title="1"> if allowed </span><span class="cov8" title="1">{
                return true, err
        }</span>

        // Check if sender (which in bitbucket-cloud mean the accountID) is inside the Owner file
        // in the 'main' branch Silently ignore error, which should be fine it
        // probably means the OWNERS file is not created. If we had another error
        // (ie: like API) we probably would have hit it already.
        <span class="cov8" title="1">if allowed, _ := v.IsAllowedOwnersFile(ctx, event); allowed </span><span class="cov8" title="1">{
                return true, err
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

func (v *Provider) checkOkToTestCommentFromApprovedMember(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        commentsIntf, err := v.Client().Repositories.PullRequests.GetComments(&amp;bitbucket.PullRequestsOptions{
                Owner:    event.Organization,
                RepoSlug: event.Repository,
                ID:       strconv.Itoa(event.PullRequestNumber),
        })
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">comments := &amp;types.Comments{}
        err = mapstructure.Decode(commentsIntf, comments)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, comment := range comments.Values </span><span class="cov8" title="1">{
                if acl.MatchRegexp(acl.OKToTestCommentRegexp, comment.Content.Raw) </span><span class="cov8" title="1">{
                        commenterEvent := info.NewEvent()
                        commenterEvent.Event = event.Event
                        commenterEvent.Sender = comment.User.Nickname
                        commenterEvent.AccountID = comment.User.AccountID
                        commenterEvent.BaseBranch = event.BaseBranch
                        commenterEvent.HeadBranch = event.HeadBranch
                        commenterEvent.Repository = event.Repository
                        commenterEvent.Organization = event.Organization
                        commenterEvent.DefaultBranch = event.DefaultBranch
                        allowed, err := v.checkMember(ctx, commenterEvent)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package bitbucketcloud

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/ktrysmt/go-bitbucket"
        "github.com/mitchellh/mapstructure"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/types"
        providerMetrics "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/metrics"
        "go.uber.org/zap"
)

var _ provider.Interface = (*Provider)(nil)

type Provider struct {
        bbClient      *bitbucket.Client
        Logger        *zap.SugaredLogger
        run           *params.Run
        pacInfo       *info.PacOpts
        Token, APIURL *string
        Username      *string
        provenance    string
        eventEmitter  *events.EventEmitter
        repo          *v1alpha1.Repository
        triggerEvent  string
}

func (v *Provider) Client() *bitbucket.Client <span class="cov8" title="1">{
        providerMetrics.RecordAPIUsage(
                v.Logger,
                v.GetConfig().Name,
                v.triggerEvent,
                v.repo,
        )
        return v.bbClient
}</span>

func (v *Provider) CreateComment(_ context.Context, _ *info.Event, _, _ string) error <span class="cov0" title="0">{
        return nil
}</span>

// CheckPolicyAllowing TODO: Implement ME.
func (v *Provider) CheckPolicyAllowing(_ context.Context, _ *info.Event, _ []string) (bool, string) <span class="cov0" title="0">{
        return false, ""
}</span>

// GetTaskURI TODO: Implement ME.
func (v *Provider) GetTaskURI(_ context.Context, _ *info.Event, _ string) (bool, string, error) <span class="cov0" title="0">{
        return false, "", nil
}</span>

func (v *Provider) SetPacInfo(pacInfo *info.PacOpts) <span class="cov0" title="0">{
        v.pacInfo = pacInfo
}</span>

const taskStatusTemplate = `{{range $taskrun := .TaskRunList }} | **{{ formatCondition $taskrun.PipelineRunTaskRunStatus.Status.Conditions }}** | {{ $taskrun.ConsoleLogURL }} | *{{ formatDuration $taskrun.PipelineRunTaskRunStatus.Status.StartTime $taskrun.PipelineRunTaskRunStatus.Status.CompletionTime }}* |
{{ end }}`

func (v *Provider) Validate(_ context.Context, _ *params.Run, _ *info.Event) error <span class="cov0" title="0">{
        return nil
}</span>

func (v *Provider) SetLogger(logger *zap.SugaredLogger) <span class="cov0" title="0">{
        v.Logger = logger
}</span>

func (v *Provider) GetConfig() *info.ProviderConfig <span class="cov8" title="1">{
        return &amp;info.ProviderConfig{
                TaskStatusTMPL: taskStatusTemplate,
                APIURL:         bitbucket.DEFAULT_BITBUCKET_API_BASE_URL,
                Name:           "bitbucket-cloud",
        }
}</span>

func (v *Provider) CreateStatus(_ context.Context, event *info.Event, statusopts provider.StatusOpts) error <span class="cov8" title="1">{
        switch statusopts.Conclusion </span>{
        case "skipped":<span class="cov8" title="1">
                statusopts.Conclusion = "STOPPED"
                statusopts.Title = " Skipping this commit"</span>
        case "neutral":<span class="cov8" title="1">
                statusopts.Conclusion = "STOPPED"
                statusopts.Title = " CI has stopped"</span>
        case "failure":<span class="cov8" title="1">
                statusopts.Conclusion = "FAILED"
                statusopts.Title = " Failed"</span>
        case "pending":<span class="cov8" title="1">
                statusopts.Conclusion = "INPROGRESS"
                statusopts.Title = " CI has started"</span>
        case "success":<span class="cov8" title="1">
                statusopts.Conclusion = "SUCCESSFUL"
                statusopts.Title = " Commit has been validated"</span>
        case "completed":<span class="cov8" title="1">
                statusopts.Conclusion = "SUCCESSFUL"
                statusopts.Title = " Completed"</span>
        }
        <span class="cov8" title="1">detailsURL := event.Provider.URL
        if statusopts.DetailsURL != "" </span><span class="cov8" title="1">{
                detailsURL = statusopts.DetailsURL
        }</span>

        <span class="cov8" title="1">cso := &amp;bitbucket.CommitStatusOptions{
                Key:         v.pacInfo.ApplicationName,
                Url:         detailsURL,
                State:       statusopts.Conclusion,
                Description: statusopts.Title,
        }
        cmo := &amp;bitbucket.CommitsOptions{
                Owner:    event.Organization,
                RepoSlug: event.Repository,
                Revision: event.SHA,
        }

        if v.bbClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no token has been set, cannot set status")
        }</span>

        <span class="cov8" title="1">_, err := v.Client().Repositories.Commits.CreateCommitStatus(cmo, cso)
        if err != nil </span><span class="cov0" title="0">{
                // Only emit an event to notify the user that something went wrong with the commit status API,
                // and proceed with creating the comment (if applicable).
                v.eventEmitter.EmitMessage(v.repo, zap.ErrorLevel, "FailedToSetCommitStatus",
                        "cannot set status with the Bitbucket Cloud token because of: "+err.Error())
        }</span>

        <span class="cov8" title="1">eventType := triggertype.IsPullRequestType(event.EventType)
        if statusopts.Conclusion != "STOPPED" &amp;&amp; statusopts.Status == "completed" &amp;&amp;
                statusopts.Text != "" &amp;&amp;
                (eventType == triggertype.PullRequest || event.TriggerTarget == triggertype.PullRequest) </span><span class="cov8" title="1">{
                onPr := ""
                if statusopts.OriginalPipelineRunName != "" </span><span class="cov0" title="0">{
                        onPr = "/" + statusopts.OriginalPipelineRunName
                }</span>
                <span class="cov8" title="1">_, err = v.Client().Repositories.PullRequests.AddComment(
                        &amp;bitbucket.PullRequestCommentOptions{
                                Owner:         event.Organization,
                                RepoSlug:      event.Repository,
                                PullRequestID: strconv.Itoa(event.PullRequestNumber),
                                Content:       fmt.Sprintf("**%s%s** - %s\n\n%s", v.pacInfo.ApplicationName, onPr, statusopts.Title, statusopts.Text),
                        })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (v *Provider) GetTektonDir(_ context.Context, event *info.Event, path, provenance string) (string, error) <span class="cov8" title="1">{
        v.provenance = provenance
        repositoryFiles, err := v.getDir(event, path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return v.concatAllYamlFiles(repositoryFiles, event)</span>
}

func (v *Provider) getDir(event *info.Event, path string) ([]bitbucket.RepositoryFile, error) <span class="cov8" title="1">{
        // default set provenance from the SHA
        revision := event.SHA
        if v.provenance == "default_branch" </span><span class="cov8" title="1">{
                revision = event.DefaultBranch
                v.Logger.Infof("Using PipelineRun definition from default_branch: %s", event.DefaultBranch)
        }</span> else<span class="cov8" title="1"> {
                v.Logger.Infof("Using PipelineRun definition from source %s commit SHA: %s", event.TriggerTarget.String(), event.SHA)
        }</span>
        <span class="cov8" title="1">repoFileOpts := &amp;bitbucket.RepositoryFilesOptions{
                Owner:    event.Organization,
                RepoSlug: event.Repository,
                Ref:      revision,
                Path:     path,
        }

        repositoryFiles, err := v.Client().Repositories.Repository.ListFiles(repoFileOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return repositoryFiles, nil</span>
}

func (v *Provider) GetFileInsideRepo(_ context.Context, event *info.Event, path, _ string) (string, error) <span class="cov8" title="1">{
        revision := event.SHA
        if v.provenance == "default_branch" </span><span class="cov0" title="0">{
                revision = event.DefaultBranch
        }</span>
        <span class="cov8" title="1">return v.getBlob(event, revision, path)</span>
}

func (v *Provider) SetClient(_ context.Context, run *params.Run, event *info.Event, repo *v1alpha1.Repository, eventEmitter *events.EventEmitter) error <span class="cov8" title="1">{
        if event.Provider.Token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no git_provider.secret has been set in the repo crd")
        }</span>
        <span class="cov8" title="1">if event.Provider.User == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no git_provider.user has been in repo crd")
        }</span>
        <span class="cov8" title="1">v.bbClient = bitbucket.NewBasicAuth(event.Provider.User, event.Provider.Token)

        // Added log for security audit purposes to log client access when a token is used
        run.Clients.Log.Infof("bitbucket-cloud: initialized client with provided token for user=%s", event.Provider.User)

        v.Token = &amp;event.Provider.Token
        v.Username = &amp;event.Provider.User
        v.run = run
        v.eventEmitter = eventEmitter
        v.repo = repo
        v.triggerEvent = event.EventType
        return nil</span>
}

func (v *Provider) GetCommitInfo(_ context.Context, event *info.Event) error <span class="cov8" title="1">{
        branchortag := event.SHA
        if branchortag == "" </span><span class="cov8" title="1">{
                branchortag = event.HeadBranch
        }</span>
        <span class="cov8" title="1">response, err := v.Client().Repositories.Commits.GetCommits(&amp;bitbucket.CommitsOptions{
                Owner:       event.Organization,
                RepoSlug:    event.Repository,
                Branchortag: branchortag,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">commitMap, ok := response.(map[string]any)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot convert")
        }</span>
        <span class="cov8" title="1">values, ok := commitMap["values"].([]any)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot convert")
        }</span>
        <span class="cov8" title="1">if len(values) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("we did not get commit information from commit: %s", event.SHA)
        }</span>
        <span class="cov8" title="1">commitinfo := &amp;types.Commit{}
        err = mapstructure.Decode(values[0], commitinfo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Some silliness since we get first the account id and we fill it properly after
        <span class="cov8" title="1">event.SHATitle = commitinfo.Message
        event.SHAURL = commitinfo.Links.HTML.HRef
        event.SHA = commitinfo.Hash

        // now to get the default branch from repository.Get
        repo, err := v.Client().Repositories.Repository.Get(&amp;bitbucket.RepositoryOptions{
                Owner:    event.Organization,
                RepoSlug: event.Repository,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">event.DefaultBranch = repo.Mainbranch.Name
        return nil</span>
}

func (v *Provider) concatAllYamlFiles(objects []bitbucket.RepositoryFile, event *info.Event) (string, error) <span class="cov8" title="1">{
        var allTemplates string

        revision := event.SHA
        if v.provenance == "default_branch" </span><span class="cov8" title="1">{
                revision = event.DefaultBranch
        }</span>
        <span class="cov8" title="1">for _, value := range objects </span><span class="cov8" title="1">{
                if value.Type == "commit_directory" </span><span class="cov8" title="1">{
                        objects, err := v.getDir(event, value.Path)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">subdirdata, err := v.concatAllYamlFiles(objects, event)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if allTemplates != "" &amp;&amp; !strings.HasPrefix(subdirdata, "---") </span><span class="cov8" title="1">{
                                allTemplates += "---"
                        }</span>
                        <span class="cov8" title="1">allTemplates += fmt.Sprintf("\n%s\n", subdirdata)</span>
                } else<span class="cov8" title="1"> if strings.HasSuffix(value.Path, ".yaml") ||
                        strings.HasSuffix(value.Path, ".yml") </span><span class="cov8" title="1">{
                        data, err := v.getBlob(event, revision, value.Path)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if err := provider.ValidateYaml([]byte(data), value.Path); err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>

                        <span class="cov8" title="1">if allTemplates != "" &amp;&amp; !strings.HasPrefix(data, "---") </span><span class="cov8" title="1">{
                                allTemplates += "---"
                        }</span>
                        <span class="cov8" title="1">allTemplates += "\n" + data + "\n"</span>
                }
        }
        <span class="cov8" title="1">return allTemplates, nil</span>
}

func (v *Provider) getBlob(runevent *info.Event, ref, path string) (string, error) <span class="cov8" title="1">{
        blob, err := v.Client().Repositories.Repository.GetFileBlob(&amp;bitbucket.RepositoryBlobOptions{
                Owner:    runevent.Organization,
                RepoSlug: runevent.Repository,
                Ref:      ref,
                Path:     path,
        })
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("cannot find %s on branch %s in repo %s/%s", path, ref, runevent.Organization, runevent.Repository)
        }</span>
        <span class="cov8" title="1">return blob.String(), nil</span>
}

func (v *Provider) GetFiles(_ context.Context, _ *info.Event) (changedfiles.ChangedFiles, error) <span class="cov0" title="0">{
        return changedfiles.ChangedFiles{}, nil
}</span>

func (v *Provider) CreateToken(_ context.Context, _ []string, _ *info.Event) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (v *Provider) GetTemplate(commentType provider.CommentType) string <span class="cov0" title="0">{
        return provider.GetMarkdownTemplate(commentType)
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package bitbucketcloud

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/types"
        "go.uber.org/zap"
)

var (
        pullRequestsClosed         = []string{"pullrequest:closed", "pullrequest:fulfilled", "pullrequest:rejected"}
        pullRequestsCreated        = []string{"pullrequest:created", "pullrequest:updated"}
        pullRequestsCommentCreated = []string{"pullrequest:comment_created"}
        pushRepo                   = []string{"repo:push"}
        PullRequestAllEvents       = append(append(append(append([]string{}, pullRequestsCreated...), pullRequestsCommentCreated...), pullRequestsClosed...), pushRepo...)
)

func (v *Provider) Detect(req *http.Request, payload string, logger *zap.SugaredLogger) (bool, bool, *zap.SugaredLogger, string, error) <span class="cov8" title="1">{
        isBitCloud := false
        reqHeader := req.Header
        event := reqHeader.Get("X-Event-Key")
        if event == "" </span><span class="cov8" title="1">{
                return false, false, logger, "", nil
        }</span>

        <span class="cov8" title="1">eventInt, err := parsePayloadType(event, payload)
        if err != nil || eventInt == nil </span><span class="cov8" title="1">{
                logger.Error("skip processing event", zap.String("event", event), zap.Error(err))
                return false, false, logger, "", err
        }</span>

        // it is a Bitbucket cloud event
        <span class="cov8" title="1">isBitCloud = true

        setLoggerAndProceed := func(processEvent bool, reason string, err error) (bool, bool, *zap.SugaredLogger,
                string, error,
        ) </span><span class="cov8" title="1">{
                logger = logger.With("provider", "bitbucket-cloud", "event-id", reqHeader.Get("X-Request-Id"))
                return isBitCloud, processEvent, logger, reason, err
        }</span>

        <span class="cov8" title="1">_ = json.Unmarshal([]byte(payload), &amp;eventInt)

        switch e := eventInt.(type) </span>{
        case *types.PullRequestEvent:<span class="cov8" title="1">
                if provider.Valid(event, pullRequestsClosed) </span><span class="cov0" title="0">{
                        return setLoggerAndProceed(true, "", nil)
                }</span>

                <span class="cov8" title="1">if provider.Valid(event, pullRequestsCreated) </span><span class="cov8" title="1">{
                        return setLoggerAndProceed(true, "", nil)
                }</span>

                <span class="cov8" title="1">if provider.Valid(event, pullRequestsCommentCreated) </span><span class="cov8" title="1">{
                        if provider.IsTestRetestComment(e.Comment.Content.Raw) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                        <span class="cov8" title="1">if provider.IsOkToTestComment(e.Comment.Content.Raw) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                        <span class="cov8" title="1">if provider.IsCancelComment(e.Comment.Content.Raw) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                }
                <span class="cov8" title="1">return setLoggerAndProceed(false, fmt.Sprintf("not a valid gitops comment: \"%s\"", event), nil)</span>

        case *types.PushRequestEvent:<span class="cov8" title="1">
                if provider.Valid(event, pushRepo) </span><span class="cov8" title="1">{
                        if e.Push.Changes != nil </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                }
                <span class="cov0" title="0">return setLoggerAndProceed(false, fmt.Sprintf("invalid push event: \"%s\"", event), nil)</span>

        default:<span class="cov0" title="0">
                return setLoggerAndProceed(false, "", fmt.Errorf("bitbucket-cloud: event \"%s\" is not supported", event))</span>
        }
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package bitbucketcloud

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud/types"
)

const bitbucketCloudIPrangesList = "https://ip-ranges.atlassian.com/"

// lastForwarderForIP get last ip from the X-Forwarded-For chain
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For
func lastForwarderForIP(xff string) string <span class="cov8" title="1">{
        split := strings.Split(xff, ",")
        return split[len(split)-1]
}</span>

// checkFromPublicCloudIPS Grab public IP from public cloud and make sure we match it.
func (v *Provider) checkFromPublicCloudIPS(ctx context.Context, run *params.Run, sourceIP string) (bool, error) <span class="cov8" title="1">{
        if !v.pacInfo.BitbucketCloudCheckSourceIP </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if sourceIP == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("we need to check the source_ip but no source_ip has been passed")
        }</span>
        <span class="cov8" title="1">sourceIP = lastForwarderForIP(sourceIP)

        netsourceIP := net.ParseIP(sourceIP)
        data, err := run.Clients.GetURL(ctx, bitbucketCloudIPrangesList)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">ipranges := &amp;types.IPRanges{}
        err = json.Unmarshal(data, &amp;ipranges)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">extraIPEnv := v.pacInfo.BitbucketCloudAdditionalSourceIP
        if extraIPEnv != "" </span><span class="cov8" title="1">{
                for _, value := range strings.Split(extraIPEnv, ",") </span><span class="cov8" title="1">{
                        if !strings.Contains(value, "/") </span><span class="cov8" title="1">{
                                value = fmt.Sprintf("%s/32", value)
                        }</span>
                        <span class="cov8" title="1">ipranges.Items = append(ipranges.Items, types.IPRangesItem{
                                CIDR: strings.TrimSpace(value),
                        })</span>
                }
        }
        <span class="cov8" title="1">for _, value := range ipranges.Items </span><span class="cov8" title="1">{
                _, cidr, err := net.ParseCIDR(value.CIDR)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if cidr.Contains(netsourceIP) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false,
                fmt.Errorf("payload from %s is not coming from the public bitbucket cloud ips as defined here: %s",
                        sourceIP, bitbucketCloudIPrangesList)</span>
}

func parsePayloadType(event, rawPayload string) (any, error) <span class="cov8" title="1">{
        var payload any

        var localEvent string
        if strings.HasPrefix(event, "pullrequest:") </span><span class="cov8" title="1">{
                if !provider.Valid(event, PullRequestAllEvents) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("event %s is not supported", event)
                }</span>
                <span class="cov8" title="1">localEvent = triggertype.PullRequest.String()</span>
        } else<span class="cov8" title="1"> if provider.Valid(event, pushRepo) </span><span class="cov8" title="1">{
                localEvent = "push"
        }</span>

        <span class="cov8" title="1">switch localEvent </span>{
        case triggertype.PullRequest.String():<span class="cov8" title="1">
                payload = &amp;types.PullRequestEvent{}</span>
        case "push":<span class="cov8" title="1">
                payload = &amp;types.PushRequestEvent{}</span>
        default:<span class="cov8" title="1">
                return nil, nil</span>
        }
        <span class="cov8" title="1">err := json.Unmarshal([]byte(rawPayload), payload)
        return payload, err</span>
}

func (v *Provider) ParsePayload(ctx context.Context, run *params.Run, request *http.Request, payload string) (*info.Event, error) <span class="cov8" title="1">{
        processedEvent := info.NewEvent()

        event := request.Header.Get("X-Event-Key")
        eventInt, err := parsePayloadType(event, payload)
        if err != nil || eventInt == nil </span><span class="cov0" title="0">{
                return info.NewEvent(), err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal([]byte(payload), &amp;eventInt)
        if err != nil </span><span class="cov0" title="0">{
                return info.NewEvent(), err
        }</span>

        <span class="cov8" title="1">sourceIP := request.Header.Get("X-Forwarded-For")
        allowed, err := v.checkFromPublicCloudIPS(ctx, run, sourceIP)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !allowed </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("payload is not coming from the public bitbucket cloud ips as defined here: %s",
                        bitbucketCloudIPrangesList)
        }</span>

        <span class="cov8" title="1">processedEvent.Event = eventInt
        switch e := eventInt.(type) </span>{
        case *types.PullRequestEvent:<span class="cov8" title="1">
                processedEvent.TriggerTarget = triggertype.PullRequest
                switch </span>{
                case provider.Valid(event, pullRequestsCreated):<span class="cov8" title="1">
                        processedEvent.EventType = triggertype.PullRequest.String()</span>
                case provider.Valid(event, pullRequestsCommentCreated):<span class="cov8" title="1">
                        opscomments.SetEventTypeAndTargetPR(processedEvent, e.Comment.Content.Raw)</span>
                case provider.Valid(event, pullRequestsClosed):<span class="cov0" title="0">
                        processedEvent.EventType = string(triggertype.PullRequestClosed)
                        processedEvent.TriggerTarget = triggertype.PullRequestClosed</span>
                }
                <span class="cov8" title="1">processedEvent.Organization = e.Repository.Workspace.Slug
                processedEvent.Repository = strings.Split(e.Repository.FullName, "/")[1]
                processedEvent.SHA = e.PullRequest.Source.Commit.Hash
                processedEvent.URL = e.Repository.Links.HTML.HRef
                processedEvent.BaseBranch = e.PullRequest.Destination.Branch.Name
                processedEvent.HeadBranch = e.PullRequest.Source.Branch.Name
                processedEvent.BaseURL = e.PullRequest.Destination.Repository.Links.HTML.HRef
                processedEvent.HeadURL = e.PullRequest.Source.Repository.Links.HTML.HRef
                processedEvent.AccountID = e.PullRequest.Author.AccountID
                processedEvent.Sender = e.PullRequest.Author.Nickname
                processedEvent.PullRequestNumber = e.PullRequest.ID
                processedEvent.PullRequestTitle = e.PullRequest.Title</span>
        case *types.PushRequestEvent:<span class="cov8" title="1">
                processedEvent.Event = "push"
                processedEvent.TriggerTarget = "push"
                processedEvent.EventType = "push"
                processedEvent.Organization = e.Repository.Workspace.Slug
                processedEvent.Repository = strings.Split(e.Repository.FullName, "/")[1]
                processedEvent.SHA = e.Push.Changes[0].New.Target.Hash
                processedEvent.URL = e.Repository.Links.HTML.HRef
                processedEvent.HeadBranch = e.Push.Changes[0].Old.Name
                processedEvent.BaseURL = e.Push.Changes[0].New.Target.Links.HTML.HRef
                processedEvent.HeadURL = e.Push.Changes[0].Old.Target.Links.HTML.HRef
                if e.Push.Changes[0].New.Type == "tag" </span><span class="cov8" title="1">{
                        processedEvent.BaseBranch = fmt.Sprintf("refs/tags/%s", e.Push.Changes[0].New.Name)
                }</span> else<span class="cov8" title="1"> {
                        processedEvent.BaseBranch = e.Push.Changes[0].New.Name
                }</span>
                <span class="cov8" title="1">processedEvent.AccountID = e.Actor.AccountID
                processedEvent.Sender = e.Actor.Nickname</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("event %s is not recognized", event)</span>
        }
        <span class="cov8" title="1">return processedEvent, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package bitbucketdatacenter

import (
        "context"
        "fmt"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/acl"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"

        "github.com/jenkins-x/go-scm/scm"
)

func (v *Provider) IsAllowed(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        allowed, err := v.checkMemberShip(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // Check then from comment if there is a approved user that has done a /ok-to-test
        <span class="cov8" title="1">return v.checkOkToTestCommentFromApprovedMember(ctx, event)</span>
}

// IsAllowedOwnersFile get the owner files (OWNERS, OWNERS_ALIASES) from main branch
// and check if we have explicitly allowed the user in there.
func (v *Provider) IsAllowedOwnersFile(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        ownerContent, err := v.GetFileInsideRepo(ctx, event, "OWNERS", event.DefaultBranch)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">ownerAliasesContent, err := v.GetFileInsideRepo(ctx, event, "OWNERS_ALIASES", event.DefaultBranch)
        if err != nil </span><span class="cov8" title="1">{
                if !strings.Contains(err.Error(), "cannot find") </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">return acl.UserInOwnerFile(ownerContent, ownerAliasesContent, event.AccountID)</span>
}

func (v *Provider) checkOkToTestCommentFromApprovedMember(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        allComments := []*scm.Comment{}
        OrgAndRepo := fmt.Sprintf("%s/%s", event.Organization, event.Repository)
        opts := &amp;scm.ListOptions{Page: 1, Size: apiResponseLimit}
        for </span><span class="cov8" title="1">{
                comments, _, err := v.Client().PullRequests.ListComments(ctx, OrgAndRepo, v.pullRequestNumber, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">allComments = append(allComments, comments...)

                if len(comments) &lt; apiResponseLimit </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov0" title="0">opts.Page++</span>
        }

        <span class="cov8" title="1">for _, comment := range allComments </span><span class="cov8" title="1">{
                if acl.MatchRegexp(acl.OKToTestCommentRegexp, comment.Body) </span><span class="cov8" title="1">{
                        commenterEvent := info.NewEvent()
                        commenterEvent.Sender = comment.Author.Login
                        commenterEvent.AccountID = fmt.Sprintf("%d", comment.Author.ID)
                        commenterEvent.Event = event.Event
                        commenterEvent.BaseBranch = event.BaseBranch
                        commenterEvent.HeadBranch = event.HeadBranch
                        commenterEvent.Repository = event.Repository
                        commenterEvent.Organization = v.projectKey
                        commenterEvent.DefaultBranch = event.DefaultBranch
                        allowed, err := v.checkMemberShip(ctx, commenterEvent)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, err
                        }</span>
                        <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                                // TODO: show a log how come this has been allowed
                                return true, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">return false, nil</span>
}

func (v *Provider) checkMemberShip(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        // Get permissions from project
        allowed, _, err := v.Client().Organizations.IsMember(ctx, event.Organization, event.Sender)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">orgAndRepo := fmt.Sprintf("%s/%s", event.Organization, event.Repository)
        // Get permissions from repo
        allowed, _, err = v.Client().Repositories.IsCollaborator(ctx, orgAndRepo, event.Sender)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if allowed </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Check if sender is inside the Owner file
        // in the 'main' branch Silently ignore error, which should be fine it
        // probably means the OWNERS file is not created. If we had another error
        // (ie: like API) we probably would have hit it already.
        <span class="cov8" title="1">allowed, err = v.IsAllowedOwnersFile(ctx, event)
        if allowed </span><span class="cov8" title="1">{
                return true, err
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package bitbucketdatacenter

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "path/filepath"
        "strings"

        "github.com/google/go-github/v74/github"
        "github.com/jenkins-x/go-scm/scm"
        "github.com/jenkins-x/go-scm/scm/driver/stash"
        "github.com/jenkins-x/go-scm/scm/transport/oauth2"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        providerMetrics "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/metrics"
        "go.uber.org/zap"
)

const taskStatusTemplate = `{{range $taskrun := .TaskRunList }}| **{{ formatCondition $taskrun.PipelineRunTaskRunStatus.Status.Conditions }}** | {{ $taskrun.ConsoleLogURL }} | *{{ formatDuration $taskrun.Status.StartTime $taskrun.Status.CompletionTime }}* |
{{ end }}`
const apiResponseLimit = 100

var _ provider.Interface = (*Provider)(nil)

type Provider struct {
        client                    *scm.Client
        Logger                    *zap.SugaredLogger
        run                       *params.Run
        pacInfo                   *info.PacOpts
        baseURL                   string
        defaultBranchLatestCommit string
        pullRequestNumber         int
        apiURL                    string
        provenance                string
        projectKey                string
        repo                      *v1alpha1.Repository
        triggerEvent              string
}

func (v Provider) Client() *scm.Client <span class="cov8" title="1">{
        providerMetrics.RecordAPIUsage(
                v.Logger,
                v.GetConfig().Name,
                v.triggerEvent,
                v.repo,
        )
        return v.client
}</span>

func (v *Provider) CreateComment(_ context.Context, _ *info.Event, _, _ string) error <span class="cov0" title="0">{
        return nil
}</span>

func (v *Provider) SetPacInfo(pacInfo *info.PacOpts) <span class="cov0" title="0">{
        v.pacInfo = pacInfo
}</span>

func (v *Provider) CheckPolicyAllowing(_ context.Context, _ *info.Event, _ []string) (bool, string) <span class="cov0" title="0">{
        return false, ""
}</span>

// GetTaskURI TODO: Implement ME.
func (v *Provider) GetTaskURI(_ context.Context, _ *info.Event, _ string) (bool, string, error) <span class="cov0" title="0">{
        return false, "", nil
}</span>

func (v *Provider) SetLogger(logger *zap.SugaredLogger) <span class="cov0" title="0">{
        v.Logger = logger
}</span>

func (v *Provider) Validate(_ context.Context, _ *params.Run, event *info.Event) error <span class="cov8" title="1">{
        signature := event.Request.Header.Get("X-Hub-Signature")
        if event.Provider.WebhookSecret == "" &amp;&amp; signature != "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket-datacenter failed validation: failed to find webhook secret")
        }</span>
        <span class="cov8" title="1">return github.ValidateSignature(signature, event.Request.Payload, []byte(event.Provider.WebhookSecret))</span>
}

// sanitizeTitle make sure we only get the tile by remove everything after \n.
func sanitizeTitle(s string) string <span class="cov8" title="1">{
        return strings.Split(s, "\n")[0]
}</span>

func (v *Provider) CreateStatus(ctx context.Context, event *info.Event, statusOpts provider.StatusOpts) error <span class="cov8" title="1">{
        detailsURL := event.Provider.URL
        switch statusOpts.Conclusion </span>{
        case "skipped":<span class="cov8" title="1">
                statusOpts.Conclusion = "FAILED"
                statusOpts.Title = " Skipping this commit"</span>
        case "neutral":<span class="cov8" title="1">
                statusOpts.Conclusion = "FAILED"
                statusOpts.Title = " CI has stopped"</span>
        case "failure":<span class="cov8" title="1">
                statusOpts.Conclusion = "FAILED"
                statusOpts.Title = " Failed"</span>
        case "pending":<span class="cov8" title="1">
                if statusOpts.Status == "queued" </span><span class="cov8" title="1">{
                        statusOpts.Conclusion = "UNKNOWN"
                }</span> else<span class="cov8" title="1"> {
                        statusOpts.Conclusion = "INPROGRESS"
                        statusOpts.Title = " CI has started"
                }</span>
        case "success":<span class="cov8" title="1">
                statusOpts.Conclusion = "SUCCESSFUL"
                statusOpts.Title = "Commit has been validated"</span>
        case "completed":<span class="cov8" title="1">
                statusOpts.Conclusion = "SUCCESSFUL"
                statusOpts.Title = "Completed"</span>
        }
        <span class="cov8" title="1">if statusOpts.DetailsURL != "" </span><span class="cov8" title="1">{
                detailsURL = statusOpts.DetailsURL
        }</span>
        <span class="cov8" title="1">if v.client == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no token has been set, cannot set status")
        }</span>

        <span class="cov8" title="1">key := statusOpts.PipelineRunName
        if key == "" </span><span class="cov8" title="1">{
                key = statusOpts.Title
        }</span>

        <span class="cov8" title="1">if v.pacInfo.ApplicationName != "" </span><span class="cov8" title="1">{
                key = fmt.Sprintf("%s / %s", v.pacInfo.ApplicationName, key)
        }</span>

        <span class="cov8" title="1">OrgAndRepo := fmt.Sprintf("%s/%s", event.Organization, event.Repository)
        opts := &amp;scm.StatusInput{
                State: convertState(statusOpts.Conclusion),
                Label: key,
                Desc:  statusOpts.Text,
                Link:  detailsURL,
        }
        _, _, err := v.Client().Repositories.CreateStatus(ctx, OrgAndRepo, event.SHA, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">onPr := ""
        if statusOpts.OriginalPipelineRunName != "" </span><span class="cov0" title="0">{
                onPr = "/" + statusOpts.OriginalPipelineRunName
        }</span>
        <span class="cov8" title="1">bbComment := fmt.Sprintf("**%s%s** - %s\n\n%s", v.pacInfo.ApplicationName, onPr, statusOpts.Title, statusOpts.Text)

        if statusOpts.Conclusion == "SUCCESSFUL" &amp;&amp; statusOpts.Status == "completed" &amp;&amp;
                statusOpts.Text != "" &amp;&amp; event.TriggerTarget == triggertype.PullRequest &amp;&amp; event.PullRequestNumber &gt; 0 </span><span class="cov0" title="0">{
                input := &amp;scm.CommentInput{
                        Body: bbComment,
                }
                _, _, err := v.Client().PullRequests.CreateComment(ctx, OrgAndRepo, event.PullRequestNumber, input)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // TODO: Completed status
        <span class="cov8" title="1">return nil</span>
}

func convertState(from string) scm.State <span class="cov8" title="1">{
        switch from </span>{
        case "FAILED":<span class="cov8" title="1">
                return scm.StateFailure</span>
        case "INPROGRESS":<span class="cov8" title="1">
                return scm.StatePending</span>
        case "SUCCESSFUL":<span class="cov8" title="1">
                return scm.StateSuccess</span>
        case "UNKNOWN":<span class="cov8" title="1">
                return scm.StateUnknown</span>
        default:<span class="cov0" title="0">
                return scm.StateUnknown</span>
        }
}

func (v *Provider) concatAllYamlFiles(ctx context.Context, objects []string, sha string, runevent *info.Event) (string, error) <span class="cov8" title="1">{
        var allTemplates string
        for _, value := range objects </span><span class="cov8" title="1">{
                if strings.HasSuffix(value, ".yaml") ||
                        strings.HasSuffix(value, ".yml") </span><span class="cov8" title="1">{
                        // if sha is empty string then it fetches raw file from
                        // default branch which we can use for PAC provenance.
                        data, err := v.getRaw(ctx, runevent, sha, value)
                        if err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>

                        <span class="cov8" title="1">if err := provider.ValidateYaml([]byte(data), value); err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>

                        <span class="cov8" title="1">if allTemplates != "" &amp;&amp; !strings.HasPrefix(data, "---") </span><span class="cov8" title="1">{
                                allTemplates += "---"
                        }</span>
                        <span class="cov8" title="1">allTemplates += "\n" + data + "\n"</span>
                }
        }
        <span class="cov8" title="1">return allTemplates, nil</span>
}

func (v *Provider) getRaw(ctx context.Context, runevent *info.Event, revision, path string) (string, error) <span class="cov8" title="1">{
        repo := fmt.Sprintf("%s/%s", runevent.Organization, runevent.Repository)
        content, _, err := v.Client().Contents.Find(ctx, repo, path, revision)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("cannot find %s inside the %s repository: %w", path, runevent.Repository, err)
        }</span>
        <span class="cov8" title="1">return string(content.Data), nil</span>
}

func (v *Provider) GetTektonDir(ctx context.Context, event *info.Event, path, provenance string) (string, error) <span class="cov8" title="1">{
        v.provenance = provenance
        // If "at" is empty string "" then default branch will be used as source
        at := ""
        if v.provenance == "source" </span><span class="cov0" title="0">{
                at = event.SHA
                v.Logger.Infof("Using PipelineRun definition from source %s commit SHA: %s", event.TriggerTarget.String(), event.SHA)
        }</span> else<span class="cov8" title="1"> {
                v.Logger.Infof("Using PipelineRun definition from default_branch: %s", event.DefaultBranch)
        }</span>

        <span class="cov8" title="1">orgAndRepo := fmt.Sprintf("%s/%s", event.Organization, event.Repository)
        var fileEntries []*scm.FileEntry
        opts := &amp;scm.ListOptions{Page: 1, Size: apiResponseLimit}
        for </span><span class="cov8" title="1">{
                entries, _, err := v.Client().Contents.List(ctx, orgAndRepo, path, at, opts)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("cannot list content of %s directory: %w", path, err)
                }</span>
                <span class="cov8" title="1">fileEntries = append(fileEntries, entries...)

                if len(entries) &lt; apiResponseLimit </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov0" title="0">opts.Page++</span>
        }

        <span class="cov8" title="1">fpathTmpl := []string{}
        for _, e := range fileEntries </span><span class="cov8" title="1">{
                fpathTmpl = append(fpathTmpl, filepath.Join(path, e.Path))
        }</span>

        <span class="cov8" title="1">return v.concatAllYamlFiles(ctx, fpathTmpl, at, event)</span>
}

func (v *Provider) GetFileInsideRepo(ctx context.Context, event *info.Event, path, targetBranch string) (string, error) <span class="cov8" title="1">{
        branch := event.SHA
        // TODO: this may be buggy? we need to figure out how to get the fromSource ref
        if targetBranch == event.DefaultBranch </span><span class="cov8" title="1">{
                branch = v.defaultBranchLatestCommit
        }</span>

        <span class="cov8" title="1">ret, err := v.getRaw(ctx, event, branch, path)
        return ret, err</span>
}

func removeLastSegment(urlStr string) string <span class="cov8" title="1">{
        u, _ := url.Parse(urlStr)
        segments := strings.Split(u.Path, "/")
        switch </span>{
        case len(segments) &gt; 1:<span class="cov8" title="1">
                segments = segments[:len(segments)-1]</span>
        case (len(segments) == 1 &amp;&amp; segments[0] != "") || u.Path == "/":<span class="cov0" title="0">
                segments = []string{""}</span>
        }

        <span class="cov8" title="1">newPath := strings.Join(segments, "/")
        if newPath == "" &amp;&amp; strings.HasPrefix(u.Path, "/") </span><span class="cov8" title="1">{
                newPath = "/" // Ensure root path is correctly represented as "/"
        }</span>

        <span class="cov8" title="1">u.Path = newPath
        return u.String()</span>
}

func (v *Provider) SetClient(ctx context.Context, run *params.Run, event *info.Event, repo *v1alpha1.Repository, _ *events.EventEmitter) error <span class="cov8" title="1">{
        if event.Provider.User == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no spec.git_provider.user has been set in the repo crd")
        }</span>
        <span class="cov8" title="1">if event.Provider.Token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no spec.git_provider.secret has been set in the repo crd")
        }</span>
        <span class="cov8" title="1">if event.Provider.URL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no spec.git_provider.url has been set in the repo crd")
        }</span>

        // make sure we have /rest at the end of the url
        <span class="cov8" title="1">if !strings.HasSuffix(event.Provider.URL, "/rest") </span><span class="cov8" title="1">{
                event.Provider.URL += "/rest"
        }</span>

        // make sure we strip slashes from the end of the URL
        <span class="cov8" title="1">event.Provider.URL = strings.TrimSuffix(event.Provider.URL, "/")
        v.apiURL = event.Provider.URL

        if v.client == nil </span><span class="cov0" title="0">{
                client, err := stash.New(removeLastSegment(event.Provider.URL)) // remove `/rest` from url
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">client.Client = &amp;http.Client{
                        Transport: &amp;oauth2.Transport{
                                Source: oauth2.StaticTokenSource(
                                        &amp;scm.Token{
                                                Token: event.Provider.Token,
                                        },
                                ),
                        },
                }
                v.client = client

                // Added for security audit purposes to log client access when a token is used
                run.Clients.Log.Infof("bitbucket-datacenter: initialized client with provided token for user=%s providerURL=%s", event.Provider.User, event.Provider.URL)</span>
        }
        <span class="cov8" title="1">v.run = run
        v.repo = repo
        v.triggerEvent = event.EventType
        _, resp, err := v.Client().Users.FindLogin(ctx, event.Provider.User)
        if resp != nil &amp;&amp; resp.Status == http.StatusUnauthorized </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot get user %s with token: %w", event.Provider.User, err)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot get user %s: %w", event.Provider.User, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (v *Provider) GetCommitInfo(_ context.Context, event *info.Event) error <span class="cov8" title="1">{
        OrgAndRepo := fmt.Sprintf("%s/%s", event.Organization, event.Repository)
        commit, _, err := v.Client().Git.FindCommit(context.Background(), OrgAndRepo, event.SHA)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">event.SHATitle = sanitizeTitle(commit.Message)
        event.SHAURL = fmt.Sprintf("%s/projects/%s/repos/%s/commits/%s", v.baseURL, v.projectKey, event.Repository, event.SHA)

        ref, _, err := v.Client().Git.GetDefaultBranch(context.Background(), OrgAndRepo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">v.defaultBranchLatestCommit = ref.Sha
        event.DefaultBranch = ref.Name
        return nil</span>
}

func (v *Provider) GetConfig() *info.ProviderConfig <span class="cov8" title="1">{
        return &amp;info.ProviderConfig{
                TaskStatusTMPL: taskStatusTemplate,
                Name:           "bitbucket-datacenter",
        }
}</span>

func (v *Provider) GetFiles(ctx context.Context, runevent *info.Event) (changedfiles.ChangedFiles, error) <span class="cov8" title="1">{
        OrgAndRepo := fmt.Sprintf("%s/%s", runevent.Organization, runevent.Repository)
        if runevent.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                opts := &amp;scm.ListOptions{Page: 1, Size: apiResponseLimit}
                changedFiles := changedfiles.ChangedFiles{}
                for </span><span class="cov8" title="1">{
                        changes, _, err := v.Client().PullRequests.ListChanges(ctx, OrgAndRepo, runevent.PullRequestNumber, opts)
                        if err != nil </span><span class="cov8" title="1">{
                                return changedfiles.ChangedFiles{}, fmt.Errorf("failed to list changes for pull request: %w", err)
                        }</span>

                        <span class="cov8" title="1">for _, c := range changes </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, c.Path)
                                if c.Added </span><span class="cov8" title="1">{
                                        changedFiles.Added = append(changedFiles.Added, c.Path)
                                }</span>
                                <span class="cov8" title="1">if c.Modified </span><span class="cov8" title="1">{
                                        changedFiles.Modified = append(changedFiles.Modified, c.Path)
                                }</span>
                                <span class="cov8" title="1">if c.Renamed </span><span class="cov8" title="1">{
                                        changedFiles.Renamed = append(changedFiles.Renamed, c.Path)
                                }</span>
                                <span class="cov8" title="1">if c.Deleted </span><span class="cov8" title="1">{
                                        changedFiles.Deleted = append(changedFiles.Deleted, c.Path)
                                }</span>
                        }

                        // In the Jenkins-x/go-scm package, the `isLastPage` field is not available, and the value of
                        // `response.Page.Last` is set to `0`. Therefore, to determine if there are more items to fetch,
                        // we can check if the length of the currently fetched items is less than the specified limit.
                        // If the length is less than the limit, it indicates that there are no more items to retrieve.
                        <span class="cov8" title="1">if len(changes) &lt; apiResponseLimit </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov0" title="0">opts.Page++</span>
                }
                <span class="cov8" title="1">return changedFiles, nil</span>
        }

        <span class="cov8" title="1">if runevent.TriggerTarget == triggertype.Push </span><span class="cov8" title="1">{
                opts := &amp;scm.ListOptions{Page: 1, Size: apiResponseLimit}
                changedFiles := changedfiles.ChangedFiles{}
                for </span><span class="cov8" title="1">{
                        changes, _, err := v.Client().Git.ListChanges(ctx, OrgAndRepo, runevent.SHA, opts)
                        if err != nil </span><span class="cov8" title="1">{
                                return changedfiles.ChangedFiles{}, fmt.Errorf("failed to list changes for commit %s: %w", runevent.SHA, err)
                        }</span>

                        <span class="cov8" title="1">for _, c := range changes </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, c.Path)
                                if c.Added </span><span class="cov8" title="1">{
                                        changedFiles.Added = append(changedFiles.Added, c.Path)
                                }</span>
                                <span class="cov8" title="1">if c.Modified </span><span class="cov8" title="1">{
                                        changedFiles.Modified = append(changedFiles.Modified, c.Path)
                                }</span>
                                <span class="cov8" title="1">if c.Renamed </span><span class="cov8" title="1">{
                                        changedFiles.Renamed = append(changedFiles.Renamed, c.Path)
                                }</span>
                                <span class="cov8" title="1">if c.Deleted </span><span class="cov8" title="1">{
                                        changedFiles.Deleted = append(changedFiles.Deleted, c.Path)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(changes) &lt; apiResponseLimit </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov0" title="0">opts.Page++</span>
                }
                <span class="cov8" title="1">return changedFiles, nil</span>
        }
        <span class="cov0" title="0">return changedfiles.ChangedFiles{}, nil</span>
}

func (v *Provider) CreateToken(_ context.Context, _ []string, _ *info.Event) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (v *Provider) GetTemplate(commentType provider.CommentType) string <span class="cov0" title="0">{
        return provider.GetMarkdownTemplate(commentType)
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package bitbucketdatacenter

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter/types"
        "go.uber.org/zap"
)

// Detect processes event and detect if it is a bitbucket data center event, whether to process or reject it
// returns (if is a bitbucket data center event, whether to process or reject, error if any occurred).
func (v *Provider) Detect(req *http.Request, payload string, logger *zap.SugaredLogger) (bool, bool, *zap.SugaredLogger, string, error) <span class="cov8" title="1">{
        isBitDataCenter := false
        event := req.Header.Get("X-Event-Key")
        if event == "" </span><span class="cov8" title="1">{
                return false, false, logger, "", nil
        }</span>

        <span class="cov8" title="1">eventPayload, err := parsePayloadType(event)
        if err != nil || eventPayload == nil </span><span class="cov8" title="1">{
                return false, false, logger, "", err
        }</span>

        // it is a Bitbucket data center event
        <span class="cov8" title="1">isBitDataCenter = true

        setLoggerAndProceed := func(processEvent bool, reason string, err error) (bool, bool, *zap.SugaredLogger, string,
                error,
        ) </span><span class="cov8" title="1">{
                logger = logger.With("provider", "bitbucket-datacenter", "event-id", req.Header.Get("X-Request-Id"))
                return isBitDataCenter, processEvent, logger, reason, err
        }</span>

        <span class="cov8" title="1">_ = json.Unmarshal([]byte(payload), &amp;eventPayload)

        switch e := eventPayload.(type) </span>{
        case *types.PullRequestEvent:<span class="cov8" title="1">
                if provider.Valid(event, []string{"pr:from_ref_updated", "pr:opened"}) </span><span class="cov8" title="1">{
                        return setLoggerAndProceed(true, "", nil)
                }</span>
                <span class="cov8" title="1">if provider.Valid(event, []string{"pr:comment:added"}) </span><span class="cov8" title="1">{
                        if provider.IsTestRetestComment(e.Comment.Text) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                        <span class="cov8" title="1">if provider.IsOkToTestComment(e.Comment.Text) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                        <span class="cov8" title="1">if provider.IsCancelComment(e.Comment.Text) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                }
                <span class="cov8" title="1">return setLoggerAndProceed(false, fmt.Sprintf("not a recognized bitbucket event: \"%s\"", event), nil)</span>

        case *types.PushRequestEvent:<span class="cov8" title="1">
                if provider.Valid(event, []string{"repo:refs_changed"}) </span><span class="cov8" title="1">{
                        if e.Changes != nil </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                }
                <span class="cov0" title="0">return setLoggerAndProceed(false, fmt.Sprintf("not an event we support: \"%s\"", event), nil)</span>

        default:<span class="cov0" title="0">
                return setLoggerAndProceed(false, "", fmt.Errorf("bitbucket-datacenter: event \"%s\" is not supported", event))</span>
        }
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package bitbucketdatacenter

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter/types"
)

// checkValidPayload checks if the payload is valid.
func checkValidPayload(e *types.PullRequestEvent) error <span class="cov8" title="1">{
        if e.PullRequest.ToRef.Repository.Project == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket toRef project is nil")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.ToRef.Repository.Project.Key == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket toRef project key is empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.ToRef.Repository.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket toRef repository name is empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.ToRef.LatestCommit == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket toRef latest commit is empty")
        }</span>

        <span class="cov8" title="1">if e.PullRequest.FromRef.Repository.Project == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket fromRef project is nil")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.FromRef.Repository.Project.Key == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket fromRef project key is empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.FromRef.Repository.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket fromRef repository name is empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.FromRef.LatestCommit == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket fromRef latest commit is empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.ID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket pull request ID is zero")
        }</span>

        <span class="cov8" title="1">if e.PullRequest.ToRef.Repository.Links == nil || len(e.PullRequest.ToRef.Repository.Links.Self) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket toRef repository links are nil or empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.ToRef.DisplayID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket toRef display ID is empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.FromRef.DisplayID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket fromRef display ID is empty")
        }</span>
        <span class="cov8" title="1">if e.PullRequest.FromRef.Repository.Links == nil || len(e.PullRequest.FromRef.Repository.Links.Self) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket fromRef repository links are nil or empty")
        }</span>
        <span class="cov8" title="1">if len(e.PullRequest.ToRef.Repository.Links.Clone) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket toRef repository clone links are empty")
        }</span>
        <span class="cov8" title="1">if len(e.PullRequest.FromRef.Repository.Links.Clone) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket fromRef repository clone links are empty")
        }</span>

        <span class="cov8" title="1">if e.Actor.ID == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket actor ID is zero")
        }</span>
        <span class="cov8" title="1">if e.Actor.Name == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("bitbucket actor name is empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// sanitizeEventURL returns the URL to the event without the /browse.
func sanitizeEventURL(eventURL string) string <span class="cov8" title="1">{
        if strings.HasSuffix(eventURL, "/browse") </span><span class="cov8" title="1">{
                return eventURL[:len(eventURL)-len("/browse")]
        }</span>
        <span class="cov8" title="1">return eventURL</span>
}

// sanitizeOwner remove ~ from OWNER in case of personal repos.
func sanitizeOwner(owner string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(owner, "~", "")
}</span>

// ParsePayload parses the payload from the event.
func (v *Provider) ParsePayload(_ context.Context, _ *params.Run, request *http.Request,
        payload string,
) (*info.Event, error) <span class="cov8" title="1">{
        processedEvent := info.NewEvent()

        eventType := request.Header.Get("X-Event-Key")
        eventPayload, err := parsePayloadType(eventType)
        if err != nil </span><span class="cov8" title="1">{
                return info.NewEvent(), err
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal([]byte(payload), &amp;eventPayload); err != nil </span><span class="cov8" title="1">{
                return info.NewEvent(), err
        }</span>

        <span class="cov8" title="1">processedEvent.Event = eventPayload

        switch e := eventPayload.(type) </span>{
        case *types.PullRequestEvent:<span class="cov8" title="1">
                if provider.Valid(eventType, []string{"pr:from_ref_updated", "pr:opened"}) </span><span class="cov8" title="1">{
                        processedEvent.TriggerTarget = triggertype.PullRequest
                        processedEvent.EventType = triggertype.PullRequest.String()
                }</span> else<span class="cov8" title="1"> if provider.Valid(eventType, []string{"pr:comment:added", "pr:comment:edited"}) </span><span class="cov8" title="1">{
                        switch </span>{
                        case provider.IsTestRetestComment(e.Comment.Text):<span class="cov8" title="1">
                                processedEvent.TriggerTarget = triggertype.PullRequest
                                if strings.Contains(e.Comment.Text, "/test") </span><span class="cov8" title="1">{
                                        processedEvent.EventType = "test-comment"
                                }</span> else<span class="cov8" title="1"> {
                                        processedEvent.EventType = "retest-comment"
                                }</span>
                                <span class="cov8" title="1">processedEvent.TargetTestPipelineRun = provider.GetPipelineRunFromTestComment(e.Comment.Text)</span>
                        case provider.IsOkToTestComment(e.Comment.Text):<span class="cov8" title="1">
                                processedEvent.TriggerTarget = triggertype.PullRequest
                                processedEvent.EventType = "ok-to-test-comment"</span>
                        case provider.IsCancelComment(e.Comment.Text):<span class="cov8" title="1">
                                processedEvent.TriggerTarget = triggertype.PullRequest
                                processedEvent.EventType = "cancel-comment"
                                processedEvent.CancelPipelineRuns = true
                                processedEvent.TargetCancelPipelineRun = provider.GetPipelineRunFromCancelComment(e.Comment.Text)</span>
                        }
                        <span class="cov8" title="1">processedEvent.TriggerComment = e.Comment.Text</span>
                }

                <span class="cov8" title="1">if err := checkValidPayload(e); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // TODO: It's Really not an OWNER but a PROJECT
                <span class="cov8" title="1">processedEvent.Organization = e.PullRequest.ToRef.Repository.Project.Key
                processedEvent.Repository = e.PullRequest.ToRef.Repository.Name
                processedEvent.SHA = e.PullRequest.FromRef.LatestCommit
                processedEvent.PullRequestNumber = e.PullRequest.ID
                processedEvent.URL = e.PullRequest.ToRef.Repository.Links.Self[0].Href
                processedEvent.BaseBranch = e.PullRequest.ToRef.DisplayID
                processedEvent.HeadBranch = e.PullRequest.FromRef.DisplayID
                processedEvent.BaseURL = e.PullRequest.ToRef.Repository.Links.Self[0].Href
                processedEvent.HeadURL = e.PullRequest.FromRef.Repository.Links.Self[0].Href
                processedEvent.AccountID = fmt.Sprintf("%d", e.Actor.ID)
                processedEvent.Sender = e.Actor.Name
                for _, value := range e.PullRequest.FromRef.Repository.Links.Clone </span><span class="cov8" title="1">{
                        if value.Name == "http" </span><span class="cov8" title="1">{
                                processedEvent.CloneURL = value.Href
                        }</span>
                }
                <span class="cov8" title="1">v.pullRequestNumber = e.PullRequest.ID</span>
        case *types.PushRequestEvent:<span class="cov8" title="1">
                processedEvent.TriggerTarget = triggertype.Push
                processedEvent.EventType = triggertype.Push.String()
                processedEvent.Organization = e.Repository.Project.Key
                processedEvent.Repository = e.Repository.Slug

                if len(e.Changes) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("push event contains no commits under 'changes'; cannot proceed")
                }</span>

                // Check for branch deletion - if any change is a DELETE type with zero hash, skip processing
                <span class="cov8" title="1">for _, change := range e.Changes </span><span class="cov8" title="1">{
                        if provider.IsZeroSHA(change.ToHash) &amp;&amp; change.Type == "DELETE" </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("branch delete event is not supported; cannot proceed")
                        }</span>
                }

                <span class="cov8" title="1">if len(e.Commits) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("push event contains no commits; cannot proceed")
                }</span>

                <span class="cov8" title="1">processedEvent.SHA = e.Changes[0].ToHash
                processedEvent.URL = e.Repository.Links.Self[0].Href
                processedEvent.BaseBranch = e.Changes[0].RefID
                processedEvent.HeadBranch = e.Changes[0].RefID
                processedEvent.BaseURL = e.Repository.Links.Self[0].Href
                processedEvent.HeadURL = e.Repository.Links.Self[0].Href
                processedEvent.AccountID = fmt.Sprintf("%d", e.Actor.ID)
                processedEvent.Sender = e.Actor.Name
                // Should we care about clone via SSH or just only do HTTP clones?
                for _, value := range e.Repository.Links.Clone </span><span class="cov8" title="1">{
                        if value.Name == "http" </span><span class="cov8" title="1">{
                                processedEvent.CloneURL = value.Href
                        }</span>
                }
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("event %s is not supported", eventType)</span>
        }

        <span class="cov8" title="1">v.projectKey = processedEvent.Organization
        processedEvent.Organization = sanitizeOwner(processedEvent.Organization)
        processedEvent.URL = sanitizeEventURL(processedEvent.URL)

        // TODO: is this the right way? I guess i have no way to know what is the
        // baseURL of a bitbucket data center unless there is something in the API?
        // remove everything after /project in the URL to get the basePath
        pURL, err := url.Parse(processedEvent.URL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">v.baseURL = fmt.Sprintf("%s://%s", pURL.Scheme, pURL.Host)
        return processedEvent, nil</span>
}

func parsePayloadType(event string) (any, error) <span class="cov8" title="1">{
        // bitbucket data center event type has `pr:` prefix for pull request
        // but in case of push event it is `repo:` prefix for both bitbucket data center
        // and cloud, so we check the event name directly
        var localEvent string
        if strings.HasPrefix(event, "pr:") </span><span class="cov8" title="1">{
                if !provider.Valid(event, []string{
                        "pr:from_ref_updated", "pr:opened", "pr:comment:added", "pr:comment:edited",
                }) </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("event \"%s\" is not supported", event)
                }</span>
                <span class="cov8" title="1">localEvent = triggertype.PullRequest.String()</span>
        } else<span class="cov8" title="1"> if event == "repo:refs_changed" </span><span class="cov8" title="1">{
                localEvent = "push"
        }</span>

        <span class="cov8" title="1">var intfType any
        switch localEvent </span>{
        case triggertype.PullRequest.String():<span class="cov8" title="1">
                intfType = &amp;types.PullRequestEvent{}</span>
        case "push":<span class="cov8" title="1">
                intfType = &amp;types.PushRequestEvent{}</span>
        default:<span class="cov8" title="1">
                intfType = nil</span>
        }
        <span class="cov8" title="1">return intfType, nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package gitea

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        giteaStructs "code.gitea.io/gitea/modules/structs"
        "code.gitea.io/sdk/gitea"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/acl"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/policy"
)

func (v *Provider) CheckPolicyAllowing(_ context.Context, event *info.Event, allowedTeams []string) (bool, string) <span class="cov8" title="1">{
        if event.Organization == event.Repository </span><span class="cov0" title="0">{
                return true, ""
        }</span>
        // TODO: caching
        <span class="cov8" title="1">orgTeams, resp, err := v.Client().ListOrgTeams(event.Organization, gitea.ListTeamsOptions{})
        if resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                // we explicitly disallow the policy when there is no team on org
                return false, fmt.Sprintf("no teams on org %s", event.Organization)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // probably a 500 or another api error, no need to try again and again with other teams
                return false, fmt.Sprintf("error while getting org team, error: %s", err.Error())
        }</span>
        <span class="cov8" title="1">for _, allowedTeam := range allowedTeams </span><span class="cov8" title="1">{
                for _, orgTeam := range orgTeams </span><span class="cov8" title="1">{
                        if orgTeam.Name == allowedTeam </span><span class="cov8" title="1">{
                                teamMember, _, err := v.Client().GetTeamMember(orgTeam.ID, event.Sender)
                                if err != nil </span><span class="cov0" title="0">{
                                        v.Logger.Infof("error while getting team member: %s, error: %s", event.Sender, err.Error())
                                        continue</span>
                                }
                                <span class="cov8" title="1">if teamMember.ID != 0 </span><span class="cov8" title="1">{
                                        return true, fmt.Sprintf("allowing user: %s as a member of the team: %s", event.Sender, orgTeam.Name)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false, fmt.Sprintf("user: %s is not a member of any of the allowed teams: %v", event.Sender, allowedTeams)</span>
}

func (v *Provider) IsAllowed(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        aclPolicy := policy.Policy{
                Repository:   v.repo,
                EventEmitter: v.eventEmitter,
                Event:        event,
                VCX:          v,
                Logger:       v.Logger,
        }

        // Try to detect a policy rule allowed it
        tType, _ := detectTriggerTypeFromPayload("", event.Event)
        policyAllowed, policyReason := aclPolicy.IsAllowed(ctx, tType)
        switch policyAllowed </span>{
        case policy.ResultAllowed:<span class="cov0" title="0">
                return true, nil</span>
        case policy.ResultDisallowed:<span class="cov0" title="0">
                return false, nil</span>
        case policy.ResultNotSet:<span class="cov8" title="1"></span> // this is to make golangci-lint happy
        }

        // Check all the ACL rules
        <span class="cov8" title="1">allowed, err := v.aclCheckAll(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if allowed </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Try to parse the comment from an owner who has issues a /ok-to-test
        <span class="cov8" title="1">ownerAllowed, err := v.aclAllowedOkToTestFromAnOwner(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if ownerAllowed </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // error with the policy reason if it was set
        <span class="cov8" title="1">if policyReason != "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%s", policyReason)
        }</span>

        // finally silently return false if no rules allowed this
        <span class="cov8" title="1">return false, nil</span>
}

// allowedOkToTestFromAnOwner Go over comments in a pull request and check
// if there is a /ok-to-test in there running an aclCheck again on the comment
// Sender if she is an OWNER and then allow it to run CI.
// TODO: pull out the github logic from there in an agnostic way.
func (v *Provider) aclAllowedOkToTestFromAnOwner(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        revent := info.NewEvent()
        event.DeepCopyInto(revent)
        revent.EventType = ""
        revent.TriggerTarget = ""
        if revent.Event == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">switch event := revent.Event.(type) </span>{
        case *giteaStructs.IssueCommentPayload:<span class="cov8" title="1">
                // if we don't need to check old comments, then on issue comment we
                // need to check if comment have /ok-to-test and is from allowed user
                if !v.pacInfo.RememberOKToTest </span><span class="cov8" title="1">{
                        return v.aclAllowedOkToTestCurrentComment(ctx, revent, event.Comment.ID)
                }</span>
                <span class="cov8" title="1">revent.URL = event.Issue.URL</span>
        case *giteaStructs.PullRequestPayload:<span class="cov8" title="1">
                // if we don't need to check old comments, then on push event we don't need
                // to check anything for the non-allowed user
                if !v.pacInfo.RememberOKToTest </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">revent.URL = event.PullRequest.HTMLURL</span>
        default:<span class="cov8" title="1">
                return false, nil</span>
        }

        <span class="cov8" title="1">comments, err := v.GetStringPullRequestComment(ctx, revent, acl.OKToTestCommentRegexp)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, comment := range comments </span><span class="cov8" title="1">{
                revent.Sender = comment.Poster.UserName
                allowed, err := v.aclCheckAll(ctx, revent)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// aclAllowedOkToTestCurrentEvent only check if this is issue comment event
// have /ok-to-test regex and sender is allowed.
func (v *Provider) aclAllowedOkToTestCurrentComment(ctx context.Context, revent *info.Event, id int64) (bool, error) <span class="cov8" title="1">{
        comment, _, err := v.Client().GetIssueComment(revent.Organization, revent.Repository, id)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if acl.MatchRegexp(acl.OKToTestCommentRegexp, comment.Body) </span><span class="cov8" title="1">{
                revent.Sender = comment.Poster.UserName
                allowed, err := v.aclCheckAll(ctx, revent)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// aclCheck check if we are allowed to run the pipeline on that PR.
func (v *Provider) aclCheckAll(ctx context.Context, rev *info.Event) (bool, error) <span class="cov8" title="1">{
        if rev.Organization == rev.Sender </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">checkSenderRepoMembership, err := v.checkSenderRepoMembership(ctx, rev)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if checkSenderRepoMembership </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return v.IsAllowedOwnersFile(ctx, rev)</span>
}

// IsAllowedOwnersFile get the OWNERS files from main branch and check if we have
// explicitly allowed the user in there.
func (v *Provider) IsAllowedOwnersFile(ctx context.Context, rev *info.Event) (bool, error) <span class="cov8" title="1">{
        // If we have a OWNERS and OWNERS_ALIASE files in the defaultBranch (ie: master) then
        // parse them and check if sender is in there.
        ownerContent, err := v.getFileFromDefaultBranch(ctx, "OWNERS", rev)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "cannot find") </span><span class="cov8" title="1">{
                        // no owner file, skipping
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        // If there is OWNERS file, check for OWNERS_ALIASES. OWNERS can exist without OWNERS_ALIASES.
        // OWNERS_ALIASES can't exist without OWNERS.
        <span class="cov8" title="1">ownerAliasesContent, err := v.getFileFromDefaultBranch(ctx, "OWNERS_ALIASES", rev)
        if err != nil </span><span class="cov8" title="1">{
                if !strings.Contains(err.Error(), "cannot find") </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">return acl.UserInOwnerFile(ownerContent, ownerAliasesContent, rev.Sender)</span>
}

func (v *Provider) checkSenderRepoMembership(_ context.Context, runevent *info.Event) (bool, error) <span class="cov8" title="1">{
        ret, _, err := v.Client().IsCollaborator(runevent.Organization, runevent.Repository, runevent.Sender)
        return ret, err
}</span>

// getFileFromDefaultBranch will get a file directly from the Default BaseBranch as
// configured in runinfo which is directly set in webhook by Github.
func (v *Provider) getFileFromDefaultBranch(ctx context.Context, path string, runevent *info.Event) (string, error) <span class="cov8" title="1">{
        tektonyaml, err := v.GetFileInsideRepo(ctx, runevent, path, runevent.DefaultBranch)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("cannot find %s inside the %s branch: %w", path, runevent.DefaultBranch, err)
        }</span>
        <span class="cov8" title="1">return tektonyaml, err</span>
}

// GetStringPullRequestComment return the comment if we find a regexp in one of
// the comments text of a pull request.
func (v *Provider) GetStringPullRequestComment(_ context.Context, runevent *info.Event, reg string) ([]*gitea.Comment, error) <span class="cov8" title="1">{
        var ret []*gitea.Comment
        prNumber, err := convertPullRequestURLtoNumber(runevent.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">comments, _, err := v.Client().ListIssueComments(runevent.Organization, runevent.Repository, int64(prNumber), gitea.ListIssueCommentOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, v := range comments </span><span class="cov8" title="1">{
                if acl.MatchRegexp(reg, v.Body) </span><span class="cov8" title="1">{
                        ret = append(ret, v)
                }</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package gitea

import (
        "encoding/json"
        "fmt"
        "net/http"

        giteaStructs "code.gitea.io/gitea/modules/structs"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "go.uber.org/zap"
)

var (
        pullRequestOpenSyncEvent = []string{"opened", "synchronize", "synchronized", "reopened"}
        pullRequestLabelUpdated  = "label_updated"
        pullRequestLabelClosed   = "closed"
)

// Detect processes event and detect if it is a gitea event, whether to process or reject it
// returns (if is a Gitea event, whether to process or reject, logger with event metadata,, error if any occurred).
func (v *Provider) Detect(req *http.Request, payload string, logger *zap.SugaredLogger) (bool, bool, *zap.SugaredLogger, string, error) <span class="cov8" title="1">{
        isGitea := false
        eventType := req.Header.Get("X-Gitea-Event-Type")
        if eventType == "" </span><span class="cov8" title="1">{
                return false, false, logger, "not a gitea event", nil
        }</span>

        <span class="cov8" title="1">isGitea = true
        setLoggerAndProceed := func(processEvent bool, reason string, err error) (bool, bool, *zap.SugaredLogger,
                string, error,
        ) </span><span class="cov8" title="1">{
                logger = logger.With("provider", "gitea", "event-id", req.Header.Get("X-Gitea-Delivery"))
                return isGitea, processEvent, logger, reason, err
        }</span>

        <span class="cov8" title="1">eventInt, err := parseWebhook(whEventType(eventType), []byte(payload))
        if err != nil </span><span class="cov8" title="1">{
                return setLoggerAndProceed(false, "", err)
        }</span>
        <span class="cov8" title="1">_ = json.Unmarshal([]byte(payload), &amp;eventInt)
        eType, errReason := detectTriggerTypeFromPayload(eventType, eventInt)
        if eType != "" </span><span class="cov8" title="1">{
                return setLoggerAndProceed(true, "", nil)
        }</span>

        <span class="cov8" title="1">return setLoggerAndProceed(false, errReason, nil)</span>
}

// detectTriggerTypeFromPayload will detect the event type from the payload,
// filtering out the events that are not supported.
func detectTriggerTypeFromPayload(ghEventType string, eventInt any) (triggertype.Trigger, string) <span class="cov8" title="1">{
        switch event := eventInt.(type) </span>{
        case *giteaStructs.PushPayload:<span class="cov8" title="1">
                if event.Pusher != nil </span><span class="cov8" title="1">{
                        return triggertype.Push, ""
                }</span>
                <span class="cov8" title="1">return "", "invalid payload: no pusher in event"</span>
        case *giteaStructs.PullRequestPayload:<span class="cov8" title="1">
                if provider.Valid(string(event.Action), append(pullRequestOpenSyncEvent, pullRequestLabelUpdated, pullRequestLabelClosed)) </span><span class="cov8" title="1">{
                        return triggertype.PullRequest, ""
                }</span>
                <span class="cov8" title="1">return "", fmt.Sprintf("pull_request: unsupported action \"%s\"", event.Action)</span>
        case *giteaStructs.IssueCommentPayload:<span class="cov8" title="1">
                if event.Action == "created" &amp;&amp;
                        event.Issue.PullRequest != nil &amp;&amp;
                        event.Issue.State == "open" </span><span class="cov8" title="1">{
                        if provider.IsTestRetestComment(event.Comment.Body) </span><span class="cov8" title="1">{
                                return triggertype.Retest, ""
                        }</span>
                        <span class="cov8" title="1">if provider.IsOkToTestComment(event.Comment.Body) </span><span class="cov8" title="1">{
                                return triggertype.OkToTest, ""
                        }</span>
                        <span class="cov8" title="1">if provider.IsCancelComment(event.Comment.Body) </span><span class="cov8" title="1">{
                                return triggertype.Cancel, ""
                        }</span>
                        // this ignores the comment if it is not a PAC gitops comment and not return an error
                        <span class="cov8" title="1">return triggertype.Comment, ""</span>
                }
                <span class="cov8" title="1">return "", "skip: not a PAC gitops comment"</span>
        }
        <span class="cov8" title="1">return "", fmt.Sprintf("gitea: event \"%v\" is not supported", ghEventType)</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package gitea

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "path"
        "regexp"
        "strconv"
        "strings"

        "code.gitea.io/sdk/gitea"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        providerMetrics "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/metrics"
        "go.uber.org/zap"
)

const (
        taskStatusTemplate = `
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;th&gt;Duration&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt;

{{- range $taskrun := .TaskRunList }}
&lt;tr&gt;
&lt;td&gt;{{ formatCondition $taskrun.PipelineRunTaskRunStatus.Status.Conditions }}&lt;/td&gt;
&lt;td&gt;{{ formatDuration $taskrun.PipelineRunTaskRunStatus.Status.StartTime $taskrun.Status.CompletionTime }}&lt;/td&gt;&lt;td&gt;

{{ $taskrun.ConsoleLogURL }}

&lt;/td&gt;&lt;/tr&gt;
{{- end }}
&lt;/table&gt;`
)

// validate the struct to interface.
var _ provider.Interface = (*Provider)(nil)

type Provider struct {
        giteaClient      *gitea.Client
        Logger           *zap.SugaredLogger
        pacInfo          *info.PacOpts
        Token            *string
        giteaInstanceURL string
        // only exposed for e2e tests
        Password     string
        repo         *v1alpha1.Repository
        eventEmitter *events.EventEmitter
        run          *params.Run
        triggerEvent string
}

func (v *Provider) Client() *gitea.Client <span class="cov8" title="1">{
        providerMetrics.RecordAPIUsage(
                v.Logger,
                // URL used instead of "gitea" to differentiate in the case of a CI cluster which
                // serves multiple Gitea instances
                v.giteaInstanceURL,
                v.triggerEvent,
                v.repo,
        )
        return v.giteaClient
}</span>

func (v *Provider) SetGiteaClient(client *gitea.Client) <span class="cov0" title="0">{
        v.giteaClient = client
}</span>

func (v *Provider) CreateComment(_ context.Context, event *info.Event, commit, updateMarker string) error <span class="cov8" title="1">{
        if v.giteaClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no gitea client has been initialized")
        }</span>

        <span class="cov8" title="1">if event.PullRequestNumber == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("create comment only works on pull requests")
        }</span>

        // List comments of the PR
        <span class="cov8" title="1">if updateMarker != "" </span><span class="cov8" title="1">{
                comments, _, err := v.Client().ListIssueComments(event.Organization, event.Repository, int64(event.PullRequestNumber), gitea.ListIssueCommentOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">re := regexp.MustCompile(updateMarker)
                for _, comment := range comments </span><span class="cov8" title="1">{
                        if re.MatchString(comment.Body) </span><span class="cov8" title="1">{
                                _, _, err := v.Client().EditIssueComment(event.Organization, event.Repository, comment.ID, gitea.EditIssueCommentOption{
                                        Body: commit,
                                })
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">_, _, err := v.Client().CreateIssueComment(event.Organization, event.Repository, int64(event.PullRequestNumber), gitea.CreateIssueCommentOption{
                Body: commit,
        })

        return err</span>
}

func (v *Provider) SetPacInfo(pacInfo *info.PacOpts) <span class="cov0" title="0">{
        v.pacInfo = pacInfo
}</span>

// GetTaskURI TODO: Implement ME.
func (v *Provider) GetTaskURI(_ context.Context, _ *info.Event, _ string) (bool, string, error) <span class="cov0" title="0">{
        return false, "", nil
}</span>

func (v *Provider) SetLogger(logger *zap.SugaredLogger) <span class="cov0" title="0">{
        v.Logger = logger
}</span>

func (v *Provider) Validate(_ context.Context, _ *params.Run, _ *info.Event) error <span class="cov0" title="0">{
        // TODO: figure out why gitea doesn't work with mac validation as github which seems to be the same
        v.Logger.Debug("no secret and signature found, skipping validation for gitea")
        return nil
}</span>

func convertPullRequestURLtoNumber(pullRequest string) (int, error) <span class="cov8" title="1">{
        prNumber, err := strconv.Atoi(path.Base(pullRequest))
        if err != nil </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("bad pull request number html_url number: %w", err)
        }</span>
        <span class="cov8" title="1">return prNumber, nil</span>
}

func (v *Provider) GetConfig() *info.ProviderConfig <span class="cov0" title="0">{
        return &amp;info.ProviderConfig{
                TaskStatusTMPL: taskStatusTemplate,
                APIURL:         v.giteaInstanceURL,
                Name:           "gitea",
                SkipEmoji:      true,
        }
}</span>

func (v *Provider) SetClient(_ context.Context, run *params.Run, runevent *info.Event, repo *v1alpha1.Repository, emitter *events.EventEmitter) error <span class="cov0" title="0">{
        var err error
        apiURL := runevent.Provider.URL
        // password is not exposed to CRD, it's only used from the e2e tests
        if v.Password != "" &amp;&amp; runevent.Provider.User != "" </span><span class="cov0" title="0">{
                v.giteaClient, err = gitea.NewClient(apiURL, gitea.SetBasicAuth(runevent.Provider.User, v.Password))
        }</span> else<span class="cov0" title="0"> {
                if runevent.Provider.Token == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("no git_provider.secret has been set in the repo crd")
                }</span>
                <span class="cov0" title="0">v.giteaClient, err = gitea.NewClient(apiURL, gitea.SetToken(runevent.Provider.Token))</span>
        }
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Added log for security audit purposes to log client access when a token is used
        <span class="cov0" title="0">run.Clients.Log.Infof("gitea: initialized API client with provided credentials user=%s providerURL=%s", runevent.Provider.User, apiURL)

        v.giteaInstanceURL = runevent.Provider.URL
        v.eventEmitter = emitter
        v.repo = repo
        v.run = run
        v.triggerEvent = runevent.EventType
        return nil</span>
}

func (v *Provider) CreateStatus(_ context.Context, event *info.Event, statusOpts provider.StatusOpts) error <span class="cov8" title="1">{
        if v.giteaClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot set status on gitea no token or url set")
        }</span>
        <span class="cov8" title="1">switch statusOpts.Conclusion </span>{
        case "success":<span class="cov8" title="1">
                statusOpts.Title = "Success"
                statusOpts.Summary = "has &lt;b&gt;successfully&lt;/b&gt; validated your commit."</span>
        case "failure":<span class="cov8" title="1">
                statusOpts.Title = "Failed"
                statusOpts.Summary = "has &lt;b&gt;failed&lt;/b&gt;."</span>
        case "pending":<span class="cov8" title="1">
                // for concurrency set title as pending
                if statusOpts.Title == "" </span><span class="cov8" title="1">{
                        statusOpts.Title = "Pending"
                }</span>
                // for unauthorized user set title as Pending approval
                <span class="cov8" title="1">statusOpts.Summary = "is skipping this commit."</span>
        case "neutral":<span class="cov8" title="1">
                statusOpts.Title = "Unknown"
                statusOpts.Summary = "doesn't know what happened with this commit."</span>
        }

        <span class="cov8" title="1">if statusOpts.Status == "in_progress" </span><span class="cov8" title="1">{
                statusOpts.Title = "CI has Started"
                statusOpts.Summary = "is running.\n"
        }</span>

        <span class="cov8" title="1">onPr := ""
        if statusOpts.PipelineRunName != "" </span><span class="cov8" title="1">{
                onPr = fmt.Sprintf("/%s", statusOpts.PipelineRunName)
        }</span>
        // gitea show weirdly the &lt;br&gt;
        <span class="cov8" title="1">statusOpts.Summary = fmt.Sprintf("%s%s %s", v.pacInfo.ApplicationName, onPr, statusOpts.Summary)

        return v.createStatusCommit(event, v.pacInfo, statusOpts)</span>
}

func (v *Provider) createStatusCommit(event *info.Event, pacopts *info.PacOpts, status provider.StatusOpts) error <span class="cov8" title="1">{
        state := gitea.StatusState(status.Conclusion)
        switch status.Conclusion </span>{
        case "neutral":<span class="cov8" title="1">
                state = gitea.StatusSuccess</span> // We don't have a choice than setting as success, no pending here.c
        case "pending":<span class="cov8" title="1">
                if status.Title != "" </span><span class="cov8" title="1">{
                        state = gitea.StatusPending
                }</span>
        }
        <span class="cov8" title="1">if status.Status == "in_progress" </span><span class="cov8" title="1">{
                state = gitea.StatusPending
        }</span>

        <span class="cov8" title="1">gStatus := gitea.CreateStatusOption{
                State:       state,
                TargetURL:   status.DetailsURL,
                Description: status.Title,
                Context:     provider.GetCheckName(status, pacopts),
        }
        if _, _, err := v.Client().CreateStatus(event.Organization, event.Repository, event.SHA, gStatus); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">eventType := triggertype.IsPullRequestType(event.EventType)
        if opscomments.IsAnyOpsEventType(eventType.String()) </span><span class="cov8" title="1">{
                eventType = triggertype.PullRequest
        }</span>
        <span class="cov8" title="1">if status.Text != "" &amp;&amp; (eventType == triggertype.PullRequest || event.TriggerTarget == triggertype.PullRequest) </span><span class="cov8" title="1">{
                status.Text = strings.ReplaceAll(strings.TrimSpace(status.Text), "&lt;br&gt;", "\n")
                _, _, err := v.Client().CreateIssueComment(event.Organization, event.Repository,
                        int64(event.PullRequestNumber), gitea.CreateIssueCommentOption{
                                Body: fmt.Sprintf("%s\n%s", status.Summary, status.Text),
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (v *Provider) GetTektonDir(_ context.Context, event *info.Event, path, provenance string) (string, error) <span class="cov8" title="1">{
        // default set provenance from the SHA
        revision := event.SHA
        if provenance == "default_branch" </span><span class="cov0" title="0">{
                revision = event.DefaultBranch
                v.Logger.Infof("Using PipelineRun definition from default_branch: %s", event.DefaultBranch)
        }</span> else<span class="cov8" title="1"> {
                v.Logger.Infof("Using PipelineRun definition from source %s commit SHA: %s", event.TriggerTarget.String(), event.SHA)
        }</span>

        <span class="cov8" title="1">tektonDirSha := ""
        opt := gitea.ListTreeOptions{
                Ref:       revision,
                Recursive: false,
        }
        rootobjects, _, err := v.Client().GetTrees(event.Organization, event.Repository, opt)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">for _, object := range rootobjects.Entries </span><span class="cov8" title="1">{
                if object.Path == path </span><span class="cov8" title="1">{
                        if object.Type != "tree" </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("%s has been found but is not a directory", path)
                        }</span>
                        <span class="cov8" title="1">tektonDirSha = object.SHA</span>
                }
        }

        // If we didn't find a .tekton directory then just silently ignore the error.
        <span class="cov8" title="1">if tektonDirSha == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        // Get all files in the .tekton directory recursively
        // TODO: figure out if there is a object limit we need to handle here
        <span class="cov8" title="1">opts := gitea.ListTreeOptions{Recursive: false, Ref: tektonDirSha}
        tektonDirObjects, _, err := v.Client().GetTrees(event.Organization, event.Repository, opts)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return v.concatAllYamlFiles(tektonDirObjects.Entries, event)</span>
}

func (v *Provider) concatAllYamlFiles(objects []gitea.GitEntry, event *info.Event) (string,
        error,
) <span class="cov8" title="1">{
        var allTemplates string

        for _, value := range objects </span><span class="cov8" title="1">{
                if strings.HasSuffix(value.Path, ".yaml") ||
                        strings.HasSuffix(value.Path, ".yml") </span><span class="cov8" title="1">{
                        data, err := v.getObject(value.SHA, event)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if err := provider.ValidateYaml(data, value.Path); err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">if allTemplates != "" &amp;&amp; !strings.HasPrefix(string(data), "---") </span><span class="cov0" title="0">{
                                allTemplates += "---"
                        }</span>
                        <span class="cov0" title="0">allTemplates += "\n" + string(data) + "\n"</span>
                }
        }
        <span class="cov0" title="0">return allTemplates, nil</span>
}

func (v *Provider) getObject(sha string, event *info.Event) ([]byte, error) <span class="cov8" title="1">{
        blob, _, err := v.Client().GetBlob(event.Organization, event.Repository, sha)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(blob.Content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return decoded, err</span>
}

func (v *Provider) GetFileInsideRepo(_ context.Context, runevent *info.Event, path, target string) (string, error) <span class="cov8" title="1">{
        ref := runevent.SHA
        if target != "" </span><span class="cov8" title="1">{
                ref = runevent.BaseBranch
        }</span>

        <span class="cov8" title="1">content, _, err := v.Client().GetContents(runevent.Organization, runevent.Repository, ref, path)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        // base64 decode to string
        <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(*content.Content)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(decoded), nil</span>
}

func (v *Provider) GetCommitInfo(_ context.Context, runevent *info.Event) error <span class="cov0" title="0">{
        if v.giteaClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no gitea client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>

        <span class="cov0" title="0">sha := runevent.SHA
        if sha == "" &amp;&amp; runevent.HeadBranch != "" </span><span class="cov0" title="0">{
                branchinfo, _, err := v.Client().GetRepoBranch(runevent.Organization, runevent.Repository, runevent.HeadBranch)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sha = branchinfo.Commit.ID</span>
        } else<span class="cov0" title="0"> if sha == "" &amp;&amp; runevent.PullRequestNumber != 0 </span><span class="cov0" title="0">{
                pr, _, err := v.Client().GetPullRequest(runevent.Organization, runevent.Repository, int64(runevent.PullRequestNumber))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">runevent.SHA = pr.Head.Sha
                runevent.HeadBranch = pr.Head.Ref
                runevent.BaseBranch = pr.Base.Ref
                sha = pr.Head.Sha</span>
        }
        <span class="cov0" title="0">commit, _, err := v.Client().GetSingleCommit(runevent.Organization, runevent.Repository, sha)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">runevent.SHAURL = commit.HTMLURL
        runevent.SHATitle = strings.Split(commit.RepoCommit.Message, "\n\n")[0]
        runevent.SHA = commit.SHA
        return nil</span>
}

func ShouldGetNextPage(resp *gitea.Response, currentPage int) (bool, int) <span class="cov8" title="1">{
        val, exists := resp.Header[http.CanonicalHeaderKey("x-pagecount")]
        if !exists </span><span class="cov8" title="1">{
                return false, 0
        }</span>
        <span class="cov0" title="0">i, err := strconv.Atoi(val[0])
        if err != nil </span><span class="cov0" title="0">{
                return false, 0
        }</span>
        <span class="cov0" title="0">if i &gt;= currentPage </span><span class="cov0" title="0">{
                return false, i
        }</span>
        <span class="cov0" title="0">return true, (currentPage + 1)</span>
}

type PushPayload struct {
        Commits []gitea.PayloadCommit `json:"commits,omitempty"`
}

func (v *Provider) GetFiles(_ context.Context, runevent *info.Event) (changedfiles.ChangedFiles, error) <span class="cov8" title="1">{
        changedFiles := changedfiles.ChangedFiles{}

        //nolint:exhaustive // we don't need to handle all cases
        switch runevent.TriggerTarget </span>{
        case triggertype.PullRequest, triggertype.PullRequestClosed:<span class="cov8" title="1">
                opt := gitea.ListPullRequestFilesOptions{ListOptions: gitea.ListOptions{Page: 1, PageSize: 50}}
                shouldGetNextPage := false
                for </span><span class="cov8" title="1">{
                        prChangedFiles, resp, err := v.Client().ListPullRequestFiles(runevent.Organization, runevent.Repository, int64(runevent.PullRequestNumber), opt)
                        if err != nil </span><span class="cov0" title="0">{
                                return changedfiles.ChangedFiles{}, err
                        }</span>
                        <span class="cov8" title="1">for j := range prChangedFiles </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, prChangedFiles[j].Filename)
                                if prChangedFiles[j].Status == "added" </span><span class="cov8" title="1">{
                                        changedFiles.Added = append(changedFiles.Added, prChangedFiles[j].Filename)
                                }</span>
                                <span class="cov8" title="1">if prChangedFiles[j].Status == "deleted" </span><span class="cov8" title="1">{
                                        changedFiles.Deleted = append(changedFiles.Deleted, prChangedFiles[j].Filename)
                                }</span>
                                <span class="cov8" title="1">if prChangedFiles[j].Status == "changed" </span><span class="cov8" title="1">{
                                        changedFiles.Modified = append(changedFiles.Modified, prChangedFiles[j].Filename)
                                }</span>
                                <span class="cov8" title="1">if prChangedFiles[j].Status == "renamed" </span><span class="cov8" title="1">{
                                        changedFiles.Renamed = append(changedFiles.Renamed, prChangedFiles[j].Filename)
                                }</span>
                        }

                        <span class="cov8" title="1">shouldGetNextPage, opt.Page = ShouldGetNextPage(resp, opt.Page)
                        if !shouldGetNextPage </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        case triggertype.Push:<span class="cov8" title="1">
                pushPayload := PushPayload{}
                err := json.Unmarshal(runevent.Request.Payload, &amp;pushPayload)
                if err != nil </span><span class="cov0" title="0">{
                        v.Logger.Errorf("failed to unmarshal the push payload to get changed files - %v", err)
                        return changedfiles.ChangedFiles{}, fmt.Errorf("failed to unmarshal the push payload to get changed files - %w", err)
                }</span>

                <span class="cov8" title="1">for _, commit := range pushPayload.Commits </span><span class="cov8" title="1">{
                        for _, file := range commit.Added </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, file)
                                changedFiles.Added = append(changedFiles.Added, file)
                        }</span>
                        <span class="cov8" title="1">for _, file := range commit.Modified </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, file)
                                changedFiles.Modified = append(changedFiles.Modified, file)
                        }</span>
                        <span class="cov8" title="1">for _, file := range commit.Removed </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, file)
                                changedFiles.Deleted = append(changedFiles.Deleted, file)
                        }</span>
                }
        default:<span class="cov0" title="0">
                v.Logger.Errorf("unable to get changed files. Unknown trigger type of '%s'. Expected pull_request or push", runevent.TriggerTarget)
                return changedFiles, fmt.Errorf("unable to get changed files. Unknown trigger type of '%s'. Expected pull_request or push", runevent.TriggerTarget)</span>
        }

        <span class="cov8" title="1">return changedFiles, nil</span>
}

func (v *Provider) CreateToken(_ context.Context, _ []string, _ *info.Event) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (v *Provider) GetTemplate(commentType provider.CommentType) string <span class="cov0" title="0">{
        return provider.GetHTMLTemplate(commentType)
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package gitea

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        giteaStructs "code.gitea.io/gitea/modules/structs"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
)

func (v *Provider) ParsePayload(_ context.Context, _ *params.Run, request *http.Request,
        payload string,
) (*info.Event, error) <span class="cov0" title="0">{
        // TODO: parse request to figure out which event
        var processedEvent *info.Event

        eventType := request.Header.Get("X-Gitea-Event-Type")
        if eventType == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find event type in request header")
        }</span>

        <span class="cov0" title="0">payloadB := []byte(payload)
        eventInt, err := parseWebhook(whEventType(eventType), payloadB)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">_ = json.Unmarshal(payloadB, &amp;eventInt)

        switch gitEvent := eventInt.(type) </span>{
        case *giteaStructs.PullRequestPayload:<span class="cov0" title="0">
                processedEvent = info.NewEvent()
                // // Organization:  event.GetRepo().GetOwner().GetLogin(),
                processedEvent.Sender = gitEvent.Sender.UserName
                processedEvent.DefaultBranch = gitEvent.Repository.DefaultBranch
                processedEvent.URL = gitEvent.Repository.HTMLURL
                processedEvent.SHA = gitEvent.PullRequest.Head.Sha
                processedEvent.SHAURL = fmt.Sprintf("%s/commit/%s", gitEvent.PullRequest.HTMLURL, processedEvent.SHA)
                processedEvent.HeadBranch = gitEvent.PullRequest.Head.Ref
                processedEvent.BaseBranch = gitEvent.PullRequest.Base.Ref
                processedEvent.HeadURL = gitEvent.PullRequest.Head.Repository.HTMLURL
                processedEvent.BaseURL = gitEvent.PullRequest.Base.Repository.HTMLURL
                processedEvent.PullRequestNumber = int(gitEvent.Index)
                processedEvent.PullRequestTitle = gitEvent.PullRequest.Title
                processedEvent.Organization = gitEvent.Repository.Owner.UserName
                processedEvent.Repository = gitEvent.Repository.Name
                processedEvent.TriggerTarget = triggertype.PullRequest
                processedEvent.EventType = triggertype.PullRequest.String()
                if provider.Valid(string(gitEvent.Action), []string{pullRequestLabelUpdated}) </span><span class="cov0" title="0">{
                        processedEvent.EventType = string(triggertype.PullRequestLabeled)
                }</span>
                <span class="cov0" title="0">for _, label := range gitEvent.PullRequest.Labels </span><span class="cov0" title="0">{
                        processedEvent.PullRequestLabel = append(processedEvent.PullRequestLabel, label.Name)
                }</span>
                <span class="cov0" title="0">if gitEvent.Action == giteaStructs.HookIssueClosed </span><span class="cov0" title="0">{
                        processedEvent.TriggerTarget = triggertype.PullRequestClosed
                }</span>
        case *giteaStructs.PushPayload:<span class="cov0" title="0">
                processedEvent = info.NewEvent()
                processedEvent.SHA = gitEvent.HeadCommit.ID
                if processedEvent.SHA == "" </span><span class="cov0" title="0">{
                        processedEvent.SHA = gitEvent.Before
                }</span>
                <span class="cov0" title="0">processedEvent.SHAURL = gitEvent.HeadCommit.URL
                processedEvent.SHATitle = gitEvent.HeadCommit.Message
                processedEvent.Organization = gitEvent.Repo.Owner.UserName
                processedEvent.Repository = gitEvent.Repo.Name
                processedEvent.DefaultBranch = gitEvent.Repo.DefaultBranch
                processedEvent.URL = gitEvent.Repo.HTMLURL
                processedEvent.Sender = gitEvent.Sender.UserName
                processedEvent.BaseBranch = gitEvent.Ref
                processedEvent.EventType = eventType
                processedEvent.HeadBranch = processedEvent.BaseBranch // in push events Head Branch is the same as Basebranch
                processedEvent.BaseURL = gitEvent.Repo.HTMLURL
                processedEvent.HeadURL = processedEvent.BaseURL // in push events Head URL is the same as BaseURL
                processedEvent.TriggerTarget = "push"</span>
        case *giteaStructs.IssueCommentPayload:<span class="cov0" title="0">
                if gitEvent.Issue.PullRequest == nil </span><span class="cov0" title="0">{
                        return info.NewEvent(), fmt.Errorf("issue comment is not coming from a pull_request")
                }</span>
                <span class="cov0" title="0">processedEvent = info.NewEvent()
                processedEvent.Organization = gitEvent.Repository.Owner.UserName
                processedEvent.Repository = gitEvent.Repository.Name
                processedEvent.Sender = gitEvent.Sender.UserName
                processedEvent.TriggerTarget = triggertype.PullRequest
                opscomments.SetEventTypeAndTargetPR(processedEvent, gitEvent.Comment.Body)
                processedEvent.PullRequestNumber, err = convertPullRequestURLtoNumber(gitEvent.Issue.URL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">processedEvent.URL = gitEvent.Repository.HTMLURL
                processedEvent.DefaultBranch = gitEvent.Repository.DefaultBranch</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("event %s is not supported", eventType)</span>
        }

        <span class="cov0" title="0">processedEvent.Event = eventInt
        return processedEvent, nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package gitea

import (
        "encoding/json"
        "fmt"

        giteaStructs "code.gitea.io/gitea/modules/structs"
)

// whEventType represents a Gitea webhook event.
type whEventType string

// List of supported events
//
// Find them in Gitea's source at /models/webhook.go as HookEventType.
// To correlate with when each of these trigger, see the Trigger On -&gt; Custom Events options
// when editing a repo's webhook in a Gitea project. Those descriptions are helpful.
const (
        EventTypeCreate              whEventType = "create"
        EventTypeDelete              whEventType = "delete"
        EventTypeFork                whEventType = "fork"
        EventTypePush                whEventType = "push"
        EventTypeIssues              whEventType = "issues"
        EventTypeIssueComment        whEventType = "issue_comment"
        EventTypeRepository          whEventType = "repository"
        EventTypeRelease             whEventType = "release"
        EventTypePullRequest         whEventType = "pull_request"
        EventTypePullRequestApproved whEventType = "pull_request_approved"
        EventTypePullRequestRejected whEventType = "pull_request_rejected"
        EventTypePullRequestLabel    whEventType = "pull_request_label"
        EventTypePullRequestComment  whEventType = "pull_request_comment"
        EventTypePullRequestSync     whEventType = "pull_request_sync"
)

func parseWebhook(eventType whEventType, payload []byte) (event any, err error) <span class="cov8" title="1">{
        switch eventType </span>{
        case EventTypePush:<span class="cov8" title="1">
                event = &amp;giteaStructs.PushPayload{}</span>
        case EventTypeCreate:<span class="cov8" title="1">
                event = &amp;giteaStructs.CreatePayload{}</span>
        case EventTypeDelete:<span class="cov0" title="0">
                event = &amp;giteaStructs.DeletePayload{}</span>
        case EventTypeFork:<span class="cov0" title="0">
                event = &amp;giteaStructs.ForkPayload{}</span>
        case EventTypeIssues:<span class="cov0" title="0">
                event = &amp;giteaStructs.IssuePayload{}</span>
        case EventTypeIssueComment:<span class="cov8" title="1">
                event = &amp;giteaStructs.IssueCommentPayload{}</span>
        case EventTypeRepository:<span class="cov0" title="0">
                event = &amp;giteaStructs.RepositoryPayload{}</span>
        case EventTypeRelease:<span class="cov0" title="0">
                event = &amp;giteaStructs.ReleasePayload{}</span>
        case EventTypePullRequestComment:<span class="cov0" title="0">
                event = &amp;giteaStructs.IssueCommentPayload{}</span>
        case EventTypePullRequest, EventTypePullRequestApproved, EventTypePullRequestSync, EventTypePullRequestRejected, EventTypePullRequestLabel:<span class="cov8" title="1">
                event = &amp;giteaStructs.PullRequestPayload{}</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unexpected event type: %s", eventType)</span>
        }

        <span class="cov8" title="1">if err := json.Unmarshal(payload, event); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return event, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package github

import (
        "context"
        "fmt"
        "net/http"
        "strings"

        "github.com/google/go-github/v74/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/acl"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/policy"
)

// CheckPolicyAllowing check that policy is allowing the event to be processed
// we  check the membership of the team allowed
// if the team is not found we explicitly disallow the policy, user have to correct the setting.
func (v *Provider) CheckPolicyAllowing(ctx context.Context, event *info.Event, allowedTeams []string) (bool, string) <span class="cov8" title="1">{
        for _, team := range allowedTeams </span><span class="cov8" title="1">{
                // TODO: caching
                opt := github.ListOptions{PerPage: v.PaginedNumber}
                for </span><span class="cov8" title="1">{
                        members, resp, err := wrapAPI(v, "list_team_members_by_slug", func() ([]*github.User, *github.Response, error) </span><span class="cov8" title="1">{
                                return v.Client().Teams.ListTeamMembersBySlug(ctx, event.Organization, team, &amp;github.TeamListTeamMembersOptions{ListOptions: opt})
                        }</span>)
                        <span class="cov8" title="1">if resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                                // we explicitly disallow the policy when the team is not found
                                // maybe we should ignore it instead? i'd rather keep this explicit
                                // and conservative since being security related.
                                return false, fmt.Sprintf("team: %s is not found on the organization: %s", team, event.Organization)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                // probably a 500 or another api error, no need to try again and again with other teams
                                return false, fmt.Sprintf("error while getting team membership for user: %s in team: %s, error: %s", event.Sender, team, err.Error())
                        }</span>
                        <span class="cov8" title="1">for _, member := range members </span><span class="cov8" title="1">{
                                if member.GetLogin() == event.Sender </span><span class="cov8" title="1">{
                                        return true, fmt.Sprintf("allowing user: %s as a member of the team: %s", event.Sender, team)
                                }</span>
                        }
                        <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">opt.Page = resp.NextPage</span>
                }
        }

        <span class="cov8" title="1">return false, fmt.Sprintf("user: %s is not a member of any of the allowed teams: %v", event.Sender, allowedTeams)</span>
}

// IsAllowedOwnersFile get the owner files (OWNERS, OWNERS_ALIASES) from main branch
// and check if we have explicitly allowed the user in there.
func (v *Provider) IsAllowedOwnersFile(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        ownerContent, err := v.getFileFromDefaultBranch(ctx, "OWNERS", event)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "cannot find") </span><span class="cov8" title="1">{
                        // no owner file, skipping
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        // If there is OWNERS file, check for OWNERS_ALIASES
        <span class="cov8" title="1">ownerAliasesContent, err := v.getFileFromDefaultBranch(ctx, "OWNERS_ALIASES", event)
        if err != nil </span><span class="cov8" title="1">{
                if !strings.Contains(err.Error(), "cannot find") </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov8" title="1">return acl.UserInOwnerFile(ownerContent, ownerAliasesContent, event.Sender)</span>
}

func (v *Provider) IsAllowed(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        aclPolicy := policy.Policy{
                Repository:   v.repo,
                EventEmitter: v.eventEmitter,
                Event:        event,
                VCX:          v,
                Logger:       v.Logger,
        }

        // Try to detect a policy rule allowing this
        tType, _ := v.detectTriggerTypeFromPayload("", event.Event)
        policyAllowed, policyReason := aclPolicy.IsAllowed(ctx, tType)

        switch policyAllowed </span>{
        case policy.ResultAllowed:<span class="cov0" title="0">
                return true, nil</span>
        case policy.ResultDisallowed:<span class="cov0" title="0">
                return false, nil</span>
        case policy.ResultNotSet:<span class="cov8" title="1"></span> // this is to make golangci-lint happy
        }

        // Check all the ACL rules
        <span class="cov8" title="1">allowed, err := v.aclCheckAll(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if allowed </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Try to parse the comment from an owner who has issues a /ok-to-test
        <span class="cov8" title="1">ownerAllowed, err := v.aclAllowedOkToTestFromAnOwner(ctx, event)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if ownerAllowed </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // error with the policy reason if it was set
        <span class="cov8" title="1">if policyReason != "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%s", policyReason)
        }</span>

        // finally silently return false if no rules allowed this
        <span class="cov8" title="1">return false, nil</span>
}

// allowedOkToTestFromAnOwner Go over comments in a pull request and check
// if there is a /ok-to-test in there running an aclCheck again on the comment
// Sender if she is an OWNER and then allow it to run CI.
// TODO: pull out the github logic from there in an agnostic way.
func (v *Provider) aclAllowedOkToTestFromAnOwner(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        revent := info.NewEvent()
        event.DeepCopyInto(revent)
        revent.EventType = ""
        revent.TriggerTarget = ""
        if revent.Event == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">switch event := revent.Event.(type) </span>{
        case *github.IssueCommentEvent:<span class="cov8" title="1">
                // if we don't need to check old comments, then on issue comment we
                // need to check if comment have /ok-to-test and is from allowed user
                if !v.pacInfo.RememberOKToTest </span><span class="cov8" title="1">{
                        return v.aclAllowedOkToTestCurrentComment(ctx, revent, event.Comment.GetID())
                }</span>
                <span class="cov8" title="1">revent.URL = event.Issue.GetPullRequestLinks().GetHTMLURL()</span>
        case *github.PullRequestEvent:<span class="cov8" title="1">
                // if we don't need to check old comments, then on push event we don't need
                // to check anything for the non-allowed user
                if !v.pacInfo.RememberOKToTest </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">revent.URL = event.GetPullRequest().GetHTMLURL()</span>
        default:<span class="cov8" title="1">
                return false, nil</span>
        }

        <span class="cov8" title="1">comments, err := v.GetStringPullRequestComment(ctx, revent, acl.OKToTestCommentRegexp)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, comment := range comments </span><span class="cov8" title="1">{
                revent.Sender = comment.User.GetLogin()
                allowed, err := v.aclCheckAll(ctx, revent)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// aclAllowedOkToTestCurrentEvent only check if this is issue comment event
// have /ok-to-test regex and sender is allowed.
func (v *Provider) aclAllowedOkToTestCurrentComment(ctx context.Context, revent *info.Event, id int64) (bool, error) <span class="cov8" title="1">{
        comment, _, err := wrapAPI(v, "get_issue_comment", func() (*github.IssueComment, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Issues.GetComment(ctx, revent.Organization, revent.Repository, id)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if acl.MatchRegexp(acl.OKToTestCommentRegexp, comment.GetBody()) </span><span class="cov8" title="1">{
                revent.Sender = comment.User.GetLogin()
                allowed, err := v.aclCheckAll(ctx, revent)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// aclCheck check if we are allowed to run the pipeline on that PR.
func (v *Provider) aclCheckAll(ctx context.Context, rev *info.Event) (bool, error) <span class="cov8" title="1">{
        // if the sender own the repo, then allow it to run
        if rev.Organization == rev.Sender </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // If the user who has submitted the PR is not a owner or public member or Collaborator or not there in OWNERS file
        // but has permission to push to branches then allow the CI to be run.
        // This can only happen with GithubApp and Bots.
        // Ex: dependabot, bots
        <span class="cov8" title="1">if rev.PullRequestNumber != 0 </span><span class="cov8" title="1">{
                isSameCloneURL, err := v.checkPullRequestForSameURL(ctx, rev)
                if err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if isSameCloneURL </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        // If the user who has submitted the pr is a owner on the repo then allows
        // the CI to be run.
        <span class="cov8" title="1">isUserMemberRepo, err := v.checkSenderOrgMembership(ctx, rev)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if isUserMemberRepo </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">checkSenderRepoMembership, err := v.checkSenderRepoMembership(ctx, rev)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">if checkSenderRepoMembership </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        // If we have a prow OWNERS file in the defaultBranch (ie: master) then
        // parse it in approvers and reviewers field and check if sender is in there.
        <span class="cov8" title="1">return v.IsAllowedOwnersFile(ctx, rev)</span>
}

// checkPullRequestForSameURL checks If PullRequests are for same clone URL and different branches
// means if the user has access to create a branch in the repository without forking or having any permissions then PAC should allow to run CI.
//
//        ex: dependabot, *[bot] etc...
func (v *Provider) checkPullRequestForSameURL(ctx context.Context, runevent *info.Event) (bool, error) <span class="cov8" title="1">{
        pr, resp, err := wrapAPI(v, "get_pull_request", func() (*github.PullRequest, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().PullRequests.Get(ctx, runevent.Organization, runevent.Repository, runevent.PullRequestNumber)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if pr.GetHead().GetRepo().GetCloneURL() == pr.GetBase().GetRepo().GetCloneURL() &amp;&amp; pr.GetHead().GetRef() != pr.GetBase().GetRef() </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

// checkSenderOrgMembership Get sender user's organization. We can
// only get the one that the user sets as public .
func (v *Provider) checkSenderOrgMembership(ctx context.Context, runevent *info.Event) (bool, error) <span class="cov8" title="1">{
        opt := &amp;github.ListMembersOptions{
                ListOptions: github.ListOptions{PerPage: v.PaginedNumber},
        }

        for </span><span class="cov8" title="1">{
                users, resp, err := wrapAPI(v, "list_org_members", func() ([]*github.User, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Organizations.ListMembers(ctx, runevent.Organization, opt)
                }</span>)
                // If we are 404 it means we are checking a repo owner and not a org so let's bail out with grace
                <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return false, err
                }</span>
                <span class="cov8" title="1">for _, v := range users </span><span class="cov8" title="1">{
                        if v.GetLogin() == runevent.Sender </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
                <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">opt.Page = resp.NextPage</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// checkSenderRepoMembership check if user is allowed to run CI.
func (v *Provider) checkSenderRepoMembership(ctx context.Context, runevent *info.Event) (bool, error) <span class="cov8" title="1">{
        isCollab, _, err := wrapAPI(v, "is_collaborator", func() (bool, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Repositories.IsCollaborator(ctx,
                        runevent.Organization,
                        runevent.Repository,
                        runevent.Sender)
        }</span>)

        <span class="cov8" title="1">return isCollab, err</span>
}

// getFileFromDefaultBranch will get a file directly from the Default BaseBranch as
// configured in runinfo which is directly set in webhook by Github.
func (v *Provider) getFileFromDefaultBranch(ctx context.Context, path string, runevent *info.Event) (string, error) <span class="cov8" title="1">{
        tektonyaml, err := v.GetFileInsideRepo(ctx, runevent, path, runevent.DefaultBranch)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("cannot find %s inside the %s branch: %w", path, runevent.DefaultBranch, err)
        }</span>
        <span class="cov8" title="1">return tektonyaml, err</span>
}

// GetStringPullRequestComment return the comment if we find a regexp in one of
// the comments text of a pull request.
func (v *Provider) GetStringPullRequestComment(ctx context.Context, runevent *info.Event, reg string) ([]*github.IssueComment, error) <span class="cov8" title="1">{
        var ret []*github.IssueComment
        prNumber, err := convertPullRequestURLtoNumber(runevent.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">opt := &amp;github.IssueListCommentsOptions{
                ListOptions: github.ListOptions{PerPage: v.PaginedNumber},
        }
        for </span><span class="cov8" title="1">{
                comments, resp, err := wrapAPI(v, "list_issue_comments", func() ([]*github.IssueComment, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Issues.ListComments(ctx, runevent.Organization, runevent.Repository,
                                prNumber, opt)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, v := range comments </span><span class="cov8" title="1">{
                        if acl.MatchRegexp(reg, v.GetBody()) </span><span class="cov8" title="1">{
                                ret = append(ret, v)
                        }</span>
                }
                <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">opt.Page = resp.NextPage</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package app

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v4"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github"
        "knative.dev/pkg/logging"
)

type Install struct {
        request   *http.Request
        run       *params.Run
        repo      *v1alpha1.Repository
        ghClient  *github.Provider
        namespace string
}

func NewInstallation(req *http.Request, run *params.Run, repo *v1alpha1.Repository, gh *github.Provider, namespace string) *Install <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                req = &amp;http.Request{}
        }</span>
        <span class="cov8" title="1">return &amp;Install{
                request:   req,
                run:       run,
                repo:      repo,
                ghClient:  gh,
                namespace: namespace,
        }</span>
}

// GetAndUpdateInstallationID retrieves and updates the installation ID for the GitHub App.
// It generates a JWT token, and directly fetches the installation for the
// repository.
func (ip *Install) GetAndUpdateInstallationID(ctx context.Context) (string, string, int64, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // Generate a JWT token for authentication
        jwtToken, err := ip.GenerateJWT(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, err
        }</span>

        // Get owner and repo from the repository URL
        <span class="cov8" title="1">repoURL, err := url.Parse(ip.repo.Spec.URL)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", 0, fmt.Errorf("failed to parse repository URL: %w", err)
        }</span>
        <span class="cov8" title="1">pathParts := strings.Split(strings.Trim(repoURL.Path, "/"), "/")
        if len(pathParts) != 2 </span><span class="cov8" title="1">{
                return "", "", 0, fmt.Errorf("invalid repository URL path: %s", repoURL.Path)
        }</span>
        <span class="cov8" title="1">owner := pathParts[0]
        repoName := pathParts[1]
        if owner == "" || repoName == "" </span><span class="cov0" title="0">{
                return "", "", 0, fmt.Errorf("invalid repository URL: owner or repo name is empty")
        }</span>

        <span class="cov8" title="1">if ip.ghClient.APIURL == nil </span><span class="cov0" title="0">{
                return "", "", 0, fmt.Errorf("github client APIURL is nil")
        }</span>
        <span class="cov8" title="1">apiURL := *ip.ghClient.APIURL
        enterpriseHost := ip.request.Header.Get("X-GitHub-Enterprise-Host")
        if enterpriseHost != "" </span><span class="cov0" title="0">{
                apiURL = fmt.Sprintf("https://%s/api/v3", strings.TrimSuffix(enterpriseHost, "/"))
        }</span>

        <span class="cov8" title="1">client, _, _ := github.MakeClient(ctx, apiURL, jwtToken)
        // Directly get the installation for the repository
        installation, _, err := client.Apps.FindRepositoryInstallation(ctx, owner, repoName)
        if err != nil </span><span class="cov8" title="1">{
                // Fallback to finding organization installation if repository installation is not found
                installation, _, err = client.Apps.FindOrganizationInstallation(ctx, owner)
                if err != nil </span><span class="cov8" title="1">{
                        // Fallback to finding user installation if organization installation is not found
                        installation, _, err = client.Apps.FindUserInstallation(ctx, owner)
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", "", 0, fmt.Errorf("could not find repository, organization or user installation for %s/%s: %w", owner, repoName, err)
        }</span>

        <span class="cov8" title="1">if installation.ID == nil </span><span class="cov0" title="0">{
                return "", "", 0, fmt.Errorf("github App installation found but contained no ID. This is likely a bug")
        }</span>

        <span class="cov8" title="1">installationID := *installation.ID
        token, err := ip.ghClient.GetAppToken(ctx, ip.run.Clients.Kube, enterpriseHost, installationID, ip.namespace)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("Could not get a token for installation ID %d: %v", installationID, err)
                // Return with the installation ID even if token generation fails,
                // as some operations might only need the ID.
                return enterpriseHost, "", installationID, nil
        }</span>

        <span class="cov8" title="1">return enterpriseHost, token, installationID, nil</span>
}

// JWTClaim represents the JWT claims for the GitHub App.
type JWTClaim struct {
        Issuer int64 `json:"iss"`
        jwt.RegisteredClaims
}

// GenerateJWT generates a JWT token for the GitHub App.
// It retrieves the application ID and private key, sets the claims, and signs the token.
func (ip *Install) GenerateJWT(ctx context.Context) (string, error) <span class="cov8" title="1">{
        // TODO: move this out of here
        gh := github.New()
        gh.Run = ip.run
        applicationID, privateKey, err := gh.GetAppIDAndPrivateKey(ctx, ip.namespace, ip.run.Clients.Kube)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        // The expirationTime claim identifies the expiration time on or after which the JWT MUST NOT be accepted for processing.
        // Value cannot be longer duration.
        // See https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4
        <span class="cov8" title="1">expirationTime := time.Now().Add(5 * time.Minute)
        claims := &amp;JWTClaim{
                Issuer: applicationID,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expirationTime),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }
        token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)

        parsedPK, err := jwt.ParseRSAPrivateKeyFromPEM(privateKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("failed to parse private key: %w", err)
        }</span>

        <span class="cov8" title="1">tokenString, err := token.SignedString(parsedPK)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to sign private key: %w", err)
        }</span>
        <span class="cov8" title="1">return tokenString, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package github

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/google/go-github/v74/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "go.uber.org/zap"
)

var (
        pullRequestOpenSyncEvent = []string{"opened", "synchronize", "synchronized", "reopened", "ready_for_review"}
        pullRequestLabelEvent    = []string{"labeled"}
)

// Detect processes event and detect if it is a github event, whether to process or reject it
// returns (if is a GH event, whether to process or reject, error if any occurred).
func (v *Provider) Detect(req *http.Request, payload string, logger *zap.SugaredLogger) (bool, bool, *zap.SugaredLogger, string, error) <span class="cov8" title="1">{
        // gitea set x-github-event too, so skip it for the gitea driver
        if h := req.Header.Get("X-Gitea-Event-Type"); h != "" </span><span class="cov0" title="0">{
                return false, false, logger, "", nil
        }</span>
        <span class="cov8" title="1">isGH := false
        eventType := req.Header.Get("X-Github-Event")
        if eventType == "" </span><span class="cov8" title="1">{
                return false, false, logger, "", nil
        }</span>

        // it is a Github event
        <span class="cov8" title="1">isGH = true

        setLoggerAndProceed := func(processEvent bool, reason string, err error) (bool, bool, *zap.SugaredLogger,
                string, error,
        ) </span><span class="cov8" title="1">{
                logger = logger.With("provider", "github", "event-id", req.Header.Get("X-GitHub-Delivery"))
                return isGH, processEvent, logger, reason, err
        }</span>

        <span class="cov8" title="1">eventInt, err := github.ParseWebHook(eventType, []byte(payload))
        if err != nil </span><span class="cov8" title="1">{
                return setLoggerAndProceed(false, "", err)
        }</span>

        <span class="cov8" title="1">_ = json.Unmarshal([]byte(payload), &amp;eventInt)
        eType, errReason := v.detectTriggerTypeFromPayload(eventType, eventInt)
        if eType != "" </span><span class="cov8" title="1">{
                return setLoggerAndProceed(true, "", nil)
        }</span>

        <span class="cov8" title="1">return setLoggerAndProceed(false, errReason, nil)</span>
}

// detectTriggerTypeFromPayload will detect the event type from the payload,
// filtering out the events that are not supported.
// first arg will get the event type and the second one will get an error string explaining why it's not supported.
func (v *Provider) detectTriggerTypeFromPayload(ghEventType string, eventInt any) (triggertype.Trigger, string) <span class="cov8" title="1">{
        switch event := eventInt.(type) </span>{
        case *github.PushEvent:<span class="cov8" title="1">
                if event.GetPusher() != nil </span><span class="cov8" title="1">{
                        return triggertype.Push, ""
                }</span>
                <span class="cov0" title="0">return "", "no pusher in payload"</span>
        case *github.PullRequestEvent:<span class="cov8" title="1">
                if event.GetAction() == "closed" </span><span class="cov0" title="0">{
                        return triggertype.PullRequestClosed, ""
                }</span>

                <span class="cov8" title="1">if provider.Valid(event.GetAction(), pullRequestOpenSyncEvent) || provider.Valid(event.GetAction(), pullRequestLabelEvent) </span><span class="cov8" title="1">{
                        return triggertype.PullRequest, ""
                }</span>
                <span class="cov8" title="1">return "", fmt.Sprintf("pull_request: unsupported action \"%s\"", event.GetAction())</span>
        case *github.IssueCommentEvent:<span class="cov8" title="1">
                if event.GetAction() == "created" &amp;&amp;
                        event.GetIssue().IsPullRequest() &amp;&amp;
                        event.GetIssue().GetState() == "open" </span><span class="cov8" title="1">{
                        if provider.IsTestRetestComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                                return triggertype.Retest, ""
                        }</span>
                        <span class="cov8" title="1">if provider.IsOkToTestComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                                return triggertype.OkToTest, ""
                        }</span>
                        <span class="cov8" title="1">if provider.IsCancelComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                                return triggertype.Cancel, ""
                        }</span>
                }
                <span class="cov8" title="1">return triggertype.Comment, ""</span>
        case *github.CheckSuiteEvent:<span class="cov8" title="1">
                if event.GetAction() == "rerequested" &amp;&amp; event.GetCheckSuite() != nil </span><span class="cov8" title="1">{
                        return triggertype.CheckSuiteRerequested, ""
                }</span>
                <span class="cov0" title="0">return "", fmt.Sprintf("check_suite: unsupported action \"%s\"", event.GetAction())</span>
        case *github.CheckRunEvent:<span class="cov8" title="1">
                if event.GetAction() == "rerequested" &amp;&amp; event.GetCheckRun() != nil </span><span class="cov8" title="1">{
                        return triggertype.CheckRunRerequested, ""
                }</span>
                <span class="cov8" title="1">return "", fmt.Sprintf("check_run: unsupported action \"%s\"", event.GetAction())</span>
        case *github.CommitCommentEvent:<span class="cov8" title="1">
                if event.GetAction() == "created" </span><span class="cov8" title="1">{
                        if provider.IsTestRetestComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                                return triggertype.Retest, ""
                        }</span>
                        <span class="cov8" title="1">if provider.IsCancelComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                                return triggertype.Cancel, ""
                        }</span>
                        // Here, the `/ok-to-test` command is ignored because it is intended for pull requests.
                        // For unauthorized users, it has no relevance to pushed commits, as only authorized users
                        // are allowed to run CI on pushed commits. Therefore, the `ok-to-test` command holds no significance in this context.
                        // However, it is left to be processed by the `on-comment` annotation rather than returning an error.
                }
                <span class="cov8" title="1">return triggertype.Comment, ""</span>
        }
        <span class="cov8" title="1">return "", fmt.Sprintf("github: event \"%v\" is not supported", ghEventType)</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package github

import (
        "context"
        "encoding/base64"
        "fmt"
        "net/http"
        "net/url"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/google/go-github/v74/github"
        "github.com/jonboulle/clockwork"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "go.uber.org/zap"
        "golang.org/x/oauth2"
        "k8s.io/client-go/kubernetes"
)

const (
        apiPublicURL = "https://api.github.com/"
        // TODO: makes this configurable for GHE in the ConfigMap.
        // on our GHE instance, it looks like this :
        // https://raw.ghe.openshiftpipelines.com/pac/chmouel-test/main/README.md
        // we can perhaps do some autodetection with event.Provider.GHEURL and adding
        // a raw into it.
        publicRawURLHost = "raw.githubusercontent.com"

        defaultPaginedNumber = 100
)

var _ provider.Interface = (*Provider)(nil)

type Provider struct {
        ghClient      *github.Client
        Logger        *zap.SugaredLogger
        Run           *params.Run
        pacInfo       *info.PacOpts
        Token, APIURL *string
        ApplicationID *int64
        providerName  string
        provenance    string
        RepositoryIDs []int64
        repo          *v1alpha1.Repository
        eventEmitter  *events.EventEmitter
        PaginedNumber int
        userType      string // The type of user i.e bot or not
        skippedRun
        triggerEvent string
}

type skippedRun struct {
        mutex      *sync.Mutex
        checkRunID int64
}

func New() *Provider <span class="cov8" title="1">{
        return &amp;Provider{
                APIURL:        github.Ptr(keys.PublicGithubAPIURL),
                PaginedNumber: defaultPaginedNumber,
                skippedRun: skippedRun{
                        mutex: &amp;sync.Mutex{},
                },
        }
}</span>

func (v *Provider) Client() *github.Client <span class="cov8" title="1">{
        return v.ghClient
}</span>

func (v *Provider) SetGithubClient(client *github.Client) <span class="cov8" title="1">{
        v.ghClient = client
}</span>

func (v *Provider) SetPacInfo(pacInfo *info.PacOpts) <span class="cov8" title="1">{
        v.pacInfo = pacInfo
}</span>

// detectGHERawURL Detect if we have a raw URL in GHE.
func detectGHERawURL(event *info.Event, taskHost string) bool <span class="cov8" title="1">{
        gheURL, err := url.Parse(event.GHEURL)
        if err != nil </span><span class="cov0" title="0">{
                // should not happen but may as well make sure
                return false
        }</span>
        <span class="cov8" title="1">return taskHost == fmt.Sprintf("raw.%s", gheURL.Host)</span>
}

// splitGithubURL Take a Github url and split it with org/repo path ref, supports rawURL.
func splitGithubURL(event *info.Event, uri string) (string, string, string, string, error) <span class="cov8" title="1">{
        pURL, err := url.Parse(uri)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("URL %s is not a valid provider URL: %w", uri, err)
        }</span>
        <span class="cov8" title="1">path := pURL.Path
        if pURL.RawPath != "" </span><span class="cov8" title="1">{
                path = pURL.RawPath
        }</span>
        <span class="cov8" title="1">split := strings.Split(path, "/")
        if len(split) &lt;= 3 </span><span class="cov8" title="1">{
                return "", "", "", "", fmt.Errorf("URL %s does not seem to be a proper provider url: %w", uri, err)
        }</span>
        <span class="cov8" title="1">var spOrg, spRepo, spRef, spPath string
        switch </span>{
        case (pURL.Host == publicRawURLHost || detectGHERawURL(event, pURL.Host)) &amp;&amp; len(split) &gt;= 5:<span class="cov8" title="1">
                spOrg = split[1]
                spRepo = split[2]
                spRef = split[3]
                spPath = strings.Join(split[4:], "/")</span>
        case split[3] == "blob" &amp;&amp; len(split) &gt;= 5:<span class="cov8" title="1">
                spOrg = split[1]
                spRepo = split[2]
                spRef = split[4]
                spPath = strings.Join(split[5:], "/")</span>
        default:<span class="cov8" title="1">
                return "", "", "", "", fmt.Errorf("cannot recognize task as a GitHub URL to fetch: %s", uri)</span>
        }
        // url decode the org, repo, ref and path
        <span class="cov8" title="1">if spRef, err = url.QueryUnescape(spRef); err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("cannot decode ref: %w", err)
        }</span>
        <span class="cov8" title="1">if spPath, err = url.QueryUnescape(spPath); err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("cannot decode path: %w", err)
        }</span>
        <span class="cov8" title="1">if spOrg, err = url.QueryUnescape(spOrg); err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("cannot decode org: %w", err)
        }</span>
        <span class="cov8" title="1">if spRepo, err = url.QueryUnescape(spRepo); err != nil </span><span class="cov0" title="0">{
                return "", "", "", "", fmt.Errorf("cannot decode repo: %w", err)
        }</span>
        <span class="cov8" title="1">return spOrg, spRepo, spPath, spRef, nil</span>
}

func (v *Provider) GetTaskURI(ctx context.Context, event *info.Event, uri string) (bool, string, error) <span class="cov8" title="1">{
        if ret := provider.CompareHostOfURLS(uri, event.URL); !ret </span><span class="cov8" title="1">{
                return false, "", nil
        }</span>

        <span class="cov8" title="1">spOrg, spRepo, spPath, spRef, err := splitGithubURL(event, uri)
        if err != nil </span><span class="cov8" title="1">{
                return false, "", err
        }</span>
        <span class="cov8" title="1">nEvent := info.NewEvent()
        nEvent.Organization = spOrg
        nEvent.Repository = spRepo
        nEvent.BaseBranch = spRef
        ret, err := v.GetFileInsideRepo(ctx, nEvent, spPath, spRef)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>
        <span class="cov8" title="1">return true, ret, nil</span>
}

func (v *Provider) InitAppClient(ctx context.Context, kube kubernetes.Interface, event *info.Event) error <span class="cov0" title="0">{
        var err error
        // TODO: move this out of here when we move al config inside context
        ns := info.GetNS(ctx)
        event.Provider.Token, err = v.GetAppToken(ctx, kube, event.GHEURL, event.InstallationID, ns)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (v *Provider) SetLogger(logger *zap.SugaredLogger) <span class="cov0" title="0">{
        v.Logger = logger
}</span>

func (v *Provider) Validate(_ context.Context, _ *params.Run, event *info.Event) error <span class="cov8" title="1">{
        signature := event.Request.Header.Get(github.SHA256SignatureHeader)

        if signature == "" </span><span class="cov8" title="1">{
                signature = event.Request.Header.Get(github.SHA1SignatureHeader)
        }</span>
        <span class="cov8" title="1">if signature == "" || signature == "sha1=" </span><span class="cov0" title="0">{
                // if no signature is present then don't validate, because user hasn't set one
                return fmt.Errorf("no signature has been detected, for security reason we are not allowing webhooks that has no secret")
        }</span>
        <span class="cov8" title="1">if event.Provider.WebhookSecret == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no webhook secret has been set, in repository CR or secret")
        }</span>
        <span class="cov8" title="1">return github.ValidateSignature(signature, event.Request.Payload, []byte(event.Provider.WebhookSecret))</span>
}

func (v *Provider) GetConfig() *info.ProviderConfig <span class="cov0" title="0">{
        return &amp;info.ProviderConfig{
                TaskStatusTMPL: taskStatusTemplate,
                APIURL:         apiPublicURL,
                Name:           v.providerName,
        }
}</span>

func MakeClient(ctx context.Context, apiURL, token string) (*github.Client, string, *string) <span class="cov8" title="1">{
        var client *github.Client
        ts := oauth2.StaticTokenSource(
                &amp;oauth2.Token{AccessToken: token},
        )

        tc := oauth2.NewClient(ctx, ts)
        if apiURL != "" </span><span class="cov8" title="1">{
                if !strings.HasPrefix(apiURL, "https") &amp;&amp; !strings.HasPrefix(apiURL, "http") </span><span class="cov8" title="1">{
                        apiURL = "https://" + apiURL
                }</span>
        }

        <span class="cov8" title="1">providerName := "github"
        if apiURL != "" &amp;&amp; apiURL != apiPublicURL </span><span class="cov8" title="1">{
                providerName = "github-enterprise"
                uploadURL := apiURL + "/api/uploads"
                client, _ = github.NewClient(tc).WithEnterpriseURLs(apiURL, uploadURL)
        }</span> else<span class="cov8" title="1"> {
                client = github.NewClient(tc)
                apiURL = client.BaseURL.String()
        }</span>

        <span class="cov8" title="1">return client, providerName, github.Ptr(apiURL)</span>
}

func parseTS(headerTS string) (time.Time, error) <span class="cov8" title="1">{
        ts := time.Time{}
        // Normal UTC: 2023-01-31 23:00:00 UTC
        if t, err := time.Parse("2006-01-02 15:04:05 MST", headerTS); err == nil </span><span class="cov8" title="1">{
                ts = t
        }</span>

        // With TZ(???), ie: a token from Christoph 2023-04-26 23:23:26 +2000
        <span class="cov8" title="1">if t, err := time.Parse("2006-01-02 15:04:05 -0700", headerTS); err == nil </span><span class="cov8" title="1">{
                ts = t
        }</span>
        <span class="cov8" title="1">if ts.Year() == 1 </span><span class="cov8" title="1">{
                return ts, fmt.Errorf("cannot parse token expiration date: %s", headerTS)
        }</span>

        <span class="cov8" title="1">return ts, nil</span>
}

// checkWebhookSecretValidity check the webhook secret is valid and not
// ratelimited. we try to check first the header is set (unlimited life token  would
// not have an expiration) we would anyway get a 401 error when trying to use it
// but this gives a nice hint to the user into their namespace event of where
// the issue was.
func (v *Provider) checkWebhookSecretValidity(ctx context.Context, cw clockwork.Clock) error <span class="cov8" title="1">{
        rl, resp, err := wrapAPI(v, "check_rate_limit", func() (*github.RateLimits, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().RateLimit.Get(ctx)
        }</span>)
        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                v.Logger.Info("skipping checking if token has expired, rate_limit api is not enabled on token")
                return nil
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error making request to the GitHub API checking rate limit: %w", err)
        }</span>

        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.Header.Get("GitHub-Authentication-Token-Expiration") != "" </span><span class="cov8" title="1">{
                ts, err := parseTS(resp.Header.Get("GitHub-Authentication-Token-Expiration"))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error parsing token expiration date: %w", err)
                }</span>

                <span class="cov8" title="1">if cw.Now().After(ts) </span><span class="cov8" title="1">{
                        errMsg := fmt.Sprintf("token has expired at %s", resp.TokenExpiration.Format(time.RFC1123))
                        return fmt.Errorf("%s", errMsg)
                }</span>
        }

        // Guard against nil rl or rl.SCIM which could lead to a panic.
        <span class="cov8" title="1">if rl == nil || rl.SCIM == nil </span><span class="cov8" title="1">{
                v.Logger.Info("skipping token expiration check, SCIM rate limit API is not available for this token")
                return nil
        }</span>

        <span class="cov8" title="1">if rl.SCIM.Remaining == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("api rate limit exceeded. Access will be restored at %s", rl.SCIM.Reset.Format(time.RFC1123))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (v *Provider) SetClient(ctx context.Context, run *params.Run, event *info.Event, repo *v1alpha1.Repository, eventsEmitter *events.EventEmitter) error <span class="cov8" title="1">{
        client, providerName, apiURL := MakeClient(ctx, event.Provider.URL, event.Provider.Token)
        v.providerName = providerName
        v.Run = run
        v.repo = repo
        v.eventEmitter = eventsEmitter
        v.triggerEvent = event.EventType

        // check that the Client is not already set, so we don't override our fakeclient
        // from unittesting.
        if v.ghClient == nil </span><span class="cov8" title="1">{
                v.ghClient = client
        }</span>
        <span class="cov8" title="1">if v.ghClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no github client has been initialized")
        }</span>

        // Added log for security audit purposes to log client access when a token is used
        <span class="cov8" title="1">integration := "github-webhook"
        if event.InstallationID != 0 </span><span class="cov8" title="1">{
                integration = "github-app"
        }</span>
        <span class="cov8" title="1">run.Clients.Log.Infof(integration+": initialized OAuth2 client for providerName=%s providerURL=%s", v.providerName, event.Provider.URL)

        v.APIURL = apiURL

        if event.Provider.WebhookSecretFromRepo </span><span class="cov0" title="0">{
                // check the webhook secret is valid and not ratelimited
                if err := v.checkWebhookSecretValidity(ctx, clockwork.NewRealClock()); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("the webhook secret is not valid: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetTektonDir Get all yaml files in tekton directory return as a single concated file.
func (v *Provider) GetTektonDir(ctx context.Context, runevent *info.Event, path, provenance string) (string, error) <span class="cov8" title="1">{
        tektonDirSha := ""

        v.provenance = provenance
        // default set provenance from the SHA
        revision := runevent.SHA
        if provenance == "default_branch" </span><span class="cov8" title="1">{
                revision = runevent.DefaultBranch
                v.Logger.Infof("Using PipelineRun definition from default_branch: %s", runevent.DefaultBranch)
        }</span> else<span class="cov8" title="1"> {
                prInfo := ""
                if runevent.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                        prInfo = fmt.Sprintf("%s/%s#%d", runevent.Organization, runevent.Repository, runevent.PullRequestNumber)
                }</span>
                <span class="cov8" title="1">v.Logger.Infof("Using PipelineRun definition from source %s %s on commit SHA %s", runevent.TriggerTarget.String(), prInfo, runevent.SHA)</span>
        }

        <span class="cov8" title="1">rootobjects, _, err := wrapAPI(v, "get_root_tree", func() (*github.Tree, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Git.GetTree(ctx, runevent.Organization, runevent.Repository, revision, false)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">for _, object := range rootobjects.Entries </span><span class="cov8" title="1">{
                if object.GetPath() == path </span><span class="cov8" title="1">{
                        if object.GetType() != "tree" </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("%s has been found but is not a directory", path)
                        }</span>
                        <span class="cov8" title="1">tektonDirSha = object.GetSHA()</span>
                }
        }

        // If we didn't find a .tekton directory then just silently ignore the error.
        <span class="cov8" title="1">if tektonDirSha == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        // Get all files in the .tekton directory recursively
        // there is a limit on this recursive calls to 500 entries, as documented here:
        // https://docs.github.com/en/rest/reference/git#get-a-tree
        // so we may need to address it in the future.
        <span class="cov8" title="1">tektonDirObjects, _, err := wrapAPI(v, "get_tekton_tree", func() (*github.Tree, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Git.GetTree(ctx, runevent.Organization, runevent.Repository, tektonDirSha,
                        true)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return v.concatAllYamlFiles(ctx, tektonDirObjects.Entries, runevent)</span>
}

// GetCommitInfo get info (url and title) on a commit in runevent, this needs to
// be run after sewebhook while we already matched a token.
func (v *Provider) GetCommitInfo(ctx context.Context, runevent *info.Event) error <span class="cov8" title="1">{
        if v.ghClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no github client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>

        // if we don't have a sha we may have a branch (ie: incoming webhook) then
        // use the branch as sha since github supports it
        <span class="cov8" title="1">var commit *github.Commit
        sha := runevent.SHA
        if runevent.SHA == "" &amp;&amp; runevent.HeadBranch != "" </span><span class="cov0" title="0">{
                branchinfo, _, err := wrapAPI(v, "get_branch_info", func() (*github.Branch, *github.Response, error) </span><span class="cov0" title="0">{
                        return v.Client().Repositories.GetBranch(ctx, runevent.Organization, runevent.Repository, runevent.HeadBranch, 1)
                }</span>)
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">sha = branchinfo.Commit.GetSHA()</span>
        }
        <span class="cov8" title="1">var err error
        commit, _, err = wrapAPI(v, "get_commit", func() (*github.Commit, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Git.GetCommit(ctx, runevent.Organization, runevent.Repository, sha)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">runevent.SHAURL = commit.GetHTMLURL()
        runevent.SHATitle = strings.Split(commit.GetMessage(), "\n\n")[0]
        runevent.SHA = commit.GetSHA()

        return nil</span>
}

// GetFileInsideRepo Get a file via Github API using the runinfo information, we
// branch is true, the user the branch as ref instead of the SHA
// TODO: merge GetFileInsideRepo amd GetTektonDir.
func (v *Provider) GetFileInsideRepo(ctx context.Context, runevent *info.Event, path, target string) (string, error) <span class="cov8" title="1">{
        ref := runevent.SHA
        if target != "" </span><span class="cov8" title="1">{
                ref = runevent.BaseBranch
        }</span> else<span class="cov8" title="1"> if v.provenance == "default_branch" </span><span class="cov0" title="0">{
                ref = runevent.DefaultBranch
        }</span>

        <span class="cov8" title="1">fp, objects, _, err := wrapAPIGetContents(v, "get_file_contents", func() (*github.RepositoryContent, []*github.RepositoryContent, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Repositories.GetContents(ctx, runevent.Organization,
                        runevent.Repository, path, &amp;github.RepositoryContentGetOptions{Ref: ref})
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if objects != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("referenced file inside the Github Repository %s is a directory", path)
        }</span>

        <span class="cov8" title="1">getobj, err := v.getObject(ctx, fp.GetSHA(), runevent)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(getobj), nil</span>
}

// concatAllYamlFiles concat all yaml files from a directory as one big multi document yaml string.
func (v *Provider) concatAllYamlFiles(ctx context.Context, objects []*github.TreeEntry, runevent *info.Event) (string, error) <span class="cov8" title="1">{
        var allTemplates string

        for _, value := range objects </span><span class="cov8" title="1">{
                if strings.HasSuffix(value.GetPath(), ".yaml") ||
                        strings.HasSuffix(value.GetPath(), ".yml") </span><span class="cov8" title="1">{
                        data, err := v.getObject(ctx, value.GetSHA(), runevent)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if err := provider.ValidateYaml(data, value.GetPath()); err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if allTemplates != "" &amp;&amp; !strings.HasPrefix(string(data), "---") </span><span class="cov8" title="1">{
                                allTemplates += "---"
                        }</span>
                        <span class="cov8" title="1">allTemplates += "\n" + string(data) + "\n"</span>
                }
        }
        <span class="cov8" title="1">return allTemplates, nil</span>
}

// getPullRequest get a pull request details.
func (v *Provider) getPullRequest(ctx context.Context, runevent *info.Event) (*info.Event, error) <span class="cov8" title="1">{
        pr, _, err := wrapAPI(v, "get_pull_request", func() (*github.PullRequest, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().PullRequests.Get(ctx, runevent.Organization, runevent.Repository, runevent.PullRequestNumber)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return runevent, err
        }</span>
        // Make sure to use the Base for Default BaseBranch or there would be a potential hijack
        <span class="cov8" title="1">runevent.DefaultBranch = pr.GetBase().GetRepo().GetDefaultBranch()
        runevent.URL = pr.GetBase().GetRepo().GetHTMLURL()
        runevent.SHA = pr.GetHead().GetSHA()
        runevent.SHAURL = fmt.Sprintf("%s/commit/%s", pr.GetHTMLURL(), pr.GetHead().GetSHA())
        runevent.PullRequestTitle = pr.GetTitle()

        // TODO: check if we really need this
        if runevent.Sender == "" </span><span class="cov8" title="1">{
                runevent.Sender = pr.GetUser().GetLogin()
        }</span>
        <span class="cov8" title="1">runevent.HeadBranch = pr.GetHead().GetRef()
        runevent.BaseBranch = pr.GetBase().GetRef()
        runevent.HeadURL = pr.GetHead().GetRepo().GetHTMLURL()
        runevent.BaseURL = pr.GetBase().GetRepo().GetHTMLURL()
        if runevent.EventType == "" </span><span class="cov8" title="1">{
                runevent.EventType = triggertype.PullRequest.String()
        }</span>

        <span class="cov8" title="1">for _, label := range pr.Labels </span><span class="cov0" title="0">{
                runevent.PullRequestLabel = append(runevent.PullRequestLabel, label.GetName())
        }</span>

        <span class="cov8" title="1">v.RepositoryIDs = []int64{
                pr.GetBase().GetRepo().GetID(),
        }
        return runevent, nil</span>
}

// GetFiles get a files from pull request.
func (v *Provider) GetFiles(ctx context.Context, runevent *info.Event) (changedfiles.ChangedFiles, error) <span class="cov8" title="1">{
        if runevent.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                opt := &amp;github.ListOptions{PerPage: v.PaginedNumber}
                changedFiles := changedfiles.ChangedFiles{}
                for </span><span class="cov8" title="1">{
                        repoCommit, resp, err := wrapAPI(v, "list_pull_request_files", func() ([]*github.CommitFile, *github.Response, error) </span><span class="cov8" title="1">{
                                return v.Client().PullRequests.ListFiles(ctx, runevent.Organization, runevent.Repository, runevent.PullRequestNumber, opt)
                        }</span>)
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return changedfiles.ChangedFiles{}, err
                        }</span>
                        <span class="cov8" title="1">for j := range repoCommit </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, *repoCommit[j].Filename)
                                if *repoCommit[j].Status == "added" </span><span class="cov8" title="1">{
                                        changedFiles.Added = append(changedFiles.Added, *repoCommit[j].Filename)
                                }</span>
                                <span class="cov8" title="1">if *repoCommit[j].Status == "removed" </span><span class="cov8" title="1">{
                                        changedFiles.Deleted = append(changedFiles.Deleted, *repoCommit[j].Filename)
                                }</span>
                                <span class="cov8" title="1">if *repoCommit[j].Status == "modified" </span><span class="cov8" title="1">{
                                        changedFiles.Modified = append(changedFiles.Modified, *repoCommit[j].Filename)
                                }</span>
                                <span class="cov8" title="1">if *repoCommit[j].Status == "renamed" </span><span class="cov8" title="1">{
                                        changedFiles.Renamed = append(changedFiles.Renamed, *repoCommit[j].Filename)
                                }</span>
                        }
                        <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">opt.Page = resp.NextPage</span>
                }
                <span class="cov8" title="1">return changedFiles, nil</span>
        }

        <span class="cov8" title="1">if runevent.TriggerTarget == "push" </span><span class="cov8" title="1">{
                changedFiles := changedfiles.ChangedFiles{}
                rC, _, err := wrapAPI(v, "get_commit_files", func() (*github.RepositoryCommit, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Repositories.GetCommit(ctx, runevent.Organization, runevent.Repository, runevent.SHA, &amp;github.ListOptions{})
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return changedfiles.ChangedFiles{}, err
                }</span>
                <span class="cov8" title="1">for i := range rC.Files </span><span class="cov8" title="1">{
                        changedFiles.All = append(changedFiles.All, *rC.Files[i].Filename)
                        if *rC.Files[i].Status == "added" </span><span class="cov8" title="1">{
                                changedFiles.Added = append(changedFiles.Added, *rC.Files[i].Filename)
                        }</span>
                        <span class="cov8" title="1">if *rC.Files[i].Status == "removed" </span><span class="cov8" title="1">{
                                changedFiles.Deleted = append(changedFiles.Deleted, *rC.Files[i].Filename)
                        }</span>
                        <span class="cov8" title="1">if *rC.Files[i].Status == "modified" </span><span class="cov8" title="1">{
                                changedFiles.Modified = append(changedFiles.Modified, *rC.Files[i].Filename)
                        }</span>
                        <span class="cov8" title="1">if *rC.Files[i].Status == "renamed" </span><span class="cov8" title="1">{
                                changedFiles.Renamed = append(changedFiles.Renamed, *rC.Files[i].Filename)
                        }</span>
                }
                <span class="cov8" title="1">return changedFiles, nil</span>
        }
        <span class="cov0" title="0">return changedfiles.ChangedFiles{}, nil</span>
}

// getObject Get an object from a repository.
func (v *Provider) getObject(ctx context.Context, sha string, runevent *info.Event) ([]byte, error) <span class="cov8" title="1">{
        blob, _, err := wrapAPI(v, "get_blob", func() (*github.Blob, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Git.GetBlob(ctx, runevent.Organization, runevent.Repository, sha)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(blob.GetContent())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return decoded, err</span>
}

// ListRepos lists all the repos for a particular token.
func ListRepos(ctx context.Context, v *Provider) ([]string, error) <span class="cov8" title="1">{
        if v.ghClient == nil </span><span class="cov0" title="0">{
                return []string{}, fmt.Errorf("no github client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>

        <span class="cov8" title="1">opt := &amp;github.ListOptions{PerPage: v.PaginedNumber}
        repoURLs := []string{}
        for </span><span class="cov8" title="1">{
                repoList, resp, err := wrapAPI(v, "list_app_repos", func() (*github.ListRepositories, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Apps.ListRepos(ctx, opt)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
                <span class="cov8" title="1">for i := range repoList.Repositories </span><span class="cov8" title="1">{
                        repoURLs = append(repoURLs, *repoList.Repositories[i].HTMLURL)
                }</span>
                <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">opt.Page = resp.NextPage</span>
        }
        <span class="cov8" title="1">return repoURLs, nil</span>
}

func (v *Provider) CreateToken(ctx context.Context, repository []string, event *info.Event) (string, error) <span class="cov8" title="1">{
        for _, r := range repository </span><span class="cov8" title="1">{
                split := strings.Split(r, "/")
                infoData, _, err := wrapAPI(v, "get_repository", func() (*github.Repository, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Repositories.Get(ctx, split[0], split[1])
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        v.Logger.Warn("we have an invalid repository: `%s` or no access to it: %v", r, err)
                        continue</span>
                }
                <span class="cov8" title="1">v.RepositoryIDs = uniqueRepositoryID(v.RepositoryIDs, infoData.GetID())</span>
        }
        <span class="cov8" title="1">ns := info.GetNS(ctx)
        token, err := v.GetAppToken(ctx, v.Run.Clients.Kube, event.Provider.URL, event.InstallationID, ns)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return token, nil</span>
}

func uniqueRepositoryID(repoIDs []int64, id int64) []int64 <span class="cov8" title="1">{
        r := repoIDs
        m := make(map[int64]bool)
        for _, val := range repoIDs </span><span class="cov8" title="1">{
                if _, ok := m[val]; !ok </span><span class="cov8" title="1">{
                        m[val] = true
                }</span>
        }
        <span class="cov8" title="1">if _, ok := m[id]; !ok </span><span class="cov8" title="1">{
                r = append(r, id)
        }</span>
        <span class="cov8" title="1">return r</span>
}

// isHeadCommitOfBranch checks whether provided branch is valid or not and SHA is HEAD commit of the branch.
func (v *Provider) isHeadCommitOfBranch(ctx context.Context, runevent *info.Event, branchName string) error <span class="cov8" title="1">{
        if v.ghClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no github client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>

        <span class="cov8" title="1">branchInfo, _, err := wrapAPI(v, "get_branch", func() (*github.Branch, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Repositories.GetBranch(ctx, runevent.Organization, runevent.Repository, branchName, 1)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if branchInfo.Commit.GetSHA() == runevent.SHA </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("provided SHA %s is not the HEAD commit of the branch %s", runevent.SHA, branchName)</span>
}

func (v *Provider) GetTemplate(commentType provider.CommentType) string <span class="cov0" title="0">{
        return provider.GetHTMLTemplate(commentType)
}</span>

// CreateComment creates a comment on a Pull Request.
func (v *Provider) CreateComment(ctx context.Context, event *info.Event, commit, updateMarker string) error <span class="cov8" title="1">{
        if v.ghClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no github client has been initialized")
        }</span>

        <span class="cov8" title="1">if event.PullRequestNumber == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("create comment only works on pull requests")
        }</span>

        // List last page of the comments of the PR
        <span class="cov8" title="1">if updateMarker != "" </span><span class="cov8" title="1">{
                comments, _, err := wrapAPI(v, "list_comments", func() ([]*github.IssueComment, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Issues.ListComments(ctx, event.Organization, event.Repository, event.PullRequestNumber, &amp;github.IssueListCommentsOptions{
                                ListOptions: github.ListOptions{
                                        Page:    1,
                                        PerPage: 100,
                                },
                        })
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">re := regexp.MustCompile(regexp.QuoteMeta(updateMarker))
                for _, comment := range comments </span><span class="cov8" title="1">{
                        if re.MatchString(comment.GetBody()) </span><span class="cov8" title="1">{
                                if _, _, err := wrapAPI(v, "edit_comment", func() (*github.IssueComment, *github.Response, error) </span><span class="cov8" title="1">{
                                        return v.Client().Issues.EditComment(ctx, event.Organization, event.Repository, comment.GetID(), &amp;github.IssueComment{
                                                Body: &amp;commit,
                                        })
                                }</span>); err != nil <span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }
                }
        }

        <span class="cov8" title="1">_, _, err := wrapAPI(v, "create_comment", func() (*github.IssueComment, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Issues.CreateComment(ctx, event.Organization, event.Repository, event.PullRequestNumber, &amp;github.IssueComment{
                        Body: &amp;commit,
                })
        }</span>)
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package github

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "os"
        "path"
        "strconv"
        "strings"

        ghinstallation "github.com/bradleyfalzon/ghinstallation/v2"
        ogithub "github.com/google/go-github/v72/github"
        "github.com/google/go-github/v74/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

// GetAppIDAndPrivateKey retrieves the GitHub application ID and private key from a secret in the specified namespace.
// It takes a context, namespace, and Kubernetes client as input parameters.
// It returns the application ID (int64), private key ([]byte), and an error if any.
func (v *Provider) GetAppIDAndPrivateKey(ctx context.Context, ns string, kube kubernetes.Interface) (int64, []byte, error) <span class="cov8" title="1">{
        paramsinfo := &amp;v.Run.Info
        secret, err := kube.CoreV1().Secrets(ns).Get(ctx, paramsinfo.Controller.Secret, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return 0, []byte{}, fmt.Errorf("could not get the secret %s in ns %s: %w", paramsinfo.Controller.Secret, ns, err)
        }</span>

        <span class="cov8" title="1">appID := secret.Data[keys.GithubApplicationID]
        applicationID, err := strconv.ParseInt(strings.TrimSpace(string(appID)), 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0, []byte{}, fmt.Errorf("could not parse the github application_id number from secret: %w", err)
        }</span>

        <span class="cov8" title="1">privateKey := secret.Data[keys.GithubPrivateKey]
        return applicationID, privateKey, nil</span>
}

func (v *Provider) GetAppToken(ctx context.Context, kube kubernetes.Interface, gheURL string, installationID int64, ns string) (string, error) <span class="cov8" title="1">{
        applicationID, privateKey, err := v.GetAppIDAndPrivateKey(ctx, ns, kube)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">v.ApplicationID = &amp;applicationID
        tr := http.DefaultTransport

        itr, err := ghinstallation.New(tr, applicationID, installationID, privateKey)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">itr.InstallationTokenOptions = &amp;ogithub.InstallationTokenOptions{
                RepositoryIDs: v.RepositoryIDs,
        }

        // This is a hack when we have auth and api disassociated like in our
        // unittests since we are using a custom http server with httptest
        reqTokenURL := os.Getenv("PAC_GIT_PROVIDER_TOKEN_APIURL")
        if reqTokenURL != "" </span><span class="cov8" title="1">{
                itr.BaseURL = reqTokenURL
                v.APIURL = &amp;reqTokenURL
                gheURL = strings.TrimSuffix(reqTokenURL, "/api/v3")
        }</span>

        <span class="cov8" title="1">if gheURL != "" </span><span class="cov8" title="1">{
                if !strings.HasPrefix(gheURL, "https://") &amp;&amp; !strings.HasPrefix(gheURL, "http://") </span><span class="cov0" title="0">{
                        gheURL = "https://" + gheURL
                }</span>
                <span class="cov8" title="1">uploadURL := gheURL + "/api/uploads"
                v.ghClient, _ = github.NewClient(&amp;http.Client{Transport: itr}).WithEnterpriseURLs(gheURL, uploadURL)
                itr.BaseURL = strings.TrimSuffix(v.Client().BaseURL.String(), "/")</span>
        } else<span class="cov8" title="1"> {
                v.ghClient = github.NewClient(&amp;http.Client{Transport: itr})
        }</span>

        // Get a token ASAP because we need it for setting private repos
        <span class="cov8" title="1">token, err := itr.Token(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">v.Token = github.Ptr(token)

        return token, err</span>
}

func (v *Provider) parseEventType(request *http.Request, event *info.Event) error <span class="cov8" title="1">{
        event.EventType = request.Header.Get("X-GitHub-Event")
        if event.EventType == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find event type in request header")
        }</span>

        <span class="cov8" title="1">event.Provider.URL = request.Header.Get("X-GitHub-Enterprise-Host")

        if event.EventType == "push" </span><span class="cov8" title="1">{
                event.TriggerTarget = triggertype.Push
        }</span> else<span class="cov8" title="1"> {
                event.TriggerTarget = triggertype.PullRequest
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type Payload struct {
        Installation struct {
                ID *int64 `json:"id"`
        } `json:"installation"`
}

func getInstallationIDFromPayload(payload string) (int64, error) <span class="cov8" title="1">{
        var data Payload
        err := json.Unmarshal([]byte(payload), &amp;data)
        if err != nil </span><span class="cov8" title="1">{
                return -1, err
        }</span>
        <span class="cov8" title="1">if data.Installation.ID != nil </span><span class="cov8" title="1">{
                return *data.Installation.ID, nil
        }</span>
        <span class="cov8" title="1">return -1, nil</span>
}

// ParsePayload will parse the payload and return the event
// it generate the github app token targeting the installation id
// this pieces of code is a bit messy because we need first getting a token to
// before parsing the payload.
//
// We need to get the token at first because in some case when coming from pull request
// comment (or recheck from the UI) we will use that token to get
// information about the PR that is not part of the payload.
//
// We then regenerate a second time the token scoped to the repo where the
// payload come from so we can avoid the scenario where an admin install the
// app on a github org which has a mixed of private and public repos and some of
// the public users should not have access to the private repos.
//
// Another thing: The payload is protected by the webhook signature so it cannot be tempered but even tho if it's
// tempered with and somehow a malicious user found the token and set their own github endpoint to hijack and
// exfiltrate the token, it would fail since the jwt token generation will fail, so we are safe here.
// a bit too far fetched but i don't see any way we can exploit this.
func (v *Provider) ParsePayload(ctx context.Context, run *params.Run, request *http.Request, payload string) (*info.Event, error) <span class="cov8" title="1">{
        // ParsePayload is really happening before SetClient so let's set this at first here.
        // Only apply for GitHub provider since we do fancy token creation at payload parsing
        v.Run = run
        event := info.NewEvent()
        systemNS := info.GetNS(ctx)
        if err := v.parseEventType(request, event); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">installationIDFrompayload, err := getInstallationIDFromPayload(payload)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if installationIDFrompayload != -1 </span><span class="cov8" title="1">{
                var err error
                // TODO: move this out of here when we move al config inside context
                if event.Provider.Token, err = v.GetAppToken(ctx, run.Clients.Kube, event.Provider.URL, installationIDFrompayload, systemNS); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">eventInt, err := github.ParseWebHook(event.EventType, []byte(payload))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // should not get invalid json since we already check it in github.ParseWebHook
        <span class="cov8" title="1">_ = json.Unmarshal([]byte(payload), &amp;eventInt)

        processedEvent, err := v.processEvent(ctx, event, eventInt)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">processedEvent.Event = eventInt
        processedEvent.InstallationID = installationIDFrompayload
        processedEvent.GHEURL = event.Provider.URL
        processedEvent.Provider.URL = event.Provider.URL

        // regenerate token scoped to the repo IDs
        if v.pacInfo.SecretGHAppRepoScoped &amp;&amp; installationIDFrompayload != -1 &amp;&amp; len(v.RepositoryIDs) &gt; 0 </span><span class="cov8" title="1">{
                repoLists := []string{}
                if v.pacInfo.SecretGhAppTokenScopedExtraRepos != "" </span><span class="cov8" title="1">{
                        // this is going to show up a lot in the logs but i guess that
                        // would make people fix the value instead of being lost into
                        // the top of the logs at controller start.
                        for _, configValue := range strings.Split(v.pacInfo.SecretGhAppTokenScopedExtraRepos, ",") </span><span class="cov8" title="1">{
                                configValueS := strings.TrimSpace(configValue)
                                if configValueS == "" </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">repoLists = append(repoLists, configValueS)</span>
                        }
                        <span class="cov8" title="1">v.Logger.Infof("Github token scope extended to %v keeping SecretGHAppRepoScoped to true", repoLists)</span>
                }
                <span class="cov8" title="1">token, err := v.CreateToken(ctx, repoLists, processedEvent)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">processedEvent.Provider.Token = token</span>
        }

        <span class="cov8" title="1">return processedEvent, nil</span>
}

// getPullRequestsWithCommit lists the all pull requests associated with given commit.
func (v *Provider) getPullRequestsWithCommit(ctx context.Context, sha, org, repo string) ([]*github.PullRequest, error) <span class="cov8" title="1">{
        if v.ghClient == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("github client is not initialized")
        }</span>

        // Validate input parameters
        <span class="cov8" title="1">if sha == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("sha cannot be empty")
        }</span>
        <span class="cov8" title="1">if org == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("organization cannot be empty")
        }</span>
        <span class="cov8" title="1">if repo == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("repository cannot be empty")
        }</span>

        <span class="cov8" title="1">opts := &amp;github.ListOptions{
                PerPage: 100, // GitHub's maximum per page
        }

        pullRequests := []*github.PullRequest{}

        for </span><span class="cov8" title="1">{
                // Use the "List pull requests associated with a commit" API to check if the commit is part of any open PR
                prs, resp, err := wrapAPI(v, "list_pull_requests_with_commit", func() ([]*github.PullRequest, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().PullRequests.ListPullRequestsWithCommit(ctx, org, repo, sha, opts)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        // Log the error for debugging purposes
                        v.Logger.Debugf("Failed to list pull requests for commit %s in %s/%s: %v", sha, org, repo, err)
                        return nil, fmt.Errorf("failed to list pull requests for commit %s: %w", sha, err)
                }</span>

                <span class="cov8" title="1">pullRequests = append(pullRequests, prs...)

                // Check if there are more pages
                if resp.NextPage == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">opts.Page = resp.NextPage</span>
        }

        <span class="cov8" title="1">return pullRequests, nil</span>
}

// isCommitPartOfPullRequest checks if the commit from a push event is part of an open pull request
// If it is, it returns true and the PR number.
func (v *Provider) isCommitPartOfPullRequest(sha, org, repo string, prs []*github.PullRequest) (bool, int) <span class="cov8" title="1">{
        // Check if any of the returned PRs are open
        for _, pr := range prs </span><span class="cov8" title="1">{
                if pr.GetState() == "open" </span><span class="cov8" title="1">{
                        v.Logger.Debugf("Commit %s is part of open PR #%d in %s/%s", sha, pr.GetNumber(), org, repo)
                        return true, pr.GetNumber()
                }</span>
        }

        <span class="cov8" title="1">v.Logger.Debugf("Commit %s is not part of any open pull request in %s/%s", sha, org, repo)
        return false, 0</span>
}

func (v *Provider) processEvent(ctx context.Context, event *info.Event, eventInt any) (*info.Event, error) <span class="cov8" title="1">{
        var processedEvent *info.Event
        var err error

        processedEvent = info.NewEvent()

        switch gitEvent := eventInt.(type) </span>{
        case *github.CheckRunEvent:<span class="cov8" title="1">
                if v.ghClient == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("check run rerequest is only supported with github apps integration")
                }</span>

                <span class="cov8" title="1">if *gitEvent.Action != "rerequested" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("only issue recheck is supported in checkrunevent")
                }</span>
                <span class="cov8" title="1">return v.handleReRequestEvent(ctx, gitEvent)</span>
        case *github.CheckSuiteEvent:<span class="cov8" title="1">
                if v.ghClient == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("check suite rerequest is only supported with github apps integration")
                }</span>

                <span class="cov8" title="1">if *gitEvent.Action != "rerequested" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("only issue recheck is supported in checkrunevent")
                }</span>
                <span class="cov8" title="1">return v.handleCheckSuites(ctx, gitEvent)</span>
        case *github.IssueCommentEvent:<span class="cov8" title="1">
                if v.ghClient == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("no github client has been initialized, " +
                                "exiting... (hint: did you forget setting a secret on your repo?)")
                }</span>
                <span class="cov8" title="1">if gitEvent.GetAction() != "created" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("only newly created comment is supported, received: %s", gitEvent.GetAction())
                }</span>
                <span class="cov8" title="1">processedEvent, err = v.handleIssueCommentEvent(ctx, gitEvent)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        case *github.CommitCommentEvent:<span class="cov8" title="1">
                if v.ghClient == nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("no github client has been initialized, " +
                                "exiting... (hint: did you forget setting a secret on your repo?)")
                }</span>
                <span class="cov8" title="1">processedEvent, err = v.handleCommitCommentEvent(ctx, gitEvent)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        case *github.PushEvent:<span class="cov8" title="1">
                if gitEvent.GetRepo() == nil </span><span class="cov8" title="1">{
                        return nil, errors.New("error parsing payload the repository should not be nil")
                }</span>

                // When a branch is deleted via repository UI, it triggers a push event.
                // However, Pipelines as Code does not support handling branch delete events,
                // so we return an error here to indicate this unsupported operation.
                <span class="cov8" title="1">if gitEvent.After != nil </span><span class="cov8" title="1">{
                        if provider.IsZeroSHA(*gitEvent.After) </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("branch %s has been deleted, exiting", gitEvent.GetRef())
                        }</span>
                }

                // Check if this push commit is part of an open pull request
                <span class="cov8" title="1">sha := gitEvent.GetHeadCommit().GetID()
                if sha == "" </span><span class="cov0" title="0">{
                        sha = gitEvent.GetBefore()
                }</span>
                <span class="cov8" title="1">org := gitEvent.GetRepo().GetOwner().GetLogin()
                repoName := gitEvent.GetRepo().GetName()

                // First get all the pull requests associated with this commit so that we can reuse the output to check
                // whether the commit is included in any PR or not, and if this push is generated on PR merge event, we can
                // assign PR number to `pull_request_number` variable.
                prs, err := v.getPullRequestsWithCommit(ctx, sha, org, repoName)
                if err != nil </span><span class="cov8" title="1">{
                        v.Logger.Warnf("Error getting pull requests associated with the commit in this push event: %v", err)
                }</span>

                // Only check if the flag is enabled and there are pull requests associated with this commit.
                <span class="cov8" title="1">if v.pacInfo.SkipPushEventForPRCommits &amp;&amp; len(prs) &gt; 0 </span><span class="cov8" title="1">{
                        isPartOfPR, prNumber := v.isCommitPartOfPullRequest(sha, org, repoName, prs)

                        // If the commit is part of a PR, skip processing the push event
                        if isPartOfPR </span><span class="cov8" title="1">{
                                v.Logger.Infof("Skipping push event for commit %s as it belongs to pull request #%d", sha, prNumber)
                                return nil, fmt.Errorf("commit %s is part of pull request #%d, skipping push event", sha, prNumber)
                        }</span>
                }

                // if there are pull requests associated with this commit, first pull request number will be used
                // for `pull_request_number` dynamic variable.
                <span class="cov8" title="1">if len(prs) &gt; 0 </span><span class="cov0" title="0">{
                        processedEvent.PullRequestNumber = *prs[0].Number
                }</span>

                <span class="cov8" title="1">processedEvent.Organization = gitEvent.GetRepo().GetOwner().GetLogin()
                processedEvent.Repository = gitEvent.GetRepo().GetName()
                processedEvent.DefaultBranch = gitEvent.GetRepo().GetDefaultBranch()
                processedEvent.URL = gitEvent.GetRepo().GetHTMLURL()
                v.RepositoryIDs = []int64{gitEvent.GetRepo().GetID()}
                processedEvent.SHA = sha
                processedEvent.SHAURL = gitEvent.GetHeadCommit().GetURL()
                processedEvent.SHATitle = gitEvent.GetHeadCommit().GetMessage()
                processedEvent.Sender = gitEvent.GetSender().GetLogin()
                processedEvent.BaseBranch = gitEvent.GetRef()
                processedEvent.EventType = event.TriggerTarget.String()
                processedEvent.HeadBranch = processedEvent.BaseBranch // in push events Head Branch is the same as Basebranch
                processedEvent.BaseURL = gitEvent.GetRepo().GetHTMLURL()
                processedEvent.HeadURL = processedEvent.BaseURL // in push events Head URL is the same as BaseURL
                v.userType = gitEvent.GetSender().GetType()</span>
        case *github.PullRequestEvent:<span class="cov8" title="1">
                processedEvent.Repository = gitEvent.GetRepo().GetName()
                if gitEvent.GetRepo() == nil </span><span class="cov8" title="1">{
                        return nil, errors.New("error parsing payload the repository should not be nil")
                }</span>
                <span class="cov8" title="1">processedEvent.Organization = gitEvent.GetRepo().Owner.GetLogin()
                processedEvent.DefaultBranch = gitEvent.GetRepo().GetDefaultBranch()
                processedEvent.SHA = gitEvent.GetPullRequest().Head.GetSHA()
                processedEvent.URL = gitEvent.GetRepo().GetHTMLURL()
                processedEvent.BaseBranch = gitEvent.GetPullRequest().Base.GetRef()
                processedEvent.HeadBranch = gitEvent.GetPullRequest().Head.GetRef()
                processedEvent.BaseURL = gitEvent.GetPullRequest().Base.GetRepo().GetHTMLURL()
                processedEvent.HeadURL = gitEvent.GetPullRequest().Head.GetRepo().GetHTMLURL()
                processedEvent.Sender = gitEvent.GetPullRequest().GetUser().GetLogin()
                processedEvent.EventType = event.EventType
                v.userType = gitEvent.GetPullRequest().GetUser().GetType()

                if gitEvent.Action != nil &amp;&amp; provider.Valid(*gitEvent.Action, pullRequestLabelEvent) </span><span class="cov0" title="0">{
                        processedEvent.EventType = string(triggertype.PullRequestLabeled)
                }</span>

                <span class="cov8" title="1">if gitEvent.GetAction() == "closed" </span><span class="cov8" title="1">{
                        processedEvent.TriggerTarget = triggertype.PullRequestClosed
                }</span>

                <span class="cov8" title="1">processedEvent.PullRequestNumber = gitEvent.GetPullRequest().GetNumber()
                processedEvent.PullRequestTitle = gitEvent.GetPullRequest().GetTitle()
                // getting the repository ids of the base and head of the pull request
                // to scope the token to
                v.RepositoryIDs = []int64{
                        gitEvent.GetPullRequest().GetBase().GetRepo().GetID(),
                }
                for _, label := range gitEvent.GetPullRequest().Labels </span><span class="cov0" title="0">{
                        processedEvent.PullRequestLabel = append(processedEvent.PullRequestLabel, label.GetName())
                }</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("this event is not supported")</span>
        }

        // check before overriding the value for TriggerTarget
        <span class="cov8" title="1">if processedEvent.TriggerTarget == "" </span><span class="cov8" title="1">{
                processedEvent.TriggerTarget = event.TriggerTarget
        }</span>
        <span class="cov8" title="1">processedEvent.Provider.Token = event.Provider.Token

        return processedEvent, nil</span>
}

func (v *Provider) handleReRequestEvent(ctx context.Context, event *github.CheckRunEvent) (*info.Event, error) <span class="cov8" title="1">{
        runevent := info.NewEvent()
        if event.GetRepo() == nil </span><span class="cov0" title="0">{
                return nil, errors.New("error parsing payload the repository should not be nil")
        }</span>
        <span class="cov8" title="1">runevent.Organization = event.GetRepo().GetOwner().GetLogin()
        runevent.Repository = event.GetRepo().GetName()
        runevent.URL = event.GetRepo().GetHTMLURL()
        runevent.DefaultBranch = event.GetRepo().GetDefaultBranch()
        runevent.SHA = event.GetCheckRun().GetCheckSuite().GetHeadSHA()
        runevent.HeadBranch = event.GetCheckRun().GetCheckSuite().GetHeadBranch()
        runevent.HeadURL = event.GetCheckRun().GetCheckSuite().GetRepository().GetHTMLURL()
        // If we don't have a pull_request in this it probably mean a push
        if len(event.GetCheckRun().GetCheckSuite().PullRequests) == 0 </span><span class="cov8" title="1">{
                runevent.BaseBranch = runevent.HeadBranch
                runevent.BaseURL = runevent.HeadURL
                runevent.EventType = "push"
                // we allow the rerequest user here, not the push user, i guess it's
                // fine because you can't do a rereq without being a github owner?
                runevent.Sender = event.GetSender().GetLogin()
                v.userType = event.GetSender().GetType()
                return runevent, nil
        }</span>
        <span class="cov8" title="1">runevent.PullRequestNumber = event.GetCheckRun().GetCheckSuite().PullRequests[0].GetNumber()
        runevent.TriggerTarget = triggertype.PullRequest
        v.Logger.Infof("Recheck of PR %s/%s#%d has been requested", runevent.Organization, runevent.Repository, runevent.PullRequestNumber)
        return v.getPullRequest(ctx, runevent)</span>
}

func (v *Provider) handleCheckSuites(ctx context.Context, event *github.CheckSuiteEvent) (*info.Event, error) <span class="cov8" title="1">{
        runevent := info.NewEvent()
        if event.GetRepo() == nil </span><span class="cov0" title="0">{
                return nil, errors.New("error parsing payload the repository should not be nil")
        }</span>
        <span class="cov8" title="1">runevent.Organization = event.GetRepo().GetOwner().GetLogin()
        runevent.Repository = event.GetRepo().GetName()
        runevent.URL = event.GetRepo().GetHTMLURL()
        runevent.DefaultBranch = event.GetRepo().GetDefaultBranch()
        runevent.SHA = event.GetCheckSuite().GetHeadSHA()
        runevent.HeadBranch = event.GetCheckSuite().GetHeadBranch()
        runevent.HeadURL = event.GetCheckSuite().GetRepository().GetHTMLURL()
        // If we don't have a pull_request in this it probably mean a push
        // we are not able to know which
        if len(event.GetCheckSuite().PullRequests) == 0 </span><span class="cov0" title="0">{
                runevent.BaseBranch = runevent.HeadBranch
                runevent.BaseURL = runevent.HeadURL
                runevent.EventType = "push"
                runevent.TriggerTarget = "push"
                // we allow the rerequest user here, not the push user, i guess it's
                // fine because you can't do a rereq without being a github owner?
                runevent.Sender = event.GetSender().GetLogin()
                v.userType = event.GetSender().GetType()
                return runevent, nil
                // return nil, fmt.Errorf("check suite event is not supported for push events")
        }</span>
        <span class="cov8" title="1">runevent.PullRequestNumber = event.GetCheckSuite().PullRequests[0].GetNumber()
        runevent.TriggerTarget = triggertype.PullRequest
        v.Logger.Infof("Rerun of all check on PR %s/%s#%d has been requested", runevent.Organization, runevent.Repository, runevent.PullRequestNumber)
        return v.getPullRequest(ctx, runevent)</span>
}

func convertPullRequestURLtoNumber(pullRequest string) (int, error) <span class="cov8" title="1">{
        prNumber, err := strconv.Atoi(path.Base(pullRequest))
        if err != nil </span><span class="cov8" title="1">{
                return -1, fmt.Errorf("bad pull request number html_url number: %w", err)
        }</span>
        <span class="cov8" title="1">return prNumber, nil</span>
}

func (v *Provider) handleIssueCommentEvent(ctx context.Context, event *github.IssueCommentEvent) (*info.Event, error) <span class="cov8" title="1">{
        action := "recheck"
        runevent := info.NewEvent()
        runevent.Organization = event.GetRepo().GetOwner().GetLogin()
        runevent.Repository = event.GetRepo().GetName()
        runevent.Sender = event.GetSender().GetLogin()
        // Always set the trigger target as pull_request on issue comment events
        runevent.TriggerTarget = triggertype.PullRequest
        if !event.GetIssue().IsPullRequest() </span><span class="cov8" title="1">{
                return info.NewEvent(), fmt.Errorf("issue comment is not coming from a pull_request")
        }</span>
        <span class="cov8" title="1">v.userType = event.GetSender().GetType()
        opscomments.SetEventTypeAndTargetPR(runevent, event.GetComment().GetBody())
        // We are getting the full URL so we have to get the last part to get the PR number,
        // we don't have to care about URL query string/hash and other stuff because
        // that comes up from the API.
        var err error
        runevent.PullRequestNumber, err = convertPullRequestURLtoNumber(event.GetIssue().GetPullRequestLinks().GetHTMLURL())
        if err != nil </span><span class="cov8" title="1">{
                return info.NewEvent(), err
        }</span>

        <span class="cov8" title="1">v.Logger.Infof("issue_comment: pipelinerun %s on %s/%s#%d has been requested", action, runevent.Organization, runevent.Repository, runevent.PullRequestNumber)
        return v.getPullRequest(ctx, runevent)</span>
}

func (v *Provider) handleCommitCommentEvent(ctx context.Context, event *github.CommitCommentEvent) (*info.Event, error) <span class="cov8" title="1">{
        action := "push"
        runevent := info.NewEvent()
        if event.GetRepo() == nil </span><span class="cov8" title="1">{
                return nil, errors.New("error parsing payload the repository should not be nil")
        }</span>
        <span class="cov8" title="1">runevent.Organization = event.GetRepo().GetOwner().GetLogin()
        runevent.Repository = event.GetRepo().GetName()
        runevent.Sender = event.GetSender().GetLogin()
        v.userType = event.GetSender().GetType()
        runevent.URL = event.GetRepo().GetHTMLURL()
        runevent.SHA = event.GetComment().GetCommitID()
        runevent.HeadURL = runevent.URL
        runevent.BaseURL = runevent.HeadURL
        runevent.TriggerTarget = triggertype.Push
        opscomments.SetEventTypeAndTargetPR(runevent, event.GetComment().GetBody())

        defaultBranch := event.GetRepo().GetDefaultBranch()
        // Set Event.Repository.DefaultBranch as default branch to runevent.HeadBranch, runevent.BaseBranch
        runevent.HeadBranch, runevent.BaseBranch = defaultBranch, defaultBranch
        var (
                branchName string
                prName     string
                tagName    string
                err        error
        )

        // If it is a /test or /retest comment with pipelinerun name figure out the pipelinerun name
        if provider.IsTestRetestComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                prName, branchName, tagName, err = provider.GetPipelineRunAndBranchOrTagNameFromTestComment(event.GetComment().GetBody())
                if err != nil </span><span class="cov8" title="1">{
                        return runevent, err
                }</span>
                <span class="cov8" title="1">runevent.TargetTestPipelineRun = prName</span>
        }
        // Check for /cancel comment
        <span class="cov8" title="1">if provider.IsCancelComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                action = "cancellation"
                prName, branchName, tagName, err = provider.GetPipelineRunAndBranchOrTagNameFromCancelComment(event.GetComment().GetBody())
                if err != nil </span><span class="cov0" title="0">{
                        return runevent, err
                }</span>
                <span class="cov8" title="1">runevent.CancelPipelineRuns = true
                runevent.TargetCancelPipelineRun = prName</span>
        }

        <span class="cov8" title="1">if tagName != "" </span><span class="cov8" title="1">{
                tagPath := fmt.Sprintf("refs/tags/%s", tagName)
                // here in GitHub TAG_SHA and the commit which is tagged for a tag are different
                // so we need to get the ref for the tag and then get the tag object to get the tag SHA
                ref, _, err := wrapAPI(v, "get_ref", func() (*github.Reference, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Git.GetRef(ctx, runevent.Organization, runevent.Repository, tagPath)
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return runevent, fmt.Errorf("error getting ref for tag %s: %w", tagName, err)
                }</span>
                // get the tag object to get the SHA
                <span class="cov8" title="1">tag, _, err := wrapAPI(v, "get_tag", func() (*github.Tag, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Git.GetTag(ctx, runevent.Organization, runevent.Repository, ref.GetObject().GetSHA())
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return runevent, fmt.Errorf("error getting tag %s: %w", tagName, err)
                }</span>
                <span class="cov8" title="1">if tag.GetObject().GetSHA() != runevent.SHA </span><span class="cov0" title="0">{
                        return runevent, fmt.Errorf("provided SHA %s is not the tagged commit for the tag %s", runevent.SHA, tagName)
                }</span>
                <span class="cov8" title="1">runevent.HeadBranch = tagPath
                runevent.BaseBranch = tagPath
                return runevent, nil</span>
        }

        // If no branch is specified in GitOps comments, use runevent.HeadBranch
        <span class="cov8" title="1">if branchName == "" </span><span class="cov8" title="1">{
                branchName = runevent.HeadBranch
        }</span>

        // Check if the specified branch contains the commit
        <span class="cov8" title="1">if err = v.isHeadCommitOfBranch(ctx, runevent, branchName); err != nil </span><span class="cov8" title="1">{
                if provider.IsCancelComment(event.GetComment().GetBody()) </span><span class="cov8" title="1">{
                        runevent.CancelPipelineRuns = false
                }</span>
                <span class="cov8" title="1">return runevent, err</span>
        }
        // Finally update branch information to runevent.HeadBranch and runevent.BaseBranch
        <span class="cov8" title="1">runevent.HeadBranch = branchName
        runevent.BaseBranch = branchName

        v.Logger.Infof("github commit_comment: pipelinerun %s on %s/%s#%s has been requested", action, runevent.Organization, runevent.Repository, runevent.SHA)
        return runevent, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package github

import (
        "fmt"
        "net/http"
        "strconv"
        "time"

        "github.com/google/go-github/v74/github"
        providerMetrics "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/metrics"
)

const (
        // Rate limit warning thresholds.
        rateLimitCritical = 50  // Warn when remaining calls &lt; 50
        rateLimitWarning  = 100 // Warn when remaining calls &lt; 100
        rateLimitInfo     = 500 // Info when remaining calls &lt; 500
)

// checkRateLimit monitors GitHub API rate limits and logs warnings when limits are running low.
func (v *Provider) checkRateLimit(resp *github.Response) (remaining string) <span class="cov8" title="1">{
        if resp == nil || resp.Response == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Extract rate limit information from headers (using canonical header keys)
        <span class="cov8" title="1">values := resp.Header[http.CanonicalHeaderKey("X-RateLimit-Remaining")]
        if len(values) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">remaining = values[0]
        if remaining == "" </span><span class="cov0" title="0">{
                return remaining
        }</span>

        // Parse remaining count
        <span class="cov8" title="1">remainingCount, err := strconv.Atoi(remaining)
        if err != nil </span><span class="cov0" title="0">{
                v.Logger.Debugf("Failed to parse rate limit remaining: %s", remaining)
                return remaining
        }</span>

        // Get additional rate limit context
        <span class="cov8" title="1">limit := ""
        reset := ""
        if limitValues := resp.Header[http.CanonicalHeaderKey("X-RateLimit-Limit")]; len(limitValues) &gt; 0 </span><span class="cov8" title="1">{
                limit = limitValues[0]
        }</span>
        <span class="cov8" title="1">if resetValues := resp.Header[http.CanonicalHeaderKey("X-RateLimit-Reset")]; len(resetValues) &gt; 0 </span><span class="cov8" title="1">{
                reset = resetValues[0]
                // Convert Unix timestamp to human readable time
                if resetTimestamp, err := strconv.ParseInt(reset, 10, 64); err == nil </span><span class="cov8" title="1">{
                        resetTime := time.Unix(resetTimestamp, 0)
                        reset = fmt.Sprintf("%s (%s)", reset, resetTime.Format("15:04:05 MST"))
                }</span>
        }

        <span class="cov8" title="1">repoName := ""
        if v.repo != nil </span><span class="cov8" title="1">{
                repoName = fmt.Sprintf("%s/%s", v.repo.Namespace, v.repo.Name)
        }</span>

        // Log warnings based on thresholds
        <span class="cov8" title="1">logFields := []any{
                "repo", repoName,
                "remaining", remainingCount,
                "limit", limit,
                "reset", reset,
        }
        switch </span>{
        case remainingCount &lt; rateLimitCritical:<span class="cov8" title="1">
                v.Logger.Errorw("GitHub API rate limit critically low", logFields...)</span>
        case remainingCount &lt; rateLimitWarning:<span class="cov8" title="1">
                v.Logger.Warnw("GitHub API rate limit running low", logFields...)</span>
        case remainingCount &lt; rateLimitInfo:<span class="cov8" title="1">
                v.Logger.Infow("GitHub API rate limit moderate", logFields...)</span>
        }

        <span class="cov8" title="1">return remaining</span>
}

// wrapAPI wraps a GitHub API call with logging, metrics, and operation context.
func wrapAPI[T any](v *Provider, operation string, call func() (T, *github.Response, error)) (T, *github.Response, error) <span class="cov8" title="1">{
        // This check ensures we only profile if a logger is available.
        if v.Logger == nil </span><span class="cov8" title="1">{
                return call()
        }</span>

        <span class="cov8" title="1">start := time.Now()
        data, resp, err := call()
        duration := time.Since(start)

        v.logAPICall(operation, duration, resp, err)

        return data, resp, err</span>
}

func (v *Provider) logAPICall(operation string, duration time.Duration, resp *github.Response, err error) <span class="cov8" title="1">{
        providerMetrics.RecordAPIUsage(v.Logger, v.providerName, v.triggerEvent, v.repo)

        // Build structured logging context
        logFields := []any{
                "operation", operation,
                "duration_ms", duration.Milliseconds(),
                "provider", "github",
        }

        // Add repository context if available
        if v.repo != nil </span><span class="cov8" title="1">{
                logFields = append(logFields, "repo", fmt.Sprintf("%s/%s", v.repo.Namespace, v.repo.Name))
        }</span>

        // Add response context if available
        <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                remaining := v.checkRateLimit(resp)
                logFields = append(logFields,
                        "url_path", resp.Request.URL.Path,
                        "rate_limit_remaining", remaining,
                )
                if resp.StatusCode &gt; 0 </span><span class="cov8" title="1">{
                        logFields = append(logFields, "status_code", resp.StatusCode)
                }</span>
        }

        // Log based on success/failure with appropriate level
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                logFields = append(logFields, "error", err.Error())
                v.Logger.Errorw("GitHub API call failed", logFields...)
        }</span> else<span class="cov8" title="1"> {
                v.Logger.Debugw("GitHub API call completed", logFields...)
        }</span>
}

// wrapAPIGetContents wraps the GetContents API call with operation context.
func wrapAPIGetContents(v *Provider, operation string, call func() (*github.RepositoryContent, []*github.RepositoryContent, *github.Response, error)) (*github.RepositoryContent, []*github.RepositoryContent, *github.Response, error) <span class="cov8" title="1">{
        // This check ensures we only profile if a logger is available.
        if v.Logger == nil </span><span class="cov8" title="1">{
                return call()
        }</span>

        <span class="cov8" title="1">start := time.Now()
        file, dir, resp, err := call()
        duration := time.Since(start)

        v.logAPICall(operation, duration, resp, err)

        return file, dir, resp, err</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package github

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/google/go-github/v74/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/clients"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/templates"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        defaultNsTemplate   = "%v-pipelines"
        defaultRepoTemplate = "%v-repo-cr"
)

func ConfigureRepository(ctx context.Context, run *params.Run, req *http.Request, payload string, pacInfo *info.PacOpts, logger *zap.SugaredLogger) (bool, bool, error) <span class="cov8" title="1">{
        // check if repo auto configuration is enabled
        if !pacInfo.AutoConfigureNewGitHubRepo </span><span class="cov0" title="0">{
                return false, false, nil
        }</span>
        // gitea set x-github-event too, so skip it for the gitea driver
        <span class="cov8" title="1">if h := req.Header.Get("X-Gitea-Event-Type"); h != "" </span><span class="cov0" title="0">{
                return false, false, nil
        }</span>
        <span class="cov8" title="1">event := req.Header.Get("X-Github-Event")
        if event != "repository" </span><span class="cov8" title="1">{
                return false, false, nil
        }</span>

        <span class="cov8" title="1">eventInt, err := github.ParseWebHook(event, []byte(payload))
        if err != nil </span><span class="cov0" title="0">{
                return true, false, err
        }</span>
        <span class="cov8" title="1">_ = json.Unmarshal([]byte(payload), &amp;eventInt)
        repoEvent, _ := eventInt.(*github.RepositoryEvent)

        if repoEvent.GetAction() != "created" </span><span class="cov8" title="1">{
                logger.Infof("github: repository event \"%v\" is not supported", repoEvent.GetAction())
                return true, false, nil
        }</span>

        <span class="cov8" title="1">logger.Infof("github: configuring repository cr for repo: %v", repoEvent.Repo.GetHTMLURL())
        nsTemplate := pacInfo.AutoConfigureRepoNamespaceTemplate
        repoTemplate := pacInfo.AutoConfigureRepoRepositoryTemplate
        if err := createRepository(ctx, nsTemplate, repoTemplate, run.Clients, repoEvent, logger); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed repository creation: %v", err)
                return true, true, err
        }</span>

        <span class="cov8" title="1">return true, true, nil</span>
}

func createRepository(ctx context.Context, nsTemplate, repoTemplate string, clients clients.Clients, gitEvent *github.RepositoryEvent, logger *zap.SugaredLogger) error <span class="cov8" title="1">{
        repoNsName, repoCRName, err := generateNamespaceAndRepositoryName(nsTemplate, repoTemplate, gitEvent)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate namespace for repo: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("github: generated namespace name: ", repoNsName)

        // create namespace
        repoNs := &amp;corev1.Namespace{
                ObjectMeta: metav1.ObjectMeta{
                        Name: repoNsName,
                },
        }
        repoNs, err = clients.Kube.CoreV1().Namespaces().Create(ctx, repoNs, metav1.CreateOptions{})
        if err != nil &amp;&amp; !errors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create namespace %v: %w", repoNs.Name, err)
        }</span>

        <span class="cov8" title="1">if errors.IsAlreadyExists(err) </span><span class="cov8" title="1">{
                logger.Infof("github: namespace %v already exists, creating repository", repoNsName)
        }</span> else<span class="cov8" title="1"> {
                logger.Info("github: created repository namespace: ", repoNs.Name)
        }</span>

        // create repository
        <span class="cov8" title="1">repo := &amp;v1alpha1.Repository{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      repoCRName,
                        Namespace: repoNsName,
                },
                Spec: v1alpha1.RepositorySpec{
                        URL: gitEvent.Repo.GetHTMLURL(),
                },
        }
        repo, err = clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(repoNsName).Create(ctx, repo, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create repository for repo: %v: %w", gitEvent.Repo.GetHTMLURL(), err)
        }</span>
        <span class="cov8" title="1">logger = logger.With("namespace", repo.Namespace)
        logger.Infof("github: repository created: %s/%s ", repo.Namespace, repo.Name)
        return nil</span>
}

func generateNamespaceAndRepositoryName(nsTemplate, repoTemplate string, gitEvent *github.RepositoryEvent) (string, string, error) <span class="cov8" title="1">{
        repoOwner, repoName, err := formatting.GetRepoOwnerSplitted(gitEvent.Repo.GetHTMLURL())
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to parse git repo url: %w", err)
        }</span>

        <span class="cov8" title="1">nsName := ""
        repoCRName := ""
        placeholders := map[string]string{
                "repo_owner": repoOwner,
                "repo_name":  repoName,
        }

        if nsTemplate == "" </span><span class="cov8" title="1">{
                nsName = fmt.Sprintf(defaultNsTemplate, repoName)
        }</span> else<span class="cov8" title="1"> {
                nsName = templates.ReplacePlaceHoldersVariables(nsTemplate, placeholders, nil, http.Header{}, map[string]any{})
        }</span>

        <span class="cov8" title="1">if repoTemplate == "" </span><span class="cov8" title="1">{
                repoCRName = fmt.Sprintf(defaultRepoTemplate, repoName)
        }</span> else<span class="cov8" title="1"> {
                repoCRName = templates.ReplacePlaceHoldersVariables(repoTemplate, placeholders, nil, http.Header{}, map[string]any{})
        }</span>
        <span class="cov8" title="1">return nsName, repoCRName, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package github

import (
        "context"
        "errors"
        "fmt"
        "net/url"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func ScopeTokenToListOfRepos(ctx context.Context, vcx provider.Interface, pacInfo *info.PacOpts, repo *v1alpha1.Repository, run *params.Run,
        event *info.Event, eventEmitter *events.EventEmitter, logger *zap.SugaredLogger,
) (string, error) <span class="cov8" title="1">{
        var (
                listRepos bool
                token     string
        )
        listURLs := map[string]string{}
        repoListToScopeToken := []string{}

        // This is a Global config to provide list of repos to scope token
        if pacInfo.SecretGhAppTokenScopedExtraRepos != "" </span><span class="cov8" title="1">{
                for _, configValue := range strings.Split(pacInfo.SecretGhAppTokenScopedExtraRepos, ",") </span><span class="cov8" title="1">{
                        configValueS := strings.TrimSpace(configValue)
                        if configValueS == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">repoListToScopeToken = append(repoListToScopeToken, configValueS)</span>
                }
                <span class="cov8" title="1">listRepos = true
                logger.Infof("configured Global configuration to %v to scope Github token ", repoListToScopeToken)</span>
        }
        <span class="cov8" title="1">if repo.Spec.Settings != nil &amp;&amp; len(repo.Spec.Settings.GithubAppTokenScopeRepos) != 0 </span><span class="cov8" title="1">{
                ns := repo.Namespace
                repoListInPerticularNamespace, err := run.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(ns).List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">for i := range repoListInPerticularNamespace.Items </span><span class="cov8" title="1">{
                        splitData, err := getURLPathData(repoListInPerticularNamespace.Items[i].Spec.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">listURLs[splitData[1]+"/"+splitData[2]] = splitData[1] + "/" + splitData[2]</span>
                }
                <span class="cov8" title="1">for i := range repo.Spec.Settings.GithubAppTokenScopeRepos </span><span class="cov8" title="1">{
                        if _, ok := listURLs[repo.Spec.Settings.GithubAppTokenScopeRepos[i]]; !ok </span><span class="cov8" title="1">{
                                msg := fmt.Sprintf("failed to scope GitHub token as repo %s does not exist in namespace %s", repo.Spec.Settings.GithubAppTokenScopeRepos[i], ns)
                                eventEmitter.EmitMessage(nil, zap.ErrorLevel, "RepoDoesNotExistInNamespace", msg)
                                return "", errors.New(msg)
                        }</span>
                        <span class="cov8" title="1">repoListToScopeToken = append(repoListToScopeToken, repo.Spec.Settings.GithubAppTokenScopeRepos[i])</span>
                }
                // When the global configuration is not set then check for secret-github-app-token-scoped key for the repo level configuration
                <span class="cov8" title="1">if pacInfo.SecretGHAppRepoScoped &amp;&amp; pacInfo.SecretGhAppTokenScopedExtraRepos == "" </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf(`failed to scope GitHub token as repo scoped key %s is enabled. Hint: update key %s from pipelines-as-code configmap to false`,
                                settings.SecretGhAppTokenRepoScopedKey, settings.SecretGhAppTokenRepoScopedKey)
                        eventEmitter.EmitMessage(nil, zap.ErrorLevel, "SecretGHAppTokenRepoScopeIsEnabled", msg)
                        return "", errors.New(msg)
                }</span>
                <span class="cov8" title="1">listRepos = true
                logger.Infof("configured repo level configuration to %v to scope Github token ", repo.Spec.Settings.GithubAppTokenScopeRepos)</span>
        }
        <span class="cov8" title="1">if listRepos </span><span class="cov8" title="1">{
                repoInfoFromWhichEventCame, err := getURLPathData(repo.Spec.URL)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                // adding the repo info from which event came so that repositoryID will be added while scoping the token
                <span class="cov8" title="1">repoListToScopeToken = append(repoListToScopeToken, repoInfoFromWhichEventCame[1]+"/"+repoInfoFromWhichEventCame[2])
                token, err = vcx.CreateToken(ctx, repoListToScopeToken, event)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to scope token to repositories with error : %w", err)
                }</span>
                <span class="cov8" title="1">logger.Infof("Github token scope extended to %v ", repoListToScopeToken)</span>
        }
        <span class="cov8" title="1">return token, nil</span>
}

func getURLPathData(urlInfo string) ([]string, error) <span class="cov8" title="1">{
        urlData, err := url.ParseRequestURI(urlInfo)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>
        <span class="cov8" title="1">return strings.Split(urlData.Path, "/"), nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package github

import (
        "context"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/google/go-github/v74/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/action"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        kstatus "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/status"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

const (
        botType         = "Bot"
        pendingApproval = "Pending approval, waiting for an /ok-to-test"
)

const taskStatusTemplate = `
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;th&gt;Duration&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt;

{{- range $taskrun := .TaskRunList }}
&lt;tr&gt;
&lt;td&gt;{{ formatCondition $taskrun.PipelineRunTaskRunStatus.Status.Conditions }}&lt;/td&gt;
&lt;td&gt;{{ formatDuration $taskrun.PipelineRunTaskRunStatus.Status.StartTime $taskrun.PipelineRunTaskRunStatus.Status.CompletionTime }}&lt;/td&gt;&lt;td&gt;

{{ $taskrun.ConsoleLogURL }}

&lt;/td&gt;&lt;/tr&gt;
{{- end }}
&lt;/table&gt;`

func (v *Provider) getExistingCheckRunID(ctx context.Context, runevent *info.Event, status provider.StatusOpts) (*int64, error) <span class="cov8" title="1">{
        opt := github.ListOptions{PerPage: v.PaginedNumber}
        for </span><span class="cov8" title="1">{
                res, resp, err := wrapAPI(v, "list_check_runs_for_ref", func() (*github.ListCheckRunsResults, *github.Response, error) </span><span class="cov8" title="1">{
                        return v.Client().Checks.ListCheckRunsForRef(ctx, runevent.Organization, runevent.Repository,
                                runevent.SHA, &amp;github.ListCheckRunsOptions{
                                        AppID:       v.ApplicationID,
                                        ListOptions: opt,
                                })
                }</span>)
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">for _, checkrun := range res.CheckRuns </span><span class="cov8" title="1">{
                        // if it is a Pending approval CheckRun then overwrite it
                        if isPendingApprovalCheckrun(checkrun) || isFailedCheckrun(checkrun) </span><span class="cov8" title="1">{
                                if v.canIUseCheckrunID(checkrun.ID) </span><span class="cov8" title="1">{
                                        return checkrun.ID, nil
                                }</span>
                        }
                        <span class="cov8" title="1">if *checkrun.ExternalID == status.PipelineRunName </span><span class="cov8" title="1">{
                                return checkrun.ID, nil
                        }</span>
                }
                <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">opt.Page = resp.NextPage</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func isPendingApprovalCheckrun(run *github.CheckRun) bool <span class="cov8" title="1">{
        if run == nil || run.Output == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if run.Output.Title != nil &amp;&amp; strings.Contains(*run.Output.Title, "Pending") &amp;&amp;
                run.Output.Summary != nil &amp;&amp;
                strings.Contains(*run.Output.Summary, "is waiting for approval") </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func isFailedCheckrun(run *github.CheckRun) bool <span class="cov8" title="1">{
        if run == nil || run.Output == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if run.Output.Title != nil &amp;&amp; strings.Contains(*run.Output.Title, "pipelinerun start failure") &amp;&amp;
                run.Output.Summary != nil &amp;&amp;
                strings.Contains(*run.Output.Summary, "failed") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (v *Provider) canIUseCheckrunID(checkrunid *int64) bool <span class="cov8" title="1">{
        v.mutex.Lock()
        defer v.mutex.Unlock()

        if v.checkRunID == 0 </span><span class="cov8" title="1">{
                v.checkRunID = *checkrunid
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (v *Provider) createCheckRunStatus(ctx context.Context, runevent *info.Event, status provider.StatusOpts) (*int64, error) <span class="cov8" title="1">{
        now := github.Timestamp{Time: time.Now()}
        checkrunoption := github.CreateCheckRunOptions{
                Name:       provider.GetCheckName(status, v.pacInfo),
                HeadSHA:    runevent.SHA,
                Status:     github.Ptr("in_progress"),
                DetailsURL: github.Ptr(status.DetailsURL),
                ExternalID: github.Ptr(status.PipelineRunName),
                StartedAt:  &amp;now,
        }

        checkRun, _, err := wrapAPI(v, "create_check_run", func() (*github.CheckRun, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Checks.CreateCheckRun(ctx, runevent.Organization, runevent.Repository, checkrunoption)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return checkRun.ID, nil</span>
}

func (v *Provider) getFailuresMessageAsAnnotations(ctx context.Context, pr *tektonv1.PipelineRun, pacopts *info.PacOpts) []*github.CheckRunAnnotation <span class="cov0" title="0">{
        annotations := []*github.CheckRunAnnotation{}
        r, err := regexp.Compile(pacopts.ErrorDetectionSimpleRegexp)
        if err != nil </span><span class="cov0" title="0">{
                v.Logger.Errorf("invalid regexp for filtering failure messages: %v", pacopts.ErrorDetectionSimpleRegexp)
                return annotations
        }</span>
        <span class="cov0" title="0">intf, err := kubeinteraction.NewKubernetesInteraction(v.Run)
        if err != nil </span><span class="cov0" title="0">{
                v.Logger.Errorf("failed to create kubeinteraction: %v", err)
                return annotations
        }</span>
        <span class="cov0" title="0">taskinfos := kstatus.CollectFailedTasksLogSnippet(ctx, v.Run, intf, pr, int64(pacopts.ErrorDetectionNumberOfLines))
        for _, taskinfo := range taskinfos </span><span class="cov0" title="0">{
                for _, errline := range strings.Split(taskinfo.LogSnippet, "\n") </span><span class="cov0" title="0">{
                        results := map[string]string{}
                        if !r.MatchString(errline) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">matches := r.FindStringSubmatch(errline)
                        for i, name := range r.SubexpNames() </span><span class="cov0" title="0">{
                                if i != 0 &amp;&amp; name != "" </span><span class="cov0" title="0">{
                                        results[name] = matches[i]
                                }</span>
                        }

                        // check if we  have file in results
                        <span class="cov0" title="0">var linenumber, errmsg, filename string
                        var ok bool

                        if filename, ok = results["filename"]; !ok </span><span class="cov0" title="0">{
                                v.Logger.Errorf("regexp for filtering failure messages does not contain a filename regexp group: %v", pacopts.ErrorDetectionSimpleRegexp)
                                continue</span>
                        }
                        // remove ./ cause it would bug github otherwise
                        <span class="cov0" title="0">filename = strings.TrimPrefix(filename, "./")

                        if linenumber, ok = results["line"]; !ok </span><span class="cov0" title="0">{
                                v.Logger.Errorf("regexp for filtering failure messages does not contain a line regexp group: %v", pacopts.ErrorDetectionSimpleRegexp)
                                continue</span>
                        }

                        <span class="cov0" title="0">if errmsg, ok = results["error"]; !ok </span><span class="cov0" title="0">{
                                v.Logger.Errorf("regexp for filtering failure messages does not contain a error regexp group: %v", pacopts.ErrorDetectionSimpleRegexp)
                                continue</span>
                        }

                        <span class="cov0" title="0">ilinenumber, err := strconv.Atoi(linenumber)
                        if err != nil </span><span class="cov0" title="0">{
                                // can't do much regexp has probably failed to detect
                                v.Logger.Errorf("cannot convert %s as integer: %v", linenumber, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">annotations = append(annotations, &amp;github.CheckRunAnnotation{
                                Path:            github.Ptr(filename),
                                StartLine:       github.Ptr(ilinenumber),
                                EndLine:         github.Ptr(ilinenumber),
                                AnnotationLevel: github.Ptr("failure"),
                                Message:         github.Ptr(errmsg),
                        })</span>
                }
        }
        <span class="cov0" title="0">return annotations</span>
}

// getOrUpdateCheckRunStatus create a status via the checkRun API, which is only
// available with GitHub apps tokens.
func (v *Provider) getOrUpdateCheckRunStatus(ctx context.Context, runevent *info.Event, statusOpts provider.StatusOpts) error <span class="cov8" title="1">{
        var err error
        var checkRunID *int64
        var found bool
        pacopts := v.pacInfo

        // The purpose of this condition is to limit the generation of checkrun IDs
        // when multiple pipelineruns fail. In such cases, generate only one checkrun ID,
        // regardless of the number of failed pipelineruns.
        if statusOpts.Title == "Failed" &amp;&amp; statusOpts.PipelineRunName == "" </span><span class="cov8" title="1">{
                // setting different title to handle multiple checkrun cases
                statusOpts.Title = "pipelinerun start failure"
                if statusOpts.InstanceCountForCheckRun &gt;= 1 </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        // check if pipelineRun has the label with checkRun-id
        <span class="cov8" title="1">if statusOpts.PipelineRun != nil </span><span class="cov8" title="1">{
                var id string
                id, found = statusOpts.PipelineRun.GetAnnotations()[keys.CheckRunID]
                if found </span><span class="cov8" title="1">{
                        checkID, err := strconv.Atoi(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("api error: cannot convert checkrunid")
                        }</span>
                        <span class="cov8" title="1">checkRunID = github.Ptr(int64(checkID))</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                if checkRunID, _ = v.getExistingCheckRunID(ctx, runevent, statusOpts); checkRunID == nil </span><span class="cov8" title="1">{
                        checkRunID, err = v.createCheckRunStatus(ctx, runevent, statusOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">if statusOpts.PipelineRun != nil </span><span class="cov8" title="1">{
                        if _, err := action.PatchPipelineRun(ctx, v.Logger, "checkRunID and logURL", v.Run.Clients.Tekton, statusOpts.PipelineRun, metadataPatch(checkRunID, statusOpts.DetailsURL)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">text := statusOpts.Text
        checkRunOutput := &amp;github.CheckRunOutput{
                Title:   &amp;statusOpts.Title,
                Summary: &amp;statusOpts.Summary,
        }

        if statusOpts.PipelineRun != nil </span><span class="cov8" title="1">{
                if pacopts.ErrorDetection </span><span class="cov0" title="0">{
                        checkRunOutput.Annotations = v.getFailuresMessageAsAnnotations(ctx, statusOpts.PipelineRun, pacopts)
                }</span>
        }

        <span class="cov8" title="1">checkRunOutput.Text = github.Ptr(text)

        opts := github.UpdateCheckRunOptions{
                Name:   provider.GetCheckName(statusOpts, pacopts),
                Status: github.Ptr(statusOpts.Status),
                Output: checkRunOutput,
        }
        if statusOpts.PipelineRunName != "" </span><span class="cov8" title="1">{
                opts.ExternalID = github.Ptr(statusOpts.PipelineRunName)
        }</span>
        <span class="cov8" title="1">if statusOpts.DetailsURL != "" </span><span class="cov8" title="1">{
                opts.DetailsURL = &amp;statusOpts.DetailsURL
        }</span>

        // Only set completed-at if conclusion is set (which means finished)
        <span class="cov8" title="1">if statusOpts.Conclusion != "" &amp;&amp; statusOpts.Conclusion != "pending" </span><span class="cov8" title="1">{
                opts.CompletedAt = &amp;github.Timestamp{Time: time.Now()}
                opts.Conclusion = &amp;statusOpts.Conclusion
        }</span>
        <span class="cov8" title="1">if isPipelineRunCancelledOrStopped(statusOpts.PipelineRun) </span><span class="cov0" title="0">{
                opts.Conclusion = github.Ptr("cancelled")
        }</span>

        <span class="cov8" title="1">_, _, err = wrapAPI(v, "update_check_run", func() (*github.CheckRun, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Checks.UpdateCheckRun(ctx, runevent.Organization, runevent.Repository, *checkRunID, opts)
        }</span>)
        <span class="cov8" title="1">return err</span>
}

func isPipelineRunCancelledOrStopped(run *tektonv1.PipelineRun) bool <span class="cov8" title="1">{
        if run == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if run.IsCancelled() || run.IsGracefullyCancelled() || run.IsGracefullyStopped() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func metadataPatch(checkRunID *int64, logURL string) map[string]any <span class="cov8" title="1">{
        return map[string]any{
                "metadata": map[string]any{
                        "labels": map[string]string{
                                keys.CheckRunID: strconv.FormatInt(*checkRunID, 10),
                        },
                        "annotations": map[string]string{
                                keys.LogURL:     logURL,
                                keys.CheckRunID: strconv.FormatInt(*checkRunID, 10),
                        },
                },
        }
}</span>

// createStatusCommit use the classic/old statuses API which is available when we
// don't have a github app token.
func (v *Provider) createStatusCommit(ctx context.Context, runevent *info.Event, status provider.StatusOpts) error <span class="cov8" title="1">{
        var err error
        now := time.Now()
        switch status.Conclusion </span>{
        case "neutral":<span class="cov8" title="1">
                status.Conclusion = "success"</span> // We don't have a choice than setting as success, no pending here.
        case "pending":<span class="cov8" title="1">
                if status.Title != "" </span><span class="cov0" title="0">{
                        status.Conclusion = "pending"
                }</span>
        }
        <span class="cov8" title="1">if status.Status == "in_progress" </span><span class="cov8" title="1">{
                status.Conclusion = "pending"
        }</span>

        <span class="cov8" title="1">ghstatus := &amp;github.RepoStatus{
                State:       github.Ptr(status.Conclusion),
                TargetURL:   github.Ptr(status.DetailsURL),
                Description: github.Ptr(status.Title),
                Context:     github.Ptr(provider.GetCheckName(status, v.pacInfo)),
                CreatedAt:   &amp;github.Timestamp{Time: now},
        }

        if _, _, err := wrapAPI(v, "create_status", func() (*github.RepoStatus, *github.Response, error) </span><span class="cov8" title="1">{
                return v.Client().Repositories.CreateStatus(ctx,
                        runevent.Organization, runevent.Repository, runevent.SHA, ghstatus)
        }</span>); err != nil <span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">eventType := triggertype.IsPullRequestType(runevent.EventType)
        if opscomments.IsAnyOpsEventType(eventType.String()) </span><span class="cov0" title="0">{
                eventType = triggertype.PullRequest
        }</span>

        <span class="cov8" title="1">var commentStrategy string
        if v.repo != nil &amp;&amp; v.repo.Spec.Settings != nil &amp;&amp; v.repo.Spec.Settings.Github != nil </span><span class="cov0" title="0">{
                commentStrategy = v.repo.Spec.Settings.Github.CommentStrategy
        }</span>

        <span class="cov8" title="1">switch commentStrategy </span>{
        case "disable_all":<span class="cov0" title="0">
                v.Logger.Warn("github: comments related to PipelineRuns status have been disabled for Github pull requests")
                return nil</span>
        default:<span class="cov8" title="1">
                if (status.Status == "completed" || (status.Status == "queued" &amp;&amp; status.Title == pendingApproval)) &amp;&amp;
                        status.Text != "" &amp;&amp; eventType == triggertype.PullRequest </span><span class="cov8" title="1">{
                        _, _, err = wrapAPI(v, "create_issue_comment", func() (*github.IssueComment, *github.Response, error) </span><span class="cov8" title="1">{
                                return v.Client().Issues.CreateComment(ctx, runevent.Organization, runevent.Repository,
                                        runevent.PullRequestNumber,
                                        &amp;github.IssueComment{
                                                Body: github.Ptr(fmt.Sprintf("%s&lt;br&gt;%s", status.Summary, status.Text)),
                                        },
                                )
                        }</span>)
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (v *Provider) CreateStatus(ctx context.Context, runevent *info.Event, statusOpts provider.StatusOpts) error <span class="cov8" title="1">{
        if v.ghClient == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot set status on github no token or url set")
        }</span>

        // If the request comes from a bot user, skip setting the status and just log the event silently
        <span class="cov8" title="1">if statusOpts.AccessDenied &amp;&amp; v.userType == botType </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch statusOpts.Conclusion </span>{
        case "success":<span class="cov8" title="1">
                statusOpts.Title = "Success"
                statusOpts.Summary = "has &lt;b&gt;successfully&lt;/b&gt; validated your commit."</span>
        case "failure":<span class="cov8" title="1">
                statusOpts.Title = "Failed"
                statusOpts.Summary = "has &lt;b&gt;failed&lt;/b&gt;."</span>
        case "pending":<span class="cov8" title="1">
                // for concurrency set title as pending
                if statusOpts.Title == "" </span><span class="cov8" title="1">{
                        statusOpts.Title = "Pending"
                        statusOpts.Summary = "is skipping this commit."
                }</span> else<span class="cov0" title="0"> {
                        // for unauthorized user set title as Pending approval
                        statusOpts.Summary = "is waiting for approval."
                }</span>
        case "cancelled":<span class="cov0" title="0">
                statusOpts.Title = "Cancelled"
                statusOpts.Summary = "has been &lt;b&gt;cancelled&lt;/b&gt;."</span>
        case "neutral":<span class="cov8" title="1">
                if statusOpts.Title == "" </span><span class="cov8" title="1">{
                        statusOpts.Title = "Unknown"
                }</span>
                <span class="cov8" title="1">statusOpts.Summary = "&lt;b&gt;Completed&lt;/b&gt;"</span>
        }

        <span class="cov8" title="1">if statusOpts.Status == "in_progress" </span><span class="cov8" title="1">{
                statusOpts.Title = "CI has Started"
                statusOpts.Summary = "is running."
        }</span>

        <span class="cov8" title="1">onPr := ""
        if statusOpts.OriginalPipelineRunName != "" </span><span class="cov0" title="0">{
                onPr = "/" + statusOpts.OriginalPipelineRunName
        }</span>
        <span class="cov8" title="1">statusOpts.Summary = fmt.Sprintf("%s%s %s", v.pacInfo.ApplicationName, onPr, statusOpts.Summary)
        // If we have an installationID which mean we have a github apps and we can use the checkRun API
        if runevent.InstallationID &gt; 0 </span><span class="cov8" title="1">{
                return v.getOrUpdateCheckRunStatus(ctx, runevent, statusOpts)
        }</span>

        // Otherwise use the update status commit API
        <span class="cov8" title="1">return v.createStatusCommit(ctx, runevent, statusOpts)</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package gitlab

import (
        "context"
        "fmt"
        "net/http"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/acl"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        gitlab "gitlab.com/gitlab-org/api/client-go"
)

// IsAllowedOwnersFile get the owner files (OWNERS, OWNERS_ALIASES) from main branch
// and check if we have explicitly allowed the user in there.
func (v *Provider) IsAllowedOwnersFile(_ context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        ownerContent, _, _ := v.getObject("OWNERS", event.DefaultBranch, v.targetProjectID)
        if string(ownerContent) == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        // OWNERS_ALIASES file existence is not required, if we get "not found" continue
        <span class="cov8" title="1">ownerAliasesContent, resp, err := v.getObject("OWNERS_ALIASES", event.DefaultBranch, v.targetProjectID)
        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNotFound </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">allowed, _ := acl.UserInOwnerFile(string(ownerContent), string(ownerAliasesContent), event.Sender)
        return allowed, nil</span>
}

func (v *Provider) checkMembership(ctx context.Context, event *info.Event, userid int) bool <span class="cov8" title="1">{
        // Initialize cache lazily
        if v.memberCache == nil </span><span class="cov8" title="1">{
                v.memberCache = map[int]bool{}
        }</span>

        <span class="cov8" title="1">if allowed, ok := v.memberCache[userid]; ok </span><span class="cov8" title="1">{
                return allowed
        }</span>

        <span class="cov8" title="1">member, _, err := v.Client().ProjectMembers.GetInheritedProjectMember(v.targetProjectID, userid)
        if err != nil </span><span class="cov8" title="1">{
                // If the API call fails, fall back without caching the result so a
                // transient failure can be retried on the next invocation.
                isAllowed, _ := v.IsAllowedOwnersFile(ctx, event)
                return isAllowed
        }</span>

        <span class="cov8" title="1">if member.ID != 0 &amp;&amp; member.ID == userid </span><span class="cov8" title="1">{
                v.memberCache[userid] = true
                return true
        }</span>

        <span class="cov8" title="1">isAllowed, _ := v.IsAllowedOwnersFile(ctx, event)
        v.memberCache[userid] = isAllowed
        return isAllowed</span>
}

func (v *Provider) checkOkToTestCommentFromApprovedMember(ctx context.Context, event *info.Event, page int) (bool, error) <span class="cov8" title="1">{
        var nextPage int
        opt := &amp;gitlab.ListMergeRequestDiscussionsOptions{Page: page}
        discussions, resp, err := v.Client().Discussions.ListMergeRequestDiscussions(v.targetProjectID, event.PullRequestNumber, opt)
        if err != nil || len(discussions) == 0 </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">if resp.NextPage != 0 </span><span class="cov8" title="1">{
                nextPage = resp.NextPage
        }</span>

        <span class="cov8" title="1">for _, discussion := range discussions </span><span class="cov8" title="1">{
                // Iterate through every note in the discussion thread and evaluate them.
                // If a note contains an OK-to-test command, verify the commenter's permission
                // (either project membership or presence in OWNERS/OWNERS_ALIASES).
                for _, note := range discussion.Notes </span><span class="cov8" title="1">{
                        if acl.MatchRegexp(acl.OKToTestCommentRegexp, note.Body) </span><span class="cov8" title="1">{
                                commenterEvent := info.NewEvent()
                                commenterEvent.Event = event.Event
                                commenterEvent.Sender = note.Author.Username
                                commenterEvent.BaseBranch = event.BaseBranch
                                commenterEvent.HeadBranch = event.HeadBranch
                                commenterEvent.DefaultBranch = event.DefaultBranch
                                // We could add caching for membership checks in the future.
                                if v.checkMembership(ctx, commenterEvent, note.Author.ID) </span><span class="cov8" title="1">{
                                        return true, nil
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if nextPage != 0 </span><span class="cov8" title="1">{
                return v.checkOkToTestCommentFromApprovedMember(ctx, event, nextPage)
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}

func (v *Provider) IsAllowed(ctx context.Context, event *info.Event) (bool, error) <span class="cov8" title="1">{
        if v.gitlabClient == nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("no github client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>
        <span class="cov8" title="1">if v.checkMembership(ctx, event, v.userID) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return v.checkOkToTestCommentFromApprovedMember(ctx, event, 1)</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package gitlab

import (
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        gitlab "gitlab.com/gitlab-org/api/client-go"
        "go.uber.org/zap"
)

// Detect detects events and validates if it is a valid gitlab event Pipelines as Code supports and
// decides whether to process or reject it.
// returns a boolean value whether to process or reject, logger with event metadata, and error if any occurred.
func (v *Provider) Detect(req *http.Request, payload string, logger *zap.SugaredLogger) (bool, bool, *zap.SugaredLogger, string, error) <span class="cov8" title="1">{
        isGL := false
        event := req.Header.Get("X-Gitlab-Event")
        if event == "" </span><span class="cov8" title="1">{
                return false, false, logger, "no gitlab event", nil
        }</span>

        // it is a GitLab event
        <span class="cov8" title="1">isGL = true

        setLoggerAndProceed := func(processEvent bool, reason string, err error) (bool, bool, *zap.SugaredLogger,
                string, error,
        ) </span><span class="cov8" title="1">{
                logger = logger.With("provider", "gitlab", "event-id", req.Header.Get("X-Request-Id"))
                return isGL, processEvent, logger, reason, err
        }</span>

        <span class="cov8" title="1">eventInt, err := gitlab.ParseWebhook(gitlab.EventType(event), []byte(payload))
        if err != nil </span><span class="cov8" title="1">{
                return setLoggerAndProceed(false, "", err)
        }</span>
        <span class="cov8" title="1">_ = json.Unmarshal([]byte(payload), &amp;eventInt)

        switch gitEvent := eventInt.(type) </span>{
        case *gitlab.MergeEvent:<span class="cov8" title="1">
                // on a MR update, react only if OldRev is empty (no new commits pushed).
                // If OldRev is empty, it's a metadata-only update (e.g., label changes).
                if gitEvent.ObjectAttributes.Action == "update" &amp;&amp; gitEvent.ObjectAttributes.OldRev == "" </span><span class="cov8" title="1">{
                        if !hasOnlyLabelsChanged(gitEvent) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(false, "this 'Merge Request' update event changes are not supported; cannot proceed", nil)
                        }</span>
                }

                <span class="cov8" title="1">if provider.Valid(gitEvent.ObjectAttributes.Action, []string{"open", "reopen", "update"}) </span><span class="cov8" title="1">{
                        return setLoggerAndProceed(true, "", nil)
                }</span>

                // on a MR Update only react when there is Oldrev set, since this means
                // there is a Push of commit in there
                <span class="cov8" title="1">if gitEvent.ObjectAttributes.Action == "update" &amp;&amp; gitEvent.ObjectAttributes.OldRev != "" </span><span class="cov0" title="0">{
                        return setLoggerAndProceed(true, "", nil)
                }</span>
                <span class="cov8" title="1">if provider.Valid(gitEvent.ObjectAttributes.Action, []string{"open", "reopen", "close"}) </span><span class="cov0" title="0">{
                        return setLoggerAndProceed(true, "", nil)
                }</span>

                <span class="cov8" title="1">return setLoggerAndProceed(false, fmt.Sprintf("not a merge event we care about: \"%s\"", gitEvent.ObjectAttributes.Action), nil)</span>
        case *gitlab.PushEvent, *gitlab.TagEvent:<span class="cov8" title="1">
                return setLoggerAndProceed(true, "", nil)</span>
        case *gitlab.MergeCommentEvent:<span class="cov8" title="1">
                if gitEvent.MergeRequest.State == "opened" </span><span class="cov8" title="1">{
                        return setLoggerAndProceed(true, "", nil)
                }</span>
                <span class="cov0" title="0">return setLoggerAndProceed(false, "comments on closed merge requests is not supported", nil)</span>
        case *gitlab.CommitCommentEvent:<span class="cov8" title="1">
                comment := gitEvent.ObjectAttributes.Note
                if gitEvent.ObjectAttributes.Action == gitlab.CommentEventActionCreate </span><span class="cov8" title="1">{
                        if provider.IsTestRetestComment(comment) || provider.IsCancelComment(comment) </span><span class="cov8" title="1">{
                                return setLoggerAndProceed(true, "", nil)
                        }</span>
                        // truncate comment to make logs readable
                        <span class="cov8" title="1">if len(comment) &gt; 50 </span><span class="cov8" title="1">{
                                comment = comment[:50] + "..."
                        }</span>
                        <span class="cov8" title="1">return setLoggerAndProceed(false, fmt.Sprintf("gitlab: commit_comment: unsupported GitOps comment \"%s\" on pushed commits", comment), nil)</span>
                }
                <span class="cov8" title="1">return setLoggerAndProceed(false, fmt.Sprintf("gitlab: commit_comment: unsupported action \"%s\" with comment \"%s\"", gitEvent.ObjectAttributes.Action, comment), nil)</span>
        default:<span class="cov0" title="0">
                return setLoggerAndProceed(false, "", fmt.Errorf("gitlab: event \"%s\" is not supported", event))</span>
        }
}

// hasOnlyLabelsChanged checks if the only change in the merge request is to its labels.
// This function ensures that other fields remain unchanged.
func hasOnlyLabelsChanged(gitEvent *gitlab.MergeEvent) bool <span class="cov8" title="1">{
        changes := gitEvent.Changes

        labelsChanged := len(changes.Labels.Previous) &gt; 0 || len(changes.Labels.Current) &gt; 0

        // Only Labels can change  everything else must be zero or nil
        onlyUpdatedAtOrLabels := labelsChanged &amp;&amp;
                changes.Assignees.Previous == nil &amp;&amp; changes.Assignees.Current == nil &amp;&amp;
                changes.Reviewers.Previous == nil &amp;&amp; changes.Reviewers.Current == nil &amp;&amp;
                changes.Description.Previous == "" &amp;&amp; changes.Description.Current == "" &amp;&amp;
                changes.MergeStatus.Previous == "" &amp;&amp; changes.MergeStatus.Current == "" &amp;&amp;
                changes.MilestoneID.Previous == 0 &amp;&amp; changes.MilestoneID.Current == 0 &amp;&amp;
                changes.SourceBranch.Previous == "" &amp;&amp; changes.SourceBranch.Current == "" &amp;&amp;
                changes.SourceProjectID.Previous == 0 &amp;&amp; changes.SourceProjectID.Current == 0 &amp;&amp;
                changes.StateID.Previous == 0 &amp;&amp; changes.StateID.Current == 0 &amp;&amp;
                changes.TargetBranch.Previous == "" &amp;&amp; changes.TargetBranch.Current == "" &amp;&amp;
                changes.TargetProjectID.Previous == 0 &amp;&amp; changes.TargetProjectID.Current == 0 &amp;&amp;
                changes.Title.Previous == "" &amp;&amp; changes.Title.Current == ""

        return onlyUpdatedAtOrLabels
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">package gitlab

import (
        "context"
        "crypto/subtle"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/changedfiles"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        providerMetrics "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/metrics"
        gitlab "gitlab.com/gitlab-org/api/client-go"
        "go.uber.org/zap"
)

const (
        apiPublicURL       = "https://gitlab.com"
        taskStatusTemplate = `
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;th&gt;Duration&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;/tr&gt;

{{- range $taskrun := .TaskRunList }}
&lt;tr&gt;
&lt;td&gt;{{ formatCondition $taskrun.PipelineRunTaskRunStatus.Status.Conditions }}&lt;/td&gt;
&lt;td&gt;{{ formatDuration $taskrun.PipelineRunTaskRunStatus.Status.StartTime $taskrun.PipelineRunTaskRunStatus.Status.CompletionTime }}&lt;/td&gt;&lt;td&gt;

{{ $taskrun.ConsoleLogURL }}

&lt;/td&gt;&lt;/tr&gt;
{{- end }}
&lt;/table&gt;`
        noClientErrStr = `no gitlab client has been initialized, exiting... (hint: did you forget setting a secret on your repo?)`
)

var anyMergeRequestEventType = []string{"Merge Request", "MergeRequest"}

var _ provider.Interface = (*Provider)(nil)

type Provider struct {
        gitlabClient      *gitlab.Client
        Logger            *zap.SugaredLogger
        run               *params.Run
        pacInfo           *info.PacOpts
        Token             *string
        targetProjectID   int
        sourceProjectID   int
        userID            int
        pathWithNamespace string
        repoURL           string
        apiURL            string
        eventEmitter      *events.EventEmitter
        repo              *v1alpha1.Repository
        triggerEvent      string
        // memberCache caches membership/permission checks by user ID within the
        // current provider instance lifecycle to avoid repeated API calls.
        memberCache map[int]bool
}

func (v *Provider) Client() *gitlab.Client <span class="cov8" title="1">{
        providerMetrics.RecordAPIUsage(
                v.Logger,
                // URL used instead of "gitlab" to differentiate in the case of a CI cluster which
                // serves multiple GitLab instances
                v.apiURL,
                v.triggerEvent,
                v.repo,
        )
        return v.gitlabClient
}</span>

func (v *Provider) SetGitLabClient(client *gitlab.Client) <span class="cov8" title="1">{
        v.gitlabClient = client
}</span>

func (v *Provider) SetPacInfo(pacInfo *info.PacOpts) <span class="cov0" title="0">{
        v.pacInfo = pacInfo
}</span>

func (v *Provider) CreateComment(_ context.Context, event *info.Event, commit, updateMarker string) error <span class="cov8" title="1">{
        if v.gitlabClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no gitlab client has been initialized")
        }</span>

        <span class="cov8" title="1">if event.PullRequestNumber == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("create comment only works on merge requests")
        }</span>

        // List comments of the merge request
        <span class="cov8" title="1">if updateMarker != "" </span><span class="cov8" title="1">{
                comments, _, err := v.Client().Notes.ListMergeRequestNotes(event.TargetProjectID, event.PullRequestNumber, &amp;gitlab.ListMergeRequestNotesOptions{
                        ListOptions: gitlab.ListOptions{
                                Page:    1,
                                PerPage: 100,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">re := regexp.MustCompile(updateMarker)
                for _, comment := range comments </span><span class="cov8" title="1">{
                        if re.MatchString(comment.Body) </span><span class="cov8" title="1">{
                                _, _, err := v.Client().Notes.UpdateMergeRequestNote(event.TargetProjectID, event.PullRequestNumber, comment.ID, &amp;gitlab.UpdateMergeRequestNoteOptions{
                                        Body: &amp;commit,
                                })
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">_, _, err := v.Client().Notes.CreateMergeRequestNote(event.TargetProjectID, event.PullRequestNumber, &amp;gitlab.CreateMergeRequestNoteOptions{
                Body: &amp;commit,
        })

        return err</span>
}

// CheckPolicyAllowing TODO: Implement ME.
func (v *Provider) CheckPolicyAllowing(_ context.Context, _ *info.Event, _ []string) (bool, string) <span class="cov0" title="0">{
        return false, ""
}</span>

func (v *Provider) SetLogger(logger *zap.SugaredLogger) <span class="cov0" title="0">{
        v.Logger = logger
}</span>

func (v *Provider) Validate(_ context.Context, _ *params.Run, event *info.Event) error <span class="cov8" title="1">{
        token := event.Request.Header.Get("X-Gitlab-Token")
        if event.Provider.WebhookSecret == "" &amp;&amp; token != "" </span><span class="cov8" title="1">{
                return fmt.Errorf("gitlab failed validation: failed to find webhook secret")
        }</span>

        <span class="cov8" title="1">if subtle.ConstantTimeCompare([]byte(event.Provider.WebhookSecret), []byte(token)) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("gitlab failed validation: event's secret doesn't match with webhook secret")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// If I understood properly, you can have "personal" projects and groups
// attached projects. But this doesn't seem to show in the API, so we
// are just doing it the path_with_namespace to get the "org".
//
// Note that "orgs/groups" may have subgroups, so we get the first parts
// as Orgs and the last element as Repo It's just a detail to show for
// UI, we actually don't use this field for access or other logical
// stuff.
func getOrgRepo(pathWithNamespace string) (string, string) <span class="cov8" title="1">{
        org := filepath.Dir(pathWithNamespace)
        return org, filepath.Base(pathWithNamespace)
}</span>

func (v *Provider) GetConfig() *info.ProviderConfig <span class="cov8" title="1">{
        return &amp;info.ProviderConfig{
                TaskStatusTMPL: taskStatusTemplate,
                APIURL:         apiPublicURL,
                Name:           "gitlab",
        }
}</span>

func (v *Provider) SetClient(_ context.Context, run *params.Run, runevent *info.Event, repo *v1alpha1.Repository, eventsEmitter *events.EventEmitter) error <span class="cov8" title="1">{
        var err error
        if runevent.Provider.Token == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("no git_provider.secret has been set in the repo crd")
        }</span>

        // Try to detect automatically the API url if url is not coming from public
        // gitlab. Unless user has set a spec.provider.url in its repo crd
        <span class="cov8" title="1">apiURL := ""
        switch </span>{
        case runevent.Provider.URL != "":<span class="cov8" title="1">
                apiURL = runevent.Provider.URL</span>
        case v.repoURL != "" &amp;&amp; !strings.HasPrefix(v.repoURL, apiPublicURL):<span class="cov8" title="1">
                apiURL = strings.ReplaceAll(v.repoURL, v.pathWithNamespace, "")</span>
        case runevent.URL != "":<span class="cov8" title="1">
                burl, err := url.Parse(runevent.URL)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">apiURL = fmt.Sprintf("%s://%s", burl.Scheme, burl.Host)</span>
        default:<span class="cov8" title="1">
                // this really should not happen but let's just hope this is it
                apiURL = apiPublicURL</span>
        }
        <span class="cov8" title="1">_, err = url.Parse(apiURL)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to parse api url %s: %w", apiURL, err)
        }</span>
        <span class="cov8" title="1">v.apiURL = apiURL

        if v.gitlabClient == nil </span><span class="cov0" title="0">{
                v.gitlabClient, err = gitlab.NewClient(runevent.Provider.Token, gitlab.WithBaseURL(apiURL))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">v.Token = &amp;runevent.Provider.Token

        run.Clients.Log.Infof("gitlab: initialized for client with token for apiURL=%s, org=%s, repo=%s", apiURL, runevent.Organization, runevent.Repository)
        // In a scenario where the source repository is forked and a merge request (MR) is created on the upstream
        // repository, runevent.SourceProjectID will not be 0 when SetClient is called from the pac-watcher code.
        // This is because, in the controller, SourceProjectID is set in the annotation of the pull request,
        // and runevent.SourceProjectID is set before SetClient is called. Therefore, we need to take
        // the ID from runevent.SourceProjectID when v.sourceProject is 0 (nil).
        if v.sourceProjectID == 0 &amp;&amp; runevent.SourceProjectID &gt; 0 </span><span class="cov8" title="1">{
                v.sourceProjectID = runevent.SourceProjectID
        }</span>

        // check that we have access to the source project if it's a private repo, this should only occur on Merge Requests
        <span class="cov8" title="1">if runevent.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                _, resp, err := v.Client().Projects.GetProject(runevent.SourceProjectID, &amp;gitlab.GetProjectOptions{})
                errmsg := fmt.Sprintf("failed to access GitLab source repository ID %d: please ensure token has 'read_repository' scope on that repository",
                        runevent.SourceProjectID)
                if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s", errmsg)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s: %w", errmsg, err)
                }</span>
        }

        // if we don't have sourceProjectID (ie: incoming-webhook) then try to set
        // it ASAP if we can.
        <span class="cov8" title="1">if v.sourceProjectID == 0 &amp;&amp; runevent.Organization != "" &amp;&amp; runevent.Repository != "" </span><span class="cov0" title="0">{
                projectSlug := path.Join(runevent.Organization, runevent.Repository)
                projectinfo, _, err := v.Client().Projects.GetProject(projectSlug, &amp;gitlab.GetProjectOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // TODO: we really need to move out the runevent.*ProjecTID to v.*ProjectID,
                // I just spent half an hour debugging because i didn't realise it was there instead in v.*
                <span class="cov0" title="0">v.sourceProjectID = projectinfo.ID
                runevent.SourceProjectID = projectinfo.ID
                runevent.TargetProjectID = projectinfo.ID
                runevent.DefaultBranch = projectinfo.DefaultBranch</span>
        }
        <span class="cov8" title="1">v.run = run
        v.eventEmitter = eventsEmitter
        v.repo = repo
        v.triggerEvent = runevent.EventType

        return nil</span>
}

//nolint:misspell
func (v *Provider) CreateStatus(_ context.Context, event *info.Event, statusOpts provider.StatusOpts,
) error <span class="cov8" title="1">{
        var detailsURL string
        if v.gitlabClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no gitlab client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>
        <span class="cov8" title="1">switch statusOpts.Conclusion </span>{
        case "skipped":<span class="cov8" title="1">
                statusOpts.Conclusion = "canceled"
                statusOpts.Title = "skipped validating this commit"</span>
        case "neutral":<span class="cov8" title="1">
                statusOpts.Conclusion = "canceled"
                statusOpts.Title = "stopped"</span>
        case "cancelled":<span class="cov8" title="1">
                statusOpts.Conclusion = "canceled"
                statusOpts.Title = "cancelled validating this commit"</span>
        case "failure":<span class="cov8" title="1">
                statusOpts.Conclusion = "failed"
                statusOpts.Title = "failed"</span>
        case "success":<span class="cov8" title="1">
                statusOpts.Conclusion = "success"
                statusOpts.Title = "successfully validated your commit"</span>
        case "completed":<span class="cov8" title="1">
                statusOpts.Conclusion = "success"
                statusOpts.Title = "completed"</span>
        case "pending":<span class="cov8" title="1">
                statusOpts.Conclusion = "running"</span>
        }
        <span class="cov8" title="1">if statusOpts.DetailsURL != "" </span><span class="cov8" title="1">{
                detailsURL = statusOpts.DetailsURL
        }</span>

        <span class="cov8" title="1">onPr := ""
        if statusOpts.OriginalPipelineRunName != "" </span><span class="cov0" title="0">{
                onPr = "/" + statusOpts.OriginalPipelineRunName
        }</span>
        <span class="cov8" title="1">body := fmt.Sprintf("**%s%s** has %s\n\n%s\n\n&lt;small&gt;Full log available [here](%s)&lt;/small&gt;",
                v.pacInfo.ApplicationName, onPr, statusOpts.Title, statusOpts.Text, detailsURL)

        contextName := provider.GetCheckName(statusOpts, v.pacInfo)
        opt := &amp;gitlab.SetCommitStatusOptions{
                State:       gitlab.BuildStateValue(statusOpts.Conclusion),
                Name:        gitlab.Ptr(contextName),
                TargetURL:   gitlab.Ptr(detailsURL),
                Description: gitlab.Ptr(statusOpts.Title),
                Context:     gitlab.Ptr(contextName),
        }

        // In case we have access, set the status. Typically, on a Merge Request (MR)
        // from a fork in an upstream repository, the token needs to have write access
        // to the fork repository in order to create a status. However, the token set on the
        // Repository CR usually doesn't have such broad access, preventing from creating
        // a status comment on it.
        // This would work on a push or an MR from a branch within the same repo.
        // Ignoring errors because of the write access issues,
        _, _, err := v.Client().Commits.SetCommitStatus(event.SourceProjectID, event.SHA, opt)
        if err != nil </span><span class="cov8" title="1">{
                v.Logger.Debugf("cannot set status with the GitLab token on the source project: %v", err)
        }</span> else<span class="cov8" title="1"> {
                // we managed to set the status on the source repo, all good we are done
                v.Logger.Debugf("created commit status on source project ID %d", event.TargetProjectID)
                return nil
        }</span>
        <span class="cov8" title="1">if _, _, err2 := v.Client().Commits.SetCommitStatus(event.TargetProjectID, event.SHA, opt); err2 == nil </span><span class="cov8" title="1">{
                v.Logger.Debugf("created commit status on target project ID %d", event.TargetProjectID)
                // we managed to set the status on the target repo, all good we are done
                return nil
        }</span>
        <span class="cov8" title="1">v.Logger.Debugf("cannot set status with the GitLab token on the target project: %v", err)
        // we only show the first error as it's likely something the user has more control to fix
        // the second err is cryptic as it needs a dummy gitlab pipeline to start
        // with and will only give more confusion in the event namespace
        v.eventEmitter.EmitMessage(v.repo, zap.InfoLevel, "FailedToSetCommitStatus",
                fmt.Sprintf("failed to create commit status: source project ID %d, target project ID %d. "+
                        "If you want Gitlab Pipeline Status update, ensure your GitLab token giving it access "+
                        "to the source repository. %v",
                        event.SourceProjectID, event.TargetProjectID, err))

        eventType := triggertype.IsPullRequestType(event.EventType)
        // When a GitOps command is sent on a pushed commit, it mistakenly treats it as a pull_request
        // and attempts to create a note, but notes are not intended for pushed commits.
        if event.TriggerTarget == triggertype.PullRequest &amp;&amp; opscomments.IsAnyOpsEventType(event.EventType) </span><span class="cov0" title="0">{
                eventType = triggertype.PullRequest
        }</span>

        <span class="cov8" title="1">var commentStrategy string

        if v.repo != nil &amp;&amp; v.repo.Spec.Settings != nil &amp;&amp; v.repo.Spec.Settings.Gitlab != nil </span><span class="cov0" title="0">{
                commentStrategy = v.repo.Spec.Settings.Gitlab.CommentStrategy
        }</span>
        <span class="cov8" title="1">switch commentStrategy </span>{
        case "disable_all":<span class="cov0" title="0">
                v.Logger.Warn("Comments related to PipelineRuns status have been disabled for GitLab merge requests")
                return nil</span>
        default:<span class="cov8" title="1">
                if eventType == triggertype.PullRequest || provider.Valid(event.EventType, anyMergeRequestEventType) </span><span class="cov0" title="0">{
                        mopt := &amp;gitlab.CreateMergeRequestNoteOptions{Body: gitlab.Ptr(body)}
                        _, _, err := v.Client().Notes.CreateMergeRequestNote(event.TargetProjectID, event.PullRequestNumber, mopt)
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (v *Provider) GetTektonDir(_ context.Context, event *info.Event, path, provenance string) (string, error) <span class="cov8" title="1">{
        if v.gitlabClient == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no gitlab client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>
        // default set provenance from head
        <span class="cov8" title="1">revision := event.HeadBranch
        if provenance == "default_branch" </span><span class="cov8" title="1">{
                revision = event.DefaultBranch
                v.Logger.Infof("Using PipelineRun definition from default_branch: %s", event.DefaultBranch)
        }</span> else<span class="cov8" title="1"> {
                trigger := event.TriggerTarget.String()
                if event.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                        trigger = "merge request"
                }</span>
                <span class="cov8" title="1">v.Logger.Infof("Using PipelineRun definition from source %s on commit SHA: %s", trigger, event.SHA)</span>
        }

        <span class="cov8" title="1">opt := &amp;gitlab.ListTreeOptions{
                Path:      gitlab.Ptr(path),
                Ref:       gitlab.Ptr(revision),
                Recursive: gitlab.Ptr(true),
                ListOptions: gitlab.ListOptions{
                        OrderBy:    "id",
                        Pagination: "keyset",
                        PerPage:    20,
                        Sort:       "asc",
                },
        }

        options := []gitlab.RequestOptionFunc{}
        nodes := []*gitlab.TreeNode{}

        for </span><span class="cov8" title="1">{
                objects, resp, err := v.Client().Repositories.ListTree(v.sourceProjectID, opt, options...)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("failed to list %s dir: %w", path, err)
                }</span>
                <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                        return "", nil
                }</span>

                <span class="cov8" title="1">nodes = append(nodes, objects...)

                // Exit the loop when we've seen all pages.
                if resp.NextLink == "" </span><span class="cov8" title="1">{
                        break</span>
                }

                // Otherwise, set param to query the next page
                <span class="cov8" title="1">options = []gitlab.RequestOptionFunc{
                        gitlab.WithKeysetPaginationParameters(resp.NextLink),
                }</span>
        }

        <span class="cov8" title="1">return v.concatAllYamlFiles(nodes, revision)</span>
}

// concatAllYamlFiles concat all yaml files from a directory as one big multi document yaml string.
func (v *Provider) concatAllYamlFiles(objects []*gitlab.TreeNode, revision string) (string, error) <span class="cov8" title="1">{
        var allTemplates string
        for _, value := range objects </span><span class="cov8" title="1">{
                if strings.HasSuffix(value.Name, ".yaml") ||
                        strings.HasSuffix(value.Name, ".yml") </span><span class="cov8" title="1">{
                        data, _, err := v.getObject(value.Path, revision, v.sourceProjectID)
                        if err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if err := provider.ValidateYaml(data, value.Path); err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">if allTemplates != "" &amp;&amp; !strings.HasPrefix(string(data), "---") </span><span class="cov8" title="1">{
                                allTemplates += "---"
                        }</span>
                        <span class="cov8" title="1">allTemplates += "\n" + string(data) + "\n"</span>
                }
        }

        <span class="cov8" title="1">return allTemplates, nil</span>
}

func (v *Provider) getObject(fname, branch string, pid int) ([]byte, *gitlab.Response, error) <span class="cov8" title="1">{
        opt := &amp;gitlab.GetRawFileOptions{
                Ref: gitlab.Ptr(branch),
        }
        file, resp, err := v.Client().RepositoryFiles.GetRawFile(pid, fname, opt)
        if err != nil </span><span class="cov8" title="1">{
                return []byte{}, resp, fmt.Errorf("failed to get filename from api %s dir: %w", fname, err)
        }</span>
        <span class="cov8" title="1">if resp != nil &amp;&amp; resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return []byte{}, resp, nil
        }</span>
        <span class="cov8" title="1">return file, resp, nil</span>
}

func (v *Provider) GetFileInsideRepo(_ context.Context, runevent *info.Event, path, _ string) (string, error) <span class="cov8" title="1">{
        getobj, _, err := v.getObject(path, runevent.HeadBranch, v.sourceProjectID)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(getobj), nil</span>
}

func (v *Provider) GetCommitInfo(_ context.Context, runevent *info.Event) error <span class="cov8" title="1">{
        if v.gitlabClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%s", noClientErrStr)
        }</span>

        // if we don't have a SHA (ie: incoming-webhook) then get it from the branch
        // and populate in the runevent.
        <span class="cov8" title="1">if runevent.SHA == "" &amp;&amp; runevent.HeadBranch != "" </span><span class="cov0" title="0">{
                branchinfo, _, err := v.Client().Commits.GetCommit(v.sourceProjectID, runevent.HeadBranch, &amp;gitlab.GetCommitOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">runevent.SHA = branchinfo.ID
                runevent.SHATitle = branchinfo.Title
                runevent.SHAURL = branchinfo.WebURL</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (v *Provider) GetFiles(_ context.Context, runevent *info.Event) (changedfiles.ChangedFiles, error) <span class="cov8" title="1">{
        if v.gitlabClient == nil </span><span class="cov0" title="0">{
                return changedfiles.ChangedFiles{}, fmt.Errorf("no gitlab client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>
        <span class="cov8" title="1">if runevent.TriggerTarget == triggertype.PullRequest </span><span class="cov8" title="1">{
                opt := &amp;gitlab.ListMergeRequestDiffsOptions{
                        ListOptions: gitlab.ListOptions{
                                OrderBy:    "id",
                                Pagination: "keyset",
                                PerPage:    20,
                                Sort:       "asc",
                        },
                }
                options := []gitlab.RequestOptionFunc{}
                changedFiles := changedfiles.ChangedFiles{}

                for </span><span class="cov8" title="1">{
                        mrchanges, resp, err := v.Client().MergeRequests.ListMergeRequestDiffs(v.targetProjectID, runevent.PullRequestNumber, opt, options...)
                        if err != nil </span><span class="cov8" title="1">{
                                return changedfiles.ChangedFiles{}, err
                        }</span>

                        <span class="cov8" title="1">for _, change := range mrchanges </span><span class="cov8" title="1">{
                                changedFiles.All = append(changedFiles.All, change.NewPath)
                                if change.NewFile </span><span class="cov8" title="1">{
                                        changedFiles.Added = append(changedFiles.Added, change.NewPath)
                                }</span>
                                <span class="cov8" title="1">if change.DeletedFile </span><span class="cov8" title="1">{
                                        changedFiles.Deleted = append(changedFiles.Deleted, change.NewPath)
                                }</span>
                                <span class="cov8" title="1">if !change.RenamedFile &amp;&amp; !change.DeletedFile &amp;&amp; !change.NewFile </span><span class="cov8" title="1">{
                                        changedFiles.Modified = append(changedFiles.Modified, change.NewPath)
                                }</span>
                                <span class="cov8" title="1">if change.RenamedFile </span><span class="cov8" title="1">{
                                        changedFiles.Renamed = append(changedFiles.Renamed, change.NewPath)
                                }</span>
                        }

                        // Exit the loop when we've seen all pages.
                        <span class="cov8" title="1">if resp.NextLink == "" </span><span class="cov8" title="1">{
                                break</span>
                        }

                        // Otherwise, set param to query the next page
                        <span class="cov0" title="0">options = []gitlab.RequestOptionFunc{
                                gitlab.WithKeysetPaginationParameters(resp.NextLink),
                        }</span>
                }
                <span class="cov8" title="1">return changedFiles, nil</span>
        }

        <span class="cov8" title="1">if runevent.TriggerTarget == "push" </span><span class="cov8" title="1">{
                pushChanges, _, err := v.Client().Commits.GetCommitDiff(v.sourceProjectID, runevent.SHA, &amp;gitlab.GetCommitDiffOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return changedfiles.ChangedFiles{}, err
                }</span>
                <span class="cov8" title="1">changedFiles := changedfiles.ChangedFiles{}
                for _, change := range pushChanges </span><span class="cov8" title="1">{
                        changedFiles.All = append(changedFiles.All, change.NewPath)
                        if change.NewFile </span><span class="cov8" title="1">{
                                changedFiles.Added = append(changedFiles.Added, change.NewPath)
                        }</span>
                        <span class="cov8" title="1">if change.DeletedFile </span><span class="cov8" title="1">{
                                changedFiles.Deleted = append(changedFiles.Deleted, change.NewPath)
                        }</span>
                        <span class="cov8" title="1">if !change.RenamedFile &amp;&amp; !change.DeletedFile &amp;&amp; !change.NewFile </span><span class="cov8" title="1">{
                                changedFiles.Modified = append(changedFiles.Modified, change.NewPath)
                        }</span>
                        <span class="cov8" title="1">if change.RenamedFile </span><span class="cov8" title="1">{
                                changedFiles.Renamed = append(changedFiles.Renamed, change.NewPath)
                        }</span>
                }
                <span class="cov8" title="1">return changedFiles, nil</span>
        }
        <span class="cov0" title="0">return changedfiles.ChangedFiles{}, nil</span>
}

func (v *Provider) CreateToken(_ context.Context, _ []string, _ *info.Event) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

// isHeadCommitOfBranch validates that branch exists and the SHA is HEAD commit of the branch.
func (v *Provider) isHeadCommitOfBranch(runevent *info.Event, branchName string) error <span class="cov8" title="1">{
        if v.gitlabClient == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no gitlab client has been initialized, " +
                        "exiting... (hint: did you forget setting a secret on your repo?)")
        }</span>
        <span class="cov8" title="1">branch, _, err := v.Client().Branches.GetBranch(v.sourceProjectID, branchName)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if branch.Commit.ID == runevent.SHA </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("provided SHA %s is not the HEAD commit of the branch %s", runevent.SHA, branchName)</span>
}

func (v *Provider) GetTemplate(commentType provider.CommentType) string <span class="cov0" title="0">{
        return provider.GetHTMLTemplate(commentType)
}</span>
</pre>
		
		<pre class="file" id="file112" style="display: none">package gitlab

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/matcher"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/opscomments"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"

        gitlab "gitlab.com/gitlab-org/api/client-go"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (v *Provider) ParsePayload(ctx context.Context, run *params.Run, request *http.Request,
        payload string,
) (*info.Event, error) <span class="cov8" title="1">{
        event := request.Header.Get("X-Gitlab-Event")
        if event == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find event type in request header")
        }</span>

        <span class="cov8" title="1">payloadB := []byte(payload)
        eventInt, err := gitlab.ParseWebhook(gitlab.EventType(event), payloadB)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">_ = json.Unmarshal(payloadB, &amp;eventInt)

        // Remove the " Hook" suffix so looks better in status, and since we don't
        // really use it anymore we good to do whatever we want with it for
        // cosmetics.
        processedEvent := info.NewEvent()
        processedEvent.EventType = strings.ReplaceAll(event, " Hook", "")
        processedEvent.Event = eventInt
        switch gitEvent := eventInt.(type) </span>{
        case *gitlab.MergeEvent:<span class="cov8" title="1">
                // Organization:  event.GetRepo().GetOwner().GetLogin(),
                processedEvent.Sender = gitEvent.User.Username
                processedEvent.DefaultBranch = gitEvent.Project.DefaultBranch
                processedEvent.URL = gitEvent.Project.WebURL
                processedEvent.SHA = gitEvent.ObjectAttributes.LastCommit.ID
                processedEvent.SHAURL = gitEvent.ObjectAttributes.LastCommit.URL
                processedEvent.SHATitle = gitEvent.ObjectAttributes.LastCommit.Title
                processedEvent.HeadBranch = gitEvent.ObjectAttributes.SourceBranch
                processedEvent.BaseBranch = gitEvent.ObjectAttributes.TargetBranch
                processedEvent.HeadURL = gitEvent.ObjectAttributes.Source.WebURL
                processedEvent.BaseURL = gitEvent.ObjectAttributes.Target.WebURL
                processedEvent.PullRequestNumber = gitEvent.ObjectAttributes.IID
                processedEvent.PullRequestTitle = gitEvent.ObjectAttributes.Title
                v.targetProjectID = gitEvent.Project.ID
                v.sourceProjectID = gitEvent.ObjectAttributes.SourceProjectID
                v.userID = gitEvent.User.ID

                v.pathWithNamespace = gitEvent.ObjectAttributes.Target.PathWithNamespace
                processedEvent.Organization, processedEvent.Repository = getOrgRepo(v.pathWithNamespace)
                processedEvent.SourceProjectID = gitEvent.ObjectAttributes.SourceProjectID
                processedEvent.TargetProjectID = gitEvent.Project.ID

                processedEvent.TriggerTarget = triggertype.PullRequest
                processedEvent.EventType = strings.ReplaceAll(event, " Hook", "")

                // This is a label update, like adding or removing a label from a MR.
                if gitEvent.Changes.Labels.Current != nil </span><span class="cov0" title="0">{
                        processedEvent.EventType = triggertype.PullRequestLabeled.String()
                }</span>
                <span class="cov8" title="1">for _, label := range gitEvent.Labels </span><span class="cov0" title="0">{
                        processedEvent.PullRequestLabel = append(processedEvent.PullRequestLabel, label.Title)
                }</span>
                <span class="cov8" title="1">if gitEvent.ObjectAttributes.Action == "close" </span><span class="cov8" title="1">{
                        processedEvent.TriggerTarget = triggertype.PullRequestClosed
                }</span>
        case *gitlab.TagEvent:<span class="cov8" title="1">
                // GitLab sends same event for both Tag creation and deletion i.e. "Tag Push Hook".
                // if gitEvent.After is containing all zeros and gitEvent.CheckoutSHA is empty
                // it is Delete "Tag Push Hook".
                if isZeroSHA(gitEvent.After) &amp;&amp; gitEvent.CheckoutSHA == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("event Delete %s is not supported", event)
                }</span>

                // sometime in gitlab tag push event contains no commit
                // in this case we're not supposed to process the event.
                <span class="cov8" title="1">if len(gitEvent.Commits) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no commits attached to this %s event", event)
                }</span>

                <span class="cov8" title="1">lastCommitIdx := len(gitEvent.Commits) - 1
                processedEvent.Sender = gitEvent.UserUsername
                processedEvent.DefaultBranch = gitEvent.Project.DefaultBranch
                processedEvent.URL = gitEvent.Project.WebURL
                processedEvent.SHA = gitEvent.Commits[lastCommitIdx].ID
                processedEvent.SHAURL = gitEvent.Commits[lastCommitIdx].URL
                processedEvent.SHATitle = gitEvent.Commits[lastCommitIdx].Title
                processedEvent.HeadBranch = gitEvent.Ref
                processedEvent.BaseBranch = gitEvent.Ref
                processedEvent.HeadURL = gitEvent.Project.WebURL
                processedEvent.BaseURL = processedEvent.HeadURL
                processedEvent.TriggerTarget = "push"
                v.pathWithNamespace = gitEvent.Project.PathWithNamespace
                processedEvent.Organization, processedEvent.Repository = getOrgRepo(v.pathWithNamespace)
                v.targetProjectID = gitEvent.ProjectID
                v.sourceProjectID = gitEvent.ProjectID
                v.userID = gitEvent.UserID
                processedEvent.SourceProjectID = gitEvent.ProjectID
                processedEvent.TargetProjectID = gitEvent.ProjectID
                processedEvent.EventType = strings.ReplaceAll(event, " Hook", "")</span>
        case *gitlab.PushEvent:<span class="cov8" title="1">
                if len(gitEvent.Commits) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("no commits attached to this push event")
                }</span>
                <span class="cov8" title="1">lastCommitIdx := len(gitEvent.Commits) - 1
                processedEvent.Sender = gitEvent.UserUsername
                processedEvent.DefaultBranch = gitEvent.Project.DefaultBranch
                processedEvent.URL = gitEvent.Project.WebURL
                processedEvent.SHA = gitEvent.Commits[lastCommitIdx].ID
                processedEvent.SHAURL = gitEvent.Commits[lastCommitIdx].URL
                processedEvent.SHATitle = gitEvent.Commits[lastCommitIdx].Title
                processedEvent.HeadBranch = gitEvent.Ref
                processedEvent.BaseBranch = gitEvent.Ref
                processedEvent.HeadURL = gitEvent.Project.WebURL
                processedEvent.BaseURL = processedEvent.HeadURL
                processedEvent.TriggerTarget = "push"
                v.pathWithNamespace = gitEvent.Project.PathWithNamespace
                processedEvent.Organization, processedEvent.Repository = getOrgRepo(v.pathWithNamespace)
                v.targetProjectID = gitEvent.ProjectID
                v.sourceProjectID = gitEvent.ProjectID
                v.userID = gitEvent.UserID
                processedEvent.SourceProjectID = gitEvent.ProjectID
                processedEvent.TargetProjectID = gitEvent.ProjectID
                processedEvent.EventType = strings.ToLower(strings.ReplaceAll(event, " Hook", ""))</span>
        case *gitlab.MergeCommentEvent:<span class="cov8" title="1">
                processedEvent.Sender = gitEvent.User.Username
                processedEvent.DefaultBranch = gitEvent.Project.DefaultBranch
                processedEvent.URL = gitEvent.Project.WebURL
                processedEvent.SHA = gitEvent.MergeRequest.LastCommit.ID
                processedEvent.SHAURL = gitEvent.MergeRequest.LastCommit.URL
                processedEvent.SHATitle = gitEvent.MergeRequest.LastCommit.Title
                processedEvent.BaseBranch = gitEvent.MergeRequest.TargetBranch
                processedEvent.HeadBranch = gitEvent.MergeRequest.SourceBranch
                processedEvent.BaseURL = gitEvent.MergeRequest.Target.WebURL
                processedEvent.HeadURL = gitEvent.MergeRequest.Source.WebURL

                opscomments.SetEventTypeAndTargetPR(processedEvent, gitEvent.ObjectAttributes.Note)
                v.pathWithNamespace = gitEvent.Project.PathWithNamespace
                processedEvent.Organization, processedEvent.Repository = getOrgRepo(v.pathWithNamespace)
                processedEvent.TriggerTarget = triggertype.PullRequest

                processedEvent.PullRequestNumber = gitEvent.MergeRequest.IID
                v.targetProjectID = gitEvent.MergeRequest.TargetProjectID
                v.sourceProjectID = gitEvent.MergeRequest.SourceProjectID
                v.userID = gitEvent.User.ID
                processedEvent.SourceProjectID = gitEvent.MergeRequest.SourceProjectID
                processedEvent.TargetProjectID = gitEvent.MergeRequest.TargetProjectID</span>
        case *gitlab.CommitCommentEvent:<span class="cov8" title="1">
                // need run in fetching repository
                v.run = run
                return v.handleCommitCommentEvent(ctx, gitEvent)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("event %s is not supported", event)</span>
        }

        <span class="cov8" title="1">v.repoURL = processedEvent.URL
        return processedEvent, nil</span>
}

func (v *Provider) initGitLabClient(ctx context.Context, event *info.Event) (*info.Event, error) <span class="cov8" title="1">{
        // This is to ensure the base URL of the client is not reinitialized during tests.
        if v.gitlabClient != nil </span><span class="cov8" title="1">{
                return event, nil
        }</span>

        // need repo here to get secret info and create gitlab api client
        <span class="cov0" title="0">repo, err := matcher.MatchEventURLRepo(ctx, v.run, event, "")
        if err != nil </span><span class="cov0" title="0">{
                return event, err
        }</span>

        <span class="cov0" title="0">if repo == nil </span><span class="cov0" title="0">{
                return event, fmt.Errorf("cannot find a repository match for %s", event.URL)
        }</span>

        // should check global repository for secrets
        <span class="cov0" title="0">secretNS := repo.GetNamespace()
        globalRepo, err := v.run.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(v.run.Info.Kube.Namespace).Get(
                ctx, v.run.Info.Controller.GlobalRepository, metav1.GetOptions{},
        )
        if err == nil &amp;&amp; globalRepo != nil </span><span class="cov0" title="0">{
                if repo.Spec.GitProvider != nil &amp;&amp; repo.Spec.GitProvider.Secret == nil &amp;&amp; globalRepo.Spec.GitProvider != nil &amp;&amp; globalRepo.Spec.GitProvider.Secret != nil </span><span class="cov0" title="0">{
                        secretNS = globalRepo.GetNamespace()
                }</span>
                <span class="cov0" title="0">repo.Spec.Merge(globalRepo.Spec)</span>
        }

        <span class="cov0" title="0">kubeInterface, err := kubeinteraction.NewKubernetesInteraction(v.run)
        if err != nil </span><span class="cov0" title="0">{
                return event, err
        }</span>

        <span class="cov0" title="0">scm := pipelineascode.SecretFromRepository{
                K8int:       kubeInterface,
                Config:      v.GetConfig(),
                Event:       event,
                Repo:        repo,
                WebhookType: v.pacInfo.WebhookType,
                Logger:      v.Logger,
                Namespace:   secretNS,
        }
        if err := scm.Get(ctx); err != nil </span><span class="cov0" title="0">{
                return event, fmt.Errorf("cannot get secret from repository: %w", err)
        }</span>

        <span class="cov0" title="0">err = v.SetClient(ctx, v.run, event, repo, v.eventEmitter)
        if err != nil </span><span class="cov0" title="0">{
                return event, err
        }</span>
        <span class="cov0" title="0">return event, nil</span>
}

func (v *Provider) handleCommitCommentEvent(ctx context.Context, event *gitlab.CommitCommentEvent) (*info.Event, error) <span class="cov8" title="1">{
        action := "trigger"
        processedEvent := info.NewEvent()
        if event.Repository == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error parse_payload: the repository in event payload must not be nil")
        }</span>
        // since comment is made on pushed commit, SourceProjectID and TargetProjectID will be equal.
        <span class="cov8" title="1">v.sourceProjectID = event.ProjectID
        v.targetProjectID = event.ProjectID
        processedEvent.SourceProjectID = v.sourceProjectID
        processedEvent.TargetProjectID = v.targetProjectID
        v.userID = event.User.ID
        v.pathWithNamespace = event.Project.PathWithNamespace
        processedEvent.Organization, processedEvent.Repository = getOrgRepo(v.pathWithNamespace)
        processedEvent.Sender = event.User.Username
        processedEvent.Provider.User = processedEvent.Sender
        processedEvent.URL = event.Project.WebURL
        processedEvent.SHA = event.ObjectAttributes.CommitID
        processedEvent.SHATitle = event.Commit.Title
        processedEvent.HeadURL = processedEvent.URL
        processedEvent.BaseURL = processedEvent.URL
        processedEvent.TriggerTarget = triggertype.Push
        opscomments.SetEventTypeAndTargetPR(processedEvent, event.ObjectAttributes.Note)
        // Set Head and Base branch to default_branch of the repo as this comment is made on
        // a pushed commit.
        defaultBranch := event.Project.DefaultBranch
        processedEvent.HeadBranch, processedEvent.BaseBranch = defaultBranch, defaultBranch
        processedEvent.DefaultBranch = defaultBranch

        var (
                branchName string
                prName     string
                tagName    string
                err        error
        )

        // since we're going to make an API call to ensure that the commit is HEAD of the branch
        // therefore we need to initialize GitLab client here
        processedEvent, err = v.initGitLabClient(ctx, processedEvent)
        if err != nil </span><span class="cov0" title="0">{
                return processedEvent, err
        }</span>

        // get PipelineRun name from comment if it does contain e.g. `/test pr7`
        <span class="cov8" title="1">if provider.IsTestRetestComment(event.ObjectAttributes.Note) </span><span class="cov8" title="1">{
                prName, branchName, tagName, err = provider.GetPipelineRunAndBranchOrTagNameFromTestComment(event.ObjectAttributes.Note)
                if err != nil </span><span class="cov8" title="1">{
                        return processedEvent, err
                }</span>
                <span class="cov8" title="1">processedEvent.TargetTestPipelineRun = prName</span>
        }

        <span class="cov8" title="1">if provider.IsCancelComment(event.ObjectAttributes.Note) </span><span class="cov8" title="1">{
                action = "cancellation"
                prName, branchName, tagName, err = provider.GetPipelineRunAndBranchOrTagNameFromCancelComment(event.ObjectAttributes.Note)
                if err != nil </span><span class="cov0" title="0">{
                        return processedEvent, err
                }</span>
                <span class="cov8" title="1">processedEvent.CancelPipelineRuns = true
                processedEvent.TargetCancelPipelineRun = prName</span>
        }

        <span class="cov8" title="1">if tagName != "" </span><span class="cov8" title="1">{
                tagPath := fmt.Sprintf("refs/tags/%s", tagName)
                tag, _, err := v.gitlabClient.Tags.GetTag(v.sourceProjectID, tagName)
                if err != nil </span><span class="cov8" title="1">{
                        return processedEvent, fmt.Errorf("error getting tag %s: %w", tagName, err)
                }</span>

                <span class="cov8" title="1">if tag.Commit.ID != processedEvent.SHA </span><span class="cov8" title="1">{
                        return processedEvent, fmt.Errorf("provided SHA %s is not the tagged commit for the tag %s", processedEvent.SHA, tagName)
                }</span>

                <span class="cov8" title="1">processedEvent.HeadBranch = tagPath
                processedEvent.BaseBranch = tagPath
                return processedEvent, nil</span>
        }

        <span class="cov8" title="1">if branchName == "" </span><span class="cov8" title="1">{
                branchName = processedEvent.HeadBranch
        }</span>

        // check if the commit on which comment is made, is HEAD commit of the branch
        <span class="cov8" title="1">if err := v.isHeadCommitOfBranch(processedEvent, branchName); err != nil </span><span class="cov0" title="0">{
                if provider.IsCancelComment(event.ObjectAttributes.Note) </span><span class="cov0" title="0">{
                        processedEvent.CancelPipelineRuns = false
                }</span>
                <span class="cov0" title="0">return processedEvent, err</span>
        }

        <span class="cov8" title="1">processedEvent.HeadBranch = branchName
        processedEvent.BaseBranch = branchName
        v.Logger.Infof("gitlab commit_comment: pipelinerun %s has been requested on %s/%s#%s", action, processedEvent.Organization, processedEvent.Repository, processedEvent.SHA)
        return processedEvent, nil</span>
}

func isZeroSHA(sha string) bool <span class="cov8" title="1">{
        return sha == "0000000000000000000000000000000000000000"
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package gitlab

import (
        "context"
        "fmt"
        "net/url"
        "regexp"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
)

type gitLabInfo struct {
        Host        string
        GroupOrUser string
        Repository  string
        Revision    string
        FilePath    string
}

// extractGitLabInfo generated with chatGPT https://chatgpt.com/share/e3c06a7e-3f16-4891-85c7-832b3e7f25c5
func extractGitLabInfo(gitlabURL string) (*gitLabInfo, error) <span class="cov8" title="1">{
        parsedURL, err := url.Parse(gitlabURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Regular expression to match the specific GitLab URL pattern
        <span class="cov8" title="1">re := regexp.MustCompile(`^/([^/]+(?:/[^/]+)*)/([^/]+)/-/blob/([^/]+)(/.*)?|^/([^/]+(?:/[^/]+)*)/([^/]+)/-/raw/([^/]+)(/.*)?`)
        matches := re.FindStringSubmatch(parsedURL.Path)

        if len(matches) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("URL does not match the expected GitLab pattern")
        }</span>

        <span class="cov8" title="1">groupOrUser := ""
        repoName := ""
        revision := ""
        filePath := ""

        if matches[1] != "" </span><span class="cov8" title="1">{ // For /blob/ URLs
                groupOrUser = matches[1]
                repoName = matches[2]
                revision = matches[3]
                if len(matches) &gt;= 5 &amp;&amp; matches[4] != "" </span><span class="cov8" title="1">{
                        filePath = matches[4][1:] // Remove initial slash
                }</span>
        } else<span class="cov8" title="1"> if matches[5] != "" </span><span class="cov8" title="1">{ // For /raw/ URLs
                groupOrUser = matches[5]
                repoName = matches[6]
                revision = matches[7]
                if len(matches) &gt;= 9 &amp;&amp; matches[8] != "" </span><span class="cov8" title="1">{
                        filePath = matches[8][1:] // Remove initial slash
                }</span>
        }

        <span class="cov8" title="1">return &amp;gitLabInfo{
                Host:        parsedURL.Host,
                GroupOrUser: groupOrUser,
                Repository:  repoName,
                Revision:    revision,
                FilePath:    filePath,
        }, nil</span>
}

// GetTaskURI if we are getting a URL from the same URL where the provider is,
// it means we can try to get the file with the provider token.
func (v *Provider) GetTaskURI(ctx context.Context, event *info.Event, uri string) (bool, string, error) <span class="cov0" title="0">{
        if ret := provider.CompareHostOfURLS(uri, event.URL); !ret </span><span class="cov0" title="0">{
                return false, "", nil
        }</span>
        <span class="cov0" title="0">extracted, err := extractGitLabInfo(uri)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        <span class="cov0" title="0">nEvent := info.NewEvent()
        nEvent.Organization = extracted.GroupOrUser
        nEvent.Repository = extracted.Repository
        nEvent.BaseBranch = extracted.Revision
        ret, err := v.GetFileInsideRepo(ctx, nEvent, extracted.FilePath, extracted.Revision)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>
        <span class="cov0" title="0">return true, ret, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package metrics

import (
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/metrics"
        "go.uber.org/zap"
)

func RecordAPIUsage(logger *zap.SugaredLogger, provider, eventType string, repo *v1alpha1.Repository) <span class="cov8" title="1">{
        recorder, err := metrics.NewRecorder()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error initializing metrics recorder: %v", err)
        }</span>
        <span class="cov8" title="1">repoName := ""
        namespace := ""
        if repo != nil </span><span class="cov8" title="1">{
                repoName = repo.Name
                namespace = repo.Namespace
        }</span>

        <span class="cov8" title="1">if err := recorder.ReportGitProviderAPIUsage(provider, eventType, namespace, repoName); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error reporting git API usage metrics for %q repository %q in %q namespace: %v", provider, namespace, repoName, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package provider

import (
        "fmt"
        "net/url"
        "regexp"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "gopkg.in/yaml.v2"
)

const ValidationErrorTemplate = `&gt; [!CAUTION]
&gt; There are some errors in your PipelineRun template.

| PipelineRun | Error |
|------|-------|`

var (
        testRetestAllRegex    = regexp.MustCompile(`(?m)^(/retest|/test)\s*$`)
        testRetestSingleRegex = regexp.MustCompile(`(?m)^(/test|/retest)[ \t]+\S+`)
        oktotestRegex         = regexp.MustCompile(`(?m)^/ok-to-test\s*$`)
        cancelAllRegex        = regexp.MustCompile(`(?m)^(/cancel)\s*$`)
        cancelSingleRegex     = regexp.MustCompile(`(?m)^(/cancel)[ \t]+\S+`)
)

const (
        testComment   = "/test"
        retestComment = "/retest"
        cancelComment = "/cancel"
)

const (
        GitHubApp = "GitHubApp"
)

type CommentType int

const (
        StartingPipelineType CommentType = iota
        PipelineRunStatusType
        QueueingPipelineType
)

func GetHTMLTemplate(commentType CommentType) string <span class="cov0" title="0">{
        switch commentType </span>{
        case StartingPipelineType:<span class="cov0" title="0">
                return formatting.StartingPipelineRunHTML</span>
        case PipelineRunStatusType:<span class="cov0" title="0">
                return formatting.PipelineRunStatusHTML</span>
        case QueueingPipelineType:<span class="cov0" title="0">
                return formatting.QueuingPipelineRunHTML</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func GetMarkdownTemplate(commentType CommentType) string <span class="cov0" title="0">{
        switch commentType </span>{
        case StartingPipelineType:<span class="cov0" title="0">
                return formatting.StartingPipelineRunMarkdown</span>
        case PipelineRunStatusType:<span class="cov0" title="0">
                return formatting.PipelineRunStatusMarkDown</span>
        case QueueingPipelineType:<span class="cov0" title="0">
                return formatting.QueuingPipelineRunMarkdown</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func Valid(value string, validValues []string) bool <span class="cov0" title="0">{
        for _, v := range validValues </span><span class="cov0" title="0">{
                if v == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func IsTestRetestComment(comment string) bool <span class="cov8" title="1">{
        return testRetestSingleRegex.MatchString(comment) || testRetestAllRegex.MatchString(comment)
}</span>

func IsOkToTestComment(comment string) bool <span class="cov8" title="1">{
        return oktotestRegex.MatchString(comment)
}</span>

func IsCancelComment(comment string) bool <span class="cov8" title="1">{
        return cancelAllRegex.MatchString(comment) || cancelSingleRegex.MatchString(comment)
}</span>

func GetPipelineRunFromTestComment(comment string) string <span class="cov8" title="1">{
        if strings.Contains(comment, testComment) </span><span class="cov8" title="1">{
                return getNameFromComment(testComment, comment)
        }</span>
        <span class="cov8" title="1">return getNameFromComment(retestComment, comment)</span>
}

func GetPipelineRunFromCancelComment(comment string) string <span class="cov8" title="1">{
        return getNameFromComment(cancelComment, comment)
}</span>

func getNameFromComment(typeOfComment, comment string) string <span class="cov8" title="1">{
        splitTest := strings.Split(comment, typeOfComment)
        // now get the first line
        getFirstLine := strings.Split(splitTest[1], "\n")
        // trim spaces
        return strings.TrimSpace(getFirstLine[0])
}</span>

func GetPipelineRunAndBranchOrTagNameFromTestComment(comment string) (string, string, string, error) <span class="cov8" title="1">{
        if strings.Contains(comment, testComment) </span><span class="cov8" title="1">{
                return getPipelineRunAndBranchOrTagNameFromComment(testComment, comment)
        }</span>
        <span class="cov8" title="1">return getPipelineRunAndBranchOrTagNameFromComment(retestComment, comment)</span>
}

func GetPipelineRunAndBranchOrTagNameFromCancelComment(comment string) (string, string, string, error) <span class="cov8" title="1">{
        return getPipelineRunAndBranchOrTagNameFromComment(cancelComment, comment)
}</span>

// getPipelineRunAndBranchOrTagNameFromComment function will take GitOps comment and split the comment
// by /test, /retest or /cancel to return branch name and pipelinerun name.
func getPipelineRunAndBranchOrTagNameFromComment(typeOfComment, comment string) (string, string, string, error) <span class="cov8" title="1">{
        var prName, branchName, tagName string
        // avoid parsing error due to branch name contains /test, /retest or /cancel,
        // here only split the first keyword and not split the later keywords.
        splitText := strings.SplitN(comment, typeOfComment, 2)

        // after the split get the second part of the typeOfComment (/test, /retest or /cancel)
        // as second part can be branch name or pipelinerun name and branch name
        // ex: /test branch:nightly, /test prname branch:nightly, /test prname branch:nightly key=value
        if splitText[1] != "" &amp;&amp; strings.Contains(splitText[1], ":") </span><span class="cov8" title="1">{
                branchData := strings.Split(splitText[1], ":")

                // make sure no other word is supported other than branch word
                if !strings.Contains(splitText[1], "branch:") &amp;&amp; !strings.Contains(splitText[1], "tag:") </span><span class="cov8" title="1">{
                        return prName, branchName, tagName, fmt.Errorf("the GitOps comment `%s` does not contain a branch or tag word", comment)
                }</span>

                <span class="cov8" title="1">if strings.Contains(splitText[1], "tag") </span><span class="cov0" title="0">{
                        tagName = getBranchOrTagNameFromComment(splitText[1], "tag")
                }</span> else<span class="cov8" title="1"> {
                        branchName = getBranchOrTagNameFromComment(splitText[1], "branch")
                }</span>

                // if data after the split contains prname then fetch that
                <span class="cov8" title="1">prData := strings.Split(strings.TrimSpace(branchData[0]), " ")
                if len(prData) &gt; 1 </span><span class="cov8" title="1">{
                        prName = strings.TrimSpace(prData[0])
                }</span>
        } else<span class="cov8" title="1"> {
                // get the second part of the typeOfComment (/test, /retest or /cancel)
                // as second part contains pipelinerun name
                // ex: /test prname
                getFirstLine := strings.Split(splitText[1], "\n")
                // trim spaces
                // adapt for the comment contains the key=value pair
                prName = strings.Split(strings.TrimSpace(getFirstLine[0]), " ")[0]
        }</span>
        <span class="cov8" title="1">return prName, branchName, tagName, nil</span>
}

// getBranchOrTagNameFromComment extracts the tag or branch name that follows the "tag:" or "branch:" marker in
// the provided comment. It allows optional whitespace after the colon and
// returns the first contiguous non-whitespace token (e.g., "v1.2.3"). If no
// such token is found, it returns an empty string.
func getBranchOrTagNameFromComment(comment, prefix string) string <span class="cov8" title="1">{
        re := regexp.MustCompile(fmt.Sprintf(`%s:\s*(\S+)`, prefix))
        matches := re.FindStringSubmatch(comment)
        if len(matches) &gt; 1 </span><span class="cov8" title="1">{
                return matches[1]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// CompareHostOfURLS compares the host of two parsed URLs and returns true if
// they are.
func CompareHostOfURLS(uri1, uri2 string) bool <span class="cov8" title="1">{
        u1, err := url.Parse(uri1)
        if err != nil || u1.Host == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">u2, err := url.Parse(uri2)
        if err != nil || u2.Host == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return u1.Host == u2.Host</span>
}

func ValidateYaml(content []byte, filename string) error <span class="cov0" title="0">{
        var validYaml any
        if err := yaml.Unmarshal(content, &amp;validYaml); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error unmarshalling yaml file %s: %w", filename, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetCheckName returns the name of the check to be created based on the status
// and the pacopts.
// If the pacopts.ApplicationName is set, it will be used as the check name.
// Otherwise, the OriginalPipelineRunName will be used.
// If the OriginalPipelineRunName is not set, an empty string will be returned.
// The check name will be in the format "ApplicationName / OriginalPipelineRunName".
func GetCheckName(status StatusOpts, pacopts *info.PacOpts) string <span class="cov8" title="1">{
        if pacopts.ApplicationName != "" </span><span class="cov8" title="1">{
                if status.OriginalPipelineRunName == "" </span><span class="cov8" title="1">{
                        return pacopts.ApplicationName
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%s / %s", pacopts.ApplicationName, status.OriginalPipelineRunName)</span>
        }
        <span class="cov8" title="1">return status.OriginalPipelineRunName</span>
}

func IsZeroSHA(sha string) bool <span class="cov0" title="0">{
        return sha == "0000000000000000000000000000000000000000"
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package random

import (
        "crypto/rand"
)

const (
        letterBytes   = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" // 52 possibilities
        letterIdxBits = 6                                                      // 6 bits to represent 64 possibilities / indexes
        letterIdxMask = 1&lt;&lt;letterIdxBits - 1                                   // All 1-bits, as many as letterIdxBits
)

// AlphaString returns a random alphanumeric string of the requested length
// https://stackoverflow.com/a/35615565/145125
func AlphaString(length int) string <span class="cov8" title="1">{
        result := make([]byte, length)
        bufferSize := int(float64(length) * 1.3)
        for i, j, randomBytes := 0, 0, []byte{}; i &lt; length; j++ </span><span class="cov8" title="1">{
                if j%bufferSize == 0 </span><span class="cov8" title="1">{
                        randomBytes = secureRandomBytes(bufferSize)
                }</span>
                <span class="cov8" title="1">if idx := int(randomBytes[j%length] &amp; letterIdxMask); idx &lt; len(letterBytes) </span><span class="cov8" title="1">{
                        result[i] = letterBytes[idx]
                        i++
                }</span>
        }

        <span class="cov8" title="1">return string(result)</span>
}

// secureRandomBytes returns the requested number of bytes using crypto/rand.
func secureRandomBytes(length int) []byte <span class="cov8" title="1">{
        randomBytes := make([]byte, length)
        _, _ = rand.Read(randomBytes)
        return randomBytes
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">package reconciler

import (
        "context"
        "strconv"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
)

func (r *Reconciler) cleanupPipelineRuns(ctx context.Context, logger *zap.SugaredLogger, pacInfo *info.PacOpts, repo *v1alpha1.Repository, pr *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        keepMaxPipeline, ok := pr.Annotations[keys.MaxKeepRuns]
        if ok </span><span class="cov8" title="1">{
                maxVal, err := strconv.Atoi(keepMaxPipeline)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // if annotation value is more than max limit defined in config then use from config
                <span class="cov8" title="1">if pacInfo.MaxKeepRunsUpperLimit &gt; 0 &amp;&amp; maxVal &gt; pacInfo.MaxKeepRunsUpperLimit </span><span class="cov8" title="1">{
                        logger.Infof("max-keep-run value in annotation (%v) is more than max-keep-run-upper-limit (%v), so using upper-limit", maxVal, pacInfo.MaxKeepRunsUpperLimit)
                        maxVal = pacInfo.MaxKeepRunsUpperLimit
                }</span>
                <span class="cov8" title="1">err = r.kinteract.CleanupPipelines(ctx, logger, repo, pr, maxVal)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        // if annotation is not defined but default max-keep-run value is defined then use that
        <span class="cov8" title="1">if pacInfo.DefaultMaxKeepRuns &gt; 0 </span><span class="cov8" title="1">{
                maxVal := pacInfo.DefaultMaxKeepRuns

                err := r.kinteract.CleanupPipelines(ctx, logger, repo, pr, maxVal)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package reconciler

import (
        "context"
        "path"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/injection/informers/pipelinesascode/v1alpha1/repository"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/metrics"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/sync"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        tektonPipelineRunInformerv1 "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        tektonPipelineRunReconcilerv1 "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        "k8s.io/apimachinery/pkg/types"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/system"
)

func NewController() func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, _ configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                ctx = info.StoreNS(ctx, system.Namespace())
                log := logging.FromContext(ctx)

                run := params.New()
                err := run.Clients.NewClients(ctx, &amp;run.Info)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("failed to init clients : ", err)
                }</span>

                <span class="cov0" title="0">kinteract, err := kubeinteraction.NewKubernetesInteraction(run)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal("failed to init kinit client : ", err)
                }</span>

                // Start pac config syncer
                <span class="cov0" title="0">go params.StartConfigSync(ctx, run)

                pipelineRunInformer := tektonPipelineRunInformerv1.Get(ctx)
                metrics, err := metrics.NewRecorder()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to create pipeline as code metrics recorder %v", err)
                }</span>

                <span class="cov0" title="0">r := &amp;Reconciler{
                        run:               run,
                        kinteract:         kinteract,
                        pipelineRunLister: pipelineRunInformer.Lister(),
                        repoLister:        repository.Get(ctx).Lister(),
                        qm:                sync.NewQueueManager(run.Clients.Log),
                        metrics:           metrics,
                        eventEmitter:      events.NewEventEmitter(run.Clients.Kube, run.Clients.Log),
                }
                impl := tektonPipelineRunReconcilerv1.NewImpl(ctx, r, ctrlOpts())

                if err := r.qm.InitQueues(ctx, run.Clients.Tekton, run.Clients.PipelineAsCode); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("failed to init queues", err)
                }</span>

                <span class="cov0" title="0">if _, err := pipelineRunInformer.Informer().AddEventHandler(controller.HandleAll(checkStateAndEnqueue(impl))); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register PipelineRun informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}

// enqueue only the pipelineruns which are in `started` state
// pipelinerun will have a label `pipelinesascode.tekton.dev/state` to describe the state.
func checkStateAndEnqueue(impl *controller.Impl) func(obj any) <span class="cov8" title="1">{
        return func(obj any) </span><span class="cov8" title="1">{
                object, err := kmeta.DeletionHandlingAccessor(obj)
                if err == nil </span><span class="cov8" title="1">{
                        _, exist := object.GetAnnotations()[keys.State]
                        if exist </span><span class="cov8" title="1">{
                                impl.EnqueueKey(types.NamespacedName{Namespace: object.GetNamespace(), Name: object.GetName()})
                        }</span>
                }
        }
}

func ctrlOpts() func(impl *controller.Impl) controller.Options <span class="cov8" title="1">{
        return func(_ *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                return controller.Options{
                        FinalizerName: path.Join(pipelinesascode.GroupName, pipelinesascode.FinalizerName),
                        PromoteFilterFunc: func(obj any) bool </span><span class="cov8" title="1">{
                                _, exist := obj.(*tektonv1.PipelineRun).GetAnnotations()[keys.State]
                                return exist
                        }</span>,
                }
        }
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package reconciler

import (
        "fmt"
        "time"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/apis"
)

func (r *Reconciler) emitMetrics(pr *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        if err := r.countPipelineRun(pr); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">if err := r.calculatePRDuration(pr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) countPipelineRun(pr *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        gitProvider := pr.GetAnnotations()[keys.GitProvider]
        eventType := pr.GetAnnotations()[keys.EventType]
        repository := pr.GetAnnotations()[keys.Repository]

        switch gitProvider </span>{
        case "github", "github-enterprise":<span class="cov8" title="1">
                if _, ok := pr.GetAnnotations()[keys.InstallationID]; ok </span><span class="cov8" title="1">{
                        gitProvider += "-app"
                }</span> else<span class="cov8" title="1"> {
                        gitProvider += "-webhook"
                }</span>
        case "gitlab", "gitea", "bitbucket-cloud", "bitbucket-datacenter":<span class="cov8" title="1">
                gitProvider += "-webhook"</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("no supported Git provider")</span>
        }

        <span class="cov8" title="1">return r.metrics.Count(gitProvider, eventType, pr.GetNamespace(), repository)</span>
}

func (r *Reconciler) calculatePRDuration(pr *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        repository := pr.GetAnnotations()[keys.Repository]
        duration := time.Duration(0)
        if pr.Status.StartTime != nil </span><span class="cov8" title="1">{
                duration = time.Since(pr.Status.StartTime.Time)
                if pr.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                        duration = pr.Status.CompletionTime.Sub(pr.Status.StartTime.Time)
                }</span>
        }

        <span class="cov8" title="1">cond := pr.Status.GetCondition(apis.ConditionSucceeded)
        status := "success"
        if cond.Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                status = "failed"
                if cond.Reason == tektonv1.PipelineRunReasonCancelled.String() </span><span class="cov8" title="1">{
                        status = "cancelled"
                }</span>
        }
        <span class="cov8" title="1">reason := cond.Reason

        return r.metrics.CountPRDuration(pr.GetNamespace(), repository, status, reason, duration)</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package reconciler

import (
        "context"
        "fmt"
        "strconv"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/triggertype"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketcloud"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/bitbucketdatacenter"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitea"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/github"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider/gitlab"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
)

// detectProvider detects the git provider for the given PipelineRun and
// initializes the corresponding provider interface. It returns the provider
// interface, event information, and an error if any occurs during detection or
// initialization.
//
// Supported providers: github, gitlab, bitbucket-cloud, bitbucket-datacenter, gitea
// any new provider should be added to the switch case below.
func (r *Reconciler) detectProvider(ctx context.Context, logger *zap.SugaredLogger, pr *tektonv1.PipelineRun) (provider.Interface, *info.Event, error) <span class="cov8" title="1">{
        gitProvider, ok := pr.GetAnnotations()[keys.GitProvider]
        if !ok </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed to detect git provider for pipleinerun %s : git-provider label not found", pr.GetName())
        }</span>

        <span class="cov8" title="1">event := buildEventFromPipelineRun(pr)

        var provider provider.Interface
        switch gitProvider </span>{
        case "github", "github-enterprise":<span class="cov0" title="0">
                gh := github.New()
                gh.Logger = logger
                gh.Run = r.run
                if event.InstallationID != 0 </span><span class="cov0" title="0">{
                        if err := gh.InitAppClient(ctx, r.run.Clients.Kube, event); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                }
                <span class="cov0" title="0">provider = gh</span>
        case "gitlab":<span class="cov8" title="1">
                provider = &amp;gitlab.Provider{}</span>
        case "bitbucket-cloud":<span class="cov0" title="0">
                provider = &amp;bitbucketcloud.Provider{}</span>
        case "bitbucket-datacenter":<span class="cov0" title="0">
                provider = &amp;bitbucketdatacenter.Provider{}</span>
        case "gitea":<span class="cov0" title="0">
                provider = &amp;gitea.Provider{}</span>
        default:<span class="cov8" title="1">
                return nil, nil, fmt.Errorf("failed to detect provider for pipelinerun: %s : unknown provider", pr.GetName())</span>
        }
        <span class="cov8" title="1">provider.SetLogger(logger)
        return provider, event, nil</span>
}

func buildEventFromPipelineRun(pr *tektonv1.PipelineRun) *info.Event <span class="cov8" title="1">{
        event := info.NewEvent()

        prAnno := pr.GetAnnotations()

        event.URL = prAnno[keys.RepoURL]
        event.Organization = prAnno[keys.URLOrg]
        event.Repository = prAnno[keys.URLRepository]
        event.EventType = prAnno[keys.EventType]
        event.TriggerTarget = triggertype.StringToType(prAnno[keys.EventType])
        event.BaseBranch = prAnno[keys.Branch]
        event.SHA = prAnno[keys.SHA]

        event.SHATitle = prAnno[keys.ShaTitle]
        event.SHAURL = prAnno[keys.ShaURL]

        prNumber := prAnno[keys.PullRequest]
        if prNumber != "" </span><span class="cov8" title="1">{
                event.PullRequestNumber, _ = strconv.Atoi(prNumber)
                event.TriggerTarget = triggertype.PullRequest
        }</span>

        // GitHub
        <span class="cov8" title="1">if installationID, ok := prAnno[keys.InstallationID]; ok </span><span class="cov8" title="1">{
                id, _ := strconv.Atoi(installationID)
                event.InstallationID = int64(id)
        }</span>
        <span class="cov8" title="1">if gheURL, ok := prAnno[keys.GHEURL]; ok </span><span class="cov8" title="1">{
                event.GHEURL = gheURL
        }</span>

        // GitLab
        <span class="cov8" title="1">if projectID, ok := prAnno[keys.SourceProjectID]; ok </span><span class="cov8" title="1">{
                event.SourceProjectID, _ = strconv.Atoi(projectID)
        }</span>
        <span class="cov8" title="1">if projectID, ok := prAnno[keys.TargetProjectID]; ok </span><span class="cov8" title="1">{
                event.TargetProjectID, _ = strconv.Atoi(projectID)
        }</span>
        <span class="cov8" title="1">return event</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package reconciler

import (
        "context"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

func (r *Reconciler) FinalizeKind(ctx context.Context, pr *tektonv1.PipelineRun) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        state, exist := pr.GetAnnotations()[keys.State]
        if !exist || state == kubeinteraction.StateCompleted </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if state == kubeinteraction.StateQueued || state == kubeinteraction.StateStarted </span><span class="cov8" title="1">{
                repoName, ok := pr.GetAnnotations()[keys.Repository]
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">repo, err := r.repoLister.Repositories(pr.Namespace).Get(repoName)
                // if repository is not found then remove the queue for that repository if exist
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        r.qm.RemoveRepository(&amp;v1alpha1.Repository{
                                ObjectMeta: metav1.ObjectMeta{Name: repoName, Namespace: pr.Namespace},
                        })
                        return nil
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">r.secretNS = repo.GetNamespace()
                if r.globalRepo, err = r.repoLister.Repositories(r.run.Info.Kube.Namespace).Get(r.run.Info.Controller.GlobalRepository); err == nil &amp;&amp; r.globalRepo != nil </span><span class="cov0" title="0">{
                        if repo.Spec.GitProvider != nil &amp;&amp; repo.Spec.GitProvider.Secret == nil &amp;&amp; r.globalRepo.Spec.GitProvider != nil &amp;&amp; r.globalRepo.Spec.GitProvider.Secret != nil </span><span class="cov0" title="0">{
                                r.secretNS = r.globalRepo.GetNamespace()
                        }</span>
                        <span class="cov0" title="0">repo.Spec.Merge(r.globalRepo.Spec)</span>
                }
                <span class="cov8" title="1">logger = logger.With("namespace", repo.Namespace)
                next := r.qm.RemoveAndTakeItemFromQueue(repo, pr)
                if next != "" </span><span class="cov0" title="0">{
                        key := strings.Split(next, "/")
                        pr, err := r.run.Clients.Tekton.TektonV1().PipelineRuns(key[0]).Get(ctx, key[1], metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := r.
                                updatePipelineRunToInProgress(ctx, logger, repo, pr); err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("failed to update status: %w", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package reconciler

import (
        "context"
        "fmt"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        pacAPIv1alpha1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/sync"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (r *Reconciler) queuePipelineRun(ctx context.Context, logger *zap.SugaredLogger, pr *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        order, exist := pr.GetAnnotations()[keys.ExecutionOrder]
        if !exist </span><span class="cov8" title="1">{
                // if the pipelineRun doesn't have order label then wait
                return nil
        }</span>

        // check if annotation exist
        <span class="cov8" title="1">repoName, exist := pr.GetAnnotations()[keys.Repository]
        if !exist </span><span class="cov8" title="1">{
                return fmt.Errorf("no %s annotation found", keys.Repository)
        }</span>
        <span class="cov8" title="1">if repoName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("annotation %s is empty", keys.Repository)
        }</span>
        <span class="cov8" title="1">repo, err := r.repoLister.Repositories(pr.Namespace).Get(repoName)
        if err != nil </span><span class="cov8" title="1">{
                // if repository is not found, then skip processing the pipelineRun and return nil
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        r.qm.RemoveRepository(&amp;pacAPIv1alpha1.Repository{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      repoName,
                                        Namespace: pr.Namespace,
                                },
                        })
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("error getting PipelineRun: %w", err)</span>
        }

        // merge local repo with global repo here in order to derive settings from global
        // for further concurrency and other operations.
        <span class="cov8" title="1">if r.globalRepo, err = r.repoLister.Repositories(r.run.Info.Kube.Namespace).Get(r.run.Info.Controller.GlobalRepository); err == nil &amp;&amp; r.globalRepo != nil </span><span class="cov8" title="1">{
                logger.Info("Merging global repository settings with local repository settings")
                repo.Spec.Merge(r.globalRepo.Spec)
        }</span>

        // if concurrency was set and later removed or changed to zero
        // then remove pipelineRun from Queue and update pending state to running
        <span class="cov8" title="1">if repo.Spec.ConcurrencyLimit != nil &amp;&amp; *repo.Spec.ConcurrencyLimit == 0 </span><span class="cov0" title="0">{
                _ = r.qm.RemoveAndTakeItemFromQueue(repo, pr)
                if err := r.updatePipelineRunToInProgress(ctx, logger, repo, pr); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update PipelineRun to in_progress: %w", err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">var processed bool
        var itered int
        maxIterations := 5

        orderedList := sync.FilterPipelineRunByState(ctx, r.run.Clients.Tekton, strings.Split(order, ","), tektonv1.PipelineRunSpecStatusPending, kubeinteraction.StateQueued)
        for </span><span class="cov8" title="1">{
                acquired, err := r.qm.AddListToRunningQueue(repo, orderedList)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add to queue: %s: %w", pr.GetName(), err)
                }</span>
                <span class="cov8" title="1">if len(acquired) == 0 </span><span class="cov8" title="1">{
                        logger.Infof("no new PipelineRun acquired for repo %s", repo.GetName())
                        break</span>
                }

                <span class="cov8" title="1">for _, prKeys := range acquired </span><span class="cov8" title="1">{
                        nsName := strings.Split(prKeys, "/")
                        repoKey := sync.RepoKey(repo)
                        pr, err = r.run.Clients.Tekton.TektonV1().PipelineRuns(nsName[0]).Get(ctx, nsName[1], metav1.GetOptions{})
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Info("failed to get pr with namespace and name: ", nsName[0], nsName[1])
                                _ = r.qm.RemoveFromQueue(repoKey, prKeys)
                        }</span> else<span class="cov0" title="0"> {
                                if err := r.updatePipelineRunToInProgress(ctx, logger, repo, pr); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("failed to update pipelineRun to in_progress: %w", err)
                                        _ = r.qm.RemoveFromQueue(repoKey, prKeys)
                                }</span> else<span class="cov0" title="0"> {
                                        processed = true
                                }</span>
                        }
                }
                <span class="cov8" title="1">if processed </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if itered &gt;= maxIterations </span><span class="cov8" title="1">{
                        return fmt.Errorf("max iterations reached of %d times trying to get a pipelinerun started for %s", maxIterations, repo.GetName())
                }</span>
                <span class="cov8" title="1">itered++</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package reconciler

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        tektonv1lister "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/action"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/customparams"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/events"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        pacapi "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/listers/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/metrics"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        pac "github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/sync"
)

// Reconciler implements controller.Reconciler for PipelineRun resources.
type Reconciler struct {
        run               *params.Run
        repoLister        pacapi.RepositoryLister
        pipelineRunLister tektonv1lister.PipelineRunLister
        kinteract         kubeinteraction.Interface
        qm                sync.QueueManagerInterface
        metrics           *metrics.Recorder
        eventEmitter      *events.EventEmitter
        globalRepo        *v1alpha1.Repository
        secretNS          string
}

var (
        _ pipelinerunreconciler.Interface = (*Reconciler)(nil)
        _ pipelinerunreconciler.Finalizer = (*Reconciler)(nil)
)

// ReconcileKind is the main entry point for reconciling PipelineRun resources.
func (r *Reconciler) ReconcileKind(ctx context.Context, pr *tektonv1.PipelineRun) pkgreconciler.Event <span class="cov8" title="1">{
        ctx = info.StoreNS(ctx, system.Namespace())
        logger := logging.FromContext(ctx).With("namespace", pr.GetNamespace())

        logger.Debugf("reconciling pipelineRun %s/%s", pr.GetNamespace(), pr.GetName())

        // make sure we have the latest pipelinerun to reconcile, since there is something updating at the same time
        lpr, err := r.run.Clients.Tekton.TektonV1().PipelineRuns(pr.GetNamespace()).Get(ctx, pr.GetName(), metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot get pipelineRun: %w", err)
        }</span>

        <span class="cov8" title="1">if lpr.GetResourceVersion() != pr.GetResourceVersion() </span><span class="cov0" title="0">{
                logger.Debugf("Skipping reconciliation, pipelineRun was updated (cached version %s vs fresh version %s)", pr.GetResourceVersion(), lpr.GetResourceVersion())
                return nil
        }</span>

        // if pipelineRun is in completed or failed state then return
        <span class="cov8" title="1">state, exist := pr.GetAnnotations()[keys.State]
        if exist &amp;&amp; (state == kubeinteraction.StateCompleted || state == kubeinteraction.StateFailed) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">reason := ""
        if len(pr.Status.GetConditions()) &gt; 0 </span><span class="cov8" title="1">{
                reason = pr.Status.GetConditions()[0].GetReason()
        }</span>
        // This condition handles cases where the PipelineRun has entered a "Running" state,
        // but its status in the Git provider remains "queued" (e.g., due to updates made by
        // another controller outside PaC). To maintain consistency between the PipelineRun
        // status and the Git provider status, we update both the PipelineRun resource and
        // the corresponding status on the Git provider here.
        <span class="cov8" title="1">scmReportingPLRStarted, exist := pr.GetAnnotations()[keys.SCMReportingPLRStarted]
        startReported := exist &amp;&amp; scmReportingPLRStarted == "true"
        logger.Debugf("pipelineRun %s/%s scmReportingPLRStarted=%v, exist=%v", pr.GetNamespace(), pr.GetName(), startReported, exist)

        if reason == string(tektonv1.PipelineRunReasonRunning) &amp;&amp; !startReported </span><span class="cov8" title="1">{
                logger.Infof("pipelineRun %s/%s is running but not yet reported to provider, updating status", pr.GetNamespace(), pr.GetName())
                repoName := pr.GetAnnotations()[keys.Repository]
                repo, err := r.repoLister.Repositories(pr.Namespace).Get(repoName)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get repository CR: %w", err)
                }</span>
                <span class="cov8" title="1">return r.updatePipelineRunToInProgress(ctx, logger, repo, pr)</span>
        }
        <span class="cov8" title="1">logger.Debugf("pipelineRun %s/%s condition not met: reason='%s', startReported=%v", pr.GetNamespace(), pr.GetName(), reason, startReported)

        // if its a GitHub App pipelineRun PR then process only if check run id is added otherwise wait
        if _, ok := pr.Annotations[keys.InstallationID]; ok </span><span class="cov0" title="0">{
                if _, ok := pr.Annotations[keys.CheckRunID]; !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        // queue pipelines which are in queued state and pending status
        // if status is not pending, it could be cancelled so let it be reported, even if state is queued
        <span class="cov8" title="1">if state == kubeinteraction.StateQueued &amp;&amp; pr.Spec.Status == tektonv1.PipelineRunSpecStatusPending </span><span class="cov8" title="1">{
                return r.queuePipelineRun(ctx, logger, pr)
        }</span>

        <span class="cov8" title="1">if !pr.IsDone() &amp;&amp; !pr.IsCancelled() </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If we have a controllerInfo annotation, then we need to get the
        // configmap configuration for it
        //
        // The annotation is a json string with a label, the pac controller
        // configmap and the GitHub app secret .
        //
        // We always assume the controller is in the same namespace as the original
        // controller but that may changes
        <span class="cov0" title="0">if controllerInfo, ok := pr.GetAnnotations()[keys.ControllerInfo]; ok </span><span class="cov0" title="0">{
                var parsedControllerInfo *info.ControllerInfo
                if err := json.Unmarshal([]byte(controllerInfo), &amp;parsedControllerInfo); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse controllerInfo: %w", err)
                }</span>
                <span class="cov0" title="0">r.run.Info.Controller = parsedControllerInfo</span>
        } else<span class="cov0" title="0"> {
                r.run.Info.Controller = info.GetControllerInfoFromEnvOrDefault()
        }</span>

        <span class="cov0" title="0">ctx = info.StoreCurrentControllerName(ctx, r.run.Info.Controller.Name)

        logFields := []interface{}{
                "pipeline-run", pr.GetName(),
                "event-sha", pr.GetAnnotations()[keys.SHA],
        }

        // Add source repository URL if available
        if repoURL := pr.GetAnnotations()[keys.RepoURL]; repoURL != "" </span><span class="cov0" title="0">{
                logFields = append(logFields, "source-repo-url", repoURL)
        }</span>

        // Add branch information if available
        <span class="cov0" title="0">if targetBranch := pr.GetAnnotations()[keys.Branch]; targetBranch != "" </span><span class="cov0" title="0">{
                logFields = append(logFields, "target-branch", targetBranch)
                if sourceBranch := pr.GetAnnotations()[keys.SourceBranch]; sourceBranch != "" &amp;&amp; sourceBranch != targetBranch </span><span class="cov0" title="0">{
                        logFields = append(logFields, "source-branch", sourceBranch)
                }</span>
        }

        // Add event type information if available
        <span class="cov0" title="0">if eventType := pr.GetAnnotations()[keys.EventType]; eventType != "" </span><span class="cov0" title="0">{
                logFields = append(logFields, "event-type", eventType)
        }</span>

        <span class="cov0" title="0">logger = logger.With(logFields...)
        logger.Infof("pipelineRun %v/%v is done, reconciling to report status!  ", pr.GetNamespace(), pr.GetName())
        r.eventEmitter.SetLogger(logger)

        // use same pac opts across the reconciliation
        pacInfo := r.run.Info.GetPacOpts()

        detectedProvider, event, err := r.detectProvider(ctx, logger, pr)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("detectProvider: %v", err)
                r.eventEmitter.EmitMessage(nil, zap.ErrorLevel, "RepositoryDetectProvider", msg)
                return nil
        }</span>
        <span class="cov0" title="0">detectedProvider.SetPacInfo(&amp;pacInfo)

        if repo, err := r.reportFinalStatus(ctx, logger, &amp;pacInfo, event, pr, detectedProvider); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("report status: %v", err)
                r.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "RepositoryReportFinalStatus", msg)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) reportFinalStatus(ctx context.Context, logger *zap.SugaredLogger, pacInfo *info.PacOpts, event *info.Event, pr *tektonv1.PipelineRun, provider provider.Interface) (*v1alpha1.Repository, error) <span class="cov8" title="1">{
        repoName := pr.GetAnnotations()[keys.Repository]
        repo, err := r.repoLister.Repositories(pr.Namespace).Get(repoName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reportFinalStatus: %w", err)
        }</span>

        <span class="cov8" title="1">r.secretNS = repo.GetNamespace()
        if r.globalRepo, err = r.repoLister.Repositories(r.run.Info.Kube.Namespace).Get(r.run.Info.Controller.GlobalRepository); err == nil &amp;&amp; r.globalRepo != nil </span><span class="cov0" title="0">{
                if repo.Spec.GitProvider != nil &amp;&amp; repo.Spec.GitProvider.Secret == nil &amp;&amp; r.globalRepo.Spec.GitProvider != nil &amp;&amp; r.globalRepo.Spec.GitProvider.Secret != nil </span><span class="cov0" title="0">{
                        r.secretNS = r.globalRepo.GetNamespace()
                }</span>
                <span class="cov0" title="0">repo.Spec.Merge(r.globalRepo.Spec)</span>
        }

        <span class="cov8" title="1">cp := customparams.NewCustomParams(event, repo, r.run, r.kinteract, r.eventEmitter, nil)
        maptemplate, _, err := cp.GetParams(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.eventEmitter.EmitMessage(repo, zap.ErrorLevel, "ParamsError",
                        fmt.Sprintf("error processing repository CR custom params: %s", err.Error()))
        }</span>
        <span class="cov8" title="1">r.run.Clients.ConsoleUI().SetParams(maptemplate)

        if event.InstallationID &gt; 0 </span><span class="cov8" title="1">{
                event.Provider.WebhookSecret, _ = pac.GetCurrentNSWebhookSecret(ctx, r.kinteract, r.run)
        }</span> else<span class="cov0" title="0"> {
                secretFromRepo := pac.SecretFromRepository{
                        K8int:       r.kinteract,
                        Config:      provider.GetConfig(),
                        Event:       event,
                        Repo:        repo,
                        WebhookType: pacInfo.WebhookType,
                        Logger:      logger,
                        Namespace:   r.secretNS,
                }
                if err := secretFromRepo.Get(ctx); err != nil </span><span class="cov0" title="0">{
                        return repo, fmt.Errorf("cannot get secret from repository: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if r.run.Clients.Log == nil </span><span class="cov8" title="1">{
                r.run.Clients.Log = logger
        }</span>
        <span class="cov8" title="1">err = provider.SetClient(ctx, r.run, event, repo, r.eventEmitter)
        if err != nil </span><span class="cov0" title="0">{
                return repo, fmt.Errorf("cannot set client: %w", err)
        }</span>

        <span class="cov8" title="1">finalState := kubeinteraction.StateCompleted
        newPr, err := r.postFinalStatus(ctx, logger, pacInfo, provider, event, pr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to post final status, moving on: %v", err)
                finalState = kubeinteraction.StateFailed
        }</span>

        <span class="cov8" title="1">if err := r.updateRepoRunStatus(ctx, logger, newPr, repo, event); err != nil </span><span class="cov0" title="0">{
                return repo, fmt.Errorf("cannot update run status: %w", err)
        }</span>

        <span class="cov8" title="1">if _, err := r.updatePipelineRunState(ctx, logger, pr, finalState); err != nil </span><span class="cov0" title="0">{
                return repo, fmt.Errorf("cannot update state: %w", err)
        }</span>

        <span class="cov8" title="1">if err := r.emitMetrics(pr); err != nil </span><span class="cov8" title="1">{
                logger.Error("failed to emit metrics: ", err)
        }</span>

        // remove pipelineRun from Queue and start the next one
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                next := r.qm.RemoveAndTakeItemFromQueue(repo, pr)
                if next == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">key := strings.Split(next, "/")
                pr, err := r.run.Clients.Tekton.TektonV1().PipelineRuns(key[0]).Get(ctx, key[1], metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("cannot get pipeline for next in queue: %w", err)
                        continue</span>
                }

                <span class="cov0" title="0">if err := r.updatePipelineRunToInProgress(ctx, logger, repo, pr); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to update status: %w", err)
                        _ = r.qm.RemoveFromQueue(sync.RepoKey(repo), sync.PrKey(pr))
                        continue</span>
                }
                <span class="cov0" title="0">break</span>
        }

        <span class="cov8" title="1">if err := r.cleanupPipelineRuns(ctx, logger, pacInfo, repo, pr); err != nil </span><span class="cov0" title="0">{
                return repo, fmt.Errorf("error cleaning pipelineruns: %w", err)
        }</span>

        <span class="cov8" title="1">return repo, nil</span>
}

func (r *Reconciler) updatePipelineRunToInProgress(ctx context.Context, logger *zap.SugaredLogger, repo *v1alpha1.Repository, pr *tektonv1.PipelineRun) error <span class="cov8" title="1">{
        pr, err := r.updatePipelineRunState(ctx, logger, pr, kubeinteraction.StateStarted)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot update state: %w", err)
        }</span>
        <span class="cov8" title="1">pacInfo := r.run.Info.GetPacOpts()
        detectedProvider, event, err := r.detectProvider(ctx, logger, pr)
        if err != nil </span><span class="cov8" title="1">{
                logger.Error(err)
                return nil
        }</span>
        <span class="cov0" title="0">detectedProvider.SetPacInfo(&amp;pacInfo)

        if event.InstallationID &gt; 0 </span><span class="cov0" title="0">{
                event.Provider.WebhookSecret, _ = pac.GetCurrentNSWebhookSecret(ctx, r.kinteract, r.run)
        }</span> else<span class="cov0" title="0"> {
                // secretNS is needed when git provider is other than Github.
                secretNS := repo.GetNamespace()
                if repo.Spec.GitProvider != nil &amp;&amp; repo.Spec.GitProvider.Secret == nil &amp;&amp; r.globalRepo != nil &amp;&amp; r.globalRepo.Spec.GitProvider != nil &amp;&amp; r.globalRepo.Spec.GitProvider.Secret != nil </span><span class="cov0" title="0">{
                        secretNS = r.globalRepo.GetNamespace()
                }</span>

                <span class="cov0" title="0">secretFromRepo := pac.SecretFromRepository{
                        K8int:       r.kinteract,
                        Config:      detectedProvider.GetConfig(),
                        Event:       event,
                        Repo:        repo,
                        WebhookType: pacInfo.WebhookType,
                        Logger:      logger,
                        Namespace:   secretNS,
                }
                if err := secretFromRepo.Get(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot get secret from repository: %w", err)
                }</span>
        }

        <span class="cov0" title="0">err = detectedProvider.SetClient(ctx, r.run, event, repo, r.eventEmitter)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot set client: %w", err)
        }</span>

        <span class="cov0" title="0">consoleURL := r.run.Clients.ConsoleUI().DetailURL(pr)

        mt := formatting.MessageTemplate{
                PipelineRunName: pr.GetName(),
                Namespace:       repo.GetNamespace(),
                ConsoleName:     r.run.Clients.ConsoleUI().GetName(),
                ConsoleURL:      consoleURL,
                TknBinary:       settings.TknBinaryName,
                TknBinaryURL:    settings.TknBinaryURL,
        }
        msg, err := mt.MakeTemplate(detectedProvider.GetTemplate(provider.StartingPipelineType))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot create message template: %w", err)
        }</span>
        <span class="cov0" title="0">status := provider.StatusOpts{
                Status:                  "in_progress",
                Conclusion:              "pending",
                Text:                    msg,
                DetailsURL:              consoleURL,
                PipelineRunName:         pr.GetName(),
                PipelineRun:             pr,
                OriginalPipelineRunName: pr.GetAnnotations()[keys.OriginalPRName],
        }

        if err := createStatusWithRetry(ctx, logger, detectedProvider, event, status); err != nil </span><span class="cov0" title="0">{
                // if failed to report status for running state, let the pipelineRun continue,
                // pipelineRun is already started so we will try again once it completes
                logger.Errorf("failed to report status to running on provider continuing! error: %v", err)
                return nil
        }</span>

        <span class="cov0" title="0">logger.Info("updated in_progress status on provider platform for pipelineRun ", pr.GetName())
        return nil</span>
}

func (r *Reconciler) updatePipelineRunState(ctx context.Context, logger *zap.SugaredLogger, pr *tektonv1.PipelineRun, state string) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        currentState := pr.GetAnnotations()[keys.State]
        logger.Infof("updating pipelineRun %v/%v state from %s to %s", pr.GetNamespace(), pr.GetName(), currentState, state)
        annotations := map[string]string{
                keys.State: state,
        }
        if state == kubeinteraction.StateStarted </span><span class="cov8" title="1">{
                annotations[keys.SCMReportingPLRStarted] = "true"
        }</span>

        <span class="cov8" title="1">mergePatch := map[string]any{
                "metadata": map[string]any{
                        "labels": map[string]string{
                                keys.State: state,
                        },
                        "annotations": annotations,
                },
        }

        // if state is started then remove pipelineRun pending status
        if state == kubeinteraction.StateStarted </span><span class="cov8" title="1">{
                mergePatch["spec"] = map[string]any{
                        "status": "",
                }
        }</span>
        <span class="cov8" title="1">actionLog := state + " state"
        patchedPR, err := action.PatchPipelineRun(ctx, logger, actionLog, r.run.Clients.Tekton, pr, mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return pr, fmt.Errorf("error patching the pipelinerun: %w", err)
        }</span>
        <span class="cov8" title="1">return patchedPR, nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package reconciler

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/google/go-github/v74/github"
        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        pacv1a1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        kstatus "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction/status"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/pipelineascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/sort"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

const (
        maxPipelineRunStatusRun = 5
)

var backoffSchedule = []time.Duration{
        1 * time.Second,
        3 * time.Second,
        5 * time.Second,
}

func (r *Reconciler) updateRepoRunStatus(ctx context.Context, logger *zap.SugaredLogger, pr *tektonv1.PipelineRun, repo *pacv1a1.Repository, event *info.Event) error <span class="cov8" title="1">{
        refsanitized := formatting.SanitizeBranch(event.BaseBranch)
        repoStatus := pacv1a1.RepositoryRunStatus{
                Status:          pr.Status.Status,
                PipelineRunName: pr.Name,
                StartTime:       pr.Status.StartTime,
                CompletionTime:  pr.Status.CompletionTime,
                SHA:             &amp;event.SHA,
                SHAURL:          &amp;event.SHAURL,
                Title:           &amp;event.SHATitle,
                LogURL:          github.Ptr(r.run.Clients.ConsoleUI().DetailURL(pr)),
                EventType:       &amp;event.EventType,
                TargetBranch:    &amp;refsanitized,
        }

        // Get repository again in case it was updated while we were running the CI
        // we try multiple time until we get right in case of conflicts.
        // that's what the error message tell us anyway, so i guess we listen.
        maxRun := 10
        for i := 0; i &lt; maxRun; i++ </span><span class="cov8" title="1">{
                lastrepo, err := r.run.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(
                        pr.GetNamespace()).Get(ctx, repo.Name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Append PipelineRun status files to the repo status
                <span class="cov8" title="1">if len(lastrepo.Status) &gt;= maxPipelineRunStatusRun </span><span class="cov0" title="0">{
                        copy(lastrepo.Status, lastrepo.Status[len(lastrepo.Status)-maxPipelineRunStatusRun+1:])
                        lastrepo.Status = lastrepo.Status[:maxPipelineRunStatusRun-1]
                }</span>

                <span class="cov8" title="1">lastrepo.Status = append(lastrepo.Status, repoStatus)
                nrepo, err := r.run.Clients.PipelineAsCode.PipelinesascodeV1alpha1().Repositories(lastrepo.Namespace).Update(
                        ctx, lastrepo, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Infof("Could not update repo %s, retrying %d/%d: %s", lastrepo.Namespace, i, maxRun, err.Error())
                        continue</span>
                }
                <span class="cov8" title="1">logger.Infof("Repository status of %s has been updated", nrepo.Name)
                logger.Warn("The `pipelinerun_status` field in the Repository CR is scheduled for deprecation and will be removed in a future release. Please avoid relying on it.")
                return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("cannot update %s", repo.Name)</span>
}

func (r *Reconciler) getFailureSnippet(ctx context.Context, pr *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        lines := int64(settings.DefaultSettings().ErrorLogSnippetNumberOfLines)
        if r.run.Info.Pac != nil </span><span class="cov0" title="0">{
                lines = int64(r.run.Info.Pac.ErrorLogSnippetNumberOfLines)
        }</span>
        <span class="cov8" title="1">taskinfos := kstatus.CollectFailedTasksLogSnippet(ctx, r.run, r.kinteract, pr, lines)
        if len(taskinfos) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">sortedTaskInfos := sort.TaskInfos(taskinfos)
        text := strings.TrimSpace(sortedTaskInfos[0].LogSnippet)
        if text == "" </span><span class="cov0" title="0">{
                text = sortedTaskInfos[0].Message
        }</span>
        <span class="cov8" title="1">name := sortedTaskInfos[0].Name
        if sortedTaskInfos[0].DisplayName != "" </span><span class="cov0" title="0">{
                name = strings.ToLower(sortedTaskInfos[0].DisplayName)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("task &lt;b&gt;%s&lt;/b&gt; has the status &lt;b&gt;\"%s\"&lt;/b&gt;:\n&lt;pre&gt;%s&lt;/pre&gt;", name, sortedTaskInfos[0].Reason, text)</span>
}

func (r *Reconciler) postFinalStatus(ctx context.Context, logger *zap.SugaredLogger, pacInfo *info.PacOpts, vcx provider.Interface, event *info.Event, createdPR *tektonv1.PipelineRun) (*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        pr, err := r.run.Clients.Tekton.TektonV1().PipelineRuns(createdPR.GetNamespace()).Get(
                ctx, createdPR.GetName(), metav1.GetOptions{},
        )
        if err != nil </span><span class="cov0" title="0">{
                return pr, err
        }</span>

        <span class="cov8" title="1">trStatus := kstatus.GetStatusFromTaskStatusOrFromAsking(ctx, pr, r.run)
        var taskStatusText string
        if len(trStatus) &gt; 0 </span><span class="cov8" title="1">{
                var err error
                taskStatusText, err = sort.TaskStatusTmpl(pr, trStatus, r.run, vcx.GetConfig())
                if err != nil </span><span class="cov0" title="0">{
                        return pr, err
                }</span>
        } else<span class="cov8" title="1"> {
                taskStatusText = pr.Status.GetCondition(apis.ConditionSucceeded).Message
        }</span>

        <span class="cov8" title="1">namespaceURL := r.run.Clients.ConsoleUI().NamespaceURL(pr)
        consoleURL := r.run.Clients.ConsoleUI().DetailURL(pr)
        mt := formatting.MessageTemplate{
                PipelineRunName: pr.GetName(),
                Namespace:       pr.GetNamespace(),
                NamespaceURL:    namespaceURL,
                ConsoleName:     r.run.Clients.ConsoleUI().GetName(),
                ConsoleURL:      consoleURL,
                TknBinary:       settings.TknBinaryName,
                TknBinaryURL:    settings.TknBinaryURL,
                TaskStatus:      taskStatusText,
        }
        if pacInfo.ErrorLogSnippet </span><span class="cov8" title="1">{
                failures := r.getFailureSnippet(ctx, pr)
                if failures != "" </span><span class="cov8" title="1">{
                        secretValues := secrets.GetSecretsAttachedToPipelineRun(ctx, r.kinteract, pr)
                        failures = secrets.ReplaceSecretsInText(failures, secretValues)
                        mt.FailureSnippet = failures
                }</span>
        }
        <span class="cov8" title="1">var tmplStatusText string
        if tmplStatusText, err = mt.MakeTemplate(vcx.GetTemplate(provider.PipelineRunStatusType)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create message template: %w", err)
        }</span>

        <span class="cov8" title="1">status := provider.StatusOpts{
                Status:                  pipelineascode.CompletedStatus,
                PipelineRun:             pr,
                Conclusion:              formatting.PipelineRunStatus(pr),
                Text:                    tmplStatusText,
                PipelineRunName:         pr.Name,
                DetailsURL:              r.run.Clients.ConsoleUI().DetailURL(pr),
                OriginalPipelineRunName: pr.GetAnnotations()[apipac.OriginalPRName],
        }

        err = createStatusWithRetry(ctx, logger, vcx, event, status)
        logger.Infof("pipelinerun %s has a status of '%s'", pr.Name, status.Conclusion)
        return pr, err</span>
}

func createStatusWithRetry(ctx context.Context, logger *zap.SugaredLogger, vcx provider.Interface, event *info.Event, status provider.StatusOpts) error <span class="cov8" title="1">{
        var finalError error
        for _, backoff := range backoffSchedule </span><span class="cov8" title="1">{
                err := vcx.CreateStatus(ctx, event, status)
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">logger.Infof("failed to create status, error: %v, retrying in %v", err, backoff)
                time.Sleep(backoff)
                finalError = err</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("failed to report status: %w", finalError)</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package resolve

import (
        "context"
        "fmt"
        "net/url"
        "path"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/matcher"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

type NamedItem interface {
        GetName() string
}

func alreadyFetchedResource[T NamedItem](resources map[string]T, resourceName string) bool <span class="cov8" title="1">{
        if _, ok := resources[resourceName]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Tries to assemble task FQDNs based on the base URL
// of a remote pipeline.
//
// If there isn't a remote pipeline reference for the current
// run, tasks are returned as they are. Any task with an already
// valid URL is skipped.
func assembleTaskFQDNs(pipelineURL string, tasks []string) ([]string, error) <span class="cov8" title="1">{
        if pipelineURL == "" </span><span class="cov0" title="0">{
                return tasks, nil // no pipeline URL, return tasks as is
        }</span>

        <span class="cov8" title="1">pURL, err := url.Parse(pipelineURL)
        if err != nil </span><span class="cov0" title="0">{
                return tasks, err
        }</span>
        // pop the pipeline file path from the URL
        <span class="cov8" title="1">pURL.Path = path.Dir(pURL.Path)

        taskURLS := make([]string, len(tasks))
        for i, t := range tasks </span><span class="cov8" title="1">{
                tURL, err := url.Parse(t)
                if err == nil &amp;&amp; tURL.Scheme != "" &amp;&amp; tURL.Host != "" </span><span class="cov8" title="1">{
                        taskURLS[i] = t
                        continue</span> // it's already an absolute URL
                }
                <span class="cov8" title="1">tURL = pURL
                tURL = tURL.JoinPath(t)
                taskURLS[i] = tURL.String()</span>
        }
        <span class="cov8" title="1">return taskURLS, nil</span>
}

// resolveRemoteResources will get remote tasks or Pipelines from annotations.
//
// It already has some tasks or pipeline coming from the tekton directory stored in [types]
//
// The precedence logic for tasks is in this order:
//
// * Tasks from the PipelineRun annotations
// * Tasks from the Pipeline annotations
// * Tasks from the Tekton directory
//
// The precedence logic for Pipeline is first from PipelineRun annotations and
// then from Tekton directory.
func resolveRemoteResources(ctx context.Context, rt *matcher.RemoteTasks, types TektonTypes, ropt *Opts) ([]*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        // contain Resources fetched for the event
        fetchedResourcesForEvent := FetchedResources{
                Tasks:     map[string]*tektonv1.Task{},
                Pipelines: map[string]*tektonv1.Pipeline{},
        }
        pipelineRuns := []*tektonv1.PipelineRun{}
        for _, pipelinerun := range types.PipelineRuns </span><span class="cov8" title="1">{
                // contain Resources specific to run
                fetchedResourcesForPipelineRun := FetchedResourcesForRun{
                        Tasks:       map[string]*tektonv1.Task{},
                        PipelineURL: "",
                }
                var pipeline *tektonv1.Pipeline
                var err error
                if ropt.RemoteTasks </span><span class="cov8" title="1">{
                        // no annotations on run, then skip
                        if pipelinerun.GetObjectMeta().GetAnnotations() == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if len(pipelinerun.GetObjectMeta().GetAnnotations()) == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // get first all the pipeline from the pipelinerun annotations
                        <span class="cov8" title="1">remotePipeline, err := matcher.GrabPipelineFromAnnotations(pipelinerun.GetObjectMeta().GetAnnotations())
                        if err != nil </span><span class="cov0" title="0">{
                                return []*tektonv1.PipelineRun{}, fmt.Errorf("error getting remote pipeline from pipelinerun annotations: %w", err)
                        }</span>

                        // if we got the pipeline name from annotation, we need to fetch the pipeline
                        <span class="cov8" title="1">if remotePipeline != "" </span><span class="cov8" title="1">{
                                // making sure that the pipeline with same annotation name is not fetched
                                if alreadyFetchedResource(fetchedResourcesForEvent.Pipelines, remotePipeline) </span><span class="cov0" title="0">{
                                        rt.Logger.Debugf("skipping already fetched pipeline %s in annotations on pipelinerun %s", remotePipeline, pipelinerun.GetName())
                                        // already fetched, then just get the pipeline to add to run specific Resources
                                        pipeline = fetchedResourcesForEvent.Pipelines[remotePipeline]
                                }</span> else<span class="cov8" title="1"> {
                                        // seems like a new pipeline, fetch it based on name in annotation
                                        pipeline, err = rt.GetPipelineFromAnnotationName(ctx, remotePipeline)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return []*tektonv1.PipelineRun{}, fmt.Errorf("error getting remote pipeline from pipelinerun annotations: %w", err)
                                        }</span>
                                        // add the pipeline to the Resources fetched for the Event
                                        <span class="cov8" title="1">fetchedResourcesForEvent.Pipelines[remotePipeline] = pipeline
                                        // add the pipeline URL to the run specific Resources
                                        fetchedResourcesForPipelineRun.PipelineURL = remotePipeline</span>
                                }
                        }
                }
                <span class="cov8" title="1">pipelineTasks := []string{}
                // if run is referring to the pipelineRef and pipeline fetched from annotation have name equal to the pipelineRef
                if pipelinerun.Spec.PipelineRef != nil &amp;&amp; pipelinerun.Spec.PipelineRef.Resolver == "" </span><span class="cov8" title="1">{
                        if pipeline == nil || pipeline.Name != pipelinerun.Spec.PipelineRef.Name </span><span class="cov8" title="1">{
                                // if pipeline fetched from annotation is not having same name as PipelineRef, then we need to get a local pipeline if exist by same name
                                pipeline, err = getPipelineByName(pipelinerun.Spec.PipelineRef.Name, types.Pipelines)
                                if err != nil </span><span class="cov8" title="1">{
                                        return []*tektonv1.PipelineRun{}, err
                                }</span>
                        }
                        // add the pipeline to the run specific Resources
                        <span class="cov8" title="1">fetchedResourcesForPipelineRun.Pipeline = pipeline
                        // grab the tasks, that we may need to fetch for this pipeline from its annotations
                        if pipeline.GetObjectMeta().GetAnnotations() != nil </span><span class="cov8" title="1">{
                                // get all the tasks from the pipeline annotations
                                pipelineTasks, err = matcher.GrabTasksFromAnnotations(pipeline.GetObjectMeta().GetAnnotations())
                                if err != nil </span><span class="cov0" title="0">{
                                        return []*tektonv1.PipelineRun{}, fmt.Errorf("error getting remote task from pipeline annotations: %w", err)
                                }</span>
                                // check for relative task references and assemble FQDNs
                                <span class="cov8" title="1">pipelineTasks, err = assembleTaskFQDNs(fetchedResourcesForPipelineRun.PipelineURL, pipelineTasks)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []*tektonv1.PipelineRun{}, err
                                }</span>
                        }
                }

                // now start fetching the tasks
                <span class="cov8" title="1">if ropt.RemoteTasks </span><span class="cov8" title="1">{
                        // first get all the tasks from the pipelinerun annotations
                        remoteTasks, err := matcher.GrabTasksFromAnnotations(pipelinerun.GetObjectMeta().GetAnnotations())
                        if err != nil </span><span class="cov8" title="1">{
                                return []*tektonv1.PipelineRun{}, fmt.Errorf("error getting remote task from pipelinerun annotations: %w", err)
                        }</span>

                        // now fetch all the tasks from pipelinerun and pipeline annotations, giving preference to pipelinerun annotation tasks
                        <span class="cov8" title="1">for _, remoteTask := range append(remoteTasks, pipelineTasks...) </span><span class="cov8" title="1">{
                                var task *tektonv1.Task
                                // if task is already fetched in the event, then just copy the task
                                if alreadyFetchedResource(fetchedResourcesForEvent.Tasks, remoteTask) </span><span class="cov8" title="1">{
                                        rt.Logger.Debugf("skipping already fetched task %s in annotations on pipelinerun %s", remoteTask, pipelinerun.GetName())
                                        task = fetchedResourcesForEvent.Tasks[remoteTask]
                                }</span> else<span class="cov8" title="1"> {
                                        // get the task from annotation name
                                        task, err = rt.GetTaskFromAnnotationName(ctx, remoteTask)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return []*tektonv1.PipelineRun{}, fmt.Errorf("error getting remote task from pipelinerun annotations: %w", err)
                                        }</span>
                                        // add the newly fetched tasks to fetchedResourcesForEvent with key annotation value
                                        <span class="cov8" title="1">fetchedResourcesForEvent.Tasks[remoteTask] = task</span>
                                }
                                // now checking if run specific resources already contain a task with same name, then don't add it
                                // this is to give preference to the pipelinerun annotation then pipeline annotation
                                <span class="cov8" title="1">if !alreadyFetchedResource(fetchedResourcesForPipelineRun.Tasks, task.GetName()) </span><span class="cov8" title="1">{
                                        rt.Logger.Infof("skipping remote task %s as already fetched task %s for pipelinerun %s", remoteTask, task.GetName(), pipelinerun.GetName())
                                        fetchedResourcesForPipelineRun.Tasks[task.GetName()] = task
                                }</span>
                        }
                }

                // now add all the tasks in .tekton directory to Tasks, as we add them by default if not found in annotation
                // we will skip the ones which exist in run specific resources with same name
                <span class="cov8" title="1">for _, task := range types.Tasks </span><span class="cov8" title="1">{
                        if alreadyFetchedResource(fetchedResourcesForPipelineRun.Tasks, task.GetName()) </span><span class="cov8" title="1">{
                                rt.Logger.Infof("overriding task %s coming from .tekton directory by an annotation task for pipelinerun %s", task.GetName(), pipelinerun.GetName())
                                continue</span>
                        }
                        <span class="cov8" title="1">fetchedResourcesForPipelineRun.Tasks[task.GetName()] = task</span>
                }

                // if PipelineRef is used then, first resolve pipeline and replace all taskRef{Finally/Task} of Pipeline, then put inlinePipeline in PipelineRun
                <span class="cov8" title="1">if pipelinerun.Spec.PipelineRef != nil &amp;&amp; pipelinerun.Spec.PipelineRef.Resolver == "" </span><span class="cov8" title="1">{
                        pipelineResolved := fetchedResourcesForPipelineRun.Pipeline
                        turns, err := inlineTasks(pipelineResolved.Spec.Tasks, ropt, fetchedResourcesForPipelineRun)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pipelineResolved.Spec.Tasks = turns

                        fruns, err := inlineTasks(pipelineResolved.Spec.Finally, ropt, fetchedResourcesForPipelineRun)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pipelineResolved.Spec.Finally = fruns

                        pipelinerun.Spec.PipelineRef = nil
                        pipelinerun.Spec.PipelineSpec = &amp;pipelineResolved.Spec</span>
                }

                // if PipelineSpec is used then, now resolve the PipelineRun by replacing all taskRef{Finally/Task}
                <span class="cov8" title="1">if pipelinerun.Spec.PipelineSpec != nil </span><span class="cov8" title="1">{
                        turns, err := inlineTasks(pipelinerun.Spec.PipelineSpec.Tasks, ropt, fetchedResourcesForPipelineRun)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pipelinerun.Spec.PipelineSpec.Tasks = turns

                        fruns, err := inlineTasks(pipelinerun.Spec.PipelineSpec.Finally, ropt, fetchedResourcesForPipelineRun)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pipelinerun.Spec.PipelineSpec.Finally = fruns</span>
                }

                // Add a GenerateName based on the pipeline name and a "-"
                // if we already have a GenerateName then just keep it like this
                <span class="cov8" title="1">if ropt.GenerateName &amp;&amp; pipelinerun.GenerateName == "" </span><span class="cov8" title="1">{
                        pipelinerun.GenerateName = pipelinerun.Name + "-"
                        pipelinerun.Name = ""
                }</span>
                <span class="cov8" title="1">pipelineRuns = append(pipelineRuns, pipelinerun)</span>
        }
        // return all resolved PipelineRuns
        <span class="cov8" title="1">return pipelineRuns, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package resolve

import (
        "context"
        "fmt"
        "regexp"
        "slices"
        "strings"

        apipac "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        pacerrors "github.com/openshift-pipelines/pipelines-as-code/pkg/errors"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/matcher"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        tektonv1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "go.uber.org/zap"
        k8scheme "k8s.io/client-go/kubernetes/scheme"
        yaml "sigs.k8s.io/yaml/goyaml.v2"
)

// Contains Resources Fetched from tektondir.
type TektonTypes struct {
        PipelineRuns     []*tektonv1.PipelineRun
        Pipelines        []*tektonv1.Pipeline
        TaskRuns         []*tektonv1.TaskRun
        Tasks            []*tektonv1.Task
        ValidationErrors []*pacerrors.PacYamlValidations
}

// Contains Fetched Resources for Event, with key equals to annotation value.
type FetchedResources struct {
        Tasks     map[string]*tektonv1.Task
        Pipelines map[string]*tektonv1.Pipeline
}

// Contains Fetched Resources for Run, with key equals to resource name from metadata.name field.
type FetchedResourcesForRun struct {
        Tasks       map[string]*tektonv1.Task
        Pipeline    *tektonv1.Pipeline
        PipelineURL string
}

func NewTektonTypes() TektonTypes <span class="cov8" title="1">{
        return TektonTypes{
                ValidationErrors: []*pacerrors.PacYamlValidations{},
        }
}</span>

var yamlDocSeparatorRe = regexp.MustCompile(`(?m)^---\s*$`)

// detectAtleastNameOrGenerateNameAndSchemaFromPipelineRun detects the name or
// generateName of a yaml files even if there is an error decoding it as tekton types.
func detectAtleastNameOrGenerateNameAndSchemaFromPipelineRun(data string) (string, string) <span class="cov8" title="1">{
        var genericKubeObj struct {
                APIVersion string `yaml:"apiVersion"`
                Metadata   struct {
                        Name         string `yaml:"name,omitempty"`
                        GenerateName string `yaml:"generateName,omitempty"`
                } `yaml:"metadata"`
        }
        err := yaml.Unmarshal([]byte(data), &amp;genericKubeObj)
        if err != nil </span><span class="cov8" title="1">{
                return "nokube", ""
        }</span>
        <span class="cov8" title="1">if genericKubeObj.Metadata.Name != "" </span><span class="cov8" title="1">{
                return genericKubeObj.Metadata.Name, genericKubeObj.APIVersion
        }</span>

        <span class="cov8" title="1">if genericKubeObj.Metadata.GenerateName != "" </span><span class="cov8" title="1">{
                return genericKubeObj.Metadata.GenerateName, genericKubeObj.APIVersion
        }</span>
        <span class="cov8" title="1">return "unknown", genericKubeObj.APIVersion</span>
}

// getPipelineByName returns the Pipeline with the given name the first one found
// will be matched. It does not handle conflicts so user has fetched multiple
// pipeline with the same name it will just pick up the first one.
// if the pipeline is not found it returns an error.
func getPipelineByName(name string, tasks []*tektonv1.Pipeline) (*tektonv1.Pipeline, error) <span class="cov8" title="1">{
        for _, value := range tasks </span><span class="cov8" title="1">{
                if value.Name == name </span><span class="cov8" title="1">{
                        return value, nil
                }</span>
        }
        <span class="cov8" title="1">return &amp;tektonv1.Pipeline{}, fmt.Errorf("cannot find referenced pipeline %s. for a remote pipeline make sure to add it in the annotation", name)</span>
}

func pipelineRunsWithSameName(prs []*tektonv1.PipelineRun) error <span class="cov8" title="1">{
        prNames := map[string]bool{}
        for _, pr := range prs </span><span class="cov8" title="1">{
                name := pr.GetName()
                generateName := pr.GetGenerateName()

                if name != "" </span><span class="cov8" title="1">{
                        if _, exist := prNames[name]; exist </span><span class="cov8" title="1">{
                                return fmt.Errorf("found multiple pipelinerun in .tekton with the same name: %v, please update", name)
                        }</span>
                        <span class="cov8" title="1">prNames[name] = true</span>
                }

                <span class="cov8" title="1">if generateName != "" </span><span class="cov8" title="1">{
                        if _, exist := prNames[generateName]; exist </span><span class="cov8" title="1">{
                                return fmt.Errorf("found multiple pipelinerun in .tekton with the same generateName: %v, please update", generateName)
                        }</span>
                        <span class="cov8" title="1">prNames[generateName] = true</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func isTektonAPIVersion(apiVersion string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(apiVersion, "tekton.dev/") || apiVersion == ""
}</span>

func inlineTasks(tasks []tektonv1.PipelineTask, ropt *Opts, remoteResource FetchedResourcesForRun) ([]tektonv1.PipelineTask, error) <span class="cov8" title="1">{
        pipelineTasks := []tektonv1.PipelineTask{}
        for _, task := range tasks </span><span class="cov8" title="1">{
                if task.TaskRef != nil &amp;&amp;
                        task.TaskRef.Resolver == "" &amp;&amp;
                        isTektonAPIVersion(task.TaskRef.APIVersion) &amp;&amp;
                        string(task.TaskRef.Kind) != "ClusterTask" &amp;&amp;
                        !slices.Contains(ropt.SkipInlining, task.TaskRef.Name) </span><span class="cov8" title="1">{
                        taskResolved, ok := remoteResource.Tasks[task.TaskRef.Name]
                        if !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("cannot find referenced task %s. if it's a remote task make sure to add it in the annotations", task.TaskRef.Name)
                        }</span>
                        <span class="cov8" title="1">tmd := tektonv1.PipelineTaskMetadata{
                                Annotations: taskResolved.GetObjectMeta().GetAnnotations(),
                                Labels:      taskResolved.GetObjectMeta().GetLabels(),
                        }
                        task.TaskRef = nil
                        task.TaskSpec = &amp;tektonv1.EmbeddedTask{
                                TaskSpec: taskResolved.Spec,
                                Metadata: tmd,
                        }</span>
                }
                <span class="cov8" title="1">pipelineTasks = append(pipelineTasks, task)</span>
        }
        <span class="cov8" title="1">return pipelineTasks, nil</span>
}

type Opts struct {
        GenerateName  bool     // whether to GenerateName
        RemoteTasks   bool     // whether to parse annotation to fetch tasks from remote
        SkipInlining  []string // task to skip inlining
        ProviderToken string
}

func ReadTektonTypes(ctx context.Context, log *zap.SugaredLogger, data string) (TektonTypes, error) <span class="cov8" title="1">{
        types := NewTektonTypes()
        decoder := k8scheme.Codecs.UniversalDeserializer()

        for _, doc := range yamlDocSeparatorRe.Split(data, -1) </span><span class="cov8" title="1">{
                if strings.TrimSpace(doc) == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">obj, _, err := decoder.Decode([]byte(doc), nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        dt, dv := detectAtleastNameOrGenerateNameAndSchemaFromPipelineRun(doc)
                        types.ValidationErrors = append(types.ValidationErrors, &amp;pacerrors.PacYamlValidations{
                                Name:   dt,
                                Err:    fmt.Errorf("error decoding yaml document: %w", err),
                                Schema: dv,
                        })
                        continue</span>
                }
                <span class="cov8" title="1">switch o := obj.(type) </span>{
                case *tektonv1beta1.Pipeline:<span class="cov8" title="1"> //nolint: staticcheck // we need to support v1beta1
                        c := &amp;tektonv1.Pipeline{}
                        if err := o.ConvertTo(ctx, c); err != nil </span><span class="cov0" title="0">{
                                return types, fmt.Errorf("pipeline v1beta1 %s cannot be converted as v1: err: %w", o.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">types.Pipelines = append(types.Pipelines, c)</span>
                case *tektonv1beta1.PipelineRun:<span class="cov8" title="1"> //nolint: staticcheck // we need to support v1beta1
                        c := &amp;tektonv1.PipelineRun{}
                        if err := o.ConvertTo(ctx, c); err != nil </span><span class="cov0" title="0">{
                                return types, fmt.Errorf("pipelinerun v1beta1 %s cannot be converted as v1: err: %w", o.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">types.PipelineRuns = append(types.PipelineRuns, c)</span>
                case *tektonv1beta1.Task:<span class="cov8" title="1"> //nolint: staticcheck // we need to support v1beta1
                        c := &amp;tektonv1.Task{}
                        if err := o.ConvertTo(ctx, c); err != nil </span><span class="cov0" title="0">{
                                return types, fmt.Errorf("task v1beta1 %s cannot be converted as v1: err: %w", o.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">types.Tasks = append(types.Tasks, c)</span>
                case *tektonv1.PipelineRun:<span class="cov8" title="1">
                        types.PipelineRuns = append(types.PipelineRuns, o)</span>
                case *tektonv1.Pipeline:<span class="cov8" title="1">
                        types.Pipelines = append(types.Pipelines, o)</span>
                case *tektonv1.Task:<span class="cov8" title="1">
                        types.Tasks = append(types.Tasks, o)</span>
                default:<span class="cov8" title="1">
                        log.Info("skipping yaml document not looking like a tekton resource we can Resolve.")</span>
                }
        }

        <span class="cov8" title="1">return types, nil</span>
}

// Resolve gets a large string which is a yaml multi documents containing
// Pipeline/PipelineRuns/Tasks and resolve them inline as a single PipelineRun
// generateName can be set as True to set the name as a generateName + "-" for
// unique pipelinerun.
func Resolve(ctx context.Context, cs *params.Run, logger *zap.SugaredLogger, providerintf provider.Interface, types TektonTypes, event *info.Event, ropt *Opts) ([]*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        if len(types.PipelineRuns) == 0 </span><span class="cov8" title="1">{
                return []*tektonv1.PipelineRun{}, fmt.Errorf("could not find any PipelineRun in your .tekton/ directory")
        }</span>

        <span class="cov8" title="1">if _, err := MetadataResolve(types.PipelineRuns); err != nil </span><span class="cov0" title="0">{
                return []*tektonv1.PipelineRun{}, err
        }</span>

        <span class="cov8" title="1">rt := &amp;matcher.RemoteTasks{
                Run:               cs,
                Event:             event,
                ProviderInterface: providerintf,
                Logger:            logger,
        }

        fetchedResources, err := resolveRemoteResources(ctx, rt, types, ropt)
        if err != nil </span><span class="cov8" title="1">{
                return []*tektonv1.PipelineRun{}, err
        }</span>
        <span class="cov8" title="1">return fetchedResources, nil</span>
}

func MetadataResolve(prs []*tektonv1.PipelineRun) ([]*tektonv1.PipelineRun, error) <span class="cov8" title="1">{
        if err := pipelineRunsWithSameName(prs); err != nil </span><span class="cov0" title="0">{
                return []*tektonv1.PipelineRun{}, err
        }</span>

        <span class="cov8" title="1">for _, prun := range prs </span><span class="cov8" title="1">{
                originPipelineRunName := prun.GetName()
                if originPipelineRunName == "" &amp;&amp; prun.GenerateName != "" </span><span class="cov8" title="1">{
                        originPipelineRunName = prun.GetGenerateName()
                }</span>

                // keep the originalPipelineRun in a label
                // because we would need it later on when grouping by cleanups and we
                // can attach that pr file from .tekton directory.

                // Don't overwrite the labels if there is some who already exist set by the user in repo
                <span class="cov8" title="1">if prun.GetLabels() == nil </span><span class="cov8" title="1">{
                        prun.Labels = map[string]string{}
                }</span>
                // Don't overwrite the annotation if there is some who already exist set by the user in repo
                <span class="cov8" title="1">if prun.GetAnnotations() == nil </span><span class="cov8" title="1">{
                        prun.Annotations = map[string]string{}
                }</span>
                <span class="cov8" title="1">prun.GetLabels()[apipac.OriginalPRName] = formatting.CleanValueKubernetes(originPipelineRunName)
                prun.GetAnnotations()[apipac.OriginalPRName] = originPipelineRunName</span>
        }
        <span class="cov8" title="1">return prs, nil</span>
}

//nolint:gochecknoinits
func init() <span class="cov8" title="1">{
        _ = tektonv1.AddToScheme(k8scheme.Scheme)
        _ = tektonv1beta1.AddToScheme(k8scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package secrets

import (
        "fmt"
        "net/url"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/provider"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/random"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        basicAuthGitConfigData = `
        [credential "%s"]
        helper=store
        `
        //nolint:gosec
        basicAuthSecretName = `pac-gitauth-%s`
        ranStringSeedLen    = 6
)

// MakeBasicAuthSecret Make a secret for git-clone basic-auth workspace.
func MakeBasicAuthSecret(runevent *info.Event, secretName string) (*corev1.Secret, error) <span class="cov8" title="1">{
        // Bitbucket Data Center have a different Clone URL than it's Repository URL, so we
        // have to separate them
        cloneURL := runevent.URL
        if runevent.CloneURL != "" </span><span class="cov8" title="1">{
                cloneURL = runevent.CloneURL
        }</span>

        <span class="cov8" title="1">repoURL, err := url.Parse(cloneURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot parse url %s: %w", cloneURL, err)
        }</span>

        <span class="cov8" title="1">gitUser := provider.DefaultProviderAPIUser
        if runevent.Provider.User != "" </span><span class="cov8" title="1">{
                gitUser = runevent.Provider.User
        }</span>

        // Bitbucket Data Center token have / into it, so unless we quote the URL them it's
        // impossible to use it
        //
        // It supposed not working on GitHub according to
        // https://stackoverflow.com/a/24719496 but arguably GitHub have a better
        // product and would not do such things.
        //
        // maybe we could patch the git-clone task too but that probably be a pain
        // in the *** to do it in shell.
        <span class="cov8" title="1">token := url.QueryEscape(runevent.Provider.Token)

        baseCloneURL := fmt.Sprintf("%s://%s", repoURL.Scheme, repoURL.Host)
        urlWithToken := fmt.Sprintf("%s://%s:%s@%s%s", repoURL.Scheme, gitUser, token, repoURL.Host, repoURL.Path)
        secretData := map[string]string{
                ".gitconfig":       fmt.Sprintf(basicAuthGitConfigData, baseCloneURL),
                ".git-credentials": urlWithToken,
                // With the GitHub APP method the token is available for 8h if you have
                // the user to server token expiration.  the token is scoped to the
                // installation ID
                "git-provider-token": token,
        }
        annotations := map[string]string{
                "pipelinesascode.tekton.dev/url": cloneURL,
                keys.SHA:                         runevent.SHA,
                keys.URLOrg:                      runevent.Organization,
                keys.URLRepository:               runevent.Repository,
        }

        labels := map[string]string{
                "app.kubernetes.io/managed-by": pipelinesascode.GroupName,
                keys.URLOrg:                    formatting.CleanValueKubernetes(runevent.Organization),
                keys.URLRepository:             formatting.CleanValueKubernetes(runevent.Repository),
        }

        return &amp;corev1.Secret{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: corev1.SchemeGroupVersion.String(),
                        Kind:       "Secret",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:        secretName,
                        Labels:      labels,
                        Annotations: annotations,
                },
                StringData: secretData,
        }, nil</span>
}

func GenerateBasicAuthSecretName() string <span class="cov8" title="1">{
        return strings.ToLower(
                fmt.Sprintf(basicAuthSecretName, random.AlphaString(ranStringSeedLen)))
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">package secrets

import (
        "context"
        "fmt"
        "strings"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        ktypes "github.com/openshift-pipelines/pipelines-as-code/pkg/secrets/types"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

const leakedReplacement = "*****"

// GetSecretsAttachedToPipelineRun get all secrets attached to a PipelineRun and
// grab their values attached to it.
func GetSecretsAttachedToPipelineRun(ctx context.Context, k kubeinteraction.Interface, pr *tektonv1.PipelineRun) []ktypes.SecretValue <span class="cov8" title="1">{
        ret := []ktypes.SecretValue{}
        // check if pipelineRef is defined or exist
        if pr.Spec.PipelineSpec == nil </span><span class="cov0" title="0">{
                return ret
        }</span>

        <span class="cov8" title="1">for _, pt := range append(pr.Spec.PipelineSpec.Finally, pr.Spec.PipelineSpec.Tasks...) </span><span class="cov8" title="1">{
                if pt.TaskSpec == nil || pt.TaskSpec.Steps == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, step := range pt.TaskSpec.Steps </span><span class="cov8" title="1">{
                        for _, ev := range step.Env </span><span class="cov8" title="1">{
                                if ev.ValueFrom == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if ev.ValueFrom.SecretKeyRef == nil </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">secretValue, err := k.GetSecret(ctx, ktypes.GetSecretOpt{
                                        Name:      ev.ValueFrom.SecretKeyRef.Name,
                                        Key:       ev.ValueFrom.SecretKeyRef.Key,
                                        Namespace: pr.GetNamespace(),
                                })
                                // that really should not happen but let's go on and continue if that's the case
                                if err != nil </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">keyv := fmt.Sprintf("%s-%s", ev.ValueFrom.SecretKeyRef.Name, ev.ValueFrom.SecretKeyRef.Key)
                                there := false
                                for _, value := range ret </span><span class="cov8" title="1">{
                                        if value.Name == keyv </span><span class="cov8" title="1">{
                                                there = true
                                        }</span>
                                }
                                <span class="cov8" title="1">if !there </span><span class="cov8" title="1">{
                                        ret = append(ret, ktypes.SecretValue{
                                                Name:  keyv,
                                                Value: secretValue,
                                        })
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return ret</span>
}

// sortSecretsByLongests sort all secrets by length, the longest first
// if we don't sort by longest then if there two passwords with the same prefix
// the shortest one will replace and would leak the end of the passwords of the longest after.
func sortSecretsByLongests(values []ktypes.SecretValue) []ktypes.SecretValue <span class="cov8" title="1">{
        ret := []ktypes.SecretValue{}
        ret = append(ret, values...)
        for i := 0; i &lt; len(ret); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(ret); j++ </span><span class="cov8" title="1">{
                        if len(ret[i].Value) &lt; len(ret[j].Value) </span><span class="cov8" title="1">{
                                ret[i], ret[j] = ret[j], ret[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return ret</span>
}

// ReplaceSecretsInText this will take a text snippet and hide the leaked secret.
func ReplaceSecretsInText(text string, values []ktypes.SecretValue) string <span class="cov8" title="1">{
        for _, sv := range sortSecretsByLongests(values) </span><span class="cov8" title="1">{
                text = strings.ReplaceAll(text, sv.Value, leakedReplacement)
        }</span>
        <span class="cov8" title="1">return text</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package sort

import (
        "sort"

        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

// From tekton cli prsort package.
type prSortByCompletionTime []tektonv1.PipelineRun

func (prs prSortByCompletionTime) Len() int      <span class="cov8" title="1">{ return len(prs) }</span>
func (prs prSortByCompletionTime) Swap(i, j int) <span class="cov8" title="1">{ prs[i], prs[j] = prs[j], prs[i] }</span>
func (prs prSortByCompletionTime) Less(i, j int) bool <span class="cov8" title="1">{
        if prs[j].Status.CompletionTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if prs[i].Status.CompletionTime == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return prs[j].Status.CompletionTime.Before(prs[i].Status.CompletionTime)</span>
}

func PipelineRunSortByCompletionTime(items []tektonv1.PipelineRun) []tektonv1.PipelineRun <span class="cov8" title="1">{
        sort.Sort(prSortByCompletionTime(items))
        return items
}</span>

func PipelineRunSortByStartTime(prs []tektonv1.PipelineRun) <span class="cov8" title="1">{
        sort.Sort(byStartTime(prs))
}</span>

type byStartTime []tektonv1.PipelineRun

func (prs byStartTime) Len() int      <span class="cov8" title="1">{ return len(prs) }</span>
func (prs byStartTime) Swap(i, j int) <span class="cov8" title="1">{ prs[i], prs[j] = prs[j], prs[i] }</span>
func (prs byStartTime) Less(i, j int) bool <span class="cov8" title="1">{
        if prs[j].Status.StartTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if prs[i].Status.StartTime == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return prs[j].Status.StartTime.Before(prs[i].Status.StartTime)</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package sort

import (
        "sort"

        pacv1alpha1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
)

// From tekton cli prsort package.
type repositorySortByCompletionTime []pacv1alpha1.Repository

func (repositorys repositorySortByCompletionTime) Len() int <span class="cov8" title="1">{ return len(repositorys) }</span>
func (repositorys repositorySortByCompletionTime) Swap(i, j int) <span class="cov8" title="1">{
        repositorys[j], repositorys[i] = repositorys[i], repositorys[j]
}</span>

func (repositorys repositorySortByCompletionTime) Less(i, j int) bool <span class="cov8" title="1">{
        return repositorys[j].CreationTimestamp.After(repositorys[i].CreationTimestamp.Time)
}</span>

func RepositorySortByCreationOldestTime(repositorys []pacv1alpha1.Repository) <span class="cov8" title="1">{
        sort.Sort(repositorySortByCompletionTime(repositorys))
}</span>
</pre>
		
		<pre class="file" id="file131" style="display: none">package sort

import (
        "sort"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
)

type repoSortRunStatus []v1alpha1.RepositoryRunStatus

func (rs repoSortRunStatus) Len() int <span class="cov8" title="1">{
        return len(rs)
}</span>

func (rs repoSortRunStatus) Swap(i, j int) <span class="cov8" title="1">{
        rs[i], rs[j] = rs[j], rs[i]
}</span>

func (rs repoSortRunStatus) Less(i, j int) bool <span class="cov8" title="1">{
        if rs[j].StartTime == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if rs[i].StartTime == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return rs[j].StartTime.Before(rs[i].StartTime)</span>
}

func RepositorySortRunStatus(repoStatus []v1alpha1.RepositoryRunStatus) []v1alpha1.RepositoryRunStatus <span class="cov8" title="1">{
        rrstatus := repoSortRunStatus{}
        for _, status := range repoStatus </span><span class="cov8" title="1">{
                rrstatus = append(rrstatus, status)
        }</span>
        <span class="cov8" title="1">sort.Sort(rrstatus)
        return rrstatus</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package sort

import (
        "fmt"
        "reflect"
        "sort"

        "github.com/fvbommel/sortorder"
        "k8s.io/apimachinery/pkg/api/resource"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/util/jsonpath"
        "k8s.io/klog/v2"
        "k8s.io/utils/integer"
)

// The following code has been take from kubectl get command
// instead of importing all the dependencies, copying only the required part
// https://github.com/kubernetes/kubernetes/blob/20d0ab7ae808aaddb1556c3c38ca0607663c50ac/staging/src/k8s.io/kubectl/pkg/cmd/get/sorter.go#L150

// RuntimeSort is an implementation of the golang sort interface that knows how to sort
// lists of runtime.Object.
type RuntimeSort struct {
        field        string
        objs         []runtime.Object
        origPosition []int
}

// NewRuntimeSort creates a new RuntimeSort struct that implements golang sort interface.
func NewRuntimeSort(field string, objs []runtime.Object) *RuntimeSort <span class="cov8" title="1">{
        sorter := &amp;RuntimeSort{field: field, objs: objs, origPosition: make([]int, len(objs))}
        for ix := range objs </span><span class="cov8" title="1">{
                sorter.origPosition[ix] = ix
        }</span>
        <span class="cov8" title="1">return sorter</span>
}

func (r *RuntimeSort) Len() int <span class="cov0" title="0">{
        return len(r.objs)
}</span>

func (r *RuntimeSort) Swap(i, j int) <span class="cov0" title="0">{
        r.objs[i], r.objs[j] = r.objs[j], r.objs[i]
        r.origPosition[i], r.origPosition[j] = r.origPosition[j], r.origPosition[i]
}</span>

func isLess(i, j reflect.Value) (bool, error) <span class="cov8" title="1">{
        //nolint
        switch i.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return i.Int() &lt; j.Int(), nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return i.Uint() &lt; j.Uint(), nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return i.Float() &lt; j.Float(), nil</span>
        case reflect.String:<span class="cov8" title="1">
                return sortorder.NaturalLess(i.String(), j.String()), nil</span>
        case reflect.Pointer:<span class="cov0" title="0">
                return isLess(i.Elem(), j.Elem())</span>
        case reflect.Struct:<span class="cov8" title="1">
                // sort metav1.Time
                in := i.Interface()
                if t, ok := in.(metav1.Time); ok </span><span class="cov0" title="0">{
                        time := j.Interface().(metav1.Time)
                        return t.Before(&amp;time), nil
                }</span>
                // sort resource.Quantity
                <span class="cov8" title="1">if iQuantity, ok := in.(resource.Quantity); ok </span><span class="cov8" title="1">{
                        jQuantity := j.Interface().(resource.Quantity)
                        return iQuantity.Cmp(jQuantity) &lt; 0, nil
                }</span>
                // fallback to the fields comparison
                <span class="cov0" title="0">for idx := 0; idx &lt; i.NumField(); idx++ </span><span class="cov0" title="0">{
                        less, err := isLess(i.Field(idx), j.Field(idx))
                        if err != nil || !less </span><span class="cov0" title="0">{
                                return less, err
                        }</span>
                }
                <span class="cov0" title="0">return true, nil</span>
        case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                // note: the length of i and j may be different
                for idx := 0; idx &lt; integer.IntMin(i.Len(), j.Len()); idx++ </span><span class="cov0" title="0">{
                        less, err := isLess(i.Index(idx), j.Index(idx))
                        if err != nil || !less </span><span class="cov0" title="0">{
                                return less, err
                        }</span>
                }
                <span class="cov0" title="0">return true, nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                //nolint
                if i.IsNil() &amp;&amp; j.IsNil() </span><span class="cov0" title="0">{
                        return false, nil
                }</span> else<span class="cov0" title="0"> if i.IsNil() </span><span class="cov0" title="0">{
                        return true, nil
                }</span> else<span class="cov0" title="0"> if j.IsNil() </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">switch itype := i.Interface().(type) </span>{
                case uint8:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(uint8); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case uint16:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(uint16); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case uint32:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(uint32); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case uint64:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(uint64); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case int8:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(int8); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case int16:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(int16); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case int32:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(int32); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case int64:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(int64); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case uint:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(uint); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case int:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(int); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case float32:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(float32); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case float64:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(float64); ok </span><span class="cov0" title="0">{
                                return itype &lt; jtype, nil
                        }</span>
                case string:<span class="cov0" title="0">
                        if jtype, ok := j.Interface().(string); ok </span><span class="cov0" title="0">{
                                // check if it's a Quantity
                                itypeQuantity, err := resource.ParseQuantity(itype)
                                if err != nil </span><span class="cov0" title="0">{
                                        return sortorder.NaturalLess(itype, jtype), nil
                                }</span>
                                <span class="cov0" title="0">jtypeQuantity, err := resource.ParseQuantity(jtype)
                                if err != nil </span><span class="cov0" title="0">{
                                        return sortorder.NaturalLess(itype, jtype), nil
                                }</span>
                                // Both strings are quantity
                                <span class="cov0" title="0">return itypeQuantity.Cmp(jtypeQuantity) &lt; 0, nil</span>
                        }
                default:<span class="cov0" title="0">
                        return false, fmt.Errorf("unsortable type: %T", itype)</span>
                }
                <span class="cov0" title="0">return false, fmt.Errorf("unsortable interface: %v", i.Kind())</span>

        default:<span class="cov0" title="0">
                return false, fmt.Errorf("unsortable type: %v", i.Kind())</span>
        }
}

func (r *RuntimeSort) Less(i, j int) bool <span class="cov8" title="1">{
        iObj := r.objs[i]
        jObj := r.objs[j]

        var iValues [][]reflect.Value
        var jValues [][]reflect.Value
        var err error

        parser := jsonpath.New("sorting").AllowMissingKeys(true)
        err = parser.Parse(r.field)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">iValues, err = findJSONPathResults(parser, iObj)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to get i values for %#v using %s (%#v)", iObj, r.field, err)
        }</span>

        <span class="cov8" title="1">jValues, err = findJSONPathResults(parser, jObj)
        if err != nil </span><span class="cov0" title="0">{
                klog.Fatalf("Failed to get j values for %#v using %s (%v)", jObj, r.field, err)
        }</span>

        <span class="cov8" title="1">if len(iValues) == 0 || len(iValues[0]) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if len(jValues) == 0 || len(jValues[0]) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">iField := iValues[0][0]
        jField := jValues[0][0]

        less, err := isLess(iField, jField)
        if err != nil </span><span class="cov0" title="0">{
                klog.Exitf("Field %s in %T is an unsortable type: %s, err: %v", r.field, iObj, iField.Kind().String(), err)
        }</span>
        <span class="cov8" title="1">return less</span>
}

// OriginalPosition returns the starting (original) position of a particular index.
// e.g. If OriginalPosition(0) returns 5 than the
// item currently at position 0 was at position 5 in the original unsorted array.
func (r *RuntimeSort) OriginalPosition(ix int) int <span class="cov0" title="0">{
        if ix &lt; 0 || ix &gt; len(r.origPosition) </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">return r.origPosition[ix]</span>
}

func findJSONPathResults(parser *jsonpath.JSONPath, from runtime.Object) ([][]reflect.Value, error) <span class="cov8" title="1">{
        if unstructuredObj, ok := from.(*unstructured.Unstructured); ok </span><span class="cov0" title="0">{
                return parser.FindResults(unstructuredObj.Object)
        }</span>
        <span class="cov8" title="1">return parser.FindResults(reflect.ValueOf(from).Elem().Interface())</span>
}

// ByField sorts the runtime objects passed by the field.
func ByField(field string, runTimeObj []runtime.Object) <span class="cov0" title="0">{
        sorter := NewRuntimeSort(field, runTimeObj)
        if len(runTimeObj) &gt; 0 </span><span class="cov0" title="0">{
                sort.Sort(sorter)
        }</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package sort

import (
        "sort"

        pacv1alpha1 "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
)

type taskInfoSorter []pacv1alpha1.TaskInfos

func (s taskInfoSorter) Len() int <span class="cov8" title="1">{ return len(s) }</span>

func (s taskInfoSorter) Swap(i, j int) <span class="cov8" title="1">{
        s[i], s[j] = s[j], s[i]
}</span>

func (s taskInfoSorter) Less(i, j int) bool <span class="cov8" title="1">{
        return s[i].CompletionTime.Before(s[j].CompletionTime)
}</span>

func TaskInfos(taskinfos map[string]pacv1alpha1.TaskInfos) []pacv1alpha1.TaskInfos <span class="cov8" title="1">{
        tis := taskInfoSorter{}
        for _, ti := range taskinfos </span><span class="cov8" title="1">{
                tis = append(tis, ti)
        }</span>
        <span class="cov8" title="1">sort.Sort(tis)
        return tis</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package sort

import (
        "bytes"
        "fmt"
        "sort"
        "text/template"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/formatting"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/params/info"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

type tkr struct {
        taskLogURL string
        *tektonv1.PipelineRunTaskRunStatus
}

func (t tkr) ConsoleLogURL() string <span class="cov8" title="1">{
        name := t.PipelineTaskName
        if t.Status != nil &amp;&amp; t.Status.TaskSpec != nil &amp;&amp; t.Status.TaskSpec.DisplayName != "" </span><span class="cov8" title="1">{
                name = t.Status.TaskSpec.DisplayName
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[%s](%s)", name, t.taskLogURL)</span>
}

type taskrunList []tkr

func (trs taskrunList) Len() int      <span class="cov8" title="1">{ return len(trs) }</span>
func (trs taskrunList) Swap(i, j int) <span class="cov8" title="1">{ trs[i], trs[j] = trs[j], trs[i] }</span>
func (trs taskrunList) Less(i, j int) bool <span class="cov8" title="1">{
        if trs[j].Status == nil || trs[j].Status.StartTime == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if trs[i].Status == nil || trs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return trs[j].Status.StartTime.Before(trs[i].Status.StartTime)</span>
}

// TaskStatusTmpl generate a template of all status of a TaskRuns sorted to a statusTemplate as defined by the git provider.
func TaskStatusTmpl(pr *tektonv1.PipelineRun, trStatus map[string]*tektonv1.PipelineRunTaskRunStatus, runs *params.Run, config *info.ProviderConfig) (string, error) <span class="cov8" title="1">{
        trl := taskrunList{}
        outputBuffer := bytes.Buffer{}

        if len(trStatus) == 0 </span><span class="cov8" title="1">{
                return "PipelineRun has no taskruns", nil
        }</span>

        <span class="cov8" title="1">for _, taskrunStatus := range trStatus </span><span class="cov8" title="1">{
                trl = append(trl, tkr{
                        taskLogURL:               runs.Clients.ConsoleUI().TaskLogURL(pr, taskrunStatus),
                        PipelineRunTaskRunStatus: taskrunStatus,
                })
        }</span>
        <span class="cov8" title="1">sort.Sort(sort.Reverse(trl))

        funcMap := template.FuncMap{
                "formatDuration":  formatting.Duration,
                "formatCondition": formatting.ConditionEmoji,
        }

        if config.SkipEmoji </span><span class="cov0" title="0">{
                funcMap["formatCondition"] = formatting.ConditionSad
        }</span>

        <span class="cov8" title="1">data := struct{ TaskRunList taskrunList }{TaskRunList: trl}
        t := template.Must(template.New("Task Status").Funcs(funcMap).Parse(config.TaskStatusTMPL))
        if err := t.Execute(&amp;outputBuffer, data); err != nil </span><span class="cov8" title="1">{
                _, _ = fmt.Fprintf(&amp;outputBuffer, "failed to execute template: ")
                return "", err
        }</span>

        <span class="cov8" title="1">return outputBuffer.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package sync

import (
        "container/heap"
)

type (
        key = string
)

type item struct {
        key      string
        priority int64
        index    int
}

type priorityQueue struct {
        items     []*item
        itemByKey map[string]*item
}

func (pq *priorityQueue) isPending(key key) bool <span class="cov8" title="1">{
        if _, ok := pq.itemByKey[key]; ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (pq *priorityQueue) add(key key, priority int64) <span class="cov8" title="1">{
        if _, ok := pq.itemByKey[key]; ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">heap.Push(pq, &amp;item{key: key, priority: priority})</span>
}

func (pq *priorityQueue) remove(key key) <span class="cov8" title="1">{
        if item, ok := pq.itemByKey[key]; ok </span><span class="cov8" title="1">{
                heap.Remove(pq, item.index)
                delete(pq.itemByKey, key)
        }</span>
}

func (pq *priorityQueue) pop() *item <span class="cov8" title="1">{
        item, _ := heap.Pop(pq).(*item)
        return item
}</span>

func (pq *priorityQueue) peek() *item <span class="cov8" title="1">{
        return pq.items[0]
}</span>

func (pq priorityQueue) Len() int <span class="cov8" title="1">{ return len(pq.items) }</span>

func (pq priorityQueue) Less(i, j int) bool <span class="cov8" title="1">{
        return pq.items[i].priority &lt; pq.items[j].priority
}</span>

func (pq priorityQueue) Swap(i, j int) <span class="cov8" title="1">{
        pq.items[i], pq.items[j] = pq.items[j], pq.items[i]
        pq.items[i].index = i
        pq.items[j].index = j
}</span>

func (pq *priorityQueue) Push(x any) <span class="cov8" title="1">{
        n := len(pq.items)
        item, _ := x.(*item)
        item.index = n
        pq.items = append(pq.items, item)
        pq.itemByKey[item.key] = item
}</span>

func (pq *priorityQueue) Pop() any <span class="cov8" title="1">{
        old := pq.items
        n := len(old)
        item := old[n-1]
        item.index = -1
        pq.items = old[0 : n-1]
        delete(pq.itemByKey, item.key)
        return item
}</span>
</pre>
		
		<pre class="file" id="file136" style="display: none">package sync

import (
        "context"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/clientset/versioned"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/kubeinteraction"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/sort"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned2 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "go.uber.org/zap"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
)

const (
        creationTimestamp = "{.metadata.creationTimestamp}"
)

type QueueManager struct {
        queueMap map[string]Semaphore
        lock     *sync.Mutex
        logger   *zap.SugaredLogger
}

func NewQueueManager(logger *zap.SugaredLogger) *QueueManager <span class="cov8" title="1">{
        return &amp;QueueManager{
                queueMap: make(map[string]Semaphore),
                lock:     &amp;sync.Mutex{},
                logger:   logger,
        }
}</span>

// getSemaphore returns existing semaphore created for repository or create
// a new one with limit provided in repository
// Semaphore: nothing but a waiting and a running queue for a repository
// with limit deciding how many should be running at a time.
func (qm *QueueManager) getSemaphore(repo *v1alpha1.Repository) (Semaphore, error) <span class="cov8" title="1">{
        repoKey := RepoKey(repo)

        if sema, found := qm.queueMap[repoKey]; found </span><span class="cov8" title="1">{
                if err := qm.checkAndUpdateSemaphoreSize(repo, sema); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return sema, nil</span>
        }

        // create a new semaphore; can't assume callers have checked that ConcurrencyLimit is set
        <span class="cov8" title="1">limit := 0
        if repo.Spec.ConcurrencyLimit != nil </span><span class="cov8" title="1">{
                limit = *repo.Spec.ConcurrencyLimit
        }</span>
        <span class="cov8" title="1">qm.queueMap[repoKey] = newSemaphore(repoKey, limit)

        return qm.queueMap[repoKey], nil</span>
}

func (qm *QueueManager) checkAndUpdateSemaphoreSize(repo *v1alpha1.Repository, semaphore Semaphore) error <span class="cov8" title="1">{
        limit := *repo.Spec.ConcurrencyLimit
        if limit != semaphore.getLimit() </span><span class="cov8" title="1">{
                if semaphore.resize(limit) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to resize semaphore")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// AddListToRunningQueue adds the pipelineRun to the waiting queue of the repository
// and if it is at the top and ready to run which means currently running pipelineRun &lt; limit
// then move it to running queue
// This adds the pipelineRuns in the same order as in the list.
func (qm *QueueManager) AddListToRunningQueue(repo *v1alpha1.Repository, list []string) ([]string, error) <span class="cov8" title="1">{
        qm.lock.Lock()
        defer qm.lock.Unlock()

        sema, err := qm.getSemaphore(repo)
        if err != nil </span><span class="cov0" title="0">{
                return []string{}, err
        }</span>

        <span class="cov8" title="1">for _, pr := range list </span><span class="cov8" title="1">{
                if sema.addToQueue(pr, time.Now()) </span><span class="cov8" title="1">{
                        qm.logger.Infof("added pipelineRun (%s) to running queue for repository (%s)", pr, RepoKey(repo))
                }</span>
        }

        // it is possible something besides PAC set the PipelineRun to Pending; if concurrency limit has not
        // been set, return all the pending PipelineRuns; also, if the limit is zero, that also means do not throttle,
        // so we return all the PipelinesRuns, the for loop below skips that case as well
        <span class="cov8" title="1">if repo.Spec.ConcurrencyLimit == nil || *repo.Spec.ConcurrencyLimit == 0 </span><span class="cov8" title="1">{
                return sema.getCurrentPending(), nil
        }</span>

        <span class="cov8" title="1">acquiredList := []string{}
        for i := 0; i &lt; *repo.Spec.ConcurrencyLimit; i++ </span><span class="cov8" title="1">{
                acquired := sema.acquireLatest()
                if acquired != "" </span><span class="cov8" title="1">{
                        qm.logger.Infof("moved (%s) to running for repository (%s)", acquired, RepoKey(repo))
                        acquiredList = append(acquiredList, acquired)
                }</span>
        }

        <span class="cov8" title="1">return acquiredList, nil</span>
}

func (qm *QueueManager) AddToPendingQueue(repo *v1alpha1.Repository, list []string) error <span class="cov8" title="1">{
        qm.lock.Lock()
        defer qm.lock.Unlock()

        sema, err := qm.getSemaphore(repo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, pr := range list </span><span class="cov8" title="1">{
                if sema.addToPendingQueue(pr, time.Now()) </span><span class="cov8" title="1">{
                        qm.logger.Infof("added pipelineRun (%s) to pending queue for repository (%s)", pr, RepoKey(repo))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (qm *QueueManager) RemoveFromQueue(repoKey, prKey string) bool <span class="cov8" title="1">{
        qm.lock.Lock()
        defer qm.lock.Unlock()

        sema, found := qm.queueMap[repoKey]
        if !found </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">sema.release(prKey)
        sema.removeFromQueue(prKey)
        qm.logger.Infof("removed (%s) for repository (%s)", prKey, repoKey)
        return true</span>
}

func (qm *QueueManager) RemoveAndTakeItemFromQueue(repo *v1alpha1.Repository, run *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        repoKey := RepoKey(repo)
        prKey := PrKey(run)
        if !qm.RemoveFromQueue(repoKey, prKey) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">sema, found := qm.queueMap[repoKey]
        if !found </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if next := sema.acquireLatest(); next != "" </span><span class="cov8" title="1">{
                qm.logger.Infof("moved (%s) to running for repository (%s)", next, repoKey)
                return next
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// FilterPipelineRunByInProgress filters the given list of PipelineRun names to only include those
// that are in a "queued" state and have a pending status. It retrieves the PipelineRun objects
// from the Tekton API and checks their annotations and status to determine if they should be included.
//
// Returns A list of PipelineRun names that are in a "queued" state and have a pending status.
func FilterPipelineRunByState(ctx context.Context, tekton versioned2.Interface, orderList []string, wantedStatus, wantedState string) []string <span class="cov8" title="1">{
        orderedList := []string{}
        for _, prName := range orderList </span><span class="cov8" title="1">{
                prKey := strings.Split(prName, "/")
                pr, err := tekton.TektonV1().PipelineRuns(prKey[0]).Get(ctx, prKey[1], v1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">state, exist := pr.GetAnnotations()[keys.State]
                if !exist </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if state == wantedState </span><span class="cov8" title="1">{
                        if wantedStatus != "" &amp;&amp; pr.Spec.Status != tektonv1.PipelineRunSpecStatus(wantedStatus) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">orderedList = append(orderedList, prName)</span>
                }
        }
        <span class="cov8" title="1">return orderedList</span>
}

// InitQueues rebuild all the queues for all repository if concurrency is defined before
// reconciler started reconciling them.
func (qm *QueueManager) InitQueues(ctx context.Context, tekton versioned2.Interface, pac versioned.Interface) error <span class="cov8" title="1">{
        // fetch all repos
        repos, err := pac.PipelinesascodeV1alpha1().Repositories("").List(ctx, v1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // pipelineRuns from the namespace where repository is present
        // those are required for creating queues
        <span class="cov8" title="1">for _, repo := range repos.Items </span><span class="cov8" title="1">{
                if repo.Spec.ConcurrencyLimit == nil || *repo.Spec.ConcurrencyLimit == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // add all pipelineRuns in started state to pending queue
                <span class="cov8" title="1">prs, err := tekton.TektonV1().PipelineRuns(repo.Namespace).
                        List(ctx, v1.ListOptions{
                                LabelSelector: fmt.Sprintf("%s=%s", keys.State, kubeinteraction.StateStarted),
                        })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // sort the pipelinerun by creation time before adding to queue
                <span class="cov8" title="1">sortedPRs := sortPipelineRunsByCreationTimestamp(prs.Items)

                for _, pr := range sortedPRs </span><span class="cov8" title="1">{
                        order, exist := pr.GetAnnotations()[keys.ExecutionOrder]
                        if !exist </span><span class="cov0" title="0">{
                                // if the pipelineRun doesn't have order label then wait
                                return nil
                        }</span>
                        <span class="cov8" title="1">orderedList := FilterPipelineRunByState(ctx, tekton, strings.Split(order, ","), "", kubeinteraction.StateStarted)

                        _, err = qm.AddListToRunningQueue(&amp;repo, orderedList)
                        if err != nil </span><span class="cov0" title="0">{
                                qm.logger.Error("failed to init queue for repo: ", repo.GetName())
                        }</span>
                }

                // now fetch all queued pipelineRun
                <span class="cov8" title="1">prs, err = tekton.TektonV1().PipelineRuns(repo.Namespace).
                        List(ctx, v1.ListOptions{
                                LabelSelector: fmt.Sprintf("%s=%s", keys.State, kubeinteraction.StateQueued),
                        })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // sort the pipelinerun by creation time before adding to queue
                <span class="cov8" title="1">sortedPRs = sortPipelineRunsByCreationTimestamp(prs.Items)

                for _, pr := range sortedPRs </span><span class="cov8" title="1">{
                        order, exist := pr.GetAnnotations()[keys.ExecutionOrder]
                        if !exist </span><span class="cov0" title="0">{
                                // if the pipelineRun doesn't have order label then wait
                                return nil
                        }</span>
                        <span class="cov8" title="1">orderedList := FilterPipelineRunByState(ctx, tekton, strings.Split(order, ","), tektonv1.PipelineRunSpecStatusPending, kubeinteraction.StateQueued)
                        if err := qm.AddToPendingQueue(&amp;repo, orderedList); err != nil </span><span class="cov0" title="0">{
                                qm.logger.Error("failed to init queue for repo: ", repo.GetName())
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (qm *QueueManager) RemoveRepository(repo *v1alpha1.Repository) <span class="cov0" title="0">{
        qm.lock.Lock()
        defer qm.lock.Unlock()

        repoKey := RepoKey(repo)
        delete(qm.queueMap, repoKey)
}</span>

func (qm *QueueManager) QueuedPipelineRuns(repo *v1alpha1.Repository) []string <span class="cov8" title="1">{
        qm.lock.Lock()
        defer qm.lock.Unlock()

        repoKey := RepoKey(repo)
        if sema, ok := qm.queueMap[repoKey]; ok </span><span class="cov8" title="1">{
                return sema.getCurrentPending()
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

func (qm *QueueManager) RunningPipelineRuns(repo *v1alpha1.Repository) []string <span class="cov8" title="1">{
        qm.lock.Lock()
        defer qm.lock.Unlock()

        repoKey := RepoKey(repo)
        if sema, ok := qm.queueMap[repoKey]; ok </span><span class="cov8" title="1">{
                return sema.getCurrentRunning()
        }</span>
        <span class="cov0" title="0">return []string{}</span>
}

func sortPipelineRunsByCreationTimestamp(prs []tektonv1.PipelineRun) []*tektonv1.PipelineRun <span class="cov8" title="1">{
        runTimeObj := []runtime.Object{}
        for i := range prs </span><span class="cov8" title="1">{
                runTimeObj = append(runTimeObj, &amp;prs[i])
        }</span>
        <span class="cov8" title="1">sort.ByField(creationTimestamp, runTimeObj)
        sortedPRs := []*tektonv1.PipelineRun{}
        for _, run := range runTimeObj </span><span class="cov8" title="1">{
                pr, _ := run.(*tektonv1.PipelineRun)
                sortedPRs = append(sortedPRs, pr)
        }</span>
        <span class="cov8" title="1">return sortedPRs</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package sync

import (
        "context"
        "fmt"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/clientset/versioned"
        tektonv1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        tektonVersionedClient "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
)

type QueueManagerInterface interface {
        InitQueues(ctx context.Context, tekton tektonVersionedClient.Interface, pac versioned.Interface) error
        RemoveRepository(repo *v1alpha1.Repository)
        QueuedPipelineRuns(repo *v1alpha1.Repository) []string
        RunningPipelineRuns(repo *v1alpha1.Repository) []string
        AddListToRunningQueue(repo *v1alpha1.Repository, list []string) ([]string, error)
        AddToPendingQueue(repo *v1alpha1.Repository, list []string) error
        RemoveFromQueue(repoKey, prKey string) bool
        RemoveAndTakeItemFromQueue(repo *v1alpha1.Repository, run *tektonv1.PipelineRun) string
}

func RepoKey(repo *v1alpha1.Repository) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", repo.Namespace, repo.Name)
}</span>

func PrKey(run *tektonv1.PipelineRun) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", run.Namespace, run.Name)
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">package sync

import (
        "fmt"
        "sync"
        "time"

        sema "golang.org/x/sync/semaphore"
)

type prioritySemaphore struct {
        name      string
        limit     int
        pending   *priorityQueue
        running   map[string]bool
        semaphore *sema.Weighted
        lock      *sync.Mutex
}

var _ Semaphore = &amp;prioritySemaphore{}

func newSemaphore(name string, limit int) *prioritySemaphore <span class="cov8" title="1">{
        return &amp;prioritySemaphore{
                name:      name,
                limit:     limit,
                pending:   &amp;priorityQueue{itemByKey: make(map[string]*item)},
                semaphore: sema.NewWeighted(int64(limit)),
                running:   make(map[string]bool),
                lock:      &amp;sync.Mutex{},
        }
}</span>

func (s *prioritySemaphore) getName() string <span class="cov8" title="1">{
        return s.name
}</span>

func (s *prioritySemaphore) getLimit() int <span class="cov8" title="1">{
        return s.limit
}</span>

func (s *prioritySemaphore) getCurrentPending() []string <span class="cov8" title="1">{
        keys := []string{}
        for _, item := range s.pending.items </span><span class="cov8" title="1">{
                keys = append(keys, item.key)
        }</span>
        <span class="cov8" title="1">return keys</span>
}

func (s *prioritySemaphore) getCurrentRunning() []string <span class="cov8" title="1">{
        keys := []string{}
        for k := range s.running </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">return keys</span>
}

func (s *prioritySemaphore) resize(n int) bool <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()

        cur := len(s.running)
        // downward case, acquired n locks
        if cur &gt; n </span><span class="cov8" title="1">{
                cur = n
        }</span>

        <span class="cov8" title="1">semaphore := sema.NewWeighted(int64(n))
        status := semaphore.TryAcquire(int64(cur))
        if status </span><span class="cov8" title="1">{
                s.semaphore = semaphore
                s.limit = n
        }</span>
        <span class="cov8" title="1">return status</span>
}

func (s *prioritySemaphore) removeFromQueue(key string) <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()

        s.pending.remove(key)
}</span>

func (s *prioritySemaphore) addToPendingQueue(key string, creationTime time.Time) bool <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()

        if _, ok := s.running[key]; ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if s.pending.isPending(key) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">s.pending.add(key, creationTime.UnixNano())
        return true</span>
}

func (s *prioritySemaphore) acquireLatest() string <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()

        if s.pending.Len() == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">ready := s.pending.peek()

        if s.semaphore.TryAcquire(1) </span><span class="cov8" title="1">{
                _ = s.pending.pop()
                s.running[ready.key] = true
                return ready.key
        }</span>
        <span class="cov8" title="1">return ""</span>
}

func (s *prioritySemaphore) release(key string) bool <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()

        if _, ok := s.running[key]; ok </span><span class="cov8" title="1">{
                delete(s.running, key)

                // When semaphore resized downward
                // Remove the excess holders from map once the done.
                if len(s.running) &gt;= s.limit </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">s.semaphore.Release(1)</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (s *prioritySemaphore) addToQueue(key string, creationTime time.Time) bool <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()

        if _, ok := s.running[key]; ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if s.pending.isPending(key) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">s.pending.add(key, creationTime.UnixNano())
        return true</span>
}

func (s *prioritySemaphore) tryAcquire(key string) (bool, string) <span class="cov8" title="1">{
        s.lock.Lock()
        defer s.lock.Unlock()

        if _, ok := s.running[key]; ok </span><span class="cov8" title="1">{
                return true, ""
        }</span>

        <span class="cov8" title="1">waitingMsg := fmt.Sprintf("Waiting for %s lock. Available queue status: %d/%d", s.name, s.limit-len(s.running), s.limit)

        // Check whether requested key is in front of priority queue.
        // If it is in front position, it will allow to acquire lock.
        // If it is not a front key, it needs to wait for its turn.
        var nextKey string
        if s.pending.Len() &gt; 0 </span><span class="cov8" title="1">{
                item := s.pending.peek()
                nextKey = fmt.Sprintf("%v", item.key)
                if key != nextKey </span><span class="cov8" title="1">{
                        return false, waitingMsg
                }</span>
        }

        <span class="cov8" title="1">if s.semaphore.TryAcquire(1) </span><span class="cov8" title="1">{
                s.running[key] = true
                s.pending.pop()
                return true, ""
        }</span>

        <span class="cov8" title="1">return false, waitingMsg</span>
}

func (s *prioritySemaphore) acquire(key string) bool <span class="cov0" title="0">{
        s.lock.Lock()
        defer s.lock.Unlock()

        if s.semaphore.TryAcquire(1) </span><span class="cov0" title="0">{
                s.running[key] = true
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package templates

import (
        "encoding/json"
        "net/http"
        "reflect"
        "strings"

        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/traits"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/keys"
        "github.com/openshift-pipelines/pipelines-as-code/pkg/cel"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/structpb"
)

var (
        structType = reflect.TypeOf(&amp;structpb.Value{})
        listType   = reflect.TypeOf(&amp;structpb.ListValue{})
        mapType    = reflect.TypeOf(&amp;structpb.Struct{})
)

// ReplacePlaceHoldersVariables is a function that replaces placeholders in a
// given string template with their corresponding values. The placeholders are
// expected to be in the format `{{key}}`, where `key` is the identifier for a
// value.
//
// The function first checks if the key in the placeholder has a prefix of
// "body", "headers", or "files". If it does and both `rawEvent` and `headers`
// are not nil, it attempts to retrieve the value for the key using the
// `cel.Value` function and returns the corresponding string
// representation. If the key does not have any of the mentioned prefixes, the
// function checks if the key exists in the `dico` map. If it does, the
// function replaces the placeholder with the corresponding value from the
// `dico` map.
//
// Parameters:
//   - template (string): The input string that may contain placeholders in the
//     format `{{key}}`.
//   - dico (map[string]string): A dictionary mapping keys to their corresponding
//     string values. If a placeholder's key is found in this dictionary, it will
//     be replaced with the corresponding value.
//   - rawEvent (any): The raw event data that may be used to retrieve values for
//     placeholders with keys that have a prefix of "body", "headers", or "files".
//   - headers (http.Header): The HTTP headers that may be used to retrieve
//     values for placeholders with keys that have a prefix of "headers".
//   - changedFiles (map[string]any): A map of changed files that may be
//     used to retrieve values for placeholders with keys that have a prefix of
//     "files".
func ReplacePlaceHoldersVariables(template string, dico map[string]string, rawEvent any, headers http.Header, changedFiles map[string]any) string <span class="cov8" title="1">{
        return keys.ParamsRe.ReplaceAllStringFunc(template, func(s string) string </span><span class="cov8" title="1">{
                parts := keys.ParamsRe.FindStringSubmatch(s)
                key := strings.TrimSpace(parts[1])
                if strings.HasPrefix(key, "body") || strings.HasPrefix(key, "headers") || strings.HasPrefix(key, "files") </span><span class="cov8" title="1">{
                        // Check specific requirements for each prefix
                        canEvaluate := false
                        switch </span>{
                        case strings.HasPrefix(key, "body") &amp;&amp; rawEvent != nil:<span class="cov8" title="1">
                                canEvaluate = true</span>
                        case strings.HasPrefix(key, "headers") &amp;&amp; headers != nil:<span class="cov8" title="1">
                                canEvaluate = true</span>
                        case strings.HasPrefix(key, "files"):<span class="cov8" title="1">
                                canEvaluate = true</span> // files evaluation doesn't depend on rawEvent or headers
                        }

                        <span class="cov8" title="1">if canEvaluate </span><span class="cov8" title="1">{
                                // convert headers to map[string]string
                                headerMap := make(map[string]string)
                                for k, v := range headers </span><span class="cov8" title="1">{
                                        headerMap[k] = v[0]
                                }</span>
                                <span class="cov8" title="1">val, err := cel.Value(key, rawEvent, headerMap, map[string]string{}, changedFiles)
                                if err != nil </span><span class="cov8" title="1">{
                                        return s
                                }</span>
                                <span class="cov8" title="1">var raw any
                                var b []byte

                                switch val.(type) </span>{
                                case types.String:<span class="cov8" title="1">
                                        if v, ok := val.Value().(string); ok </span><span class="cov8" title="1">{
                                                b = []byte(v)
                                        }</span>

                                case types.Bytes, types.Double, types.Int:<span class="cov8" title="1">
                                        raw, err = val.ConvertToNative(structType)
                                        if err == nil </span><span class="cov8" title="1">{
                                                if structVal, ok := raw.(*structpb.Value); ok </span><span class="cov8" title="1">{
                                                        b, err = structVal.MarshalJSON()
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                b = []byte{}
                                                        }</span>
                                                }
                                        }

                                case traits.Lister:<span class="cov8" title="1">
                                        raw, err = val.ConvertToNative(listType)
                                        if err == nil </span><span class="cov8" title="1">{
                                                if msg, ok := raw.(proto.Message); ok </span><span class="cov8" title="1">{
                                                        b, err = protojson.Marshal(msg)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                b = []byte{}
                                                        }</span>
                                                }
                                        }

                                case traits.Mapper:<span class="cov8" title="1">
                                        raw, err = val.ConvertToNative(mapType)
                                        if err == nil </span><span class="cov8" title="1">{
                                                if msg, ok := raw.(proto.Message); ok </span><span class="cov8" title="1">{
                                                        b, err = protojson.Marshal(msg)
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                b = []byte{}
                                                        }</span>
                                                }
                                        }

                                case types.Bool:<span class="cov8" title="1">
                                        raw, err = val.ConvertToNative(structType)
                                        if err == nil </span><span class="cov8" title="1">{
                                                if structVal, ok := raw.(*structpb.Value); ok </span><span class="cov8" title="1">{
                                                        b, err = json.Marshal(structVal.GetBoolValue())
                                                        if err != nil </span><span class="cov0" title="0">{
                                                                b = []byte{}
                                                        }</span>
                                                }
                                        }

                                default:<span class="cov8" title="1">
                                        raw, err = val.ConvertToNative(reflect.TypeOf([]byte{}))
                                        if err == nil </span><span class="cov0" title="0">{
                                                if v, ok := raw.([]byte); ok </span><span class="cov0" title="0">{
                                                        b = v
                                                }</span>
                                        }
                                }
                                <span class="cov8" title="1">return string(b)</span>
                        }
                        <span class="cov8" title="1">return s</span>
                }
                <span class="cov8" title="1">if _, ok := dico[key]; !ok </span><span class="cov8" title="1">{
                        return s
                }</span>
                <span class="cov8" title="1">return dico[key]</span>
        })
}
</pre>
		
		<pre class="file" id="file140" style="display: none">package webhook

import (
        "context"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/injection/informers/pipelinesascode/v1alpha1/repository"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        vwhinformer "knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/validatingwebhookconfiguration"
        "knative.dev/pkg/controller"
        secretinformer "knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
)

// NewAdmissionController constructs a reconciler.
func NewAdmissionController(
        ctx context.Context,
        name, path string,
        wc func(context.Context) context.Context,
        disallowUnknownFields bool,
) *controller.Impl <span class="cov0" title="0">{
        client := kubeclient.Get(ctx)
        vwhInformer := vwhinformer.Get(ctx)
        secretInformer := secretinformer.Get(ctx)
        options := webhook.GetOptions(ctx)
        repositoryInformer := repository.Get(ctx)

        key := types.NamespacedName{Name: name}

        wh := &amp;reconciler{
                LeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{
                        // Have this reconciler enqueue our singleton whenever it becomes leader.
                        PromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                enq(bkt, key)
                                return nil
                        }</span>,
                },

                key:  key,
                path: path,

                withContext:           wc,
                disallowUnknownFields: disallowUnknownFields,
                secretName:            options.SecretName,

                client:       client,
                vwhlister:    vwhInformer.Lister(),
                secretlister: secretInformer.Lister(),

                pacLister: repositoryInformer.Lister(),
        }

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        c := controller.NewContext(ctx, wh, controller.ControllerOptions{WorkQueueName: "ValidationWebhook", Logger: logger.Named("ValidationWebhook")})

        // Reconcile when the named ValidatingWebhookConfiguration changes.
        if _, err := vwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithName(name),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named VWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf("Couldn't register ValidatingWebhookConfiguration informer event handler: %w", err)
        }</span>

        // Reconcile when the cert bundle changes.
        <span class="cov0" title="0">if _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), wh.secretName),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named MWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf("Couldn't register Secret informer event handler: %w", err)
        }</span>

        <span class="cov0" title="0">return c</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">package webhook

import (
        "context"
        "fmt"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode"
        pac "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/listers/pipelinesascode/v1alpha1"
        "go.uber.org/zap"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        admissionlisters "k8s.io/client-go/listers/admissionregistration/v1"
        corelisters "k8s.io/client-go/listers/core/v1"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmp"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
        certresources "knative.dev/pkg/webhook/certificates/resources"
)

type reconciler struct {
        webhook.StatelessAdmissionImpl
        pkgreconciler.LeaderAwareFuncs

        key  types.NamespacedName
        path string

        withContext func(context.Context) context.Context

        client       kubernetes.Interface
        vwhlister    admissionlisters.ValidatingWebhookConfigurationLister
        secretlister corelisters.SecretLister

        disallowUnknownFields bool
        secretName            string

        pacLister pac.RepositoryLister
}

var (
        _ controller.Reconciler                = (*reconciler)(nil)
        _ pkgreconciler.LeaderAware            = (*reconciler)(nil)
        _ webhook.AdmissionController          = (*reconciler)(nil)
        _ webhook.StatelessAdmissionController = (*reconciler)(nil)
)

// Reconcile implements controller.Reconciler.
func (ac *reconciler) Reconcile(ctx context.Context, _ string) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        if !ac.IsLeaderFor(ac.key) </span><span class="cov8" title="1">{
                logger.Debugf("Skipping key %q, not the leader.", ac.key)
                return nil
        }</span>

        // Look up the webhook secret, and fetch the CA cert bundle.
        <span class="cov0" title="0">secret, err := ac.secretlister.Secrets(system.Namespace()).Get(ac.secretName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error fetching secret", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">caCert, ok := secret.Data[certresources.CACert]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("secret %q is missing %q key", ac.secretName, certresources.CACert)
        }</span>

        // Reconcile the webhook configuration.
        <span class="cov0" title="0">return ac.reconcileValidatingWebhook(ctx, caCert)</span>
}

func (ac *reconciler) reconcileValidatingWebhook(ctx context.Context, caCert []byte) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        rules := []admissionregistrationv1.RuleWithOperations{
                {
                        Operations: []admissionregistrationv1.OperationType{
                                admissionregistrationv1.Create,
                                admissionregistrationv1.Update,
                        },
                        Rule: admissionregistrationv1.Rule{
                                APIGroups:   []string{pipelinesascode.GroupName},
                                APIVersions: []string{"v1alpha1"},
                                Resources:   []string{"repositories", "repositories" + "/status"},
                        },
                },
        }

        configuredWebhook, err := ac.vwhlister.Get(ac.key.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error retrieving webhook: %w", err)
        }</span>

        <span class="cov0" title="0">webhook := configuredWebhook.DeepCopy()

        // Clear out any previous (bad) OwnerReferences.
        // See: https://github.com/knative/serving/issues/5845
        webhook.OwnerReferences = nil

        for i, wh := range webhook.Webhooks </span><span class="cov0" title="0">{
                if wh.Name != webhook.Name </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">webhook.Webhooks[i].Rules = rules
                webhook.Webhooks[i].ClientConfig.CABundle = caCert
                if webhook.Webhooks[i].ClientConfig.Service == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing service reference for webhook: %s", wh.Name)
                }</span>
                <span class="cov0" title="0">webhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())</span>
        }

        <span class="cov0" title="0">ok, err := kmp.SafeEqual(configuredWebhook, webhook)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error diffing webhooks: %w", err)
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                logger.Info("Updating webhook")
                mwhclient := ac.client.AdmissionregistrationV1().ValidatingWebhookConfigurations()
                if _, err := mwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update webhook: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("Webhook is valid")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">package webhook

import (
        "context"
        "net/url"
        "os"

        "github.com/openshift-pipelines/pipelines-as-code/pkg/apis/pipelinesascode/v1alpha1"
        pac "github.com/openshift-pipelines/pipelines-as-code/pkg/generated/listers/pipelinesascode/v1alpha1"
        v1 "k8s.io/api/admission/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/serializer"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/webhook"
)

var universalDeserializer = serializer.NewCodecFactory(runtime.NewScheme()).UniversalDeserializer()

var allowedGitlabDisableCommentStrategyOnMr = sets.NewString("", "disable_all")

// Path implements AdmissionController.
func (ac *reconciler) Path() string <span class="cov0" title="0">{
        return ac.path
}</span>

// Admit implements AdmissionController.
func (ac *reconciler) Admit(_ context.Context, request *v1.AdmissionRequest) *v1.AdmissionResponse <span class="cov8" title="1">{
        raw := request.Object.Raw
        repo := v1alpha1.Repository{}
        if _, _, err := universalDeserializer.Decode(raw, nil, &amp;repo); err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("validation failed: %v", err)
        }</span>

        // Check that if we have a URL set only for non global repository which can be set as empty.
        <span class="cov8" title="1">if repo.GetNamespace() != os.Getenv("SYSTEM_NAMESPACE") </span><span class="cov8" title="1">{
                if repo.Spec.URL == "" </span><span class="cov0" title="0">{
                        return webhook.MakeErrorStatus("URL must be set")
                }</span>

                <span class="cov8" title="1">parsed, err := url.Parse(repo.Spec.URL)
                if err != nil </span><span class="cov8" title="1">{
                        return webhook.MakeErrorStatus("invalid URL format: %v", err)
                }</span>

                <span class="cov8" title="1">if parsed.Scheme != "http" &amp;&amp; parsed.Scheme != "https" </span><span class="cov8" title="1">{
                        return webhook.MakeErrorStatus("URL scheme must be http or https")
                }</span>
        }

        <span class="cov8" title="1">exist, err := checkIfRepoExist(ac.pacLister, &amp;repo, "")
        if err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("validation failed: %v", err)
        }</span>

        <span class="cov8" title="1">if exist </span><span class="cov8" title="1">{
                return webhook.MakeErrorStatus("repository already exists with URL: %s", repo.Spec.URL)
        }</span>

        <span class="cov8" title="1">if repo.Spec.ConcurrencyLimit != nil &amp;&amp; *repo.Spec.ConcurrencyLimit == 0 </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("concurrency limit must be greater than 0")
        }</span>

        <span class="cov8" title="1">if repo.Spec.Settings != nil &amp;&amp; repo.Spec.Settings.Gitlab != nil </span><span class="cov0" title="0">{
                if !allowedGitlabDisableCommentStrategyOnMr.Has(repo.Spec.Settings.Gitlab.CommentStrategy) </span><span class="cov0" title="0">{
                        return webhook.MakeErrorStatus("comment strategy '%s' is not supported for Gitlab MRs", repo.Spec.Settings.Gitlab.CommentStrategy)
                }</span>
        }

        <span class="cov8" title="1">return &amp;v1.AdmissionResponse{Allowed: true}</span>
}

func checkIfRepoExist(pac pac.RepositoryLister, repo *v1alpha1.Repository, ns string) (bool, error) <span class="cov8" title="1">{
        repositories, err := pac.Repositories(ns).List(labels.NewSelector())
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for i := len(repositories) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                repoFromCluster := repositories[i]
                if repoFromCluster.Spec.URL == repo.Spec.URL &amp;&amp;
                        (repoFromCluster.Name != repo.Name || repoFromCluster.Namespace != repo.Namespace) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
