
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>actions: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/openshift-pipelines/manual-approval-gate/pkg/actions/actions.go (0.0%)</option>
				
				<option value="file1">github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1/approvaltask_types.go (33.3%)</option>
				
				<option value="file2">github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1/approvaltask_validation.go (0.0%)</option>
				
				<option value="file3">github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1/register.go (60.0%)</option>
				
				<option value="file4">github.com/openshift-pipelines/manual-approval-gate/pkg/cli/flags/flags.go (0.0%)</option>
				
				<option value="file5">github.com/openshift-pipelines/manual-approval-gate/pkg/cli/formatter/field.go (0.0%)</option>
				
				<option value="file6">github.com/openshift-pipelines/manual-approval-gate/pkg/cli/params.go (0.0%)</option>
				
				<option value="file7">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/clientset.go (0.0%)</option>
				
				<option value="file8">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/fake/clientset_generated.go (44.4%)</option>
				
				<option value="file9">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/fake/register.go (100.0%)</option>
				
				<option value="file10">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/scheme/register.go (100.0%)</option>
				
				<option value="file11">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/approvaltask.go (0.0%)</option>
				
				<option value="file12">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/approvaltask_client.go (0.0%)</option>
				
				<option value="file13">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/fake/fake_approvaltask.go (33.3%)</option>
				
				<option value="file14">github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/fake/fake_approvaltask_client.go (33.3%)</option>
				
				<option value="file15">github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/interface.go (0.0%)</option>
				
				<option value="file16">github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1/approvaltask.go (0.0%)</option>
				
				<option value="file17">github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1/interface.go (0.0%)</option>
				
				<option value="file18">github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/factory.go (0.0%)</option>
				
				<option value="file19">github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/generic.go (0.0%)</option>
				
				<option value="file20">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client/client.go (20.0%)</option>
				
				<option value="file21">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client/fake/fake.go (0.0%)</option>
				
				<option value="file22">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/approvaltask.go (12.5%)</option>
				
				<option value="file23">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/fake/fake.go (0.0%)</option>
				
				<option value="file24">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/filtered/approvaltask.go (0.0%)</option>
				
				<option value="file25">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file26">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/factory.go (10.0%)</option>
				
				<option value="file27">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/fake/fake.go (0.0%)</option>
				
				<option value="file28">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered/fake/fake_filtered_factory.go (0.0%)</option>
				
				<option value="file29">github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered/filtered_factory.go (0.0%)</option>
				
				<option value="file30">github.com/openshift-pipelines/manual-approval-gate/pkg/client/listers/approvaltask/v1alpha1/approvaltask.go (0.0%)</option>
				
				<option value="file31">github.com/openshift-pipelines/manual-approval-gate/pkg/reconciler/approvaltask/approvaltask.go (6.0%)</option>
				
				<option value="file32">github.com/openshift-pipelines/manual-approval-gate/pkg/reconciler/approvaltask/controller.go (0.0%)</option>
				
				<option value="file33">github.com/openshift-pipelines/manual-approval-gate/pkg/reconciler/approvaltask/utils.go (62.2%)</option>
				
				<option value="file34">github.com/openshift-pipelines/manual-approval-gate/pkg/reconciler/webhook/controller.go (0.0%)</option>
				
				<option value="file35">github.com/openshift-pipelines/manual-approval-gate/pkg/reconciler/webhook/webhook.go (0.0%)</option>
				
				<option value="file36">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/errwrap/errwrap.go (0.0%)</option>
				
				<option value="file37">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/go-multierror/append.go (0.0%)</option>
				
				<option value="file38">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/go-multierror/flatten.go (0.0%)</option>
				
				<option value="file39">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/go-multierror/format.go (0.0%)</option>
				
				<option value="file40">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/go-multierror/group.go (0.0%)</option>
				
				<option value="file41">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/go-multierror/multierror.go (0.0%)</option>
				
				<option value="file42">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/go-multierror/prefix.go (0.0%)</option>
				
				<option value="file43">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/go-multierror/sort.go (0.0%)</option>
				
				<option value="file44">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/golang-lru/2q.go (0.0%)</option>
				
				<option value="file45">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/golang-lru/arc.go (0.0%)</option>
				
				<option value="file46">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/golang-lru/lru.go (0.0%)</option>
				
				<option value="file47">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/golang-lru/simplelru/lru.go (0.0%)</option>
				
				<option value="file48">github.com/openshift-pipelines/manual-approval-gate/third_party/github.com/hashicorp/golang-lru/testing.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package actions

import (
        "context"
        "fmt"
        "os"
        "sync"

        "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        "github.com/openshift-pipelines/manual-approval-gate/pkg/cli"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/restmapper"
)

var (
        doOnce      sync.Once
        apiGroupRes []*restmapper.APIGroupResources
)

// List fetches the resource and convert it to respective object
func List(gr schema.GroupVersionResource, c *cli.Clients, opts metav1.ListOptions, ns string, obj interface{}) error <span class="cov0" title="0">{
        unstructuredObj, err := list(gr, c.Dynamic, c.ApprovalTask.Discovery(), ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to list objects from %s namespace \n", ns)
                return err
        }</span>

        <span class="cov0" title="0">return runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)</span>
}

// list takes a partial resource and fetches a list of that resource's objects in the cluster using the dynamic client.
func list(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, ns string, op metav1.ListOptions) (*unstructured.UnstructuredList, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, discovery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">allRes, err := dynamic.Resource(*gvr).Namespace(ns).List(context.Background(), op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return allRes, nil</span>
}

func Get(gr schema.GroupVersionResource, c *cli.Clients, opts *cli.Options) (*v1alpha1.ApprovalTask, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, c.ApprovalTask.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">at, err := get(gvr, c, opts)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;v1alpha1.ApprovalTask{}, err
        }</span>

        <span class="cov0" title="0">return at, nil</span>
}

func get(gvr *schema.GroupVersionResource, c *cli.Clients, opts *cli.Options) (*v1alpha1.ApprovalTask, error) <span class="cov0" title="0">{
        result, err := c.Dynamic.Resource(*gvr).Namespace(opts.Namespace).Get(context.Background(), opts.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">at := &amp;v1alpha1.ApprovalTask{}
        err = runtime.DefaultUnstructuredConverter.FromUnstructured(result.Object, at)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return at, nil</span>
}

func Update(gr schema.GroupVersionResource, c *cli.Clients, opts *cli.Options) error <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, c.ApprovalTask.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">at, err := get(gvr, c, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !containsUsername(at.Spec.Approvers, opts) </span><span class="cov0" title="0">{
                return fmt.Errorf("approver: %s, is not present in the approvers list", opts.Username)
        }</span>

        <span class="cov0" title="0">if err := update(gvr, c.Dynamic, at, opts); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func update(gvr *schema.GroupVersionResource, dynamic dynamic.Interface, at *v1alpha1.ApprovalTask, opts *cli.Options) error <span class="cov0" title="0">{
        // Track if user has been processed as individual User type to avoid duplicate processing
        userProcessedAsIndividual := false

        // First pass: Process all User type approvers to ensure User type takes precedence
        for i, approver := range at.Spec.Approvers </span><span class="cov0" title="0">{
                if v1alpha1.DefaultedApproverType(approver.Type) == "User" &amp;&amp; approver.Name == opts.Username </span><span class="cov0" title="0">{
                        at.Spec.Approvers[i].Input = opts.Input
                        if opts.Message != "" </span><span class="cov0" title="0">{
                                at.Spec.Approvers[i].Message = opts.Message
                        }</span>
                        <span class="cov0" title="0">userProcessedAsIndividual = true</span>
                }
        }

        // Second pass: Process Group type approvers, but only add user to group if not already processed as individual
        <span class="cov0" title="0">for i, approver := range at.Spec.Approvers </span><span class="cov0" title="0">{
                if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                        for _, groupName := range opts.Groups </span><span class="cov0" title="0">{
                                if approver.Name == groupName </span><span class="cov0" title="0">{
                                        at.Spec.Approvers[i].Input = opts.Input
                                        if opts.Message != "" </span><span class="cov0" title="0">{
                                                at.Spec.Approvers[i].Message = opts.Message
                                        }</span>

                                        // Only add user to group members if they haven't been processed as individual User
                                        // This prevents duplicate entries when user is both individual approver and group member
                                        <span class="cov0" title="0">if !userProcessedAsIndividual </span><span class="cov0" title="0">{
                                                userExists := false

                                                for j, existing := range at.Spec.Approvers[i].Users </span><span class="cov0" title="0">{
                                                        if existing.Name == opts.Username </span><span class="cov0" title="0">{
                                                                userExists = true
                                                                if existing.Input != opts.Input </span><span class="cov0" title="0">{
                                                                        at.Spec.Approvers[i].Users[j].Input = opts.Input
                                                                }</span>
                                                                <span class="cov0" title="0">break</span>
                                                        }
                                                }
                                                <span class="cov0" title="0">if !userExists </span><span class="cov0" title="0">{
                                                        newUser := v1alpha1.UserDetails{
                                                                Name:  opts.Username,
                                                                Input: opts.Input,
                                                        }
                                                        at.Spec.Approvers[i].Users = append(at.Spec.Approvers[i].Users, newUser)
                                                }</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">unstructuredMap, err := runtime.DefaultUnstructuredConverter.ToUnstructured(&amp;at)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error converting to unstructured: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">unstrObj := &amp;unstructured.Unstructured{Object: unstructuredMap}
        _, err = dynamic.Resource(*gvr).Namespace(opts.Namespace).Update(context.TODO(), unstrObj, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func GetGroupVersionResource(gr schema.GroupVersionResource, discovery discovery.DiscoveryInterface) (*schema.GroupVersionResource, error) <span class="cov0" title="0">{
        var err error
        doOnce.Do(func() </span><span class="cov0" title="0">{
                err = InitializeAPIGroupRes(discovery)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rm := restmapper.NewDiscoveryRESTMapper(apiGroupRes)
        gvr, err := rm.ResourceFor(gr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gvr, nil</span>
}

// InitializeAPIGroupRes initializes and populates the discovery client.
func InitializeAPIGroupRes(discovery discovery.DiscoveryInterface) error <span class="cov0" title="0">{
        var err error
        apiGroupRes, err = restmapper.GetAPIGroupResources(discovery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func containsUsername(approvers []v1alpha1.ApproverDetails, user *cli.Options) bool <span class="cov0" title="0">{
        for _, approver := range approvers </span><span class="cov0" title="0">{
                if approver.Name == user.Username </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">for _, approval := range approvers </span><span class="cov0" title="0">{
                switch approval.Type </span>{
                case "User":<span class="cov0" title="0">
                        if approval.Name == user.Username </span><span class="cov0" title="0">{
                                return true
                        }</span>
                case "Group":<span class="cov0" title="0">
                        for _, groupName := range user.Groups </span><span class="cov0" title="0">{
                                if approval.Name == groupName </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "time"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/utils/clock"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ApprovalTask is a "wait for manual approval" Task.
// +k8s:openapi-gen=true
type ApprovalTask struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata"`

        // Spec holds the desired state of the TaskGroup from the client
        // +optional
        Spec   ApprovalTaskSpec   `json:"spec"`
        Status ApprovalTaskStatus `json:"status"`
}

type ApprovalTaskSpec struct {
        Approvers                 []ApproverDetails `json:"approvers"`
        NumberOfApprovalsRequired int               `json:"numberOfApprovalsRequired"`
        Description               string            `json:"description,omitempty"`
}

type UserDetails struct {
        Name  string `json:"name"`
        Input string `json:"input"`
}

type ApproverDetails struct {
        Name    string        `json:"name"`
        Input   string        `json:"input"`
        Message string        `json:"message,omitempty"`
        Type    string        `json:"type"`
        Users   []UserDetails `json:"users,omitempty"`
}

type ApprovalTaskStatus struct {
        duckv1.Status     `json:",inline"`
        State             string          `json:"state"`
        Approvers         []string        `json:"approvers,omitempty"`
        ApproversResponse []ApproverState `json:"approversResponse,omitempty"`
        // StartTime is the time the build is actually started.
        StartTime *metav1.Time `json:"startTime,omitempty"`
        // ApprovalsRequired is the number of approvals required for the task
        ApprovalsRequired int `json:"approvalsRequired,omitempty"`
        // ApprovalsReceived is the number of approvals received so far
        ApprovalsReceived int `json:"approvalsReceived,omitempty"`
}

type GroupMemberState struct {
        Name     string `json:"name"`
        Response string `json:"response"`
        Message  string `json:"message,omitempty"`
}

type ApproverState struct {
        Name         string             `json:"name"`
        Response     string             `json:"response"`
        Message      string             `json:"message,omitempty"`
        Type         string             `json:"type"`
        GroupMembers []GroupMemberState `json:"groupMembers,omitempty"`
}

// DefaultedApproverType returns "User" if the type field is empty (for v0.6.0 compatibility),
// otherwise returns the provided type.
func DefaultedApproverType(approverType string) string <span class="cov8" title="1">{
        if approverType == "" </span><span class="cov8" title="1">{
                return "User"
        }</span>
        <span class="cov8" title="1">return approverType</span>
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ApprovalTaskList contains a list of ApprovalTasks
type ApprovalTaskList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ApprovalTask `json:"items"`
}

// ApprovalTaskRunStatus contains the status stored in the ExtraFields of a Run that references a ApprovalTask.
type ApprovalTaskRunStatus struct {
        // ApprovalTaskSpec contains the exact spec used to instantiate the Run
        // FIXME(openshift-pipelines) can probably remove
        ApprovalTaskSpec *ApprovalTaskSpec `json:"taskLoopSpec,omitempty"`
        // +optional
        // TaskRun *v1beta1.TaskRunStatus `json:"status,omitempty"`
}

// ApprovalTaskRunReason represents a reason for the Run "Succeeded" condition
type ApprovalTaskRunReason string

const (
        // ApprovalTaskRunReasonStarted is the reason set when the Run has just started
        ApprovalTaskRunReasonStarted ApprovalTaskRunReason = "Started"

        // ApprovalTaskRunReasonRunning indicates that the Run is in progress
        ApprovalTaskRunReasonRunning ApprovalTaskRunReason = "Running"

        // ApprovalTaskRunReasonFailed indicates that one of the TaskRuns created from the Run failed
        ApprovalTaskRunReasonFailed ApprovalTaskRunReason = "Failed"

        // ApprovalTaskRunReasonSucceeded indicates that all of the TaskRuns created from the Run completed successfully
        ApprovalTaskRunReasonSucceeded ApprovalTaskRunReason = "Succeeded"

        // ApprovalTaskRunReasonCouldntCancel indicates that a Run was cancelled but attempting to update
        // the running TaskRun as cancelled failed.
        ApprovalTaskRunReasonCouldntCancel ApprovalTaskRunReason = "ApprovalTaskRunCouldntCancel"

        // ApprovalTaskRunReasonCouldntGetApprovalTask indicates that the associated ApprovalTask couldn't be retrieved
        ApprovalTaskRunReasonCouldntGetApprovalTask ApprovalTaskRunReason = "CouldntGetApprovalTask"

        // ApprovalTaskRunReasonFailedValidation indicates that the ApprovalTask failed runtime validation
        ApprovalTaskRunReasonFailedValidation ApprovalTaskRunReason = "ApprovalTaskValidationFailed"

        // ApprovalTaskRunReasonInternalError indicates that the ApprovalTask failed due to an internal error in the reconciler
        ApprovalTaskRunReasonInternalError ApprovalTaskRunReason = "ApprovalTaskInternalError"
)

func (t ApprovalTaskRunReason) String() string <span class="cov0" title="0">{
        return string(t)
}</span>

func (at ApprovalTask) HasStarted() bool <span class="cov0" title="0">{
        return at.Status.StartTime != nil
}</span>

func (at ApprovalTask) ApprovalTaskHasTimedOut(ctx context.Context, c clock.PassiveClock, timeout time.Duration) bool <span class="cov0" title="0">{
        if at.Status.StartTime.IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">runtime := c.Since(at.Status.StartTime.Time)

        return runtime &gt; timeout</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "knative.dev/pkg/apis"
)

var _ apis.Validatable = (*ApprovalTask)(nil)

// Validate ApprovalTask
func (tg *ApprovalTask) Validate(ctx context.Context) *apis.FieldError <span class="cov0" title="0">{
        if err := validate.ObjectMetadata(tg.GetObjectMeta()); err != nil </span><span class="cov0" title="0">{
                return err.ViaField("metadata")
        }</span>
        <span class="cov0" title="0">return tg.Spec.Validate(ctx)</span>
}

// Validate ApprovalTaskSpec
func (tgs *ApprovalTaskSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const ManagedByLabelKey = "app.kubernetes.io/managed-by"

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: approvaltask.GroupName, Version: "v1alpha1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;ApprovalTask{},
                &amp;ApprovalTaskList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package flags

import (
        cli "github.com/openshift-pipelines/manual-approval-gate/pkg/cli"
        "github.com/spf13/cobra"
)

func AddOptions(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.PersistentFlags().StringP(
                "namespace", "n", "",
                "namespace to use (default: from $KUBECONFIG)")
}</span>

func PersistentPreRunE(p cli.Params) func(*cobra.Command, []string) error <span class="cov0" title="0">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                return InitParams(p, cmd)
        }</span>
}

func InitParams(p cli.Params, cmd *cobra.Command) error <span class="cov0" title="0">{
        ns, err := cmd.Flags().GetString("namespace")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ns != "" </span><span class="cov0" title="0">{
                p.SetNamespace(ns)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package formatter

import (
        "github.com/fatih/color"
        "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
)

var ConditionColor = map[string]color.Attribute{
        "Rejected": color.FgHiRed,
        "Approved": color.FgHiGreen,
        "Pending":  color.FgHiYellow,
}

func ColorStatus(status string) string <span class="cov0" title="0">{
        return color.New(ConditionColor[status]).Sprint(status)
}</span>

func State(at *v1alpha1.ApprovalTask) string <span class="cov0" title="0">{
        var state string

        switch at.Status.State </span>{
        case "approved":<span class="cov0" title="0">
                state = "Approved"</span>
        case "rejected":<span class="cov0" title="0">
                state = "Rejected"</span>
        case "pending":<span class="cov0" title="0">
                state = "Pending"</span>
        }
        <span class="cov0" title="0">return ColorStatus(state)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package cli

import (
        "context"
        "fmt"

        "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned"
        userv1typedclient "github.com/openshift/client-go/user/clientset/versioned/typed/user/v1"
        "github.com/pkg/errors"
        v1 "k8s.io/api/authentication/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/dynamic"
        k8s "k8s.io/client-go/kubernetes"
        authenticationv1client "k8s.io/client-go/kubernetes/typed/authentication/v1"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
)

type Clients struct {
        Config       *rest.Config
        Kube         k8s.Interface
        Dynamic      dynamic.Interface
        ApprovalTask versioned.Interface
}

type ApprovalTaskParams struct {
        clients        *Clients
        kubeConfigPath string
        kubeContext    string
        namespace      string
}

type Options struct {
        Namespace     string
        Name          string
        Input         string
        Username      string
        Message       string
        AllNamespaces bool
        Groups        []string
}

type Params interface {
        // SetKubeConfigPath uses the kubeconfig path to instantiate tekton
        // returned by Clientset function
        SetKubeConfigPath(string)
        // SetKubeContext extends the specificity of the above SetKubeConfigPath
        // by using a context other than the default context in the given kubeconfig
        SetKubeContext(string)
        SetNamespace(string)
        KubeClient() (k8s.Interface, error)
        Clients(...*rest.Config) (*Clients, error)
        Namespace() string
        GetUserInfo() (string, []string, error)
}

// ensure that TektonParams complies with cli.Params interface
var _ Params = (*ApprovalTaskParams)(nil)

func (p *ApprovalTaskParams) SetKubeConfigPath(path string) <span class="cov0" title="0">{
        p.kubeConfigPath = path
}</span>

func (p *ApprovalTaskParams) SetKubeContext(context string) <span class="cov0" title="0">{
        p.kubeContext = context
}</span>

func (p *ApprovalTaskParams) Namespace() string <span class="cov0" title="0">{
        return p.namespace
}</span>

func (p *ApprovalTaskParams) GetUserInfo() (string, []string, error) <span class="cov0" title="0">{
        authV1Client, err := authenticationv1client.NewForConfig(p.clients.Config)
        if err != nil </span><span class="cov0" title="0">{
                return "", []string{}, err
        }</span>

        <span class="cov0" title="0">userInterface, err := userv1typedclient.NewForConfig(p.clients.Config)
        if err != nil </span><span class="cov0" title="0">{
                return "", []string{}, err
        }</span>

        // Get username
        <span class="cov0" title="0">username, groups, err := getUserInfo(authV1Client, userInterface)
        if err != nil </span><span class="cov0" title="0">{
                return "", []string{}, err
        }</span>
        <span class="cov0" title="0">return username, groups, err</span>
}

func (p *ApprovalTaskParams) SetNamespace(ns string) <span class="cov0" title="0">{
        p.namespace = ns
}</span>

func (p *ApprovalTaskParams) kubeClient(config *rest.Config) (k8s.Interface, error) <span class="cov0" title="0">{
        k8scs, err := k8s.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create k8s client from config")
        }</span>

        <span class="cov0" title="0">return k8scs, nil</span>
}

func (p *ApprovalTaskParams) dynamicClient(config *rest.Config) (dynamic.Interface, error) <span class="cov0" title="0">{
        dynamicClient, err := dynamic.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create dynamic client from config")

        }</span>
        <span class="cov0" title="0">return dynamicClient, err</span>
}

func (p *ApprovalTaskParams) approvalTaskClient(config *rest.Config) (versioned.Interface, error) <span class="cov0" title="0">{
        approvalClient, err := versioned.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create dynamic client from config")

        }</span>
        <span class="cov0" title="0">return approvalClient, err</span>
}

func (p *ApprovalTaskParams) config() (*rest.Config, error) <span class="cov0" title="0">{

        loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
        if p.kubeConfigPath != "" </span><span class="cov0" title="0">{
                loadingRules.ExplicitPath = p.kubeConfigPath
        }</span>
        <span class="cov0" title="0">configOverrides := &amp;clientcmd.ConfigOverrides{}
        if p.kubeContext != "" </span><span class="cov0" title="0">{
                configOverrides.CurrentContext = p.kubeContext
        }</span>

        <span class="cov0" title="0">kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
        if p.namespace == "" </span><span class="cov0" title="0">{
                namespace, _, err := kubeConfig.Namespace()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "Couldn't get kubeConfiguration namespace")
                }</span>
                <span class="cov0" title="0">p.namespace = namespace</span>
        }
        <span class="cov0" title="0">config, err := kubeConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Parsing kubeconfig failed")
        }</span>

        // set values as done in kubectl
        <span class="cov0" title="0">config.QPS = 50.0
        config.Burst = 300

        return config, nil</span>
}

// Only returns kube client, not tekton client
func (p *ApprovalTaskParams) KubeClient() (k8s.Interface, error) <span class="cov0" title="0">{
        config, err := p.config()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">kube, err := p.kubeClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return kube, nil</span>
}

func (p *ApprovalTaskParams) Clients(cfg ...*rest.Config) (*Clients, error) <span class="cov0" title="0">{
        var config *rest.Config

        if len(cfg) != 0 &amp;&amp; cfg[0] != nil </span><span class="cov0" title="0">{
                config = cfg[0]
        }</span> else<span class="cov0" title="0"> {
                defaultConfig, err := p.config()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">config = defaultConfig</span>
        }

        <span class="cov0" title="0">kube, err := p.kubeClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dynamicClient, err := p.dynamicClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">approvalClient, err := p.approvalTaskClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">p.clients = &amp;Clients{
                Config:       config,
                Kube:         kube,
                ApprovalTask: approvalClient,
                Dynamic:      dynamicClient,
        }

        return p.clients, nil</span>
}

func getUserInfo(authV1Client *authenticationv1client.AuthenticationV1Client, userInterface userv1typedclient.UserV1Interface) (string, []string, error) <span class="cov0" title="0">{
        var username string
        res, err := authV1Client.SelfSubjectReviews().Create(context.TODO(), &amp;v1.SelfSubjectReview{}, metav1.CreateOptions{})
        if err == nil </span><span class="cov0" title="0">{
                username = res.Status.UserInfo.Username
                return username, res.Status.UserInfo.Groups, nil
        }</span> else<span class="cov0" title="0"> {
                fmt.Errorf("selfsubjectreview request error %v, falling back to user object", err)
        }</span>

        <span class="cov0" title="0">user, err := userInterface.Users().Get(context.TODO(), "~", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return "", []string{}, nil
        }</span>
        <span class="cov0" title="0">username = user.Name

        return username, user.Groups, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package versioned

import (
        fmt "fmt"
        http "net/http"

        openshiftpipelinesv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1"
        discovery "k8s.io/client-go/discovery"
        rest "k8s.io/client-go/rest"
        flowcontrol "k8s.io/client-go/util/flowcontrol"
)

type Interface interface {
        Discovery() discovery.DiscoveryInterface
        OpenshiftpipelinesV1alpha1() openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Interface
}

// Clientset contains the clients for groups.
type Clientset struct {
        *discovery.DiscoveryClient
        openshiftpipelinesV1alpha1 *openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Client
}

// OpenshiftpipelinesV1alpha1 retrieves the OpenshiftpipelinesV1alpha1Client
func (c *Clientset) OpenshiftpipelinesV1alpha1() openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Interface <span class="cov0" title="0">{
        return c.openshiftpipelinesV1alpha1
}</span>

// Discovery retrieves the DiscoveryClient
func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.DiscoveryClient</span>
}

// NewForConfig creates a new Clientset for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfig will generate a rate-limiter in configShallowCopy.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c

        if configShallowCopy.UserAgent == "" </span><span class="cov0" title="0">{
                configShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        // share the transport between all clients
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span>
}

// NewForConfigAndClient creates a new Clientset for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfigAndClient will generate a rate-limiter in configShallowCopy.
func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c
        if configShallowCopy.RateLimiter == nil &amp;&amp; configShallowCopy.QPS &gt; 0 </span><span class="cov0" title="0">{
                if configShallowCopy.Burst &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0")
                }</span>
                <span class="cov0" title="0">configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)</span>
        }

        <span class="cov0" title="0">var cs Clientset
        var err error
        cs.openshiftpipelinesV1alpha1, err = openshiftpipelinesv1alpha1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cs, nil</span>
}

// NewForConfigOrDie creates a new Clientset for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *Clientset <span class="cov0" title="0">{
        cs, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cs</span>
}

// New creates a new Clientset for the given RESTClient.
func New(c rest.Interface) *Clientset <span class="cov0" title="0">{
        var cs Clientset
        cs.openshiftpipelinesV1alpha1 = openshiftpipelinesv1alpha1.New(c)

        cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
        return &amp;cs
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        clientset "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned"
        openshiftpipelinesv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1"
        fakeopenshiftpipelinesv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/fake"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/discovery"
        fakediscovery "k8s.io/client-go/discovery/fake"
        "k8s.io/client-go/testing"
)

// NewSimpleClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any field management, validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
//
// DEPRECATED: NewClientset replaces this with support for field management, which significantly improves
// server side apply testing. NewClientset is only available when apply configurations are generated (e.g.
// via --with-applyconfig).
func NewSimpleClientset(objects ...runtime.Object) *Clientset <span class="cov8" title="1">{
        o := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())
        for _, obj := range objects </span><span class="cov0" title="0">{
                if err := o.Add(obj); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov8" title="1">cs := &amp;Clientset{tracker: o}
        cs.discovery = &amp;fakediscovery.FakeDiscovery{Fake: &amp;cs.Fake}
        cs.AddReactor("*", "*", testing.ObjectReaction(o))
        cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) </span><span class="cov0" title="0">{
                gvr := action.GetResource()
                ns := action.GetNamespace()
                watch, err := o.Watch(gvr, ns)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">return true, watch, nil</span>
        })

        <span class="cov8" title="1">return cs</span>
}

// Clientset implements clientset.Interface. Meant to be embedded into a
// struct to get a default implementation. This makes faking out just the method
// you want to test easier.
type Clientset struct {
        testing.Fake
        discovery *fakediscovery.FakeDiscovery
        tracker   testing.ObjectTracker
}

func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        return c.discovery
}</span>

func (c *Clientset) Tracker() testing.ObjectTracker <span class="cov0" title="0">{
        return c.tracker
}</span>

var (
        _ clientset.Interface = &amp;Clientset{}
        _ testing.FakeClient  = &amp;Clientset{}
)

// OpenshiftpipelinesV1alpha1 retrieves the OpenshiftpipelinesV1alpha1Client
func (c *Clientset) OpenshiftpipelinesV1alpha1() openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Interface <span class="cov8" title="1">{
        return &amp;fakeopenshiftpipelinesv1alpha1.FakeOpenshiftpipelinesV1alpha1{Fake: &amp;c.Fake}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        openshiftpipelinesv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var scheme = runtime.NewScheme()
var codecs = serializer.NewCodecFactory(scheme)

var localSchemeBuilder = runtime.SchemeBuilder{
        openshiftpipelinesv1alpha1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov8" title="1">{
        v1.AddToGroupVersion(scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(scheme))
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package scheme

import (
        openshiftpipelinesv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var Scheme = runtime.NewScheme()
var Codecs = serializer.NewCodecFactory(Scheme)
var ParameterCodec = runtime.NewParameterCodec(Scheme)
var localSchemeBuilder = runtime.SchemeBuilder{
        openshiftpipelinesv1alpha1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov8" title="1">{
        v1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(Scheme))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        approvaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        scheme "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// ApprovalTasksGetter has a method to return a ApprovalTaskInterface.
// A group's client should implement this interface.
type ApprovalTasksGetter interface {
        ApprovalTasks(namespace string) ApprovalTaskInterface
}

// ApprovalTaskInterface has methods to work with ApprovalTask resources.
type ApprovalTaskInterface interface {
        Create(ctx context.Context, approvalTask *approvaltaskv1alpha1.ApprovalTask, opts v1.CreateOptions) (*approvaltaskv1alpha1.ApprovalTask, error)
        Update(ctx context.Context, approvalTask *approvaltaskv1alpha1.ApprovalTask, opts v1.UpdateOptions) (*approvaltaskv1alpha1.ApprovalTask, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, approvalTask *approvaltaskv1alpha1.ApprovalTask, opts v1.UpdateOptions) (*approvaltaskv1alpha1.ApprovalTask, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*approvaltaskv1alpha1.ApprovalTask, error)
        List(ctx context.Context, opts v1.ListOptions) (*approvaltaskv1alpha1.ApprovalTaskList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *approvaltaskv1alpha1.ApprovalTask, err error)
        ApprovalTaskExpansion
}

// approvalTasks implements ApprovalTaskInterface
type approvalTasks struct {
        *gentype.ClientWithList[*approvaltaskv1alpha1.ApprovalTask, *approvaltaskv1alpha1.ApprovalTaskList]
}

// newApprovalTasks returns a ApprovalTasks
func newApprovalTasks(c *OpenshiftpipelinesV1alpha1Client, namespace string) *approvalTasks <span class="cov0" title="0">{
        return &amp;approvalTasks{
                gentype.NewClientWithList[*approvaltaskv1alpha1.ApprovalTask, *approvaltaskv1alpha1.ApprovalTaskList](
                        "approvaltasks",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *approvaltaskv1alpha1.ApprovalTask </span><span class="cov0" title="0">{ return &amp;approvaltaskv1alpha1.ApprovalTask{} }</span>,
                        func() *approvaltaskv1alpha1.ApprovalTaskList <span class="cov0" title="0">{ return &amp;approvaltaskv1alpha1.ApprovalTaskList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        http "net/http"

        approvaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        scheme "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type OpenshiftpipelinesV1alpha1Interface interface {
        RESTClient() rest.Interface
        ApprovalTasksGetter
}

// OpenshiftpipelinesV1alpha1Client is used to interact with features provided by the openshiftpipelines.org group.
type OpenshiftpipelinesV1alpha1Client struct {
        restClient rest.Interface
}

func (c *OpenshiftpipelinesV1alpha1Client) ApprovalTasks(namespace string) ApprovalTaskInterface <span class="cov0" title="0">{
        return newApprovalTasks(c, namespace)
}</span>

// NewForConfig creates a new OpenshiftpipelinesV1alpha1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*OpenshiftpipelinesV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new OpenshiftpipelinesV1alpha1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*OpenshiftpipelinesV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;OpenshiftpipelinesV1alpha1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new OpenshiftpipelinesV1alpha1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *OpenshiftpipelinesV1alpha1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new OpenshiftpipelinesV1alpha1Client for the given RESTClient.
func New(c rest.Interface) *OpenshiftpipelinesV1alpha1Client <span class="cov0" title="0">{
        return &amp;OpenshiftpipelinesV1alpha1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := approvaltaskv1alpha1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *OpenshiftpipelinesV1alpha1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        approvaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeApprovalTasks implements ApprovalTaskInterface
type fakeApprovalTasks struct {
        *gentype.FakeClientWithList[*v1alpha1.ApprovalTask, *v1alpha1.ApprovalTaskList]
        Fake *FakeOpenshiftpipelinesV1alpha1
}

func newFakeApprovalTasks(fake *FakeOpenshiftpipelinesV1alpha1, namespace string) approvaltaskv1alpha1.ApprovalTaskInterface <span class="cov8" title="1">{
        return &amp;fakeApprovalTasks{
                gentype.NewFakeClientWithList[*v1alpha1.ApprovalTask, *v1alpha1.ApprovalTaskList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("approvaltasks"),
                        v1alpha1.SchemeGroupVersion.WithKind("ApprovalTask"),
                        func() *v1alpha1.ApprovalTask </span><span class="cov8" title="1">{ return &amp;v1alpha1.ApprovalTask{} }</span>,
                        func() *v1alpha1.ApprovalTaskList <span class="cov0" title="0">{ return &amp;v1alpha1.ApprovalTaskList{} }</span>,
                        func(dst, src *v1alpha1.ApprovalTaskList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.ApprovalTaskList) []*v1alpha1.ApprovalTask <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.ApprovalTaskList, items []*v1alpha1.ApprovalTask) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeOpenshiftpipelinesV1alpha1 struct {
        *testing.Fake
}

func (c *FakeOpenshiftpipelinesV1alpha1) ApprovalTasks(namespace string) v1alpha1.ApprovalTaskInterface <span class="cov8" title="1">{
        return newFakeApprovalTasks(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeOpenshiftpipelinesV1alpha1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package approvaltask

import (
        v1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1"
        internalinterfaces "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to each of this group's versions.
type Interface interface {
        // V1alpha1 provides access to shared informers for resources in V1alpha1.
        V1alpha1() v1alpha1.Interface
}

type group struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// V1alpha1 returns a new v1alpha1.Interface.
func (g *group) V1alpha1() v1alpha1.Interface <span class="cov0" title="0">{
        return v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apisapprovaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        versioned "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned"
        internalinterfaces "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces"
        approvaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/listers/approvaltask/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// ApprovalTaskInformer provides access to a shared informer and lister for
// ApprovalTasks.
type ApprovalTaskInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() approvaltaskv1alpha1.ApprovalTaskLister
}

type approvalTaskInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewApprovalTaskInformer constructs a new informer for ApprovalTask type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewApprovalTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredApprovalTaskInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredApprovalTaskInformer constructs a new informer for ApprovalTask type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredApprovalTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.OpenshiftpipelinesV1alpha1().ApprovalTasks(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.OpenshiftpipelinesV1alpha1().ApprovalTasks(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apisapprovaltaskv1alpha1.ApprovalTask{},
                resyncPeriod,
                indexers,
        )
}

func (f *approvalTaskInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredApprovalTaskInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *approvalTaskInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apisapprovaltaskv1alpha1.ApprovalTask{}, f.defaultInformer)
}</span>

func (f *approvalTaskInformer) Lister() approvaltaskv1alpha1.ApprovalTaskLister <span class="cov0" title="0">{
        return approvaltaskv1alpha1.NewApprovalTaskLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        internalinterfaces "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // ApprovalTasks returns a ApprovalTaskInformer.
        ApprovalTasks() ApprovalTaskInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// ApprovalTasks returns a ApprovalTaskInformer.
func (v *version) ApprovalTasks() ApprovalTaskInformer <span class="cov0" title="0">{
        return &amp;approvalTaskInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        reflect "reflect"
        sync "sync"
        time "time"

        versioned "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned"
        approvaltask "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask"
        internalinterfaces "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
        client           versioned.Interface
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        lock             sync.Mutex
        defaultResync    time.Duration
        customResync     map[reflect.Type]time.Duration
        transform        cache.TransformFunc

        informers map[reflect.Type]cache.SharedIndexInformer
        // startedInformers is used for tracking which informers have been started.
        // This allows Start() to be called multiple times safely.
        startedInformers map[reflect.Type]bool
        // wg tracks how many goroutines were started.
        wg sync.WaitGroup
        // shuttingDown is true when Shutdown has been called. It may still be running
        // because it needs to wait for goroutines.
        shuttingDown bool
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                for k, v := range resyncConfig </span><span class="cov0" title="0">{
                        factory.customResync[reflect.TypeOf(k)] = v
                }</span>
                <span class="cov0" title="0">return factory</span>
        }
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.tweakListOptions = tweakListOptions
                return factory
        }</span>
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.namespace = namespace
                return factory
        }</span>
}

// WithTransform sets a transform on all informers.
func WithTransform(transform cache.TransformFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.transform = transform
                return factory
        }</span>
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client versioned.Interface, defaultResync time.Duration) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync)
}</span>

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client versioned.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}</span>

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client versioned.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory <span class="cov0" title="0">{
        factory := &amp;sharedInformerFactory{
                client:           client,
                namespace:        v1.NamespaceAll,
                defaultResync:    defaultResync,
                informers:        make(map[reflect.Type]cache.SharedIndexInformer),
                startedInformers: make(map[reflect.Type]bool),
                customResync:     make(map[reflect.Type]time.Duration),
        }

        // Apply all options
        for _, opt := range options </span><span class="cov0" title="0">{
                factory = opt(factory)
        }</span>

        <span class="cov0" title="0">return factory</span>
}

func (f *sharedInformerFactory) Start(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        if f.shuttingDown </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                if !f.startedInformers[informerType] </span><span class="cov0" title="0">{
                        f.wg.Add(1)
                        // We need a new variable in each loop iteration,
                        // otherwise the goroutine would use the loop variable
                        // and that keeps changing.
                        informer := informer
                        go func() </span><span class="cov0" title="0">{
                                defer f.wg.Done()
                                informer.Run(stopCh)
                        }</span>()
                        <span class="cov0" title="0">f.startedInformers[informerType] = true</span>
                }
        }
}

func (f *sharedInformerFactory) Shutdown() <span class="cov0" title="0">{
        f.lock.Lock()
        f.shuttingDown = true
        f.lock.Unlock()

        // Will return immediately if there is nothing to wait for.
        f.wg.Wait()
}</span>

func (f *sharedInformerFactory) WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool <span class="cov0" title="0">{
        informers := func() map[reflect.Type]cache.SharedIndexInformer </span><span class="cov0" title="0">{
                f.lock.Lock()
                defer f.lock.Unlock()

                informers := map[reflect.Type]cache.SharedIndexInformer{}
                for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                        if f.startedInformers[informerType] </span><span class="cov0" title="0">{
                                informers[informerType] = informer
                        }</span>
                }
                <span class="cov0" title="0">return informers</span>
        }()

        <span class="cov0" title="0">res := map[reflect.Type]bool{}
        for informType, informer := range informers </span><span class="cov0" title="0">{
                res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
        }</span>
        <span class="cov0" title="0">return res</span>
}

// InformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        informerType := reflect.TypeOf(obj)
        informer, exists := f.informers[informerType]
        if exists </span><span class="cov0" title="0">{
                return informer
        }</span>

        <span class="cov0" title="0">resyncPeriod, exists := f.customResync[informerType]
        if !exists </span><span class="cov0" title="0">{
                resyncPeriod = f.defaultResync
        }</span>

        <span class="cov0" title="0">informer = newFunc(f.client, resyncPeriod)
        informer.SetTransform(f.transform)
        f.informers[informerType] = informer

        return informer</span>
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
//
// It is typically used like this:
//
//        ctx, cancel := context.Background()
//        defer cancel()
//        factory := NewSharedInformerFactory(client, resyncPeriod)
//        defer factory.WaitForStop()    // Returns immediately if nothing was started.
//        genericInformer := factory.ForResource(resource)
//        typedInformer := factory.SomeAPIGroup().V1().SomeType()
//        factory.Start(ctx.Done())          // Start processing these informers.
//        synced := factory.WaitForCacheSync(ctx.Done())
//        for v, ok := range synced {
//            if !ok {
//                fmt.Fprintf(os.Stderr, "caches failed to sync: %v", v)
//                return
//            }
//        }
//
//        // Creating informers can also be created after Start, but then
//        // Start must be called again:
//        anotherGenericInformer := factory.ForResource(resource)
//        factory.Start(ctx.Done())
type SharedInformerFactory interface {
        internalinterfaces.SharedInformerFactory

        // Start initializes all requested informers. They are handled in goroutines
        // which run until the stop channel gets closed.
        // Warning: Start does not block. When run in a go-routine, it will race with a later WaitForCacheSync.
        Start(stopCh &lt;-chan struct{})

        // Shutdown marks a factory as shutting down. At that point no new
        // informers can be started anymore and Start will return without
        // doing anything.
        //
        // In addition, Shutdown blocks until all goroutines have terminated. For that
        // to happen, the close channel(s) that they were started with must be closed,
        // either before Shutdown gets called or while it is waiting.
        //
        // Shutdown may be called multiple times, even concurrently. All such calls will
        // block until all goroutines have terminated.
        Shutdown()

        // WaitForCacheSync blocks until all started informers' caches were synced
        // or the stop channel gets closed.
        WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

        // ForResource gives generic access to a shared informer of the matching type.
        ForResource(resource schema.GroupVersionResource) (GenericInformer, error)

        // InformerFor returns the SharedIndexInformer for obj using an internal
        // client.
        InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer

        Openshiftpipelines() approvaltask.Interface
}

func (f *sharedInformerFactory) Openshiftpipelines() approvaltask.Interface <span class="cov0" title="0">{
        return approvaltask.New(f, f.namespace, f.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        fmt "fmt"

        v1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
// sharedInformers based on type
type GenericInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() cache.GenericLister
}

type genericInformer struct {
        informer cache.SharedIndexInformer
        resource schema.GroupResource
}

// Informer returns the SharedIndexInformer.
func (f *genericInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.informer
}</span>

// Lister returns the GenericLister.
func (f *genericInformer) Lister() cache.GenericLister <span class="cov0" title="0">{
        return cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)
}</span>

// ForResource gives generic access to a shared informer of the matching type
// TODO extend this to unknown resources with a client pool
func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) <span class="cov0" title="0">{
        switch resource </span>{
        // Group=openshiftpipelines.org, Version=v1alpha1
        case v1alpha1.SchemeGroupVersion.WithResource("approvaltasks"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Openshiftpipelines().V1alpha1().ApprovalTasks().Informer()}, nil</span>

        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no informer found for %v", resource)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package client

import (
        context "context"

        versioned "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(withClientFromConfig)
        injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))
}</span>

// Get extracts the versioned.Interface client from the context.
func Get(ctx context.Context) versioned.Interface <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                if injection.GetConfig(ctx) == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
                }</span> else<span class="cov0" title="0"> {
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned.Interface from context.")
                }</span>
        }
        <span class="cov0" title="0">return untyped.(versioned.Interface)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/fake"
        client "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client"
        runtime "k8s.io/apimachinery/pkg/runtime"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(withClient)
        injection.Fake.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

func withClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        ctx, _ = With(ctx)
        return ctx
}</span>

func With(ctx context.Context, objects ...runtime.Object) (context.Context, *fake.Clientset) <span class="cov0" title="0">{
        cs := fake.NewSimpleClientset(objects...)
        return context.WithValue(ctx, client.Key{}, cs), cs
}</span>

// Get extracts the Kubernetes client from the context.
func Get(ctx context.Context) *fake.Clientset <span class="cov0" title="0">{
        untyped := ctx.Value(client.Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/fake.Clientset from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(*fake.Clientset)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package approvaltask

import (
        context "context"

        v1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1"
        factory "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.ApprovalTaskInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1.ApprovalTaskInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ApprovalTaskInformer)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        approvaltask "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask"
        fake "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/fake"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = approvaltask.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()
        return context.WithValue(ctx, approvaltask.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1"
        filtered "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.ApprovalTaskInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1.ApprovalTaskInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ApprovalTaskInformer)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        filtered "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/filtered"
        factoryfiltered "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package factory

import (
        context "context"

        externalversions "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions"
        client "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions.SharedInformerFactory from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        externalversions "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions"
        fake "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client/fake"
        factory "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = factory.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, factory.Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fakeFilteredFactory

import (
        context "context"

        externalversions "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions"
        fake "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client/fake"
        filtered "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selector
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, filtered.Key{Selector: selector},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filteredFactory

import (
        context "context"

        externalversions "github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions"
        client "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct {
        Selector string
}

type LabelKey struct{}

func WithSelectors(ctx context.Context, selector ...string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LabelKey{}, selector)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        untyped := ctx.Value(LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selector
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, Key{Selector: selector},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context, selector string) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions.SharedInformerFactory with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        approvaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// ApprovalTaskLister helps list ApprovalTasks.
// All objects returned here must be treated as read-only.
type ApprovalTaskLister interface {
        // List lists all ApprovalTasks in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*approvaltaskv1alpha1.ApprovalTask, err error)
        // ApprovalTasks returns an object that can list and get ApprovalTasks.
        ApprovalTasks(namespace string) ApprovalTaskNamespaceLister
        ApprovalTaskListerExpansion
}

// approvalTaskLister implements the ApprovalTaskLister interface.
type approvalTaskLister struct {
        listers.ResourceIndexer[*approvaltaskv1alpha1.ApprovalTask]
}

// NewApprovalTaskLister returns a new ApprovalTaskLister.
func NewApprovalTaskLister(indexer cache.Indexer) ApprovalTaskLister <span class="cov0" title="0">{
        return &amp;approvalTaskLister{listers.New[*approvaltaskv1alpha1.ApprovalTask](indexer, approvaltaskv1alpha1.Resource("approvaltask"))}
}</span>

// ApprovalTasks returns an object that can list and get ApprovalTasks.
func (s *approvalTaskLister) ApprovalTasks(namespace string) ApprovalTaskNamespaceLister <span class="cov0" title="0">{
        return approvalTaskNamespaceLister{listers.NewNamespaced[*approvaltaskv1alpha1.ApprovalTask](s.ResourceIndexer, namespace)}
}</span>

// ApprovalTaskNamespaceLister helps list and get ApprovalTasks.
// All objects returned here must be treated as read-only.
type ApprovalTaskNamespaceLister interface {
        // List lists all ApprovalTasks in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*approvaltaskv1alpha1.ApprovalTask, err error)
        // Get retrieves the ApprovalTask from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*approvaltaskv1alpha1.ApprovalTask, error)
        ApprovalTaskNamespaceListerExpansion
}

// approvalTaskNamespaceLister implements the ApprovalTaskNamespaceLister
// interface.
type approvalTaskNamespaceLister struct {
        listers.ResourceIndexer[*approvaltaskv1alpha1.ApprovalTask]
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package approvaltask

import (
        "context"
        "encoding/json"
        "fmt"
        "log"
        "time"

        "github.com/hashicorp/go-multierror"
        approvaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        approvaltaskclientset "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned"
        listersapprovaltask "github.com/openshift-pipelines/manual-approval-gate/pkg/client/listers/approvaltask/v1alpha1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        clientset "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        customrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun"
        listersalpha "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/reconciler/events"
        "go.uber.org/zap"
        "gomodules.xyz/jsonpatch/v2"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/utils/clock"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        // approvaltaskLabelKey is the label identifier for a ApprovalTask.  This label is added to the Run and its TaskRuns.
        approvaltaskLabelKey = "/approvaltask"

        // approvaltaskRunLabelKey is the label identifier for a Run.  This label is added to the Run's TaskRuns.
        approvaltaskRunLabelKey = "/run"

        pendingState      = "pending"
        approvedState     = "approved"
        rejectedState     = "rejected"
        hasApproved       = "approve"
        hasRejected       = "reject"
        allApprovers      = "approvers"
        approvalsRequired = "numberOfApprovalsRequired"
        description       = "description"

        // CustomRunLabelKey is used as the label identifier for a ApprovalTask
        CustomRunLabelKey = "tekton.dev/customRun"

        LastAppliedHashKey = "tekton.dev/last-applied-hash"
)

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
        clock                 clock.PassiveClock
        pipelineClientSet     clientset.Interface
        kubeClientSet         kubernetes.Interface
        approvaltaskClientSet approvaltaskclientset.Interface
        runLister             listersalpha.RunLister
        customRunLister       listers.CustomRunLister
        approvaltaskLister    listersapprovaltask.ApprovalTaskLister
        taskRunLister         listers.TaskRunLister
}

var (
        // Check that our Reconciler implements runreconciler.Interface
        _                customrunreconciler.Interface = (*Reconciler)(nil)
        cancelPatchBytes []byte
)

func init() <span class="cov8" title="1">{
        var err error
        patches := []jsonpatch.JsonPatchOperation{{
                Operation: "add",
                Path:      "/spec/status",
                Value:     v1beta1.TaskRunSpecStatusCancelled,
        }}
        cancelPatchBytes, err = json.Marshal(patches)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to marshal patch bytes in order to cancel: %v", err)
        }</span>
}

// ReconcileKind compares the actual state with the desired, and attempts to converge the two.
// It then updates the Status block of the Run resource with the current status of the resource.
func (c *Reconciler) ReconcileKind(ctx context.Context, run *v1beta1.CustomRun) pkgreconciler.Event <span class="cov0" title="0">{
        var merr error
        logger := logging.FromContext(ctx)
        logger.Infof("Reconciling Run %s/%s at %v", run.Namespace, run.Name, time.Now())

        // Check that the Run references a ApprovalTask CRD.  The logic is controller.go should ensure that only this type of Run
        // is reconciled this controller but it never hurts to do some bullet-proofing.
        if err := checkCustomRunReferencesApprovalTask(run); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If the Run has not started, initialize the Condition and set the start time.
        <span class="cov0" title="0">initializeCustomRun(ctx, run)

        if run.IsDone() </span><span class="cov0" title="0">{
                logger.Infof("Run %s/%s is done", run.Namespace, run.Name)
                return nil
        }</span>

        // Validate parameters early for fail-fast behavior
        <span class="cov0" title="0">if err := ValidateCustomRunParameters(run); err != nil </span><span class="cov0" title="0">{
                detailedMsg := fmt.Sprintf("ApprovalTask validation failed: %s", err.Error())
                run.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonFailedValidation.String(),
                        detailedMsg)
                logger.Errorf("Parameter validation failed for Run %s/%s: %v", run.Namespace, run.Name, err)
                
                // Emit an event with detailed error message for better visibility
                events.Emit(ctx, nil, &amp;apis.Condition{
                        Type:    apis.ConditionSucceeded,
                        Status:  "False",
                        Reason:  approvaltaskv1alpha1.ApprovalTaskRunReasonFailedValidation.String(), 
                        Message: detailedMsg,
                }, run)
                return nil
        }</span>

        // Store the condition before reconcile
        <span class="cov0" title="0">beforeCondition := run.Status.GetCondition(apis.ConditionSucceeded)

        status := &amp;approvaltaskv1alpha1.ApprovalTaskRunStatus{}
        if err := run.Status.DecodeExtraFields(status); err != nil </span><span class="cov0" title="0">{
                run.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonInternalError.String(),
                        "Internal error calling DecodeExtraFields: %v", err)
                logger.Errorf("DecodeExtraFields error: %v", err.Error())
        }</span>

        // Reconcile the Run
        <span class="cov0" title="0">if err := c.reconcile(ctx, run, status); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Reconcile error: %v", err.Error())
                merr = multierror.Append(merr, err)
                return merr
        }</span>

        <span class="cov0" title="0">if err := c.updateLabelsAndAnnotations(ctx, run); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to update Run labels/annotations", zap.Error(err))
                merr = multierror.Append(merr, err)
        }</span>

        <span class="cov0" title="0">if err := run.Status.EncodeExtraFields(status); err != nil </span><span class="cov0" title="0">{
                run.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonInternalError.String(),
                        "Internal error calling EncodeExtraFields: %v", err)
                logger.Errorf("EncodeExtraFields error: %v", err.Error())
        }</span>

        <span class="cov0" title="0">afterCondition := run.Status.GetCondition(apis.ConditionSucceeded)
        events.Emit(ctx, beforeCondition, afterCondition, run)

        // Only transient errors that should retry the reconcile are returned.
        return merr</span>
}

func (r *Reconciler) reconcile(ctx context.Context, run *v1beta1.CustomRun, status *approvaltaskv1alpha1.ApprovalTaskRunStatus) error <span class="cov0" title="0">{
        // Get the ApprovalTask referenced by the Run
        logger := logging.FromContext(ctx)
        approvalTask, err := getOrCreateApprovalTask(ctx, r.approvaltaskClientSet, run)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error getting or creating the approval task: %v", err.Error())
                return err
        }</span>

        <span class="cov0" title="0">approvalTaskMeta := &amp;approvalTask.ObjectMeta
        approvalTaskSpec := approvalTask.Spec

        // Store the fetched ApprovalTaskSpec on the Run for auditing
        storeApprovalTaskSpec(status, &amp;approvalTaskSpec)

        // Propagate labels and annotations from ApprovalTask to Run.
        propagateApprovalTaskLabelsAndAnnotations(run, approvalTaskMeta)

        if !approvalTask.HasStarted() </span><span class="cov0" title="0">{
                approvalTask.Status.StartTime = &amp;approvalTask.CreationTimestamp
        }</span>

        <span class="cov0" title="0">timeout := run.Spec.Timeout
        if timeout == nil </span><span class="cov0" title="0">{
                timeout = &amp;metav1.Duration{Duration: time.Duration(60) * time.Minute}
        }</span>
        <span class="cov0" title="0">if approvalTask.ApprovalTaskHasTimedOut(ctx, r.clock, timeout.Duration) </span><span class="cov0" title="0">{
                approvalTask.Status.State = rejectedState
                _, err := r.approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(approvalTask.Namespace).UpdateStatus(ctx, approvalTask, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">message := fmt.Sprintf("Approval task %s is failed because of timeout", approvalTask.Name)
                run.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonFailed.String(), message)
                return nil</span>
        }

        <span class="cov0" title="0">if err := r.checkIfUpdateRequired(ctx, *approvalTask, run); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if approvalTask.Status.StartTime != nil </span><span class="cov0" title="0">{
                elapsed := r.clock.Since(approvalTask.Status.StartTime.Time)
                waitTime := timeout.Duration - elapsed
                return controller.NewRequeueAfter(waitTime)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2022 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package approvaltask

import (
        "context"

        "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask"
        approvaltaskv1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        approvaltaskclient "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client"
        approvaltaskinformer "github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask"
        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        customruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun"
        customrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun"
        pipelinecontroller "github.com/tektoncd/pipeline/pkg/controller"
        "k8s.io/client-go/tools/cache"
        "k8s.io/utils/clock"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController instantiates a new controller.Impl from knative.dev/pkg/controller
func NewController(clock clock.PassiveClock) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{

                logger := logging.FromContext(ctx)
                kubeclientset := kubeclient.Get(ctx)
                pipelineclientset := pipelineclient.Get(ctx)
                approvaltaskclientset := approvaltaskclient.Get(ctx)
                customRunInformer := customruninformer.Get(ctx)
                approvaltaskInformer := approvaltaskinformer.Get(ctx)

                c := &amp;Reconciler{
                        clock:                 clock,
                        kubeClientSet:         kubeclientset,
                        pipelineClientSet:     pipelineclientset,
                        approvaltaskClientSet: approvaltaskclientset,
                        customRunLister:       customRunInformer.Lister(),
                        approvaltaskLister:    approvaltaskInformer.Lister(),
                }

                impl := customrunreconciler.NewImpl(ctx, c, func(impl *controller.Impl) controller.Options </span><span class="cov0" title="0">{
                        return controller.Options{
                                AgentName: "run-approvaltask",
                        }
                }</span>)

                <span class="cov0" title="0">logger.Info("Setting up event handlers")

                // Add event handler for Runs
                customRunInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: pipelinecontroller.FilterCustomRunRef(approvaltaskv1alpha1.SchemeGroupVersion.String(), approvaltask.ControllerName),
                        Handler:    controller.HandleAll(impl.Enqueue),
                })

                approvaltaskInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue))

                return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2023 The OpenShift Pipelines Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package approvaltask

import (
        "context"
        "crypto/sha256"
        "encoding/json"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask"
        v1alpha1 "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        "github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/reconciler/events"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
)

var (
        gvk = schema.GroupVersionKind{Group: "tekton.dev", Version: "v1beta1", Kind: "CustomRun"}
)

// validateApproverParameter validates a single approver string (user or group format).
func validateApproverParameter(paramValue string, paramIndex int) error <span class="cov8" title="1">{
        if strings.TrimSpace(paramValue) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("approvers[%d]: approver name cannot be empty", paramIndex)
        }</span>

        // Check for malformed group syntax
        <span class="cov8" title="1">if strings.Contains(paramValue, " :") || strings.Contains(paramValue, ": ") </span><span class="cov8" title="1">{
                                        return fmt.Errorf("approvers[%d]: invalid group format '%s' - use 'group:groupname' format (remove spaces around colon)", paramIndex, paramValue)
        }</span>

        // Handle explicit group syntax: "group:groupname"
        <span class="cov8" title="1">if strings.HasPrefix(paramValue, "group:") </span><span class="cov8" title="1">{
                return validateGroupSyntax(paramValue, paramIndex)
        }</span>

        <span class="cov8" title="1">return validateUserSyntax(paramValue, paramIndex)</span>
}

// validateGroupSyntax validates the "group:groupname" format and ensures proper syntax.
func validateGroupSyntax(paramValue string, paramIndex int) error <span class="cov8" title="1">{
        parts := strings.SplitN(paramValue, ":", 2)
        if len(parts) != 2 || strings.TrimSpace(parts[1]) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("approvers[%d]: invalid group format '%s' - group name cannot be empty after 'group:'", paramIndex, paramValue)
        }</span>
        
        <span class="cov8" title="1">groupName := parts[1]
        // Validate group name format inline
        if strings.TrimSpace(groupName) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("approvers[%d]: group name cannot be empty", paramIndex)
        }</span>
        <span class="cov8" title="1">if strings.Contains(groupName, ":") </span><span class="cov0" title="0">{
                return fmt.Errorf("approvers[%d]: group name '%s' cannot contain colons", paramIndex, groupName)
        }</span>
        <span class="cov8" title="1">if strings.Contains(groupName, " ") </span><span class="cov8" title="1">{
                return fmt.Errorf("approvers[%d]: group name '%s' cannot contain spaces", paramIndex, groupName)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// validateUserSyntax validates a plain username approver.
func validateUserSyntax(paramValue string, paramIndex int) error <span class="cov8" title="1">{
        // Validate user name format inline
        if strings.TrimSpace(paramValue) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("approvers[%d]: username cannot be empty", paramIndex)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// ValidateCustomRunParameters validates CustomRun parameters for early error detection.
func ValidateCustomRunParameters(run *v1beta1.CustomRun) error <span class="cov8" title="1">{
        var hasApprovers bool
        var approversCount int
        var validationErrors []string

        for _, param := range run.Spec.Params </span><span class="cov8" title="1">{
                switch param.Name </span>{
                case allApprovers:<span class="cov8" title="1">
                        hasApprovers = true
                        count, errs := validateApproversParam(param)
                        approversCount = count
                        validationErrors = append(validationErrors, errs...)</span>
                case approvalsRequired:<span class="cov8" title="1">
                        if err := validateApprovalsRequired(param.Value.StringVal); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(validationErrors) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid approvers parameter: %s", validationErrors[0])
        }</span>

        <span class="cov8" title="1">if !hasApprovers </span><span class="cov8" title="1">{
                return fmt.Errorf("no valid approvers found - at least one approver is required")
        }</span>

        <span class="cov8" title="1">if approversCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no valid approvers found - at least one approver is required")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateApproversParam validates the approvers parameter and returns count + errors
func validateApproversParam(param v1beta1.Param) (int, []string) <span class="cov8" title="1">{
        var validationErrors []string
        var approversCount int

        // Parse approvers list from different formats
        approverList := parseApproversList(param, &amp;validationErrors)

        // Validate each approver
        for i, approver := range approverList </span><span class="cov8" title="1">{
                switch val := approver.(type) </span>{
                case string:<span class="cov8" title="1">
                        if err := validateApproverParameter(val, i); err != nil </span><span class="cov8" title="1">{
                                validationErrors = append(validationErrors, err.Error())
                        }</span> else<span class="cov8" title="1"> {
                                approversCount++
                        }</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        validateMalformedObjectApprover(val, i, &amp;validationErrors)</span>
                default:<span class="cov0" title="0">
                        validationErrors = append(validationErrors, fmt.Sprintf("approvers[%d]: invalid approver format - must be a string", i))</span>
                }
        }

        <span class="cov8" title="1">return approversCount, validationErrors</span>
}

// parseApproversList extracts approvers from different parameter formats
func parseApproversList(param v1beta1.Param, validationErrors *[]string) []interface{} <span class="cov8" title="1">{
        var approverList []interface{}

        if len(param.Value.ArrayVal) &gt; 0 </span><span class="cov8" title="1">{
                for _, approver := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                        approverList = append(approverList, approver)
                }</span>
        }

        <span class="cov8" title="1">if len(param.Value.ObjectVal) &gt; 0 </span><span class="cov8" title="1">{
                // Convert map[string]string to map[string]interface{} for proper handling
                objectVal := make(map[string]interface{})
                for k, v := range param.Value.ObjectVal </span><span class="cov8" title="1">{
                        objectVal[k] = v
                }</span>
                <span class="cov8" title="1">approverList = append(approverList, objectVal)</span>
        }

        <span class="cov8" title="1">if param.Value.StringVal != "" &amp;&amp; len(approverList) == 0 </span><span class="cov8" title="1">{
                var jsonData interface{}
                if err := json.Unmarshal([]byte(param.Value.StringVal), &amp;jsonData); err != nil </span><span class="cov8" title="1">{
                        *validationErrors = append(*validationErrors, fmt.Sprintf("failed to parse JSON '%s' - %v", param.Value.StringVal, err))
                        return approverList
                }</span>
                
                <span class="cov0" title="0">if arr, ok := jsonData.([]interface{}); ok </span><span class="cov0" title="0">{
                        approverList = arr
                }</span> else<span class="cov0" title="0"> {
                        *validationErrors = append(*validationErrors, "expected an array of approvers")
                }</span>
        }

        <span class="cov8" title="1">return approverList</span>
}

// validateMalformedObjectApprover validates malformed object approvers (from YAML with spaces)
func validateMalformedObjectApprover(approver map[string]interface{}, index int, validationErrors *[]string) <span class="cov8" title="1">{
        if groupName, ok := approver["group"]; ok </span><span class="cov8" title="1">{
                if groupStr, ok := groupName.(string); ok </span><span class="cov8" title="1">{
                        // Format the object as JSON for clear error message
                        objJSON := fmt.Sprintf(`{"group":"%s"}`, groupStr)
                        *validationErrors = append(*validationErrors, fmt.Sprintf("approvers[%d]: invalid group format %s - use 'group:%s' format instead", index, objJSON, groupStr))
                }</span> else<span class="cov0" title="0"> {
                        *validationErrors = append(*validationErrors, fmt.Sprintf("approvers[%d]: invalid group specification", index))
                }</span>
        } else<span class="cov8" title="1"> {
                // Handle other object formats
                objJSON, _ := json.Marshal(approver)
                *validationErrors = append(*validationErrors, fmt.Sprintf("approvers[%d]: invalid object format %s - approver must be a string, not an object", index, string(objJSON)))
        }</span>
}

// validateApprovalsRequired validates the numberOfApprovalsRequired parameter value.
func validateApprovalsRequired(value string) error <span class="cov8" title="1">{
        approvals, err := strconv.Atoi(value)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid numberOfApprovalsRequired parameter: '%s' is not a valid integer", value)
        }</span>
        <span class="cov8" title="1">if approvals &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid numberOfApprovalsRequired parameter: must be greater than 0, got %d", approvals)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func checkCustomRunReferencesApprovalTask(run *v1beta1.CustomRun) error <span class="cov8" title="1">{
        var apiVersion, kind string
        if run.Spec.CustomRef != nil </span><span class="cov8" title="1">{
                apiVersion = run.Spec.CustomRef.APIVersion
                kind = string(run.Spec.CustomRef.Kind)
        }</span> else<span class="cov0" title="0"> if run.Spec.CustomSpec != nil </span><span class="cov0" title="0">{
                apiVersion = run.Spec.CustomSpec.APIVersion
                kind = run.Spec.CustomSpec.Kind
        }</span>

        <span class="cov8" title="1">if apiVersion != v1alpha1.SchemeGroupVersion.String() ||
                kind != approvaltask.ControllerName </span><span class="cov8" title="1">{
                return fmt.Errorf("Received control for a Run %s/%s that does not reference a ApprovalTask custom CRD", run.Namespace, run.Name)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func initializeCustomRun(ctx context.Context, run *v1beta1.CustomRun) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        if !run.HasStarted() </span><span class="cov0" title="0">{
                logger.Infof("Starting new Run %s/%s", run.Namespace, run.Name)
                run.Status.InitializeConditions()
                // In case node time was not synchronized, when controller has been scheduled to other nodes.
                if run.Status.StartTime.Sub(run.CreationTimestamp.Time) &lt; 0 </span><span class="cov0" title="0">{
                        logger.Warnf("Run %s createTimestamp %s is after the Run started %s", run.Name, run.CreationTimestamp, run.Status.StartTime)
                        run.Status.StartTime = &amp;run.CreationTimestamp
                }</span>
                // Emit events. During the first reconcile the status of the Run may change twice
                // from not Started to Started and then to Running, so we need to send the event here
                // and at the end of 'Reconcile' again.
                // We also want to send the "Started" event as soon as possible for anyone who may be waiting
                // on the event to perform user facing initialisations, such as reset a CI check status
                <span class="cov0" title="0">afterCondition := run.Status.GetCondition(apis.ConditionSucceeded)
                events.Emit(ctx, nil, afterCondition, run)</span>
        }
}

func getOrCreateApprovalTask(ctx context.Context, approvaltaskClientSet versioned.Interface, run *v1beta1.CustomRun) (*v1alpha1.ApprovalTask, error) <span class="cov0" title="0">{
        approvalTask := v1alpha1.ApprovalTask{}

        if run.Spec.CustomRef != nil </span><span class="cov0" title="0">{
                // Use the k8 client to get the ApprovalTask rather than the lister.  This avoids a timing issue where
                // the ApprovalTask is not yet in the lister cache if it is created at nearly the same time as the Run.
                // See https://github.com/tektoncd/pipeline/issues/2740 for discussion on this issue.
                tl, err := approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).Get(ctx, run.Name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                at, err := createApprovalTask(ctx, approvaltaskClientSet, run)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">return &amp;at, nil</span>
                        }
                }
                <span class="cov0" title="0">approvalTask = *tl</span>
        } else<span class="cov0" title="0"> if run.Spec.CustomSpec != nil </span><span class="cov0" title="0">{
                // FIXME(openshift-pipelines) support embedded spec
                if err := json.Unmarshal(run.Spec.CustomSpec.Spec.Raw, &amp;approvalTask.Spec); err != nil </span><span class="cov0" title="0">{
                        run.Status.MarkCustomRunFailed(v1alpha1.ApprovalTaskRunReasonCouldntGetApprovalTask.String(),
                                "Error retrieving ApprovalTask for Run %s/%s: %s",
                                run.Namespace, run.Name, err)
                        return nil, fmt.Errorf("Error retrieving ApprovalTask for Run %s: %w", fmt.Sprintf("%s/%s", run.Namespace, run.Name), err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;approvalTask, nil</span>
}

func storeApprovalTaskSpec(status *v1alpha1.ApprovalTaskRunStatus, approvalTaskSpec *v1alpha1.ApprovalTaskSpec) <span class="cov0" title="0">{
        // Only store the ApprovalTaskSpec once, if it has never been set before.
        if status.ApprovalTaskSpec == nil </span><span class="cov0" title="0">{
                status.ApprovalTaskSpec = approvalTaskSpec
        }</span>
}

func propagateApprovalTaskLabelsAndAnnotations(run *v1beta1.CustomRun, approvaltaskMeta *metav1.ObjectMeta) <span class="cov8" title="1">{
        // Propagate labels from ApprovalTask to Run.
        if run.ObjectMeta.Labels == nil </span><span class="cov8" title="1">{
                run.ObjectMeta.Labels = make(map[string]string, len(approvaltaskMeta.Labels)+1)
        }</span>
        <span class="cov8" title="1">for key, value := range approvaltaskMeta.Labels </span><span class="cov0" title="0">{
                run.ObjectMeta.Labels[key] = value
        }</span>
        <span class="cov8" title="1">run.ObjectMeta.Labels[approvaltask.GroupName+approvaltaskLabelKey] = approvaltaskMeta.Name

        // Propagate annotations from ApprovalTask to Run.
        if run.ObjectMeta.Annotations == nil </span><span class="cov8" title="1">{
                run.ObjectMeta.Annotations = make(map[string]string, len(approvaltaskMeta.Annotations))
        }</span>
        <span class="cov8" title="1">for key, value := range approvaltaskMeta.Annotations </span><span class="cov0" title="0">{
                run.ObjectMeta.Annotations[key] = value
        }</span>
}

func (c *Reconciler) updateLabelsAndAnnotations(ctx context.Context, run *v1beta1.CustomRun) error <span class="cov0" title="0">{
        newRun, err := c.customRunLister.CustomRuns(run.Namespace).Get(run.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting Run %s when updating labels/annotations: %w", run.Name, err)
        }</span>
        <span class="cov0" title="0">if !reflect.DeepEqual(run.ObjectMeta.Labels, newRun.ObjectMeta.Labels) || !reflect.DeepEqual(run.ObjectMeta.Annotations, newRun.ObjectMeta.Annotations) </span><span class="cov0" title="0">{
                mergePatch := map[string]interface{}{
                        "metadata": map[string]interface{}{
                                "labels":      run.ObjectMeta.Labels,
                                "annotations": run.ObjectMeta.Annotations,
                        },
                }
                patch, err := json.Marshal(mergePatch)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = c.pipelineClientSet.TektonV1beta1().CustomRuns(run.Namespace).Patch(ctx, run.Name, types.MergePatchType, patch, metav1.PatchOptions{})
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func createApprovalTask(ctx context.Context, approvaltaskClientSet versioned.Interface, run *v1beta1.CustomRun) (v1alpha1.ApprovalTask, error) <span class="cov8" title="1">{
        var (
                approvers      []v1alpha1.ApproverDetails
                users          []string
                desc           string
                err            error
                approverExists = make(map[string]bool)
                userExists     = make(map[string]bool)
        )

        logger := logging.FromContext(ctx)
        numberOfApprovalsRequired := 1

        for _, v := range run.Spec.Params </span><span class="cov8" title="1">{
                var approver v1alpha1.ApproverDetails

                if v.Name == allApprovers </span><span class="cov8" title="1">{
                        for _, name := range v.Value.ArrayVal </span><span class="cov8" title="1">{
                                if !userExists[name] </span><span class="cov8" title="1">{
                                        approver.Name = name
                                        approver.Input = pendingState

                                        // Check if the type is mentioned in the params
                                        if strings.HasPrefix(name, "group:") </span><span class="cov0" title="0">{
                                                approver.Type = "Group"

                                                if strings.HasPrefix(approver.Name, "group:") </span><span class="cov0" title="0">{
                                                        parts := strings.SplitN(approver.Name, ":", 2)
                                                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                                                approver.Name = parts[1]
                                                        }</span>
                                                }
                                        } else<span class="cov8" title="1"> {
                                                approver.Type = "User"
                                        }</span>

                                        <span class="cov8" title="1">if !approverExists[approver.Name] </span><span class="cov8" title="1">{
                                                approvers = append(approvers, approver)
                                                approverExists[approver.Name] = true
                                        }</span>
                                        <span class="cov8" title="1">users = append(users, approver.Name)
                                        userExists[approver.Name] = true</span>
                                }
                        }
                } else<span class="cov8" title="1"> if v.Name == approvalsRequired </span><span class="cov8" title="1">{
                        tempApproversRequired, err := strconv.Atoi(v.Value.StringVal)
                        if err != nil </span><span class="cov0" title="0">{
                                return v1alpha1.ApprovalTask{}, err
                        }</span>
                        <span class="cov8" title="1">numberOfApprovalsRequired = tempApproversRequired</span>
                } else<span class="cov0" title="0"> if v.Name == description </span><span class="cov0" title="0">{
                        desc = v.Value.StringVal
                }</span>
        }

        <span class="cov8" title="1">ownerRef := *metav1.NewControllerRef(run, gvk)
        labels := make(map[string]string)
        for key, value := range run.Labels </span><span class="cov0" title="0">{
                labels[key] = value
        }</span>
        <span class="cov8" title="1">labels[CustomRunLabelKey] = run.Name

        approvalTask := &amp;v1alpha1.ApprovalTask{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            run.Name,
                        Namespace:       run.Namespace,
                        Labels:          labels,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.ApprovalTaskSpec{
                        Approvers:                 approvers,
                        NumberOfApprovalsRequired: numberOfApprovalsRequired,
                        Description:               desc,
                },
        }

        approverSpecHash, err := Compute(approvalTask.Spec.Approvers)
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha1.ApprovalTask{}, err
        }</span>
        <span class="cov8" title="1">approvalTask.Annotations = map[string]string{
                LastAppliedHashKey: approverSpecHash,
        }

        _, err = approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).Create(ctx, approvalTask, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha1.ApprovalTask{}, err
        }</span>
        <span class="cov8" title="1">logger.Infof("Approval Task %s is created", approvalTask.Name)

        at, err := approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).Get(ctx, run.Name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Error retrieving the created ApprovalTask %s: %v", run.Name, err)
                return v1alpha1.ApprovalTask{}, err
        }</span>

        <span class="cov8" title="1">status := v1alpha1.ApprovalTaskStatus{
                State:             pendingState,
                Approvers:         users,
                ApproversResponse: []v1alpha1.ApproverState{},
                ApprovalsRequired: numberOfApprovalsRequired,
                ApprovalsReceived: 0, // Initially no approvals received
        }

        at.Status = status
        _, err = approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).UpdateStatus(ctx, at, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return v1alpha1.ApprovalTask{}, err
        }</span>

        <span class="cov8" title="1">return *at, nil</span>
}

func approvalTaskHasFalseInput(approvalTask v1alpha1.ApprovalTask) bool <span class="cov8" title="1">{
        for _, approver := range approvalTask.Spec.Approvers </span><span class="cov8" title="1">{
                if approver.Input == hasRejected </span><span class="cov8" title="1">{
                        return true // Found an input that is "reject"
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func approvalTaskHasTrueInput(approvalTask v1alpha1.ApprovalTask) bool <span class="cov8" title="1">{
        // Count approvers with input "approve"
        requiredApprovals := approvalTask.Spec.NumberOfApprovalsRequired

        approvedUsers := make(map[string]bool)

        for _, approver := range approvalTask.Spec.Approvers </span><span class="cov8" title="1">{
                if approver.Input != hasApproved </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if v1alpha1.DefaultedApproverType(approver.Type) == "User" </span><span class="cov8" title="1">{
                        approvedUsers[approver.Name] = true
                }</span> else<span class="cov8" title="1"> if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov8" title="1">{
                        for _, user := range approver.Users </span><span class="cov8" title="1">{
                                if user.Input == hasApproved </span><span class="cov8" title="1">{
                                        approvedUsers[user.Name] = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return len(approvedUsers) &gt;= requiredApprovals</span>
}

func countApprovalsReceived(approvalTask v1alpha1.ApprovalTask) int <span class="cov8" title="1">{
        // Count unique users who have approved
        approvedUsers := make(map[string]bool)

        for _, approver := range approvalTask.Spec.Approvers </span><span class="cov8" title="1">{
                if approver.Input != hasApproved </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if v1alpha1.DefaultedApproverType(approver.Type) == "User" </span><span class="cov8" title="1">{
                        approvedUsers[approver.Name] = true
                }</span> else<span class="cov0" title="0"> if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                        for _, user := range approver.Users </span><span class="cov0" title="0">{
                                if user.Input == hasApproved </span><span class="cov0" title="0">{
                                        approvedUsers[user.Name] = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return len(approvedUsers)</span>
}

func (r *Reconciler) checkIfUpdateRequired(ctx context.Context, approvalTask v1alpha1.ApprovalTask, run *v1beta1.CustomRun) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        expectedHash, err := Compute(approvalTask.Spec.Approvers)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Unable to compute the hash")
                return err
        }</span>
        <span class="cov0" title="0">lastAppliedHash := approvalTask.GetAnnotations()[LastAppliedHashKey]

        if expectedHash != lastAppliedHash </span><span class="cov0" title="0">{
                if _, err := updateApprovalState(ctx, r.approvaltaskClientSet, &amp;approvalTask); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">switch approvalTask.Status.State </span>{
                case pendingState:<span class="cov0" title="0">
                        logger.Infof("Approval task %s is in pending state", approvalTask.Name)</span>
                case rejectedState:<span class="cov0" title="0">
                        logger.Infof("Approval task %s is rejected", approvalTask.Name)
                        run.Status.MarkCustomRunFailed(v1alpha1.ApprovalTaskRunReasonFailed.String(), "Approval Task denied")</span>
                case approvedState:<span class="cov0" title="0">
                        logger.Infof("Approval task %s is approved", approvalTask.Name)
                        run.Status.MarkCustomRunSucceeded(v1alpha1.ApprovalTaskRunReasonSucceeded.String(),
                                "TaskRun succeeded")</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func updateApprovalState(ctx context.Context, approvaltaskClientSet versioned.Interface, approvalTask *v1alpha1.ApprovalTask) (v1alpha1.ApprovalTask, error) <span class="cov8" title="1">{
        // Updating the approvedBy field in the status
        // Temp map to hold current approvers with approve and reject input
        currentApprovers := make(map[string]v1alpha1.ApproverState)
        approvalTask.Status.ApproversResponse = []v1alpha1.ApproverState{}
        // Track users who have already been processed as individual approvers
        // to avoid duplicate entries when they are also group members
        processedUserApprovers := make(map[string]bool)
        
        // First pass: Process all User type approvers
        for _, approver := range approvalTask.Spec.Approvers </span><span class="cov8" title="1">{
                if (approver.Input == hasApproved || approver.Input == hasRejected) &amp;&amp; v1alpha1.DefaultedApproverType(approver.Type) == "User" </span><span class="cov8" title="1">{
                        response := ""
                        if approver.Input == hasApproved </span><span class="cov8" title="1">{
                                response = approvedState
                        }</span> else<span class="cov8" title="1"> if approver.Input == hasRejected </span><span class="cov8" title="1">{
                                response = rejectedState
                        }</span>
                        
                        <span class="cov8" title="1">currentApprovers[approver.Name] = v1alpha1.ApproverState{
                                Name:     approver.Name,
                                Type:     "User",
                                Response: response,
                                Message:  approver.Message,
                        }
                        // Mark this user as processed to avoid duplication in group processing
                        processedUserApprovers[approver.Name] = true</span>
                }
        }
        
        // Second pass: Process Group type approvers, excluding users already processed as individuals
        <span class="cov8" title="1">for _, approver := range approvalTask.Spec.Approvers </span><span class="cov8" title="1">{
                if (approver.Input == hasApproved || approver.Input == hasRejected) &amp;&amp; v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                        groupMembers := []v1alpha1.GroupMemberState{}
                        groupResponse := ""
                        hasApprovals := false
                        hasRejections := false

                        for _, user := range approver.Users </span><span class="cov0" title="0">{
                                // Skip users who have already been processed as individual approvers
                                // This prevents duplicate entries when a user is both an individual approver and group member
                                if processedUserApprovers[user.Name] </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                
                                <span class="cov0" title="0">userResponse := ""
                                if user.Input == hasApproved </span><span class="cov0" title="0">{
                                        userResponse = approvedState
                                        hasApprovals = true
                                }</span> else<span class="cov0" title="0"> if user.Input == hasRejected </span><span class="cov0" title="0">{
                                        userResponse = rejectedState
                                        hasRejections = true
                                }</span>

                                <span class="cov0" title="0">if userResponse != "" </span><span class="cov0" title="0">{
                                        groupMembers = append(groupMembers, v1alpha1.GroupMemberState{
                                                Name:     user.Name,
                                                Response: userResponse,
                                                Message:  approver.Message, // Inherit message from group level
                                        })
                                }</span>
                        }

                        // Determine group response based on individual user responses
                        <span class="cov0" title="0">if hasRejections </span><span class="cov0" title="0">{
                                groupResponse = rejectedState
                        }</span> else<span class="cov0" title="0"> if hasApprovals </span><span class="cov0" title="0">{
                                groupResponse = approvedState
                        }</span>

                        <span class="cov0" title="0">if groupResponse != "" </span><span class="cov0" title="0">{
                                currentApprovers[approver.Name] = v1alpha1.ApproverState{
                                        Name:         approver.Name,
                                        Type:         "Group",
                                        Response:     groupResponse,
                                        Message:      approver.Message,
                                        GroupMembers: groupMembers,
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(currentApprovers) != 0 </span><span class="cov8" title="1">{
                // Filter the ApprovedBy to only include those that are still true
                filteredApprovedBy := []v1alpha1.ApproverState{}
                for _, approver := range currentApprovers </span><span class="cov8" title="1">{
                        filteredApprovedBy = append(filteredApprovedBy, approver)
                }</span>

                // Update the ApprovedBy list
                <span class="cov8" title="1">approvalTask.Status.ApproversResponse = filteredApprovedBy

                // Update the approvals count fields
                approvalTask.Status.ApprovalsRequired = approvalTask.Spec.NumberOfApprovalsRequired
                approvalTask.Status.ApprovalsReceived = countApprovalsReceived(*approvalTask)

                // Update the approvalState
                // Reject scenario: Check if there is one false and if found mark the approvalstate to false
                // Approve scenario: Check if the input value from the user is true and is equal to the approvalsRequired
                if approvalTaskHasFalseInput(*approvalTask) </span><span class="cov8" title="1">{
                        approvalTask.Status.State = rejectedState
                }</span> else<span class="cov8" title="1"> if approvalTaskHasTrueInput(*approvalTask) </span><span class="cov8" title="1">{
                        approvalTask.Status.State = approvedState
                }</span>

                // Update the status finally
                <span class="cov8" title="1">at, err := approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(approvalTask.Namespace).UpdateStatus(ctx, approvalTask, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return v1alpha1.ApprovalTask{}, err
                }</span>
                <span class="cov8" title="1">return *at, nil</span>
        }

        <span class="cov0" title="0">return v1alpha1.ApprovalTask{}, nil</span>
}

// Compute generates an unique hash/string for the object pass to it.
// with sha256
func Compute(obj interface{}) (string, error) <span class="cov8" title="1">{
        d, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">hashSha256 := sha256.New()
        hashSha256.Write(d)
        return fmt.Sprintf("%x", hashSha256.Sum(nil)), nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package webhook

import (
        "context"

        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        vwhinformer "knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/validatingwebhookconfiguration"
        "knative.dev/pkg/controller"
        secretinformer "knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
)

func NewAdmissionController(ctx context.Context,
        name, path string,
        wc func(context.Context) context.Context,
        disallowUnknownFields bool,
) *controller.Impl <span class="cov0" title="0">{

        client := kubeclient.Get(ctx)
        vwhInformer := vwhinformer.Get(ctx)
        secretInformer := secretinformer.Get(ctx)
        options := webhook.GetOptions(ctx)

        key := types.NamespacedName{
                Namespace: system.Namespace(),
                Name:      name,
        }

        c := &amp;reconciler{
                LeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{
                        // Have this reconciler enqueue our singleton whenever it becomes leader.
                        PromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                enq(bkt, key)
                                return nil
                        }</span>,
                },

                key:  key,
                path: path,

                withContext:           wc,
                disallowUnknownFields: disallowUnknownFields,
                secretName:            options.SecretName,

                client:       client,
                vwhlister:    vwhInformer.Lister(),
                secretlister: secretInformer.Lister(),
        }

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        cont := controller.NewContext(ctx, c, controller.ControllerOptions{WorkQueueName: "ValidatingWebhook", Logger: logger})

        // Reconcile when the named ValidatingWebhookConfiguration changes.
        if _, err := vwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithName(name),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named MWH resource.
                Handler: controller.HandleAll(cont.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("couldn't register ValidatingWebhookConfiguration informer event handler: %w", err)
        }</span>

        // Reconcile when the cert bundle changes.
        <span class="cov0" title="0">if _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), c.secretName),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named MWH resource.
                Handler: controller.HandleAll(cont.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("couldn't register Secret informer event handler: %w", err)
        }</span>

        <span class="cov0" title="0">return cont</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package webhook

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1"
        "go.uber.org/zap"
        admissionv1 "k8s.io/api/admission/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        admissionlisters "k8s.io/client-go/listers/admissionregistration/v1"
        corelisters "k8s.io/client-go/listers/core/v1"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmp"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
        certresources "knative.dev/pkg/webhook/certificates/resources"
)

const (
        Group   = "openshift-pipelines.org"
        Version = "v1alpha1"
        Kind    = "ApprovalTask"
)

// reconciler implements the AdmissionController for resources
type reconciler struct {
        webhook.StatelessAdmissionImpl
        pkgreconciler.LeaderAwareFuncs

        key  types.NamespacedName
        path string

        withContext func(context.Context) context.Context

        client       kubernetes.Interface
        vwhlister    admissionlisters.ValidatingWebhookConfigurationLister
        secretlister corelisters.SecretLister

        disallowUnknownFields bool
        secretName            string
}

var _ controller.Reconciler = (*reconciler)(nil)
var _ pkgreconciler.LeaderAware = (*reconciler)(nil)
var _ webhook.AdmissionController = (*reconciler)(nil)
var _ webhook.StatelessAdmissionController = (*reconciler)(nil)

// Reconcile implements controller.Reconciler
func (r *reconciler) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        if !r.IsLeaderFor(r.key) </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // Look up the webhook secret, and fetch the CA cert bundle.
        <span class="cov0" title="0">secret, err := r.secretlister.Secrets(system.Namespace()).Get(r.secretName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error fetching secret", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">caCert, ok := secret.Data[certresources.CACert]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("secret %q is missing %q key", r.secretName, certresources.CACert)
        }</span>

        // Reconcile the webhook configuration.
        <span class="cov0" title="0">return r.reconcileValidatingWebhook(ctx, caCert)</span>
}

func (r *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse <span class="cov0" title="0">{
        if r.withContext != nil </span><span class="cov0" title="0">{
                ctx = r.withContext(ctx)
        }</span>

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        kind := request.Kind

        newBytes := request.Object.Raw
        gvk := schema.GroupVersionKind{
                Group:   kind.Group,
                Version: kind.Version,
                Kind:    kind.Kind,
        }

        if gvk.Group != Group || gvk.Version != Version || gvk.Kind != Kind </span><span class="cov0" title="0">{
                logger.Error("Unhandled kind: ", gvk)
        }</span>

        // Decode new object 
        <span class="cov0" title="0">newObj, err := r.decodeNewObject(newBytes)
        if err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("cannot decode incoming new object: %v", err)
        }</span>

        // Validate structural requirements 
        <span class="cov0" title="0">if err := validateApprovalTask(newObj, ctx); err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("validation failed: %v", err)
        }</span>

        <span class="cov0" title="0">if request.Operation == "CREATE" </span><span class="cov0" title="0">{
                // For CREATE operations, ensure all approver inputs are set to "pending"
                if err := validateApproverInputsForCreate(newObj); err != nil </span><span class="cov0" title="0">{
                        return webhook.MakeErrorStatus("validation failed: %v", err)
                }</span>
                <span class="cov0" title="0">return &amp;admissionv1.AdmissionResponse{
                        Allowed: true,
                }</span>
        }

        <span class="cov0" title="0">if request.Operation != "UPDATE" </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("unsupported operation: %s", request.Operation)
        }</span>

        // Decode old object for UPDATE operations
        <span class="cov0" title="0">oldObj, err := r.decodeOldObject(request.OldObject.Raw)
        if err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("cannot decode incoming old object: %v", err)
        }</span>

        // Check if approval is required by the approver
        <span class="cov0" title="0">if !isApprovalRequired(*oldObj) </span><span class="cov0" title="0">{
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Message: "ApprovalTask has already reached its final state",
                        },
                }
        }</span>

        // Check if username is mentioned in the approval task
        <span class="cov0" title="0">if !ifUserExists(oldObj.Spec.Approvers, request) </span><span class="cov0" title="0">{
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Message: "User does not exist in the approval list",
                        },
                }
        }</span>

        // Check if user is updating the input for his name only
        <span class="cov0" title="0">var userApprovalChanged bool
        errMsg := fmt.Errorf("User can only update their own approval input")

        // First check if user is trying to re-approve/re-reject their own already-decided task
        if alreadyDecidedMsg := checkIfUserAlreadyDecided(oldObj, newObj, request); alreadyDecidedMsg != "" </span><span class="cov0" title="0">{
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Message: alreadyDecidedMsg,
                        },
                }
        }</span>

        <span class="cov0" title="0">changed, err := IsUserApprovalChanged(oldObj.Spec.Approvers, newObj.Spec.Approvers, request)
        if err != nil </span><span class="cov0" title="0">{
                userApprovalChanged = false
                errMsg = fmt.Errorf("Invalid input change: %v", err)
        }</span> else<span class="cov0" title="0"> if changed </span><span class="cov0" title="0">{
                if CheckOtherUsersForInvalidChanges(oldObj.Spec.Approvers, newObj.Spec.Approvers, request) </span><span class="cov0" title="0">{
                        userApprovalChanged = true
                }</span> else<span class="cov0" title="0"> {
                        userApprovalChanged = false
                }</span>
        } else<span class="cov0" title="0"> {
                userApprovalChanged = false
        }</span>

        <span class="cov0" title="0">if !userApprovalChanged </span><span class="cov0" title="0">{
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Message: errMsg.Error(),
                        },
                }
        }</span>

        <span class="cov0" title="0">return &amp;admissionv1.AdmissionResponse{
                Allowed: true,
        }</span>
}

func (ac *reconciler) reconcileValidatingWebhook(ctx context.Context, caCert []byte) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        rules := []admissionregistrationv1.RuleWithOperations{
                {
                        Operations: []admissionregistrationv1.OperationType{
                                admissionregistrationv1.Create,
                                admissionregistrationv1.Update,
                        },
                        Rule: admissionregistrationv1.Rule{
                                APIGroups:   []string{"openshift-pipelines.org"},
                                APIVersions: []string{"v1alpha1"},
                                Resources:   []string{"approvaltask", "approvaltasks"},
                        },
                },
        }

        configuredWebhook, err := ac.vwhlister.Get(ac.key.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">webhook := configuredWebhook.DeepCopy()

        webhook.OwnerReferences = nil

        for i, wh := range webhook.Webhooks </span><span class="cov0" title="0">{
                if wh.Name != webhook.Name </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">webhook.Webhooks[i].Rules = rules
                webhook.Webhooks[i].ClientConfig.CABundle = caCert
                if webhook.Webhooks[i].ClientConfig.Service == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing service reference for webhook: %s", wh.Name)
                }</span>
                <span class="cov0" title="0">webhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())</span>
        }

        <span class="cov0" title="0">if ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error diffing webhooks: %w", err)
        }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                logger.Info("Updating webhook")
                vwhclient := ac.client.AdmissionregistrationV1().ValidatingWebhookConfigurations()
                if _, err := vwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update webhook: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("Webhook is valid")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Path implements AdmissionController
func (ac *reconciler) Path() string <span class="cov0" title="0">{
        return ac.path
}</span>

func ifUserExists(approvals []v1alpha1.ApproverDetails, request *admissionv1.AdmissionRequest) bool <span class="cov0" title="0">{
        if len(approvals) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">for _, approval := range approvals </span><span class="cov0" title="0">{
                switch v1alpha1.DefaultedApproverType(approval.Type) </span>{
                case "User":<span class="cov0" title="0">
                        if approval.Name == request.UserInfo.Username </span><span class="cov0" title="0">{
                                return true
                        }</span>
                case "Group":<span class="cov0" title="0">
                        // Check if user is in the group by checking the group name against user's groups
                        for _, userGroup := range request.UserInfo.Groups </span><span class="cov0" title="0">{
                                if approval.Name == userGroup </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                        // Also check if user is explicitly listed in the group's users
                        <span class="cov0" title="0">for _, user := range approval.Users </span><span class="cov0" title="0">{
                                if user.Name == request.UserInfo.Username </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return false</span>
}

func isApprovalRequired(approvaltask v1alpha1.ApprovalTask) bool <span class="cov0" title="0">{
        // If the task has reached a final state, no more approvals are needed
        if approvaltask.Status.State == "rejected" || approvaltask.Status.State == "approved" </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Use the same logic as the controller to count approvals
        <span class="cov0" title="0">approvedUsers := make(map[string]bool)
        
        for _, approver := range approvaltask.Spec.Approvers </span><span class="cov0" title="0">{
                if approver.Input != "approve" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">if v1alpha1.DefaultedApproverType(approver.Type) == "User" </span><span class="cov0" title="0">{
                        approvedUsers[approver.Name] = true
                }</span> else<span class="cov0" title="0"> if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                        for _, user := range approver.Users </span><span class="cov0" title="0">{
                                if user.Input == "approve" </span><span class="cov0" title="0">{
                                        approvedUsers[user.Name] = true
                                }</span>
                        }
                }
        }
        
        // If we have enough approvals, the task should be approved (final state)
        <span class="cov0" title="0">if len(approvedUsers) &gt;= approvaltask.Spec.NumberOfApprovalsRequired </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}

// hasValidInputValue checks if the input value is either "approve" or "reject".
func hasValidInputValue(input string) error <span class="cov0" title="0">{
        if input == "approve" || input == "reject" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("invalid input value: '%s'. Supported values are 'approve' or 'reject'", input)</span>
}

// hasOnlyInputChanged checks if only the input field has changed for the current approver
// and if the new input value is valid
func hasOnlyInputChanged(oldObjApprover, newObjApprover v1alpha1.ApproverDetails) (bool, error) <span class="cov0" title="0">{
        if oldObjApprover.Name == newObjApprover.Name &amp;&amp; oldObjApprover.Input != newObjApprover.Input </span><span class="cov0" title="0">{
                if err := hasValidInputValue(newObjApprover.Input); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

// IsUserApprovalChanged checks if there is a valid input change for the current user.
func IsUserApprovalChanged(oldObjApprovers, newObjApprovers []v1alpha1.ApproverDetails, request *admissionv1.AdmissionRequest) (bool, error) <span class="cov0" title="0">{
        currentUser := request.UserInfo.Username
        for i, approver := range oldObjApprovers </span><span class="cov0" title="0">{
                if approver.Name == currentUser &amp;&amp; v1alpha1.DefaultedApproverType(approver.Type) == "User" </span><span class="cov0" title="0">{
                        return hasOnlyInputChanged(approver, newObjApprovers[i])
                }</span>

                <span class="cov0" title="0">if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                        // Check if current user is a member of this group
                        isUserInGroup := false

                        // Check if user is in the group by checking the group name against user's groups
                        for _, userGroup := range request.UserInfo.Groups </span><span class="cov0" title="0">{
                                if approver.Name == userGroup </span><span class="cov0" title="0">{
                                        isUserInGroup = true
                                        break</span>
                                }
                        }

                        // Also check if user is explicitly listed in the group's users
                        <span class="cov0" title="0">for _, user := range approver.Users </span><span class="cov0" title="0">{
                                if user.Name == currentUser </span><span class="cov0" title="0">{
                                        isUserInGroup = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if isUserInGroup </span><span class="cov0" title="0">{
                                // Allow changes to group-level input if user is in the group
                                if i &lt; len(newObjApprovers) </span><span class="cov0" title="0">{
                                        if approver.Input != newObjApprovers[i].Input </span><span class="cov0" title="0">{
                                                if err := hasValidInputValue(newObjApprovers[i].Input); err != nil </span><span class="cov0" title="0">{
                                                        return false, err
                                                }</span>
                                                <span class="cov0" title="0">return true, nil</span>
                                        }
                                }

                                // Check if user is adding themselves to the group's users list
                                <span class="cov0" title="0">oldUserFound := false
                                newUserFound := false

                                for _, user := range approver.Users </span><span class="cov0" title="0">{
                                        if user.Name == currentUser </span><span class="cov0" title="0">{
                                                oldUserFound = true
                                                break</span>
                                        }
                                }

                                <span class="cov0" title="0">if i &lt; len(newObjApprovers) </span><span class="cov0" title="0">{
                                        for _, user := range newObjApprovers[i].Users </span><span class="cov0" title="0">{
                                                if user.Name == currentUser </span><span class="cov0" title="0">{
                                                        newUserFound = true
                                                        break</span>
                                                }
                                        }
                                }

                                // Allow user to add themselves to the group
                                <span class="cov0" title="0">if !oldUserFound &amp;&amp; newUserFound </span><span class="cov0" title="0">{
                                        // Validate the input they're setting for themselves
                                        if i &lt; len(newObjApprovers) </span><span class="cov0" title="0">{
                                                for _, user := range newObjApprovers[i].Users </span><span class="cov0" title="0">{
                                                        if user.Name == currentUser </span><span class="cov0" title="0">{
                                                                if err := hasValidInputValue(user.Input); err != nil </span><span class="cov0" title="0">{
                                                                        return false, err
                                                                }</span>
                                                                <span class="cov0" title="0">return true, nil</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">return true, nil</span>
                                }

                                // Allow changes to individual user inputs within the group
                                // Find current user in old users list
                                <span class="cov0" title="0">var oldUserInput string
                                userFoundInOld := false
                                for _, user := range approver.Users </span><span class="cov0" title="0">{
                                        if user.Name == currentUser </span><span class="cov0" title="0">{
                                                oldUserInput = user.Input
                                                userFoundInOld = true
                                                break</span>
                                        }
                                }

                                // Find current user in new users list
                                <span class="cov0" title="0">var newUserInput string
                                userFoundInNew := false
                                if i &lt; len(newObjApprovers) </span><span class="cov0" title="0">{
                                        for _, user := range newObjApprovers[i].Users </span><span class="cov0" title="0">{
                                                if user.Name == currentUser </span><span class="cov0" title="0">{
                                                        newUserInput = user.Input
                                                        userFoundInNew = true
                                                        break</span>
                                                }
                                        }
                                }

                                // Allow user to change their input if they're in both old and new lists
                                <span class="cov0" title="0">if userFoundInOld &amp;&amp; userFoundInNew &amp;&amp; oldUserInput != newUserInput </span><span class="cov0" title="0">{
                                        if err := hasValidInputValue(newUserInput); err != nil </span><span class="cov0" title="0">{
                                                return false, err
                                        }</span>
                                        <span class="cov0" title="0">return true, nil</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return false, nil</span>
}

// checkIfUserAlreadyDecided checks if a user is trying to re-approve/re-reject a task they've already decided on
func checkIfUserAlreadyDecided(oldObj *v1alpha1.ApprovalTask, newObj *v1alpha1.ApprovalTask, request *admissionv1.AdmissionRequest) string <span class="cov0" title="0">{
        currentUser := request.UserInfo.Username
        
        // Get user's desired new input from the incoming object
        desiredInput := ""
        
        // First check if user is an individual approver
        for _, approver := range newObj.Spec.Approvers </span><span class="cov0" title="0">{
                if v1alpha1.DefaultedApproverType(approver.Type) == "User" &amp;&amp; approver.Name == currentUser </span><span class="cov0" title="0">{
                        desiredInput = approver.Input
                        break</span>
                }
        }
        
        // If not found as individual user, check if user is in any group
        <span class="cov0" title="0">if desiredInput == "" </span><span class="cov0" title="0">{
                for _, approver := range newObj.Spec.Approvers </span><span class="cov0" title="0">{
                        if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                                // Check if user is explicitly in the group's users list
                                for _, user := range approver.Users </span><span class="cov0" title="0">{
                                        if user.Name == currentUser </span><span class="cov0" title="0">{
                                                desiredInput = user.Input
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if desiredInput != "" </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                
                                // Check if user is in the group via RBAC (group-level input)
                                <span class="cov0" title="0">for _, userGroup := range request.UserInfo.Groups </span><span class="cov0" title="0">{
                                        if approver.Name == userGroup </span><span class="cov0" title="0">{
                                                desiredInput = approver.Input
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if desiredInput != "" </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }
                }
        }
        
        // Check status.approversResponse to see if user has already made a decision
        <span class="cov0" title="0">for _, approverResponse := range oldObj.Status.ApproversResponse </span><span class="cov0" title="0">{
                if v1alpha1.DefaultedApproverType(approverResponse.Type) == "User" &amp;&amp; approverResponse.Name == currentUser </span><span class="cov0" title="0">{
                        // Block duplicate approvals and any action after rejection
                        if approverResponse.Response == "approved" &amp;&amp; desiredInput == "approve" </span><span class="cov0" title="0">{
                                return "User has already approved"
                        }</span> else<span class="cov0" title="0"> if approverResponse.Response == "rejected" </span><span class="cov0" title="0">{
                                return "User has already rejected"
                        }</span>
                }
                
                // Check if user is in any group that has responded
                <span class="cov0" title="0">if v1alpha1.DefaultedApproverType(approverResponse.Type) == "Group" </span><span class="cov0" title="0">{
                        for _, member := range approverResponse.GroupMembers </span><span class="cov0" title="0">{
                                if member.Name == currentUser </span><span class="cov0" title="0">{
                                        // Block duplicate approvals and any action after rejection
                                        if member.Response == "approved" &amp;&amp; desiredInput == "approve" </span><span class="cov0" title="0">{
                                                return "User has already approved"
                                        }</span> else<span class="cov0" title="0"> if member.Response == "rejected" </span><span class="cov0" title="0">{
                                                return "User has already rejected"
                                        }</span>
                                }
                        }
                }
        }
        
        <span class="cov0" title="0">return ""</span> // No issue found
}

// CheckOtherUsersForInvalidChanges validates that no other approvers inputs have been changed
func CheckOtherUsersForInvalidChanges(oldObjApprovers, newObjApprover []v1alpha1.ApproverDetails, request *admissionv1.AdmissionRequest) bool <span class="cov0" title="0">{
        currentUser := request.UserInfo.Username
        for i, approver := range oldObjApprovers </span><span class="cov0" title="0">{
                if v1alpha1.DefaultedApproverType(approver.Type) == "User" &amp;&amp; approver.Name != currentUser </span><span class="cov0" title="0">{
                        if oldObjApprovers[i].Input != newObjApprover[i].Input </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }

                <span class="cov0" title="0">if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                        // Check if current user is a member of this group
                        isUserInGroup := false

                        // Check if user is in the group by checking the group name against user's groups
                        for _, userGroup := range request.UserInfo.Groups </span><span class="cov0" title="0">{
                                if approver.Name == userGroup </span><span class="cov0" title="0">{
                                        isUserInGroup = true
                                        break</span>
                                }
                        }

                        // Also check if user is explicitly listed in the group's users
                        <span class="cov0" title="0">for _, user := range approver.Users </span><span class="cov0" title="0">{
                                if user.Name == currentUser </span><span class="cov0" title="0">{
                                        isUserInGroup = true
                                        break</span>
                                }
                        }

                        // If current user is not in this group, they shouldn't be able to change the group-level input
                        <span class="cov0" title="0">if !isUserInGroup </span><span class="cov0" title="0">{
                                if i &lt; len(newObjApprover) &amp;&amp; approver.Input != newObjApprover[i].Input </span><span class="cov0" title="0">{
                                        return false
                                }</span>
                        }

                        // Check that only current user's input has changed in group users
                        // Build maps of existing users for easier comparison
                        <span class="cov0" title="0">oldUsers := make(map[string]string) // name -&gt; input
                        newUsers := make(map[string]string) // name -&gt; input

                        for _, user := range approver.Users </span><span class="cov0" title="0">{
                                oldUsers[user.Name] = user.Input
                        }</span>

                        <span class="cov0" title="0">if i &lt; len(newObjApprover) </span><span class="cov0" title="0">{
                                for _, user := range newObjApprover[i].Users </span><span class="cov0" title="0">{
                                        newUsers[user.Name] = user.Input
                                }</span>
                        }

                        // Check that existing users (other than current user) haven't changed their input
                        <span class="cov0" title="0">for userName, oldInput := range oldUsers </span><span class="cov0" title="0">{
                                if userName != currentUser </span><span class="cov0" title="0">{
                                        if newInput, exists := newUsers[userName]; exists </span><span class="cov0" title="0">{
                                                if oldInput != newInput </span><span class="cov0" title="0">{
                                                        return false // Someone else's input changed
                                                }</span>
                                        }
                                }
                        }

                        // Check that no unauthorized users were added to the group
                        <span class="cov0" title="0">for userName := range newUsers </span><span class="cov0" title="0">{
                                if _, existedBefore := oldUsers[userName]; !existedBefore </span><span class="cov0" title="0">{
                                        // Someone new was added - only allow if it's the current user and they're a group member
                                        if userName != currentUser </span><span class="cov0" title="0">{
                                                return false // Someone other than current user was added
                                        }</span>
                                        <span class="cov0" title="0">if !isUserInGroup </span><span class="cov0" title="0">{
                                                return false // Current user is not a member of this group
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return true</span>
}

// validateApprovalTask validates the complete ApprovalTask resource 
func validateApprovalTask(approvalTask *v1alpha1.ApprovalTask, ctx context.Context) error <span class="cov0" title="0">{
        // Validate spec
        if err := validateApprovalTaskSpec(&amp;approvalTask.Spec, ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("spec validation failed: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// validateApprovalTaskSpec validates the ApprovalTaskSpec
func validateApprovalTaskSpec(spec *v1alpha1.ApprovalTaskSpec, ctx context.Context) error <span class="cov0" title="0">{
        // Validate numberOfApprovalsRequired bounds
        if spec.NumberOfApprovalsRequired &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("numberOfApprovalsRequired: must be greater than 0, got %d", spec.NumberOfApprovalsRequired)
        }</span>

        // Validate approvers list
        <span class="cov0" title="0">if len(spec.Approvers) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("approvers: required field is missing")
        }</span>

        // Validate each approver and check for duplicates
        <span class="cov0" title="0">approverNames := make(map[string]int) // name -&gt; index
        for i, approver := range spec.Approvers </span><span class="cov0" title="0">{
                fieldPath := fmt.Sprintf("approvers[%d]", i)
                
                if err := validateApprover(approver, fieldPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                // Check for duplicate approver names
                <span class="cov0" title="0">approverKey := fmt.Sprintf("%s:%s", v1alpha1.DefaultedApproverType(approver.Type), approver.Name)
                if existingIndex, exists := approverNames[approverKey]; exists </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s.name: duplicate approver '%s' (also found at approvers[%d])", fieldPath, approver.Name, existingIndex)
                }</span>
                <span class="cov0" title="0">approverNames[approverKey] = i</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// validateApprover validates a single approver entry
func validateApprover(approver v1alpha1.ApproverDetails, fieldPath string) error <span class="cov0" title="0">{
        // Validate approver type first to determine validation rules
        approverType := v1alpha1.DefaultedApproverType(approver.Type)
        if approverType != "User" &amp;&amp; approverType != "Group" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.type: must be either 'User' or 'Group', got '%s'", fieldPath, approver.Type)
        }</span>

        // Validate name format based on type (includes empty check via validateNameFormat)
        <span class="cov0" title="0">if approverType == "User" </span><span class="cov0" title="0">{
                if err := validateUserName(approver.Name); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s.name: %w", fieldPath, err)
                }</span>
        } else<span class="cov0" title="0"> if approverType == "Group" </span><span class="cov0" title="0">{
                if err := validateGroupName(approver.Name); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s.name: %w", fieldPath, err)
                }</span>
        }

        // Validate input value
        <span class="cov0" title="0">validInputs := []string{"pending", "approve", "reject"}
        if !webhookContains(validInputs, approver.Input) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s.input: must be one of: %s, got '%s'", fieldPath, strings.Join(validInputs, ", "), approver.Input)
        }</span>

        // Validate users for group type
        <span class="cov0" title="0">if approverType == "Group" </span><span class="cov0" title="0">{
                
                // Track duplicate users within the group
                groupUsers := make(map[string]int) // username -&gt; index
                for j, user := range approver.Users </span><span class="cov0" title="0">{
                        userFieldPath := fmt.Sprintf("%s.users[%d]", fieldPath, j)
                        
                        if strings.TrimSpace(user.Name) == "" </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s.name: required field is missing", userFieldPath)
                        }</span> else<span class="cov0" title="0"> if err := validateUserName(user.Name); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s.name: %w", userFieldPath, err)
                        }</span>
                        
                        // Check for duplicate users within the group
                        <span class="cov0" title="0">if existingIndex, exists := groupUsers[user.Name]; exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s.name: duplicate user '%s' within group (also found at %s.users[%d])", userFieldPath, user.Name, fieldPath, existingIndex)
                        }</span>
                        <span class="cov0" title="0">groupUsers[user.Name] = j

                        if !webhookContains(validInputs, user.Input) </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s.input: must be one of: %s, got '%s'", userFieldPath, strings.Join(validInputs, ", "), user.Input)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// validateNameFormat performs common name validation checks
func validateNameFormat(name, fieldType string) error <span class="cov0" title="0">{
        if strings.TrimSpace(name) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("%s cannot be empty", fieldType)
        }</span>
        
        // Kubernetes names cannot contain spaces
        <span class="cov0" title="0">if strings.Contains(name, " ") </span><span class="cov0" title="0">{
                return fmt.Errorf("%s cannot contain spaces", fieldType)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// validateUserName validates username
func validateUserName(name string) error <span class="cov0" title="0">{
        // Basic empty check (spaces ARE allowed in usernames for LDAP integration)
        if strings.TrimSpace(name) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("username cannot be empty")
        }</span>
        
        <span class="cov0" title="0">if strings.HasPrefix(name, "group:") </span><span class="cov0" title="0">{
                return fmt.Errorf("username cannot start with 'group:' prefix - use type: Group for group approvers")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// validateGroupName validates group name format
func validateGroupName(name string) error <span class="cov0" title="0">{
        if err := validateNameFormat(name, "group name"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Group names should not contain colons to avoid confusion with user prefixes
        <span class="cov0" title="0">if strings.Contains(name, ":") </span><span class="cov0" title="0">{
                return fmt.Errorf("group name cannot contain colons")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// webhookContains checks if a slice contains a string
func webhookContains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// decodeNewObject decodes the incoming new object
func (r *reconciler) decodeNewObject(newBytes []byte) (*v1alpha1.ApprovalTask, error) <span class="cov0" title="0">{
        var newObj v1alpha1.ApprovalTask
        if len(newBytes) != 0 </span><span class="cov0" title="0">{
                newDecoder := json.NewDecoder(bytes.NewBuffer(newBytes))
                if r.disallowUnknownFields </span><span class="cov0" title="0">{
                        newDecoder.DisallowUnknownFields()
                }</span>
                <span class="cov0" title="0">if err := newDecoder.Decode(&amp;newObj); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return &amp;newObj, nil</span>
}

// decodeOldObject decodes the incoming old object
func (r *reconciler) decodeOldObject(oldBytes []byte) (*v1alpha1.ApprovalTask, error) <span class="cov0" title="0">{
        var oldObj v1alpha1.ApprovalTask
        if len(oldBytes) != 0 </span><span class="cov0" title="0">{
                oldDecoder := json.NewDecoder(bytes.NewBuffer(oldBytes))
                if r.disallowUnknownFields </span><span class="cov0" title="0">{
                        oldDecoder.DisallowUnknownFields()
                }</span>
                <span class="cov0" title="0">if err := oldDecoder.Decode(&amp;oldObj); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return &amp;oldObj, nil</span>
}

// validateApproverInputsForCreate ensures all approver inputs are set to "pending" for new ApprovalTask resources
func validateApproverInputsForCreate(approvalTask *v1alpha1.ApprovalTask) error <span class="cov0" title="0">{
        for i, approver := range approvalTask.Spec.Approvers </span><span class="cov0" title="0">{
                if approver.Input != "pending" </span><span class="cov0" title="0">{
                        return fmt.Errorf("approvers[%d].input: must be 'pending' for new ApprovalTask, got '%s'", i, approver.Input)
                }</span>
                
                // For group approvers, also validate that all users within the group have pending input
                <span class="cov0" title="0">if v1alpha1.DefaultedApproverType(approver.Type) == "Group" </span><span class="cov0" title="0">{
                        for j, user := range approver.Users </span><span class="cov0" title="0">{
                                if user.Input != "pending" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("approvers[%d].users[%d].input: must be 'pending' for new ApprovalTask, got '%s'", i, j, user.Input)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Package errwrap implements methods to formalize error wrapping in Go.
//
// All of the top-level functions that take an `error` are built to be able
// to take any error, not just wrapped errors. This allows you to use errwrap
// without having to type-check and type-cast everywhere.
package errwrap

import (
        "errors"
        "reflect"
        "strings"
)

// WalkFunc is the callback called for Walk.
type WalkFunc func(error)

// Wrapper is an interface that can be implemented by custom types to
// have all the Contains, Get, etc. functions in errwrap work.
//
// When Walk reaches a Wrapper, it will call the callback for every
// wrapped error in addition to the wrapper itself. Since all the top-level
// functions in errwrap use Walk, this means that all those functions work
// with your custom type.
type Wrapper interface {
        WrappedErrors() []error
}

// Wrap defines that outer wraps inner, returning an error type that
// can be cleanly used with the other methods in this package, such as
// Contains, GetAll, etc.
//
// This function won't modify the error message at all (the outer message
// will be used).
func Wrap(outer, inner error) error <span class="cov0" title="0">{
        return &amp;wrappedError{
                Outer: outer,
                Inner: inner,
        }
}</span>

// Wrapf wraps an error with a formatting message. This is similar to using
// `fmt.Errorf` to wrap an error. If you're using `fmt.Errorf` to wrap
// errors, you should replace it with this.
//
// format is the format of the error message. The string '{{err}}' will
// be replaced with the original error message.
//
// Deprecated: Use fmt.Errorf()
func Wrapf(format string, err error) error <span class="cov0" title="0">{
        outerMsg := "&lt;nil&gt;"
        if err != nil </span><span class="cov0" title="0">{
                outerMsg = err.Error()
        }</span>

        <span class="cov0" title="0">outer := errors.New(strings.Replace(
                format, "{{err}}", outerMsg, -1))

        return Wrap(outer, err)</span>
}

// Contains checks if the given error contains an error with the
// message msg. If err is not a wrapped error, this will always return
// false unless the error itself happens to match this msg.
func Contains(err error, msg string) bool <span class="cov0" title="0">{
        return len(GetAll(err, msg)) &gt; 0
}</span>

// ContainsType checks if the given error contains an error with
// the same concrete type as v. If err is not a wrapped error, this will
// check the err itself.
func ContainsType(err error, v interface{}) bool <span class="cov0" title="0">{
        return len(GetAllType(err, v)) &gt; 0
}</span>

// Get is the same as GetAll but returns the deepest matching error.
func Get(err error, msg string) error <span class="cov0" title="0">{
        es := GetAll(err, msg)
        if len(es) &gt; 0 </span><span class="cov0" title="0">{
                return es[len(es)-1]
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetType is the same as GetAllType but returns the deepest matching error.
func GetType(err error, v interface{}) error <span class="cov0" title="0">{
        es := GetAllType(err, v)
        if len(es) &gt; 0 </span><span class="cov0" title="0">{
                return es[len(es)-1]
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetAll gets all the errors that might be wrapped in err with the
// given message. The order of the errors is such that the outermost
// matching error (the most recent wrap) is index zero, and so on.
func GetAll(err error, msg string) []error <span class="cov0" title="0">{
        var result []error

        Walk(err, func(err error) </span><span class="cov0" title="0">{
                if err.Error() == msg </span><span class="cov0" title="0">{
                        result = append(result, err)
                }</span>
        })

        <span class="cov0" title="0">return result</span>
}

// GetAllType gets all the errors that are the same type as v.
//
// The order of the return value is the same as described in GetAll.
func GetAllType(err error, v interface{}) []error <span class="cov0" title="0">{
        var result []error

        var search string
        if v != nil </span><span class="cov0" title="0">{
                search = reflect.TypeOf(v).String()
        }</span>
        <span class="cov0" title="0">Walk(err, func(err error) </span><span class="cov0" title="0">{
                var needle string
                if err != nil </span><span class="cov0" title="0">{
                        needle = reflect.TypeOf(err).String()
                }</span>

                <span class="cov0" title="0">if needle == search </span><span class="cov0" title="0">{
                        result = append(result, err)
                }</span>
        })

        <span class="cov0" title="0">return result</span>
}

// Walk walks all the wrapped errors in err and calls the callback. If
// err isn't a wrapped error, this will be called once for err. If err
// is a wrapped error, the callback will be called for both the wrapper
// that implements error as well as the wrapped error itself.
func Walk(err error, cb WalkFunc) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">switch e := err.(type) </span>{
        case *wrappedError:<span class="cov0" title="0">
                cb(e.Outer)
                Walk(e.Inner, cb)</span>
        case Wrapper:<span class="cov0" title="0">
                cb(err)

                for _, err := range e.WrappedErrors() </span><span class="cov0" title="0">{
                        Walk(err, cb)
                }</span>
        case interface{ Unwrap() error }:<span class="cov0" title="0">
                cb(err)
                Walk(e.Unwrap(), cb)</span>
        default:<span class="cov0" title="0">
                cb(err)</span>
        }
}

// wrappedError is an implementation of error that has both the
// outer and inner errors.
type wrappedError struct {
        Outer error
        Inner error
}

func (w *wrappedError) Error() string <span class="cov0" title="0">{
        return w.Outer.Error()
}</span>

func (w *wrappedError) WrappedErrors() []error <span class="cov0" title="0">{
        return []error{w.Outer, w.Inner}
}</span>

func (w *wrappedError) Unwrap() error <span class="cov0" title="0">{
        return w.Inner
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package multierror

// Append is a helper function that will append more errors
// onto an Error in order to create a larger multi-error.
//
// If err is not a multierror.Error, then it will be turned into
// one. If any of the errs are multierr.Error, they will be flattened
// one level into err.
// Any nil errors within errs will be ignored. If err is nil, a new
// *Error will be returned.
func Append(err error, errs ...error) *Error <span class="cov0" title="0">{
        switch err := err.(type) </span>{
        case *Error:<span class="cov0" title="0">
                // Typed nils can reach here, so initialize if we are nil
                if err == nil </span><span class="cov0" title="0">{
                        err = new(Error)
                }</span>

                // Go through each error and flatten
                <span class="cov0" title="0">for _, e := range errs </span><span class="cov0" title="0">{
                        switch e := e.(type) </span>{
                        case *Error:<span class="cov0" title="0">
                                if e != nil </span><span class="cov0" title="0">{
                                        err.Errors = append(err.Errors, e.Errors...)
                                }</span>
                        default:<span class="cov0" title="0">
                                if e != nil </span><span class="cov0" title="0">{
                                        err.Errors = append(err.Errors, e)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return err</span>
        default:<span class="cov0" title="0">
                newErrs := make([]error, 0, len(errs)+1)
                if err != nil </span><span class="cov0" title="0">{
                        newErrs = append(newErrs, err)
                }</span>
                <span class="cov0" title="0">newErrs = append(newErrs, errs...)

                return Append(&amp;Error{}, newErrs...)</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package multierror

// Flatten flattens the given error, merging any *Errors together into
// a single *Error.
func Flatten(err error) error <span class="cov0" title="0">{
        // If it isn't an *Error, just return the error as-is
        if _, ok := err.(*Error); !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        // Otherwise, make the result and flatten away!
        <span class="cov0" title="0">flatErr := new(Error)
        flatten(err, flatErr)
        return flatErr</span>
}

func flatten(err error, flatErr *Error) <span class="cov0" title="0">{
        switch err := err.(type) </span>{
        case *Error:<span class="cov0" title="0">
                for _, e := range err.Errors </span><span class="cov0" title="0">{
                        flatten(e, flatErr)
                }</span>
        default:<span class="cov0" title="0">
                flatErr.Errors = append(flatErr.Errors, err)</span>
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package multierror

import (
        "fmt"
        "strings"
)

// ErrorFormatFunc is a function callback that is called by Error to
// turn the list of errors into a string.
type ErrorFormatFunc func([]error) string

// ListFormatFunc is a basic formatter that outputs the number of errors
// that occurred along with a bullet point list of the errors.
func ListFormatFunc(es []error) string <span class="cov0" title="0">{
        if len(es) == 1 </span><span class="cov0" title="0">{
                return fmt.Sprintf("1 error occurred:\n\t* %s\n\n", es[0])
        }</span>

        <span class="cov0" title="0">points := make([]string, len(es))
        for i, err := range es </span><span class="cov0" title="0">{
                points[i] = fmt.Sprintf("* %s", err)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf(
                "%d errors occurred:\n\t%s\n\n",
                len(es), strings.Join(points, "\n\t"))</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package multierror

import "sync"

// Group is a collection of goroutines which return errors that need to be
// coalesced.
type Group struct {
        mutex sync.Mutex
        err   *Error
        wg    sync.WaitGroup
}

// Go calls the given function in a new goroutine.
//
// If the function returns an error it is added to the group multierror which
// is returned by Wait.
func (g *Group) Go(f func() error) <span class="cov0" title="0">{
        g.wg.Add(1)

        go func() </span><span class="cov0" title="0">{
                defer g.wg.Done()

                if err := f(); err != nil </span><span class="cov0" title="0">{
                        g.mutex.Lock()
                        g.err = Append(g.err, err)
                        g.mutex.Unlock()
                }</span>
        }()
}

// Wait blocks until all function calls from the Go method have returned, then
// returns the multierror.
func (g *Group) Wait() *Error <span class="cov0" title="0">{
        g.wg.Wait()
        g.mutex.Lock()
        defer g.mutex.Unlock()
        return g.err
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package multierror

import (
        "errors"
        "fmt"
)

// Error is an error type to track multiple errors. This is used to
// accumulate errors in cases and return them as a single "error".
type Error struct {
        Errors      []error
        ErrorFormat ErrorFormatFunc
}

func (e *Error) Error() string <span class="cov0" title="0">{
        fn := e.ErrorFormat
        if fn == nil </span><span class="cov0" title="0">{
                fn = ListFormatFunc
        }</span>

        <span class="cov0" title="0">return fn(e.Errors)</span>
}

// ErrorOrNil returns an error interface if this Error represents
// a list of errors, or returns nil if the list of errors is empty. This
// function is useful at the end of accumulation to make sure that the value
// returned represents the existence of errors.
func (e *Error) ErrorOrNil() error <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if len(e.Errors) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return e</span>
}

func (e *Error) GoString() string <span class="cov0" title="0">{
        return fmt.Sprintf("*%#v", *e)
}</span>

// WrappedErrors returns the list of errors that this Error is wrapping. It is
// an implementation of the errwrap.Wrapper interface so that multierror.Error
// can be used with that library.
//
// This method is not safe to be called concurrently. Unlike accessing the
// Errors field directly, this function also checks if the multierror is nil to
// prevent a null-pointer panic. It satisfies the errwrap.Wrapper interface.
func (e *Error) WrappedErrors() []error <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return e.Errors</span>
}

// Unwrap returns an error from Error (or nil if there are no errors).
// This error returned will further support Unwrap to get the next error,
// etc. The order will match the order of Errors in the multierror.Error
// at the time of calling.
//
// The resulting error supports errors.As/Is/Unwrap so you can continue
// to use the stdlib errors package to introspect further.
//
// This will perform a shallow copy of the errors slice. Any errors appended
// to this error after calling Unwrap will not be available until a new
// Unwrap is called on the multierror.Error.
func (e *Error) Unwrap() error <span class="cov0" title="0">{
        // If we have no errors then we do nothing
        if e == nil || len(e.Errors) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If we have exactly one error, we can just return that directly.
        <span class="cov0" title="0">if len(e.Errors) == 1 </span><span class="cov0" title="0">{
                return e.Errors[0]
        }</span>

        // Shallow copy the slice
        <span class="cov0" title="0">errs := make([]error, len(e.Errors))
        copy(errs, e.Errors)
        return chain(errs)</span>
}

// chain implements the interfaces necessary for errors.Is/As/Unwrap to
// work in a deterministic way with multierror. A chain tracks a list of
// errors while accounting for the current represented error. This lets
// Is/As be meaningful.
//
// Unwrap returns the next error. In the cleanest form, Unwrap would return
// the wrapped error here but we can't do that if we want to properly
// get access to all the errors. Instead, users are recommended to use
// Is/As to get the correct error type out.
//
// Precondition: []error is non-empty (len &gt; 0)
type chain []error

// Error implements the error interface
func (e chain) Error() string <span class="cov0" title="0">{
        return e[0].Error()
}</span>

// Unwrap implements errors.Unwrap by returning the next error in the
// chain or nil if there are no more errors.
func (e chain) Unwrap() error <span class="cov0" title="0">{
        if len(e) == 1 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return e[1:]</span>
}

// As implements errors.As by attempting to map to the current value.
func (e chain) As(target interface{}) bool <span class="cov0" title="0">{
        return errors.As(e[0], target)
}</span>

// Is implements errors.Is by comparing the current value directly.
func (e chain) Is(target error) bool <span class="cov0" title="0">{
        return errors.Is(e[0], target)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package multierror

import (
        "fmt"

        "github.com/hashicorp/errwrap"
)

// Prefix is a helper function that will prefix some text
// to the given error. If the error is a multierror.Error, then
// it will be prefixed to each wrapped error.
//
// This is useful to use when appending multiple multierrors
// together in order to give better scoping.
func Prefix(err error, prefix string) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">format := fmt.Sprintf("%s {{err}}", prefix)
        switch err := err.(type) </span>{
        case *Error:<span class="cov0" title="0">
                // Typed nils can reach here, so initialize if we are nil
                if err == nil </span><span class="cov0" title="0">{
                        err = new(Error)
                }</span>

                // Wrap each of the errors
                <span class="cov0" title="0">for i, e := range err.Errors </span><span class="cov0" title="0">{
                        err.Errors[i] = errwrap.Wrapf(format, e)
                }</span>

                <span class="cov0" title="0">return err</span>
        default:<span class="cov0" title="0">
                return errwrap.Wrapf(format, err)</span>
        }
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package multierror

// Len implements sort.Interface function for length
func (err Error) Len() int <span class="cov0" title="0">{
        return len(err.Errors)
}</span>

// Swap implements sort.Interface function for swapping elements
func (err Error) Swap(i, j int) <span class="cov0" title="0">{
        err.Errors[i], err.Errors[j] = err.Errors[j], err.Errors[i]
}</span>

// Less implements sort.Interface function for determining order
func (err Error) Less(i, j int) bool <span class="cov0" title="0">{
        return err.Errors[i].Error() &lt; err.Errors[j].Error()
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package lru

import (
        "fmt"
        "sync"

        "github.com/hashicorp/golang-lru/simplelru"
)

const (
        // Default2QRecentRatio is the ratio of the 2Q cache dedicated
        // to recently added entries that have only been accessed once.
        Default2QRecentRatio = 0.25

        // Default2QGhostEntries is the default ratio of ghost
        // entries kept to track entries recently evicted
        Default2QGhostEntries = 0.50
)

// TwoQueueCache is a thread-safe fixed size 2Q cache.
// 2Q is an enhancement over the standard LRU cache
// in that it tracks both frequently and recently used
// entries separately. This avoids a burst in access to new
// entries from evicting frequently used entries. It adds some
// additional tracking overhead to the standard LRU cache, and is
// computationally about 2x the cost, and adds some metadata over
// head. The ARCCache is similar, but does not require setting any
// parameters.
type TwoQueueCache struct {
        size       int
        recentSize int

        recent      simplelru.LRUCache
        frequent    simplelru.LRUCache
        recentEvict simplelru.LRUCache
        lock        sync.RWMutex
}

// New2Q creates a new TwoQueueCache using the default
// values for the parameters.
func New2Q(size int) (*TwoQueueCache, error) <span class="cov0" title="0">{
        return New2QParams(size, Default2QRecentRatio, Default2QGhostEntries)
}</span>

// New2QParams creates a new TwoQueueCache using the provided
// parameter values.
func New2QParams(size int, recentRatio, ghostRatio float64) (*TwoQueueCache, error) <span class="cov0" title="0">{
        if size &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid size")
        }</span>
        <span class="cov0" title="0">if recentRatio &lt; 0.0 || recentRatio &gt; 1.0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid recent ratio")
        }</span>
        <span class="cov0" title="0">if ghostRatio &lt; 0.0 || ghostRatio &gt; 1.0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ghost ratio")
        }</span>

        // Determine the sub-sizes
        <span class="cov0" title="0">recentSize := int(float64(size) * recentRatio)
        evictSize := int(float64(size) * ghostRatio)

        // Allocate the LRUs
        recent, err := simplelru.NewLRU(size, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">frequent, err := simplelru.NewLRU(size, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">recentEvict, err := simplelru.NewLRU(evictSize, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialize the cache
        <span class="cov0" title="0">c := &amp;TwoQueueCache{
                size:        size,
                recentSize:  recentSize,
                recent:      recent,
                frequent:    frequent,
                recentEvict: recentEvict,
        }
        return c, nil</span>
}

// Get looks up a key's value from the cache.
func (c *TwoQueueCache) Get(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()

        // Check if this is a frequent value
        if val, ok := c.frequent.Get(key); ok </span><span class="cov0" title="0">{
                return val, ok
        }</span>

        // If the value is contained in recent, then we
        // promote it to frequent
        <span class="cov0" title="0">if val, ok := c.recent.Peek(key); ok </span><span class="cov0" title="0">{
                c.recent.Remove(key)
                c.frequent.Add(key, val)
                return val, ok
        }</span>

        // No hit
        <span class="cov0" title="0">return nil, false</span>
}

// Add adds a value to the cache.
func (c *TwoQueueCache) Add(key, value interface{}) <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()

        // Check if the value is frequently used already,
        // and just update the value
        if c.frequent.Contains(key) </span><span class="cov0" title="0">{
                c.frequent.Add(key, value)
                return
        }</span>

        // Check if the value is recently used, and promote
        // the value into the frequent list
        <span class="cov0" title="0">if c.recent.Contains(key) </span><span class="cov0" title="0">{
                c.recent.Remove(key)
                c.frequent.Add(key, value)
                return
        }</span>

        // If the value was recently evicted, add it to the
        // frequently used list
        <span class="cov0" title="0">if c.recentEvict.Contains(key) </span><span class="cov0" title="0">{
                c.ensureSpace(true)
                c.recentEvict.Remove(key)
                c.frequent.Add(key, value)
                return
        }</span>

        // Add to the recently seen list
        <span class="cov0" title="0">c.ensureSpace(false)
        c.recent.Add(key, value)</span>
}

// ensureSpace is used to ensure we have space in the cache
func (c *TwoQueueCache) ensureSpace(recentEvict bool) <span class="cov0" title="0">{
        // If we have space, nothing to do
        recentLen := c.recent.Len()
        freqLen := c.frequent.Len()
        if recentLen+freqLen &lt; c.size </span><span class="cov0" title="0">{
                return
        }</span>

        // If the recent buffer is larger than
        // the target, evict from there
        <span class="cov0" title="0">if recentLen &gt; 0 &amp;&amp; (recentLen &gt; c.recentSize || (recentLen == c.recentSize &amp;&amp; !recentEvict)) </span><span class="cov0" title="0">{
                k, _, _ := c.recent.RemoveOldest()
                c.recentEvict.Add(k, nil)
                return
        }</span>

        // Remove from the frequent list otherwise
        <span class="cov0" title="0">c.frequent.RemoveOldest()</span>
}

// Len returns the number of items in the cache.
func (c *TwoQueueCache) Len() int <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        return c.recent.Len() + c.frequent.Len()
}</span>

// Keys returns a slice of the keys in the cache.
// The frequently used keys are first in the returned slice.
func (c *TwoQueueCache) Keys() []interface{} <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        k1 := c.frequent.Keys()
        k2 := c.recent.Keys()
        return append(k1, k2...)
}</span>

// Remove removes the provided key from the cache.
func (c *TwoQueueCache) Remove(key interface{}) <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()
        if c.frequent.Remove(key) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if c.recent.Remove(key) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if c.recentEvict.Remove(key) </span><span class="cov0" title="0">{
                return
        }</span>
}

// Purge is used to completely clear the cache.
func (c *TwoQueueCache) Purge() <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()
        c.recent.Purge()
        c.frequent.Purge()
        c.recentEvict.Purge()
}</span>

// Contains is used to check if the cache contains a key
// without updating recency or frequency.
func (c *TwoQueueCache) Contains(key interface{}) bool <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        return c.frequent.Contains(key) || c.recent.Contains(key)
}</span>

// Peek is used to inspect the cache value of a key
// without updating recency or frequency.
func (c *TwoQueueCache) Peek(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        if val, ok := c.frequent.Peek(key); ok </span><span class="cov0" title="0">{
                return val, ok
        }</span>
        <span class="cov0" title="0">return c.recent.Peek(key)</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package lru

import (
        "sync"

        "github.com/hashicorp/golang-lru/simplelru"
)

// ARCCache is a thread-safe fixed size Adaptive Replacement Cache (ARC).
// ARC is an enhancement over the standard LRU cache in that tracks both
// frequency and recency of use. This avoids a burst in access to new
// entries from evicting the frequently used older entries. It adds some
// additional tracking overhead to a standard LRU cache, computationally
// it is roughly 2x the cost, and the extra memory overhead is linear
// with the size of the cache. ARC has been patented by IBM, but is
// similar to the TwoQueueCache (2Q) which requires setting parameters.
type ARCCache struct {
        size int // Size is the total capacity of the cache
        p    int // P is the dynamic preference towards T1 or T2

        t1 simplelru.LRUCache // T1 is the LRU for recently accessed items
        b1 simplelru.LRUCache // B1 is the LRU for evictions from t1

        t2 simplelru.LRUCache // T2 is the LRU for frequently accessed items
        b2 simplelru.LRUCache // B2 is the LRU for evictions from t2

        lock sync.RWMutex
}

// NewARC creates an ARC of the given size
func NewARC(size int) (*ARCCache, error) <span class="cov0" title="0">{
        // Create the sub LRUs
        b1, err := simplelru.NewLRU(size, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b2, err := simplelru.NewLRU(size, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">t1, err := simplelru.NewLRU(size, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">t2, err := simplelru.NewLRU(size, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialize the ARC
        <span class="cov0" title="0">c := &amp;ARCCache{
                size: size,
                p:    0,
                t1:   t1,
                b1:   b1,
                t2:   t2,
                b2:   b2,
        }
        return c, nil</span>
}

// Get looks up a key's value from the cache.
func (c *ARCCache) Get(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()

        // If the value is contained in T1 (recent), then
        // promote it to T2 (frequent)
        if val, ok := c.t1.Peek(key); ok </span><span class="cov0" title="0">{
                c.t1.Remove(key)
                c.t2.Add(key, val)
                return val, ok
        }</span>

        // Check if the value is contained in T2 (frequent)
        <span class="cov0" title="0">if val, ok := c.t2.Get(key); ok </span><span class="cov0" title="0">{
                return val, ok
        }</span>

        // No hit
        <span class="cov0" title="0">return nil, false</span>
}

// Add adds a value to the cache.
func (c *ARCCache) Add(key, value interface{}) <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()

        // Check if the value is contained in T1 (recent), and potentially
        // promote it to frequent T2
        if c.t1.Contains(key) </span><span class="cov0" title="0">{
                c.t1.Remove(key)
                c.t2.Add(key, value)
                return
        }</span>

        // Check if the value is already in T2 (frequent) and update it
        <span class="cov0" title="0">if c.t2.Contains(key) </span><span class="cov0" title="0">{
                c.t2.Add(key, value)
                return
        }</span>

        // Check if this value was recently evicted as part of the
        // recently used list
        <span class="cov0" title="0">if c.b1.Contains(key) </span><span class="cov0" title="0">{
                // T1 set is too small, increase P appropriately
                delta := 1
                b1Len := c.b1.Len()
                b2Len := c.b2.Len()
                if b2Len &gt; b1Len </span><span class="cov0" title="0">{
                        delta = b2Len / b1Len
                }</span>
                <span class="cov0" title="0">if c.p+delta &gt;= c.size </span><span class="cov0" title="0">{
                        c.p = c.size
                }</span> else<span class="cov0" title="0"> {
                        c.p += delta
                }</span>

                // Potentially need to make room in the cache
                <span class="cov0" title="0">if c.t1.Len()+c.t2.Len() &gt;= c.size </span><span class="cov0" title="0">{
                        c.replace(false)
                }</span>

                // Remove from B1
                <span class="cov0" title="0">c.b1.Remove(key)

                // Add the key to the frequently used list
                c.t2.Add(key, value)
                return</span>
        }

        // Check if this value was recently evicted as part of the
        // frequently used list
        <span class="cov0" title="0">if c.b2.Contains(key) </span><span class="cov0" title="0">{
                // T2 set is too small, decrease P appropriately
                delta := 1
                b1Len := c.b1.Len()
                b2Len := c.b2.Len()
                if b1Len &gt; b2Len </span><span class="cov0" title="0">{
                        delta = b1Len / b2Len
                }</span>
                <span class="cov0" title="0">if delta &gt;= c.p </span><span class="cov0" title="0">{
                        c.p = 0
                }</span> else<span class="cov0" title="0"> {
                        c.p -= delta
                }</span>

                // Potentially need to make room in the cache
                <span class="cov0" title="0">if c.t1.Len()+c.t2.Len() &gt;= c.size </span><span class="cov0" title="0">{
                        c.replace(true)
                }</span>

                // Remove from B2
                <span class="cov0" title="0">c.b2.Remove(key)

                // Add the key to the frequently used list
                c.t2.Add(key, value)
                return</span>
        }

        // Potentially need to make room in the cache
        <span class="cov0" title="0">if c.t1.Len()+c.t2.Len() &gt;= c.size </span><span class="cov0" title="0">{
                c.replace(false)
        }</span>

        // Keep the size of the ghost buffers trim
        <span class="cov0" title="0">if c.b1.Len() &gt; c.size-c.p </span><span class="cov0" title="0">{
                c.b1.RemoveOldest()
        }</span>
        <span class="cov0" title="0">if c.b2.Len() &gt; c.p </span><span class="cov0" title="0">{
                c.b2.RemoveOldest()
        }</span>

        // Add to the recently seen list
        <span class="cov0" title="0">c.t1.Add(key, value)</span>
}

// replace is used to adaptively evict from either T1 or T2
// based on the current learned value of P
func (c *ARCCache) replace(b2ContainsKey bool) <span class="cov0" title="0">{
        t1Len := c.t1.Len()
        if t1Len &gt; 0 &amp;&amp; (t1Len &gt; c.p || (t1Len == c.p &amp;&amp; b2ContainsKey)) </span><span class="cov0" title="0">{
                k, _, ok := c.t1.RemoveOldest()
                if ok </span><span class="cov0" title="0">{
                        c.b1.Add(k, nil)
                }</span>
        } else<span class="cov0" title="0"> {
                k, _, ok := c.t2.RemoveOldest()
                if ok </span><span class="cov0" title="0">{
                        c.b2.Add(k, nil)
                }</span>
        }
}

// Len returns the number of cached entries
func (c *ARCCache) Len() int <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        return c.t1.Len() + c.t2.Len()
}</span>

// Keys returns all the cached keys
func (c *ARCCache) Keys() []interface{} <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        k1 := c.t1.Keys()
        k2 := c.t2.Keys()
        return append(k1, k2...)
}</span>

// Remove is used to purge a key from the cache
func (c *ARCCache) Remove(key interface{}) <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()
        if c.t1.Remove(key) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if c.t2.Remove(key) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if c.b1.Remove(key) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if c.b2.Remove(key) </span><span class="cov0" title="0">{
                return
        }</span>
}

// Purge is used to clear the cache
func (c *ARCCache) Purge() <span class="cov0" title="0">{
        c.lock.Lock()
        defer c.lock.Unlock()
        c.t1.Purge()
        c.t2.Purge()
        c.b1.Purge()
        c.b2.Purge()
}</span>

// Contains is used to check if the cache contains a key
// without updating recency or frequency.
func (c *ARCCache) Contains(key interface{}) bool <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        return c.t1.Contains(key) || c.t2.Contains(key)
}</span>

// Peek is used to inspect the cache value of a key
// without updating recency or frequency.
func (c *ARCCache) Peek(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        c.lock.RLock()
        defer c.lock.RUnlock()
        if val, ok := c.t1.Peek(key); ok </span><span class="cov0" title="0">{
                return val, ok
        }</span>
        <span class="cov0" title="0">return c.t2.Peek(key)</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package lru

import (
        "sync"

        "github.com/hashicorp/golang-lru/simplelru"
)

const (
        // DefaultEvictedBufferSize defines the default buffer size to store evicted key/val
        DefaultEvictedBufferSize = 16
)

// Cache is a thread-safe fixed size LRU cache.
type Cache struct {
        lru                      *simplelru.LRU
        evictedKeys, evictedVals []interface{}
        onEvictedCB              func(k, v interface{})
        lock                     sync.RWMutex
}

// New creates an LRU of the given size.
func New(size int) (*Cache, error) <span class="cov0" title="0">{
        return NewWithEvict(size, nil)
}</span>

// NewWithEvict constructs a fixed size cache with the given eviction
// callback.
func NewWithEvict(size int, onEvicted func(key, value interface{})) (c *Cache, err error) <span class="cov0" title="0">{
        // create a cache with default settings
        c = &amp;Cache{
                onEvictedCB: onEvicted,
        }
        if onEvicted != nil </span><span class="cov0" title="0">{
                c.initEvictBuffers()
                onEvicted = c.onEvicted
        }</span>
        <span class="cov0" title="0">c.lru, err = simplelru.NewLRU(size, onEvicted)
        return</span>
}

func (c *Cache) initEvictBuffers() <span class="cov0" title="0">{
        c.evictedKeys = make([]interface{}, 0, DefaultEvictedBufferSize)
        c.evictedVals = make([]interface{}, 0, DefaultEvictedBufferSize)
}</span>

// onEvicted save evicted key/val and sent in externally registered callback
// outside of critical section
func (c *Cache) onEvicted(k, v interface{}) <span class="cov0" title="0">{
        c.evictedKeys = append(c.evictedKeys, k)
        c.evictedVals = append(c.evictedVals, v)
}</span>

// Purge is used to completely clear the cache.
func (c *Cache) Purge() <span class="cov0" title="0">{
        var ks, vs []interface{}
        c.lock.Lock()
        c.lru.Purge()
        if c.onEvictedCB != nil &amp;&amp; len(c.evictedKeys) &gt; 0 </span><span class="cov0" title="0">{
                ks, vs = c.evictedKeys, c.evictedVals
                c.initEvictBuffers()
        }</span>
        <span class="cov0" title="0">c.lock.Unlock()
        // invoke callback outside of critical section
        if c.onEvictedCB != nil </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(ks); i++ </span><span class="cov0" title="0">{
                        c.onEvictedCB(ks[i], vs[i])
                }</span>
        }
}

// Add adds a value to the cache. Returns true if an eviction occurred.
func (c *Cache) Add(key, value interface{}) (evicted bool) <span class="cov0" title="0">{
        var k, v interface{}
        c.lock.Lock()
        evicted = c.lru.Add(key, value)
        if c.onEvictedCB != nil &amp;&amp; evicted </span><span class="cov0" title="0">{
                k, v = c.evictedKeys[0], c.evictedVals[0]
                c.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]
        }</span>
        <span class="cov0" title="0">c.lock.Unlock()
        if c.onEvictedCB != nil &amp;&amp; evicted </span><span class="cov0" title="0">{
                c.onEvictedCB(k, v)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Get looks up a key's value from the cache.
func (c *Cache) Get(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        c.lock.Lock()
        value, ok = c.lru.Get(key)
        c.lock.Unlock()
        return value, ok
}</span>

// Contains checks if a key is in the cache, without updating the
// recent-ness or deleting it for being stale.
func (c *Cache) Contains(key interface{}) bool <span class="cov0" title="0">{
        c.lock.RLock()
        containKey := c.lru.Contains(key)
        c.lock.RUnlock()
        return containKey
}</span>

// Peek returns the key value (or undefined if not found) without updating
// the "recently used"-ness of the key.
func (c *Cache) Peek(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        c.lock.RLock()
        value, ok = c.lru.Peek(key)
        c.lock.RUnlock()
        return value, ok
}</span>

// ContainsOrAdd checks if a key is in the cache without updating the
// recent-ness or deleting it for being stale, and if not, adds the value.
// Returns whether found and whether an eviction occurred.
func (c *Cache) ContainsOrAdd(key, value interface{}) (ok, evicted bool) <span class="cov0" title="0">{
        var k, v interface{}
        c.lock.Lock()
        if c.lru.Contains(key) </span><span class="cov0" title="0">{
                c.lock.Unlock()
                return true, false
        }</span>
        <span class="cov0" title="0">evicted = c.lru.Add(key, value)
        if c.onEvictedCB != nil &amp;&amp; evicted </span><span class="cov0" title="0">{
                k, v = c.evictedKeys[0], c.evictedVals[0]
                c.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]
        }</span>
        <span class="cov0" title="0">c.lock.Unlock()
        if c.onEvictedCB != nil &amp;&amp; evicted </span><span class="cov0" title="0">{
                c.onEvictedCB(k, v)
        }</span>
        <span class="cov0" title="0">return false, evicted</span>
}

// PeekOrAdd checks if a key is in the cache without updating the
// recent-ness or deleting it for being stale, and if not, adds the value.
// Returns whether found and whether an eviction occurred.
func (c *Cache) PeekOrAdd(key, value interface{}) (previous interface{}, ok, evicted bool) <span class="cov0" title="0">{
        var k, v interface{}
        c.lock.Lock()
        previous, ok = c.lru.Peek(key)
        if ok </span><span class="cov0" title="0">{
                c.lock.Unlock()
                return previous, true, false
        }</span>
        <span class="cov0" title="0">evicted = c.lru.Add(key, value)
        if c.onEvictedCB != nil &amp;&amp; evicted </span><span class="cov0" title="0">{
                k, v = c.evictedKeys[0], c.evictedVals[0]
                c.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]
        }</span>
        <span class="cov0" title="0">c.lock.Unlock()
        if c.onEvictedCB != nil &amp;&amp; evicted </span><span class="cov0" title="0">{
                c.onEvictedCB(k, v)
        }</span>
        <span class="cov0" title="0">return nil, false, evicted</span>
}

// Remove removes the provided key from the cache.
func (c *Cache) Remove(key interface{}) (present bool) <span class="cov0" title="0">{
        var k, v interface{}
        c.lock.Lock()
        present = c.lru.Remove(key)
        if c.onEvictedCB != nil &amp;&amp; present </span><span class="cov0" title="0">{
                k, v = c.evictedKeys[0], c.evictedVals[0]
                c.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]
        }</span>
        <span class="cov0" title="0">c.lock.Unlock()
        if c.onEvictedCB != nil &amp;&amp; present </span><span class="cov0" title="0">{
                c.onEvictedCB(k, v)
        }</span>
        <span class="cov0" title="0">return</span>
}

// Resize changes the cache size.
func (c *Cache) Resize(size int) (evicted int) <span class="cov0" title="0">{
        var ks, vs []interface{}
        c.lock.Lock()
        evicted = c.lru.Resize(size)
        if c.onEvictedCB != nil &amp;&amp; evicted &gt; 0 </span><span class="cov0" title="0">{
                ks, vs = c.evictedKeys, c.evictedVals
                c.initEvictBuffers()
        }</span>
        <span class="cov0" title="0">c.lock.Unlock()
        if c.onEvictedCB != nil &amp;&amp; evicted &gt; 0 </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(ks); i++ </span><span class="cov0" title="0">{
                        c.onEvictedCB(ks[i], vs[i])
                }</span>
        }
        <span class="cov0" title="0">return evicted</span>
}

// RemoveOldest removes the oldest item from the cache.
func (c *Cache) RemoveOldest() (key, value interface{}, ok bool) <span class="cov0" title="0">{
        var k, v interface{}
        c.lock.Lock()
        key, value, ok = c.lru.RemoveOldest()
        if c.onEvictedCB != nil &amp;&amp; ok </span><span class="cov0" title="0">{
                k, v = c.evictedKeys[0], c.evictedVals[0]
                c.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]
        }</span>
        <span class="cov0" title="0">c.lock.Unlock()
        if c.onEvictedCB != nil &amp;&amp; ok </span><span class="cov0" title="0">{
                c.onEvictedCB(k, v)
        }</span>
        <span class="cov0" title="0">return</span>
}

// GetOldest returns the oldest entry
func (c *Cache) GetOldest() (key, value interface{}, ok bool) <span class="cov0" title="0">{
        c.lock.RLock()
        key, value, ok = c.lru.GetOldest()
        c.lock.RUnlock()
        return
}</span>

// Keys returns a slice of the keys in the cache, from oldest to newest.
func (c *Cache) Keys() []interface{} <span class="cov0" title="0">{
        c.lock.RLock()
        keys := c.lru.Keys()
        c.lock.RUnlock()
        return keys
}</span>

// Len returns the number of items in the cache.
func (c *Cache) Len() int <span class="cov0" title="0">{
        c.lock.RLock()
        length := c.lru.Len()
        c.lock.RUnlock()
        return length
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package simplelru

import (
        "container/list"
        "errors"
)

// EvictCallback is used to get a callback when a cache entry is evicted
type EvictCallback func(key interface{}, value interface{})

// LRU implements a non-thread safe fixed size LRU cache
type LRU struct {
        size      int
        evictList *list.List
        items     map[interface{}]*list.Element
        onEvict   EvictCallback
}

// entry is used to hold a value in the evictList
type entry struct {
        key   interface{}
        value interface{}
}

// NewLRU constructs an LRU of the given size
func NewLRU(size int, onEvict EvictCallback) (*LRU, error) <span class="cov0" title="0">{
        if size &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("must provide a positive size")
        }</span>
        <span class="cov0" title="0">c := &amp;LRU{
                size:      size,
                evictList: list.New(),
                items:     make(map[interface{}]*list.Element),
                onEvict:   onEvict,
        }
        return c, nil</span>
}

// Purge is used to completely clear the cache.
func (c *LRU) Purge() <span class="cov0" title="0">{
        for k, v := range c.items </span><span class="cov0" title="0">{
                if c.onEvict != nil </span><span class="cov0" title="0">{
                        c.onEvict(k, v.Value.(*entry).value)
                }</span>
                <span class="cov0" title="0">delete(c.items, k)</span>
        }
        <span class="cov0" title="0">c.evictList.Init()</span>
}

// Add adds a value to the cache.  Returns true if an eviction occurred.
func (c *LRU) Add(key, value interface{}) (evicted bool) <span class="cov0" title="0">{
        // Check for existing item
        if ent, ok := c.items[key]; ok </span><span class="cov0" title="0">{
                c.evictList.MoveToFront(ent)
                ent.Value.(*entry).value = value
                return false
        }</span>

        // Add new item
        <span class="cov0" title="0">ent := &amp;entry{key, value}
        entry := c.evictList.PushFront(ent)
        c.items[key] = entry

        evict := c.evictList.Len() &gt; c.size
        // Verify size not exceeded
        if evict </span><span class="cov0" title="0">{
                c.removeOldest()
        }</span>
        <span class="cov0" title="0">return evict</span>
}

// Get looks up a key's value from the cache.
func (c *LRU) Get(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        if ent, ok := c.items[key]; ok </span><span class="cov0" title="0">{
                c.evictList.MoveToFront(ent)
                if ent.Value.(*entry) == nil </span><span class="cov0" title="0">{
                        return nil, false
                }</span>
                <span class="cov0" title="0">return ent.Value.(*entry).value, true</span>
        }
        <span class="cov0" title="0">return</span>
}

// Contains checks if a key is in the cache, without updating the recent-ness
// or deleting it for being stale.
func (c *LRU) Contains(key interface{}) (ok bool) <span class="cov0" title="0">{
        _, ok = c.items[key]
        return ok
}</span>

// Peek returns the key value (or undefined if not found) without updating
// the "recently used"-ness of the key.
func (c *LRU) Peek(key interface{}) (value interface{}, ok bool) <span class="cov0" title="0">{
        var ent *list.Element
        if ent, ok = c.items[key]; ok </span><span class="cov0" title="0">{
                return ent.Value.(*entry).value, true
        }</span>
        <span class="cov0" title="0">return nil, ok</span>
}

// Remove removes the provided key from the cache, returning if the
// key was contained.
func (c *LRU) Remove(key interface{}) (present bool) <span class="cov0" title="0">{
        if ent, ok := c.items[key]; ok </span><span class="cov0" title="0">{
                c.removeElement(ent)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// RemoveOldest removes the oldest item from the cache.
func (c *LRU) RemoveOldest() (key, value interface{}, ok bool) <span class="cov0" title="0">{
        ent := c.evictList.Back()
        if ent != nil </span><span class="cov0" title="0">{
                c.removeElement(ent)
                kv := ent.Value.(*entry)
                return kv.key, kv.value, true
        }</span>
        <span class="cov0" title="0">return nil, nil, false</span>
}

// GetOldest returns the oldest entry
func (c *LRU) GetOldest() (key, value interface{}, ok bool) <span class="cov0" title="0">{
        ent := c.evictList.Back()
        if ent != nil </span><span class="cov0" title="0">{
                kv := ent.Value.(*entry)
                return kv.key, kv.value, true
        }</span>
        <span class="cov0" title="0">return nil, nil, false</span>
}

// Keys returns a slice of the keys in the cache, from oldest to newest.
func (c *LRU) Keys() []interface{} <span class="cov0" title="0">{
        keys := make([]interface{}, len(c.items))
        i := 0
        for ent := c.evictList.Back(); ent != nil; ent = ent.Prev() </span><span class="cov0" title="0">{
                keys[i] = ent.Value.(*entry).key
                i++
        }</span>
        <span class="cov0" title="0">return keys</span>
}

// Len returns the number of items in the cache.
func (c *LRU) Len() int <span class="cov0" title="0">{
        return c.evictList.Len()
}</span>

// Resize changes the cache size.
func (c *LRU) Resize(size int) (evicted int) <span class="cov0" title="0">{
        diff := c.Len() - size
        if diff &lt; 0 </span><span class="cov0" title="0">{
                diff = 0
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; diff; i++ </span><span class="cov0" title="0">{
                c.removeOldest()
        }</span>
        <span class="cov0" title="0">c.size = size
        return diff</span>
}

// removeOldest removes the oldest item from the cache.
func (c *LRU) removeOldest() <span class="cov0" title="0">{
        ent := c.evictList.Back()
        if ent != nil </span><span class="cov0" title="0">{
                c.removeElement(ent)
        }</span>
}

// removeElement is used to remove a given list element from the cache
func (c *LRU) removeElement(e *list.Element) <span class="cov0" title="0">{
        c.evictList.Remove(e)
        kv := e.Value.(*entry)
        delete(c.items, kv.key)
        if c.onEvict != nil </span><span class="cov0" title="0">{
                c.onEvict(kv.key, kv.value)
        }</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package lru

import (
        "crypto/rand"
        "math"
        "math/big"
        "testing"
)

func getRand(tb testing.TB) int64 <span class="cov0" title="0">{
        out, err := rand.Int(rand.Reader, big.NewInt(math.MaxInt64))
        if err != nil </span><span class="cov0" title="0">{
                tb.Fatal(err)
        }</span>
        <span class="cov0" title="0">return out.Int64()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
