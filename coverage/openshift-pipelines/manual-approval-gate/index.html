<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coverage Report</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <style>
      :root {
  --sidebar-width: 280px;
  --topbar-height: 48px;
  --line-height: 20px;
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
}

[data-theme="dark"] {
  --bg: #1e1e1e;
  --bg-secondary: #252526;
  --bg-tertiary: #2d2d2d;
  --text: #d4d4d4;
  --text-muted: #808080;
  --border: #3c3c3c;
  --covered: rgba(35, 134, 54, 0.25);
  --covered-gutter: #238636;
  --uncovered: rgba(218, 54, 51, 0.25);
  --uncovered-gutter: #da3633;
  --highlight: #264f78;
  --highlight-match: #613214;
  --accent: #569cd6;
  --hover: #2a2d2e;
}

[data-theme="light"] {
  --bg: #ffffff;
  --bg-secondary: #f3f3f3;
  --bg-tertiary: #e8e8e8;
  --text: #24292f;
  --text-muted: #656d76;
  --border: #d0d7de;
  --covered: rgba(35, 134, 54, 0.15);
  --covered-gutter: #1a7f37;
  --uncovered: rgba(218, 54, 51, 0.15);
  --uncovered-gutter: #cf222e;
  --highlight: #ddf4ff;
  --highlight-match: #fff8c5;
  --accent: #0969da;
  --hover: #f6f8fa;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  font-size: 14px;
  background: var(--bg);
  color: var(--text);
}

#app {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  height: 100%;
}

/* Sidebar */
#sidebar {
  display: flex;
  flex-direction: column;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  overflow: hidden;
}

#sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
}

/* Logo link */
#logo-link {
  text-decoration: none;
  color: inherit;
  display: block;
}

#logo-link:hover #logo-container {
  opacity: 0.8;
}

#logo-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  transition: opacity 0.15s ease;
}

#logo-container .github-icon {
  flex-shrink: 0;
  color: var(--text-muted);
  transition: color 0.15s ease;
}

#logo-link:hover .github-icon {
  color: var(--accent);
}

#logo {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

#logo-text {
  flex: 1;
  min-width: 0;
}

#sidebar-header h1 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  line-height: 1.2;
}

#tagline {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  margin: 2px 0 0 0;
  line-height: 1.3;
}

#summary {
  font-size: 13px;
  color: var(--text-muted);
}

#summary .percent {
  font-weight: 600;
  color: var(--text);
}

#search-box {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
}

#search-input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 13px;
}

#search-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Sort controls */
#sort-controls {
  display: flex;
  gap: 0;
  margin: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}

.sort-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 6px 8px;
  background: var(--bg-secondary);
  color: var(--text);
  border: none;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.2s, color 0.2s;
}

.sort-btn:hover {
  background: var(--hover);
}

.sort-btn.active {
  background: var(--accent);
  color: #fff;
}

.sort-btn .icon {
  font-weight: 600;
}

.sort-btn .label {
  font-size: 11px;
}

/* Coverage badges for directories */
.coverage-badge {
  margin-left: auto;
  padding-left: 8px;
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  font-family: var(--font-mono);
}

#file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}

/* Sidebar footer */
#sidebar-footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  font-size: 12px;
  text-align: center;
}

#sidebar-footer a {
  color: var(--text-muted);
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

#sidebar-footer a:hover {
  color: var(--accent);
  text-decoration: underline;
}

#sidebar-footer .github-icon {
  flex-shrink: 0;
}

.tree-node {
  cursor: pointer;
  user-select: none;
}

.tree-item {
  display: flex;
  align-items: center;
  padding: 4px 16px;
  gap: 6px;
  white-space: nowrap;
}

.tree-item:hover {
  background: var(--hover);
}

.tree-item.selected {
  background: var(--highlight);
}

.tree-item .icon {
  width: 16px;
  text-align: center;
  font-size: 12px;
  color: var(--text-muted);
}

.tree-item .name {
  font-size: 13px;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.tree-children {
  display: none;
}

.tree-node.expanded > .tree-children {
  display: block;
}

.tree-children .tree-item {
  padding-left: calc(16px + var(--depth, 0) * 16px);
}

.tree-node.hidden {
  display: none;
}

/* Canvas */
#canvas {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--topbar-height);
  padding: 0 16px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  gap: 16px;
}

#file-path {
  font-size: 13px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#topbar-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

#in-file-search {
  display: flex;
  align-items: center;
  gap: 8px;
}

#content-search {
  width: 180px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 12px;
}

#content-search:focus {
  outline: none;
  border-color: var(--accent);
}

#match-info {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
}

#prev-match, #next-match {
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 10px;
}

#prev-match:hover, #next-match:hover {
  background: var(--hover);
}

#theme-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 16px;
}

#theme-toggle:hover {
  background: var(--hover);
}

#syntax-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-family: var(--font-mono);
}

#syntax-toggle:hover {
  background: var(--hover);
}

#syntax-toggle.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

#help-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
}

#help-toggle:hover {
  background: var(--hover);
}

/* Override highlight.js to use theme-aware colors */
.hljs { background: transparent !important; }

[data-theme="dark"] .hljs-keyword { color: #569cd6; }
[data-theme="dark"] .hljs-type { color: #4ec9b0; }
[data-theme="dark"] .hljs-string { color: #ce9178; }
[data-theme="dark"] .hljs-number { color: #b5cea8; }
[data-theme="dark"] .hljs-comment { color: #6a9955; }
[data-theme="dark"] .hljs-built_in { color: #dcdcaa; }
[data-theme="dark"] .hljs-literal { color: #569cd6; }
[data-theme="dark"] .hljs-function { color: #dcdcaa; }

[data-theme="light"] .hljs-keyword { color: #0000ff; }
[data-theme="light"] .hljs-type { color: #267f99; }
[data-theme="light"] .hljs-string { color: #a31515; }
[data-theme="light"] .hljs-number { color: #098658; }
[data-theme="light"] .hljs-comment { color: #008000; }
[data-theme="light"] .hljs-built_in { color: #795e26; }
[data-theme="light"] .hljs-literal { color: #0000ff; }
[data-theme="light"] .hljs-function { color: #795e26; }

/* Viewport */
#viewport {
  flex: 1;
  overflow: auto;
  background: var(--bg);
  outline: none;
}

#viewport::-webkit-scrollbar {
  width: 14px;
  height: 14px;
}

#viewport::-webkit-scrollbar-track {
  background: var(--bg);
}

#viewport::-webkit-scrollbar-thumb {
  background: var(--border);
  border: 3px solid var(--bg);
  border-radius: 7px;
}

#viewport::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

.code-container {
  display: table;
  min-width: 100%;
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: var(--line-height);
}

.code-line {
  display: table-row;
}

.code-line:hover {
  background: var(--hover);
}

.code-line.covered {
  background: var(--covered);
}

.code-line.uncovered {
  background: var(--uncovered);
}

.code-line.covered:hover {
  background: var(--covered);
}

.code-line.uncovered:hover {
  background: var(--uncovered);
}

.gutter {
  display: table-cell;
  width: 4px;
  min-width: 4px;
}

.code-line.covered .gutter {
  background: var(--covered-gutter);
}

.code-line.uncovered .gutter {
  background: var(--uncovered-gutter);
}

.line-number {
  display: table-cell;
  width: 50px;
  min-width: 50px;
  padding: 0 12px 0 8px;
  text-align: right;
  color: var(--text-muted);
  user-select: none;
  vertical-align: top;
}

.line-content {
  display: table-cell;
  padding-right: 16px;
  white-space: pre;
  tab-size: 4;
}

.match-highlight {
  background: var(--highlight-match);
  border-radius: 2px;
}

.current-match {
  background: var(--accent);
  color: #fff;
}

/* Empty state */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-muted);
  gap: 8px;
}

.empty-state .icon {
  font-size: 48px;
  opacity: 0.5;
}

/* Scrollbar for file tree */
#file-tree::-webkit-scrollbar {
  width: 8px;
}

#file-tree::-webkit-scrollbar-track {
  background: transparent;
}

#file-tree::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

#file-tree::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Help modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  max-width: 400px;
  width: 90%;
}

.modal-content h2 {
  margin-bottom: 16px;
  font-size: 18px;
}

.modal-content dl {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px 16px;
}

.modal-content dt {
  font-family: var(--font-mono);
  background: var(--bg-tertiary);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
}

.modal-content dd {
  color: var(--text-muted);
}

.modal-content button {
  margin-top: 20px;
  padding: 8px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  width: 100%;
}

/* Selected line range (multi-line selection) */
.code-line.selected-line {
  background-color: var(--highlight);
}

.code-line.selected-line.covered {
  background-color: var(--highlight);
}

.code-line.selected-line.uncovered {
  background-color: var(--highlight);
}

/* Line number click indicator */
.line-number {
  cursor: pointer;
}

.line-number:hover {
  color: var(--accent);
}

    </style>
  </head>
  <body data-theme="dark">
    <div id="app">
      <aside id="sidebar">
        <div id="sidebar-header">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            id="logo-link"
            target="_blank"
            rel="noopener"
          >
            <div id="logo-container">
              <svg id="logo" viewBox="0 0 32 32" width="32" height="32">
                <defs>
                  <linearGradient
                    id="logoGradient"
                    x1="0%"
                    y1="0%"
                    x2="100%"
                    y2="100%"
                  >
                    <stop
                      offset="0%"
                      style="stop-color: var(--accent); stop-opacity: 1"
                    />
                    <stop
                      offset="100%"
                      style="stop-color: var(--accent); stop-opacity: 0.7"
                    />
                  </linearGradient>
                </defs>
                
                <circle
                  cx="16"
                  cy="16"
                  r="14"
                  fill="none"
                  stroke="url(#logoGradient)"
                  stroke-width="2"
                  opacity="0.3"
                />
                
                <path
                  d="M 10 17 L 14 21 L 22 11"
                  fill="none"
                  stroke="var(--accent)"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                
                <circle
                  cx="24"
                  cy="10"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
                <circle
                  cx="26"
                  cy="12"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
              </svg>
              <div id="logo-text">
                <h1>GO Coverage</h1>
                <div id="tagline">A better HTML Go Coverage</div>
              </div>
            </div>
          </a>
          <div id="summary"></div>
        </div>
        <div id="search-box">
          <input type="text" id="search-input" placeholder="Search files..." />
        </div>
        <div id="sort-controls">
          <button
            class="sort-btn active"
            data-sort="name"
            title="Sort alphabetically"
          >
            <span class="icon">Aâ†’Z</span>
            <span class="label">Name</span>
          </button>
          <button
            class="sort-btn"
            data-sort="coverage"
            title="Sort by coverage percentage"
          >
            <span class="icon">%</span>
            <span class="label">Coverage</span>
          </button>
        </div>
        <div id="file-tree"></div>
        <footer id="sidebar-footer">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            target="_blank"
            rel="noopener"
          >
            <svg
              class="github-icon"
              viewBox="0 0 16 16"
              width="14"
              height="14"
              fill="currentColor"
            >
              <path
                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
              />
            </svg>
            chmouel/go-better-html-coverage
          </a>
        </footer>
      </aside>
      <main id="canvas">
        <header id="topbar">
          <div id="file-path"></div>
          <div id="topbar-actions">
            <div id="in-file-search">
              <input
                type="text"
                id="content-search"
                placeholder="Search in file..."
              />
              <span id="match-info"></span>
              <button id="prev-match" title="Previous match">&#9650;</button>
              <button id="next-match" title="Next match">&#9660;</button>
            </div>
            <button id="syntax-toggle" title="Toggle syntax highlighting">
              &lt;/&gt;
            </button>
            <button id="theme-toggle" title="Toggle theme">&#9788;</button>
            <button id="help-toggle" title="Keyboard shortcuts">?</button>
          </div>
        </header>
        <div id="viewport" tabindex="-1"></div>
      </main>
      <div id="help-modal" class="modal hidden">
        <div class="modal-content">
          <h2>Keyboard Shortcuts</h2>
          <dl>
            <dt>Ctrl+P</dt>
            <dd>Focus file search</dd>
            <dt>Ctrl+F</dt>
            <dd>Search in file</dd>
            <dt>Enter</dt>
            <dd>Next match</dd>
            <dt>Shift+Enter</dt>
            <dd>Previous match</dd>
            <dt>?</dt>
            <dd>Show this help</dd>
            <dt>Esc</dt>
            <dd>Close modal</dd>
          </dl>
          <h2>Permalinks</h2>
          <dl>
            <dt>Click line</dt>
            <dd>Select line, update URL</dd>
            <dt>Shift+Click</dt>
            <dd>Select line range</dd>
          </dl>
          <button id="close-help">Close</button>
        </div>
      </div>
    </div>
    <script>
      window.COVERAGE_DATA = {"files":[{"id":0,"path":"pkg/actions/actions.go","lines":["package actions","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"sync\"","","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/cli\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/client-go/discovery\"","\t\"k8s.io/client-go/dynamic\"","\t\"k8s.io/client-go/restmapper\"",")","","var (","\tdoOnce      sync.Once","\tapiGroupRes []*restmapper.APIGroupResources",")","","// List fetches the resource and convert it to respective object","func List(gr schema.GroupVersionResource, c *cli.Clients, opts metav1.ListOptions, ns string, obj interface{}) error {","\tunstructuredObj, err := list(gr, c.Dynamic, c.ApprovalTask.Discovery(), ns, opts)","\tif err != nil {","\t\tfmt.Fprintf(os.Stderr, \"Failed to list objects from %s namespace \\n\", ns)","\t\treturn err","\t}","","\treturn runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)","}","","// list takes a partial resource and fetches a list of that resource's objects in the cluster using the dynamic client.","func list(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, ns string, op metav1.ListOptions) (*unstructured.UnstructuredList, error) {","\tgvr, err := GetGroupVersionResource(gr, discovery)","\tif err != nil {","\t\treturn nil, err","\t}","","\tallRes, err := dynamic.Resource(*gvr).Namespace(ns).List(context.Background(), op)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn allRes, nil","}","","func Get(gr schema.GroupVersionResource, c *cli.Clients, opts *cli.Options) (*v1alpha1.ApprovalTask, error) {","\tgvr, err := GetGroupVersionResource(gr, c.ApprovalTask.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tat, err := get(gvr, c, opts)","\tif err != nil {","\t\treturn \u0026v1alpha1.ApprovalTask{}, err","\t}","","\treturn at, nil","}","","func get(gvr *schema.GroupVersionResource, c *cli.Clients, opts *cli.Options) (*v1alpha1.ApprovalTask, error) {","\tresult, err := c.Dynamic.Resource(*gvr).Namespace(opts.Namespace).Get(context.Background(), opts.Name, metav1.GetOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tat := \u0026v1alpha1.ApprovalTask{}","\terr = runtime.DefaultUnstructuredConverter.FromUnstructured(result.Object, at)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn at, nil","}","","func Update(gr schema.GroupVersionResource, c *cli.Clients, opts *cli.Options) error {","\tgvr, err := GetGroupVersionResource(gr, c.ApprovalTask.Discovery())","\tif err != nil {","\t\treturn err","\t}","","\tat, err := get(gvr, c, opts)","\tif err != nil {","\t\treturn err","\t}","","\tif !containsUsername(at.Spec.Approvers, opts) {","\t\treturn fmt.Errorf(\"approver: %s, is not present in the approvers list\", opts.Username)","\t}","","\tif err := update(gvr, c.Dynamic, at, opts); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func update(gvr *schema.GroupVersionResource, dynamic dynamic.Interface, at *v1alpha1.ApprovalTask, opts *cli.Options) error {","\t// Track if user has been processed as individual User type to avoid duplicate processing","\tuserProcessedAsIndividual := false","","\t// First pass: Process all User type approvers to ensure User type takes precedence","\tfor i, approver := range at.Spec.Approvers {","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"User\" \u0026\u0026 approver.Name == opts.Username {","\t\t\tat.Spec.Approvers[i].Input = opts.Input","\t\t\tif opts.Message != \"\" {","\t\t\t\tat.Spec.Approvers[i].Message = opts.Message","\t\t\t}","\t\t\tuserProcessedAsIndividual = true","\t\t}","\t}","","\t// Second pass: Process Group type approvers, but only add user to group if not already processed as individual","\tfor i, approver := range at.Spec.Approvers {","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\tfor _, groupName := range opts.Groups {","\t\t\t\tif approver.Name == groupName {","\t\t\t\t\tat.Spec.Approvers[i].Input = opts.Input","\t\t\t\t\tif opts.Message != \"\" {","\t\t\t\t\t\tat.Spec.Approvers[i].Message = opts.Message","\t\t\t\t\t}","","\t\t\t\t\t// Only add user to group members if they haven't been processed as individual User","\t\t\t\t\t// This prevents duplicate entries when user is both individual approver and group member","\t\t\t\t\tif !userProcessedAsIndividual {","\t\t\t\t\t\tuserExists := false","","\t\t\t\t\t\tfor j, existing := range at.Spec.Approvers[i].Users {","\t\t\t\t\t\t\tif existing.Name == opts.Username {","\t\t\t\t\t\t\t\tuserExists = true","\t\t\t\t\t\t\t\tif existing.Input != opts.Input {","\t\t\t\t\t\t\t\t\tat.Spec.Approvers[i].Users[j].Input = opts.Input","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\tif existing.Message != opts.Message {","\t\t\t\t\t\t\t\t\tat.Spec.Approvers[i].Users[j].Message = opts.Message","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t\tif !userExists {","\t\t\t\t\t\t\tnewUser := v1alpha1.UserDetails{","\t\t\t\t\t\t\t\tName:  opts.Username,","\t\t\t\t\t\t\t\tInput: opts.Input,","\t\t\t\t\t\t\t\tMessage: opts.Message,","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\tat.Spec.Approvers[i].Users = append(at.Spec.Approvers[i].Users, newUser)","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\tunstructuredMap, err := runtime.DefaultUnstructuredConverter.ToUnstructured(\u0026at)","\tif err != nil {","\t\tfmt.Printf(\"Error converting to unstructured: %v\\n\", err)","\t\treturn err","\t}","","\tunstrObj := \u0026unstructured.Unstructured{Object: unstructuredMap}","\t_, err = dynamic.Resource(*gvr).Namespace(opts.Namespace).Update(context.TODO(), unstrObj, metav1.UpdateOptions{})","\tif err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func GetGroupVersionResource(gr schema.GroupVersionResource, discovery discovery.DiscoveryInterface) (*schema.GroupVersionResource, error) {","\tvar err error","\tdoOnce.Do(func() {","\t\terr = InitializeAPIGroupRes(discovery)","\t})","\tif err != nil {","\t\treturn nil, err","\t}","","\trm := restmapper.NewDiscoveryRESTMapper(apiGroupRes)","\tgvr, err := rm.ResourceFor(gr)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn \u0026gvr, nil","}","","// InitializeAPIGroupRes initializes and populates the discovery client.","func InitializeAPIGroupRes(discovery discovery.DiscoveryInterface) error {","\tvar err error","\tapiGroupRes, err = restmapper.GetAPIGroupResources(discovery)","\tif err != nil {","\t\treturn err","\t}","\treturn nil","}","","func containsUsername(approvers []v1alpha1.ApproverDetails, user *cli.Options) bool {","\tfor _, approver := range approvers {","\t\tif approver.Name == user.Username {","\t\t\treturn true","\t\t}","\t}","","\tfor _, approval := range approvers {","\t\tswitch approval.Type {","\t\tcase \"User\":","\t\t\tif approval.Name == user.Username {","\t\t\t\treturn true","\t\t\t}","\t\tcase \"Group\":","\t\t\tfor _, groupName := range user.Groups {","\t\t\t\tif approval.Name == groupName {","\t\t\t\t\treturn true","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\treturn false","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0]},{"id":1,"path":"pkg/apis/approvaltask/v1alpha1/approvaltask_types.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"time\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/utils/clock\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// +genclient","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// ApprovalTask is a \"wait for manual approval\" Task.","// +k8s:openapi-gen=true","type ApprovalTask struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata\"`","","\t// Spec holds the desired state of the TaskGroup from the client","\t// +optional","\tSpec   ApprovalTaskSpec   `json:\"spec\"`","\tStatus ApprovalTaskStatus `json:\"status\"`","}","","type ApprovalTaskSpec struct {","\tApprovers                 []ApproverDetails `json:\"approvers\"`","\tNumberOfApprovalsRequired int               `json:\"numberOfApprovalsRequired\"`","\tDescription               string            `json:\"description,omitempty\"`","}","","type UserDetails struct {","\tName  string `json:\"name\"`","\tInput string `json:\"input\"`","\tMessage string `json:\"message,omitempty\"`","}","","type ApproverDetails struct {","\tName    string        `json:\"name\"`","\tInput   string        `json:\"input\"`","\tMessage string        `json:\"message,omitempty\"`","\tType    string        `json:\"type\"`","\tUsers   []UserDetails `json:\"users,omitempty\"`","}","","type ApprovalTaskStatus struct {","\tduckv1.Status     `json:\",inline\"`","\tState             string          `json:\"state\"`","\tApprovers         []string        `json:\"approvers,omitempty\"`","\tApproversResponse []ApproverState `json:\"approversResponse,omitempty\"`","\t// StartTime is the time the build is actually started.","\tStartTime *metav1.Time `json:\"startTime,omitempty\"`","\t// ApprovalsRequired is the number of approvals required for the task","\tApprovalsRequired int `json:\"approvalsRequired,omitempty\"`","\t// ApprovalsReceived is the number of approvals received so far","\tApprovalsReceived int `json:\"approvalsReceived,omitempty\"`","}","","type GroupMemberState struct {","\tName     string `json:\"name\"`","\tResponse string `json:\"response\"`","\tMessage  string `json:\"message,omitempty\"`","}","","type ApproverState struct {","\tName         string             `json:\"name\"`","\tResponse     string             `json:\"response\"`","\tMessage      string             `json:\"message,omitempty\"`","\tType         string             `json:\"type\"`","\tGroupMembers []GroupMemberState `json:\"groupMembers,omitempty\"`","}","","// DefaultedApproverType returns \"User\" if the type field is empty (for v0.6.0 compatibility),","// otherwise returns the provided type.","func DefaultedApproverType(approverType string) string {","\tif approverType == \"\" {","\t\treturn \"User\"","\t}","\treturn approverType","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// ApprovalTaskList contains a list of ApprovalTasks","type ApprovalTaskList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []ApprovalTask `json:\"items\"`","}","","// ApprovalTaskRunStatus contains the status stored in the ExtraFields of a Run that references a ApprovalTask.","type ApprovalTaskRunStatus struct {","\t// ApprovalTaskSpec contains the exact spec used to instantiate the Run","\t// FIXME(openshift-pipelines) can probably remove","\tApprovalTaskSpec *ApprovalTaskSpec `json:\"taskLoopSpec,omitempty\"`","\t// +optional","\t// TaskRun *v1beta1.TaskRunStatus `json:\"status,omitempty\"`","}","","// ApprovalTaskRunReason represents a reason for the Run \"Succeeded\" condition","type ApprovalTaskRunReason string","","const (","\t// ApprovalTaskRunReasonStarted is the reason set when the Run has just started","\tApprovalTaskRunReasonStarted ApprovalTaskRunReason = \"Started\"","","\t// ApprovalTaskRunReasonRunning indicates that the Run is in progress","\tApprovalTaskRunReasonRunning ApprovalTaskRunReason = \"Running\"","","\t// ApprovalTaskRunReasonFailed indicates that one of the TaskRuns created from the Run failed","\tApprovalTaskRunReasonFailed ApprovalTaskRunReason = \"Failed\"","","\t// ApprovalTaskRunReasonSucceeded indicates that all of the TaskRuns created from the Run completed successfully","\tApprovalTaskRunReasonSucceeded ApprovalTaskRunReason = \"Succeeded\"","","\t// ApprovalTaskRunReasonCouldntCancel indicates that a Run was cancelled but attempting to update","\t// the running TaskRun as cancelled failed.","\tApprovalTaskRunReasonCouldntCancel ApprovalTaskRunReason = \"ApprovalTaskRunCouldntCancel\"","","\t// ApprovalTaskRunReasonCouldntGetApprovalTask indicates that the associated ApprovalTask couldn't be retrieved","\tApprovalTaskRunReasonCouldntGetApprovalTask ApprovalTaskRunReason = \"CouldntGetApprovalTask\"","","\t// ApprovalTaskRunReasonFailedValidation indicates that the ApprovalTask failed runtime validation","\tApprovalTaskRunReasonFailedValidation ApprovalTaskRunReason = \"ApprovalTaskValidationFailed\"","","\t// ApprovalTaskRunReasonInternalError indicates that the ApprovalTask failed due to an internal error in the reconciler","\tApprovalTaskRunReasonInternalError ApprovalTaskRunReason = \"ApprovalTaskInternalError\"",")","","func (t ApprovalTaskRunReason) String() string {","\treturn string(t)","}","","func (at ApprovalTask) HasStarted() bool {","\treturn at.Status.StartTime != nil","}","","func (at ApprovalTask) ApprovalTaskHasTimedOut(ctx context.Context, c clock.PassiveClock, timeout time.Duration) bool {","\tif at.Status.StartTime.IsZero() {","\t\treturn false","\t}","\truntime := c.Since(at.Status.StartTime.Time)","","\treturn runtime \u003e timeout","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0]},{"id":2,"path":"pkg/apis/approvaltask/v1alpha1/approvaltask_validation.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\t\"knative.dev/pkg/apis\"",")","","var _ apis.Validatable = (*ApprovalTask)(nil)","","// Validate ApprovalTask","func (tg *ApprovalTask) Validate(ctx context.Context) *apis.FieldError {","\tif err := validate.ObjectMetadata(tg.GetObjectMeta()); err != nil {","\t\treturn err.ViaField(\"metadata\")","\t}","\treturn tg.Spec.Validate(ctx)","}","","// Validate ApprovalTaskSpec","func (tgs *ApprovalTaskSpec) Validate(ctx context.Context) (errs *apis.FieldError) {","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1]},{"id":3,"path":"pkg/apis/approvaltask/v1alpha1/register.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","const ManagedByLabelKey = \"app.kubernetes.io/managed-by\"","","// SchemeGroupVersion is group version used to register these objects","var SchemeGroupVersion = schema.GroupVersion{Group: approvaltask.GroupName, Version: \"v1alpha1\"}","","// Kind takes an unqualified kind and returns back a Group qualified GroupKind","func Kind(kind string) schema.GroupKind {","\treturn SchemeGroupVersion.WithKind(kind).GroupKind()","}","","// Resource takes an unqualified resource and returns a Group qualified GroupResource","func Resource(resource string) schema.GroupResource {","\treturn SchemeGroupVersion.WithResource(resource).GroupResource()","}","","var (","\tschemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)","","\t// AddToScheme adds Build types to the scheme.","\tAddToScheme = schemeBuilder.AddToScheme",")","","// Adds the list of known types to Scheme.","func addKnownTypes(scheme *runtime.Scheme) error {","\tscheme.AddKnownTypes(SchemeGroupVersion,","\t\t\u0026ApprovalTask{},","\t\t\u0026ApprovalTaskList{},","\t)","\tmetav1.AddToGroupVersion(scheme, SchemeGroupVersion)","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1]},{"id":4,"path":"pkg/cli/flags/flags.go","lines":["package flags","","import (","\tcli \"github.com/openshift-pipelines/manual-approval-gate/pkg/cli\"","\t\"github.com/spf13/cobra\"",")","","func AddOptions(cmd *cobra.Command) {","\tcmd.PersistentFlags().StringP(","\t\t\"namespace\", \"n\", \"\",","\t\t\"namespace to use (default: from $KUBECONFIG)\")","}","","func PersistentPreRunE(p cli.Params) func(*cobra.Command, []string) error {","\treturn func(cmd *cobra.Command, _ []string) error {","\t\treturn InitParams(p, cmd)","\t}","}","","func InitParams(p cli.Params, cmd *cobra.Command) error {","\tns, err := cmd.Flags().GetString(\"namespace\")","\tif err != nil {","\t\treturn err","\t}","\tif ns != \"\" {","\t\tp.SetNamespace(ns)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0]},{"id":5,"path":"pkg/cli/formatter/field.go","lines":["package formatter","","import (","\t\"github.com/fatih/color\"","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"",")","","var ConditionColor = map[string]color.Attribute{","\t\"Rejected\": color.FgHiRed,","\t\"Approved\": color.FgHiGreen,","\t\"Pending\":  color.FgHiYellow,","}","","func ColorStatus(status string) string {","\treturn color.New(ConditionColor[status]).Sprint(status)","}","","func State(at *v1alpha1.ApprovalTask) string {","\tvar state string","","\tswitch at.Status.State {","\tcase \"approved\":","\t\tstate = \"Approved\"","\tcase \"rejected\":","\t\tstate = \"Rejected\"","\tcase \"pending\":","\t\tstate = \"Pending\"","\t}","\treturn ColorStatus(state)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":6,"path":"pkg/cli/params.go","lines":["package cli","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned\"","\tuserv1typedclient \"github.com/openshift/client-go/user/clientset/versioned/typed/user/v1\"","\t\"github.com/pkg/errors\"","\tv1 \"k8s.io/api/authentication/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/dynamic\"","\tk8s \"k8s.io/client-go/kubernetes\"","\tauthenticationv1client \"k8s.io/client-go/kubernetes/typed/authentication/v1\"","\t\"k8s.io/client-go/rest\"","\t\"k8s.io/client-go/tools/clientcmd\"",")","","type Clients struct {","\tConfig       *rest.Config","\tKube         k8s.Interface","\tDynamic      dynamic.Interface","\tApprovalTask versioned.Interface","}","","type ApprovalTaskParams struct {","\tclients        *Clients","\tkubeConfigPath string","\tkubeContext    string","\tnamespace      string","}","","type Options struct {","\tNamespace     string","\tName          string","\tInput         string","\tUsername      string","\tMessage       string","\tAllNamespaces bool","\tGroups        []string","}","","type Params interface {","\t// SetKubeConfigPath uses the kubeconfig path to instantiate tekton","\t// returned by Clientset function","\tSetKubeConfigPath(string)","\t// SetKubeContext extends the specificity of the above SetKubeConfigPath","\t// by using a context other than the default context in the given kubeconfig","\tSetKubeContext(string)","\tSetNamespace(string)","\tKubeClient() (k8s.Interface, error)","\tClients(...*rest.Config) (*Clients, error)","\tNamespace() string","\tGetUserInfo() (string, []string, error)","}","","// ensure that TektonParams complies with cli.Params interface","var _ Params = (*ApprovalTaskParams)(nil)","","func (p *ApprovalTaskParams) SetKubeConfigPath(path string) {","\tp.kubeConfigPath = path","}","","func (p *ApprovalTaskParams) SetKubeContext(context string) {","\tp.kubeContext = context","}","","func (p *ApprovalTaskParams) Namespace() string {","\treturn p.namespace","}","","func (p *ApprovalTaskParams) GetUserInfo() (string, []string, error) {","\tauthV1Client, err := authenticationv1client.NewForConfig(p.clients.Config)","\tif err != nil {","\t\treturn \"\", []string{}, err","\t}","","\tuserInterface, err := userv1typedclient.NewForConfig(p.clients.Config)","\tif err != nil {","\t\treturn \"\", []string{}, err","\t}","","\t// Get username","\tusername, groups, err := getUserInfo(authV1Client, userInterface)","\tif err != nil {","\t\treturn \"\", []string{}, err","\t}","\treturn username, groups, err","}","","func (p *ApprovalTaskParams) SetNamespace(ns string) {","\tp.namespace = ns","}","","func (p *ApprovalTaskParams) kubeClient(config *rest.Config) (k8s.Interface, error) {","\tk8scs, err := k8s.NewForConfig(config)","\tif err != nil {","\t\treturn nil, errors.Wrapf(err, \"failed to create k8s client from config\")","\t}","","\treturn k8scs, nil","}","","func (p *ApprovalTaskParams) dynamicClient(config *rest.Config) (dynamic.Interface, error) {","\tdynamicClient, err := dynamic.NewForConfig(config)","\tif err != nil {","\t\treturn nil, errors.Wrapf(err, \"failed to create dynamic client from config\")","","\t}","\treturn dynamicClient, err","}","","func (p *ApprovalTaskParams) approvalTaskClient(config *rest.Config) (versioned.Interface, error) {","\tapprovalClient, err := versioned.NewForConfig(config)","\tif err != nil {","\t\treturn nil, errors.Wrapf(err, \"failed to create dynamic client from config\")","","\t}","\treturn approvalClient, err","}","","func (p *ApprovalTaskParams) config() (*rest.Config, error) {","","\tloadingRules := clientcmd.NewDefaultClientConfigLoadingRules()","\tif p.kubeConfigPath != \"\" {","\t\tloadingRules.ExplicitPath = p.kubeConfigPath","\t}","\tconfigOverrides := \u0026clientcmd.ConfigOverrides{}","\tif p.kubeContext != \"\" {","\t\tconfigOverrides.CurrentContext = p.kubeContext","\t}","","\tkubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)","\tif p.namespace == \"\" {","\t\tnamespace, _, err := kubeConfig.Namespace()","\t\tif err != nil {","\t\t\treturn nil, errors.Wrap(err, \"Couldn't get kubeConfiguration namespace\")","\t\t}","\t\tp.namespace = namespace","\t}","\tconfig, err := kubeConfig.ClientConfig()","\tif err != nil {","\t\treturn nil, errors.Wrap(err, \"Parsing kubeconfig failed\")","\t}","","\t// set values as done in kubectl","\tconfig.QPS = 50.0","\tconfig.Burst = 300","","\treturn config, nil","}","","// Only returns kube client, not tekton client","func (p *ApprovalTaskParams) KubeClient() (k8s.Interface, error) {","\tconfig, err := p.config()","\tif err != nil {","\t\treturn nil, err","\t}","","\tkube, err := p.kubeClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn kube, nil","}","","func (p *ApprovalTaskParams) Clients(cfg ...*rest.Config) (*Clients, error) {","\tvar config *rest.Config","","\tif len(cfg) != 0 \u0026\u0026 cfg[0] != nil {","\t\tconfig = cfg[0]","\t} else {","\t\tdefaultConfig, err := p.config()","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tconfig = defaultConfig","\t}","","\tkube, err := p.kubeClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\tdynamicClient, err := p.dynamicClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\tapprovalClient, err := p.approvalTaskClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\tp.clients = \u0026Clients{","\t\tConfig:       config,","\t\tKube:         kube,","\t\tApprovalTask: approvalClient,","\t\tDynamic:      dynamicClient,","\t}","","\treturn p.clients, nil","}","","func getUserInfo(authV1Client *authenticationv1client.AuthenticationV1Client, userInterface userv1typedclient.UserV1Interface) (string, []string, error) {","\tvar username string","\tres, err := authV1Client.SelfSubjectReviews().Create(context.TODO(), \u0026v1.SelfSubjectReview{}, metav1.CreateOptions{})","\tif err == nil {","\t\tusername = res.Status.UserInfo.Username","\t\treturn username, res.Status.UserInfo.Groups, nil","\t} else {","\t\tfmt.Errorf(\"selfsubjectreview request error %v, falling back to user object\", err)","\t}","","\tuser, err := userInterface.Users().Get(context.TODO(), \"~\", metav1.GetOptions{})","\tif err != nil {","\t\treturn \"\", []string{}, nil","\t}","\tusername = user.Name","","\treturn username, user.Groups, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0]},{"id":7,"path":"pkg/client/clientset/versioned/clientset.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package versioned","","import (","\tfmt \"fmt\"","\thttp \"net/http\"","","\topenshiftpipelinesv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1\"","\tdiscovery \"k8s.io/client-go/discovery\"","\trest \"k8s.io/client-go/rest\"","\tflowcontrol \"k8s.io/client-go/util/flowcontrol\"",")","","type Interface interface {","\tDiscovery() discovery.DiscoveryInterface","\tOpenshiftpipelinesV1alpha1() openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Interface","}","","// Clientset contains the clients for groups.","type Clientset struct {","\t*discovery.DiscoveryClient","\topenshiftpipelinesV1alpha1 *openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Client","}","","// OpenshiftpipelinesV1alpha1 retrieves the OpenshiftpipelinesV1alpha1Client","func (c *Clientset) OpenshiftpipelinesV1alpha1() openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Interface {","\treturn c.openshiftpipelinesV1alpha1","}","","// Discovery retrieves the DiscoveryClient","func (c *Clientset) Discovery() discovery.DiscoveryInterface {","\tif c == nil {","\t\treturn nil","\t}","\treturn c.DiscoveryClient","}","","// NewForConfig creates a new Clientset for the given config.","// If config's RateLimiter is not set and QPS and Burst are acceptable,","// NewForConfig will generate a rate-limiter in configShallowCopy.","// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),","// where httpClient was generated with rest.HTTPClientFor(c).","func NewForConfig(c *rest.Config) (*Clientset, error) {","\tconfigShallowCopy := *c","","\tif configShallowCopy.UserAgent == \"\" {","\t\tconfigShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()","\t}","","\t// share the transport between all clients","\thttpClient, err := rest.HTTPClientFor(\u0026configShallowCopy)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn NewForConfigAndClient(\u0026configShallowCopy, httpClient)","}","","// NewForConfigAndClient creates a new Clientset for the given config and http client.","// Note the http client provided takes precedence over the configured transport values.","// If config's RateLimiter is not set and QPS and Burst are acceptable,","// NewForConfigAndClient will generate a rate-limiter in configShallowCopy.","func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) {","\tconfigShallowCopy := *c","\tif configShallowCopy.RateLimiter == nil \u0026\u0026 configShallowCopy.QPS \u003e 0 {","\t\tif configShallowCopy.Burst \u003c= 0 {","\t\t\treturn nil, fmt.Errorf(\"burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0\")","\t\t}","\t\tconfigShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)","\t}","","\tvar cs Clientset","\tvar err error","\tcs.openshiftpipelinesV1alpha1, err = openshiftpipelinesv1alpha1.NewForConfigAndClient(\u0026configShallowCopy, httpClient)","\tif err != nil {","\t\treturn nil, err","\t}","","\tcs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfigAndClient(\u0026configShallowCopy, httpClient)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn \u0026cs, nil","}","","// NewForConfigOrDie creates a new Clientset for the given config and","// panics if there is an error in the config.","func NewForConfigOrDie(c *rest.Config) *Clientset {","\tcs, err := NewForConfig(c)","\tif err != nil {","\t\tpanic(err)","\t}","\treturn cs","}","","// New creates a new Clientset for the given RESTClient.","func New(c rest.Interface) *Clientset {","\tvar cs Clientset","\tcs.openshiftpipelinesV1alpha1 = openshiftpipelinesv1alpha1.New(c)","","\tcs.DiscoveryClient = discovery.NewDiscoveryClient(c)","\treturn \u0026cs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1]},{"id":8,"path":"pkg/client/clientset/versioned/fake/clientset_generated.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package fake","","import (","\tclientset \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned\"","\topenshiftpipelinesv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1\"","\tfakeopenshiftpipelinesv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/fake\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/watch\"","\t\"k8s.io/client-go/discovery\"","\tfakediscovery \"k8s.io/client-go/discovery/fake\"","\t\"k8s.io/client-go/testing\"",")","","// NewSimpleClientset returns a clientset that will respond with the provided objects.","// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,","// without applying any field management, validations and/or defaults. It shouldn't be considered a replacement","// for a real clientset and is mostly useful in simple unit tests.","//","// DEPRECATED: NewClientset replaces this with support for field management, which significantly improves","// server side apply testing. NewClientset is only available when apply configurations are generated (e.g.","// via --with-applyconfig).","func NewSimpleClientset(objects ...runtime.Object) *Clientset {","\to := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())","\tfor _, obj := range objects {","\t\tif err := o.Add(obj); err != nil {","\t\t\tpanic(err)","\t\t}","\t}","","\tcs := \u0026Clientset{tracker: o}","\tcs.discovery = \u0026fakediscovery.FakeDiscovery{Fake: \u0026cs.Fake}","\tcs.AddReactor(\"*\", \"*\", testing.ObjectReaction(o))","\tcs.AddWatchReactor(\"*\", func(action testing.Action) (handled bool, ret watch.Interface, err error) {","\t\tgvr := action.GetResource()","\t\tns := action.GetNamespace()","\t\twatch, err := o.Watch(gvr, ns)","\t\tif err != nil {","\t\t\treturn false, nil, err","\t\t}","\t\treturn true, watch, nil","\t})","","\treturn cs","}","","// Clientset implements clientset.Interface. Meant to be embedded into a","// struct to get a default implementation. This makes faking out just the method","// you want to test easier.","type Clientset struct {","\ttesting.Fake","\tdiscovery *fakediscovery.FakeDiscovery","\ttracker   testing.ObjectTracker","}","","func (c *Clientset) Discovery() discovery.DiscoveryInterface {","\treturn c.discovery","}","","func (c *Clientset) Tracker() testing.ObjectTracker {","\treturn c.tracker","}","","var (","\t_ clientset.Interface = \u0026Clientset{}","\t_ testing.FakeClient  = \u0026Clientset{}",")","","// OpenshiftpipelinesV1alpha1 retrieves the OpenshiftpipelinesV1alpha1Client","func (c *Clientset) OpenshiftpipelinesV1alpha1() openshiftpipelinesv1alpha1.OpenshiftpipelinesV1alpha1Interface {","\treturn \u0026fakeopenshiftpipelinesv1alpha1.FakeOpenshiftpipelinesV1alpha1{Fake: \u0026c.Fake}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1]},{"id":9,"path":"pkg/client/clientset/versioned/fake/register.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package fake","","import (","\topenshiftpipelinesv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\truntime \"k8s.io/apimachinery/pkg/runtime\"","\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"","\tserializer \"k8s.io/apimachinery/pkg/runtime/serializer\"","\tutilruntime \"k8s.io/apimachinery/pkg/util/runtime\"",")","","var scheme = runtime.NewScheme()","var codecs = serializer.NewCodecFactory(scheme)","","var localSchemeBuilder = runtime.SchemeBuilder{","\topenshiftpipelinesv1alpha1.AddToScheme,","}","","// AddToScheme adds all types of this clientset into the given scheme. This allows composition","// of clientsets, like in:","//","//\timport (","//\t  \"k8s.io/client-go/kubernetes\"","//\t  clientsetscheme \"k8s.io/client-go/kubernetes/scheme\"","//\t  aggregatorclientsetscheme \"k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme\"","//\t)","//","//\tkclientset, _ := kubernetes.NewForConfig(c)","//\t_ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)","//","// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types","// correctly.","var AddToScheme = localSchemeBuilder.AddToScheme","","func init() {","\tv1.AddToGroupVersion(scheme, schema.GroupVersion{Version: \"v1\"})","\tutilruntime.Must(AddToScheme(scheme))","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1]},{"id":10,"path":"pkg/client/clientset/versioned/scheme/register.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package scheme","","import (","\topenshiftpipelinesv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\truntime \"k8s.io/apimachinery/pkg/runtime\"","\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"","\tserializer \"k8s.io/apimachinery/pkg/runtime/serializer\"","\tutilruntime \"k8s.io/apimachinery/pkg/util/runtime\"",")","","var Scheme = runtime.NewScheme()","var Codecs = serializer.NewCodecFactory(Scheme)","var ParameterCodec = runtime.NewParameterCodec(Scheme)","var localSchemeBuilder = runtime.SchemeBuilder{","\topenshiftpipelinesv1alpha1.AddToScheme,","}","","// AddToScheme adds all types of this clientset into the given scheme. This allows composition","// of clientsets, like in:","//","//\timport (","//\t  \"k8s.io/client-go/kubernetes\"","//\t  clientsetscheme \"k8s.io/client-go/kubernetes/scheme\"","//\t  aggregatorclientsetscheme \"k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme\"","//\t)","//","//\tkclientset, _ := kubernetes.NewForConfig(c)","//\t_ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)","//","// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types","// correctly.","var AddToScheme = localSchemeBuilder.AddToScheme","","func init() {","\tv1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: \"v1\"})","\tutilruntime.Must(AddToScheme(Scheme))","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1]},{"id":11,"path":"pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/approvaltask.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package v1alpha1","","import (","\tcontext \"context\"","","\tapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tscheme \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/scheme\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\ttypes \"k8s.io/apimachinery/pkg/types\"","\twatch \"k8s.io/apimachinery/pkg/watch\"","\tgentype \"k8s.io/client-go/gentype\"",")","","// ApprovalTasksGetter has a method to return a ApprovalTaskInterface.","// A group's client should implement this interface.","type ApprovalTasksGetter interface {","\tApprovalTasks(namespace string) ApprovalTaskInterface","}","","// ApprovalTaskInterface has methods to work with ApprovalTask resources.","type ApprovalTaskInterface interface {","\tCreate(ctx context.Context, approvalTask *approvaltaskv1alpha1.ApprovalTask, opts v1.CreateOptions) (*approvaltaskv1alpha1.ApprovalTask, error)","\tUpdate(ctx context.Context, approvalTask *approvaltaskv1alpha1.ApprovalTask, opts v1.UpdateOptions) (*approvaltaskv1alpha1.ApprovalTask, error)","\t// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().","\tUpdateStatus(ctx context.Context, approvalTask *approvaltaskv1alpha1.ApprovalTask, opts v1.UpdateOptions) (*approvaltaskv1alpha1.ApprovalTask, error)","\tDelete(ctx context.Context, name string, opts v1.DeleteOptions) error","\tDeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error","\tGet(ctx context.Context, name string, opts v1.GetOptions) (*approvaltaskv1alpha1.ApprovalTask, error)","\tList(ctx context.Context, opts v1.ListOptions) (*approvaltaskv1alpha1.ApprovalTaskList, error)","\tWatch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)","\tPatch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *approvaltaskv1alpha1.ApprovalTask, err error)","\tApprovalTaskExpansion","}","","// approvalTasks implements ApprovalTaskInterface","type approvalTasks struct {","\t*gentype.ClientWithList[*approvaltaskv1alpha1.ApprovalTask, *approvaltaskv1alpha1.ApprovalTaskList]","}","","// newApprovalTasks returns a ApprovalTasks","func newApprovalTasks(c *OpenshiftpipelinesV1alpha1Client, namespace string) *approvalTasks {","\treturn \u0026approvalTasks{","\t\tgentype.NewClientWithList[*approvaltaskv1alpha1.ApprovalTask, *approvaltaskv1alpha1.ApprovalTaskList](","\t\t\t\"approvaltasks\",","\t\t\tc.RESTClient(),","\t\t\tscheme.ParameterCodec,","\t\t\tnamespace,","\t\t\tfunc() *approvaltaskv1alpha1.ApprovalTask { return \u0026approvaltaskv1alpha1.ApprovalTask{} },","\t\t\tfunc() *approvaltaskv1alpha1.ApprovalTaskList { return \u0026approvaltaskv1alpha1.ApprovalTaskList{} },","\t\t),","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0]},{"id":12,"path":"pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/approvaltask_client.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package v1alpha1","","import (","\thttp \"net/http\"","","\tapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tscheme \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/scheme\"","\trest \"k8s.io/client-go/rest\"",")","","type OpenshiftpipelinesV1alpha1Interface interface {","\tRESTClient() rest.Interface","\tApprovalTasksGetter","}","","// OpenshiftpipelinesV1alpha1Client is used to interact with features provided by the openshiftpipelines.org group.","type OpenshiftpipelinesV1alpha1Client struct {","\trestClient rest.Interface","}","","func (c *OpenshiftpipelinesV1alpha1Client) ApprovalTasks(namespace string) ApprovalTaskInterface {","\treturn newApprovalTasks(c, namespace)","}","","// NewForConfig creates a new OpenshiftpipelinesV1alpha1Client for the given config.","// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),","// where httpClient was generated with rest.HTTPClientFor(c).","func NewForConfig(c *rest.Config) (*OpenshiftpipelinesV1alpha1Client, error) {","\tconfig := *c","\tif err := setConfigDefaults(\u0026config); err != nil {","\t\treturn nil, err","\t}","\thttpClient, err := rest.HTTPClientFor(\u0026config)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn NewForConfigAndClient(\u0026config, httpClient)","}","","// NewForConfigAndClient creates a new OpenshiftpipelinesV1alpha1Client for the given config and http client.","// Note the http client provided takes precedence over the configured transport values.","func NewForConfigAndClient(c *rest.Config, h *http.Client) (*OpenshiftpipelinesV1alpha1Client, error) {","\tconfig := *c","\tif err := setConfigDefaults(\u0026config); err != nil {","\t\treturn nil, err","\t}","\tclient, err := rest.RESTClientForConfigAndClient(\u0026config, h)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn \u0026OpenshiftpipelinesV1alpha1Client{client}, nil","}","","// NewForConfigOrDie creates a new OpenshiftpipelinesV1alpha1Client for the given config and","// panics if there is an error in the config.","func NewForConfigOrDie(c *rest.Config) *OpenshiftpipelinesV1alpha1Client {","\tclient, err := NewForConfig(c)","\tif err != nil {","\t\tpanic(err)","\t}","\treturn client","}","","// New creates a new OpenshiftpipelinesV1alpha1Client for the given RESTClient.","func New(c rest.Interface) *OpenshiftpipelinesV1alpha1Client {","\treturn \u0026OpenshiftpipelinesV1alpha1Client{c}","}","","func setConfigDefaults(config *rest.Config) error {","\tgv := approvaltaskv1alpha1.SchemeGroupVersion","\tconfig.GroupVersion = \u0026gv","\tconfig.APIPath = \"/apis\"","\tconfig.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()","","\tif config.UserAgent == \"\" {","\t\tconfig.UserAgent = rest.DefaultKubernetesUserAgent()","\t}","","\treturn nil","}","","// RESTClient returns a RESTClient that is used to communicate","// with API server by this client implementation.","func (c *OpenshiftpipelinesV1alpha1Client) RESTClient() rest.Interface {","\tif c == nil {","\t\treturn nil","\t}","\treturn c.restClient","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0]},{"id":13,"path":"pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/fake/fake_approvaltask.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package fake","","import (","\tv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1\"","\tgentype \"k8s.io/client-go/gentype\"",")","","// fakeApprovalTasks implements ApprovalTaskInterface","type fakeApprovalTasks struct {","\t*gentype.FakeClientWithList[*v1alpha1.ApprovalTask, *v1alpha1.ApprovalTaskList]","\tFake *FakeOpenshiftpipelinesV1alpha1","}","","func newFakeApprovalTasks(fake *FakeOpenshiftpipelinesV1alpha1, namespace string) approvaltaskv1alpha1.ApprovalTaskInterface {","\treturn \u0026fakeApprovalTasks{","\t\tgentype.NewFakeClientWithList[*v1alpha1.ApprovalTask, *v1alpha1.ApprovalTaskList](","\t\t\tfake.Fake,","\t\t\tnamespace,","\t\t\tv1alpha1.SchemeGroupVersion.WithResource(\"approvaltasks\"),","\t\t\tv1alpha1.SchemeGroupVersion.WithKind(\"ApprovalTask\"),","\t\t\tfunc() *v1alpha1.ApprovalTask { return \u0026v1alpha1.ApprovalTask{} },","\t\t\tfunc() *v1alpha1.ApprovalTaskList { return \u0026v1alpha1.ApprovalTaskList{} },","\t\t\tfunc(dst, src *v1alpha1.ApprovalTaskList) { dst.ListMeta = src.ListMeta },","\t\t\tfunc(list *v1alpha1.ApprovalTaskList) []*v1alpha1.ApprovalTask {","\t\t\t\treturn gentype.ToPointerSlice(list.Items)","\t\t\t},","\t\t\tfunc(list *v1alpha1.ApprovalTaskList, items []*v1alpha1.ApprovalTask) {","\t\t\t\tlist.Items = gentype.FromPointerSlice(items)","\t\t\t},","\t\t),","\t\tfake,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0]},{"id":14,"path":"pkg/client/clientset/versioned/typed/approvaltask/v1alpha1/fake/fake_approvaltask_client.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by client-gen. DO NOT EDIT.","","package fake","","import (","\tv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/typed/approvaltask/v1alpha1\"","\trest \"k8s.io/client-go/rest\"","\ttesting \"k8s.io/client-go/testing\"",")","","type FakeOpenshiftpipelinesV1alpha1 struct {","\t*testing.Fake","}","","func (c *FakeOpenshiftpipelinesV1alpha1) ApprovalTasks(namespace string) v1alpha1.ApprovalTaskInterface {","\treturn newFakeApprovalTasks(c, namespace)","}","","// RESTClient returns a RESTClient that is used to communicate","// with API server by this client implementation.","func (c *FakeOpenshiftpipelinesV1alpha1) RESTClient() rest.Interface {","\tvar ret *rest.RESTClient","\treturn ret","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1]},{"id":15,"path":"pkg/client/informers/externalversions/approvaltask/interface.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by informer-gen. DO NOT EDIT.","","package approvaltask","","import (","\tv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1\"","\tinternalinterfaces \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces\"",")","","// Interface provides access to each of this group's versions.","type Interface interface {","\t// V1alpha1 provides access to shared informers for resources in V1alpha1.","\tV1alpha1() v1alpha1.Interface","}","","type group struct {","\tfactory          internalinterfaces.SharedInformerFactory","\tnamespace        string","\ttweakListOptions internalinterfaces.TweakListOptionsFunc","}","","// New returns a new Interface.","func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface {","\treturn \u0026group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}","}","","// V1alpha1 returns a new v1alpha1.Interface.","func (g *group) V1alpha1() v1alpha1.Interface {","\treturn v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1]},{"id":16,"path":"pkg/client/informers/externalversions/approvaltask/v1alpha1/approvaltask.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by informer-gen. DO NOT EDIT.","","package v1alpha1","","import (","\tcontext \"context\"","\ttime \"time\"","","\tapisapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tversioned \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned\"","\tinternalinterfaces \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces\"","\tapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/listers/approvaltask/v1alpha1\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\truntime \"k8s.io/apimachinery/pkg/runtime\"","\twatch \"k8s.io/apimachinery/pkg/watch\"","\tcache \"k8s.io/client-go/tools/cache\"",")","","// ApprovalTaskInformer provides access to a shared informer and lister for","// ApprovalTasks.","type ApprovalTaskInformer interface {","\tInformer() cache.SharedIndexInformer","\tLister() approvaltaskv1alpha1.ApprovalTaskLister","}","","type approvalTaskInformer struct {","\tfactory          internalinterfaces.SharedInformerFactory","\ttweakListOptions internalinterfaces.TweakListOptionsFunc","\tnamespace        string","}","","// NewApprovalTaskInformer constructs a new informer for ApprovalTask type.","// Always prefer using an informer factory to get a shared informer instead of getting an independent","// one. This reduces memory footprint and number of connections to the server.","func NewApprovalTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer {","\treturn NewFilteredApprovalTaskInformer(client, namespace, resyncPeriod, indexers, nil)","}","","// NewFilteredApprovalTaskInformer constructs a new informer for ApprovalTask type.","// Always prefer using an informer factory to get a shared informer instead of getting an independent","// one. This reduces memory footprint and number of connections to the server.","func NewFilteredApprovalTaskInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer {","\treturn cache.NewSharedIndexInformer(","\t\t\u0026cache.ListWatch{","\t\t\tListFunc: func(options v1.ListOptions) (runtime.Object, error) {","\t\t\t\tif tweakListOptions != nil {","\t\t\t\t\ttweakListOptions(\u0026options)","\t\t\t\t}","\t\t\t\treturn client.OpenshiftpipelinesV1alpha1().ApprovalTasks(namespace).List(context.TODO(), options)","\t\t\t},","\t\t\tWatchFunc: func(options v1.ListOptions) (watch.Interface, error) {","\t\t\t\tif tweakListOptions != nil {","\t\t\t\t\ttweakListOptions(\u0026options)","\t\t\t\t}","\t\t\t\treturn client.OpenshiftpipelinesV1alpha1().ApprovalTasks(namespace).Watch(context.TODO(), options)","\t\t\t},","\t\t},","\t\t\u0026apisapprovaltaskv1alpha1.ApprovalTask{},","\t\tresyncPeriod,","\t\tindexers,","\t)","}","","func (f *approvalTaskInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer {","\treturn NewFilteredApprovalTaskInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)","}","","func (f *approvalTaskInformer) Informer() cache.SharedIndexInformer {","\treturn f.factory.InformerFor(\u0026apisapprovaltaskv1alpha1.ApprovalTask{}, f.defaultInformer)","}","","func (f *approvalTaskInformer) Lister() approvaltaskv1alpha1.ApprovalTaskLister {","\treturn approvaltaskv1alpha1.NewApprovalTaskLister(f.Informer().GetIndexer())","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1]},{"id":17,"path":"pkg/client/informers/externalversions/approvaltask/v1alpha1/interface.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by informer-gen. DO NOT EDIT.","","package v1alpha1","","import (","\tinternalinterfaces \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces\"",")","","// Interface provides access to all the informers in this group version.","type Interface interface {","\t// ApprovalTasks returns a ApprovalTaskInformer.","\tApprovalTasks() ApprovalTaskInformer","}","","type version struct {","\tfactory          internalinterfaces.SharedInformerFactory","\tnamespace        string","\ttweakListOptions internalinterfaces.TweakListOptionsFunc","}","","// New returns a new Interface.","func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface {","\treturn \u0026version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}","}","","// ApprovalTasks returns a ApprovalTaskInformer.","func (v *version) ApprovalTasks() ApprovalTaskInformer {","\treturn \u0026approvalTaskInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1]},{"id":18,"path":"pkg/client/informers/externalversions/factory.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by informer-gen. DO NOT EDIT.","","package externalversions","","import (","\treflect \"reflect\"","\tsync \"sync\"","\ttime \"time\"","","\tversioned \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned\"","\tapprovaltask \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask\"","\tinternalinterfaces \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/internalinterfaces\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\truntime \"k8s.io/apimachinery/pkg/runtime\"","\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"","\tcache \"k8s.io/client-go/tools/cache\"",")","","// SharedInformerOption defines the functional option type for SharedInformerFactory.","type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory","","type sharedInformerFactory struct {","\tclient           versioned.Interface","\tnamespace        string","\ttweakListOptions internalinterfaces.TweakListOptionsFunc","\tlock             sync.Mutex","\tdefaultResync    time.Duration","\tcustomResync     map[reflect.Type]time.Duration","\ttransform        cache.TransformFunc","","\tinformers map[reflect.Type]cache.SharedIndexInformer","\t// startedInformers is used for tracking which informers have been started.","\t// This allows Start() to be called multiple times safely.","\tstartedInformers map[reflect.Type]bool","\t// wg tracks how many goroutines were started.","\twg sync.WaitGroup","\t// shuttingDown is true when Shutdown has been called. It may still be running","\t// because it needs to wait for goroutines.","\tshuttingDown bool","}","","// WithCustomResyncConfig sets a custom resync period for the specified informer types.","func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption {","\treturn func(factory *sharedInformerFactory) *sharedInformerFactory {","\t\tfor k, v := range resyncConfig {","\t\t\tfactory.customResync[reflect.TypeOf(k)] = v","\t\t}","\t\treturn factory","\t}","}","","// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.","func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption {","\treturn func(factory *sharedInformerFactory) *sharedInformerFactory {","\t\tfactory.tweakListOptions = tweakListOptions","\t\treturn factory","\t}","}","","// WithNamespace limits the SharedInformerFactory to the specified namespace.","func WithNamespace(namespace string) SharedInformerOption {","\treturn func(factory *sharedInformerFactory) *sharedInformerFactory {","\t\tfactory.namespace = namespace","\t\treturn factory","\t}","}","","// WithTransform sets a transform on all informers.","func WithTransform(transform cache.TransformFunc) SharedInformerOption {","\treturn func(factory *sharedInformerFactory) *sharedInformerFactory {","\t\tfactory.transform = transform","\t\treturn factory","\t}","}","","// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.","func NewSharedInformerFactory(client versioned.Interface, defaultResync time.Duration) SharedInformerFactory {","\treturn NewSharedInformerFactoryWithOptions(client, defaultResync)","}","","// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.","// Listers obtained via this SharedInformerFactory will be subject to the same filters","// as specified here.","// Deprecated: Please use NewSharedInformerFactoryWithOptions instead","func NewFilteredSharedInformerFactory(client versioned.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory {","\treturn NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))","}","","// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.","func NewSharedInformerFactoryWithOptions(client versioned.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory {","\tfactory := \u0026sharedInformerFactory{","\t\tclient:           client,","\t\tnamespace:        v1.NamespaceAll,","\t\tdefaultResync:    defaultResync,","\t\tinformers:        make(map[reflect.Type]cache.SharedIndexInformer),","\t\tstartedInformers: make(map[reflect.Type]bool),","\t\tcustomResync:     make(map[reflect.Type]time.Duration),","\t}","","\t// Apply all options","\tfor _, opt := range options {","\t\tfactory = opt(factory)","\t}","","\treturn factory","}","","func (f *sharedInformerFactory) Start(stopCh \u003c-chan struct{}) {","\tf.lock.Lock()","\tdefer f.lock.Unlock()","","\tif f.shuttingDown {","\t\treturn","\t}","","\tfor informerType, informer := range f.informers {","\t\tif !f.startedInformers[informerType] {","\t\t\tf.wg.Add(1)","\t\t\t// We need a new variable in each loop iteration,","\t\t\t// otherwise the goroutine would use the loop variable","\t\t\t// and that keeps changing.","\t\t\tinformer := informer","\t\t\tgo func() {","\t\t\t\tdefer f.wg.Done()","\t\t\t\tinformer.Run(stopCh)","\t\t\t}()","\t\t\tf.startedInformers[informerType] = true","\t\t}","\t}","}","","func (f *sharedInformerFactory) Shutdown() {","\tf.lock.Lock()","\tf.shuttingDown = true","\tf.lock.Unlock()","","\t// Will return immediately if there is nothing to wait for.","\tf.wg.Wait()","}","","func (f *sharedInformerFactory) WaitForCacheSync(stopCh \u003c-chan struct{}) map[reflect.Type]bool {","\tinformers := func() map[reflect.Type]cache.SharedIndexInformer {","\t\tf.lock.Lock()","\t\tdefer f.lock.Unlock()","","\t\tinformers := map[reflect.Type]cache.SharedIndexInformer{}","\t\tfor informerType, informer := range f.informers {","\t\t\tif f.startedInformers[informerType] {","\t\t\t\tinformers[informerType] = informer","\t\t\t}","\t\t}","\t\treturn informers","\t}()","","\tres := map[reflect.Type]bool{}","\tfor informType, informer := range informers {","\t\tres[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)","\t}","\treturn res","}","","// InformerFor returns the SharedIndexInformer for obj using an internal","// client.","func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer {","\tf.lock.Lock()","\tdefer f.lock.Unlock()","","\tinformerType := reflect.TypeOf(obj)","\tinformer, exists := f.informers[informerType]","\tif exists {","\t\treturn informer","\t}","","\tresyncPeriod, exists := f.customResync[informerType]","\tif !exists {","\t\tresyncPeriod = f.defaultResync","\t}","","\tinformer = newFunc(f.client, resyncPeriod)","\tinformer.SetTransform(f.transform)","\tf.informers[informerType] = informer","","\treturn informer","}","","// SharedInformerFactory provides shared informers for resources in all known","// API group versions.","//","// It is typically used like this:","//","//\tctx, cancel := context.Background()","//\tdefer cancel()","//\tfactory := NewSharedInformerFactory(client, resyncPeriod)","//\tdefer factory.WaitForStop()    // Returns immediately if nothing was started.","//\tgenericInformer := factory.ForResource(resource)","//\ttypedInformer := factory.SomeAPIGroup().V1().SomeType()","//\tfactory.Start(ctx.Done())          // Start processing these informers.","//\tsynced := factory.WaitForCacheSync(ctx.Done())","//\tfor v, ok := range synced {","//\t    if !ok {","//\t        fmt.Fprintf(os.Stderr, \"caches failed to sync: %v\", v)","//\t        return","//\t    }","//\t}","//","//\t// Creating informers can also be created after Start, but then","//\t// Start must be called again:","//\tanotherGenericInformer := factory.ForResource(resource)","//\tfactory.Start(ctx.Done())","type SharedInformerFactory interface {","\tinternalinterfaces.SharedInformerFactory","","\t// Start initializes all requested informers. They are handled in goroutines","\t// which run until the stop channel gets closed.","\t// Warning: Start does not block. When run in a go-routine, it will race with a later WaitForCacheSync.","\tStart(stopCh \u003c-chan struct{})","","\t// Shutdown marks a factory as shutting down. At that point no new","\t// informers can be started anymore and Start will return without","\t// doing anything.","\t//","\t// In addition, Shutdown blocks until all goroutines have terminated. For that","\t// to happen, the close channel(s) that they were started with must be closed,","\t// either before Shutdown gets called or while it is waiting.","\t//","\t// Shutdown may be called multiple times, even concurrently. All such calls will","\t// block until all goroutines have terminated.","\tShutdown()","","\t// WaitForCacheSync blocks until all started informers' caches were synced","\t// or the stop channel gets closed.","\tWaitForCacheSync(stopCh \u003c-chan struct{}) map[reflect.Type]bool","","\t// ForResource gives generic access to a shared informer of the matching type.","\tForResource(resource schema.GroupVersionResource) (GenericInformer, error)","","\t// InformerFor returns the SharedIndexInformer for obj using an internal","\t// client.","\tInformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer","","\tOpenshiftpipelines() approvaltask.Interface","}","","func (f *sharedInformerFactory) Openshiftpipelines() approvaltask.Interface {","\treturn approvaltask.New(f, f.namespace, f.tweakListOptions)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":19,"path":"pkg/client/informers/externalversions/generic.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by informer-gen. DO NOT EDIT.","","package externalversions","","import (","\tfmt \"fmt\"","","\tv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"","\tcache \"k8s.io/client-go/tools/cache\"",")","","// GenericInformer is type of SharedIndexInformer which will locate and delegate to other","// sharedInformers based on type","type GenericInformer interface {","\tInformer() cache.SharedIndexInformer","\tLister() cache.GenericLister","}","","type genericInformer struct {","\tinformer cache.SharedIndexInformer","\tresource schema.GroupResource","}","","// Informer returns the SharedIndexInformer.","func (f *genericInformer) Informer() cache.SharedIndexInformer {","\treturn f.informer","}","","// Lister returns the GenericLister.","func (f *genericInformer) Lister() cache.GenericLister {","\treturn cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)","}","","// ForResource gives generic access to a shared informer of the matching type","// TODO extend this to unknown resources with a client pool","func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) {","\tswitch resource {","\t// Group=openshiftpipelines.org, Version=v1alpha1","\tcase v1alpha1.SchemeGroupVersion.WithResource(\"approvaltasks\"):","\t\treturn \u0026genericInformer{resource: resource.GroupResource(), informer: f.Openshiftpipelines().V1alpha1().ApprovalTasks().Informer()}, nil","","\t}","","\treturn nil, fmt.Errorf(\"no informer found for %v\", resource)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,1,1,0,1,1,0,0,0,1,0]},{"id":20,"path":"pkg/client/injection/client/client.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package client","","import (","\tcontext \"context\"","","\tversioned \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned\"","\trest \"k8s.io/client-go/rest\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Default.RegisterClient(withClientFromConfig)","\tinjection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} {","\t\treturn Get(ctx)","\t})","}","","// Key is used as the key for associating information with a context.Context.","type Key struct{}","","func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context {","\treturn context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))","}","","// Get extracts the versioned.Interface client from the context.","func Get(ctx context.Context) versioned.Interface {","\tuntyped := ctx.Value(Key{})","\tif untyped == nil {","\t\tif injection.GetConfig(ctx) == nil {","\t\t\tlogging.FromContext(ctx).Panic(","\t\t\t\t\"Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).\")","\t\t} else {","\t\t\tlogging.FromContext(ctx).Panic(","\t\t\t\t\"Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned.Interface from context.\")","\t\t}","\t}","\treturn untyped.(versioned.Interface)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":21,"path":"pkg/client/injection/client/fake/fake.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package fake","","import (","\tcontext \"context\"","","\tfake \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/fake\"","\tclient \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client\"","\truntime \"k8s.io/apimachinery/pkg/runtime\"","\trest \"k8s.io/client-go/rest\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Fake.RegisterClient(withClient)","\tinjection.Fake.RegisterClientFetcher(func(ctx context.Context) interface{} {","\t\treturn Get(ctx)","\t})","}","","func withClient(ctx context.Context, cfg *rest.Config) context.Context {","\tctx, _ = With(ctx)","\treturn ctx","}","","func With(ctx context.Context, objects ...runtime.Object) (context.Context, *fake.Clientset) {","\tcs := fake.NewSimpleClientset(objects...)","\treturn context.WithValue(ctx, client.Key{}, cs), cs","}","","// Get extracts the Kubernetes client from the context.","func Get(ctx context.Context) *fake.Clientset {","\tuntyped := ctx.Value(client.Key{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(","\t\t\t\"Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned/fake.Clientset from context.\")","\t}","\treturn untyped.(*fake.Clientset)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0]},{"id":22,"path":"pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/approvaltask.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package approvaltask","","import (","\tcontext \"context\"","","\tv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1\"","\tfactory \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Default.RegisterInformer(withInformer)","}","","// Key is used for associating the Informer inside the context.Context.","type Key struct{}","","func withInformer(ctx context.Context) (context.Context, controller.Informer) {","\tf := factory.Get(ctx)","\tinf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()","\treturn context.WithValue(ctx, Key{}, inf), inf.Informer()","}","","// Get extracts the typed informer from the context.","func Get(ctx context.Context) v1alpha1.ApprovalTaskInformer {","\tuntyped := ctx.Value(Key{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(","\t\t\t\"Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1.ApprovalTaskInformer from context.\")","\t}","\treturn untyped.(v1alpha1.ApprovalTaskInformer)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0]},{"id":23,"path":"pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/fake/fake.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package fake","","import (","\tcontext \"context\"","","\tapprovaltask \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask\"","\tfake \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/fake\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"",")","","var Get = approvaltask.Get","","func init() {","\tinjection.Fake.RegisterInformer(withInformer)","}","","func withInformer(ctx context.Context) (context.Context, controller.Informer) {","\tf := fake.Get(ctx)","\tinf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()","\treturn context.WithValue(ctx, approvaltask.Key{}, inf), inf.Informer()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1]},{"id":24,"path":"pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/filtered/approvaltask.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package filtered","","import (","\tcontext \"context\"","","\tv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1\"","\tfiltered \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Default.RegisterFilteredInformers(withInformer)","}","","// Key is used for associating the Informer inside the context.Context.","type Key struct {","\tSelector string","}","","func withInformer(ctx context.Context) (context.Context, []controller.Informer) {","\tuntyped := ctx.Value(filtered.LabelKey{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(","\t\t\t\"Unable to fetch labelkey from context.\")","\t}","\tlabelSelectors := untyped.([]string)","\tinfs := []controller.Informer{}","\tfor _, selector := range labelSelectors {","\t\tf := filtered.Get(ctx, selector)","\t\tinf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()","\t\tctx = context.WithValue(ctx, Key{Selector: selector}, inf)","\t\tinfs = append(infs, inf.Informer())","\t}","\treturn ctx, infs","}","","// Get extracts the typed informer from the context.","func Get(ctx context.Context, selector string) v1alpha1.ApprovalTaskInformer {","\tuntyped := ctx.Value(Key{Selector: selector})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panicf(","\t\t\t\"Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions/approvaltask/v1alpha1.ApprovalTaskInformer with selector %s from context.\", selector)","\t}","\treturn untyped.(v1alpha1.ApprovalTaskInformer)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0]},{"id":25,"path":"pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/filtered/fake/fake.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package fake","","import (","\tcontext \"context\"","","\tfiltered \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask/filtered\"","\tfactoryfiltered \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","var Get = filtered.Get","","func init() {","\tinjection.Fake.RegisterFilteredInformers(withInformer)","}","","func withInformer(ctx context.Context) (context.Context, []controller.Informer) {","\tuntyped := ctx.Value(factoryfiltered.LabelKey{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(","\t\t\t\"Unable to fetch labelkey from context.\")","\t}","\tlabelSelectors := untyped.([]string)","\tinfs := []controller.Informer{}","\tfor _, selector := range labelSelectors {","\t\tf := factoryfiltered.Get(ctx, selector)","\t\tinf := f.Openshiftpipelines().V1alpha1().ApprovalTasks()","\t\tctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)","\t\tinfs = append(infs, inf.Informer())","\t}","\treturn ctx, infs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":26,"path":"pkg/client/injection/informers/factory/factory.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package factory","","import (","\tcontext \"context\"","","\texternalversions \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions\"","\tclient \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Default.RegisterInformerFactory(withInformerFactory)","}","","// Key is used as the key for associating information with a context.Context.","type Key struct{}","","func withInformerFactory(ctx context.Context) context.Context {","\tc := client.Get(ctx)","\topts := make([]externalversions.SharedInformerOption, 0, 1)","\tif injection.HasNamespaceScope(ctx) {","\t\topts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))","\t}","\treturn context.WithValue(ctx, Key{},","\t\texternalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))","}","","// Get extracts the InformerFactory from the context.","func Get(ctx context.Context) externalversions.SharedInformerFactory {","\tuntyped := ctx.Value(Key{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(","\t\t\t\"Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions.SharedInformerFactory from context.\")","\t}","\treturn untyped.(externalversions.SharedInformerFactory)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0]},{"id":27,"path":"pkg/client/injection/informers/factory/fake/fake.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package fake","","import (","\tcontext \"context\"","","\texternalversions \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions\"","\tfake \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client/fake\"","\tfactory \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"",")","","var Get = factory.Get","","func init() {","\tinjection.Fake.RegisterInformerFactory(withInformerFactory)","}","","func withInformerFactory(ctx context.Context) context.Context {","\tc := fake.Get(ctx)","\topts := make([]externalversions.SharedInformerOption, 0, 1)","\tif injection.HasNamespaceScope(ctx) {","\t\topts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))","\t}","\treturn context.WithValue(ctx, factory.Key{},","\t\texternalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0]},{"id":28,"path":"pkg/client/injection/informers/factory/filtered/fake/fake_filtered_factory.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package fakeFilteredFactory","","import (","\tcontext \"context\"","","\texternalversions \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions\"","\tfake \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client/fake\"","\tfiltered \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/factory/filtered\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","var Get = filtered.Get","","func init() {","\tinjection.Fake.RegisterInformerFactory(withInformerFactory)","}","","func withInformerFactory(ctx context.Context) context.Context {","\tc := fake.Get(ctx)","\tuntyped := ctx.Value(filtered.LabelKey{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(","\t\t\t\"Unable to fetch labelkey from context.\")","\t}","\tlabelSelectors := untyped.([]string)","\tfor _, selector := range labelSelectors {","\t\topts := []externalversions.SharedInformerOption{}","\t\tif injection.HasNamespaceScope(ctx) {","\t\t\topts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))","\t\t}","\t\topts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) {","\t\t\tl.LabelSelector = selector","\t\t}))","\t\tctx = context.WithValue(ctx, filtered.Key{Selector: selector},","\t\t\texternalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))","\t}","\treturn ctx","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":29,"path":"pkg/client/injection/informers/factory/filtered/filtered_factory.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by injection-gen. DO NOT EDIT.","","package filteredFactory","","import (","\tcontext \"context\"","","\texternalversions \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions\"","\tclient \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tcontroller \"knative.dev/pkg/controller\"","\tinjection \"knative.dev/pkg/injection\"","\tlogging \"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Default.RegisterInformerFactory(withInformerFactory)","}","","// Key is used as the key for associating information with a context.Context.","type Key struct {","\tSelector string","}","","type LabelKey struct{}","","func WithSelectors(ctx context.Context, selector ...string) context.Context {","\treturn context.WithValue(ctx, LabelKey{}, selector)","}","","func withInformerFactory(ctx context.Context) context.Context {","\tc := client.Get(ctx)","\tuntyped := ctx.Value(LabelKey{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(","\t\t\t\"Unable to fetch labelkey from context.\")","\t}","\tlabelSelectors := untyped.([]string)","\tfor _, selector := range labelSelectors {","\t\topts := []externalversions.SharedInformerOption{}","\t\tif injection.HasNamespaceScope(ctx) {","\t\t\topts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))","\t\t}","\t\topts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) {","\t\t\tl.LabelSelector = selector","\t\t}))","\t\tctx = context.WithValue(ctx, Key{Selector: selector},","\t\t\texternalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))","\t}","\treturn ctx","}","","// Get extracts the InformerFactory from the context.","func Get(ctx context.Context, selector string) externalversions.SharedInformerFactory {","\tuntyped := ctx.Value(Key{Selector: selector})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panicf(","\t\t\t\"Unable to fetch github.com/openshift-pipelines/manual-approval-gate/pkg/client/informers/externalversions.SharedInformerFactory with selector %s from context.\", selector)","\t}","\treturn untyped.(externalversions.SharedInformerFactory)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,0]},{"id":30,"path":"pkg/client/listers/approvaltask/v1alpha1/approvaltask.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// Code generated by lister-gen. DO NOT EDIT.","","package v1alpha1","","import (","\tapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tlabels \"k8s.io/apimachinery/pkg/labels\"","\tlisters \"k8s.io/client-go/listers\"","\tcache \"k8s.io/client-go/tools/cache\"",")","","// ApprovalTaskLister helps list ApprovalTasks.","// All objects returned here must be treated as read-only.","type ApprovalTaskLister interface {","\t// List lists all ApprovalTasks in the indexer.","\t// Objects returned here must be treated as read-only.","\tList(selector labels.Selector) (ret []*approvaltaskv1alpha1.ApprovalTask, err error)","\t// ApprovalTasks returns an object that can list and get ApprovalTasks.","\tApprovalTasks(namespace string) ApprovalTaskNamespaceLister","\tApprovalTaskListerExpansion","}","","// approvalTaskLister implements the ApprovalTaskLister interface.","type approvalTaskLister struct {","\tlisters.ResourceIndexer[*approvaltaskv1alpha1.ApprovalTask]","}","","// NewApprovalTaskLister returns a new ApprovalTaskLister.","func NewApprovalTaskLister(indexer cache.Indexer) ApprovalTaskLister {","\treturn \u0026approvalTaskLister{listers.New[*approvaltaskv1alpha1.ApprovalTask](indexer, approvaltaskv1alpha1.Resource(\"approvaltask\"))}","}","","// ApprovalTasks returns an object that can list and get ApprovalTasks.","func (s *approvalTaskLister) ApprovalTasks(namespace string) ApprovalTaskNamespaceLister {","\treturn approvalTaskNamespaceLister{listers.NewNamespaced[*approvaltaskv1alpha1.ApprovalTask](s.ResourceIndexer, namespace)}","}","","// ApprovalTaskNamespaceLister helps list and get ApprovalTasks.","// All objects returned here must be treated as read-only.","type ApprovalTaskNamespaceLister interface {","\t// List lists all ApprovalTasks in the indexer for a given namespace.","\t// Objects returned here must be treated as read-only.","\tList(selector labels.Selector) (ret []*approvaltaskv1alpha1.ApprovalTask, err error)","\t// Get retrieves the ApprovalTask from the indexer for a given namespace and name.","\t// Objects returned here must be treated as read-only.","\tGet(name string) (*approvaltaskv1alpha1.ApprovalTask, error)","\tApprovalTaskNamespaceListerExpansion","}","","// approvalTaskNamespaceLister implements the ApprovalTaskNamespaceLister","// interface.","type approvalTaskNamespaceLister struct {","\tlisters.ResourceIndexer[*approvaltaskv1alpha1.ApprovalTask]","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":31,"path":"pkg/reconciler/approvaltask/approvaltask.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package approvaltask","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"log\"","\t\"time\"","","\t\"github.com/hashicorp/go-multierror\"","\tapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tapprovaltaskclientset \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned\"","\tlistersapprovaltask \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/listers/approvaltask/v1alpha1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tclientset \"github.com/tektoncd/pipeline/pkg/client/clientset/versioned\"","\tcustomrunreconciler \"github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun\"","\tlistersalpha \"github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1alpha1\"","\tlisters \"github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1beta1\"","\t\"github.com/tektoncd/pipeline/pkg/reconciler/events\"","\t\"go.uber.org/zap\"","\t\"gomodules.xyz/jsonpatch/v2\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"k8s.io/utils/clock\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const (","\t// approvaltaskLabelKey is the label identifier for a ApprovalTask.  This label is added to the Run and its TaskRuns.","\tapprovaltaskLabelKey = \"/approvaltask\"","","\t// approvaltaskRunLabelKey is the label identifier for a Run.  This label is added to the Run's TaskRuns.","\tapprovaltaskRunLabelKey = \"/run\"","","\tpendingState      = \"pending\"","\tapprovedState     = \"approved\"","\trejectedState     = \"rejected\"","\thasApproved       = \"approve\"","\thasRejected       = \"reject\"","\tallApprovers      = \"approvers\"","\tapprovalsRequired = \"numberOfApprovalsRequired\"","\tdescription       = \"description\"","\ttimeout           = \"timeout\"","","\t// CustomRunLabelKey is used as the label identifier for a ApprovalTask","\tCustomRunLabelKey = \"tekton.dev/customRun\"","","\tLastAppliedHashKey = \"tekton.dev/last-applied-hash\"",")","","// Reconciler implements controller.Reconciler for Configuration resources.","type Reconciler struct {","\tclock                 clock.PassiveClock","\tpipelineClientSet     clientset.Interface","\tkubeClientSet         kubernetes.Interface","\tapprovaltaskClientSet approvaltaskclientset.Interface","\trunLister             listersalpha.RunLister","\tcustomRunLister       listers.CustomRunLister","\tapprovaltaskLister    listersapprovaltask.ApprovalTaskLister","\ttaskRunLister         listers.TaskRunLister","}","","var (","\t// Check that our Reconciler implements runreconciler.Interface","\t_                customrunreconciler.Interface = (*Reconciler)(nil)","\tcancelPatchBytes []byte",")","","func init() {","\tvar err error","\tpatches := []jsonpatch.JsonPatchOperation{{","\t\tOperation: \"add\",","\t\tPath:      \"/spec/status\",","\t\tValue:     v1beta1.TaskRunSpecStatusCancelled,","\t}}","\tcancelPatchBytes, err = json.Marshal(patches)","\tif err != nil {","\t\tlog.Fatalf(\"failed to marshal patch bytes in order to cancel: %v\", err)","\t}","}","","// ReconcileKind compares the actual state with the desired, and attempts to converge the two.","// It then updates the Status block of the Run resource with the current status of the resource.","func (c *Reconciler) ReconcileKind(ctx context.Context, run *v1beta1.CustomRun) pkgreconciler.Event {","\tvar merr error","\tlogger := logging.FromContext(ctx)","\tlogger.Infof(\"Reconciling Run %s/%s at %v\", run.Namespace, run.Name, time.Now())","","\t// Check that the Run references a ApprovalTask CRD.  The logic is controller.go should ensure that only this type of Run","\t// is reconciled this controller but it never hurts to do some bullet-proofing.","\tif err := checkCustomRunReferencesApprovalTask(run); err != nil {","\t\treturn err","\t}","","\t// If the Run has not started, initialize the Condition and set the start time.","\tinitializeCustomRun(ctx, run)","","\tif run.IsDone() {","\t\tlogger.Infof(\"Run %s/%s is done\", run.Namespace, run.Name)","\t\treturn nil","\t}","","\t// Validate parameters early for fail-fast behavior","\tif err := ValidateCustomRunParameters(run); err != nil {","\t\tdetailedMsg := fmt.Sprintf(\"ApprovalTask validation failed: %s\", err.Error())","\t\trun.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonFailedValidation.String(),","\t\t\tdetailedMsg)","\t\tlogger.Errorf(\"Parameter validation failed for Run %s/%s: %v\", run.Namespace, run.Name, err)","\t\t","\t\t// Emit an event with detailed error message for better visibility","\t\tevents.Emit(ctx, nil, \u0026apis.Condition{","\t\t\tType:    apis.ConditionSucceeded,","\t\t\tStatus:  \"False\",","\t\t\tReason:  approvaltaskv1alpha1.ApprovalTaskRunReasonFailedValidation.String(), ","\t\t\tMessage: detailedMsg,","\t\t}, run)","\t\treturn nil","\t}","","\t// Parse timeout parameter from params if provided","\tif run.Spec.Timeout == nil {","\t\tfor _, param := range run.Spec.Params {","\t\t\tif param.Name == timeout {","\t\t\t\tduration, err := time.ParseDuration(param.Value.StringVal)","\t\t\t\tif err != nil {","\t\t\t\t\tlogger.Errorf(\"Invalid timeout parameter value '%s' for Run %s/%s: %v\", param.Value.StringVal, run.Namespace, run.Name, err)","\t\t\t\t\trun.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonFailedValidation.String(),","\t\t\t\t\t\tfmt.Sprintf(\"Invalid timeout parameter: %s\", err.Error()))","\t\t\t\t\treturn nil","\t\t\t\t}","\t\t\t\trun.Spec.Timeout = \u0026metav1.Duration{Duration: duration}","\t\t\t\tlogger.Infof(\"Set timeout from parameter to %v for Run %s/%s\", duration, run.Namespace, run.Name)","\t\t\t\tbreak","\t\t\t}","\t\t}","\t}","","\t// Store the condition before reconcile","\tbeforeCondition := run.Status.GetCondition(apis.ConditionSucceeded)","","\tstatus := \u0026approvaltaskv1alpha1.ApprovalTaskRunStatus{}","\tif err := run.Status.DecodeExtraFields(status); err != nil {","\t\trun.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonInternalError.String(),","\t\t\t\"Internal error calling DecodeExtraFields: %v\", err)","\t\tlogger.Errorf(\"DecodeExtraFields error: %v\", err.Error())","\t}","","\t// Reconcile the Run","\tif err := c.reconcile(ctx, run, status); err != nil {","\t\tlogger.Errorf(\"Reconcile error: %v\", err.Error())","\t\tmerr = multierror.Append(merr, err)","\t\treturn merr","\t}","","\tif err := c.updateLabelsAndAnnotations(ctx, run); err != nil {","\t\tlogger.Warn(\"Failed to update Run labels/annotations\", zap.Error(err))","\t\tmerr = multierror.Append(merr, err)","\t}","","\tif err := run.Status.EncodeExtraFields(status); err != nil {","\t\trun.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonInternalError.String(),","\t\t\t\"Internal error calling EncodeExtraFields: %v\", err)","\t\tlogger.Errorf(\"EncodeExtraFields error: %v\", err.Error())","\t}","","\tafterCondition := run.Status.GetCondition(apis.ConditionSucceeded)","\tevents.Emit(ctx, beforeCondition, afterCondition, run)","","\t// Only transient errors that should retry the reconcile are returned.","\treturn merr","}","","func (r *Reconciler) reconcile(ctx context.Context, run *v1beta1.CustomRun, status *approvaltaskv1alpha1.ApprovalTaskRunStatus) error {","\t// Get the ApprovalTask referenced by the Run","\tlogger := logging.FromContext(ctx)","\tapprovalTask, err := getOrCreateApprovalTask(ctx, r.approvaltaskClientSet, run)","\tif err != nil {","\t\tlogger.Errorf(\"Error getting or creating the approval task: %v\", err.Error())","\t\treturn err","\t}","","\tapprovalTaskMeta := \u0026approvalTask.ObjectMeta","\tapprovalTaskSpec := approvalTask.Spec","","\t// Store the fetched ApprovalTaskSpec on the Run for auditing","\tstoreApprovalTaskSpec(status, \u0026approvalTaskSpec)","","\t// Propagate labels and annotations from ApprovalTask to Run.","\tpropagateApprovalTaskLabelsAndAnnotations(run, approvalTaskMeta)","","\tif !approvalTask.HasStarted() {","\t\tapprovalTask.Status.StartTime = \u0026approvalTask.CreationTimestamp","\t}","","\ttimeout := run.Spec.Timeout","\tif timeout == nil {","\t\ttimeout = \u0026metav1.Duration{Duration: time.Duration(60) * time.Minute}","\t}","\tif approvalTask.ApprovalTaskHasTimedOut(ctx, r.clock, timeout.Duration) {","\t\tapprovalTask.Status.State = rejectedState","\t\t_, err := r.approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(approvalTask.Namespace).UpdateStatus(ctx, approvalTask, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tmessage := fmt.Sprintf(\"Approval task %s is failed because of timeout\", approvalTask.Name)","\t\trun.Status.MarkCustomRunFailed(approvaltaskv1alpha1.ApprovalTaskRunReasonFailed.String(), message)","\t\treturn nil","\t}","","\tif err := r.checkIfUpdateRequired(ctx, *approvalTask, run); err != nil {","\t\treturn err","\t}","","\tif approvalTask.Status.StartTime != nil {","\t\telapsed := r.clock.Since(approvalTask.Status.StartTime.Time)","\t\twaitTime := timeout.Duration - elapsed","\t\t// If waitTime is negative or very small, requeue immediately to check timeout","\t\tif waitTime \u003c= 0 {","\t\t\twaitTime = time.Second","\t\t}","\t\treturn controller.NewRequeueAfter(waitTime)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,0]},{"id":32,"path":"pkg/reconciler/approvaltask/controller.go","lines":["/*","Copyright 2022 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","package approvaltask","","import (","\t\"context\"","","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask\"","\tapprovaltaskv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\tapprovaltaskclient \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/client\"","\tapprovaltaskinformer \"github.com/openshift-pipelines/manual-approval-gate/pkg/client/injection/informers/approvaltask/v1alpha1/approvaltask\"","\tpipelineclient \"github.com/tektoncd/pipeline/pkg/client/injection/client\"","\tcustomruninformer \"github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1beta1/customrun\"","\tcustomrunreconciler \"github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1beta1/customrun\"","\tpipelinecontroller \"github.com/tektoncd/pipeline/pkg/controller\"","\t\"k8s.io/client-go/tools/cache\"","\t\"k8s.io/utils/clock\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","// NewController instantiates a new controller.Impl from knative.dev/pkg/controller","func NewController(clock clock.PassiveClock) func(context.Context, configmap.Watcher) *controller.Impl {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","","\t\tlogger := logging.FromContext(ctx)","\t\tkubeclientset := kubeclient.Get(ctx)","\t\tpipelineclientset := pipelineclient.Get(ctx)","\t\tapprovaltaskclientset := approvaltaskclient.Get(ctx)","\t\tcustomRunInformer := customruninformer.Get(ctx)","\t\tapprovaltaskInformer := approvaltaskinformer.Get(ctx)","","\t\tc := \u0026Reconciler{","\t\t\tclock:                 clock,","\t\t\tkubeClientSet:         kubeclientset,","\t\t\tpipelineClientSet:     pipelineclientset,","\t\t\tapprovaltaskClientSet: approvaltaskclientset,","\t\t\tcustomRunLister:       customRunInformer.Lister(),","\t\t\tapprovaltaskLister:    approvaltaskInformer.Lister(),","\t\t}","","\t\timpl := customrunreconciler.NewImpl(ctx, c, func(impl *controller.Impl) controller.Options {","\t\t\treturn controller.Options{","\t\t\t\tAgentName: \"run-approvaltask\",","\t\t\t}","\t\t})","","\t\tlogger.Info(\"Setting up event handlers\")","","\t\t// Add event handler for Runs","\t\tcustomRunInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: pipelinecontroller.FilterCustomRunRef(approvaltaskv1alpha1.SchemeGroupVersion.String(), approvaltask.ControllerName),","\t\t\tHandler:    controller.HandleAll(impl.Enqueue),","\t\t})","","\t\tapprovaltaskInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue))","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0]},{"id":33,"path":"pkg/reconciler/approvaltask/utils.go","lines":["/*","Copyright 2023 The OpenShift Pipelines Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package approvaltask","","import (","\t\"context\"","\t\"crypto/sha256\"","\t\"encoding/json\"","\t\"fmt\"","\t\"reflect\"","\t\"strconv\"","\t\"strings\"","","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask\"","\tv1alpha1 \"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/client/clientset/versioned\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\t\"github.com/tektoncd/pipeline/pkg/reconciler/events\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"",")","","var (","\tgvk = schema.GroupVersionKind{Group: \"tekton.dev\", Version: \"v1beta1\", Kind: \"CustomRun\"}",")","","// validateApproverParameter validates a single approver string (user or group format).","func validateApproverParameter(paramValue string, paramIndex int) error {","\tif strings.TrimSpace(paramValue) == \"\" {","\t\treturn fmt.Errorf(\"approvers[%d]: approver name cannot be empty\", paramIndex)","\t}","","\t// Check for malformed group syntax","\tif strings.Contains(paramValue, \" :\") || strings.Contains(paramValue, \": \") {","\t\t\t\t\treturn fmt.Errorf(\"approvers[%d]: invalid group format '%s' - use 'group:groupname' format (remove spaces around colon)\", paramIndex, paramValue)","\t}","","\t// Handle explicit group syntax: \"group:groupname\"","\tif strings.HasPrefix(paramValue, \"group:\") {","\t\treturn validateGroupSyntax(paramValue, paramIndex)","\t}","","\treturn validateUserSyntax(paramValue, paramIndex)","}","","// validateGroupSyntax validates the \"group:groupname\" format and ensures proper syntax.","func validateGroupSyntax(paramValue string, paramIndex int) error {","\tparts := strings.SplitN(paramValue, \":\", 2)","\tif len(parts) != 2 || strings.TrimSpace(parts[1]) == \"\" {","\t\treturn fmt.Errorf(\"approvers[%d]: invalid group format '%s' - group name cannot be empty after 'group:'\", paramIndex, paramValue)","\t}","\t","\tgroupName := parts[1]","\t// Validate group name format inline","\tif strings.TrimSpace(groupName) == \"\" {","\t\treturn fmt.Errorf(\"approvers[%d]: group name cannot be empty\", paramIndex)","\t}","\tif strings.Contains(groupName, \":\") {","\t\treturn fmt.Errorf(\"approvers[%d]: group name '%s' cannot contain colons\", paramIndex, groupName)","\t}","\tif strings.Contains(groupName, \" \") {","\t\treturn fmt.Errorf(\"approvers[%d]: group name '%s' cannot contain spaces\", paramIndex, groupName)","\t}","\t","\treturn nil","}","","// validateUserSyntax validates a plain username approver.","func validateUserSyntax(paramValue string, paramIndex int) error {","\t// Validate user name format inline","\tif strings.TrimSpace(paramValue) == \"\" {","\t\treturn fmt.Errorf(\"approvers[%d]: username cannot be empty\", paramIndex)","\t}","\t","\treturn nil","}","","// ValidateCustomRunParameters validates CustomRun parameters for early error detection.","func ValidateCustomRunParameters(run *v1beta1.CustomRun) error {","\tvar hasApprovers bool","\tvar approversCount int","\tvar validationErrors []string","","\tfor _, param := range run.Spec.Params {","\t\tswitch param.Name {","\t\tcase allApprovers:","\t\t\thasApprovers = true","\t\t\tcount, errs := validateApproversParam(param)","\t\t\tapproversCount = count","\t\t\tvalidationErrors = append(validationErrors, errs...)","\t\tcase approvalsRequired:","\t\t\tif err := validateApprovalsRequired(param.Value.StringVal); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t}","","\tif len(validationErrors) \u003e 0 {","\t\treturn fmt.Errorf(\"invalid approvers parameter: %s\", validationErrors[0])","\t}","","\tif !hasApprovers {","\t\treturn fmt.Errorf(\"no valid approvers found - at least one approver is required\")","\t}","","\tif approversCount == 0 {","\t\treturn fmt.Errorf(\"no valid approvers found - at least one approver is required\")","\t}","","\treturn nil","}","","// validateApproversParam validates the approvers parameter and returns count + errors","func validateApproversParam(param v1beta1.Param) (int, []string) {","\tvar validationErrors []string","\tvar approversCount int","","\t// Parse approvers list from different formats","\tapproverList := parseApproversList(param, \u0026validationErrors)","","\t// Validate each approver","\tfor i, approver := range approverList {","\t\tswitch val := approver.(type) {","\t\tcase string:","\t\t\tif err := validateApproverParameter(val, i); err != nil {","\t\t\t\tvalidationErrors = append(validationErrors, err.Error())","\t\t\t} else {","\t\t\t\tapproversCount++","\t\t\t}","\t\tcase map[string]interface{}:","\t\t\tvalidateMalformedObjectApprover(val, i, \u0026validationErrors)","\t\tdefault:","\t\t\tvalidationErrors = append(validationErrors, fmt.Sprintf(\"approvers[%d]: invalid approver format - must be a string\", i))","\t\t}","\t}","","\treturn approversCount, validationErrors","}","","// parseApproversList extracts approvers from different parameter formats","func parseApproversList(param v1beta1.Param, validationErrors *[]string) []interface{} {","\tvar approverList []interface{}","","\tif len(param.Value.ArrayVal) \u003e 0 {","\t\tfor _, approver := range param.Value.ArrayVal {","\t\t\tapproverList = append(approverList, approver)","\t\t}","\t}","","\tif len(param.Value.ObjectVal) \u003e 0 {","\t\t// Convert map[string]string to map[string]interface{} for proper handling","\t\tobjectVal := make(map[string]interface{})","\t\tfor k, v := range param.Value.ObjectVal {","\t\t\tobjectVal[k] = v","\t\t}","\t\tapproverList = append(approverList, objectVal)","\t}","","\tif param.Value.StringVal != \"\" \u0026\u0026 len(approverList) == 0 {","\t\tvar jsonData interface{}","\t\tif err := json.Unmarshal([]byte(param.Value.StringVal), \u0026jsonData); err != nil {","\t\t\t*validationErrors = append(*validationErrors, fmt.Sprintf(\"failed to parse JSON '%s' - %v\", param.Value.StringVal, err))","\t\t\treturn approverList","\t\t}","\t\t","\t\tif arr, ok := jsonData.([]interface{}); ok {","\t\t\tapproverList = arr","\t\t} else {","\t\t\t*validationErrors = append(*validationErrors, \"expected an array of approvers\")","\t\t}","\t}","","\treturn approverList","}","","// validateMalformedObjectApprover validates malformed object approvers (from YAML with spaces)","func validateMalformedObjectApprover(approver map[string]interface{}, index int, validationErrors *[]string) {","\tif groupName, ok := approver[\"group\"]; ok {","\t\tif groupStr, ok := groupName.(string); ok {","\t\t\t// Format the object as JSON for clear error message","\t\t\tobjJSON := fmt.Sprintf(`{\"group\":\"%s\"}`, groupStr)","\t\t\t*validationErrors = append(*validationErrors, fmt.Sprintf(\"approvers[%d]: invalid group format %s - use 'group:%s' format instead\", index, objJSON, groupStr))","\t\t} else {","\t\t\t*validationErrors = append(*validationErrors, fmt.Sprintf(\"approvers[%d]: invalid group specification\", index))","\t\t}","\t} else {","\t\t// Handle other object formats","\t\tobjJSON, _ := json.Marshal(approver)","\t\t*validationErrors = append(*validationErrors, fmt.Sprintf(\"approvers[%d]: invalid object format %s - approver must be a string, not an object\", index, string(objJSON)))","\t}","}","","// validateApprovalsRequired validates the numberOfApprovalsRequired parameter value.","func validateApprovalsRequired(value string) error {","\tapprovals, err := strconv.Atoi(value)","\tif err != nil {","\t\treturn fmt.Errorf(\"invalid numberOfApprovalsRequired parameter: '%s' is not a valid integer\", value)","\t}","\tif approvals \u003c= 0 {","\t\treturn fmt.Errorf(\"invalid numberOfApprovalsRequired parameter: must be greater than 0, got %d\", approvals)","\t}","\treturn nil","}","","func checkCustomRunReferencesApprovalTask(run *v1beta1.CustomRun) error {","\tvar apiVersion, kind string","\tif run.Spec.CustomRef != nil {","\t\tapiVersion = run.Spec.CustomRef.APIVersion","\t\tkind = string(run.Spec.CustomRef.Kind)","\t} else if run.Spec.CustomSpec != nil {","\t\tapiVersion = run.Spec.CustomSpec.APIVersion","\t\tkind = run.Spec.CustomSpec.Kind","\t}","","\tif apiVersion != v1alpha1.SchemeGroupVersion.String() ||","\t\tkind != approvaltask.ControllerName {","\t\treturn fmt.Errorf(\"Received control for a Run %s/%s that does not reference a ApprovalTask custom CRD\", run.Namespace, run.Name)","\t}","\treturn nil","}","","func initializeCustomRun(ctx context.Context, run *v1beta1.CustomRun) {","\tlogger := logging.FromContext(ctx)","\tif !run.HasStarted() {","\t\tlogger.Infof(\"Starting new Run %s/%s\", run.Namespace, run.Name)","\t\trun.Status.InitializeConditions()","\t\t// In case node time was not synchronized, when controller has been scheduled to other nodes.","\t\tif run.Status.StartTime.Sub(run.CreationTimestamp.Time) \u003c 0 {","\t\t\tlogger.Warnf(\"Run %s createTimestamp %s is after the Run started %s\", run.Name, run.CreationTimestamp, run.Status.StartTime)","\t\t\trun.Status.StartTime = \u0026run.CreationTimestamp","\t\t}","\t\t// Emit events. During the first reconcile the status of the Run may change twice","\t\t// from not Started to Started and then to Running, so we need to send the event here","\t\t// and at the end of 'Reconcile' again.","\t\t// We also want to send the \"Started\" event as soon as possible for anyone who may be waiting","\t\t// on the event to perform user facing initialisations, such as reset a CI check status","\t\tafterCondition := run.Status.GetCondition(apis.ConditionSucceeded)","\t\tevents.Emit(ctx, nil, afterCondition, run)","\t}","}","","func getOrCreateApprovalTask(ctx context.Context, approvaltaskClientSet versioned.Interface, run *v1beta1.CustomRun) (*v1alpha1.ApprovalTask, error) {","\tapprovalTask := v1alpha1.ApprovalTask{}","","\tif run.Spec.CustomRef != nil {","\t\t// Use the k8 client to get the ApprovalTask rather than the lister.  This avoids a timing issue where","\t\t// the ApprovalTask is not yet in the lister cache if it is created at nearly the same time as the Run.","\t\t// See https://github.com/tektoncd/pipeline/issues/2740 for discussion on this issue.","\t\ttl, err := approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).Get(ctx, run.Name, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tif errors.IsNotFound(err) {","\t\t\t\tat, err := createApprovalTask(ctx, approvaltaskClientSet, run)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\treturn \u0026at, nil","\t\t\t}","\t\t}","\t\tapprovalTask = *tl","\t} else if run.Spec.CustomSpec != nil {","\t\t// FIXME(openshift-pipelines) support embedded spec","\t\tif err := json.Unmarshal(run.Spec.CustomSpec.Spec.Raw, \u0026approvalTask.Spec); err != nil {","\t\t\trun.Status.MarkCustomRunFailed(v1alpha1.ApprovalTaskRunReasonCouldntGetApprovalTask.String(),","\t\t\t\t\"Error retrieving ApprovalTask for Run %s/%s: %s\",","\t\t\t\trun.Namespace, run.Name, err)","\t\t\treturn nil, fmt.Errorf(\"Error retrieving ApprovalTask for Run %s: %w\", fmt.Sprintf(\"%s/%s\", run.Namespace, run.Name), err)","\t\t}","\t}","","\treturn \u0026approvalTask, nil","}","","func storeApprovalTaskSpec(status *v1alpha1.ApprovalTaskRunStatus, approvalTaskSpec *v1alpha1.ApprovalTaskSpec) {","\t// Only store the ApprovalTaskSpec once, if it has never been set before.","\tif status.ApprovalTaskSpec == nil {","\t\tstatus.ApprovalTaskSpec = approvalTaskSpec","\t}","}","","func propagateApprovalTaskLabelsAndAnnotations(run *v1beta1.CustomRun, approvaltaskMeta *metav1.ObjectMeta) {","\t// Propagate labels from ApprovalTask to Run.","\tif run.ObjectMeta.Labels == nil {","\t\trun.ObjectMeta.Labels = make(map[string]string, len(approvaltaskMeta.Labels)+1)","\t}","\tfor key, value := range approvaltaskMeta.Labels {","\t\trun.ObjectMeta.Labels[key] = value","\t}","\trun.ObjectMeta.Labels[approvaltask.GroupName+approvaltaskLabelKey] = approvaltaskMeta.Name","","\t// Propagate annotations from ApprovalTask to Run.","\tif run.ObjectMeta.Annotations == nil {","\t\trun.ObjectMeta.Annotations = make(map[string]string, len(approvaltaskMeta.Annotations))","\t}","\tfor key, value := range approvaltaskMeta.Annotations {","\t\trun.ObjectMeta.Annotations[key] = value","\t}","}","","func (c *Reconciler) updateLabelsAndAnnotations(ctx context.Context, run *v1beta1.CustomRun) error {","\tnewRun, err := c.customRunLister.CustomRuns(run.Namespace).Get(run.Name)","\tif err != nil {","\t\treturn fmt.Errorf(\"error getting Run %s when updating labels/annotations: %w\", run.Name, err)","\t}","\tif !reflect.DeepEqual(run.ObjectMeta.Labels, newRun.ObjectMeta.Labels) || !reflect.DeepEqual(run.ObjectMeta.Annotations, newRun.ObjectMeta.Annotations) {","\t\tmergePatch := map[string]interface{}{","\t\t\t\"metadata\": map[string]interface{}{","\t\t\t\t\"labels\":      run.ObjectMeta.Labels,","\t\t\t\t\"annotations\": run.ObjectMeta.Annotations,","\t\t\t},","\t\t}","\t\tpatch, err := json.Marshal(mergePatch)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t_, err = c.pipelineClientSet.TektonV1beta1().CustomRuns(run.Namespace).Patch(ctx, run.Name, types.MergePatchType, patch, metav1.PatchOptions{})","\t\treturn err","\t}","\treturn nil","}","","func createApprovalTask(ctx context.Context, approvaltaskClientSet versioned.Interface, run *v1beta1.CustomRun) (v1alpha1.ApprovalTask, error) {","\tvar (","\t\tapprovers      []v1alpha1.ApproverDetails","\t\tusers          []string","\t\tdesc           string","\t\terr            error","\t\tapproverExists = make(map[string]bool)","\t\tuserExists     = make(map[string]bool)","\t)","","\tlogger := logging.FromContext(ctx)","\tnumberOfApprovalsRequired := 1","","\tfor _, v := range run.Spec.Params {","\t\tvar approver v1alpha1.ApproverDetails","","\t\tif v.Name == allApprovers {","\t\t\tfor _, name := range v.Value.ArrayVal {","\t\t\t\tif !userExists[name] {","\t\t\t\t\tapprover.Name = name","\t\t\t\t\tapprover.Input = pendingState","","\t\t\t\t\t// Check if the type is mentioned in the params","\t\t\t\t\tif strings.HasPrefix(name, \"group:\") {","\t\t\t\t\t\tapprover.Type = \"Group\"","","\t\t\t\t\t\tif strings.HasPrefix(approver.Name, \"group:\") {","\t\t\t\t\t\t\tparts := strings.SplitN(approver.Name, \":\", 2)","\t\t\t\t\t\t\tif len(parts) == 2 {","\t\t\t\t\t\t\t\tapprover.Name = parts[1]","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t} else {","\t\t\t\t\t\tapprover.Type = \"User\"","\t\t\t\t\t}","","\t\t\t\t\tif !approverExists[approver.Name] {","\t\t\t\t\t\tapprovers = append(approvers, approver)","\t\t\t\t\t\tapproverExists[approver.Name] = true","\t\t\t\t\t}","\t\t\t\t\tusers = append(users, approver.Name)","\t\t\t\t\tuserExists[approver.Name] = true","\t\t\t\t}","\t\t\t}","\t\t} else if v.Name == approvalsRequired {","\t\t\ttempApproversRequired, err := strconv.Atoi(v.Value.StringVal)","\t\t\tif err != nil {","\t\t\t\treturn v1alpha1.ApprovalTask{}, err","\t\t\t}","\t\t\tnumberOfApprovalsRequired = tempApproversRequired","\t\t} else if v.Name == description {","\t\t\tdesc = v.Value.StringVal","\t\t}","\t}","","\townerRef := *metav1.NewControllerRef(run, gvk)","\tlabels := make(map[string]string)","\tfor key, value := range run.Labels {","\t\tlabels[key] = value","\t}","\tlabels[CustomRunLabelKey] = run.Name","","\tapprovalTask := \u0026v1alpha1.ApprovalTask{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            run.Name,","\t\t\tNamespace:       run.Namespace,","\t\t\tLabels:          labels,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.ApprovalTaskSpec{","\t\t\tApprovers:                 approvers,","\t\t\tNumberOfApprovalsRequired: numberOfApprovalsRequired,","\t\t\tDescription:               desc,","\t\t},","\t}","","\tapproverSpecHash, err := Compute(approvalTask.Spec.Approvers)","\tif err != nil {","\t\treturn v1alpha1.ApprovalTask{}, err","\t}","\tapprovalTask.Annotations = map[string]string{","\t\tLastAppliedHashKey: approverSpecHash,","\t}","","\t_, err = approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).Create(ctx, approvalTask, metav1.CreateOptions{})","\tif err != nil {","\t\treturn v1alpha1.ApprovalTask{}, err","\t}","\tlogger.Infof(\"Approval Task %s is created\", approvalTask.Name)","","\tat, err := approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).Get(ctx, run.Name, metav1.GetOptions{})","\tif err != nil {","\t\tlogger.Errorf(\"Error retrieving the created ApprovalTask %s: %v\", run.Name, err)","\t\treturn v1alpha1.ApprovalTask{}, err","\t}","","\tstatus := v1alpha1.ApprovalTaskStatus{","\t\tState:             pendingState,","\t\tApprovers:         users,","\t\tApproversResponse: []v1alpha1.ApproverState{},","\t\tApprovalsRequired: numberOfApprovalsRequired,","\t\tApprovalsReceived: 0, // Initially no approvals received","\t}","","\tat.Status = status","\t_, err = approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(run.Namespace).UpdateStatus(ctx, at, metav1.UpdateOptions{})","\tif err != nil {","\t\treturn v1alpha1.ApprovalTask{}, err","\t}","","\treturn *at, nil","}","","func approvalTaskHasFalseInput(approvalTask v1alpha1.ApprovalTask) bool {","\tfor _, approver := range approvalTask.Spec.Approvers {","\t\tif approver.Input == hasRejected {","\t\t\treturn true // Found an input that is \"reject\"","\t\t}","\t}","\treturn false","}","","func approvalTaskHasTrueInput(approvalTask v1alpha1.ApprovalTask) bool {","\t// Count approvers with input \"approve\"","\trequiredApprovals := approvalTask.Spec.NumberOfApprovalsRequired","","\tapprovedUsers := make(map[string]bool)","","\tfor _, approver := range approvalTask.Spec.Approvers {","\t\tif approver.Input != hasApproved {","\t\t\tcontinue","\t\t}","","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"User\" {","\t\t\tapprovedUsers[approver.Name] = true","\t\t} else if v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\tfor _, user := range approver.Users {","\t\t\t\tif user.Input == hasApproved {","\t\t\t\t\tapprovedUsers[user.Name] = true","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\treturn len(approvedUsers) \u003e= requiredApprovals","}","","func countApprovalsReceived(approvalTask v1alpha1.ApprovalTask) int {","\t// Count unique users who have approved","\tapprovedUsers := make(map[string]bool)","","\tfor _, approver := range approvalTask.Spec.Approvers {","\t\tif approver.Input != hasApproved {","\t\t\tcontinue","\t\t}","","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"User\" {","\t\t\tapprovedUsers[approver.Name] = true","\t\t} else if v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\tfor _, user := range approver.Users {","\t\t\t\tif user.Input == hasApproved {","\t\t\t\t\tapprovedUsers[user.Name] = true","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\treturn len(approvedUsers)","}","","func (r *Reconciler) checkIfUpdateRequired(ctx context.Context, approvalTask v1alpha1.ApprovalTask, run *v1beta1.CustomRun) error {","\tlogger := logging.FromContext(ctx)","","\texpectedHash, err := Compute(approvalTask.Spec.Approvers)","\tif err != nil {","\t\tlogger.Errorf(\"Unable to compute the hash\")","\t\treturn err","\t}","\tlastAppliedHash := approvalTask.GetAnnotations()[LastAppliedHashKey]","","\tif expectedHash != lastAppliedHash {","\t\tif _, err := updateApprovalState(ctx, r.approvaltaskClientSet, \u0026approvalTask); err != nil {","\t\t\treturn err","\t\t}","","\t\tswitch approvalTask.Status.State {","\t\tcase pendingState:","\t\t\tlogger.Infof(\"Approval task %s is in pending state\", approvalTask.Name)","\t\tcase rejectedState:","\t\t\tlogger.Infof(\"Approval task %s is rejected\", approvalTask.Name)","\t\t\trun.Status.MarkCustomRunFailed(v1alpha1.ApprovalTaskRunReasonFailed.String(), \"Approval Task denied\")","\t\tcase approvedState:","\t\t\tlogger.Infof(\"Approval task %s is approved\", approvalTask.Name)","\t\t\trun.Status.MarkCustomRunSucceeded(v1alpha1.ApprovalTaskRunReasonSucceeded.String(),","\t\t\t\t\"TaskRun succeeded\")","\t\t}","\t}","","\treturn nil","}","","func updateApprovalState(ctx context.Context, approvaltaskClientSet versioned.Interface, approvalTask *v1alpha1.ApprovalTask) (v1alpha1.ApprovalTask, error) {","\t// Updating the approvedBy field in the status","\t// Temp map to hold current approvers with approve and reject input","\tcurrentApprovers := make(map[string]v1alpha1.ApproverState)","\tapprovalTask.Status.ApproversResponse = []v1alpha1.ApproverState{}","\t// Track users who have already been processed as individual approvers","\t// to avoid duplicate entries when they are also group members","\tprocessedUserApprovers := make(map[string]bool)","\t","\t// First pass: Process all User type approvers","\tfor _, approver := range approvalTask.Spec.Approvers {","\t\tif (approver.Input == hasApproved || approver.Input == hasRejected) \u0026\u0026 v1alpha1.DefaultedApproverType(approver.Type) == \"User\" {","\t\t\tresponse := \"\"","\t\t\tif approver.Input == hasApproved {","\t\t\t\tresponse = approvedState","\t\t\t} else if approver.Input == hasRejected {","\t\t\t\tresponse = rejectedState","\t\t\t}","\t\t\t","\t\t\tcurrentApprovers[approver.Name] = v1alpha1.ApproverState{","\t\t\t\tName:     approver.Name,","\t\t\t\tType:     \"User\",","\t\t\t\tResponse: response,","\t\t\t\tMessage:  approver.Message,","\t\t\t}","\t\t\t// Mark this user as processed to avoid duplication in group processing","\t\t\tprocessedUserApprovers[approver.Name] = true","\t\t}","\t}","\t","\t// Second pass: Process Group type approvers, excluding users already processed as individuals","\tfor _, approver := range approvalTask.Spec.Approvers {","\t\tif (approver.Input == hasApproved || approver.Input == hasRejected) \u0026\u0026 v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\tgroupMembers := []v1alpha1.GroupMemberState{}","\t\t\tgroupResponse := \"\"","\t\t\thasApprovals := false","\t\t\thasRejections := false","","\t\t\tfor _, user := range approver.Users {","\t\t\t\t// Skip users who have already been processed as individual approvers","\t\t\t\t// This prevents duplicate entries when a user is both an individual approver and group member","\t\t\t\tif processedUserApprovers[user.Name] {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\t","\t\t\t\tuserResponse := \"\"","\t\t\t\tif user.Input == hasApproved {","\t\t\t\t\tuserResponse = approvedState","\t\t\t\t\thasApprovals = true","\t\t\t\t} else if user.Input == hasRejected {","\t\t\t\t\tuserResponse = rejectedState","\t\t\t\t\thasRejections = true","\t\t\t\t}","","\t\t\t\tif userResponse != \"\" {","\t\t\t\t\tgroupMembers = append(groupMembers, v1alpha1.GroupMemberState{","\t\t\t\t\t\tName:     user.Name,","\t\t\t\t\t\tResponse: userResponse,","\t\t\t\t\t\tMessage:  user.Message, // Inherit message from user level","\t\t\t\t\t})","\t\t\t\t}","\t\t\t}","","\t\t\t// Determine group response based on individual user responses","\t\t\tif hasRejections {","\t\t\t\tgroupResponse = rejectedState","\t\t\t} else if hasApprovals {","\t\t\t\tgroupResponse = approvedState","\t\t\t}","","\t\t\tif groupResponse != \"\" {","\t\t\t\tcurrentApprovers[approver.Name] = v1alpha1.ApproverState{","\t\t\t\t\tName:         approver.Name,","\t\t\t\t\tType:         \"Group\",","\t\t\t\t\tResponse:     groupResponse,","\t\t\t\t\tMessage:      approver.Message,","\t\t\t\t\tGroupMembers: groupMembers,","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\tif len(currentApprovers) != 0 {","\t\t// Filter the ApprovedBy to only include those that are still true","\t\tfilteredApprovedBy := []v1alpha1.ApproverState{}","\t\tfor _, approver := range currentApprovers {","\t\t\tfilteredApprovedBy = append(filteredApprovedBy, approver)","\t\t}","","\t\t// Update the ApprovedBy list","\t\tapprovalTask.Status.ApproversResponse = filteredApprovedBy","","\t\t// Update the approvals count fields","\t\tapprovalTask.Status.ApprovalsRequired = approvalTask.Spec.NumberOfApprovalsRequired","\t\tapprovalTask.Status.ApprovalsReceived = countApprovalsReceived(*approvalTask)","","\t\t// Update the approvalState","\t\t// Reject scenario: Check if there is one false and if found mark the approvalstate to false","\t\t// Approve scenario: Check if the input value from the user is true and is equal to the approvalsRequired","\t\tif approvalTaskHasFalseInput(*approvalTask) {","\t\t\tapprovalTask.Status.State = rejectedState","\t\t} else if approvalTaskHasTrueInput(*approvalTask) {","\t\t\tapprovalTask.Status.State = approvedState","\t\t}","","\t\t// Update the status finally","\t\tat, err := approvaltaskClientSet.OpenshiftpipelinesV1alpha1().ApprovalTasks(approvalTask.Namespace).UpdateStatus(ctx, approvalTask, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn v1alpha1.ApprovalTask{}, err","\t\t}","\t\treturn *at, nil","\t}","","\treturn v1alpha1.ApprovalTask{}, nil","}","","// Compute generates an unique hash/string for the object pass to it.","// with sha256","func Compute(obj interface{}) (string, error) {","\td, err := json.Marshal(obj)","\tif err != nil {","\t\treturn \"\", err","\t}","\thashSha256 := sha256.New()","\thashSha256.Write(d)","\treturn fmt.Sprintf(\"%x\", hashSha256.Sum(nil)), nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,0,0,0,2,2,2,2,2,0,2,2,2,1,1,2,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,2,2,2,0,2,1,1,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,2,0,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,2,2,2,2,2,0,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,1,1,1,1,1,0,0,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0,2,2,2,0,2,2,2,2,2,2,0,0,2,2,2,1,1,2,1,1,1,0,0,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,1,1,0,2,0,0,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,0,0,2,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,0,0,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,1,2,0,0,1,0,0,0,0,2,2,2,1,1,2,2,2,0]},{"id":34,"path":"pkg/reconciler/webhook/controller.go","lines":["package webhook","","import (","\t\"context\"","","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tvwhinformer \"knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/validatingwebhookconfiguration\"","\t\"knative.dev/pkg/controller\"","\tsecretinformer \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"",")","","func NewAdmissionController(ctx context.Context,","\tname, path string,","\twc func(context.Context) context.Context,","\tdisallowUnknownFields bool,",") *controller.Impl {","","\tclient := kubeclient.Get(ctx)","\tvwhInformer := vwhinformer.Get(ctx)","\tsecretInformer := secretinformer.Get(ctx)","\toptions := webhook.GetOptions(ctx)","","\tkey := types.NamespacedName{","\t\tNamespace: system.Namespace(),","\t\tName:      name,","\t}","","\tc := \u0026reconciler{","\t\tLeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{","\t\t\t// Have this reconciler enqueue our singleton whenever it becomes leader.","\t\t\tPromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error {","\t\t\t\tenq(bkt, key)","\t\t\t\treturn nil","\t\t\t},","\t\t},","","\t\tkey:  key,","\t\tpath: path,","","\t\twithContext:           wc,","\t\tdisallowUnknownFields: disallowUnknownFields,","\t\tsecretName:            options.SecretName,","","\t\tclient:       client,","\t\tvwhlister:    vwhInformer.Lister(),","\t\tsecretlister: secretInformer.Lister(),","\t}","","\tlogger := logging.FromContext(ctx)","\tcont := controller.NewContext(ctx, c, controller.ControllerOptions{WorkQueueName: \"ValidatingWebhook\", Logger: logger})","","\t// Reconcile when the named ValidatingWebhookConfiguration changes.","\tif _, err := vwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithName(name),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named MWH resource.","\t\tHandler: controller.HandleAll(cont.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"couldn't register ValidatingWebhookConfiguration informer event handler: %w\", err)","\t}","","\t// Reconcile when the cert bundle changes.","\tif _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), c.secretName),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named MWH resource.","\t\tHandler: controller.HandleAll(cont.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"couldn't register Secret informer event handler: %w\", err)","\t}","","\treturn cont","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0]},{"id":35,"path":"pkg/reconciler/webhook/webhook.go","lines":["package webhook","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/openshift-pipelines/manual-approval-gate/pkg/apis/approvaltask/v1alpha1\"","\t\"go.uber.org/zap\"","\tadmissionv1 \"k8s.io/api/admission/v1\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","\tadmissionlisters \"k8s.io/client-go/listers/admissionregistration/v1\"","\tcorelisters \"k8s.io/client-go/listers/core/v1\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/kmp\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"","\tcertresources \"knative.dev/pkg/webhook/certificates/resources\"",")","","const (","\tGroup   = \"openshift-pipelines.org\"","\tVersion = \"v1alpha1\"","\tKind    = \"ApprovalTask\"",")","","// reconciler implements the AdmissionController for resources","type reconciler struct {","\twebhook.StatelessAdmissionImpl","\tpkgreconciler.LeaderAwareFuncs","","\tkey  types.NamespacedName","\tpath string","","\twithContext func(context.Context) context.Context","","\tclient       kubernetes.Interface","\tvwhlister    admissionlisters.ValidatingWebhookConfigurationLister","\tsecretlister corelisters.SecretLister","","\tdisallowUnknownFields bool","\tsecretName            string","}","","var _ controller.Reconciler = (*reconciler)(nil)","var _ pkgreconciler.LeaderAware = (*reconciler)(nil)","var _ webhook.AdmissionController = (*reconciler)(nil)","var _ webhook.StatelessAdmissionController = (*reconciler)(nil)","","// Reconcile implements controller.Reconciler","func (r *reconciler) Reconcile(ctx context.Context, key string) error {","\tlogger := logging.FromContext(ctx)","","\tif !r.IsLeaderFor(r.key) {","\t\treturn controller.NewSkipKey(key)","\t}","","\t// Look up the webhook secret, and fetch the CA cert bundle.","\tsecret, err := r.secretlister.Secrets(system.Namespace()).Get(r.secretName)","\tif err != nil {","\t\tlogger.Errorw(\"Error fetching secret\", zap.Error(err))","\t\treturn err","\t}","","\tcaCert, ok := secret.Data[certresources.CACert]","\tif !ok {","\t\treturn fmt.Errorf(\"secret %q is missing %q key\", r.secretName, certresources.CACert)","\t}","","\t// Reconcile the webhook configuration.","\treturn r.reconcileValidatingWebhook(ctx, caCert)","}","","func (r *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {","\tif r.withContext != nil {","\t\tctx = r.withContext(ctx)","\t}","","\tlogger := logging.FromContext(ctx)","\tkind := request.Kind","","\tnewBytes := request.Object.Raw","\tgvk := schema.GroupVersionKind{","\t\tGroup:   kind.Group,","\t\tVersion: kind.Version,","\t\tKind:    kind.Kind,","\t}","","\tif gvk.Group != Group || gvk.Version != Version || gvk.Kind != Kind {","\t\tlogger.Error(\"Unhandled kind: \", gvk)","\t}","","\t// Decode new object ","\tnewObj, err := r.decodeNewObject(newBytes)","\tif err != nil {","\t\treturn webhook.MakeErrorStatus(\"cannot decode incoming new object: %v\", err)","\t}","","\t// Validate structural requirements ","\tif err := validateApprovalTask(newObj, ctx); err != nil {","\t\treturn webhook.MakeErrorStatus(\"validation failed: %v\", err)","\t}","","\tif request.Operation == \"CREATE\" {","\t\t// For CREATE operations, ensure all approver inputs are set to \"pending\"","\t\tif err := validateApproverInputsForCreate(newObj); err != nil {","\t\t\treturn webhook.MakeErrorStatus(\"validation failed: %v\", err)","\t\t}","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: true,","\t\t}","\t}","","\tif request.Operation != \"UPDATE\" {","\t\treturn webhook.MakeErrorStatus(\"unsupported operation: %s\", request.Operation)","\t}","","\t// Decode old object for UPDATE operations","\toldObj, err := r.decodeOldObject(request.OldObject.Raw)","\tif err != nil {","\t\treturn webhook.MakeErrorStatus(\"cannot decode incoming old object: %v\", err)","\t}","","\t// Check if approval is required by the approver","\tif !isApprovalRequired(*oldObj) {","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tMessage: \"ApprovalTask has already reached it's final state\",","\t\t\t},","\t\t}","\t}","","\t// Check if username is mentioned in the approval task","\tif !ifUserExists(oldObj.Spec.Approvers, request) {","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tMessage: \"User does not exist in the approval list\",","\t\t\t},","\t\t}","\t}","","\t// Check if user is updating the input for his name only","\tvar userApprovalChanged bool","\terrMsg := fmt.Errorf(\"User can only update their own approval input\")","","\t// First check if user is trying to re-approve/re-reject their own already-decided task","\tif alreadyDecidedMsg := checkIfUserAlreadyDecided(oldObj, newObj, request); alreadyDecidedMsg != \"\" {","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tMessage: alreadyDecidedMsg,","\t\t\t},","\t\t}","\t}","","\tchanged, err := IsUserApprovalChanged(oldObj.Spec.Approvers, newObj.Spec.Approvers, request)","\tif err != nil {","\t\tuserApprovalChanged = false","\t\terrMsg = fmt.Errorf(\"Invalid input change: %v\", err)","\t} else if changed {","\t\tif CheckOtherUsersForInvalidChanges(oldObj.Spec.Approvers, newObj.Spec.Approvers, request) {","\t\t\tuserApprovalChanged = true","\t\t} else {","\t\t\tuserApprovalChanged = false","\t\t}","\t} else {","\t\tuserApprovalChanged = false","\t}","","\tif !userApprovalChanged {","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tMessage: errMsg.Error(),","\t\t\t},","\t\t}","\t}","","\treturn \u0026admissionv1.AdmissionResponse{","\t\tAllowed: true,","\t}","}","","func (ac *reconciler) reconcileValidatingWebhook(ctx context.Context, caCert []byte) error {","\tlogger := logging.FromContext(ctx)","\trules := []admissionregistrationv1.RuleWithOperations{","\t\t{","\t\t\tOperations: []admissionregistrationv1.OperationType{","\t\t\t\tadmissionregistrationv1.Create,","\t\t\t\tadmissionregistrationv1.Update,","\t\t\t},","\t\t\tRule: admissionregistrationv1.Rule{","\t\t\t\tAPIGroups:   []string{\"openshift-pipelines.org\"},","\t\t\t\tAPIVersions: []string{\"v1alpha1\"},","\t\t\t\tResources:   []string{\"approvaltask\", \"approvaltasks\"},","\t\t\t},","\t\t},","\t}","","\tconfiguredWebhook, err := ac.vwhlister.Get(ac.key.Name)","\tif err != nil {","\t\treturn err","\t}","","\twebhook := configuredWebhook.DeepCopy()","","\twebhook.OwnerReferences = nil","","\tfor i, wh := range webhook.Webhooks {","\t\tif wh.Name != webhook.Name {","\t\t\tcontinue","\t\t}","\t\twebhook.Webhooks[i].Rules = rules","\t\twebhook.Webhooks[i].ClientConfig.CABundle = caCert","\t\tif webhook.Webhooks[i].ClientConfig.Service == nil {","\t\t\treturn fmt.Errorf(\"missing service reference for webhook: %s\", wh.Name)","\t\t}","\t\twebhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())","\t}","","\tif ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil {","\t\treturn fmt.Errorf(\"error diffing webhooks: %w\", err)","\t} else if !ok {","\t\tlogger.Info(\"Updating webhook\")","\t\tvwhclient := ac.client.AdmissionregistrationV1().ValidatingWebhookConfigurations()","\t\tif _, err := vwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil {","\t\t\treturn fmt.Errorf(\"failed to update webhook: %w\", err)","\t\t}","\t} else {","\t\tlogger.Info(\"Webhook is valid\")","\t}","\treturn nil","}","","// Path implements AdmissionController","func (ac *reconciler) Path() string {","\treturn ac.path","}","","func ifUserExists(approvals []v1alpha1.ApproverDetails, request *admissionv1.AdmissionRequest) bool {","\tif len(approvals) == 0 {","\t\treturn true","\t}","\tfor _, approval := range approvals {","\t\tswitch v1alpha1.DefaultedApproverType(approval.Type) {","\t\tcase \"User\":","\t\t\tif approval.Name == request.UserInfo.Username {","\t\t\t\treturn true","\t\t\t}","\t\tcase \"Group\":","\t\t\t// Check if user is in the group by checking the group name against user's groups","\t\t\tfor _, userGroup := range request.UserInfo.Groups {","\t\t\t\tif approval.Name == userGroup {","\t\t\t\t\treturn true","\t\t\t\t}","\t\t\t}","\t\t\t// Also check if user is explicitly listed in the group's users","\t\t\tfor _, user := range approval.Users {","\t\t\t\tif user.Name == request.UserInfo.Username {","\t\t\t\t\treturn true","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\treturn false","}","","func isApprovalRequired(approvaltask v1alpha1.ApprovalTask) bool {","\t// If the task has reached a final state, no more approvals are needed","\tif approvaltask.Status.State == \"rejected\" || approvaltask.Status.State == \"approved\" {","\t\treturn false","\t}","\t","\t// Use the same logic as the controller to count approvals","\tapprovedUsers := make(map[string]bool)","\t","\tfor _, approver := range approvaltask.Spec.Approvers {","\t\tif approver.Input != \"approve\" {","\t\t\tcontinue","\t\t}","\t\t","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"User\" {","\t\t\tapprovedUsers[approver.Name] = true","\t\t} else if v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\tfor _, user := range approver.Users {","\t\t\t\tif user.Input == \"approve\" {","\t\t\t\t\tapprovedUsers[user.Name] = true","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\t","\t// If we have enough approvals, the task should be approved (final state)","\tif len(approvedUsers) \u003e= approvaltask.Spec.NumberOfApprovalsRequired {","\t\treturn false","\t}","\t","\treturn true","}","","// hasValidInputValue checks if the input value is either \"approve\" or \"reject\".","func hasValidInputValue(input string) error {","\tif input == \"approve\" || input == \"reject\" {","\t\treturn nil","\t}","\treturn fmt.Errorf(\"invalid input value: '%s'. Supported values are 'approve' or 'reject'\", input)","}","","// hasOnlyInputChanged checks if only the input field has changed for the current approver","// and if the new input value is valid","func hasOnlyInputChanged(oldObjApprover, newObjApprover v1alpha1.ApproverDetails) (bool, error) {","\tif oldObjApprover.Name == newObjApprover.Name \u0026\u0026 oldObjApprover.Input != newObjApprover.Input {","\t\tif err := hasValidInputValue(newObjApprover.Input); err != nil {","\t\t\treturn false, err","\t\t}","\t\treturn true, nil","\t}","\treturn false, nil","}","","// IsUserApprovalChanged checks if there is a valid input change for the current user.","func IsUserApprovalChanged(oldObjApprovers, newObjApprovers []v1alpha1.ApproverDetails, request *admissionv1.AdmissionRequest) (bool, error) {","\tcurrentUser := request.UserInfo.Username","\tfor i, approver := range oldObjApprovers {","\t\tif approver.Name == currentUser \u0026\u0026 v1alpha1.DefaultedApproverType(approver.Type) == \"User\" {","\t\t\treturn hasOnlyInputChanged(approver, newObjApprovers[i])","\t\t}","","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\t// Check if current user is a member of this group","\t\t\tisUserInGroup := false","","\t\t\t// Check if user is in the group by checking the group name against user's groups","\t\t\tfor _, userGroup := range request.UserInfo.Groups {","\t\t\t\tif approver.Name == userGroup {","\t\t\t\t\tisUserInGroup = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","","\t\t\t// Also check if user is explicitly listed in the group's users","\t\t\tfor _, user := range approver.Users {","\t\t\t\tif user.Name == currentUser {","\t\t\t\t\tisUserInGroup = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","","\t\t\tif isUserInGroup {","\t\t\t\t// Allow changes to group-level input if user is in the group","\t\t\t\tif i \u003c len(newObjApprovers) {","\t\t\t\t\tif approver.Input != newObjApprovers[i].Input {","\t\t\t\t\t\tif err := hasValidInputValue(newObjApprovers[i].Input); err != nil {","\t\t\t\t\t\t\treturn false, err","\t\t\t\t\t\t}","\t\t\t\t\t\treturn true, nil","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// Check if user is adding themselves to the group's users list","\t\t\t\toldUserFound := false","\t\t\t\tnewUserFound := false","","\t\t\t\tfor _, user := range approver.Users {","\t\t\t\t\tif user.Name == currentUser {","\t\t\t\t\t\toldUserFound = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\tif i \u003c len(newObjApprovers) {","\t\t\t\t\tfor _, user := range newObjApprovers[i].Users {","\t\t\t\t\t\tif user.Name == currentUser {","\t\t\t\t\t\t\tnewUserFound = true","\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// Allow user to add themselves to the group","\t\t\t\tif !oldUserFound \u0026\u0026 newUserFound {","\t\t\t\t\t// Validate the input they're setting for themselves","\t\t\t\t\tif i \u003c len(newObjApprovers) {","\t\t\t\t\t\tfor _, user := range newObjApprovers[i].Users {","\t\t\t\t\t\t\tif user.Name == currentUser {","\t\t\t\t\t\t\t\tif err := hasValidInputValue(user.Input); err != nil {","\t\t\t\t\t\t\t\t\treturn false, err","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\treturn true, nil","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\treturn true, nil","\t\t\t\t}","","\t\t\t\t// Allow changes to individual user inputs within the group","\t\t\t\t// Find current user in old users list","\t\t\t\tvar oldUserInput string","\t\t\t\tuserFoundInOld := false","\t\t\t\tfor _, user := range approver.Users {","\t\t\t\t\tif user.Name == currentUser {","\t\t\t\t\t\toldUserInput = user.Input","\t\t\t\t\t\tuserFoundInOld = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// Find current user in new users list","\t\t\t\tvar newUserInput string","\t\t\t\tuserFoundInNew := false","\t\t\t\tif i \u003c len(newObjApprovers) {","\t\t\t\t\tfor _, user := range newObjApprovers[i].Users {","\t\t\t\t\t\tif user.Name == currentUser {","\t\t\t\t\t\t\tnewUserInput = user.Input","\t\t\t\t\t\t\tuserFoundInNew = true","\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// Allow user to change their input if they're in both old and new lists","\t\t\t\tif userFoundInOld \u0026\u0026 userFoundInNew \u0026\u0026 oldUserInput != newUserInput {","\t\t\t\t\tif err := hasValidInputValue(newUserInput); err != nil {","\t\t\t\t\t\treturn false, err","\t\t\t\t\t}","\t\t\t\t\treturn true, nil","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\treturn false, nil","}","","// checkIfUserAlreadyDecided checks if a user is trying to re-approve/re-reject a task they've already decided on","func checkIfUserAlreadyDecided(oldObj *v1alpha1.ApprovalTask, newObj *v1alpha1.ApprovalTask, request *admissionv1.AdmissionRequest) string {","\tcurrentUser := request.UserInfo.Username","\t","\t// Get user's desired new input from the incoming object","\tdesiredInput := \"\"","\t","\t// First check if user is an individual approver","\tfor _, approver := range newObj.Spec.Approvers {","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"User\" \u0026\u0026 approver.Name == currentUser {","\t\t\tdesiredInput = approver.Input","\t\t\tbreak","\t\t}","\t}","\t","\t// If not found as individual user, check if user is in any group","\tif desiredInput == \"\" {","\t\tfor _, approver := range newObj.Spec.Approvers {","\t\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\t\t// Check if user is explicitly in the group's users list","\t\t\t\tfor _, user := range approver.Users {","\t\t\t\t\tif user.Name == currentUser {","\t\t\t\t\t\tdesiredInput = user.Input","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif desiredInput != \"\" {","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t\t","\t\t\t\t// Check if user is in the group via RBAC (group-level input)","\t\t\t\tfor _, userGroup := range request.UserInfo.Groups {","\t\t\t\t\tif approver.Name == userGroup {","\t\t\t\t\t\tdesiredInput = approver.Input","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif desiredInput != \"\" {","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\t","\t// Check status.approversResponse to see if user has already made a decision","\tfor _, approverResponse := range oldObj.Status.ApproversResponse {","\t\tif v1alpha1.DefaultedApproverType(approverResponse.Type) == \"User\" \u0026\u0026 approverResponse.Name == currentUser {","\t\t\t// Block duplicate approvals and any action after rejection","\t\t\tif approverResponse.Response == \"approved\" \u0026\u0026 desiredInput == \"approve\" {","\t\t\t\treturn \"User has already approved\"","\t\t\t} else if approverResponse.Response == \"rejected\" {","\t\t\t\treturn \"User has already rejected\"","\t\t\t}","\t\t}","\t\t","\t\t// Check if user is in any group that has responded","\t\tif v1alpha1.DefaultedApproverType(approverResponse.Type) == \"Group\" {","\t\t\tfor _, member := range approverResponse.GroupMembers {","\t\t\t\tif member.Name == currentUser {","\t\t\t\t\t// Block duplicate approvals and any action after rejection","\t\t\t\t\tif member.Response == \"approved\" \u0026\u0026 desiredInput == \"approve\" {","\t\t\t\t\t\treturn \"User has already approved\"","\t\t\t\t\t} else if member.Response == \"rejected\" {","\t\t\t\t\t\treturn \"User has already rejected\"","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\t","\treturn \"\" // No issue found","}","","// CheckOtherUsersForInvalidChanges validates that no other approvers inputs have been changed","func CheckOtherUsersForInvalidChanges(oldObjApprovers, newObjApprover []v1alpha1.ApproverDetails, request *admissionv1.AdmissionRequest) bool {","\tcurrentUser := request.UserInfo.Username","\tfor i, approver := range oldObjApprovers {","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"User\" \u0026\u0026 approver.Name != currentUser {","\t\t\tif oldObjApprovers[i].Input != newObjApprover[i].Input {","\t\t\t\treturn false","\t\t\t}","\t\t}","","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\t// Check if current user is a member of this group","\t\t\tisUserInGroup := false","","\t\t\t// Check if user is in the group by checking the group name against user's groups","\t\t\tfor _, userGroup := range request.UserInfo.Groups {","\t\t\t\tif approver.Name == userGroup {","\t\t\t\t\tisUserInGroup = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","","\t\t\t// Also check if user is explicitly listed in the group's users","\t\t\tfor _, user := range approver.Users {","\t\t\t\tif user.Name == currentUser {","\t\t\t\t\tisUserInGroup = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","","\t\t\t// If current user is not in this group, they shouldn't be able to change the group-level input","\t\t\tif !isUserInGroup {","\t\t\t\tif i \u003c len(newObjApprover) \u0026\u0026 approver.Input != newObjApprover[i].Input {","\t\t\t\t\treturn false","\t\t\t\t}","\t\t\t}","","\t\t\t// Check that only current user's input has changed in group users","\t\t\t// Build maps of existing users for easier comparison","\t\t\toldUsers := make(map[string]string) // name -\u003e input","\t\t\tnewUsers := make(map[string]string) // name -\u003e input","","\t\t\tfor _, user := range approver.Users {","\t\t\t\toldUsers[user.Name] = user.Input","\t\t\t}","","\t\t\tif i \u003c len(newObjApprover) {","\t\t\t\tfor _, user := range newObjApprover[i].Users {","\t\t\t\t\tnewUsers[user.Name] = user.Input","\t\t\t\t}","\t\t\t}","","\t\t\t// Check that existing users (other than current user) haven't changed their input","\t\t\tfor userName, oldInput := range oldUsers {","\t\t\t\tif userName != currentUser {","\t\t\t\t\tif newInput, exists := newUsers[userName]; exists {","\t\t\t\t\t\tif oldInput != newInput {","\t\t\t\t\t\t\treturn false // Someone else's input changed","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\t// Check that no unauthorized users were added to the group","\t\t\tfor userName := range newUsers {","\t\t\t\tif _, existedBefore := oldUsers[userName]; !existedBefore {","\t\t\t\t\t// Someone new was added - only allow if it's the current user and they're a group member","\t\t\t\t\tif userName != currentUser {","\t\t\t\t\t\treturn false // Someone other than current user was added","\t\t\t\t\t}","\t\t\t\t\tif !isUserInGroup {","\t\t\t\t\t\treturn false // Current user is not a member of this group","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\treturn true","}","","// validateApprovalTask validates the complete ApprovalTask resource ","func validateApprovalTask(approvalTask *v1alpha1.ApprovalTask, ctx context.Context) error {","\t// Validate spec","\tif err := validateApprovalTaskSpec(\u0026approvalTask.Spec, ctx); err != nil {","\t\treturn fmt.Errorf(\"spec validation failed: %w\", err)","\t}","\t","\treturn nil","}","","// validateApprovalTaskSpec validates the ApprovalTaskSpec","func validateApprovalTaskSpec(spec *v1alpha1.ApprovalTaskSpec, ctx context.Context) error {","\t// Validate numberOfApprovalsRequired bounds","\tif spec.NumberOfApprovalsRequired \u003c= 0 {","\t\treturn fmt.Errorf(\"numberOfApprovalsRequired: must be greater than 0, got %d\", spec.NumberOfApprovalsRequired)","\t}","","\t// Validate approvers list","\tif len(spec.Approvers) == 0 {","\t\treturn fmt.Errorf(\"approvers: required field is missing\")","\t}","","\t// Validate each approver and check for duplicates","\tapproverNames := make(map[string]int) // name -\u003e index","\tfor i, approver := range spec.Approvers {","\t\tfieldPath := fmt.Sprintf(\"approvers[%d]\", i)","\t\t","\t\tif err := validateApprover(approver, fieldPath); err != nil {","\t\t\treturn err","\t\t}","\t\t","\t\t// Check for duplicate approver names","\t\tapproverKey := fmt.Sprintf(\"%s:%s\", v1alpha1.DefaultedApproverType(approver.Type), approver.Name)","\t\tif existingIndex, exists := approverNames[approverKey]; exists {","\t\t\treturn fmt.Errorf(\"%s.name: duplicate approver '%s' (also found at approvers[%d])\", fieldPath, approver.Name, existingIndex)","\t\t}","\t\tapproverNames[approverKey] = i","\t}","","\treturn nil","}","","// validateApprover validates a single approver entry","func validateApprover(approver v1alpha1.ApproverDetails, fieldPath string) error {","\t// Validate approver type first to determine validation rules","\tapproverType := v1alpha1.DefaultedApproverType(approver.Type)","\tif approverType != \"User\" \u0026\u0026 approverType != \"Group\" {","\t\treturn fmt.Errorf(\"%s.type: must be either 'User' or 'Group', got '%s'\", fieldPath, approver.Type)","\t}","","\t// Validate name format based on type (includes empty check via validateNameFormat)","\tif approverType == \"User\" {","\t\tif err := validateUserName(approver.Name); err != nil {","\t\t\treturn fmt.Errorf(\"%s.name: %w\", fieldPath, err)","\t\t}","\t} else if approverType == \"Group\" {","\t\tif err := validateGroupName(approver.Name); err != nil {","\t\t\treturn fmt.Errorf(\"%s.name: %w\", fieldPath, err)","\t\t}","\t}","","\t// Validate input value","\tvalidInputs := []string{\"pending\", \"approve\", \"reject\"}","\tif !webhookContains(validInputs, approver.Input) {","\t\treturn fmt.Errorf(\"%s.input: must be one of: %s, got '%s'\", fieldPath, strings.Join(validInputs, \", \"), approver.Input)","\t}","","\t// Validate users for group type","\tif approverType == \"Group\" {","\t\t","\t\t// Track duplicate users within the group","\t\tgroupUsers := make(map[string]int) // username -\u003e index","\t\tfor j, user := range approver.Users {","\t\t\tuserFieldPath := fmt.Sprintf(\"%s.users[%d]\", fieldPath, j)","\t\t\t","\t\t\tif strings.TrimSpace(user.Name) == \"\" {","\t\t\t\treturn fmt.Errorf(\"%s.name: required field is missing\", userFieldPath)","\t\t\t} else if err := validateUserName(user.Name); err != nil {","\t\t\t\treturn fmt.Errorf(\"%s.name: %w\", userFieldPath, err)","\t\t\t}","\t\t\t","\t\t\t// Check for duplicate users within the group","\t\t\tif existingIndex, exists := groupUsers[user.Name]; exists {","\t\t\t\treturn fmt.Errorf(\"%s.name: duplicate user '%s' within group (also found at %s.users[%d])\", userFieldPath, user.Name, fieldPath, existingIndex)","\t\t\t}","\t\t\tgroupUsers[user.Name] = j","","\t\t\tif !webhookContains(validInputs, user.Input) {","\t\t\t\treturn fmt.Errorf(\"%s.input: must be one of: %s, got '%s'\", userFieldPath, strings.Join(validInputs, \", \"), user.Input)","\t\t\t}","\t\t}","\t}","","\treturn nil","}","","// validateNameFormat performs common name validation checks","func validateNameFormat(name, fieldType string) error {","\tif strings.TrimSpace(name) == \"\" {","\t\treturn fmt.Errorf(\"%s cannot be empty\", fieldType)","\t}","\t","\t// Kubernetes names cannot contain spaces","\tif strings.Contains(name, \" \") {","\t\treturn fmt.Errorf(\"%s cannot contain spaces\", fieldType)","\t}","\t","\treturn nil","}","","// validateUserName validates username","func validateUserName(name string) error {","\t// Basic empty check (spaces ARE allowed in usernames for LDAP integration)","\tif strings.TrimSpace(name) == \"\" {","\t\treturn fmt.Errorf(\"username cannot be empty\")","\t}","\t","\tif strings.HasPrefix(name, \"group:\") {","\t\treturn fmt.Errorf(\"username cannot start with 'group:' prefix - use type: Group for group approvers\")","\t}","\t","\treturn nil","}","","// validateGroupName validates group name format","func validateGroupName(name string) error {","\tif err := validateNameFormat(name, \"group name\"); err != nil {","\t\treturn err","\t}","\t","\t// Group names should not contain colons to avoid confusion with user prefixes","\tif strings.Contains(name, \":\") {","\t\treturn fmt.Errorf(\"group name cannot contain colons\")","\t}","\t","\treturn nil","}","","// webhookContains checks if a slice contains a string","func webhookContains(slice []string, item string) bool {","\tfor _, s := range slice {","\t\tif s == item {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","// decodeNewObject decodes the incoming new object","func (r *reconciler) decodeNewObject(newBytes []byte) (*v1alpha1.ApprovalTask, error) {","\tvar newObj v1alpha1.ApprovalTask","\tif len(newBytes) != 0 {","\t\tnewDecoder := json.NewDecoder(bytes.NewBuffer(newBytes))","\t\tif r.disallowUnknownFields {","\t\t\tnewDecoder.DisallowUnknownFields()","\t\t}","\t\tif err := newDecoder.Decode(\u0026newObj); err != nil {","\t\t\treturn nil, err","\t\t}","\t}","\treturn \u0026newObj, nil","}","","// decodeOldObject decodes the incoming old object","func (r *reconciler) decodeOldObject(oldBytes []byte) (*v1alpha1.ApprovalTask, error) {","\tvar oldObj v1alpha1.ApprovalTask","\tif len(oldBytes) != 0 {","\t\toldDecoder := json.NewDecoder(bytes.NewBuffer(oldBytes))","\t\tif r.disallowUnknownFields {","\t\t\toldDecoder.DisallowUnknownFields()","\t\t}","\t\tif err := oldDecoder.Decode(\u0026oldObj); err != nil {","\t\t\treturn nil, err","\t\t}","\t}","\treturn \u0026oldObj, nil","}","","// validateApproverInputsForCreate ensures all approver inputs are set to \"pending\" for new ApprovalTask resources","func validateApproverInputsForCreate(approvalTask *v1alpha1.ApprovalTask) error {","\tfor i, approver := range approvalTask.Spec.Approvers {","\t\tif approver.Input != \"pending\" {","\t\t\treturn fmt.Errorf(\"approvers[%d].input: must be 'pending' for new ApprovalTask, got '%s'\", i, approver.Input)","\t\t}","\t\t","\t\t// For group approvers, also validate that all users within the group have pending input","\t\tif v1alpha1.DefaultedApproverType(approver.Type) == \"Group\" {","\t\t\tfor j, user := range approver.Users {","\t\t\t\tif user.Input != \"pending\" {","\t\t\t\t\treturn fmt.Errorf(\"approvers[%d].users[%d].input: must be 'pending' for new ApprovalTask, got '%s'\", i, j, user.Input)","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,1,0]},{"id":36,"path":"third_party/github.com/hashicorp/errwrap/errwrap.go","lines":["// Package errwrap implements methods to formalize error wrapping in Go.","//","// All of the top-level functions that take an `error` are built to be able","// to take any error, not just wrapped errors. This allows you to use errwrap","// without having to type-check and type-cast everywhere.","package errwrap","","import (","\t\"errors\"","\t\"reflect\"","\t\"strings\"",")","","// WalkFunc is the callback called for Walk.","type WalkFunc func(error)","","// Wrapper is an interface that can be implemented by custom types to","// have all the Contains, Get, etc. functions in errwrap work.","//","// When Walk reaches a Wrapper, it will call the callback for every","// wrapped error in addition to the wrapper itself. Since all the top-level","// functions in errwrap use Walk, this means that all those functions work","// with your custom type.","type Wrapper interface {","\tWrappedErrors() []error","}","","// Wrap defines that outer wraps inner, returning an error type that","// can be cleanly used with the other methods in this package, such as","// Contains, GetAll, etc.","//","// This function won't modify the error message at all (the outer message","// will be used).","func Wrap(outer, inner error) error {","\treturn \u0026wrappedError{","\t\tOuter: outer,","\t\tInner: inner,","\t}","}","","// Wrapf wraps an error with a formatting message. This is similar to using","// `fmt.Errorf` to wrap an error. If you're using `fmt.Errorf` to wrap","// errors, you should replace it with this.","//","// format is the format of the error message. The string '{{err}}' will","// be replaced with the original error message.","//","// Deprecated: Use fmt.Errorf()","func Wrapf(format string, err error) error {","\touterMsg := \"\u003cnil\u003e\"","\tif err != nil {","\t\touterMsg = err.Error()","\t}","","\touter := errors.New(strings.Replace(","\t\tformat, \"{{err}}\", outerMsg, -1))","","\treturn Wrap(outer, err)","}","","// Contains checks if the given error contains an error with the","// message msg. If err is not a wrapped error, this will always return","// false unless the error itself happens to match this msg.","func Contains(err error, msg string) bool {","\treturn len(GetAll(err, msg)) \u003e 0","}","","// ContainsType checks if the given error contains an error with","// the same concrete type as v. If err is not a wrapped error, this will","// check the err itself.","func ContainsType(err error, v interface{}) bool {","\treturn len(GetAllType(err, v)) \u003e 0","}","","// Get is the same as GetAll but returns the deepest matching error.","func Get(err error, msg string) error {","\tes := GetAll(err, msg)","\tif len(es) \u003e 0 {","\t\treturn es[len(es)-1]","\t}","","\treturn nil","}","","// GetType is the same as GetAllType but returns the deepest matching error.","func GetType(err error, v interface{}) error {","\tes := GetAllType(err, v)","\tif len(es) \u003e 0 {","\t\treturn es[len(es)-1]","\t}","","\treturn nil","}","","// GetAll gets all the errors that might be wrapped in err with the","// given message. The order of the errors is such that the outermost","// matching error (the most recent wrap) is index zero, and so on.","func GetAll(err error, msg string) []error {","\tvar result []error","","\tWalk(err, func(err error) {","\t\tif err.Error() == msg {","\t\t\tresult = append(result, err)","\t\t}","\t})","","\treturn result","}","","// GetAllType gets all the errors that are the same type as v.","//","// The order of the return value is the same as described in GetAll.","func GetAllType(err error, v interface{}) []error {","\tvar result []error","","\tvar search string","\tif v != nil {","\t\tsearch = reflect.TypeOf(v).String()","\t}","\tWalk(err, func(err error) {","\t\tvar needle string","\t\tif err != nil {","\t\t\tneedle = reflect.TypeOf(err).String()","\t\t}","","\t\tif needle == search {","\t\t\tresult = append(result, err)","\t\t}","\t})","","\treturn result","}","","// Walk walks all the wrapped errors in err and calls the callback. If","// err isn't a wrapped error, this will be called once for err. If err","// is a wrapped error, the callback will be called for both the wrapper","// that implements error as well as the wrapped error itself.","func Walk(err error, cb WalkFunc) {","\tif err == nil {","\t\treturn","\t}","","\tswitch e := err.(type) {","\tcase *wrappedError:","\t\tcb(e.Outer)","\t\tWalk(e.Inner, cb)","\tcase Wrapper:","\t\tcb(err)","","\t\tfor _, err := range e.WrappedErrors() {","\t\t\tWalk(err, cb)","\t\t}","\tcase interface{ Unwrap() error }:","\t\tcb(err)","\t\tWalk(e.Unwrap(), cb)","\tdefault:","\t\tcb(err)","\t}","}","","// wrappedError is an implementation of error that has both the","// outer and inner errors.","type wrappedError struct {","\tOuter error","\tInner error","}","","func (w *wrappedError) Error() string {","\treturn w.Outer.Error()","}","","func (w *wrappedError) WrappedErrors() []error {","\treturn []error{w.Outer, w.Inner}","}","","func (w *wrappedError) Unwrap() error {","\treturn w.Inner","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1]},{"id":37,"path":"third_party/github.com/hashicorp/go-multierror/append.go","lines":["package multierror","","// Append is a helper function that will append more errors","// onto an Error in order to create a larger multi-error.","//","// If err is not a multierror.Error, then it will be turned into","// one. If any of the errs are multierr.Error, they will be flattened","// one level into err.","// Any nil errors within errs will be ignored. If err is nil, a new","// *Error will be returned.","func Append(err error, errs ...error) *Error {","\tswitch err := err.(type) {","\tcase *Error:","\t\t// Typed nils can reach here, so initialize if we are nil","\t\tif err == nil {","\t\t\terr = new(Error)","\t\t}","","\t\t// Go through each error and flatten","\t\tfor _, e := range errs {","\t\t\tswitch e := e.(type) {","\t\t\tcase *Error:","\t\t\t\tif e != nil {","\t\t\t\t\terr.Errors = append(err.Errors, e.Errors...)","\t\t\t\t}","\t\t\tdefault:","\t\t\t\tif e != nil {","\t\t\t\t\terr.Errors = append(err.Errors, e)","\t\t\t\t}","\t\t\t}","\t\t}","","\t\treturn err","\tdefault:","\t\tnewErrs := make([]error, 0, len(errs)+1)","\t\tif err != nil {","\t\t\tnewErrs = append(newErrs, err)","\t\t}","\t\tnewErrs = append(newErrs, errs...)","","\t\treturn Append(\u0026Error{}, newErrs...)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0]},{"id":38,"path":"third_party/github.com/hashicorp/go-multierror/flatten.go","lines":["package multierror","","// Flatten flattens the given error, merging any *Errors together into","// a single *Error.","func Flatten(err error) error {","\t// If it isn't an *Error, just return the error as-is","\tif _, ok := err.(*Error); !ok {","\t\treturn err","\t}","","\t// Otherwise, make the result and flatten away!","\tflatErr := new(Error)","\tflatten(err, flatErr)","\treturn flatErr","}","","func flatten(err error, flatErr *Error) {","\tswitch err := err.(type) {","\tcase *Error:","\t\tfor _, e := range err.Errors {","\t\t\tflatten(e, flatErr)","\t\t}","\tdefault:","\t\tflatErr.Errors = append(flatErr.Errors, err)","\t}","}"],"coverage":[0,0,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0]},{"id":39,"path":"third_party/github.com/hashicorp/go-multierror/format.go","lines":["package multierror","","import (","\t\"fmt\"","\t\"strings\"",")","","// ErrorFormatFunc is a function callback that is called by Error to","// turn the list of errors into a string.","type ErrorFormatFunc func([]error) string","","// ListFormatFunc is a basic formatter that outputs the number of errors","// that occurred along with a bullet point list of the errors.","func ListFormatFunc(es []error) string {","\tif len(es) == 1 {","\t\treturn fmt.Sprintf(\"1 error occurred:\\n\\t* %s\\n\\n\", es[0])","\t}","","\tpoints := make([]string, len(es))","\tfor i, err := range es {","\t\tpoints[i] = fmt.Sprintf(\"* %s\", err)","\t}","","\treturn fmt.Sprintf(","\t\t\"%d errors occurred:\\n\\t%s\\n\\n\",","\t\tlen(es), strings.Join(points, \"\\n\\t\"))","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0]},{"id":40,"path":"third_party/github.com/hashicorp/go-multierror/group.go","lines":["package multierror","","import \"sync\"","","// Group is a collection of goroutines which return errors that need to be","// coalesced.","type Group struct {","\tmutex sync.Mutex","\terr   *Error","\twg    sync.WaitGroup","}","","// Go calls the given function in a new goroutine.","//","// If the function returns an error it is added to the group multierror which","// is returned by Wait.","func (g *Group) Go(f func() error) {","\tg.wg.Add(1)","","\tgo func() {","\t\tdefer g.wg.Done()","","\t\tif err := f(); err != nil {","\t\t\tg.mutex.Lock()","\t\t\tg.err = Append(g.err, err)","\t\t\tg.mutex.Unlock()","\t\t}","\t}()","}","","// Wait blocks until all function calls from the Go method have returned, then","// returns the multierror.","func (g *Group) Wait() *Error {","\tg.wg.Wait()","\tg.mutex.Lock()","\tdefer g.mutex.Unlock()","\treturn g.err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1]},{"id":41,"path":"third_party/github.com/hashicorp/go-multierror/multierror.go","lines":["package multierror","","import (","\t\"errors\"","\t\"fmt\"",")","","// Error is an error type to track multiple errors. This is used to","// accumulate errors in cases and return them as a single \"error\".","type Error struct {","\tErrors      []error","\tErrorFormat ErrorFormatFunc","}","","func (e *Error) Error() string {","\tfn := e.ErrorFormat","\tif fn == nil {","\t\tfn = ListFormatFunc","\t}","","\treturn fn(e.Errors)","}","","// ErrorOrNil returns an error interface if this Error represents","// a list of errors, or returns nil if the list of errors is empty. This","// function is useful at the end of accumulation to make sure that the value","// returned represents the existence of errors.","func (e *Error) ErrorOrNil() error {","\tif e == nil {","\t\treturn nil","\t}","\tif len(e.Errors) == 0 {","\t\treturn nil","\t}","","\treturn e","}","","func (e *Error) GoString() string {","\treturn fmt.Sprintf(\"*%#v\", *e)","}","","// WrappedErrors returns the list of errors that this Error is wrapping. It is","// an implementation of the errwrap.Wrapper interface so that multierror.Error","// can be used with that library.","//","// This method is not safe to be called concurrently. Unlike accessing the","// Errors field directly, this function also checks if the multierror is nil to","// prevent a null-pointer panic. It satisfies the errwrap.Wrapper interface.","func (e *Error) WrappedErrors() []error {","\tif e == nil {","\t\treturn nil","\t}","\treturn e.Errors","}","","// Unwrap returns an error from Error (or nil if there are no errors).","// This error returned will further support Unwrap to get the next error,","// etc. The order will match the order of Errors in the multierror.Error","// at the time of calling.","//","// The resulting error supports errors.As/Is/Unwrap so you can continue","// to use the stdlib errors package to introspect further.","//","// This will perform a shallow copy of the errors slice. Any errors appended","// to this error after calling Unwrap will not be available until a new","// Unwrap is called on the multierror.Error.","func (e *Error) Unwrap() error {","\t// If we have no errors then we do nothing","\tif e == nil || len(e.Errors) == 0 {","\t\treturn nil","\t}","","\t// If we have exactly one error, we can just return that directly.","\tif len(e.Errors) == 1 {","\t\treturn e.Errors[0]","\t}","","\t// Shallow copy the slice","\terrs := make([]error, len(e.Errors))","\tcopy(errs, e.Errors)","\treturn chain(errs)","}","","// chain implements the interfaces necessary for errors.Is/As/Unwrap to","// work in a deterministic way with multierror. A chain tracks a list of","// errors while accounting for the current represented error. This lets","// Is/As be meaningful.","//","// Unwrap returns the next error. In the cleanest form, Unwrap would return","// the wrapped error here but we can't do that if we want to properly","// get access to all the errors. Instead, users are recommended to use","// Is/As to get the correct error type out.","//","// Precondition: []error is non-empty (len \u003e 0)","type chain []error","","// Error implements the error interface","func (e chain) Error() string {","\treturn e[0].Error()","}","","// Unwrap implements errors.Unwrap by returning the next error in the","// chain or nil if there are no more errors.","func (e chain) Unwrap() error {","\tif len(e) == 1 {","\t\treturn nil","\t}","","\treturn e[1:]","}","","// As implements errors.As by attempting to map to the current value.","func (e chain) As(target interface{}) bool {","\treturn errors.As(e[0], target)","}","","// Is implements errors.Is by comparing the current value directly.","func (e chain) Is(target error) bool {","\treturn errors.Is(e[0], target)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,1]},{"id":42,"path":"third_party/github.com/hashicorp/go-multierror/prefix.go","lines":["package multierror","","import (","\t\"fmt\"","","\t\"github.com/hashicorp/errwrap\"",")","","// Prefix is a helper function that will prefix some text","// to the given error. If the error is a multierror.Error, then","// it will be prefixed to each wrapped error.","//","// This is useful to use when appending multiple multierrors","// together in order to give better scoping.","func Prefix(err error, prefix string) error {","\tif err == nil {","\t\treturn nil","\t}","","\tformat := fmt.Sprintf(\"%s {{err}}\", prefix)","\tswitch err := err.(type) {","\tcase *Error:","\t\t// Typed nils can reach here, so initialize if we are nil","\t\tif err == nil {","\t\t\terr = new(Error)","\t\t}","","\t\t// Wrap each of the errors","\t\tfor i, e := range err.Errors {","\t\t\terr.Errors[i] = errwrap.Wrapf(format, e)","\t\t}","","\t\treturn err","\tdefault:","\t\treturn errwrap.Wrapf(format, err)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,0,0]},{"id":43,"path":"third_party/github.com/hashicorp/go-multierror/sort.go","lines":["package multierror","","// Len implements sort.Interface function for length","func (err Error) Len() int {","\treturn len(err.Errors)","}","","// Swap implements sort.Interface function for swapping elements","func (err Error) Swap(i, j int) {","\terr.Errors[i], err.Errors[j] = err.Errors[j], err.Errors[i]","}","","// Less implements sort.Interface function for determining order","func (err Error) Less(i, j int) bool {","\treturn err.Errors[i].Error() \u003c err.Errors[j].Error()","}"],"coverage":[0,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":44,"path":"third_party/github.com/hashicorp/golang-lru/2q.go","lines":["package lru","","import (","\t\"fmt\"","\t\"sync\"","","\t\"github.com/hashicorp/golang-lru/simplelru\"",")","","const (","\t// Default2QRecentRatio is the ratio of the 2Q cache dedicated","\t// to recently added entries that have only been accessed once.","\tDefault2QRecentRatio = 0.25","","\t// Default2QGhostEntries is the default ratio of ghost","\t// entries kept to track entries recently evicted","\tDefault2QGhostEntries = 0.50",")","","// TwoQueueCache is a thread-safe fixed size 2Q cache.","// 2Q is an enhancement over the standard LRU cache","// in that it tracks both frequently and recently used","// entries separately. This avoids a burst in access to new","// entries from evicting frequently used entries. It adds some","// additional tracking overhead to the standard LRU cache, and is","// computationally about 2x the cost, and adds some metadata over","// head. The ARCCache is similar, but does not require setting any","// parameters.","type TwoQueueCache struct {","\tsize       int","\trecentSize int","","\trecent      simplelru.LRUCache","\tfrequent    simplelru.LRUCache","\trecentEvict simplelru.LRUCache","\tlock        sync.RWMutex","}","","// New2Q creates a new TwoQueueCache using the default","// values for the parameters.","func New2Q(size int) (*TwoQueueCache, error) {","\treturn New2QParams(size, Default2QRecentRatio, Default2QGhostEntries)","}","","// New2QParams creates a new TwoQueueCache using the provided","// parameter values.","func New2QParams(size int, recentRatio, ghostRatio float64) (*TwoQueueCache, error) {","\tif size \u003c= 0 {","\t\treturn nil, fmt.Errorf(\"invalid size\")","\t}","\tif recentRatio \u003c 0.0 || recentRatio \u003e 1.0 {","\t\treturn nil, fmt.Errorf(\"invalid recent ratio\")","\t}","\tif ghostRatio \u003c 0.0 || ghostRatio \u003e 1.0 {","\t\treturn nil, fmt.Errorf(\"invalid ghost ratio\")","\t}","","\t// Determine the sub-sizes","\trecentSize := int(float64(size) * recentRatio)","\tevictSize := int(float64(size) * ghostRatio)","","\t// Allocate the LRUs","\trecent, err := simplelru.NewLRU(size, nil)","\tif err != nil {","\t\treturn nil, err","\t}","\tfrequent, err := simplelru.NewLRU(size, nil)","\tif err != nil {","\t\treturn nil, err","\t}","\trecentEvict, err := simplelru.NewLRU(evictSize, nil)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Initialize the cache","\tc := \u0026TwoQueueCache{","\t\tsize:        size,","\t\trecentSize:  recentSize,","\t\trecent:      recent,","\t\tfrequent:    frequent,","\t\trecentEvict: recentEvict,","\t}","\treturn c, nil","}","","// Get looks up a key's value from the cache.","func (c *TwoQueueCache) Get(key interface{}) (value interface{}, ok bool) {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","","\t// Check if this is a frequent value","\tif val, ok := c.frequent.Get(key); ok {","\t\treturn val, ok","\t}","","\t// If the value is contained in recent, then we","\t// promote it to frequent","\tif val, ok := c.recent.Peek(key); ok {","\t\tc.recent.Remove(key)","\t\tc.frequent.Add(key, val)","\t\treturn val, ok","\t}","","\t// No hit","\treturn nil, false","}","","// Add adds a value to the cache.","func (c *TwoQueueCache) Add(key, value interface{}) {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","","\t// Check if the value is frequently used already,","\t// and just update the value","\tif c.frequent.Contains(key) {","\t\tc.frequent.Add(key, value)","\t\treturn","\t}","","\t// Check if the value is recently used, and promote","\t// the value into the frequent list","\tif c.recent.Contains(key) {","\t\tc.recent.Remove(key)","\t\tc.frequent.Add(key, value)","\t\treturn","\t}","","\t// If the value was recently evicted, add it to the","\t// frequently used list","\tif c.recentEvict.Contains(key) {","\t\tc.ensureSpace(true)","\t\tc.recentEvict.Remove(key)","\t\tc.frequent.Add(key, value)","\t\treturn","\t}","","\t// Add to the recently seen list","\tc.ensureSpace(false)","\tc.recent.Add(key, value)","}","","// ensureSpace is used to ensure we have space in the cache","func (c *TwoQueueCache) ensureSpace(recentEvict bool) {","\t// If we have space, nothing to do","\trecentLen := c.recent.Len()","\tfreqLen := c.frequent.Len()","\tif recentLen+freqLen \u003c c.size {","\t\treturn","\t}","","\t// If the recent buffer is larger than","\t// the target, evict from there","\tif recentLen \u003e 0 \u0026\u0026 (recentLen \u003e c.recentSize || (recentLen == c.recentSize \u0026\u0026 !recentEvict)) {","\t\tk, _, _ := c.recent.RemoveOldest()","\t\tc.recentEvict.Add(k, nil)","\t\treturn","\t}","","\t// Remove from the frequent list otherwise","\tc.frequent.RemoveOldest()","}","","// Len returns the number of items in the cache.","func (c *TwoQueueCache) Len() int {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\treturn c.recent.Len() + c.frequent.Len()","}","","// Keys returns a slice of the keys in the cache.","// The frequently used keys are first in the returned slice.","func (c *TwoQueueCache) Keys() []interface{} {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\tk1 := c.frequent.Keys()","\tk2 := c.recent.Keys()","\treturn append(k1, k2...)","}","","// Remove removes the provided key from the cache.","func (c *TwoQueueCache) Remove(key interface{}) {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","\tif c.frequent.Remove(key) {","\t\treturn","\t}","\tif c.recent.Remove(key) {","\t\treturn","\t}","\tif c.recentEvict.Remove(key) {","\t\treturn","\t}","}","","// Purge is used to completely clear the cache.","func (c *TwoQueueCache) Purge() {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","\tc.recent.Purge()","\tc.frequent.Purge()","\tc.recentEvict.Purge()","}","","// Contains is used to check if the cache contains a key","// without updating recency or frequency.","func (c *TwoQueueCache) Contains(key interface{}) bool {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\treturn c.frequent.Contains(key) || c.recent.Contains(key)","}","","// Peek is used to inspect the cache value of a key","// without updating recency or frequency.","func (c *TwoQueueCache) Peek(key interface{}) (value interface{}, ok bool) {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\tif val, ok := c.frequent.Peek(key); ok {","\t\treturn val, ok","\t}","\treturn c.recent.Peek(key)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0]},{"id":45,"path":"third_party/github.com/hashicorp/golang-lru/arc.go","lines":["package lru","","import (","\t\"sync\"","","\t\"github.com/hashicorp/golang-lru/simplelru\"",")","","// ARCCache is a thread-safe fixed size Adaptive Replacement Cache (ARC).","// ARC is an enhancement over the standard LRU cache in that tracks both","// frequency and recency of use. This avoids a burst in access to new","// entries from evicting the frequently used older entries. It adds some","// additional tracking overhead to a standard LRU cache, computationally","// it is roughly 2x the cost, and the extra memory overhead is linear","// with the size of the cache. ARC has been patented by IBM, but is","// similar to the TwoQueueCache (2Q) which requires setting parameters.","type ARCCache struct {","\tsize int // Size is the total capacity of the cache","\tp    int // P is the dynamic preference towards T1 or T2","","\tt1 simplelru.LRUCache // T1 is the LRU for recently accessed items","\tb1 simplelru.LRUCache // B1 is the LRU for evictions from t1","","\tt2 simplelru.LRUCache // T2 is the LRU for frequently accessed items","\tb2 simplelru.LRUCache // B2 is the LRU for evictions from t2","","\tlock sync.RWMutex","}","","// NewARC creates an ARC of the given size","func NewARC(size int) (*ARCCache, error) {","\t// Create the sub LRUs","\tb1, err := simplelru.NewLRU(size, nil)","\tif err != nil {","\t\treturn nil, err","\t}","\tb2, err := simplelru.NewLRU(size, nil)","\tif err != nil {","\t\treturn nil, err","\t}","\tt1, err := simplelru.NewLRU(size, nil)","\tif err != nil {","\t\treturn nil, err","\t}","\tt2, err := simplelru.NewLRU(size, nil)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Initialize the ARC","\tc := \u0026ARCCache{","\t\tsize: size,","\t\tp:    0,","\t\tt1:   t1,","\t\tb1:   b1,","\t\tt2:   t2,","\t\tb2:   b2,","\t}","\treturn c, nil","}","","// Get looks up a key's value from the cache.","func (c *ARCCache) Get(key interface{}) (value interface{}, ok bool) {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","","\t// If the value is contained in T1 (recent), then","\t// promote it to T2 (frequent)","\tif val, ok := c.t1.Peek(key); ok {","\t\tc.t1.Remove(key)","\t\tc.t2.Add(key, val)","\t\treturn val, ok","\t}","","\t// Check if the value is contained in T2 (frequent)","\tif val, ok := c.t2.Get(key); ok {","\t\treturn val, ok","\t}","","\t// No hit","\treturn nil, false","}","","// Add adds a value to the cache.","func (c *ARCCache) Add(key, value interface{}) {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","","\t// Check if the value is contained in T1 (recent), and potentially","\t// promote it to frequent T2","\tif c.t1.Contains(key) {","\t\tc.t1.Remove(key)","\t\tc.t2.Add(key, value)","\t\treturn","\t}","","\t// Check if the value is already in T2 (frequent) and update it","\tif c.t2.Contains(key) {","\t\tc.t2.Add(key, value)","\t\treturn","\t}","","\t// Check if this value was recently evicted as part of the","\t// recently used list","\tif c.b1.Contains(key) {","\t\t// T1 set is too small, increase P appropriately","\t\tdelta := 1","\t\tb1Len := c.b1.Len()","\t\tb2Len := c.b2.Len()","\t\tif b2Len \u003e b1Len {","\t\t\tdelta = b2Len / b1Len","\t\t}","\t\tif c.p+delta \u003e= c.size {","\t\t\tc.p = c.size","\t\t} else {","\t\t\tc.p += delta","\t\t}","","\t\t// Potentially need to make room in the cache","\t\tif c.t1.Len()+c.t2.Len() \u003e= c.size {","\t\t\tc.replace(false)","\t\t}","","\t\t// Remove from B1","\t\tc.b1.Remove(key)","","\t\t// Add the key to the frequently used list","\t\tc.t2.Add(key, value)","\t\treturn","\t}","","\t// Check if this value was recently evicted as part of the","\t// frequently used list","\tif c.b2.Contains(key) {","\t\t// T2 set is too small, decrease P appropriately","\t\tdelta := 1","\t\tb1Len := c.b1.Len()","\t\tb2Len := c.b2.Len()","\t\tif b1Len \u003e b2Len {","\t\t\tdelta = b1Len / b2Len","\t\t}","\t\tif delta \u003e= c.p {","\t\t\tc.p = 0","\t\t} else {","\t\t\tc.p -= delta","\t\t}","","\t\t// Potentially need to make room in the cache","\t\tif c.t1.Len()+c.t2.Len() \u003e= c.size {","\t\t\tc.replace(true)","\t\t}","","\t\t// Remove from B2","\t\tc.b2.Remove(key)","","\t\t// Add the key to the frequently used list","\t\tc.t2.Add(key, value)","\t\treturn","\t}","","\t// Potentially need to make room in the cache","\tif c.t1.Len()+c.t2.Len() \u003e= c.size {","\t\tc.replace(false)","\t}","","\t// Keep the size of the ghost buffers trim","\tif c.b1.Len() \u003e c.size-c.p {","\t\tc.b1.RemoveOldest()","\t}","\tif c.b2.Len() \u003e c.p {","\t\tc.b2.RemoveOldest()","\t}","","\t// Add to the recently seen list","\tc.t1.Add(key, value)","}","","// replace is used to adaptively evict from either T1 or T2","// based on the current learned value of P","func (c *ARCCache) replace(b2ContainsKey bool) {","\tt1Len := c.t1.Len()","\tif t1Len \u003e 0 \u0026\u0026 (t1Len \u003e c.p || (t1Len == c.p \u0026\u0026 b2ContainsKey)) {","\t\tk, _, ok := c.t1.RemoveOldest()","\t\tif ok {","\t\t\tc.b1.Add(k, nil)","\t\t}","\t} else {","\t\tk, _, ok := c.t2.RemoveOldest()","\t\tif ok {","\t\t\tc.b2.Add(k, nil)","\t\t}","\t}","}","","// Len returns the number of cached entries","func (c *ARCCache) Len() int {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\treturn c.t1.Len() + c.t2.Len()","}","","// Keys returns all the cached keys","func (c *ARCCache) Keys() []interface{} {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\tk1 := c.t1.Keys()","\tk2 := c.t2.Keys()","\treturn append(k1, k2...)","}","","// Remove is used to purge a key from the cache","func (c *ARCCache) Remove(key interface{}) {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","\tif c.t1.Remove(key) {","\t\treturn","\t}","\tif c.t2.Remove(key) {","\t\treturn","\t}","\tif c.b1.Remove(key) {","\t\treturn","\t}","\tif c.b2.Remove(key) {","\t\treturn","\t}","}","","// Purge is used to clear the cache","func (c *ARCCache) Purge() {","\tc.lock.Lock()","\tdefer c.lock.Unlock()","\tc.t1.Purge()","\tc.t2.Purge()","\tc.b1.Purge()","\tc.b2.Purge()","}","","// Contains is used to check if the cache contains a key","// without updating recency or frequency.","func (c *ARCCache) Contains(key interface{}) bool {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\treturn c.t1.Contains(key) || c.t2.Contains(key)","}","","// Peek is used to inspect the cache value of a key","// without updating recency or frequency.","func (c *ARCCache) Peek(key interface{}) (value interface{}, ok bool) {","\tc.lock.RLock()","\tdefer c.lock.RUnlock()","\tif val, ok := c.t1.Peek(key); ok {","\t\treturn val, ok","\t}","\treturn c.t2.Peek(key)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0]},{"id":46,"path":"third_party/github.com/hashicorp/golang-lru/lru.go","lines":["package lru","","import (","\t\"sync\"","","\t\"github.com/hashicorp/golang-lru/simplelru\"",")","","const (","\t// DefaultEvictedBufferSize defines the default buffer size to store evicted key/val","\tDefaultEvictedBufferSize = 16",")","","// Cache is a thread-safe fixed size LRU cache.","type Cache struct {","\tlru                      *simplelru.LRU","\tevictedKeys, evictedVals []interface{}","\tonEvictedCB              func(k, v interface{})","\tlock                     sync.RWMutex","}","","// New creates an LRU of the given size.","func New(size int) (*Cache, error) {","\treturn NewWithEvict(size, nil)","}","","// NewWithEvict constructs a fixed size cache with the given eviction","// callback.","func NewWithEvict(size int, onEvicted func(key, value interface{})) (c *Cache, err error) {","\t// create a cache with default settings","\tc = \u0026Cache{","\t\tonEvictedCB: onEvicted,","\t}","\tif onEvicted != nil {","\t\tc.initEvictBuffers()","\t\tonEvicted = c.onEvicted","\t}","\tc.lru, err = simplelru.NewLRU(size, onEvicted)","\treturn","}","","func (c *Cache) initEvictBuffers() {","\tc.evictedKeys = make([]interface{}, 0, DefaultEvictedBufferSize)","\tc.evictedVals = make([]interface{}, 0, DefaultEvictedBufferSize)","}","","// onEvicted save evicted key/val and sent in externally registered callback","// outside of critical section","func (c *Cache) onEvicted(k, v interface{}) {","\tc.evictedKeys = append(c.evictedKeys, k)","\tc.evictedVals = append(c.evictedVals, v)","}","","// Purge is used to completely clear the cache.","func (c *Cache) Purge() {","\tvar ks, vs []interface{}","\tc.lock.Lock()","\tc.lru.Purge()","\tif c.onEvictedCB != nil \u0026\u0026 len(c.evictedKeys) \u003e 0 {","\t\tks, vs = c.evictedKeys, c.evictedVals","\t\tc.initEvictBuffers()","\t}","\tc.lock.Unlock()","\t// invoke callback outside of critical section","\tif c.onEvictedCB != nil {","\t\tfor i := 0; i \u003c len(ks); i++ {","\t\t\tc.onEvictedCB(ks[i], vs[i])","\t\t}","\t}","}","","// Add adds a value to the cache. Returns true if an eviction occurred.","func (c *Cache) Add(key, value interface{}) (evicted bool) {","\tvar k, v interface{}","\tc.lock.Lock()","\tevicted = c.lru.Add(key, value)","\tif c.onEvictedCB != nil \u0026\u0026 evicted {","\t\tk, v = c.evictedKeys[0], c.evictedVals[0]","\t\tc.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]","\t}","\tc.lock.Unlock()","\tif c.onEvictedCB != nil \u0026\u0026 evicted {","\t\tc.onEvictedCB(k, v)","\t}","\treturn","}","","// Get looks up a key's value from the cache.","func (c *Cache) Get(key interface{}) (value interface{}, ok bool) {","\tc.lock.Lock()","\tvalue, ok = c.lru.Get(key)","\tc.lock.Unlock()","\treturn value, ok","}","","// Contains checks if a key is in the cache, without updating the","// recent-ness or deleting it for being stale.","func (c *Cache) Contains(key interface{}) bool {","\tc.lock.RLock()","\tcontainKey := c.lru.Contains(key)","\tc.lock.RUnlock()","\treturn containKey","}","","// Peek returns the key value (or undefined if not found) without updating","// the \"recently used\"-ness of the key.","func (c *Cache) Peek(key interface{}) (value interface{}, ok bool) {","\tc.lock.RLock()","\tvalue, ok = c.lru.Peek(key)","\tc.lock.RUnlock()","\treturn value, ok","}","","// ContainsOrAdd checks if a key is in the cache without updating the","// recent-ness or deleting it for being stale, and if not, adds the value.","// Returns whether found and whether an eviction occurred.","func (c *Cache) ContainsOrAdd(key, value interface{}) (ok, evicted bool) {","\tvar k, v interface{}","\tc.lock.Lock()","\tif c.lru.Contains(key) {","\t\tc.lock.Unlock()","\t\treturn true, false","\t}","\tevicted = c.lru.Add(key, value)","\tif c.onEvictedCB != nil \u0026\u0026 evicted {","\t\tk, v = c.evictedKeys[0], c.evictedVals[0]","\t\tc.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]","\t}","\tc.lock.Unlock()","\tif c.onEvictedCB != nil \u0026\u0026 evicted {","\t\tc.onEvictedCB(k, v)","\t}","\treturn false, evicted","}","","// PeekOrAdd checks if a key is in the cache without updating the","// recent-ness or deleting it for being stale, and if not, adds the value.","// Returns whether found and whether an eviction occurred.","func (c *Cache) PeekOrAdd(key, value interface{}) (previous interface{}, ok, evicted bool) {","\tvar k, v interface{}","\tc.lock.Lock()","\tprevious, ok = c.lru.Peek(key)","\tif ok {","\t\tc.lock.Unlock()","\t\treturn previous, true, false","\t}","\tevicted = c.lru.Add(key, value)","\tif c.onEvictedCB != nil \u0026\u0026 evicted {","\t\tk, v = c.evictedKeys[0], c.evictedVals[0]","\t\tc.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]","\t}","\tc.lock.Unlock()","\tif c.onEvictedCB != nil \u0026\u0026 evicted {","\t\tc.onEvictedCB(k, v)","\t}","\treturn nil, false, evicted","}","","// Remove removes the provided key from the cache.","func (c *Cache) Remove(key interface{}) (present bool) {","\tvar k, v interface{}","\tc.lock.Lock()","\tpresent = c.lru.Remove(key)","\tif c.onEvictedCB != nil \u0026\u0026 present {","\t\tk, v = c.evictedKeys[0], c.evictedVals[0]","\t\tc.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]","\t}","\tc.lock.Unlock()","\tif c.onEvictedCB != nil \u0026\u0026 present {","\t\tc.onEvictedCB(k, v)","\t}","\treturn","}","","// Resize changes the cache size.","func (c *Cache) Resize(size int) (evicted int) {","\tvar ks, vs []interface{}","\tc.lock.Lock()","\tevicted = c.lru.Resize(size)","\tif c.onEvictedCB != nil \u0026\u0026 evicted \u003e 0 {","\t\tks, vs = c.evictedKeys, c.evictedVals","\t\tc.initEvictBuffers()","\t}","\tc.lock.Unlock()","\tif c.onEvictedCB != nil \u0026\u0026 evicted \u003e 0 {","\t\tfor i := 0; i \u003c len(ks); i++ {","\t\t\tc.onEvictedCB(ks[i], vs[i])","\t\t}","\t}","\treturn evicted","}","","// RemoveOldest removes the oldest item from the cache.","func (c *Cache) RemoveOldest() (key, value interface{}, ok bool) {","\tvar k, v interface{}","\tc.lock.Lock()","\tkey, value, ok = c.lru.RemoveOldest()","\tif c.onEvictedCB != nil \u0026\u0026 ok {","\t\tk, v = c.evictedKeys[0], c.evictedVals[0]","\t\tc.evictedKeys, c.evictedVals = c.evictedKeys[:0], c.evictedVals[:0]","\t}","\tc.lock.Unlock()","\tif c.onEvictedCB != nil \u0026\u0026 ok {","\t\tc.onEvictedCB(k, v)","\t}","\treturn","}","","// GetOldest returns the oldest entry","func (c *Cache) GetOldest() (key, value interface{}, ok bool) {","\tc.lock.RLock()","\tkey, value, ok = c.lru.GetOldest()","\tc.lock.RUnlock()","\treturn","}","","// Keys returns a slice of the keys in the cache, from oldest to newest.","func (c *Cache) Keys() []interface{} {","\tc.lock.RLock()","\tkeys := c.lru.Keys()","\tc.lock.RUnlock()","\treturn keys","}","","// Len returns the number of items in the cache.","func (c *Cache) Len() int {","\tc.lock.RLock()","\tlength := c.lru.Len()","\tc.lock.RUnlock()","\treturn length","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1]},{"id":47,"path":"third_party/github.com/hashicorp/golang-lru/simplelru/lru.go","lines":["package simplelru","","import (","\t\"container/list\"","\t\"errors\"",")","","// EvictCallback is used to get a callback when a cache entry is evicted","type EvictCallback func(key interface{}, value interface{})","","// LRU implements a non-thread safe fixed size LRU cache","type LRU struct {","\tsize      int","\tevictList *list.List","\titems     map[interface{}]*list.Element","\tonEvict   EvictCallback","}","","// entry is used to hold a value in the evictList","type entry struct {","\tkey   interface{}","\tvalue interface{}","}","","// NewLRU constructs an LRU of the given size","func NewLRU(size int, onEvict EvictCallback) (*LRU, error) {","\tif size \u003c= 0 {","\t\treturn nil, errors.New(\"must provide a positive size\")","\t}","\tc := \u0026LRU{","\t\tsize:      size,","\t\tevictList: list.New(),","\t\titems:     make(map[interface{}]*list.Element),","\t\tonEvict:   onEvict,","\t}","\treturn c, nil","}","","// Purge is used to completely clear the cache.","func (c *LRU) Purge() {","\tfor k, v := range c.items {","\t\tif c.onEvict != nil {","\t\t\tc.onEvict(k, v.Value.(*entry).value)","\t\t}","\t\tdelete(c.items, k)","\t}","\tc.evictList.Init()","}","","// Add adds a value to the cache.  Returns true if an eviction occurred.","func (c *LRU) Add(key, value interface{}) (evicted bool) {","\t// Check for existing item","\tif ent, ok := c.items[key]; ok {","\t\tc.evictList.MoveToFront(ent)","\t\tent.Value.(*entry).value = value","\t\treturn false","\t}","","\t// Add new item","\tent := \u0026entry{key, value}","\tentry := c.evictList.PushFront(ent)","\tc.items[key] = entry","","\tevict := c.evictList.Len() \u003e c.size","\t// Verify size not exceeded","\tif evict {","\t\tc.removeOldest()","\t}","\treturn evict","}","","// Get looks up a key's value from the cache.","func (c *LRU) Get(key interface{}) (value interface{}, ok bool) {","\tif ent, ok := c.items[key]; ok {","\t\tc.evictList.MoveToFront(ent)","\t\tif ent.Value.(*entry) == nil {","\t\t\treturn nil, false","\t\t}","\t\treturn ent.Value.(*entry).value, true","\t}","\treturn","}","","// Contains checks if a key is in the cache, without updating the recent-ness","// or deleting it for being stale.","func (c *LRU) Contains(key interface{}) (ok bool) {","\t_, ok = c.items[key]","\treturn ok","}","","// Peek returns the key value (or undefined if not found) without updating","// the \"recently used\"-ness of the key.","func (c *LRU) Peek(key interface{}) (value interface{}, ok bool) {","\tvar ent *list.Element","\tif ent, ok = c.items[key]; ok {","\t\treturn ent.Value.(*entry).value, true","\t}","\treturn nil, ok","}","","// Remove removes the provided key from the cache, returning if the","// key was contained.","func (c *LRU) Remove(key interface{}) (present bool) {","\tif ent, ok := c.items[key]; ok {","\t\tc.removeElement(ent)","\t\treturn true","\t}","\treturn false","}","","// RemoveOldest removes the oldest item from the cache.","func (c *LRU) RemoveOldest() (key, value interface{}, ok bool) {","\tent := c.evictList.Back()","\tif ent != nil {","\t\tc.removeElement(ent)","\t\tkv := ent.Value.(*entry)","\t\treturn kv.key, kv.value, true","\t}","\treturn nil, nil, false","}","","// GetOldest returns the oldest entry","func (c *LRU) GetOldest() (key, value interface{}, ok bool) {","\tent := c.evictList.Back()","\tif ent != nil {","\t\tkv := ent.Value.(*entry)","\t\treturn kv.key, kv.value, true","\t}","\treturn nil, nil, false","}","","// Keys returns a slice of the keys in the cache, from oldest to newest.","func (c *LRU) Keys() []interface{} {","\tkeys := make([]interface{}, len(c.items))","\ti := 0","\tfor ent := c.evictList.Back(); ent != nil; ent = ent.Prev() {","\t\tkeys[i] = ent.Value.(*entry).key","\t\ti++","\t}","\treturn keys","}","","// Len returns the number of items in the cache.","func (c *LRU) Len() int {","\treturn c.evictList.Len()","}","","// Resize changes the cache size.","func (c *LRU) Resize(size int) (evicted int) {","\tdiff := c.Len() - size","\tif diff \u003c 0 {","\t\tdiff = 0","\t}","\tfor i := 0; i \u003c diff; i++ {","\t\tc.removeOldest()","\t}","\tc.size = size","\treturn diff","}","","// removeOldest removes the oldest item from the cache.","func (c *LRU) removeOldest() {","\tent := c.evictList.Back()","\tif ent != nil {","\t\tc.removeElement(ent)","\t}","}","","// removeElement is used to remove a given list element from the cache","func (c *LRU) removeElement(e *list.Element) {","\tc.evictList.Remove(e)","\tkv := e.Value.(*entry)","\tdelete(c.items, kv.key)","\tif c.onEvict != nil {","\t\tc.onEvict(kv.key, kv.value)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0]},{"id":48,"path":"third_party/github.com/hashicorp/golang-lru/testing.go","lines":["package lru","","import (","\t\"crypto/rand\"","\t\"math\"","\t\"math/big\"","\t\"testing\"",")","","func getRand(tb testing.TB) int64 {","\tout, err := rand.Int(rand.Reader, big.NewInt(math.MaxInt64))","\tif err != nil {","\t\ttb.Fatal(err)","\t}","\treturn out.Int64()","}"],"coverage":[0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0]}],"tree":{"name":".","type":"dir","children":[{"name":"pkg","type":"dir","children":[{"name":"actions","type":"dir","children":[{"name":"actions.go","type":"file","fileId":0}]},{"name":"apis","type":"dir","children":[{"name":"approvaltask","type":"dir","children":[{"name":"v1alpha1","type":"dir","children":[{"name":"approvaltask_types.go","type":"file","fileId":1},{"name":"approvaltask_validation.go","type":"file","fileId":2},{"name":"register.go","type":"file","fileId":3}]}]}]},{"name":"cli","type":"dir","children":[{"name":"flags","type":"dir","children":[{"name":"flags.go","type":"file","fileId":4}]},{"name":"formatter","type":"dir","children":[{"name":"field.go","type":"file","fileId":5}]},{"name":"params.go","type":"file","fileId":6}]},{"name":"client","type":"dir","children":[{"name":"clientset","type":"dir","children":[{"name":"versioned","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"clientset_generated.go","type":"file","fileId":8},{"name":"register.go","type":"file","fileId":9}]},{"name":"scheme","type":"dir","children":[{"name":"register.go","type":"file","fileId":10}]},{"name":"typed","type":"dir","children":[{"name":"approvaltask","type":"dir","children":[{"name":"v1alpha1","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"fake_approvaltask.go","type":"file","fileId":13},{"name":"fake_approvaltask_client.go","type":"file","fileId":14}]},{"name":"approvaltask.go","type":"file","fileId":11},{"name":"approvaltask_client.go","type":"file","fileId":12}]}]}]},{"name":"clientset.go","type":"file","fileId":7}]}]},{"name":"informers","type":"dir","children":[{"name":"externalversions","type":"dir","children":[{"name":"approvaltask","type":"dir","children":[{"name":"v1alpha1","type":"dir","children":[{"name":"approvaltask.go","type":"file","fileId":16},{"name":"interface.go","type":"file","fileId":17}]},{"name":"interface.go","type":"file","fileId":15}]},{"name":"factory.go","type":"file","fileId":18},{"name":"generic.go","type":"file","fileId":19}]}]},{"name":"injection","type":"dir","children":[{"name":"client","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"fake.go","type":"file","fileId":21}]},{"name":"client.go","type":"file","fileId":20}]},{"name":"informers","type":"dir","children":[{"name":"approvaltask","type":"dir","children":[{"name":"v1alpha1","type":"dir","children":[{"name":"approvaltask","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"fake.go","type":"file","fileId":23}]},{"name":"filtered","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"fake.go","type":"file","fileId":25}]},{"name":"approvaltask.go","type":"file","fileId":24}]},{"name":"approvaltask.go","type":"file","fileId":22}]}]}]},{"name":"factory","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"fake.go","type":"file","fileId":27}]},{"name":"filtered","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"fake_filtered_factory.go","type":"file","fileId":28}]},{"name":"filtered_factory.go","type":"file","fileId":29}]},{"name":"factory.go","type":"file","fileId":26}]}]}]},{"name":"listers","type":"dir","children":[{"name":"approvaltask","type":"dir","children":[{"name":"v1alpha1","type":"dir","children":[{"name":"approvaltask.go","type":"file","fileId":30}]}]}]}]},{"name":"reconciler","type":"dir","children":[{"name":"approvaltask","type":"dir","children":[{"name":"approvaltask.go","type":"file","fileId":31},{"name":"controller.go","type":"file","fileId":32},{"name":"utils.go","type":"file","fileId":33}]},{"name":"webhook","type":"dir","children":[{"name":"controller.go","type":"file","fileId":34},{"name":"webhook.go","type":"file","fileId":35}]}]}]},{"name":"third_party","type":"dir","children":[{"name":"github.com","type":"dir","children":[{"name":"hashicorp","type":"dir","children":[{"name":"errwrap","type":"dir","children":[{"name":"errwrap.go","type":"file","fileId":36}]},{"name":"go-multierror","type":"dir","children":[{"name":"append.go","type":"file","fileId":37},{"name":"flatten.go","type":"file","fileId":38},{"name":"format.go","type":"file","fileId":39},{"name":"group.go","type":"file","fileId":40},{"name":"multierror.go","type":"file","fileId":41},{"name":"prefix.go","type":"file","fileId":42},{"name":"sort.go","type":"file","fileId":43}]},{"name":"golang-lru","type":"dir","children":[{"name":"simplelru","type":"dir","children":[{"name":"lru.go","type":"file","fileId":47}]},{"name":"2q.go","type":"file","fileId":44},{"name":"arc.go","type":"file","fileId":45},{"name":"lru.go","type":"file","fileId":46},{"name":"testing.go","type":"file","fileId":48}]}]}]}]}]},"summary":{"totalLines":2847,"coveredLines":358,"percent":12.574639971900245}};
    </script>
    <script>
      window.COVERAGE_CONFIG = {"syntaxEnabled":true};
    </script>
    <script>
      (function() {
  'use strict';

  const data = window.COVERAGE_DATA;
  const config = window.COVERAGE_CONFIG || { syntaxEnabled: true };

  // State
  let currentFileId = null;
  let searchQuery = '';
  let contentSearchQuery = '';
  let matches = [];
  let currentMatchIndex = -1;
  let expandedDirs = new Set();
  let syntaxHighlightEnabled = config.syntaxEnabled;
  let sortMode = 'name'; // 'name' or 'coverage'
  let anchorLine = null;        // First line clicked (anchor for shift-select)
  let selectedRange = null;     // { start: N, end: M } or null

  // DOM elements
  const fileTree = document.getElementById('file-tree');
  const viewport = document.getElementById('viewport');
  const filePath = document.getElementById('file-path');
  const summary = document.getElementById('summary');
  const searchInput = document.getElementById('search-input');
  const contentSearch = document.getElementById('content-search');
  const matchInfo = document.getElementById('match-info');
  const prevMatch = document.getElementById('prev-match');
  const nextMatch = document.getElementById('next-match');
  const themeToggle = document.getElementById('theme-toggle');
  const syntaxToggle = document.getElementById('syntax-toggle');
  const helpModal = document.getElementById('help-modal');
  const closeHelp = document.getElementById('close-help');
  const helpToggle = document.getElementById('help-toggle');

  // Coverage cache: fileId -> percentage
  let coverageCache = new Map();

  function initCoverageCache() {
    data.files.forEach((file, idx) => {
      coverageCache.set(idx, calculateFileCoverage(idx));
    });
  }

  function calculateFileCoverage(fileId) {
    const file = data.files[fileId];
    let totalStatements = 0;
    let coveredStatements = 0;

    file.coverage.forEach(cov => {
      if (cov > 0) totalStatements++;
      if (cov === 2) coveredStatements++;
    });

    return totalStatements === 0 ? 0 : (coveredStatements / totalStatements) * 100;
  }

  function calculateDirectoryCoverage(node) {
    if (node.type === 'file') {
      return coverageCache.get(node.fileId) || 0;
    }

    let totalCoverage = 0;
    let fileCount = 0;

    node.children?.forEach(child => {
      const childCov = calculateDirectoryCoverage(child);
      totalCoverage += childCov;
      fileCount++;
    });

    return fileCount === 0 ? 0 : totalCoverage / fileCount;
  }

  function sortTreeNodes(node, mode) {
    if (!node.children || node.children.length === 0) return node;

    // Deep copy to avoid mutating original
    const sorted = { ...node };
    sorted.children = [...node.children].map(child => sortTreeNodes(child, mode));

    // Sort children
    sorted.children.sort((a, b) => {
      // Directories always first
      if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;

      if (mode === 'coverage') {
        const aCov = calculateDirectoryCoverage(a);
        const bCov = calculateDirectoryCoverage(b);
        console.log('Sorting:', a.name, '('+aCov.toFixed(1)+'%) vs', b.name, '('+bCov.toFixed(1)+'%)', '=', bCov - aCov);
        // Descending: high coverage first
        return aCov !== bCov ? bCov - aCov : a.name.localeCompare(b.name);
      }

      return a.name.localeCompare(b.name);
    });

    return sorted;
  }

  // Initialize
  function init() {
    initCoverageCache();
    loadSortPreference();
    renderSummary();
    renderTree();
    setupEventListeners();
    loadTheme();
    loadSyntaxPreference();

    // Check for deep link hash first, otherwise select first file
    if (!navigateToHash() && data.files.length > 0) {
      selectFile(0);
    }

    // Listen for hash changes (browser back/forward)
    window.addEventListener('hashchange', navigateToHash);
  }

  // Deep linking: parse URL hash
  function parseHash() {
    const hash = window.location.hash.slice(1);
    if (!hash) return null;

    const match = hash.match(/^file-(\d+)(?::line-(\d+)(?:-(\d+))?)?$/);
    if (!match) return null;

    return {
      fileId: parseInt(match[1], 10),
      lineStart: match[2] ? parseInt(match[2], 10) : null,
      lineEnd: match[3] ? parseInt(match[3], 10) : null
    };
  }

  // Deep linking: navigate to hash location
  function navigateToHash() {
    const target = parseHash();
    if (!target) return false;

    if (target.fileId < 0 || target.fileId >= data.files.length) return false;

    selectFile(target.fileId);

    if (target.lineStart) {
      requestAnimationFrame(() => {
        const lineEnd = target.lineEnd || target.lineStart;
        anchorLine = target.lineStart;
        selectedRange = { start: target.lineStart, end: lineEnd };
        selectLineRange(target.lineStart, lineEnd);
        scrollToLine(target.lineStart);
      });
    }

    return true;
  }

  // Deep linking: scroll to and highlight a line
  function scrollToLine(lineNum) {
    const lineEl = document.querySelector('.code-line[data-line="' + lineNum + '"]');
    if (!lineEl) return;

    lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  // Clear all selected lines
  function clearLineSelection() {
    document.querySelectorAll('.code-line.selected-line').forEach(el => {
      el.classList.remove('selected-line');
    });
  }

  // Select a range of lines (inclusive)
  function selectLineRange(start, end) {
    clearLineSelection();
    const minLine = Math.min(start, end);
    const maxLine = Math.max(start, end);
    for (let i = minLine; i <= maxLine; i++) {
      const lineEl = document.querySelector('.code-line[data-line="' + i + '"]');
      if (lineEl) {
        lineEl.classList.add('selected-line');
      }
    }
  }

  // Deep linking: update URL hash
  function updateHash(fileId, lineStart, lineEnd) {
    let hash = 'file-' + fileId;
    if (lineStart) {
      hash += ':line-' + lineStart;
      if (lineEnd && lineEnd !== lineStart) {
        // Normalise so start < end
        const minLine = Math.min(lineStart, lineEnd);
        const maxLine = Math.max(lineStart, lineEnd);
        hash = 'file-' + fileId + ':line-' + minLine + '-' + maxLine;
      }
    }
    history.replaceState(null, '', '#' + hash);
  }

  function renderSummary() {
    // Build summary safely using DOM methods
    summary.textContent = '';
    const span = document.createElement('span');
    span.className = 'percent';
    span.textContent = data.summary.percent.toFixed(1) + '%';
    summary.appendChild(span);
    summary.appendChild(document.createTextNode(
      ' coverage (' + data.summary.coveredLines + '/' + data.summary.totalLines + ' lines)'
    ));
  }

  function renderTree() {
    fileTree.textContent = '';
    // Auto-expand all top-level directories
    if (data.tree.children && data.tree.children.length > 0) {
      data.tree.children.forEach(child => {
        if (child.type === 'dir') {
          expandedDirs.add(getNodePath(child, 0));
        }
      });
    }
    const sortedTree = sortTreeNodes(data.tree, sortMode);
    renderNode(sortedTree, fileTree, 0);
  }

  function renderNode(node, container, depth) {
    if (node.name === '.' && node.type === 'dir') {
      // Root node, render children directly
      node.children.forEach(child => renderNode(child, container, depth));
      return;
    }

    const nodeEl = document.createElement('div');
    nodeEl.className = 'tree-node';
    nodeEl.dataset.name = node.name.toLowerCase();

    const item = document.createElement('div');
    item.className = 'tree-item';
    item.style.setProperty('--depth', depth);

    const icon = document.createElement('span');
    icon.className = 'icon';

    const name = document.createElement('span');
    name.className = 'name';
    name.textContent = node.name;

    if (node.type === 'dir') {
      const dirPath = getNodePath(node, depth);
      icon.textContent = expandedDirs.has(dirPath) ? '\u25BC' : '\u25B6';
      if (expandedDirs.has(dirPath)) {
        nodeEl.classList.add('expanded');
      }

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleDir(nodeEl, dirPath, icon);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to all directories
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);

      if (node.children && node.children.length > 0) {
        const children = document.createElement('div');
        children.className = 'tree-children';
        node.children.forEach(child => renderNode(child, children, depth + 1));
        nodeEl.appendChild(children);
      }
    } else {
      icon.textContent = '\uD83D\uDCC4';
      nodeEl.dataset.fileId = node.fileId;

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        selectFile(node.fileId);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to files
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);
    }

    container.appendChild(nodeEl);
  }

  function getNodePath(node, depth) {
    return node.name + '_' + depth;
  }

  function toggleDir(nodeEl, path, icon) {
    if (nodeEl.classList.contains('expanded')) {
      nodeEl.classList.remove('expanded');
      expandedDirs.delete(path);
      icon.textContent = '\u25B6';
    } else {
      nodeEl.classList.add('expanded');
      expandedDirs.add(path);
      icon.textContent = '\u25BC';
    }
  }

  function selectFile(fileId) {
    currentFileId = fileId;
    matches = [];
    currentMatchIndex = -1;
    matchInfo.textContent = '';
    contentSearch.value = '';
    contentSearchQuery = '';
    anchorLine = null;
    selectedRange = null;

    // Update selection in tree
    document.querySelectorAll('.tree-item.selected').forEach(el => {
      el.classList.remove('selected');
    });
    const selected = document.querySelector('[data-file-id="' + fileId + '"] .tree-item');
    if (selected) {
      selected.classList.add('selected');
    }

    const file = data.files[fileId];
    if (!file) return;

    filePath.textContent = file.path;
    renderCode(file);

    // Update URL hash for deep linking
    updateHash(fileId, null);
  }

  function renderCode(file) {
    viewport.textContent = '';

    if (!file.lines || file.lines.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty-state';
      const iconDiv = document.createElement('div');
      iconDiv.className = 'icon';
      iconDiv.textContent = '\uD83D\uDCED';
      const textDiv = document.createElement('div');
      textDiv.textContent = 'No content';
      empty.appendChild(iconDiv);
      empty.appendChild(textDiv);
      viewport.appendChild(empty);
      return;
    }

    const container = document.createElement('div');
    container.className = 'code-container';

    file.lines.forEach((line, idx) => {
      const lineEl = document.createElement('div');
      lineEl.className = 'code-line';
      lineEl.dataset.line = idx + 1;

      const cov = file.coverage[idx];
      if (cov === 2) {
        lineEl.classList.add('covered');
      } else if (cov === 1) {
        lineEl.classList.add('uncovered');
      }

      const gutter = document.createElement('div');
      gutter.className = 'gutter';

      const lineNum = document.createElement('div');
      lineNum.className = 'line-number';
      lineNum.textContent = idx + 1;
      lineNum.title = 'Click to select line, Shift+Click for range';

      // Add click handler for line number deep linking
      const lineNumber = idx + 1;
      lineNum.addEventListener('click', (e) => {
        e.stopPropagation();

        if (e.shiftKey && anchorLine !== null) {
          // Shift-click: select range from anchor to clicked line
          const start = Math.min(anchorLine, lineNumber);
          const end = Math.max(anchorLine, lineNumber);
          selectedRange = { start: start, end: end };
          selectLineRange(start, end);
          updateHash(currentFileId, start, end);
        } else {
          // Regular click: set anchor and select single line
          anchorLine = lineNumber;
          selectedRange = { start: lineNumber, end: lineNumber };
          selectLineRange(lineNumber, lineNumber);
          updateHash(currentFileId, lineNumber, null);
        }
      });

      const content = document.createElement('div');
      content.className = 'line-content';
      content.textContent = line || ' ';

      lineEl.appendChild(gutter);
      lineEl.appendChild(lineNum);
      lineEl.appendChild(content);
      container.appendChild(lineEl);
    });

    viewport.appendChild(container);

    // Apply syntax highlighting after rendering if enabled
    if (syntaxHighlightEnabled) {
      applySyntaxHighlighting();
    }
  }

  function setupEventListeners() {
    // File search
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchQuery = e.target.value.toLowerCase();
        filterTree();
      }, 300);
    });

    // Content search
    let contentTimeout;
    contentSearch.addEventListener('input', (e) => {
      clearTimeout(contentTimeout);
      contentTimeout = setTimeout(() => {
        contentSearchQuery = e.target.value;
        searchInFile();
      }, 300);
    });

    contentSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (e.shiftKey) {
          goToPrevMatch();
        } else {
          goToNextMatch();
        }
      }
    });

    prevMatch.addEventListener('click', goToPrevMatch);
    nextMatch.addEventListener('click', goToNextMatch);

    // Theme toggle
    themeToggle.addEventListener('click', toggleTheme);

    // Syntax toggle
    syntaxToggle.addEventListener('click', toggleSyntax);

    // Sort controls
    const sortButtons = document.querySelectorAll('.sort-btn');
    console.log('Found', sortButtons.length, 'sort buttons');
    sortButtons.forEach(btn => {
      console.log('Attaching click handler to button:', btn.dataset.sort);
      btn.addEventListener('click', () => {
        console.log('Sort button clicked:', btn.dataset.sort);
        changeSortMode(btn.dataset.sort);
      });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f' && currentFileId !== null) {
        e.preventDefault();
        contentSearch.focus();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        searchInput.focus();
      }
      // Help modal
      if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        showHelp();
      }
      if (e.key === 'Escape') {
        // Exit search if focused
        if (document.activeElement === searchInput) {
          searchInput.value = '';
          searchQuery = '';
          filterTree();
          searchInput.blur();
          viewport.focus();
          return;
        }
        if (document.activeElement === contentSearch) {
          contentSearch.value = '';
          contentSearchQuery = '';
          matchInfo.textContent = '';
          matches = [];
          currentMatchIndex = -1;
          if (currentFileId !== null) {
            renderCode(data.files[currentFileId]);
          }
          contentSearch.blur();
          viewport.focus();
          return;
        }
        hideHelp();
      }
    });

    closeHelp.addEventListener('click', hideHelp);
    helpToggle.addEventListener('click', showHelp);
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) hideHelp();
    });
  }

  function filterTree() {
    const nodes = document.querySelectorAll('.tree-node');

    if (!searchQuery) {
      nodes.forEach(n => n.classList.remove('hidden'));
      return;
    }

    nodes.forEach(node => {
      const name = node.dataset.name || '';
      const fileId = node.dataset.fileId;

      if (fileId !== undefined) {
        const file = data.files[parseInt(fileId)];
        const matchesQuery = file && file.path.toLowerCase().includes(searchQuery);
        node.classList.toggle('hidden', !matchesQuery);
      } else {
        const hasVisibleChild = Array.from(node.querySelectorAll('[data-file-id]')).some(f => {
          const fid = parseInt(f.dataset.fileId);
          const file = data.files[fid];
          return file && file.path.toLowerCase().includes(searchQuery);
        });
        node.classList.toggle('hidden', !hasVisibleChild);
        if (hasVisibleChild && searchQuery) {
          node.classList.add('expanded');
          const icon = node.querySelector('.icon');
          if (icon && icon.textContent === '\u25B6') {
            icon.textContent = '\u25BC';
          }
        }
      }
    });
  }

  function searchInFile() {
    matches = [];
    currentMatchIndex = -1;

    // Re-render code to clear highlights
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }

    if (!contentSearchQuery || currentFileId === null) {
      matchInfo.textContent = '';
      return;
    }

    const file = data.files[currentFileId];
    if (!file) return;

    const query = contentSearchQuery.toLowerCase();

    file.lines.forEach((line, idx) => {
      const text = line || '';
      const lowerText = text.toLowerCase();
      let pos = 0;
      let matchIndex;

      while ((matchIndex = lowerText.indexOf(query, pos)) !== -1) {
        matches.push({ line: idx, start: matchIndex, length: query.length });
        pos = matchIndex + 1;
      }
    });

    if (matches.length > 0) {
      highlightMatches();
      currentMatchIndex = 0;
      scrollToMatch(0);
      updateMatchInfo();
    } else {
      matchInfo.textContent = 'No matches';
    }
  }

  function highlightMatches() {
    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    // Group matches by line
    const matchesByLine = {};
    matches.forEach((m, idx) => {
      if (!matchesByLine[m.line]) matchesByLine[m.line] = [];
      matchesByLine[m.line].push({ ...m, idx });
    });

    Object.keys(matchesByLine).forEach(lineIdx => {
      const lineEl = lineEls[parseInt(lineIdx)];
      if (!lineEl) return;

      const content = lineEl.querySelector('.line-content');
      if (!content) return;

      const text = file.lines[parseInt(lineIdx)] || '';
      const lineMatches = matchesByLine[lineIdx].sort((a, b) => a.start - b.start);

      // Build content using DOM nodes for safety
      content.textContent = '';
      let lastEnd = 0;

      lineMatches.forEach(m => {
        // Text before match
        if (m.start > lastEnd) {
          content.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
        }
        // Match span
        const span = document.createElement('span');
        span.className = 'match-highlight';
        span.dataset.matchIdx = m.idx;
        span.textContent = text.substring(m.start, m.start + m.length);
        content.appendChild(span);
        lastEnd = m.start + m.length;
      });

      // Text after last match
      if (lastEnd < text.length) {
        content.appendChild(document.createTextNode(text.substring(lastEnd)));
      }

      // Handle empty line
      if (content.childNodes.length === 0) {
        content.textContent = ' ';
      }
    });
  }

  function scrollToMatch(idx) {
    document.querySelectorAll('.current-match').forEach(el => {
      el.classList.remove('current-match');
    });

    const matchEl = document.querySelector('[data-match-idx="' + idx + '"]');
    if (matchEl) {
      matchEl.classList.add('current-match');
      matchEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function updateMatchInfo() {
    if (matches.length === 0) {
      matchInfo.textContent = 'No matches';
    } else {
      matchInfo.textContent = (currentMatchIndex + 1) + '/' + matches.length;
    }
  }

  function goToNextMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex + 1) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function goToPrevMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex - 1 + matches.length) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function toggleTheme() {
    const body = document.body;
    const current = body.dataset.theme;
    const next = current === 'dark' ? 'light' : 'dark';
    body.dataset.theme = next;
    localStorage.setItem('coverage-theme', next);
  }

  function loadTheme() {
    const saved = localStorage.getItem('coverage-theme');
    if (saved) {
      document.body.dataset.theme = saved;
    }
  }

  function applySyntaxHighlighting() {
    if (!syntaxHighlightEnabled || currentFileId === null) return;
    if (typeof hljs === 'undefined') return;

    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    lineEls.forEach((lineEl, idx) => {
      const cov = file.coverage[idx];
      // Only highlight lines with no coverage info
      if (cov !== 0) return;

      const content = lineEl.querySelector('.line-content');
      if (!content || !content.textContent.trim()) return;

      const text = content.textContent;

      // Use hljs.highlight() which returns result object
      const result = hljs.highlight(text, { language: 'go' });

      // Parse the highlighted HTML safely using DOMParser
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + result.value + '</div>', 'text/html');
      const wrapper = doc.body.firstChild;

      // Clear and append parsed nodes
      content.textContent = '';
      while (wrapper.firstChild) {
        content.appendChild(wrapper.firstChild);
      }
    });
  }

  function toggleSyntax() {
    syntaxHighlightEnabled = !syntaxHighlightEnabled;
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
    localStorage.setItem('coverage-syntax', syntaxHighlightEnabled ? 'on' : 'off');

    // Re-render current file
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }
  }

  function loadSyntaxPreference() {
    const saved = localStorage.getItem('coverage-syntax');
    if (saved !== null) {
      // User preference overrides default
      syntaxHighlightEnabled = saved === 'on';
    }
    // Update button state
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
  }

  function changeSortMode(mode) {
    if (sortMode === mode) return;

    console.log('Changing sort mode from', sortMode, 'to', mode);
    sortMode = mode;
    localStorage.setItem('coverage-sort-mode', mode);

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === mode);
    });

    // Re-render tree
    renderTree();
  }

  function loadSortPreference() {
    const saved = localStorage.getItem('coverage-sort-mode');
    if (saved && (saved === 'name' || saved === 'coverage')) {
      sortMode = saved;
    }

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === sortMode);
    });
  }

  function showHelp() {
    helpModal.classList.remove('hidden');
  }

  function hideHelp() {
    helpModal.classList.add('hidden');
  }

  // Start the app
  init();
})();

    </script>
  </body>
</html>
