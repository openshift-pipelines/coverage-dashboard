
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>actions: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/cli/pkg/actions/create.go (0.0%)</option>
				
				<option value="file1">github.com/tektoncd/cli/pkg/actions/delete.go (0.0%)</option>
				
				<option value="file2">github.com/tektoncd/cli/pkg/actions/get.go (0.0%)</option>
				
				<option value="file3">github.com/tektoncd/cli/pkg/actions/gvr.go (0.0%)</option>
				
				<option value="file4">github.com/tektoncd/cli/pkg/actions/list.go (0.0%)</option>
				
				<option value="file5">github.com/tektoncd/cli/pkg/actions/patch.go (0.0%)</option>
				
				<option value="file6">github.com/tektoncd/cli/pkg/actions/watch.go (0.0%)</option>
				
				<option value="file7">github.com/tektoncd/cli/pkg/bundle/builder.go (81.8%)</option>
				
				<option value="file8">github.com/tektoncd/cli/pkg/bundle/flags.go (0.0%)</option>
				
				<option value="file9">github.com/tektoncd/cli/pkg/bundle/keychain.go (92.3%)</option>
				
				<option value="file10">github.com/tektoncd/cli/pkg/bundle/parser.go (85.0%)</option>
				
				<option value="file11">github.com/tektoncd/cli/pkg/bundle/reader.go (75.9%)</option>
				
				<option value="file12">github.com/tektoncd/cli/pkg/bundle/remote.go (68.8%)</option>
				
				<option value="file13">github.com/tektoncd/cli/pkg/chain/chain.go (0.0%)</option>
				
				<option value="file14">github.com/tektoncd/cli/pkg/cli/params.go (0.0%)</option>
				
				<option value="file15">github.com/tektoncd/cli/pkg/cli/prerun/prerun.go (0.0%)</option>
				
				<option value="file16">github.com/tektoncd/cli/pkg/clustertriggerbinding/clustertriggerbinding.go (68.0%)</option>
				
				<option value="file17">github.com/tektoncd/cli/pkg/customrun/sort/by_namespace.go (84.6%)</option>
				
				<option value="file18">github.com/tektoncd/cli/pkg/customrun/sort/by_start_time.go (87.5%)</option>
				
				<option value="file19">github.com/tektoncd/cli/pkg/deleter/deleter.go (72.4%)</option>
				
				<option value="file20">github.com/tektoncd/cli/pkg/eventlistener/eventlistener.go (72.0%)</option>
				
				<option value="file21">github.com/tektoncd/cli/pkg/export/export.go (92.9%)</option>
				
				<option value="file22">github.com/tektoncd/cli/pkg/file/file.go (51.7%)</option>
				
				<option value="file23">github.com/tektoncd/cli/pkg/flags/flags.go (6.8%)</option>
				
				<option value="file24">github.com/tektoncd/cli/pkg/formatted/address.go (100.0%)</option>
				
				<option value="file25">github.com/tektoncd/cli/pkg/formatted/color.go (70.0%)</option>
				
				<option value="file26">github.com/tektoncd/cli/pkg/formatted/completion.go (0.0%)</option>
				
				<option value="file27">github.com/tektoncd/cli/pkg/formatted/description.go (100.0%)</option>
				
				<option value="file28">github.com/tektoncd/cli/pkg/formatted/k8s.go (93.1%)</option>
				
				<option value="file29">github.com/tektoncd/cli/pkg/formatted/param.go (83.0%)</option>
				
				<option value="file30">github.com/tektoncd/cli/pkg/formatted/results.go (83.3%)</option>
				
				<option value="file31">github.com/tektoncd/cli/pkg/formatted/task.go (0.0%)</option>
				
				<option value="file32">github.com/tektoncd/cli/pkg/formatted/time.go (63.6%)</option>
				
				<option value="file33">github.com/tektoncd/cli/pkg/formatted/version.go (100.0%)</option>
				
				<option value="file34">github.com/tektoncd/cli/pkg/formatted/workspace.go (68.9%)</option>
				
				<option value="file35">github.com/tektoncd/cli/pkg/labels/mergelabels.go (100.0%)</option>
				
				<option value="file36">github.com/tektoncd/cli/pkg/log/pipeline_reader.go (0.0%)</option>
				
				<option value="file37">github.com/tektoncd/cli/pkg/log/reader.go (0.0%)</option>
				
				<option value="file38">github.com/tektoncd/cli/pkg/log/task_reader.go (0.0%)</option>
				
				<option value="file39">github.com/tektoncd/cli/pkg/log/writer.go (0.0%)</option>
				
				<option value="file40">github.com/tektoncd/cli/pkg/names/formats.go (0.0%)</option>
				
				<option value="file41">github.com/tektoncd/cli/pkg/options/delete.go (94.3%)</option>
				
				<option value="file42">github.com/tektoncd/cli/pkg/options/describe.go (30.4%)</option>
				
				<option value="file43">github.com/tektoncd/cli/pkg/options/logs.go (27.7%)</option>
				
				<option value="file44">github.com/tektoncd/cli/pkg/options/start.go (0.0%)</option>
				
				<option value="file45">github.com/tektoncd/cli/pkg/params/mergeparams.go (96.6%)</option>
				
				<option value="file46">github.com/tektoncd/cli/pkg/params/validation.go (0.0%)</option>
				
				<option value="file47">github.com/tektoncd/cli/pkg/pipeline/pipeline.go (25.0%)</option>
				
				<option value="file48">github.com/tektoncd/cli/pkg/pipeline/pipelinelastrun.go (88.9%)</option>
				
				<option value="file49">github.com/tektoncd/cli/pkg/pipelinerun/description.go (21.0%)</option>
				
				<option value="file50">github.com/tektoncd/cli/pkg/pipelinerun/pipelinerun.go (40.0%)</option>
				
				<option value="file51">github.com/tektoncd/cli/pkg/pipelinerun/sort/by_namespace.go (84.6%)</option>
				
				<option value="file52">github.com/tektoncd/cli/pkg/pipelinerun/sort/by_start_time.go (87.5%)</option>
				
				<option value="file53">github.com/tektoncd/cli/pkg/pipelinerun/tracker.go (71.1%)</option>
				
				<option value="file54">github.com/tektoncd/cli/pkg/plugins/plugins.go (85.0%)</option>
				
				<option value="file55">github.com/tektoncd/cli/pkg/pods/container.go (46.3%)</option>
				
				<option value="file56">github.com/tektoncd/cli/pkg/pods/fake/log.go (0.0%)</option>
				
				<option value="file57">github.com/tektoncd/cli/pkg/pods/fake/pod.go (0.0%)</option>
				
				<option value="file58">github.com/tektoncd/cli/pkg/pods/fake/stream.go (0.0%)</option>
				
				<option value="file59">github.com/tektoncd/cli/pkg/pods/pod.go (78.6%)</option>
				
				<option value="file60">github.com/tektoncd/cli/pkg/pods/pod_template.go (100.0%)</option>
				
				<option value="file61">github.com/tektoncd/cli/pkg/suggestion/suggest.go (90.3%)</option>
				
				<option value="file62">github.com/tektoncd/cli/pkg/task/task.go (53.8%)</option>
				
				<option value="file63">github.com/tektoncd/cli/pkg/task/tasklastrun.go (92.0%)</option>
				
				<option value="file64">github.com/tektoncd/cli/pkg/taskrun/create.go (0.0%)</option>
				
				<option value="file65">github.com/tektoncd/cli/pkg/taskrun/description.go (50.7%)</option>
				
				<option value="file66">github.com/tektoncd/cli/pkg/taskrun/list.go (91.7%)</option>
				
				<option value="file67">github.com/tektoncd/cli/pkg/taskrun/sort/by_namespace.go (84.6%)</option>
				
				<option value="file68">github.com/tektoncd/cli/pkg/taskrun/sort/by_start_time.go (87.5%)</option>
				
				<option value="file69">github.com/tektoncd/cli/pkg/taskrun/taskrun.go (0.0%)</option>
				
				<option value="file70">github.com/tektoncd/cli/pkg/triggerbinding/triggerbinding.go (68.0%)</option>
				
				<option value="file71">github.com/tektoncd/cli/pkg/triggertemplate/triggertemplate.go (68.0%)</option>
				
				<option value="file72">github.com/tektoncd/cli/pkg/trustedresources/sign.go (56.8%)</option>
				
				<option value="file73">github.com/tektoncd/cli/pkg/trustedresources/verify.go (73.1%)</option>
				
				<option value="file74">github.com/tektoncd/cli/pkg/version/version.go (84.7%)</option>
				
				<option value="file75">github.com/tektoncd/cli/pkg/workspaces/workspaces.go (95.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package actions

import (
        "context"

        "github.com/tektoncd/cli/pkg/cli"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// Create is used to take a partial resource and an unstructured object and create it in the cluster using the dynamic client.
func Create(gr schema.GroupVersionResource, clients *cli.Clients, object *unstructured.Unstructured, ns string, op metav1.CreateOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, clients.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">obj, err := clients.Dynamic.Resource(*gvr).Namespace(ns).Create(context.Background(), object, op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return obj, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package actions

import (
        "context"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
)

// Delete is used to take a partial resource and the name of an object in the cluster and delete it using the dynamic client.
func Delete(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, objname, ns string, op metav1.DeleteOptions) error <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, discovery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = dynamic.Resource(*gvr).Namespace(ns).Delete(context.Background(), objname, op)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright © 2019-2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package actions

import (
        "context"
        "io"

        "github.com/tektoncd/cli/pkg/cli"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/cli-runtime/pkg/printers"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
)

// TODO: remove as all the function uses are moved to new func
// PrintObject is used to take a partial resource and the name of an object in the cluster, fetch it using the dynamic client, and print out the object.
func PrintObject(groupResource schema.GroupVersionResource, obj string, w io.Writer, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, p printers.ResourcePrinter, ns string) error <span class="cov0" title="0">{
        res, err := Get(groupResource, dynamic, discovery, obj, ns, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return p.PrintObj(res, w)</span>
}

// PrintObject is used to take a partial resource and the name of an object in the cluster, fetch it using the dynamic client, and print out the object.
func PrintObjectV1(groupResource schema.GroupVersionResource, obj string, w io.Writer, client *cli.Clients, p printers.ResourcePrinter, ns string) error <span class="cov0" title="0">{
        res, err := GetUnstructured(groupResource, client, obj, ns, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return p.PrintObj(res, w)</span>
}

// GetV1 is used to take a partial resource and the name of an object in the cluster and fetch it from the cluster using the dynamic client.
func GetV1(gr schema.GroupVersionResource, c *cli.Clients, objname, ns string, op metav1.GetOptions, obj interface{}) error <span class="cov0" title="0">{
        unstructuredObj, err := GetUnstructured(gr, c, objname, ns, op)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)</span>
}

func GetUnstructured(gr schema.GroupVersionResource, c *cli.Clients, objname, ns string, op metav1.GetOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, c.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">unstructuredObj, err := c.Dynamic.Resource(*gvr).Namespace(ns).Get(context.Background(), objname, op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return unstructuredObj, nil</span>
}

// TODO: remove as all the function uses are moved to new func
// Get is used to take a partial resource and the name of an object in the cluster and fetch it from the cluster using the dynamic client.
func Get(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, objname, ns string, op metav1.GetOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, discovery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">obj, err := dynamic.Resource(*gvr).Namespace(ns).Get(context.Background(), objname, op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return obj, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package actions

import (
        "sync"

        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/restmapper"
)

var (
        doOnce      sync.Once
        apiGroupRes []*restmapper.APIGroupResources
)

// GetGroupVersionResource takes a partial resource, and returns the full resource matching the partial resource, if there's only one match.
func GetGroupVersionResource(gr schema.GroupVersionResource, discovery discovery.DiscoveryInterface) (*schema.GroupVersionResource, error) <span class="cov0" title="0">{
        var err error
        doOnce.Do(func() </span><span class="cov0" title="0">{
                err = InitializeAPIGroupRes(discovery)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">rm := restmapper.NewDiscoveryRESTMapper(apiGroupRes)
        gvr, err := rm.ResourceFor(gr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;gvr, nil</span>
}

// InitializeAPIGroupRes initializes and populates the discovery client.
func InitializeAPIGroupRes(discovery discovery.DiscoveryInterface) error <span class="cov0" title="0">{
        var err error
        apiGroupRes, err = restmapper.GetAPIGroupResources(discovery)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package actions

import (
        "context"
        "fmt"
        "io"
        "os"

        "github.com/tektoncd/cli/pkg/cli"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/cli-runtime/pkg/printers"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
)

// PrintObjects takes a partial resource, fetches a list of that resource's objects in the cluster using the dynamic client, and prints out the objects.
func PrintObjects(groupResource schema.GroupVersionResource, w io.Writer, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, p printers.ResourcePrinter, ns string) error <span class="cov0" title="0">{
        allres, err := list(groupResource, dynamic, discovery, ns, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return p.PrintObj(allres, w)</span>
}

// List fetches the resource and convert it to respective object
func ListV1(gr schema.GroupVersionResource, c *cli.Clients, opts metav1.ListOptions, ns string, obj interface{}) error <span class="cov0" title="0">{
        unstructuredObj, err := list(gr, c.Dynamic, c.Tekton.Discovery(), ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to list objects from %s namespace \n", ns)
                return err
        }</span>

        <span class="cov0" title="0">return runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)</span>
}

// list takes a partial resource and fetches a list of that resource's objects in the cluster using the dynamic client.
func list(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, ns string, op metav1.ListOptions) (*unstructured.UnstructuredList, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, discovery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">allRes, err := dynamic.Resource(*gvr).Namespace(ns).List(context.Background(), op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return allRes, nil</span>
}

// TODO: remove as all the function uses are moved to new func
// List takes a partial resource and fetches a list of that resource's objects in the cluster using the dynamic client.
func List(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, ns string, op metav1.ListOptions) (*unstructured.UnstructuredList, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, discovery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">allRes, err := dynamic.Resource(*gvr).Namespace(ns).List(context.Background(), op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return allRes, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright © 2019-2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package actions

import (
        "context"
        "fmt"
        "os"

        "github.com/tektoncd/cli/pkg/cli"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
)

// Patch takes a partial resource, an object name in the cluster, and patch data to be applied to that object, and patches the object using the dynamic client.
func Patch(gr schema.GroupVersionResource, clients *cli.Clients, objName string, data []byte, opt metav1.PatchOptions, ns string, obj interface{}) error <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, clients.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">unstructuredObj, err := clients.Dynamic.Resource(*gvr).Namespace(ns).Patch(context.Background(), objName, types.JSONPatchType, data, opt)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to patch object from %s namespace \n", ns)
                return err
        }</span>

        <span class="cov0" title="0">return runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright © 2019-2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package actions

import (
        "context"

        "github.com/tektoncd/cli/pkg/cli"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/watch"
)

// Watch takes a partial resource, and returns a watcher interface for that resource using the dynamic client
func Watch(gr schema.GroupVersionResource, clients *cli.Clients, ns string, op metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        gvr, err := GetGroupVersionResource(gr, clients.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">watch, err := clients.Dynamic.Resource(*gvr).Namespace(ns).Watch(context.Background(), op)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return watch, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package bundle

import (
        "archive/tar"
        "bytes"
        "crypto/sha256"
        "errors"
        "fmt"
        "io"
        "sort"
        "strings"
        "time"

        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/empty"
        "github.com/google/go-containerregistry/pkg/v1/mutate"
        "github.com/google/go-containerregistry/pkg/v1/tarball"
        tkremote "github.com/tektoncd/pipeline/pkg/remote/oci"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// BuildTektonBundle will return a complete OCI Image usable as a Tekton Bundle built by parsing, decoding, and
// compressing the provided contents as Tekton objects.
func BuildTektonBundle(contents []string, annotations, labels map[string]string, ctime time.Time, log io.Writer) (v1.Image, error) <span class="cov8" title="1">{
        img := mutate.Annotations(empty.Image, annotations).(v1.Image)
        img, err := mutate.Config(img, v1.Config{
                Labels: labels,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("setting labels: %w", err)
        }</span>

        <span class="cov8" title="1">if len(contents) &gt; tkremote.MaximumBundleObjects </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("bundle contains more than the maximum %d allow objects", tkremote.MaximumBundleObjects)
        }</span>

        <span class="cov8" title="1">fmt.Fprint(log, "Creating Tekton Bundle:\n")

        // sort the contents based on the digest of the content, this keeps the layer
        // order in the image manifest deterministic
        sort.Slice(contents, func(i, j int) bool </span><span class="cov8" title="1">{
                iDigest := sha256.Sum256([]byte(contents[i]))
                jDigest := sha256.Sum256([]byte(contents[j]))

                return bytes.Compare(iDigest[:], jDigest[:]) &lt; 0
        }</span>)

        // For each block of input, attempt to parse all of the YAML/JSON objects as Tekton objects and compress them into
        // the OCI image as a tar layer.
        <span class="cov8" title="1">for _, content := range contents </span><span class="cov8" title="1">{
                if err := decodeObjects(content, func(gvr *schema.GroupVersionKind, element runtime.Object, raw []byte) error </span><span class="cov8" title="1">{
                        name, err := getObjectName(element)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // Tar up this object before writing it to the layer.
                        <span class="cov8" title="1">var tarbundle bytes.Buffer
                        writer := tar.NewWriter(&amp;tarbundle)
                        if err := writer.WriteHeader(&amp;tar.Header{
                                Name:     name,
                                Mode:     0600,
                                Size:     int64(len(raw)),
                                Typeflag: tar.TypeReg,
                        }); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if _, err := writer.Write(raw); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // nolint: staticcheck
                        <span class="cov8" title="1">l, err := tarball.LayerFromReader(&amp;tarbundle)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Add this layer to the image with all of the required annotations.
                        <span class="cov8" title="1">img, err = mutate.Append(img, mutate.Addendum{
                                Layer: l,
                                Annotations: map[string]string{
                                        tkremote.APIVersionAnnotation: gvr.Version,
                                        tkremote.KindAnnotation:       strings.ToLower(gvr.Kind),
                                        tkremote.TitleAnnotation:      name,
                                },
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to add %q to Tekton Bundle: %w", string(raw), err)
                        }</span>

                        <span class="cov8" title="1">fmt.Fprintf(log, "\t- Added %s: %s to image\n", gvr.Kind, name)

                        return nil</span>
                }); err != nil <span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        // Set created time for bundle image
        <span class="cov8" title="1">img, err = mutate.CreatedAt(img, v1.Time{Time: ctime})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add created time to image: %w", err)
        }</span>

        <span class="cov8" title="1">return img, nil</span>
}

// Return the ObjectMetadata.Name field which every resource should have.
func getObjectName(obj runtime.Object) (string, error) <span class="cov8" title="1">{
        metaObj, ok := obj.(metav1.Object)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("object is not a registered kubernetes resource")
        }</span>
        <span class="cov8" title="1">name := metaObj.GetName()
        if name == "" </span><span class="cov8" title="1">{
                return "", errors.New("kubernetes resources should have a name")
        }</span>
        <span class="cov8" title="1">return name, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package bundle

import (
        "net/http"

        "github.com/google/go-containerregistry/pkg/authn"
        remoteimg "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/spf13/pflag"
)

// RemoteOptions is a set of flags that are used configure the connection options to a registry.
type RemoteOptions struct {
        bearerToken   string
        basicUsername string
        basicPassword string

        skipTLS bool
}

// ToOptions outputs a list of `remoteimg.Option`s that can be passed into various fetch/write calls to a remote
// registry.
func (r *RemoteOptions) ToOptions() []remoteimg.Option <span class="cov0" title="0">{
        var opts []remoteimg.Option

        // Set the auth chain based on the flags.
        if r.bearerToken != "" </span><span class="cov0" title="0">{
                opts = append(opts, remoteimg.WithAuth(&amp;authn.Bearer{Token: r.bearerToken}))
        }</span>
        <span class="cov0" title="0">if r.basicUsername != "" &amp;&amp; r.basicPassword != "" </span><span class="cov0" title="0">{
                opts = append(opts, remoteimg.WithAuth(&amp;authn.Basic{
                        Username: r.basicUsername,
                        Password: r.basicPassword,
                }))
        }</span>

        // Use local keychain if no auth is provided. It's not allowed to use both.
        <span class="cov0" title="0">if len(opts) == 0 </span><span class="cov0" title="0">{
                keychains := authn.NewMultiKeychain(authn.DefaultKeychain, PodmanKeyChain)
                opts = []remoteimg.Option{remoteimg.WithAuthFromKeychain(keychains)}
        }</span>

        <span class="cov0" title="0">transport := http.DefaultTransport.(*http.Transport)
        if r.skipTLS </span><span class="cov0" title="0">{
                transport.TLSClientConfig.InsecureSkipVerify = r.skipTLS
        }</span>
        // TODO: consider adding CA overrides for self-signed or private registries.
        <span class="cov0" title="0">opts = append(opts, remoteimg.WithTransport(transport))
        return opts</span>
}

// AddRemoteFlags will define a common set of flags that can be used to change how images are pushed/fetched from remote
// image repositories.
func AddRemoteFlags(flags *pflag.FlagSet, opts *RemoteOptions) <span class="cov0" title="0">{
        flags.StringVar(&amp;opts.bearerToken, "remote-bearer", "", "A Bearer token to authenticate against the repository")
        flags.StringVar(&amp;opts.basicUsername, "remote-username", "", "A username to pass to the registry for basic auth. Must be used with --remote-password")
        flags.StringVar(&amp;opts.basicPassword, "remote-password", "", "A password to pass to the registry for basic auth. Must be used with --remote-username")

        // TLS related flags.
        flags.BoolVar(&amp;opts.skipTLS, "remote-skip-tls", false, "If set to true, skips TLS check when connecting to the registry")
}</span>

// PullOptions configure how an image is cached once it is fetched from the remote.
type CacheOptions struct {
        cacheDir string
        noCache  bool
}

// AddCacheFlags will define a set of flags to control how Tekton Bundle caching is done.
func AddCacheFlags(flags *pflag.FlagSet, opts *CacheOptions) <span class="cov0" title="0">{
        flags.StringVar(&amp;opts.cacheDir, "cache-dir", "~/.tekton/bundles", "A directory to cache Tekton bundles in.")
        flags.BoolVar(&amp;opts.noCache, "no-cache", false, "If set to true, pulls a Tekton bundle from the remote even its exact digest is available in the cache.")
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package bundle

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "sync"

        "github.com/docker/cli/cli/config"
        "github.com/docker/cli/cli/config/types"
        "github.com/docker/docker/pkg/homedir"
        "github.com/google/go-containerregistry/pkg/authn"
)

type podmanKeychain struct {
        mu sync.Mutex
}

var PodmanKeyChain authn.Keychain = &amp;podmanKeychain{}

func (pk *podmanKeychain) Resolve(target authn.Resource) (authn.Authenticator, error) <span class="cov8" title="1">{
        pk.mu.Lock()
        defer pk.mu.Unlock()

        authFile, err := os.Open(getPathToPodmanAuth())
        // Return error only when the auth file is there but somehow unable to read.
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                        return authn.Anonymous, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">defer authFile.Close()

        cf, err := config.LoadFromReader(authFile)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">key := target.RegistryStr()
        cfg, err := cf.GetAuthConfig(key)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">empty := types.AuthConfig{}
        if cfg == empty </span><span class="cov8" title="1">{
                return authn.Anonymous, nil
        }</span>
        <span class="cov8" title="1">return authn.FromConfig(authn.AuthConfig{
                Username:      cfg.Username,
                Password:      cfg.Password,
                Auth:          cfg.Auth,
                IdentityToken: cfg.IdentityToken,
                RegistryToken: cfg.RegistryToken,
        }), nil</span>
}

func getPathToPodmanAuth() string <span class="cov8" title="1">{
        var (
                defaultPerUIDPathFormat = filepath.FromSlash("/run/containers/%d/auth.json")
                xdgRuntimeDirPath       = filepath.FromSlash("containers/auth.json")
                nonLinuxAuthFilePath    = filepath.FromSlash(".config/containers/auth.json")
        )

        if runtime.GOOS == "windows" || runtime.GOOS == "darwin" </span><span class="cov0" title="0">{
                return filepath.Join(homedir.Get(), nonLinuxAuthFilePath)
        }</span>

        <span class="cov8" title="1">runtimeDir := os.Getenv("XDG_RUNTIME_DIR")
        if runtimeDir != "" </span><span class="cov8" title="1">{
                return filepath.Join(runtimeDir, xdgRuntimeDirPath)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(defaultPerUIDPathFormat, os.Getuid())</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package bundle

import (
        "bytes"
        "fmt"
        "io"
        "strings"

        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/runtime/serializer"
        "k8s.io/apimachinery/pkg/util/yaml"
)

// decodedElementHandler is a function type that processes a single decoded resource from #decodeObjects. Errors are
// returned as is. Each invocation is given the GVR of the element, the parsed struct, and the raw JSON bytes.
type decodedElementHandler func(gvr *schema.GroupVersionKind, element runtime.Object, raw []byte) error

func decodeObjects(contents string, handler decodedElementHandler) error <span class="cov8" title="1">{
        yamlDecoder := yaml.NewYAMLOrJSONDecoder(strings.NewReader(contents), 4096)
        tektonDecoder := serializer.NewCodecFactory(scheme.Scheme).UniversalDeserializer()

        // Scratch object to decode raw manifest into.
        spec := runtime.RawExtension{}
        for </span><span class="cov8" title="1">{
                // Note that the code below mostly mirrors
                // https://github.com/kubernetes/cli-runtime/blob/b4586cbefd3668543b8b2b56845419e39ad1792f/pkg/resource/visitor.go#L572
                if err := yamlDecoder.Decode(&amp;spec); err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("found a spec that isn't YAML or JSON parseable: %q", contents)</span>
                }

                <span class="cov8" title="1">spec.Raw = bytes.TrimSpace(spec.Raw)
                if len(spec.Raw) == 0 || bytes.Equal(spec.Raw, []byte("null")) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">specInJSON := string(spec.Raw)
                obj, gvr, err := tektonDecoder.Decode(spec.Raw, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to parse string as a Tekton object: %q", specInJSON)
                }</span>

                <span class="cov8" title="1">if gvr == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to parse raw tekton object with no kind or apiVersion: %s", specInJSON)
                }</span>

                <span class="cov8" title="1">if err = handler(gvr, obj, spec.Raw); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package bundle

import (
        "archive/tar"
        "fmt"
        "io"

        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        tkremote "github.com/tektoncd/pipeline/pkg/remote/oci"
        "k8s.io/apimachinery/pkg/runtime"
)

// ObjectVisitor is an input function that callers of this file's methods can implement to act on the read contents of a
// Tekton bundle. The `version`, `kind`, and `name` fields map 1:1 with the same named fields in the Tekton Bundle spec.
type ObjectVisitor func(version, kind, name string, element runtime.Object, raw []byte)

// List will call visitor for every single layer in the img.
func List(img v1.Image, visitor ObjectVisitor) error <span class="cov8" title="1">{
        manifest, err := img.Manifest()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">layers, err := img.Layers()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">layerMap := map[string]v1.Layer{}
        for _, l := range layers </span><span class="cov8" title="1">{
                digest, err := l.Digest()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">layerMap[digest.String()] = l</span>
        }

        <span class="cov8" title="1">for _, l := range manifest.Layers </span><span class="cov8" title="1">{
                rawLayer, ok := layerMap[l.Digest.String()]
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("no image layer with digest %s exists in the bundle", l.Digest.String())
                }</span>

                <span class="cov8" title="1">contents, err := readTarLayer(rawLayer)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read layer %s: %w", l.Digest, err)
                }</span>

                <span class="cov8" title="1">obj, _, err := scheme.Codecs.UniversalDeserializer().Decode(contents, nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to decode layer %s to a Tekton object: %w", l.Digest, err)
                }</span>
                <span class="cov8" title="1">visitor(
                        l.Annotations[tkremote.APIVersionAnnotation],
                        l.Annotations[tkremote.KindAnnotation],
                        l.Annotations[tkremote.TitleAnnotation],
                        obj,
                        contents,
                )</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ListKind is like #List but only returns elements of a single kind. Kind will be lowercased to conform to the Tekton
// Bundle spec.
func ListKind(img v1.Image, pkind string, visitor ObjectVisitor) error <span class="cov8" title="1">{
        listedItems := 0
        if err := List(img, func(version, kind string, name string, element runtime.Object, raw []byte) </span><span class="cov8" title="1">{
                if kind == pkind </span><span class="cov8" title="1">{
                        listedItems++
                        visitor(version, kind, name, element, raw)
                }</span>
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if listedItems == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no objects of kind %q found in img", pkind)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Get returns a single named element of a specific kind from the Tekton Bundle.
func Get(img v1.Image, pkind, name string, visitor ObjectVisitor) error <span class="cov8" title="1">{
        objectFound := false
        if err := ListKind(img, pkind, func(version, kind, foundName string, element runtime.Object, raw []byte) </span><span class="cov8" title="1">{
                if foundName == name </span><span class="cov8" title="1">{
                        objectFound = true
                        visitor(version, kind, foundName, element, raw)
                }</span>
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !objectFound </span><span class="cov0" title="0">{
                return fmt.Errorf("no objects of kind %q named %q found in img", pkind, name)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// readTarLayer is a helper function to read the contents of a tar'ed layer.
func readTarLayer(l v1.Layer) ([]byte, error) <span class="cov8" title="1">{
        rc, err := l.Uncompressed()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Failed to read image layer: %w", err)
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        // If the user bundled this up as a tar file then we need to untar it.
        treader := tar.NewReader(rc)
        header, err := treader.Next()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("layer is not a tarball")
        }</span>

        <span class="cov8" title="1">contents := make([]byte, header.Size)
        if _, err := io.ReadFull(treader, contents); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                // We only allow 1 resource per layer so this tar bundle should have one and only one file.
                return nil, fmt.Errorf("failed to read tar bundle: %w", err)
        }</span>
        <span class="cov8" title="1">return contents, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package bundle

import (
        "fmt"

        "github.com/google/go-containerregistry/pkg/name"
        v1 "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/cache"
        remoteimg "github.com/google/go-containerregistry/pkg/v1/remote"
        homedir "github.com/mitchellh/go-homedir"
)

// Write will publish an OCI image to a remote registry using the provided options and reference.
func Write(img v1.Image, ref name.Reference, opts ...remoteimg.Option) (string, error) <span class="cov8" title="1">{
        if err := remoteimg.Write(ref, img, opts...); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not push image to registry as %q: %w", ref.String(), err)
        }</span>

        <span class="cov8" title="1">digest, err := img.Digest()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not read image digest: %w", err)
        }</span>

        <span class="cov8" title="1">return ref.Context().Digest(digest.String()).String(), nil</span>
}

// Read looks up an image from a remote registry and fetches layers from a local cache if we have seen it before.
func Read(ref name.Reference, cacheOptions *CacheOptions, opts ...remoteimg.Option) (v1.Image, error) <span class="cov8" title="1">{
        img, err := remoteimg.Image(ref, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch image: %w", err)
        }</span>

        <span class="cov8" title="1">if cacheOptions.noCache </span><span class="cov0" title="0">{
                return img, nil
        }</span>

        // Construct a new cache and wrap this image in that.
        <span class="cov8" title="1">dir, err := homedir.Expand(cacheOptions.cacheDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fsCache := cache.NewFilesystemCache(dir)
        return cache.Image(img, fsCache), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright © 2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package chain

import (
        "context"
        "fmt"
        "os"

        "go.uber.org/zap/zapcore"

        "github.com/tektoncd/chains/pkg/chains/storage"
        "github.com/tektoncd/chains/pkg/config"
        "github.com/tektoncd/cli/pkg/cli"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// ConfigMapToContext returns a context initialized with the Chains ConfigMap.
func ConfigMapToContext(cs *cli.Clients, namespace string) (context.Context, error) <span class="cov0" title="0">{
        cfg, err := getChainsConfig(cs, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return config.ToContext(context.Background(), cfg), nil</span>
}

func GetTaskRunBackends(cs *cli.Clients, namespace string, tr *v1.TaskRun) (map[string]storage.Backend, config.StorageOpts, error) <span class="cov0" title="0">{
        // Prepare the logger.
        encoderCfg := zapcore.EncoderConfig{
                MessageKey: "msg",
        }
        core := zapcore.NewCore(zapcore.NewConsoleEncoder(encoderCfg), os.Stderr, zapcore.DebugLevel)
        logger := zap.New(core).WithOptions()

        // flushes buffer, if any
        defer func() </span><span class="cov0" title="0">{
                // intentionally ignoring error here, see https://github.com/uber-go/zap/issues/328
                _ = logger.Sync()
        }</span>()

        // Get the storage backend.
        <span class="cov0" title="0">backends, err := initializeBackends(cs, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, config.StorageOpts{}, fmt.Errorf("failed to retrieve the backend storage: %v", err)
        }</span>

        // Initialize the storage options.
        <span class="cov0" title="0">opts := config.StorageOpts{
                ShortKey: fmt.Sprintf("taskrun-%s", tr.UID),
        }

        return backends, opts, nil</span>
}

func initializeBackends(cs *cli.Clients, namespace string) (map[string]storage.Backend, error) <span class="cov0" title="0">{
        // Retrieve the Chains configuration.
        cfg, err := getChainsConfig(cs, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialize the backend.
        <span class="cov0" title="0">backends, err := storage.InitializeBackends(context.Background(), cs.Tekton, cs.Kube, *cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error initializing backends: %s", err)
        }</span>

        // Return the configured backend.
        <span class="cov0" title="0">return backends, nil</span>
}

// getChainsConfig returns the chains config configmap
func getChainsConfig(cs *cli.Clients, namespace string) (*config.Config, error) <span class="cov0" title="0">{
        chainsConfig, err := cs.Kube.CoreV1().ConfigMaps(namespace).Get(context.Background(), "chains-config", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error retrieving tekton chains configmap: %s", err)
        }</span>
        <span class="cov0" title="0">cfg, err := config.NewConfigFromConfigMap(chainsConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating tekton chains configuration: %s", err)
        }</span>
        <span class="cov0" title="0">return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cli

import (
        "github.com/fatih/color"
        "github.com/jonboulle/clockwork"
        "github.com/pkg/errors"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        versionedTriggers "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        "k8s.io/client-go/dynamic"
        k8s "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
)

type TektonParams struct {
        clients        *Clients
        kubeConfigPath string
        kubeContext    string
        namespace      string
}

// ensure that TektonParams complies with cli.Params interface
var _ Params = (*TektonParams)(nil)

func (p *TektonParams) SetKubeConfigPath(path string) <span class="cov0" title="0">{
        p.kubeConfigPath = path
}</span>

func (p *TektonParams) SetKubeContext(context string) <span class="cov0" title="0">{
        p.kubeContext = context
}</span>

func (p *TektonParams) tektonClient(config *rest.Config) (versioned.Interface, error) <span class="cov0" title="0">{
        cs, err := versioned.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cs, nil</span>
}

func (p *TektonParams) triggersClient(config *rest.Config) (versionedTriggers.Interface, error) <span class="cov0" title="0">{
        cs, err := versionedTriggers.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return cs, nil</span>
}

// Set kube client based on config
func (p *TektonParams) kubeClient(config *rest.Config) (k8s.Interface, error) <span class="cov0" title="0">{
        k8scs, err := k8s.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create k8s client from config")
        }</span>

        <span class="cov0" title="0">return k8scs, nil</span>
}

func (p *TektonParams) dynamicClient(config *rest.Config) (dynamic.Interface, error) <span class="cov0" title="0">{
        dynamicClient, err := dynamic.NewForConfig(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create dynamic client from config")

        }</span>
        <span class="cov0" title="0">return dynamicClient, err</span>
}

// Only returns kube client, not tekton client
func (p *TektonParams) KubeClient() (k8s.Interface, error) <span class="cov0" title="0">{
        config, err := p.config()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">kube, err := p.kubeClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return kube, nil</span>
}

func (p *TektonParams) Clients(cfg ...*rest.Config) (*Clients, error) <span class="cov0" title="0">{
        if p.clients != nil </span><span class="cov0" title="0">{
                return p.clients, nil
        }</span>
        <span class="cov0" title="0">var config *rest.Config

        if len(cfg) != 0 &amp;&amp; cfg[0] != nil </span><span class="cov0" title="0">{
                config = cfg[0]
        }</span> else<span class="cov0" title="0"> {
                defaultConfig, err := p.config()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">config = defaultConfig</span>
        }

        <span class="cov0" title="0">tekton, err := p.tektonClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">triggers, err := p.triggersClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">kube, err := p.kubeClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dynamic, err := p.dynamicClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">p.clients = &amp;Clients{
                Tekton:   tekton,
                Kube:     kube,
                Triggers: triggers,
                Dynamic:  dynamic,
        }

        return p.clients, nil</span>
}

func (p *TektonParams) config() (*rest.Config, error) <span class="cov0" title="0">{
        loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
        if p.kubeConfigPath != "" </span><span class="cov0" title="0">{
                loadingRules.ExplicitPath = p.kubeConfigPath
        }</span>
        <span class="cov0" title="0">configOverrides := &amp;clientcmd.ConfigOverrides{}
        if p.kubeContext != "" </span><span class="cov0" title="0">{
                configOverrides.CurrentContext = p.kubeContext
        }</span>
        <span class="cov0" title="0">kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
        if p.namespace == "" </span><span class="cov0" title="0">{
                namespace, _, err := kubeConfig.Namespace()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "Couldn't get kubeConfiguration namespace")
                }</span>
                <span class="cov0" title="0">p.namespace = namespace</span>
        }
        <span class="cov0" title="0">config, err := kubeConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "Parsing kubeconfig failed")
        }</span>

        // set values as done in kubectl
        <span class="cov0" title="0">config.QPS = 50.0
        config.Burst = 300

        return config, nil</span>
}

func (p *TektonParams) SetNoColour(b bool) <span class="cov0" title="0">{
        color.NoColor = b
}</span>

func (p *TektonParams) SetNamespace(ns string) <span class="cov0" title="0">{
        p.namespace = ns
}</span>

func (p *TektonParams) Namespace() string <span class="cov0" title="0">{
        return p.namespace
}</span>

func (p *TektonParams) Time() clockwork.Clock <span class="cov0" title="0">{
        return clockwork.NewRealClock()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package prerun

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/flags"
)

func PersistentPreRunE(p cli.Params) func(*cobra.Command, []string) error <span class="cov0" title="0">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                if err := WarnExperimental(cmd); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return flags.InitParams(p, cmd)</span>
        }
}

func WarnExperimental(cmd *cobra.Command) error <span class="cov0" title="0">{
        if IsExperimental(cmd) </span><span class="cov0" title="0">{
                fmt.Fprintf(cmd.OutOrStderr(), "*Warning*: This is an experimental command, its usage and behavior can change in the next release(s)\n")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func IsExperimental(cmd *cobra.Command) bool <span class="cov0" title="0">{
        if _, ok := cmd.Annotations["experimental"]; ok </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">var experimental bool
        cmd.VisitParents(func(cmd *cobra.Command) </span><span class="cov0" title="0">{
                if _, ok := cmd.Annotations["experimental"]; ok </span><span class="cov0" title="0">{
                        experimental = true
                }</span>
        })
        <span class="cov0" title="0">return experimental</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright © 2021 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package clustertriggerbinding

import (
        "fmt"
        "os"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var clustertriggerbindingGroupResource = schema.GroupVersionResource{Group: "triggers.tekton.dev", Resource: "clustertriggerbindings"}

func GetAllClusterTriggerBindingNames(client *cli.Clients) ([]string, error) <span class="cov8" title="1">{
        ps, err := List(client, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ret := []string{}
        for _, item := range ps.Items </span><span class="cov8" title="1">{
                ret = append(ret, item.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func List(c *cli.Clients, opts metav1.ListOptions) (*v1beta1.ClusterTriggerBindingList, error) <span class="cov8" title="1">{
        unstructuredCTB, err := actions.List(clustertriggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), "", opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var clustertriggerbindings *v1beta1.ClusterTriggerBindingList
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredCTB.UnstructuredContent(), &amp;clustertriggerbindings); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to list clustertriggerbindings\n")
                return nil, err
        }</span>

        <span class="cov8" title="1">return clustertriggerbindings, nil</span>
}

func Get(c *cli.Clients, ctbname string, opts metav1.GetOptions) (*v1beta1.ClusterTriggerBinding, error) <span class="cov8" title="1">{
        unstructuredCTB, err := actions.Get(clustertriggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), ctbname, "", opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ctb *v1beta1.ClusterTriggerBinding
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredCTB.UnstructuredContent(), &amp;ctb); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to get clustertriggerbinding\n")
                return nil, err
        }</span>
        <span class="cov8" title="1">return ctb, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright © 2023 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package customrun

import (
        "sort"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
)

func SortByNamespace(crs []v1beta1.CustomRun) <span class="cov8" title="1">{
        sort.Sort(byNamespace(crs))
}</span>

type byNamespace []v1beta1.CustomRun

func (crs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) <span class="cov8" title="1">{
        lt, eq = ins &lt; jns, ins == jns
        return lt, eq
}</span>

func (crs byNamespace) Len() int      <span class="cov8" title="1">{ return len(crs) }</span>
func (crs byNamespace) Swap(i, j int) <span class="cov8" title="1">{ crs[i], crs[j] = crs[j], crs[i] }</span>
func (crs byNamespace) Less(i, j int) bool <span class="cov8" title="1">{
        var lt, eq bool
        if lt, eq = crs.compareNamespace(crs[i].Namespace, crs[j].Namespace); eq </span><span class="cov8" title="1">{
                if crs[j].Status.StartTime == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if crs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return crs[j].Status.StartTime.Before(crs[i].Status.StartTime)</span>
        }
        <span class="cov8" title="1">return lt</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright © 2023 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package customrun

import (
        "sort"

        v1beta1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
)

func SortByStartTime(crs []v1beta1.CustomRun) <span class="cov8" title="1">{
        sort.Sort(byStartTime(crs))
}</span>

type byStartTime []v1beta1.CustomRun

func (crs byStartTime) Len() int      <span class="cov8" title="1">{ return len(crs) }</span>
func (crs byStartTime) Swap(i, j int) <span class="cov8" title="1">{ crs[i], crs[j] = crs[j], crs[i] }</span>
func (crs byStartTime) Less(i, j int) bool <span class="cov8" title="1">{
        if crs[j].Status.StartTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if crs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return crs[j].Status.StartTime.Before(crs[i].Status.StartTime)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package deleter

import (
        "fmt"
        "strings"

        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/names"
        "go.uber.org/multierr"
)

// Deleter encapsulates behaviour around deleting resources and their relations.
// While actually performing a deletion is left to calling code, this helper
// type standardizes the sequencing, messaging and error handling related to
// deletions.
type Deleter struct {
        errors                   []error
        successfulDeletes        []string
        successfulRelatedDeletes []string

        kind        string
        relatedKind string

        delete func(string) error

        listRelated   func(string) ([]string, error)
        deleteRelated func(string) error
}

// New returns a Deleter that will delete resources of kind with the given
// delete func when Execute is called.
func New(kind string, deleteFunc func(string) error) *Deleter <span class="cov8" title="1">{
        return &amp;Deleter{
                kind:   kind,
                delete: deleteFunc,
        }
}</span>

// WithRelated tells this Deleter that it should also delete related resources
// when Execute is called. Related resources will be of given kind, the names of
// those resources must be provided by listFunc and each related resource will be
// passed to deleteFunc for deletion.
func (d *Deleter) WithRelated(kind string, listFunc func(string) ([]string, error), deleteFunc func(string) error) <span class="cov8" title="1">{
        d.relatedKind = kind
        d.listRelated = listFunc
        d.deleteRelated = deleteFunc
}</span>

// Delete performs the deletion of resources. Errors are printed to stderr of
// the passed in streams struct and are also aggregated for later access
// with d.Errors(). The names of successfully deleted resources are
// returned.
func (d *Deleter) Delete(resourceNames []string) []string <span class="cov8" title="1">{
        for _, name := range resourceNames </span><span class="cov8" title="1">{
                if err := d.delete(name); err != nil </span><span class="cov0" title="0">{
                        d.appendError(fmt.Errorf("failed to delete %s %q: %s", d.kind, name, err))
                }</span> else<span class="cov8" title="1"> {
                        d.successfulDeletes = append(d.successfulDeletes, name)
                }</span>
        }
        <span class="cov8" title="1">return d.successfulDeletes</span>
}

// DeleteRelated performs the deletion of resources related to d's kind. Errors are
// aggregated and can be accessed with d.Errors().
func (d *Deleter) DeleteRelated(resourceNames []string) <span class="cov8" title="1">{
        if d.relatedKind != "" &amp;&amp; d.listRelated != nil &amp;&amp; d.deleteRelated != nil </span><span class="cov8" title="1">{
                for _, name := range resourceNames </span><span class="cov8" title="1">{
                        d.deleteRelatedList(name)
                }</span>
        }
}

// deleteRelatedList gets the list of resources related to resourceName using the
// provided listFunc and then calls the deleteRelated func for each relation.
func (d *Deleter) deleteRelatedList(resourceName string) <span class="cov8" title="1">{
        if related, err := d.listRelated(resourceName); err != nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("failed to list %ss: %s", strings.ToLower(d.relatedKind), err)
                d.appendError(err)
        }</span> else<span class="cov8" title="1"> {
                if len(related) &gt; 0 </span><span class="cov8" title="1">{
                        for _, subresource := range related </span><span class="cov8" title="1">{
                                if err := d.deleteRelated(subresource); err != nil </span><span class="cov0" title="0">{
                                        err = fmt.Errorf("failed to delete %s %q: %s", d.relatedKind, subresource, err)
                                        d.appendError(err)
                                }</span> else<span class="cov8" title="1"> {
                                        d.successfulRelatedDeletes = append(d.successfulRelatedDeletes, subresource)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        err = fmt.Errorf("no %ss associated with %s %q", d.relatedKind, d.kind, resourceName)
                        d.appendError(err)
                }</span>
        }
}

// PrintSuccesses writes success messages to the provided stdout stream.
func (d *Deleter) PrintSuccesses(streams *cli.Stream) <span class="cov8" title="1">{
        if len(d.successfulRelatedDeletes) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(streams.Out, "%ss deleted: %s\n", d.relatedKind, names.QuotedList(d.successfulRelatedDeletes))
        }</span>
        <span class="cov8" title="1">if len(d.successfulDeletes) &gt; 0 </span><span class="cov8" title="1">{
                fmt.Fprintf(streams.Out, "%ss deleted: %s\n", d.kind, names.QuotedList(d.successfulDeletes))
        }</span>
}

// appendError adds that error to the list of accumulated errors that
// have occurred during execution.
func (d *Deleter) appendError(err error) <span class="cov0" title="0">{
        d.errors = append(d.errors, err)
}</span>

// Errors returns any accumulated errors in the operation of this deleter.
func (d *Deleter) Errors() error <span class="cov8" title="1">{
        return multierr.Combine(d.errors...)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright © 2021 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package eventlistener

import (
        "fmt"
        "os"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var eventlistenerGroupResource = schema.GroupVersionResource{Group: "triggers.tekton.dev", Resource: "eventlisteners"}

func GetAllEventListenerNames(client *cli.Clients, namespace string) ([]string, error) <span class="cov8" title="1">{
        ps, err := List(client, metav1.ListOptions{}, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ret := []string{}
        for _, item := range ps.Items </span><span class="cov8" title="1">{
                ret = append(ret, item.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func List(c *cli.Clients, opts metav1.ListOptions, ns string) (*v1beta1.EventListenerList, error) <span class="cov8" title="1">{
        unstructuredEL, err := actions.List(eventlistenerGroupResource, c.Dynamic, c.Triggers.Discovery(), ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var eventlisteners *v1beta1.EventListenerList
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredEL.UnstructuredContent(), &amp;eventlisteners); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to list eventlisteners from %s namespace \n", ns)
                return nil, err
        }</span>

        <span class="cov8" title="1">return eventlisteners, nil</span>
}

func Get(c *cli.Clients, elName string, opts metav1.GetOptions, ns string) (*v1beta1.EventListener, error) <span class="cov8" title="1">{
        unstructuredEl, err := actions.Get(eventlistenerGroupResource, c.Dynamic, c.Triggers.Discovery(), elName, ns, opts)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get EventListener %s: %v", elName, err)
        }</span>

        <span class="cov8" title="1">var el *v1beta1.EventListener
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredEl.UnstructuredContent(), &amp;el); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to get eventlistener from %s namespace \n", ns)
                return nil, err
        }</span>
        <span class="cov8" title="1">return el, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright © 2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package export

import (
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

func RemoveFieldForExport(obj *unstructured.Unstructured) error <span class="cov8" title="1">{
        content := obj.UnstructuredContent()

        // remove the status from pipelinerun and taskrun
        unstructured.RemoveNestedField(content, "status")

        // remove some metadata information of previous resource
        metadataFields := []string{
                "managedFields",
                "resourceVersion",
                "uid",
                "finalizers",
                "generation",
                "namespace",
                "creationTimestamp",
                "ownerReferences",
        }
        for _, field := range metadataFields </span><span class="cov8" title="1">{
                unstructured.RemoveNestedField(content, "metadata", field)
        }</span>
        <span class="cov8" title="1">unstructured.RemoveNestedField(content, "metadata", "annotations", "kubectl.kubernetes.io/last-applied-configuration")

        // check if generateName exists and remove name if it does
        if _, exist, err := unstructured.NestedString(content, "metadata", "generateName"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> if exist </span><span class="cov8" title="1">{
                unstructured.RemoveNestedField(content, "metadata", "name")
        }</span>

        // remove the status from spec which are related to status
        <span class="cov8" title="1">specFields := []string{"status", "statusMessage"}
        for _, field := range specFields </span><span class="cov8" title="1">{
                unstructured.RemoveNestedField(content, "spec", field)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package file

import (
        "bytes"
        "fmt"
        "log"
        "net/http"
        "os"
        "strings"
)

type TypeValidator func(target string) bool

func IsYamlFile() TypeValidator <span class="cov8" title="1">{
        return func(target string) bool </span><span class="cov8" title="1">{
                if strings.HasSuffix(target, ".yaml") || strings.HasSuffix(target, ".yml") </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }
}

func LoadFileContent(httpClient http.Client, target string, validate TypeValidator, errorMsg error) ([]byte, error) <span class="cov8" title="1">{
        if !validate(target) </span><span class="cov0" title="0">{
                return nil, errorMsg
        }</span>

        <span class="cov8" title="1">var content []byte
        var err error
        if strings.HasPrefix(target, "http") </span><span class="cov8" title="1">{
                content, err = getRemoteContent(httpClient, target)
        }</span> else<span class="cov8" title="1"> {
                content, err = os.ReadFile(target)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return content, nil</span>
}

func getRemoteContent(httpClient http.Client, url string) ([]byte, error) <span class="cov8" title="1">{
        resp, err := httpClient.Get(url)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == 404 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("url specified returned a 404: not found")
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                err := resp.Body.Close()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>
        }()

        <span class="cov0" title="0">buf := new(bytes.Buffer)
        _, err = buf.ReadFrom(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">content := buf.Bytes()
        return content, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package flags

import (
        "os"
        "runtime"

        "github.com/spf13/cobra"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/formatted"
        "golang.org/x/term"
)

const (
        kubeConfig = "kubeconfig"
        context    = "context"
        namespace  = "namespace"
        nocolour   = "nocolour"
        nocolor    = "no-color"
)

// TektonOptions all global tekton options
type TektonOptions struct {
        KubeConfig, Context, Namespace string
        Nocolour                       bool
}

// AddTektonOptions amends command to add flags required to initialise a cli.Param
func AddTektonOptions(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.PersistentFlags().StringP(
                kubeConfig, "k", "",
                "kubectl config file (default: $HOME/.kube/config)")

        cmd.PersistentFlags().StringP(
                context, "c", "",
                "name of the kubeconfig context to use (default: kubectl config current-context)")

        cmd.PersistentFlags().StringP(
                namespace, "n", "",
                "namespace to use (default: from $KUBECONFIG)")
        _ = cmd.RegisterFlagCompletionFunc(namespace,
                func(_ *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                        return formatted.BaseCompletion("namespace", args)
                }</span>,
        )

        <span class="cov0" title="0">cmd.PersistentFlags().BoolP(
                nocolour, "", false,
                "disable colouring (default: false)")

        // Since nocolour was the old name for the --no-color flag, mark
        // the flag as hidden to make the option backwards compatible while
        // only showing --no-color option in help output.
        _ = cmd.PersistentFlags().MarkHidden("nocolour")

        cmd.PersistentFlags().BoolP(
                "no-color", "C", false,
                "disable coloring (default: false)")</span>
}

// GetTektonOptions get the global tekton Options that are not passed to a subcommands
func GetTektonOptions(cmd *cobra.Command) TektonOptions <span class="cov0" title="0">{
        kcPath, _ := cmd.Flags().GetString(kubeConfig)
        kubeContext, _ := cmd.Flags().GetString(context)
        ns, _ := cmd.Flags().GetString(namespace)
        nocolourFlag, _ := cmd.Flags().GetBool(nocolor)
        return TektonOptions{
                KubeConfig: kcPath,
                Context:    kubeContext,
                Namespace:  ns,
                Nocolour:   nocolourFlag,
        }
}</span>

// InitParams initialises cli.Params based on flags defined in command
func InitParams(p cli.Params, cmd *cobra.Command) error <span class="cov8" title="1">{
        // NOTE: breaks symmetry with AddTektonOptions as this uses Flags instead of
        // PersistentFlags as it could be the sub command that is trying to access
        // the flags defined by the parent and hence need to use `Flag` instead
        // e.g. `list` accessing kubeconfig defined by `pipeline`
        kcPath, err := cmd.Flags().GetString(kubeConfig)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov0" title="0">p.SetKubeConfigPath(kcPath)

        kubeContext, err := cmd.Flags().GetString(context)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">p.SetKubeContext(kubeContext)

        // ensure that the config is valid by creating a client but skip for bundle cmd
        // as bundle cmd does not need k8s client and config
        // if this annotation is available on cmd and value is false then client
        // will not be initialized
        if cmd.Annotations["kubernetes"] != "false" </span><span class="cov0" title="0">{
                if _, err := p.Clients(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">ns, err := cmd.Flags().GetString(namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if ns != "" </span><span class="cov0" title="0">{
                p.SetNamespace(ns)
        }</span>

        <span class="cov0" title="0">nocolourFlag, err := cmd.Flags().GetBool(nocolor)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !nocolourFlag </span><span class="cov0" title="0">{
                // Check to see if --nocolour option was passed instead of --no-color or -C
                nocolourFlag, err = cmd.Flags().GetBool(nocolour)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">p.SetNoColour(nocolourFlag)

        // Make sure we set as Nocolour if we don't have a terminal (ie redirection)
        // nolint
        // this conversion is throwing error for golangci-lint G115
        if !term.IsTerminal(int(os.Stdout.Fd())) </span><span class="cov0" title="0">{
                p.SetNoColour(true)
        }</span>

        <span class="cov0" title="0">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                p.SetNoColour(true)
        }</span>

        <span class="cov0" title="0">if _, ok := os.LookupEnv("NO_COLOR"); ok </span><span class="cov0" title="0">{
                p.SetNoColour(true)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

func FormatAddress(addressURL string) string <span class="cov8" title="1">{
        if addressURL == "" </span><span class="cov8" title="1">{
                return "---"
        }</span>

        <span class="cov8" title="1">return addressURL</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        "fmt"
        "io"
        "sync"
        "sync/atomic"

        "github.com/fatih/color"
)

var (
        // Palette of colors for rainbow's tasks, Red is avoided as keeping it for errors
        palette = []color.Attribute{
                color.FgHiGreen,
                color.FgHiYellow,
                color.FgHiBlue,
                color.FgHiMagenta,
                color.FgHiCyan,
        }
)

// DecorateAttr decorate strings with a color or an emoji, respecting the user
// preference if no colour needed.
func DecorateAttr(attrString, message string) string <span class="cov8" title="1">{
        if color.NoColor </span><span class="cov8" title="1">{
                return message
        }</span>

        <span class="cov8" title="1">switch attrString </span>{
        case "bullet":<span class="cov8" title="1">
                return fmt.Sprintf("∙ %s", message)</span>
        case "check":<span class="cov8" title="1">
                return "✔ ️"</span>
        case "resources":<span class="cov8" title="1">
                return "📦 "</span>
        case "params":<span class="cov8" title="1">
                return "⚓ "</span>
        case "tasks":<span class="cov8" title="1">
                return "🗒  "</span>
        case "pipelineruns":<span class="cov8" title="1">
                return "⛩  "</span>
        case "status":<span class="cov8" title="1">
                return "🌡️  "</span>
        case "inputresources":<span class="cov8" title="1">
                return "📨 "</span>
        case "outputresources":<span class="cov8" title="1">
                return "📡 "</span>
        case "steps":<span class="cov8" title="1">
                return "🦶 "</span>
        case "message":<span class="cov8" title="1">
                return "💌 "</span>
        case "taskruns":<span class="cov8" title="1">
                return "🗂  "</span>
        case "sidecars":<span class="cov8" title="1">
                return "🚗 "</span>
        case "results":<span class="cov8" title="1">
                return "📝 "</span>
        case "workspaces":<span class="cov8" title="1">
                return "📂 "</span>
        case "skippedtasks":<span class="cov8" title="1">
                return "⏭️  "</span>
        case "timeouts":<span class="cov8" title="1">
                return "⏱  "</span>
        }

        <span class="cov8" title="1">attr := color.Reset
        switch attrString </span>{
        case "underline":<span class="cov8" title="1">
                attr = color.Underline</span>
        case "underline bold":<span class="cov0" title="0">
                return color.New(color.Underline).Add(color.Bold).Sprintf("%s", message)</span>
        case "bold":<span class="cov0" title="0">
                attr = color.Bold</span>
        case "yellow":<span class="cov0" title="0">
                attr = color.FgHiYellow</span>
        case "green":<span class="cov0" title="0">
                attr = color.FgHiGreen</span>
        case "red":<span class="cov8" title="1">
                attr = color.FgHiRed</span>
        case "blue":<span class="cov0" title="0">
                attr = color.FgHiBlue</span>
        case "magenta":<span class="cov0" title="0">
                attr = color.FgHiMagenta</span>
        case "cyan":<span class="cov0" title="0">
                attr = color.FgHiCyan</span>
        case "black":<span class="cov0" title="0">
                attr = color.FgHiBlack</span>
        case "white":<span class="cov0" title="0">
                attr = color.FgHiWhite</span>
        }

        <span class="cov8" title="1">return color.New(attr).Sprintf("%s", message)</span>
}

type atomicCounter struct {
        value     uint32
        threshold int
}

func (c *atomicCounter) next() int <span class="cov8" title="1">{
        v := atomic.AddUint32(&amp;c.value, 1)
        next := int(v-1) % c.threshold
        // nolint
        // this conversion is throwing error for golangci-lint G115
        atomic.CompareAndSwapUint32(&amp;c.value, uint32(c.threshold), 0)
        return next

}</span>

type rainbow struct {
        cache   sync.Map
        counter atomicCounter
}

func newRainbow() *rainbow <span class="cov8" title="1">{
        return &amp;rainbow{
                counter: atomicCounter{threshold: len(palette)},
        }
}</span>

func (r *rainbow) get(x string) color.Attribute <span class="cov8" title="1">{
        if value, ok := r.cache.Load(x); ok </span><span class="cov8" title="1">{
                return value.(color.Attribute)
        }</span>

        <span class="cov8" title="1">clr := palette[r.counter.next()]
        r.cache.Store(x, clr)
        return clr</span>
}

// Fprintf formats according to a format specifier and writes to w.
// the first argument is a label to keep the same colour on.
func (r *rainbow) Fprintf(label string, w io.Writer, format string, args ...interface{}) <span class="cov0" title="0">{
        attribute := r.get(label)
        crainbow := color.Set(attribute).Add(color.Bold)
        crainbow.Fprintf(w, format, args...)
}</span>

// Color formatter to print the colored output on streams
type Color struct {
        Rainbow *rainbow

        red  *color.Color
        blue *color.Color
}

// NewColor returns a new instance color formatter
func NewColor() *Color <span class="cov0" title="0">{
        return &amp;Color{
                Rainbow: newRainbow(),

                red:  color.New(color.FgRed),
                blue: color.New(color.FgBlue),
        }
}</span>

// PrintRed prints the formatted content to given destination in red color
func (c *Color) PrintRed(w io.Writer, format string, args ...interface{}) <span class="cov0" title="0">{
        c.red.Fprintf(w, format, args...)
}</span>

// Error prints the formatted content to given destination in red color
func (c *Color) Error(w io.Writer, format string, args ...interface{}) <span class="cov0" title="0">{
        c.PrintRed(w, format, args...)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package formatted

import (
        "os/exec"
        "strings"

        "github.com/spf13/cobra"
)

// GetObjectsWithKubectl return completions with kubectl, we are doing this with
// kubectl since we have caching and without it completion is way too slow
func GetObjectsWithKubectl(obj string) []string <span class="cov0" title="0">{
        out, err := exec.Command("kubectl", "get", obj, "-o=jsonpath={range .items[*]}{.metadata.name} {end}").Output()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return strings.Fields(string(out))</span>
}

// BaseCompletion return a completion for a kubernetes object using Kubectl
func BaseCompletion(target string, args []string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        if len(args) != 0 </span><span class="cov0" title="0">{
                return nil, cobra.ShellCompDirectiveNoFileComp
        }</span>
        <span class="cov0" title="0">return GetObjectsWithKubectl(target), cobra.ShellCompDirectiveNoFileComp</span>
}

// ParentCompletion do completion of command to the Parent
func ParentCompletion(cmd *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) <span class="cov0" title="0">{
        return BaseCompletion(cmd.Parent().Name(), args)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
)

// If description is longer than 20 char then it will return
// initial 20 chars suffixed by ...
func FormatDesc(desc string) string <span class="cov8" title="1">{
        if len(desc) &gt; 20 </span><span class="cov8" title="1">{
                return desc[0:19] + "..."
        }</span>
        <span class="cov8" title="1">return desc</span>
}

func RemoveLastAppliedConfig(annotations map[string]string) map[string]string <span class="cov8" title="1">{
        removed := map[string]string{}
        for k, v := range annotations </span><span class="cov8" title="1">{
                if k != corev1.LastAppliedConfigAnnotation </span><span class="cov8" title="1">{
                        removed[k] = v
                }</span>
        }
        <span class="cov8" title="1">return removed</span>
}

// Check if PipelineRef exists on a PipelineRunSpec. Returns empty string if not present.
func PipelineRefExists(spec v1.PipelineRunSpec) string <span class="cov8" title="1">{
        if spec.PipelineRef == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return spec.PipelineRef.Name</span>
}

// Check if TaskRef exists on a TaskRunSpec. Returns empty string if not present.
func TaskRefExists(spec v1.TaskRunSpec) string <span class="cov8" title="1">{
        if spec.TaskRef == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return spec.TaskRef.Name</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        "fmt"
        "sync/atomic"

        "github.com/fatih/color"
        corev1 "k8s.io/api/core/v1"
        v1 "knative.dev/pkg/apis/duck/v1"
)

var ConditionColor = map[string]color.Attribute{
        "Failed":    color.FgHiRed,
        "Succeeded": color.FgHiGreen,
        "Running":   color.FgHiBlue,
        "Cancelled": color.FgHiYellow,
        "Completed": color.FgHiMagenta,
        "Pending":   color.FgHiYellow,
        "Started":   color.FgHiCyan,
}

var stepCounter uint64

// ColorStatus Get a status coloured
func ColorStatus(status string) string <span class="cov8" title="1">{
        return color.New(ConditionColor[status]).Sprint(status)
}</span>

// AutoStepName when our stepName is empty return a generated name as generated
// on pipeLine
func AutoStepName(stepName string) string <span class="cov8" title="1">{
        unnamedStep := fmt.Sprintf("unnamed-%d", stepCounter)
        atomic.AddUint64(&amp;stepCounter, 1)
        if stepName != "" </span><span class="cov8" title="1">{
                return stepName
        }</span>
        <span class="cov8" title="1">return unnamedStep</span>
}

// Condition returns a human readable text based on the status of the Condition
func Condition(c v1.Conditions) string <span class="cov8" title="1">{
        var status string
        if len(c) == 0 </span><span class="cov8" title="1">{
                return "---"
        }</span>

        <span class="cov8" title="1">switch c[0].Status </span>{
        case corev1.ConditionFalse:<span class="cov8" title="1">
                status = "Failed"</span>
        case corev1.ConditionTrue:<span class="cov8" title="1">
                status = "Succeeded"</span>
        case corev1.ConditionUnknown:<span class="cov8" title="1">
                status = "Running"</span>
        }

        <span class="cov8" title="1">if c[0].Reason == "Completed" &amp;&amp; status == "Succeeded" </span><span class="cov8" title="1">{
                return ColorStatus(status)
        }</span> else<span class="cov8" title="1"> if c[0].Reason != "" &amp;&amp; c[0].Reason != status </span><span class="cov8" title="1">{
                switch c[0].Reason </span>{
                case "PipelineRunCancelled", "TaskRunCancelled", "Cancelled":<span class="cov8" title="1">
                        if c[0].Reason == "Cancelled" </span><span class="cov8" title="1">{
                                return ColorStatus("Cancelled")
                        }</span>
                        <span class="cov8" title="1">return ColorStatus("Cancelled") + "(" + c[0].Reason + ")"</span>
                case "PipelineRunStopping", "TaskRunStopping":<span class="cov8" title="1">
                        if c[0].Reason == "Failed" </span><span class="cov0" title="0">{
                                return ColorStatus("Failed")
                        }</span>
                        <span class="cov8" title="1">return ColorStatus("Failed") + "(" + c[0].Reason + ")"</span>
                case "CreateContainerConfigError", "ExceededNodeResources", "ExceededResourceQuota":<span class="cov8" title="1">
                        if c[0].Reason == "Pending" </span><span class="cov0" title="0">{
                                return ColorStatus("Pending")
                        }</span>
                        <span class="cov8" title="1">return ColorStatus("Pending") + "(" + c[0].Reason + ")"</span>
                case "PipelineRunPending":<span class="cov8" title="1">
                        return ColorStatus("Pending")</span>
                default:<span class="cov8" title="1">
                        return ColorStatus(status) + "(" + c[0].Reason + ")"</span>
                }
        }
        <span class="cov8" title="1">return ColorStatus(status)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        "fmt"
        "strings"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

// Param returns params with their values. If user value is not defined then returns default value,
// if default value is not defined then returns param's type
func Param(params []v1.Param, paramSpec []v1.ParamSpec) string <span class="cov8" title="1">{
        if len(params) == 0 </span><span class="cov8" title="1">{
                return "---"
        }</span>
        <span class="cov8" title="1">var str string
        for i, param := range params </span><span class="cov8" title="1">{
                paramValue := ""
                switch param.Value.Type </span>{
                case "string":<span class="cov8" title="1">
                        paramValue = CheckParamDefaultValue(param.Value.StringVal, paramSpec)</span>
                case "array":<span class="cov8" title="1">
                        paramValue = "["
                        for j, pv := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                                pv = CheckParamDefaultValue(pv, paramSpec)
                                if j == len(param.Value.ArrayVal)-1 </span><span class="cov8" title="1">{
                                        paramValue += " " + pv + " ]"
                                }</span> else<span class="cov8" title="1"> {
                                        paramValue += " " + pv + ","
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        paramValue = "{"
                        j := 0
                        for k, v := range param.Value.ObjectVal </span><span class="cov8" title="1">{
                                pv := CheckParamDefaultValue(v, paramSpec)
                                if j == len(param.Value.ObjectVal)-1 </span><span class="cov8" title="1">{
                                        paramValue += fmt.Sprintf(" %s: %s }", k, pv)
                                }</span> else<span class="cov0" title="0"> {
                                        paramValue += fmt.Sprintf(" %s: %s ,", k, pv)
                                }</span>
                                <span class="cov8" title="1">j++</span>
                        }
                }
                <span class="cov8" title="1">if i == len(params)-1 </span><span class="cov8" title="1">{
                        str += fmt.Sprintf("%s: %s", param.Name, paramValue)
                }</span> else<span class="cov8" title="1"> {
                        str += fmt.Sprintf("%s: %s, ", param.Name, paramValue)
                }</span>
        }
        <span class="cov8" title="1">return str</span>
}

// CheckParamDefaultValue returns param's value if defined, if not then checks for default value
// If default value is not defined then returns param's type
func CheckParamDefaultValue(param string, paramSpec []v1.ParamSpec) string <span class="cov8" title="1">{
        if strings.ContainsAny(param, "$") </span><span class="cov8" title="1">{
                paramValue := ""
                replacer := strings.NewReplacer("$", "", "(", "", ")", "", "params.", "")
                paramName := replacer.Replace(param)
                for _, spec := range paramSpec </span><span class="cov8" title="1">{
                        if spec.Name == paramName </span><span class="cov8" title="1">{
                                if spec.Default == nil </span><span class="cov8" title="1">{
                                        paramValue = string(spec.Type)
                                        break</span>
                                }
                                <span class="cov8" title="1">switch spec.Default.Type </span>{
                                case "string":<span class="cov8" title="1">
                                        paramValue = spec.Default.StringVal</span>
                                case "array":<span class="cov8" title="1">
                                        pv := ""
                                        for k, val := range spec.Default.ArrayVal </span><span class="cov8" title="1">{
                                                if k == 0 </span><span class="cov8" title="1">{
                                                        pv += val
                                                }</span> else<span class="cov8" title="1"> {
                                                        pv += " " + val
                                                }</span>
                                        }
                                        <span class="cov8" title="1">paramValue = pv</span>
                                default:<span class="cov0" title="0">
                                        pv := "{"
                                        first := true
                                        for k, val := range spec.Default.ObjectVal </span><span class="cov0" title="0">{
                                                if !first </span><span class="cov0" title="0">{
                                                        pv += ","
                                                }</span>
                                                <span class="cov0" title="0">pv += k + ":" + val
                                                first = false</span>
                                        }
                                        <span class="cov0" title="0">paramValue = pv + "}"</span>
                                }
                                <span class="cov8" title="1">break</span>
                        }
                }
                <span class="cov8" title="1">return paramValue</span>
        }
        <span class="cov8" title="1">return param</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        "encoding/json"
        "strings"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

// Result will format a given result value
func Result(value v1.ParamValue) string <span class="cov8" title="1">{
        switch value.Type </span>{
        case v1.ParamTypeString:<span class="cov8" title="1">
                // remove trailing new-line from value
                return strings.TrimSuffix(value.StringVal, "\n")</span>
        case v1.ParamTypeArray:<span class="cov8" title="1">
                return strings.Join(value.ArrayVal, ", ")</span>
        case v1.ParamTypeObject:<span class="cov8" title="1">
                // FIXME: do not ignore the error
                v, _ := json.Marshal(value.ObjectVal)
                return string(v)</span>
        }
        <span class="cov0" title="0">return "&lt;invalid result type&gt;"</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright © 2021 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func GetTaskRefName(task *v1.PipelineTask) string <span class="cov0" title="0">{
        if task.TaskRef != nil </span><span class="cov0" title="0">{
                return task.TaskRef.Name
        }</span>
        <span class="cov0" title="0">return "EMBEDDED"</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        "github.com/hako/durafmt"
        "github.com/jonboulle/clockwork"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func Age(t *metav1.Time, c clockwork.Clock) string <span class="cov0" title="0">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return "---"
        }</span>

        <span class="cov0" title="0">dur := c.Since(t.Time)
        return durafmt.ParseShort(dur).String() + " ago"</span>
}

func Duration(t1, t2 *metav1.Time) string <span class="cov8" title="1">{
        if t1.IsZero() || t2.IsZero() </span><span class="cov8" title="1">{
                return "---"
        }</span>

        <span class="cov8" title="1">dur := t2.Time.Sub(t1.Time)
        return dur.String()</span>
}

func Timeout(t *metav1.Duration) string <span class="cov8" title="1">{
        if t == nil </span><span class="cov8" title="1">{
                return "---"
        }</span>

        <span class="cov8" title="1">return durafmt.Parse(t.Duration).String()</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright © 2021 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

func FindVersion(version map[string]string) string <span class="cov8" title="1">{
        if _, ok := version["app.kubernetes.io/version"]; ok </span><span class="cov8" title="1">{
                return version["app.kubernetes.io/version"]
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package formatted

import (
        "fmt"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
)

func Workspace(ws v1.WorkspaceBinding) string <span class="cov8" title="1">{
        if ws.VolumeClaimTemplate != nil </span><span class="cov0" title="0">{
                return "VolumeClaimTemplate"
        }</span>
        <span class="cov8" title="1">if ws.PersistentVolumeClaim != nil </span><span class="cov0" title="0">{
                claimName := ws.PersistentVolumeClaim.ClaimName
                return fmt.Sprintf("PersistentVolumeClaim (claimName=%s)", claimName)
        }</span>
        <span class="cov8" title="1">if ws.EmptyDir != nil </span><span class="cov8" title="1">{
                dirType := getWorkspaceEmptyDir(ws.EmptyDir)
                return fmt.Sprintf("EmptyDir (emptyDir=%s)", dirType)
        }</span>
        <span class="cov8" title="1">if ws.ConfigMap != nil </span><span class="cov8" title="1">{
                cm := getWorkspaceConfig(ws.ConfigMap)
                return fmt.Sprintf("ConfigMap (%s)", cm)
        }</span>
        <span class="cov8" title="1">if ws.Secret != nil </span><span class="cov8" title="1">{
                secret := getWorkspaceSecret(ws.Secret)
                return fmt.Sprintf("Secret (%s)", secret)
        }</span>
        <span class="cov8" title="1">if ws.CSI != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("CSI (Driver=%s)", ws.CSI.Driver)
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func getWorkspaceEmptyDir(ed *corev1.EmptyDirVolumeSource) string <span class="cov8" title="1">{
        sM := ed.Medium
        var dirType string
        if sM == corev1.StorageMediumDefault </span><span class="cov8" title="1">{
                dirType = ""
        }</span>
        <span class="cov8" title="1">if sM == corev1.StorageMediumMemory </span><span class="cov8" title="1">{
                dirType = "Memory"
        }</span>
        <span class="cov8" title="1">if sM == corev1.StorageMediumHugePages </span><span class="cov0" title="0">{
                dirType = "HugePages"
        }</span>
        <span class="cov8" title="1">return dirType</span>
}

func getWorkspaceConfig(cm *corev1.ConfigMapVolumeSource) string <span class="cov8" title="1">{
        cmName := cm.LocalObjectReference.Name
        cmItems := cm.Items
        str := fmt.Sprintf("config=%s", cmName)
        if len(cmItems) != 0 </span><span class="cov0" title="0">{
                str = fmt.Sprintf("%s%s", str, getItems(cmItems))
        }</span>
        <span class="cov8" title="1">return str</span>
}

func getWorkspaceSecret(secret *corev1.SecretVolumeSource) string <span class="cov8" title="1">{
        secretName := secret.SecretName
        secretItems := secret.Items
        str := fmt.Sprintf("secret=%s", secretName)
        if len(secretItems) != 0 </span><span class="cov0" title="0">{
                str = fmt.Sprintf("%s%s", str, getItems(secretItems))
        }</span>
        <span class="cov8" title="1">return str</span>
}

func getItems(items []corev1.KeyToPath) string <span class="cov0" title="0">{
        str := ""
        for i := range items </span><span class="cov0" title="0">{
                kp := items[i]
                key := kp.Key
                value := kp.Path
                str = fmt.Sprintf("%s,item=%s=%s", str, key, value)
        }</span>
        <span class="cov0" title="0">return str</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package labels

import (
        "errors"
        "strings"
)

const invalidLabel = "invalid input format for label parameter: "

func MergeLabels(l map[string]string, optLabel []string) (map[string]string, error) <span class="cov8" title="1">{
        labels, err := parseLabels(optLabel)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(labels) == 0 </span><span class="cov8" title="1">{
                return l, nil
        }</span>

        <span class="cov8" title="1">if l == nil </span><span class="cov8" title="1">{
                return labels, nil
        }</span>

        <span class="cov8" title="1">for k, v := range labels </span><span class="cov8" title="1">{
                l[k] = v
        }</span>
        <span class="cov8" title="1">return l, nil</span>
}

func parseLabels(p []string) (map[string]string, error) <span class="cov8" title="1">{
        labels := map[string]string{}
        for _, v := range p </span><span class="cov8" title="1">{
                r := strings.SplitN(v, "=", 2)
                if len(r) != 2 </span><span class="cov8" title="1">{
                        return nil, errors.New(invalidLabel + v)
                }</span>
                <span class="cov8" title="1">labels[r[0]] = r[1]</span>
        }
        <span class="cov8" title="1">return labels, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package log

import (
        "fmt"
        "sync"
        "time"

        "github.com/tektoncd/cli/pkg/actions"
        pipelinepkg "github.com/tektoncd/cli/pkg/pipeline"
        pipelinerunpkg "github.com/tektoncd/cli/pkg/pipelinerun"
        taskrunpkg "github.com/tektoncd/cli/pkg/taskrun"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/runtime"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

func (r *Reader) readPipelineLog() (&lt;-chan Log, &lt;-chan error, error) <span class="cov0" title="0">{
        pr, err := pipelinerunpkg.GetPipelineRun(pipelineRunGroupResource, r.clients, r.run, r.ns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">if !pr.IsDone() &amp;&amp; r.follow </span><span class="cov0" title="0">{
                return r.readLivePipelineLogs(pr)
        }</span>
        <span class="cov0" title="0">return r.readAvailablePipelineLogs(pr)</span>
}

func (r *Reader) readLivePipelineLogs(pr *v1.PipelineRun) (&lt;-chan Log, &lt;-chan error, error) <span class="cov0" title="0">{
        logC := make(chan Log)
        errC := make(chan error)

        go func() </span><span class="cov0" title="0">{
                defer close(logC)
                defer close(errC)

                prTracker := pipelinerunpkg.NewTracker(pr.Name, r.ns, r.clients)
                trC := prTracker.Monitor(r.tasks)

                wg := sync.WaitGroup{}
                taskIndex := 0

                for trs := range trC </span><span class="cov0" title="0">{
                        wg.Add(len(trs))

                        for _, run := range trs </span><span class="cov0" title="0">{
                                taskIndex++
                                // NOTE: passing tr, taskIdx to avoid data race
                                go func(tr taskrunpkg.Run, taskNum int) </span><span class="cov0" title="0">{
                                        defer wg.Done()

                                        // clone the object to keep task number and name separately
                                        c := r.clone()
                                        c.setUpTask(taskNum, tr)
                                        c.pipeLogs(logC, errC)
                                }</span>(run, taskIndex)
                        }
                }

                <span class="cov0" title="0">wg.Wait()

                if !empty(pr.Status) &amp;&amp; pr.Status.Conditions[0].Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                        errC &lt;- fmt.Errorf("%s", pr.Status.Conditions[0].Message)
                }</span>
        }()

        <span class="cov0" title="0">return logC, errC, nil</span>
}

func (r *Reader) readAvailablePipelineLogs(pr *v1.PipelineRun) (&lt;-chan Log, &lt;-chan error, error) <span class="cov0" title="0">{
        if err := r.waitUntilAvailable(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">ordered, err := r.getOrderedTasks(pr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">taskRuns := taskrunpkg.Filter(ordered, r.tasks)
        if len(taskRuns) == 0 &amp;&amp; len(r.tasks) != 0 </span><span class="cov0" title="0">{
                availTasks := []string{}
                for _, o := range ordered </span><span class="cov0" title="0">{
                        availTasks = append(availTasks, o.Task)
                }</span>
                <span class="cov0" title="0">return nil, nil, fmt.Errorf("passed filtered tasks: %v is not available, available tasks are: %v", r.tasks, availTasks)</span>
        }

        <span class="cov0" title="0">logC := make(chan Log)
        errC := make(chan error)

        go func() </span><span class="cov0" title="0">{
                defer close(logC)
                defer close(errC)

                // clone the object to keep task number and name separately
                c := r.clone()
                for i, tr := range taskRuns </span><span class="cov0" title="0">{
                        c.setUpTask(i+1, tr)
                        c.pipeLogs(logC, errC)
                }</span>

                <span class="cov0" title="0">if !empty(pr.Status) &amp;&amp; pr.Status.Conditions[0].Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                        errC &lt;- fmt.Errorf("%s", pr.Status.Conditions[0].Message)
                }</span>
        }()

        <span class="cov0" title="0">return logC, errC, nil</span>
}

// reading of logs should wait till the status of run is unknown
// only if run status is unknown, open a watch channel on run
// and keep checking the status until it changes to true|false
// or the reach timeout
func (r *Reader) waitUntilAvailable() error <span class="cov0" title="0">{
        first := true
        opts := metav1.ListOptions{
                FieldSelector: fields.OneTermEqualSelector("metadata.name", r.run).String(),
        }
        run, err := pipelinerunpkg.GetPipelineRun(pipelineRunGroupResource, r.clients, r.run, r.ns)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if empty(run.Status) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if run.Status.Conditions[0].Status != corev1.ConditionUnknown </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">watchRun, err := actions.Watch(pipelineRunGroupResource, r.clients, r.ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                select </span>{
                case event := &lt;-watchRun.ResultChan():<span class="cov0" title="0">
                        run, err := cast2pipelinerun(event.Object)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if run.IsDone() </span><span class="cov0" title="0">{
                                watchRun.Stop()
                                return nil
                        }</span>
                        <span class="cov0" title="0">if first </span><span class="cov0" title="0">{
                                first = false
                                fmt.Fprintln(r.stream.Out, "Pipeline still running ...")
                        }</span>
                case &lt;-time.After(r.activityTimeout):<span class="cov0" title="0">
                        watchRun.Stop()
                        if isPipelineRunRunning(run.Status.Conditions) </span><span class="cov0" title="0">{
                                fmt.Fprintln(r.stream.Out, "PipelineRun is still running:", run.Status.Conditions[0].Message)
                                return nil
                        }</span>
                        <span class="cov0" title="0">if err = hasPipelineRunFailed(run.Status.Conditions); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("PipelineRun %s has failed: %s", run.Name, err.Error())
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("PipelineRun has not started yet")</span>
                }
        }
}

func (r *Reader) pipeLogs(logC chan&lt;- Log, errC chan&lt;- error) <span class="cov0" title="0">{
        tlogC, terrC, err := r.readTaskLog()
        if err != nil </span><span class="cov0" title="0">{
                errC &lt;- err
                return
        }</span>

        <span class="cov0" title="0">for tlogC != nil || terrC != nil </span><span class="cov0" title="0">{
                select </span>{
                case l, ok := &lt;-tlogC:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                tlogC = nil
                                continue</span>
                        }
                        <span class="cov0" title="0">logC &lt;- Log{Task: l.Task, Step: l.Step, Log: l.Log}</span>

                case e, ok := &lt;-terrC:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                terrC = nil
                                continue</span>
                        }
                        <span class="cov0" title="0">errC &lt;- fmt.Errorf("failed to get logs for task %s : %s", r.task, e)</span>
                }
        }
}

func (r *Reader) setUpTask(taskNumber int, tr taskrunpkg.Run) <span class="cov0" title="0">{
        r.setNumber(taskNumber)
        r.setRun(tr.Name)
        r.setTask(tr.Task)
        r.setRetries(tr.Retries)
}</span>

// getOrderedTasks get Tasks in order from Spec.PipelineRef or Spec.PipelineSpec
// and return trh.Run after converted taskruns into trh.Run.
func (r *Reader) getOrderedTasks(pr *v1.PipelineRun) ([]taskrunpkg.Run, error) <span class="cov0" title="0">{
        var tasks []v1.PipelineTask
        switch </span>{
        case pr.Spec.PipelineRef != nil:<span class="cov0" title="0">
                if pr.Spec.PipelineRef.Resolver != "" </span><span class="cov0" title="0">{
                        if pr.Status.PipelineSpec != nil </span><span class="cov0" title="0">{
                                tasks = append(tasks, pr.Status.PipelineSpec.Tasks...)
                        }</span> else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("pipelinerun %s does not have the PipelineRunSpec", pr.Name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        pl, err := pipelinepkg.GetPipeline(pipelineGroupResource, r.clients, pr.Spec.PipelineRef.Name, r.ns)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">tasks = pl.Spec.Tasks
                        tasks = append(tasks, pl.Spec.Finally...)</span>
                }
        case pr.Spec.PipelineSpec != nil:<span class="cov0" title="0">
                tasks = pr.Spec.PipelineSpec.Tasks
                tasks = append(tasks, pr.Spec.PipelineSpec.Finally...)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("pipelinerun %s did not provide PipelineRef or PipelineSpec", pr.Name)</span>
        }

        <span class="cov0" title="0">trsMap, err := pipelinerunpkg.GetTaskRunsWithStatus(pr, r.clients, r.ns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort taskruns, to display the taskrun logs as per pipeline tasks order
        <span class="cov0" title="0">return taskrunpkg.SortTasksBySpecOrder(tasks, trsMap), nil</span>
}

func empty(status v1.PipelineRunStatus) bool <span class="cov0" title="0">{
        if status.Conditions == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return len(status.Conditions) == 0</span>
}

func hasPipelineRunFailed(prConditions duckv1.Conditions) error <span class="cov0" title="0">{
        if len(prConditions) != 0 &amp;&amp; prConditions[0].Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                return fmt.Errorf("pipelinerun has failed: %s", prConditions[0].Message)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func isPipelineRunRunning(prConditions duckv1.Conditions) bool <span class="cov0" title="0">{
        if len(prConditions) != 0 &amp;&amp; prConditions[0].Status == corev1.ConditionUnknown </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func cast2pipelinerun(obj runtime.Object) (*v1.PipelineRun, error) <span class="cov0" title="0">{
        var run *v1.PipelineRun
        unstruct, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstruct, &amp;run); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return run, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package log

import (
        "fmt"
        "time"

        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/options"
        "github.com/tektoncd/cli/pkg/pods"
        "github.com/tektoncd/cli/pkg/pods/stream"
)

type Reader struct {
        run             string
        ns              string
        clients         *cli.Clients
        streamer        stream.NewStreamerFunc
        stream          *cli.Stream
        allSteps        bool
        follow          bool
        timestamps      bool
        tasks           []string
        steps           []string
        logType         string
        task            string
        number          int
        activityTimeout time.Duration
        retries         int
}

func NewReader(logType string, opts *options.LogOptions) (*Reader, error) <span class="cov0" title="0">{
        streamer := pods.NewStream
        if opts.Streamer != nil </span><span class="cov0" title="0">{
                streamer = opts.Streamer
        }</span>

        <span class="cov0" title="0">cs, err := opts.Params.Clients()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var run string
        switch logType </span>{
        case LogTypePipeline:<span class="cov0" title="0">
                run = opts.PipelineRunName</span>
        case LogTypeTask:<span class="cov0" title="0">
                run = opts.TaskrunName</span>
        }

        <span class="cov0" title="0">at := 10 * time.Second
        if opts.ActivityTimeout != 0 </span><span class="cov0" title="0">{
                at = opts.ActivityTimeout
        }</span>

        <span class="cov0" title="0">return &amp;Reader{
                run:             run,
                ns:              opts.Params.Namespace(),
                clients:         cs,
                streamer:        streamer,
                stream:          opts.Stream,
                follow:          opts.Follow,
                timestamps:      opts.Timestamps,
                allSteps:        opts.AllSteps,
                tasks:           opts.Tasks,
                steps:           opts.Steps,
                logType:         logType,
                activityTimeout: at,
        }, nil</span>
}

func (r *Reader) Read() (&lt;-chan Log, &lt;-chan error, error) <span class="cov0" title="0">{
        switch r.logType </span>{
        case LogTypePipeline:<span class="cov0" title="0">
                return r.readPipelineLog()</span>
        case LogTypeTask:<span class="cov0" title="0">
                return r.readTaskLog()</span>
        }
        <span class="cov0" title="0">return nil, nil, fmt.Errorf("unknown log type")</span>
}

func (r *Reader) setNumber(number int) <span class="cov0" title="0">{
        r.number = number
}</span>

func (r *Reader) setRetries(retries int) <span class="cov0" title="0">{
        r.retries = retries
}</span>

func (r *Reader) setRun(run string) <span class="cov0" title="0">{
        r.run = run
}</span>

func (r *Reader) setTask(task string) <span class="cov0" title="0">{
        r.task = task
}</span>

func (r *Reader) clone() *Reader <span class="cov0" title="0">{
        c := *r
        return &amp;c
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package log

import (
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/pods"
        taskrunpkg "github.com/tektoncd/cli/pkg/taskrun"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/apimachinery/pkg/runtime"
)

const (
        MsgTRNotFoundErr = "Unable to get TaskRun"
)

type step struct {
        name      string
        container string
        state     corev1.ContainerState
}

func (s *step) hasStarted() bool <span class="cov0" title="0">{
        return s.state.Waiting == nil
}</span>

func (r *Reader) readTaskLog() (&lt;-chan Log, &lt;-chan error, error) <span class="cov0" title="0">{
        tr, err := taskrunpkg.GetTaskRun(taskrunGroupResource, r.clients, r.run, r.ns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("%s: %s", MsgTRNotFoundErr, err)
        }</span>

        <span class="cov0" title="0">r.formTaskName(tr)

        if !tr.IsDone() &amp;&amp; r.follow </span><span class="cov0" title="0">{
                return r.readLiveTaskLogs(tr)
        }</span>
        <span class="cov0" title="0">return r.readAvailableTaskLogs(tr)</span>
}

func (r *Reader) formTaskName(tr *v1.TaskRun) <span class="cov0" title="0">{
        if r.task != "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if name, ok := tr.Labels["tekton.dev/pipelineTask"]; ok </span><span class="cov0" title="0">{
                r.task = name
                return
        }</span>

        <span class="cov0" title="0">if tr.Spec.TaskRef != nil </span><span class="cov0" title="0">{
                r.task = tr.Spec.TaskRef.Name
                return
        }</span>

        <span class="cov0" title="0">r.task = fmt.Sprintf("Task %d", r.number)</span>
}

func (r *Reader) readLiveTaskLogs(tr *v1.TaskRun) (&lt;-chan Log, &lt;-chan error, error) <span class="cov0" title="0">{
        podC, podErrC, err := r.getTaskRunPodNames(tr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">logC, errC := r.readPodLogs(podC, podErrC, r.follow, r.timestamps)
        return logC, errC, nil</span>
}

func (r *Reader) readAvailableTaskLogs(tr *v1.TaskRun) (&lt;-chan Log, &lt;-chan error, error) <span class="cov0" title="0">{
        if !tr.HasStarted() </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("task %s has not started yet", r.task)
        }</span>

        // Check if taskrun failed on start up
        <span class="cov0" title="0">if err := hasTaskRunFailed(tr, r.task); err != nil </span><span class="cov0" title="0">{
                if r.stream != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(r.stream.Err, "%s\n", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        return nil, nil, err
                }</span>
        }

        <span class="cov0" title="0">if tr.Status.PodName == "" </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("pod for taskrun %s not available yet", tr.Name)
        }</span>

        <span class="cov0" title="0">podC := make(chan string)
        go func() </span><span class="cov0" title="0">{
                defer close(podC)
                if tr.Status.PodName != "" </span><span class="cov0" title="0">{
                        if len(tr.Status.RetriesStatus) != 0 </span><span class="cov0" title="0">{
                                for _, retryStatus := range tr.Status.RetriesStatus </span><span class="cov0" title="0">{
                                        podC &lt;- retryStatus.PodName
                                }</span>
                        }
                        <span class="cov0" title="0">podC &lt;- tr.Status.PodName</span>
                }
        }()

        <span class="cov0" title="0">logC, errC := r.readPodLogs(podC, nil, false, r.timestamps)
        return logC, errC, nil</span>
}

func (r *Reader) readStepsLogs(logC chan&lt;- Log, errC chan&lt;- error, steps []*step, pod *pods.Pod, follow, timestamps bool) <span class="cov0" title="0">{
        for _, step := range steps </span><span class="cov0" title="0">{
                if !follow &amp;&amp; !step.hasStarted() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">container := pod.Container(step.container)
                containerLogC, containerLogErrC, err := container.LogReader(follow, timestamps).Read()
                if err != nil </span><span class="cov0" title="0">{
                        errC &lt;- fmt.Errorf("error in getting logs for step %s: %s", step.name, err)
                        continue</span>
                }

                <span class="cov0" title="0">for containerLogC != nil || containerLogErrC != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case l, ok := &lt;-containerLogC:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        containerLogC = nil
                                        logC &lt;- Log{Task: r.task, Step: step.name, Log: "EOFLOG"}
                                        continue</span>
                                }
                                <span class="cov0" title="0">logC &lt;- Log{Task: r.task, Step: step.name, Log: l.Log}</span>

                        case e, ok := &lt;-containerLogErrC:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        containerLogErrC = nil
                                        continue</span>
                                }

                                <span class="cov0" title="0">errC &lt;- fmt.Errorf("failed to get logs for %s: %s", step.name, e)</span>
                        }
                }

                <span class="cov0" title="0">if err := container.Status(); err != nil </span><span class="cov0" title="0">{
                        errC &lt;- err
                        return
                }</span>
        }
}

func (r *Reader) readPodLogs(podC &lt;-chan string, podErrC &lt;-chan error, follow, timestamps bool) (&lt;-chan Log, &lt;-chan error) <span class="cov0" title="0">{
        logC := make(chan Log)
        errC := make(chan error)
        var wg sync.WaitGroup

        wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                // forward pod error to error stream
                if podErrC != nil </span><span class="cov0" title="0">{
                        for podErr := range podErrC </span><span class="cov0" title="0">{
                                errC &lt;- podErr
                        }</span>
                }
                <span class="cov0" title="0">wg.Done()

                // wait for all goroutines to close before closing errC channel
                wg.Wait()
                close(errC)</span>
        }()

        <span class="cov0" title="0">wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        close(logC)
                        wg.Done()
                }</span>()

                <span class="cov0" title="0">for podName := range podC </span><span class="cov0" title="0">{
                        p := pods.New(podName, r.ns, r.clients.Kube, r.streamer)
                        var pod *corev1.Pod
                        var err error

                        if follow </span><span class="cov0" title="0">{
                                pod, err = p.Wait()
                        }</span> else<span class="cov0" title="0"> {
                                pod, err = p.Get()
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                errC &lt;- fmt.Errorf("task %s failed: %s. Run tkn tr desc %s for more details", r.task, strings.TrimSpace(err.Error()), r.run)
                                continue</span>
                        }
                        <span class="cov0" title="0">steps := filterSteps(pod, r.allSteps, r.steps)
                        if len(steps) == 0 </span><span class="cov0" title="0">{
                                errC &lt;- fmt.Errorf("no steps found for task %s", r.task)
                                continue</span>
                        }
                        <span class="cov0" title="0">r.readStepsLogs(logC, errC, steps, p, follow, timestamps)</span>
                }
        }()

        <span class="cov0" title="0">return logC, errC</span>
}

// Reading of logs should wait until the name of the pod is
// updated in the status. Open a watch channel on the task run
// and keep checking the status until the taskrun completes
// or the timeout is reached.
func (r *Reader) getTaskRunPodNames(run *v1.TaskRun) (&lt;-chan string, &lt;-chan error, error) <span class="cov0" title="0">{
        opts := metav1.ListOptions{
                FieldSelector: fields.OneTermEqualSelector("metadata.name", r.run).String(),
        }

        watchRun, err := actions.Watch(taskrunGroupResource, r.clients, r.ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">podC := make(chan string)
        errC := make(chan error)

        go func() </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        close(podC)
                        close(errC)
                        watchRun.Stop()
                }</span>()

                <span class="cov0" title="0">podMap := make(map[string]bool)
                addPod := func(name string) </span><span class="cov0" title="0">{
                        if _, ok := podMap[name]; !ok </span><span class="cov0" title="0">{
                                podMap[name] = true
                                podC &lt;- name
                        }</span>
                }

                <span class="cov0" title="0">if len(run.Status.RetriesStatus) != 0 </span><span class="cov0" title="0">{
                        for _, retryStatus := range run.Status.RetriesStatus </span><span class="cov0" title="0">{
                                addPod(retryStatus.PodName)
                        }</span>
                }
                <span class="cov0" title="0">if run.Status.PodName != "" </span><span class="cov0" title="0">{
                        addPod(run.Status.PodName)
                }</span>

                <span class="cov0" title="0">timeout := time.After(r.activityTimeout)

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case event := &lt;-watchRun.ResultChan():<span class="cov0" title="0">
                                var err error
                                run, err = cast2taskrun(event.Object)
                                if err != nil </span><span class="cov0" title="0">{
                                        errC &lt;- err
                                        return
                                }</span>
                                <span class="cov0" title="0">if run.Status.PodName != "" </span><span class="cov0" title="0">{
                                        addPod(run.Status.PodName)
                                        if !areRetriesScheduled(run, r.retries) </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                }
                        case &lt;-timeout:<span class="cov0" title="0">
                                // Check if taskrun failed on start up
                                if err := hasTaskRunFailed(run, r.task); err != nil </span><span class="cov0" title="0">{
                                        errC &lt;- err
                                        return
                                }</span>
                                // check if pod has been started and has a name
                                <span class="cov0" title="0">if run.HasStarted() &amp;&amp; run.Status.PodName != "" </span><span class="cov0" title="0">{
                                        if areRetriesScheduled(run, r.retries) </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">return</span>
                                }
                                <span class="cov0" title="0">errC &lt;- fmt.Errorf("task %s has not started yet or pod for task not yet available", r.task)
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return podC, errC, nil</span>
}

func filterSteps(pod *corev1.Pod, allSteps bool, stepsGiven []string) []*step <span class="cov0" title="0">{
        steps := []*step{}
        if pod == nil </span><span class="cov0" title="0">{
                fmt.Printf("pod not found")
                return steps
        }</span>
        <span class="cov0" title="0">stepsInPod := getSteps(pod)

        if allSteps </span><span class="cov0" title="0">{
                steps = append(steps, getInitSteps(pod)...)
        }</span>

        <span class="cov0" title="0">if len(stepsGiven) == 0 </span><span class="cov0" title="0">{
                steps = append(steps, stepsInPod...)
                return steps
        }</span>

        <span class="cov0" title="0">stepsToAdd := map[string]bool{}
        for _, s := range stepsGiven </span><span class="cov0" title="0">{
                stepsToAdd[s] = true
        }</span>

        <span class="cov0" title="0">for _, sp := range stepsInPod </span><span class="cov0" title="0">{
                if stepsToAdd[sp.name] </span><span class="cov0" title="0">{
                        steps = append(steps, sp)
                }</span>
        }

        <span class="cov0" title="0">return steps</span>
}

func getInitSteps(pod *corev1.Pod) []*step <span class="cov0" title="0">{
        status := map[string]corev1.ContainerState{}
        for _, ics := range pod.Status.InitContainerStatuses </span><span class="cov0" title="0">{
                status[ics.Name] = ics.State
        }</span>

        <span class="cov0" title="0">steps := []*step{}
        for _, ic := range pod.Spec.InitContainers </span><span class="cov0" title="0">{
                steps = append(steps, &amp;step{
                        name:      strings.TrimPrefix(ic.Name, "step-"),
                        container: ic.Name,
                        state:     status[ic.Name],
                })
        }</span>

        <span class="cov0" title="0">return steps</span>
}

func getSteps(pod *corev1.Pod) []*step <span class="cov0" title="0">{
        status := map[string]corev1.ContainerState{}
        for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                status[cs.Name] = cs.State
        }</span>

        <span class="cov0" title="0">steps := []*step{}
        for _, c := range pod.Spec.Containers </span><span class="cov0" title="0">{
                steps = append(steps, &amp;step{
                        name:      strings.TrimPrefix(c.Name, "step-"),
                        container: c.Name,
                        state:     status[c.Name],
                })
        }</span>

        <span class="cov0" title="0">return steps</span>
}

func hasTaskRunFailed(tr *v1.TaskRun, taskName string) error <span class="cov0" title="0">{
        if isFailure(tr) </span><span class="cov0" title="0">{
                return fmt.Errorf("task %s has failed: %s", taskName, tr.Status.Conditions[0].Message)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func cast2taskrun(obj runtime.Object) (*v1.TaskRun, error) <span class="cov0" title="0">{
        var run *v1.TaskRun
        unstruct, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstruct, &amp;run); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return run, nil</span>
}

func isFailure(tr *v1.TaskRun) bool <span class="cov0" title="0">{
        conditions := tr.Status.Conditions
        return len(conditions) != 0 &amp;&amp; conditions[0].Status == corev1.ConditionFalse
}</span>

func areRetriesScheduled(tr *v1.TaskRun, retries int) bool <span class="cov0" title="0">{
        if tr.IsDone() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">retriesDone := len(tr.Status.RetriesStatus)
        return retriesDone &lt; retries</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package log

import (
        "fmt"

        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/formatted"
)

// Writer helps logging pod"s log
type Writer struct {
        fmt       *formatted.Color
        logType   string
        prefixing bool
}

// NewWriter returns the new instance of LogWriter
func NewWriter(logType string, prefixing bool) *Writer <span class="cov0" title="0">{
        return &amp;Writer{
                fmt:       formatted.NewColor(),
                logType:   logType,
                prefixing: prefixing,
        }
}</span>

// Write formatted pod's logs
func (lw *Writer) Write(s *cli.Stream, logC &lt;-chan Log, errC &lt;-chan error) <span class="cov0" title="0">{
        for logC != nil || errC != nil </span><span class="cov0" title="0">{
                select </span>{
                case l, ok := &lt;-logC:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                logC = nil
                                continue</span>
                        }

                        <span class="cov0" title="0">if l.Log == "EOFLOG" </span><span class="cov0" title="0">{
                                fmt.Fprintf(s.Out, "\n")
                                continue</span>
                        }

                        <span class="cov0" title="0">if lw.prefixing </span><span class="cov0" title="0">{
                                switch lw.logType </span>{
                                case LogTypePipeline:<span class="cov0" title="0">
                                        lw.fmt.Rainbow.Fprintf(l.Step, s.Out, "[%s : %s] ", l.Task, l.Step)</span>
                                case LogTypeTask:<span class="cov0" title="0">
                                        lw.fmt.Rainbow.Fprintf(l.Step, s.Out, "[%s] ", l.Step)</span>
                                }
                        }

                        <span class="cov0" title="0">fmt.Fprintf(s.Out, "%s\n", l.Log)</span>
                case e, ok := &lt;-errC:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                errC = nil
                                continue</span>
                        }
                        <span class="cov0" title="0">lw.fmt.Error(s.Err, "%s\n", e)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package names

import (
        "fmt"
        "strings"
)

func QuotedList(names []string) string <span class="cov0" title="0">{
        quoted := make([]string, len(names))
        for i := range names </span><span class="cov0" title="0">{
                quoted[i] = fmt.Sprintf("%q", names[i])
        }</span>
        <span class="cov0" title="0">return strings.Join(quoted, ", ")</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package options

import (
        "bufio"
        "fmt"
        "strings"

        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/names"
)

type DeleteOptions struct {
        Resource                 string
        ParentResource           string
        ParentResourceName       string
        ForceDelete              bool
        DeleteRelated            bool
        DeleteAllNs              bool
        DeleteAll                bool
        Keep                     int
        KeepSince                int
        IgnoreRunning            bool
        IgnoreRunningPipelinerun bool
        LabelSelector            string
}

func (o *DeleteOptions) CheckOptions(s *cli.Stream, resourceNames []string, ns string) error <span class="cov8" title="1">{
        namesLen := len(resourceNames)

        // make sure no resource names are provided when using --keep flag
        if namesLen &gt; 0 &amp;&amp; o.Keep &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("--keep flag should not have any arguments specified with it")
        }</span>

        // make sure no resource names are provided when using --all flag
        <span class="cov8" title="1">if namesLen &gt; 0 &amp;&amp; (o.DeleteAllNs || o.DeleteAll) || (o.DeleteAllNs &amp;&amp; o.DeleteRelated) </span><span class="cov8" title="1">{
                return fmt.Errorf("--all flag should not have any arguments or flags specified with it")
        }</span>

        // make sure either resource names are provided, name of related resource,
        // or --all specified if deleting PipelineRuns or TaskRuns
        <span class="cov8" title="1">if namesLen == 0 &amp;&amp; o.ParentResource != "" &amp;&amp; o.ParentResourceName == "" &amp;&amp; !o.DeleteAllNs </span><span class="cov8" title="1">{
                return fmt.Errorf("must provide %s name(s) or use --%s flag or --all flag to use delete", o.Resource, strings.ToLower(o.ParentResource))
        }</span>

        // make sure that resource name or --all flag is specified to use delete
        // in non PipelineRun or TaskRun deletions
        <span class="cov8" title="1">if namesLen == 0 &amp;&amp; o.ParentResource == "" &amp;&amp; o.ParentResourceName == "" &amp;&amp; !o.DeleteAllNs &amp;&amp; !o.DeleteAll </span><span class="cov8" title="1">{
                return fmt.Errorf("must provide %s name(s) or use --all flag with delete", o.Resource)
        }</span>

        <span class="cov8" title="1">if o.ForceDelete </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">formattedNames := names.QuotedList(resourceNames)

        keepStr := ""
        if o.Keep &gt; 0 </span><span class="cov8" title="1">{
                keepStr = fmt.Sprintf(" keeping %d %ss", o.Keep, o.Resource)
        }</span>
        <span class="cov8" title="1">if o.KeepSince &gt; 0 </span><span class="cov8" title="1">{
                keepStr = fmt.Sprintf(" except for ones created in last %d minutes", o.KeepSince)
        }</span>
        <span class="cov8" title="1">if o.Keep &gt; 0 &amp;&amp; o.KeepSince &gt; 0 </span><span class="cov8" title="1">{
                keepStr = fmt.Sprintf(" except for ones created in last %d minutes and keeping %d %ss", o.KeepSince, o.Keep, o.Resource)
        }</span>
        <span class="cov8" title="1">switch </span>{
        case o.DeleteAllNs:<span class="cov8" title="1">
                fmt.Fprintf(s.Out, "Are you sure you want to delete all %ss in namespace %q%s (y/n): ", o.Resource, ns, keepStr)</span>
        case o.DeleteAll:<span class="cov8" title="1">
                fmt.Fprintf(s.Out, "Are you sure you want to delete all %ss%s (y/n): ", o.Resource, keepStr)</span>
        case o.ParentResource != "" &amp;&amp; o.ParentResourceName != "":<span class="cov8" title="1">
                fmt.Fprintf(s.Out, "Are you sure you want to delete all %ss related to %s %q%s (y/n): ", o.Resource, o.ParentResource, o.ParentResourceName, keepStr)</span>
        case o.DeleteRelated:<span class="cov8" title="1">
                fmt.Fprintf(s.Out, "Are you sure you want to delete %s(s) %s and related resources (y/n): ", o.Resource, formattedNames)</span>
        default:<span class="cov8" title="1">
                fmt.Fprintf(s.Out, "Are you sure you want to delete %s(s) %s (y/n): ", o.Resource, formattedNames)</span>
        }

        <span class="cov8" title="1">return o.TakeInput(s, formattedNames)</span>
}

func (o *DeleteOptions) TakeInput(s *cli.Stream, formattedNames string) error <span class="cov8" title="1">{
        scanner := bufio.NewScanner(s.In)
        for scanner.Scan() </span><span class="cov8" title="1">{
                t := strings.TrimSpace(scanner.Text())
                if t == "y" </span><span class="cov8" title="1">{
                        return nil
                }</span> else<span class="cov8" title="1"> if t == "n" </span><span class="cov8" title="1">{
                        return fmt.Errorf("canceled deleting %s(s) %s", o.Resource, formattedNames)
                }</span>
                <span class="cov0" title="0">fmt.Fprint(s.Out, "Please enter (y/n): ")</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package options

import (
        "bytes"
        "fmt"
        "os"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/AlecAivazis/survey/v2/terminal"
        "github.com/fatih/color"
        "github.com/ktr0731/go-fuzzyfinder"
        "github.com/tektoncd/cli/pkg/cli"
        pipelinerunpkg "github.com/tektoncd/cli/pkg/pipelinerun"
        taskrunpkg "github.com/tektoncd/cli/pkg/taskrun"
)

type DescribeOptions struct {
        Params                    cli.Params
        PipelineName              string
        PipelineRunName           string
        TaskName                  string
        TaskrunName               string
        Tasks                     []string
        TriggerTemplateName       string
        TriggerBindingName        string
        EventListenerName         string
        ClusterTriggerBindingName string
        Limit                     int
        AskOpts                   survey.AskOpt
        Fzf                       bool
        Last                      bool
}

func NewDescribeOptions(p cli.Params) *DescribeOptions <span class="cov8" title="1">{
        return &amp;DescribeOptions{Params: p,
                AskOpts: func(opt *survey.AskOptions) error </span><span class="cov0" title="0">{
                        opt.Stdio = terminal.Stdio{
                                In:  os.Stdin,
                                Out: os.Stdout,
                                Err: os.Stderr,
                        }
                        return nil
                }</span>,
        }
}

func (opts *DescribeOptions) ValidateOpts() error <span class="cov8" title="1">{
        if opts.Limit &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("limit was %d but must be a positive number", opts.Limit)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (opts *DescribeOptions) Ask(resource string, options []string) error <span class="cov8" title="1">{
        var ans string
        var qs = []*survey.Question{
                {
                        Name: resource,
                        Prompt: &amp;survey.Select{
                                Message: fmt.Sprintf("Select %s:", resource),
                                Options: options,
                        },
                },
        }

        if err := survey.Ask(qs, &amp;ans, opts.AskOpts); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // The Resource constants are defined in resource_names.go
        <span class="cov8" title="1">switch resource </span>{
        case ResourceNamePipeline:<span class="cov8" title="1">
                opts.PipelineName = ans</span>
        case ResourceNamePipelineRun:<span class="cov8" title="1">
                opts.PipelineRunName = strings.Fields(ans)[0]</span>
        case ResourceNameTask:<span class="cov8" title="1">
                opts.TaskName = ans</span>
        case ResourceNameTaskRun:<span class="cov8" title="1">
                opts.TaskrunName = strings.Fields(ans)[0]</span>
        case ResourceNameTriggerTemplate:<span class="cov8" title="1">
                opts.TriggerTemplateName = ans</span>
        case ResourceNameTriggerBinding:<span class="cov8" title="1">
                opts.TriggerBindingName = ans</span>
        case ResourceNameClusterTriggerBinding:<span class="cov8" title="1">
                opts.ClusterTriggerBindingName = ans</span>
        case ResourceNameEventListener:<span class="cov8" title="1">
                opts.EventListenerName = ans</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (opts *DescribeOptions) FuzzyAsk(resource string, options []string) error <span class="cov0" title="0">{
        chosencolouring := color.NoColor
        defer func() </span><span class="cov0" title="0">{
                color.NoColor = chosencolouring
        }</span>()
        // Remove colors as fuzzyfinder doesn't support it
        <span class="cov0" title="0">color.NoColor = true

        idx, err := fuzzyfinder.FindMulti(options,
                func(i int) string </span><span class="cov0" title="0">{
                        return strings.Fields(options[i])[0]
                }</span>,
                fuzzyfinder.WithPreviewWindow(func(i, _, _ int) string <span class="cov0" title="0">{
                        if i == -1 </span><span class="cov0" title="0">{
                                return ""
                        }</span>

                        <span class="cov0" title="0">buf := new(bytes.Buffer)
                        s := cli.Stream{
                                Out: buf,
                        }

                        bname := strings.Fields(options[i])[0]
                        cs, err := opts.Params.Clients()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Sprintf("Cannot initialize client: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">switch resource </span>{
                        case ResourceNameTaskRun:<span class="cov0" title="0">
                                err := taskrunpkg.PrintTaskRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Cannot get taskrun description for %s: %s", bname, err.Error())
                                }</span>
                        case ResourceNamePipelineRun:<span class="cov0" title="0">
                                err = pipelinerunpkg.PrintPipelineRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Cannot get pipelinerun description for %s: %s", bname, err.Error())
                                }</span>
                        }
                        <span class="cov0" title="0">return buf.String()</span>
                }))
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ans := options[idx[0]]
        fmt.Println(ans)
        switch resource </span>{
        case ResourceNamePipeline:<span class="cov0" title="0">
                opts.PipelineName = ans</span>
        case ResourceNamePipelineRun:<span class="cov0" title="0">
                opts.PipelineRunName = strings.Fields(ans)[0]</span>
        case ResourceNameTask:<span class="cov0" title="0">
                opts.TaskName = ans</span>
        case ResourceNameTaskRun:<span class="cov0" title="0">
                opts.TaskrunName = strings.Fields(ans)[0]</span>
        case ResourceNameTriggerTemplate:<span class="cov0" title="0">
                opts.TriggerTemplateName = ans</span>
        case ResourceNameTriggerBinding:<span class="cov0" title="0">
                opts.TriggerBindingName = ans</span>
        case ResourceNameClusterTriggerBinding:<span class="cov0" title="0">
                opts.ClusterTriggerBindingName = ans</span>
        case ResourceNameEventListener:<span class="cov0" title="0">
                opts.EventListenerName = ans</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package options

import (
        "bytes"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/AlecAivazis/survey/v2"
        "github.com/AlecAivazis/survey/v2/terminal"
        "github.com/fatih/color"
        "github.com/ktr0731/go-fuzzyfinder"
        "github.com/tektoncd/cli/pkg/cli"
        pipelinerunpkg "github.com/tektoncd/cli/pkg/pipelinerun"
        "github.com/tektoncd/cli/pkg/pods/stream"
        taskrunpkg "github.com/tektoncd/cli/pkg/taskrun"
)

type LogOptions struct {
        AllSteps        bool
        Follow          bool
        Params          cli.Params
        PipelineName    string
        PipelineRunName string
        TaskName        string
        TaskrunName     string
        Stream          *cli.Stream
        Streamer        stream.NewStreamerFunc
        Tasks           []string
        Steps           []string
        Last            bool
        Limit           int
        AskOpts         survey.AskOpt
        Fzf             bool
        Tail            int64
        Timestamps      bool
        Prefixing       bool
        ExitWithPrError bool
        // ActivityTimeout is the amount of time to wait for some activity
        // (e.g. Pod ready) before giving up.
        ActivityTimeout time.Duration
}

func NewLogOptions(p cli.Params) *LogOptions <span class="cov8" title="1">{
        return &amp;LogOptions{Params: p,
                AskOpts: func(opt *survey.AskOptions) error </span><span class="cov0" title="0">{
                        opt.Stdio = terminal.Stdio{
                                In:  os.Stdin,
                                Out: os.Stdout,
                                Err: os.Stderr,
                        }
                        return nil
                }</span>,
        }
}

func (opts *LogOptions) ValidateOpts() error <span class="cov8" title="1">{
        if opts.Limit &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("limit was %d but must be a positive number", opts.Limit)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (opts *LogOptions) Ask(resource string, options []string) error <span class="cov8" title="1">{
        var ans string
        var qs = []*survey.Question{
                {
                        Name: resource,
                        Prompt: &amp;survey.Select{
                                Message: fmt.Sprintf("Select %s:", resource),
                                Options: options,
                        },
                },
        }

        if err := survey.Ask(qs, &amp;ans, opts.AskOpts); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch resource </span>{
        case ResourceNamePipeline:<span class="cov8" title="1">
                opts.PipelineName = ans</span>
        case ResourceNamePipelineRun:<span class="cov8" title="1">
                opts.PipelineRunName = strings.Fields(ans)[0]</span>
        case ResourceNameTask:<span class="cov8" title="1">
                opts.TaskName = ans</span>
        case ResourceNameTaskRun:<span class="cov8" title="1">
                opts.TaskrunName = strings.Fields(ans)[0]</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (opts *LogOptions) FuzzyAsk(resource string, options []string) error <span class="cov0" title="0">{
        chosencolouring := color.NoColor
        defer func() </span><span class="cov0" title="0">{
                color.NoColor = chosencolouring
        }</span>()
        // Remove colors as fuzzyfinder doesn't support it!
        <span class="cov0" title="0">color.NoColor = true

        idx, err := fuzzyfinder.FindMulti(options,
                func(i int) string </span><span class="cov0" title="0">{
                        return strings.Fields(options[i])[0]
                }</span>,
                fuzzyfinder.WithPreviewWindow(func(i, _, _ int) string <span class="cov0" title="0">{
                        if i == -1 </span><span class="cov0" title="0">{
                                return ""
                        }</span>

                        <span class="cov0" title="0">buf := new(bytes.Buffer)
                        s := cli.Stream{
                                Out: buf,
                        }

                        bname := strings.Fields(options[i])[0]
                        cs, err := opts.Params.Clients()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Sprintf("Cannot initialize client: %s", err.Error())
                        }</span>
                        <span class="cov0" title="0">switch resource </span>{
                        case ResourceNameTaskRun:<span class="cov0" title="0">
                                err := taskrunpkg.PrintTaskRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Cannot get taskrun description for %s: %s", bname, err.Error())
                                }</span>
                        case ResourceNamePipelineRun:<span class="cov0" title="0">
                                err = pipelinerunpkg.PrintPipelineRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Cannot get pipelinerun description for %s: %s", bname, err.Error())
                                }</span>
                        }
                        <span class="cov0" title="0">return buf.String()</span>
                }))
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ans := options[idx[0]]
        switch resource </span>{
        case ResourceNamePipeline:<span class="cov0" title="0">
                opts.PipelineName = ans</span>
        case ResourceNamePipelineRun:<span class="cov0" title="0">
                opts.PipelineRunName = strings.Fields(ans)[0]</span>
        case ResourceNameTask:<span class="cov0" title="0">
                opts.TaskName = ans</span>
        case ResourceNameTaskRun:<span class="cov0" title="0">
                opts.TaskrunName = strings.Fields(ans)[0]</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package options

import (
        "context"
        "fmt"
        "strings"

        "github.com/AlecAivazis/survey/v2"
        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/task"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var taskrunGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "taskruns"}

type InteractiveOpts struct {
        Stream                *cli.Stream
        CliParams             cli.Params
        InputResources        []string
        OutputResources       []string
        Params                []string
        Workspaces            []string
        AskOpts               survey.AskOpt
        Ns                    string
        SkipOptionalWorkspace bool
}

type TaskRunOpts struct {
        CliParams  cli.Params
        Last       bool
        UseTaskRun string
        PrefixName string
}

func (taskRunOpts *TaskRunOpts) UseTaskRunFrom(tr *v1beta1.TaskRun, cs *cli.Clients, tname string, taskKind string) error <span class="cov0" title="0">{
        var (
                trUsed *v1beta1.TaskRun
                err    error
        )
        if taskRunOpts.Last </span><span class="cov0" title="0">{
                name, err := task.LastRunName(cs, tname, taskRunOpts.CliParams.Namespace(), taskKind)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">trUsed, err = getTaskRunV1beta1(taskrunGroupResource, cs, name, taskRunOpts.CliParams.Namespace())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        } else<span class="cov0" title="0"> if taskRunOpts.UseTaskRun != "" </span><span class="cov0" title="0">{
                trUsed, err = getTaskRunV1beta1(taskrunGroupResource, cs, taskRunOpts.UseTaskRun, taskRunOpts.CliParams.Namespace())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if trUsed.Spec.TaskRef.Kind != v1beta1.TaskKind(taskKind) </span><span class="cov0" title="0">{
                return fmt.Errorf("%s doesn't belong to %s of kind %s", trUsed.ObjectMeta.Name, tname, taskKind)
        }</span>

        <span class="cov0" title="0">if len(trUsed.ObjectMeta.GenerateName) &gt; 0 &amp;&amp; taskRunOpts.PrefixName == "" </span><span class="cov0" title="0">{
                tr.ObjectMeta.GenerateName = trUsed.ObjectMeta.GenerateName
        }</span> else<span class="cov0" title="0"> if taskRunOpts.PrefixName == "" </span><span class="cov0" title="0">{
                tr.ObjectMeta.GenerateName = trUsed.ObjectMeta.Name + "-"
        }</span>
        // Copy over spec from last or previous TaskRun to use same values for this TaskRun
        <span class="cov0" title="0">tr.Spec = trUsed.Spec
        // Reapply blank status in case TaskRun used was cancelled
        tr.Spec.Status = ""
        return nil</span>
}

func (intOpts *InteractiveOpts) TaskParams(task *v1beta1.Task, skipParams map[string]string, useParamDefaults bool) error <span class="cov0" title="0">{
        for _, param := range task.Spec.Params </span><span class="cov0" title="0">{
                if param.Default == nil &amp;&amp; useParamDefaults || !useParamDefaults </span><span class="cov0" title="0">{
                        if _, toSkip := skipParams[param.Name]; toSkip </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">var ans, ques, defaultValue string
                        ques = fmt.Sprintf("Value for param `%s` of type `%s`?", param.Name, param.Type)
                        input := &amp;survey.Input{}
                        if param.Default != nil </span><span class="cov0" title="0">{
                                if param.Type == "string" </span><span class="cov0" title="0">{
                                        defaultValue = param.Default.StringVal
                                }</span>
                                <span class="cov0" title="0">if param.Type == "array" </span><span class="cov0" title="0">{
                                        defaultValue = strings.Join(param.Default.ArrayVal, ",")
                                }</span>
                                <span class="cov0" title="0">if param.Type == "object" </span><span class="cov0" title="0">{
                                        defaultValue = fmt.Sprintf("%+v", param.Default.ObjectVal)
                                }</span>
                                <span class="cov0" title="0">ques += fmt.Sprintf(" (Default is `%s`)", defaultValue)
                                input.Default = defaultValue</span>
                        }
                        <span class="cov0" title="0">input.Message = ques

                        var qs = []*survey.Question{
                                {
                                        Name:   "pipeline param",
                                        Prompt: input,
                                },
                        }

                        if err := survey.Ask(qs, &amp;ans, intOpts.AskOpts); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">intOpts.Params = append(intOpts.Params, param.Name+"="+ans)</span>
                }

        }
        <span class="cov0" title="0">return nil</span>
}

func (intOpts *InteractiveOpts) TaskWorkspaces(task *v1beta1.Task) error <span class="cov0" title="0">{
        for _, ws := range task.Spec.Workspaces </span><span class="cov0" title="0">{
                if ws.Optional &amp;&amp; intOpts.SkipOptionalWorkspace </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if ws.Optional </span><span class="cov0" title="0">{
                        isOptional, err := askParam(fmt.Sprintf("Do you want to give specifications for the optional workspace `%s`: (y/N)", ws.Name), intOpts.AskOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if strings.ToLower(isOptional) == "n" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }
                <span class="cov0" title="0">fmt.Fprintf(intOpts.Stream.Out, "Please give specifications for the workspace: %s \n", ws.Name)
                name, err := askParam("Name for the workspace :", intOpts.AskOpts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">workspace := "name=" + name
                subPath, err := askParam("Value of the Sub Path :", intOpts.AskOpts, " ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if subPath != " " </span><span class="cov0" title="0">{
                        workspace = workspace + ",subPath=" + subPath
                }</span>

                <span class="cov0" title="0">var kind string
                var qs = []*survey.Question{
                        {
                                Name: "workspace param",
                                Prompt: &amp;survey.Select{
                                        Message: "Type of the Workspace :",
                                        Options: []string{"config", "emptyDir", "secret", "pvc"},
                                        Default: "emptyDir",
                                },
                        },
                }
                if err := survey.Ask(qs, &amp;kind, intOpts.AskOpts); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">switch kind </span>{
                case "pvc":<span class="cov0" title="0">
                        claimName, err := askParam("Value of Claim Name :", intOpts.AskOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">workspace = workspace + ",claimName=" + claimName</span>
                case "emptyDir":<span class="cov0" title="0">
                        kind, err := askParam("Type of EmptyDir :", intOpts.AskOpts, "")
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">workspace = workspace + ",emptyDir=" + kind</span>
                case "config":<span class="cov0" title="0">
                        config, err := askParam("Name of the configmap :", intOpts.AskOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">workspace = workspace + ",config=" + config
                        items, err := getItems(intOpts.AskOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">workspace += items</span>
                case "secret":<span class="cov0" title="0">
                        secret, err := askParam("Name of the secret :", intOpts.AskOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">workspace = workspace + ",secret=" + secret
                        items, err := getItems(intOpts.AskOpts)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">workspace += items</span>
                }
                <span class="cov0" title="0">intOpts.Workspaces = append(intOpts.Workspaces, workspace)</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func getItems(askOpts survey.AskOpt) (string, error) <span class="cov0" title="0">{
        var items string
        for </span><span class="cov0" title="0">{
                it, err := askParam("Item Value:", askOpts, " ")
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if it != " " </span><span class="cov0" title="0">{
                        items = items + ",item=" + it
                }</span> else<span class="cov0" title="0"> {
                        return items, nil
                }</span>
        }
}

func askParam(ques string, askOpts survey.AskOpt, def ...string) (string, error) <span class="cov0" title="0">{
        var ans string
        input := &amp;survey.Input{
                Message: ques,
        }
        if len(def) != 0 </span><span class="cov0" title="0">{
                input.Default = def[0]
        }</span>

        <span class="cov0" title="0">var qs = []*survey.Question{
                {
                        Name:   "workspace param",
                        Prompt: input,
                },
        }
        if err := survey.Ask(qs, &amp;ans, askOpts); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return ans, nil</span>
}

func getTaskRunV1beta1(gr schema.GroupVersionResource, c *cli.Clients, trName, ns string) (*v1beta1.TaskRun, error) <span class="cov0" title="0">{
        var taskrun v1beta1.TaskRun
        gvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if gvr.Version == "v1beta1" </span><span class="cov0" title="0">{
                err := actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, &amp;taskrun)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;taskrun, nil</span>
        }

        <span class="cov0" title="0">var taskrunV1 v1.TaskRun
        err = actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, &amp;taskrunV1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = taskrun.ConvertFrom(context.Background(), &amp;taskrunV1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;taskrun, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package params

import (
        "errors"
        "fmt"
        "sort"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
)

const invalidParam = "invalid input format for param parameter: "

var paramByType = map[string]v1beta1.ParamType{}

func MergeParam(p []v1beta1.Param, optPar []string) ([]v1beta1.Param, error) <span class="cov8" title="1">{
        params, err := parseParam(optPar)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(params) == 0 </span><span class="cov8" title="1">{
                return p, nil
        }</span>

        <span class="cov8" title="1">for i := range p </span><span class="cov8" title="1">{
                if v, ok := params[p[i].Name]; ok </span><span class="cov8" title="1">{
                        p[i] = v
                        delete(params, v.Name)
                }</span>
        }

        <span class="cov8" title="1">for _, v := range params </span><span class="cov0" title="0">{
                p = append(p, v)
        }</span>
        <span class="cov8" title="1">sort.Slice(p, func(i, j int) bool </span><span class="cov8" title="1">{ return p[i].Name &lt; p[j].Name }</span>)
        <span class="cov8" title="1">return p, nil</span>
}

func parseParam(p []string) (map[string]v1beta1.Param, error) <span class="cov8" title="1">{
        params := map[string]v1beta1.Param{}
        for _, v := range p </span><span class="cov8" title="1">{
                r := strings.SplitN(v, "=", 2)
                if len(r) != 2 </span><span class="cov8" title="1">{
                        return nil, errors.New(invalidParam + v)
                }</span>

                <span class="cov8" title="1">if _, ok := paramByType[r[0]]; !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("param '%s' not present in spec", r[0])
                }</span>

                <span class="cov8" title="1">param := v1beta1.Param{
                        Name: r[0],
                        Value: v1beta1.ParamValue{
                                Type: paramByType[r[0]],
                        },
                }

                if paramByType[r[0]] == "string" </span><span class="cov8" title="1">{
                        param.Value.StringVal = r[1]
                }</span>

                <span class="cov8" title="1">if paramByType[r[0]] == "array" </span><span class="cov8" title="1">{
                        if len(r[1]) == 0 </span><span class="cov8" title="1">{
                                param.Value.ArrayVal = make([]string, 0)
                        }</span> else<span class="cov8" title="1"> {
                                param.Value.ArrayVal = strings.Split(r[1], ",")
                        }</span>
                }

                <span class="cov8" title="1">if paramByType[r[0]] == "object" </span><span class="cov8" title="1">{
                        fields := strings.Split(r[1], ",")
                        object := map[string]string{}
                        for _, field := range fields </span><span class="cov8" title="1">{
                                r := strings.SplitN(field, ":", 2)
                                if len(r) != 2 </span><span class="cov0" title="0">{
                                        return nil, errors.New(invalidParam + v)
                                }</span>
                                <span class="cov8" title="1">object[strings.TrimSpace(r[0])] = strings.TrimSpace(r[1])</span>
                        }
                        <span class="cov8" title="1">param.Value.ObjectVal = object</span>
                }
                <span class="cov8" title="1">params[r[0]] = param</span>
        }
        <span class="cov8" title="1">return params, nil</span>
}

func FilterParamsByType(params []v1beta1.ParamSpec) <span class="cov8" title="1">{
        for _, p := range params </span><span class="cov8" title="1">{
                if p.Type == "string" </span><span class="cov8" title="1">{
                        paramByType[p.Name] = v1beta1.ParamTypeString
                        continue</span>
                }
                <span class="cov8" title="1">if p.Type == "array" </span><span class="cov8" title="1">{
                        paramByType[p.Name] = v1beta1.ParamTypeArray
                        continue</span>
                }
                <span class="cov8" title="1">paramByType[p.Name] = v1beta1.ParamTypeObject</span>
        }
}

// ParseParams parse the params and return as map
func ParseParams(params []string) (map[string]string, error) <span class="cov8" title="1">{
        parsedParams := make(map[string]string)
        for _, p := range params </span><span class="cov8" title="1">{
                r := strings.SplitN(p, "=", 2)
                if len(r) != 2 </span><span class="cov8" title="1">{
                        return nil, errors.New(invalidParam + p)
                }</span>
                <span class="cov8" title="1">key := strings.TrimSpace(r[0])
                val := strings.TrimSpace(r[1])
                if key == "" </span><span class="cov8" title="1">{
                        return nil, errors.New(invalidParam + p)
                }</span>
                <span class="cov8" title="1">parsedParams[key] = val</span>
        }
        <span class="cov8" title="1">return parsedParams, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package params

import (
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "k8s.io/apimachinery/pkg/util/sets"
)

var allowedParamTypes = sets.NewString("string", "array", "object")

func ValidateParamType(params []v1beta1.ParamSpec) error <span class="cov0" title="0">{
        paramsWithInvalidType := make([]v1beta1.ParamSpec, 0)
        for _, param := range params </span><span class="cov0" title="0">{
                if !allowedParamTypes.Has(string(param.Type)) </span><span class="cov0" title="0">{
                        paramsWithInvalidType = append(paramsWithInvalidType, param)
                }</span>
        }

        <span class="cov0" title="0">if len(paramsWithInvalidType) &gt; 0 </span><span class="cov0" title="0">{
                errString := "params does not have a valid type -"
                for _, param := range paramsWithInvalidType </span><span class="cov0" title="0">{
                        errString += fmt.Sprintf(" '%s'", param.Name)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("%s", errString)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipeline

import (
        "context"
        "fmt"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var pipelineGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "pipelines"}
var pipelineRunGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "pipelineruns"}

func GetAllPipelineNames(gr schema.GroupVersionResource, c *cli.Clients, ns string) ([]string, error) <span class="cov8" title="1">{
        var pipelines *v1.PipelineList
        if err := actions.ListV1(gr, c, metav1.ListOptions{}, ns, &amp;pipelines); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list Tasks from namespace %s: %v", ns, err)
        }</span>

        <span class="cov8" title="1">ret := []string{}
        for _, item := range pipelines.Items </span><span class="cov8" title="1">{
                ret = append(ret, item.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func GetPipeline(gr schema.GroupVersionResource, c *cli.Clients, pName, ns string) (*v1.Pipeline, error) <span class="cov0" title="0">{
        var pipeline v1.Pipeline
        gvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if gvr.Version == "v1" </span><span class="cov0" title="0">{
                err := actions.GetV1(gr, c, pName, ns, metav1.GetOptions{}, &amp;pipeline)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;pipeline, nil</span>

        }

        <span class="cov0" title="0">var pipelineV1beta1 v1beta1.Pipeline
        err = actions.GetV1(gr, c, pName, ns, metav1.GetOptions{}, &amp;pipelineV1beta1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = pipelineV1beta1.ConvertTo(context.Background(), &amp;pipeline)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pipeline, nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipeline

import (
        "fmt"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// LastRun returns the name of last pipelinerun for a given pipeline
func LastRunName(cs *cli.Clients, resourceName, ns string) (string, error) <span class="cov8" title="1">{
        latest, err := LastRun(cs, resourceName, ns)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return latest.Name, nil</span>
}

// DynamicLastRun returns the last run for a given pipeline
func LastRun(cs *cli.Clients, pipeline string, ns string) (*v1.PipelineRun, error) <span class="cov8" title="1">{
        options := metav1.ListOptions{}
        if pipeline != "" </span><span class="cov8" title="1">{
                options = metav1.ListOptions{
                        LabelSelector: fmt.Sprintf("tekton.dev/pipeline=%s", pipeline),
                }
        }</span>

        <span class="cov8" title="1">var runs *v1.PipelineRunList
        err := actions.ListV1(pipelineRunGroupResource, cs, options, ns, &amp;runs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(runs.Items) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no pipelineruns related to pipeline %s found in namespace %s", pipeline, ns)
        }</span>

        <span class="cov8" title="1">latest := runs.Items[0]
        for _, run := range runs.Items </span><span class="cov8" title="1">{
                if run.CreationTimestamp.Time.After(latest.CreationTimestamp.Time) </span><span class="cov8" title="1">{
                        latest = run
                }</span>
        }

        <span class="cov8" title="1">return &amp;latest, nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipelinerun

import (
        "context"
        "fmt"
        "io"
        "sort"
        "strings"
        "text/tabwriter"
        "text/template"

        "github.com/jonboulle/clockwork"
        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/formatted"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const describeTemplate = `{{decorate "bold" "Name"}}:        {{ .PipelineRun.Name }}
{{decorate "bold" "Namespace"}}:        {{ .PipelineRun.Namespace }}
{{- $pRefName := pipelineRefExists .PipelineRun.Spec }}{{- if ne $pRefName "" }}
{{decorate "bold" "Pipeline Ref"}}:        {{ $pRefName }}
{{- end }}
{{- if ne .PipelineRun.Spec.TaskRunTemplate.ServiceAccountName "" }}
{{decorate "bold" "Service Account"}}:        {{ .PipelineRun.Spec.TaskRunTemplate.ServiceAccountName }}
{{- end }}

{{- $l := len .PipelineRun.Labels }}{{ if eq $l 0 }}
{{- else }}
{{decorate "bold" "Labels"}}:
{{- range $k, $v := .PipelineRun.Labels }}
 {{ $k }}={{ $v }}
{{- end }}
{{- end }}
{{- $annotations := removeLastAppliedConfig .PipelineRun.Annotations -}}
{{- if $annotations }}
{{decorate "bold" "Annotations"}}:
{{- range $k, $v := $annotations }}
 {{ $k }}={{ $v }}
{{- end }}
{{- end }}

{{decorate "status" ""}}{{decorate "underline bold" "Status\n"}}
STARTED        DURATION        STATUS
{{ formatAge .PipelineRun.Status.StartTime  .Time }}        {{ formatDuration .PipelineRun.Status.StartTime .PipelineRun.Status.CompletionTime }}        {{ formatCondition .PipelineRun.Status.Conditions }}
{{- $msg := hasFailed .PipelineRun .TaskrunList -}}
{{-  if ne $msg "" }}

{{decorate "message" ""}}{{decorate "underline bold" "Message\n"}}
{{ $msg }}
{{- end }}


{{- if .PipelineRun.Spec.Timeouts }}

{{decorate "timeouts" ""}}{{decorate "underline bold" "Timeouts"}}
{{- $timeout := .PipelineRun.Spec.Timeouts.Pipeline -}}
{{- if $timeout }}
 {{decorate "bold" "Pipeline"}}:        {{ $timeout.Duration.String }}
{{- end }}
{{- $timeout := .PipelineRun.Spec.Timeouts.Tasks -}}
{{- if $timeout }}
 {{decorate "bold" "Tasks"}}:        {{ $timeout.Duration.String }}
{{- end }}
{{- $timeout := .PipelineRun.Spec.Timeouts.Finally -}}
{{- if $timeout }}
 {{decorate "bold" "Finally"}}:        {{ $timeout.Duration.String }}
{{- end }}
{{- end }}

{{- if ne (len .PipelineRun.Spec.Params) 0 }}

{{decorate "params" ""}}{{decorate "underline bold" "Params\n"}}
 NAME        VALUE
{{- range $i, $p := .PipelineRun.Spec.Params }}
{{- if eq $p.Value.Type "string" }}
 {{decorate "bullet" $p.Name }}        {{ $p.Value.StringVal }}
{{- else if eq $p.Value.Type "array" }}
 {{decorate "bullet" $p.Name }}        {{ $p.Value.ArrayVal }}
{{- else }}
 {{decorate "bullet" $p.Name }}        {{ $p.Value.ObjectVal }}
{{- end }}
{{- end }}
{{- end }}

{{- if ne (len .PipelineRun.Status.Results) 0 }}

{{decorate "results" ""}}{{decorate "underline bold" "Results\n"}}
 NAME        VALUE
{{- range $result := .PipelineRun.Status.Results }}
{{- if eq $result.Value.Type "string" }}
 {{decorate "bullet" $result.Name }}        {{ $result.Value.StringVal }}
{{- else }}
 {{decorate "bullet" $result.Name }}        {{ $result.Value.ArrayVal }}
{{- end }}
{{- end }}
{{- end }}

{{- if ne (len .PipelineRun.Spec.Workspaces) 0 }}

{{decorate "workspaces" ""}}{{decorate "underline bold" "Workspaces\n"}}
 NAME        SUB PATH        WORKSPACE BINDING
{{- range $workspace := .PipelineRun.Spec.Workspaces }}
{{- if not $workspace.SubPath }}
 {{ decorate "bullet" $workspace.Name }}        {{ "---" }}        {{ formatWorkspace $workspace }}
{{- else }}
 {{ decorate "bullet" $workspace.Name }}        {{ $workspace.SubPath }}        {{ formatWorkspace $workspace }}
{{- end }}
{{- end }}
{{- end }}

{{- if ne (len .TaskrunList) 0 }}

{{decorate "taskruns" ""}}{{decorate "underline bold" "Taskruns\n"}}
 NAME        TASK NAME        STARTED        DURATION        STATUS
{{- range $taskrun := .TaskrunList }}{{ if checkTRStatus $taskrun }}
 {{decorate "bullet" $taskrun.TaskRunName }}        {{ $taskrun.PipelineTaskName }}        {{ formatAge $taskrun.Status.StartTime $.Time }}        {{ formatDuration $taskrun.Status.StartTime $taskrun.Status.CompletionTime }}        {{ formatCondition $taskrun.Status.Conditions }}
{{- end }}
{{- end }}
{{- end }}

{{- if ne (len .PipelineRun.Status.SkippedTasks) 0 }}

{{decorate "skippedtasks" ""}}{{decorate "underline bold" "Skipped Tasks\n"}}
 NAME
{{- range $skippedTask := .PipelineRun.Status.SkippedTasks }}
 {{decorate "bullet" $skippedTask.Name }}
{{- end }}
{{- end }}
`

type TaskRunWithStatus struct {
        TaskRunName      string
        PipelineTaskName string
        Status           *v1.TaskRunStatus
}

type TaskRunWithStatusList []TaskRunWithStatus

func (trs TaskRunWithStatusList) Len() int      <span class="cov0" title="0">{ return len(trs) }</span>
func (trs TaskRunWithStatusList) Swap(i, j int) <span class="cov0" title="0">{ trs[i], trs[j] = trs[j], trs[i] }</span>
func (trs TaskRunWithStatusList) Less(i, j int) bool <span class="cov0" title="0">{
        if trs[j].Status == nil || trs[j].Status.StartTime == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if trs[i].Status == nil || trs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return trs[j].Status.StartTime.Before(trs[i].Status.StartTime)</span>
}

func PrintPipelineRunDescription(out io.Writer, c *cli.Clients, ns string, prName string, time clockwork.Clock) error <span class="cov0" title="0">{
        pr, err := GetPipelineRun(pipelineRunGroupResource, c, prName, ns)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find pipelinerun %q", prName)
        }</span>

        <span class="cov0" title="0">var taskRunList TaskRunWithStatusList
        for _, child := range pr.Status.ChildReferences </span><span class="cov0" title="0">{
                if child.Kind == "TaskRun" </span><span class="cov0" title="0">{
                        var tr *v1.TaskRun
                        err = actions.GetV1(taskrunGroupResource, c, child.Name, ns, metav1.GetOptions{}, &amp;tr)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to find get taskruns of the pipelineruns")
                        }</span>
                        <span class="cov0" title="0">taskRunList = append(taskRunList, TaskRunWithStatus{
                                tr.Name,
                                child.PipelineTaskName,
                                &amp;tr.Status,
                        })</span>
                }
        }

        <span class="cov0" title="0">if len(taskRunList) != 0 </span><span class="cov0" title="0">{
                sort.Sort(taskRunList)
        }</span>

        <span class="cov0" title="0">var data = struct {
                PipelineRun *v1.PipelineRun
                Time        clockwork.Clock
                TaskrunList TaskRunWithStatusList
        }{
                PipelineRun: pr,
                Time:        time,
                TaskrunList: taskRunList,
        }

        funcMap := template.FuncMap{
                "formatAge":               formatted.Age,
                "formatDuration":          formatted.Duration,
                "formatCondition":         formatted.Condition,
                "formatWorkspace":         formatted.Workspace,
                "hasFailed":               hasFailed,
                "pipelineRefExists":       formatted.PipelineRefExists,
                "decorate":                formatted.DecorateAttr,
                "checkTRStatus":           checkTaskRunStatus,
                "removeLastAppliedConfig": formatted.RemoveLastAppliedConfig,
        }

        w := tabwriter.NewWriter(out, 0, 5, 3, ' ', tabwriter.TabIndent)
        t := template.Must(template.New("Describe Pipelinerun").Funcs(funcMap).Parse(describeTemplate))

        if err = t.Execute(w, data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return w.Flush()</span>
}

func GetPipelineRun(gr schema.GroupVersionResource, c *cli.Clients, prName, ns string) (*v1.PipelineRun, error) <span class="cov0" title="0">{
        var pipelinerun v1.PipelineRun
        gvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if gvr.Version == "v1" </span><span class="cov0" title="0">{
                err := actions.GetV1(pipelineRunGroupResource, c, prName, ns, metav1.GetOptions{}, &amp;pipelinerun)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;pipelinerun, nil</span>
        }

        <span class="cov0" title="0">var pipelinerunV1beta1 v1beta1.PipelineRun
        err = actions.GetV1(pipelineRunGroupResource, c, prName, ns, metav1.GetOptions{}, &amp;pipelinerunV1beta1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = pipelinerunV1beta1.ConvertTo(context.Background(), &amp;pipelinerun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pipelinerun, nil</span>
}

func hasFailed(pr *v1.PipelineRun, taskruns TaskRunWithStatusList) string <span class="cov8" title="1">{
        if len(pr.Status.Conditions) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if pr.Status.Conditions[0].Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                var trNames []string
                for _, taskrun := range taskruns </span><span class="cov8" title="1">{
                        if taskrun.Status == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if len(taskrun.Status.Conditions) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if taskrun.Status.Conditions[0].Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                                trNames = append(trNames, taskrun.TaskRunName)
                        }</span>
                }
                <span class="cov8" title="1">message := pr.Status.Conditions[0].Message
                if len(trNames) != 0 </span><span class="cov8" title="1">{
                        sort.Strings(trNames)
                        message += fmt.Sprintf("\nTaskRun(s) cancelled: %s", strings.Join(trNames, ", "))
                }</span>
                <span class="cov8" title="1">return message</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func checkTaskRunStatus(taskRun TaskRunWithStatus) bool <span class="cov0" title="0">{
        return taskRun.Status != nil
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipelinerun

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/jonboulle/clockwork"
        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/formatted"
        prsort "github.com/tektoncd/cli/pkg/pipelinerun/sort"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var pipelineRunGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "pipelineruns"}
var taskrunGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "taskruns"}

// GetAllPipelineRuns returns all pipelinesruns running in a namespace
func GetAllPipelineRuns(gr schema.GroupVersionResource, opts metav1.ListOptions, c *cli.Clients, ns string, limit int, time clockwork.Clock) ([]string, error) <span class="cov8" title="1">{
        var pipelineruns *v1.PipelineRunList
        if err := actions.ListV1(gr, c, opts, ns, &amp;pipelineruns); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list PipelineRuns from namespace %s: %v", ns, err)
        }</span>

        <span class="cov8" title="1">runslen := len(pipelineruns.Items)
        if limit &gt; runslen </span><span class="cov8" title="1">{
                limit = runslen
        }</span>

        <span class="cov8" title="1">if runslen &gt; 1 </span><span class="cov8" title="1">{
                prsort.SortByStartTime(pipelineruns.Items)
        }</span>
        <span class="cov8" title="1">ret := []string{}
        for i, run := range pipelineruns.Items </span><span class="cov8" title="1">{
                if i &lt; limit </span><span class="cov8" title="1">{
                        ret = append(ret, run.ObjectMeta.Name+" started "+formatted.Age(run.Status.StartTime, time))
                }</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}

type patchStringValue struct {
        Op    string `json:"op"`
        Path  string `json:"path"`
        Value string `json:"value"`
}

func Cancel(c *cli.Clients, prname string, opts metav1.PatchOptions, cancelStatus, ns string) (*v1.PipelineRun, error) <span class="cov0" title="0">{
        payload := []patchStringValue{{
                Op:    "replace",
                Path:  "/spec/status",
                Value: cancelStatus,
        }}

        data, _ := json.Marshal(payload)
        prGroupResource := schema.GroupVersionResource{Group: "tekton.dev", Resource: "pipelineruns"}
        var pipelinerun *v1.PipelineRun
        err := actions.Patch(prGroupResource, c, prname, data, opts, ns, &amp;pipelinerun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return pipelinerun, nil</span>
}

// It will create the resource based on the api available.
func Create(c *cli.Clients, pr *v1beta1.PipelineRun, opts metav1.CreateOptions, ns string) (*v1beta1.PipelineRun, error) <span class="cov8" title="1">{
        gvr, err := actions.GetGroupVersionResource(pipelineRunGroupResource, c.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if gvr.Version == "v1" </span><span class="cov0" title="0">{
                prv1 := v1.PipelineRun{}
                err = pr.ConvertTo(context.Background(), &amp;prv1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">prv1.Kind = "PipelineRun"
                prv1.APIVersion = "tekton.dev/v1"

                object, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(&amp;prv1)
                unstructuredPR := &amp;unstructured.Unstructured{
                        Object: object,
                }
                newUnstructuredPR, err := actions.Create(pipelineRunGroupResource, c, unstructuredPR, ns, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var pipelinerun v1.PipelineRun
                if err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredPR.UnstructuredContent(), &amp;pipelinerun); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">pipelinerunv1beta1 := v1beta1.PipelineRun{}
                err = pipelinerunv1beta1.ConvertFrom(context.Background(), &amp;pipelinerun)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">pipelinerunv1beta1.Kind = "PipelineRun"
                pipelinerunv1beta1.APIVersion = "tekton.dev/v1beta1"
                return &amp;pipelinerunv1beta1, nil</span>
        }

        <span class="cov8" title="1">object, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(pr)
        unstructuredPR := &amp;unstructured.Unstructured{
                Object: object,
        }

        newUnstructuredPR, err := actions.Create(pipelineRunGroupResource, c, unstructuredPR, ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var pipelinerun *v1beta1.PipelineRun
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredPR.UnstructuredContent(), &amp;pipelinerun); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return pipelinerun, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipelinerun

import (
        "sort"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func SortByNamespace(prs []v1.PipelineRun) <span class="cov8" title="1">{
        sort.Sort(byNamespace(prs))
}</span>

type byNamespace []v1.PipelineRun

func (prs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) <span class="cov8" title="1">{
        lt, eq = ins &lt; jns, ins == jns
        return lt, eq
}</span>

func (prs byNamespace) Len() int      <span class="cov8" title="1">{ return len(prs) }</span>
func (prs byNamespace) Swap(i, j int) <span class="cov8" title="1">{ prs[i], prs[j] = prs[j], prs[i] }</span>
func (prs byNamespace) Less(i, j int) bool <span class="cov8" title="1">{
        var lt, eq bool
        if lt, eq = prs.compareNamespace(prs[i].Namespace, prs[j].Namespace); eq </span><span class="cov8" title="1">{
                if prs[j].Status.StartTime == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if prs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return prs[j].Status.StartTime.Before(prs[i].Status.StartTime)</span>
        }
        <span class="cov8" title="1">return lt</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipelinerun

import (
        "sort"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func SortByStartTime(prs []v1.PipelineRun) <span class="cov8" title="1">{
        sort.Sort(byStartTime(prs))
}</span>

type byStartTime []v1.PipelineRun

func (prs byStartTime) Len() int      <span class="cov8" title="1">{ return len(prs) }</span>
func (prs byStartTime) Swap(i, j int) <span class="cov8" title="1">{ prs[i], prs[j] = prs[j], prs[i] }</span>
func (prs byStartTime) Less(i, j int) bool <span class="cov8" title="1">{
        if prs[j].Status.StartTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if prs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return prs[j].Status.StartTime.Before(prs[i].Status.StartTime)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipelinerun

import (
        "context"
        "sync"
        "time"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        taskrunpkg "github.com/tektoncd/cli/pkg/taskrun"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        informers "github.com/tektoncd/pipeline/pkg/client/informers/externalversions"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/tools/cache"
)

// Tracker tracks the progress of a PipelineRun
type Tracker struct {
        Name         string
        Ns           string
        Client       *cli.Clients
        ongoingTasks map[string]bool
}

// NewTracker returns a new instance of Tracker
func NewTracker(name string, ns string, client *cli.Clients) *Tracker <span class="cov8" title="1">{
        return &amp;Tracker{
                Name:         name,
                Ns:           ns,
                Client:       client,
                ongoingTasks: map[string]bool{},
        }
}</span>

// Monitor to observe the progress of PipelineRun. It emits
// an event upon starting of a new Pipeline's Task.
// allowed containers the name of the Pipeline tasks, which used as filter
// limit the events to only those tasks
func (t *Tracker) Monitor(allowed []string) &lt;-chan []taskrunpkg.Run <span class="cov8" title="1">{

        factory := informers.NewSharedInformerFactoryWithOptions(
                t.Client.Tekton,
                time.Second*10,
                informers.WithNamespace(t.Ns),
                informers.WithTweakListOptions(pipelinerunOpts(t.Name)))

        gvr, _ := actions.GetGroupVersionResource(
                pipelineRunGroupResource,
                t.Client.Tekton.Discovery(),
        )

        genericInformer, _ := factory.ForResource(*gvr)
        informer := genericInformer.Informer()
        mu := &amp;sync.Mutex{}
        stopC := make(chan struct{})
        trC := make(chan []taskrunpkg.Run)
        go func() </span><span class="cov8" title="1">{
                &lt;-stopC
                close(trC)
        }</span>()

        <span class="cov8" title="1">eventHandler := func(obj interface{}) </span><span class="cov8" title="1">{
                var pipelinerunConverted v1.PipelineRun
                pr, ok := obj.(*v1.PipelineRun)
                if !ok || pr == nil </span><span class="cov0" title="0">{
                        prV1beta1, ok := obj.(*v1beta1.PipelineRun)
                        if !ok || prV1beta1 == nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">var prv1 v1.PipelineRun
                        err := prV1beta1.ConvertTo(context.Background(), &amp;prv1)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov0" title="0">pr = &amp;prv1</span>
                }

                <span class="cov8" title="1">trsMap, err := GetTaskRunsWithStatus(pr, t.Client, t.Ns)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">pr.DeepCopyInto(&amp;pipelinerunConverted)
                trC &lt;- t.findNewTaskruns(&amp;pipelinerunConverted, allowed, trsMap)

                if hasCompleted(&amp;pipelinerunConverted) </span><span class="cov8" title="1">{
                        close(stopC) // should close trC
                }</span>
        }

        <span class="cov8" title="1">_, err := informer.AddEventHandler(
                cache.ResourceEventHandlerFuncs{
                        AddFunc: func(obj interface{}) </span><span class="cov8" title="1">{
                                // To ensure synchonization and checks is the stopC channel has received a signal to stop
                                // If it receives a signal then return and does nothing
                                mu.Lock()
                                defer mu.Unlock()
                                select </span>{
                                case &lt;-stopC:<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        eventHandler(obj)</span>
                                }
                        },
                        UpdateFunc: func(_, newObj interface{}) <span class="cov8" title="1">{
                                mu.Lock()
                                defer mu.Unlock()
                                select </span>{
                                case &lt;-stopC:<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        eventHandler(newObj)</span>
                                }
                        },
                        DeleteFunc: func(obj interface{}) <span class="cov0" title="0">{
                                mu.Lock()
                                defer mu.Unlock()
                                select </span>{
                                case &lt;-stopC:<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov0" title="0">
                                        eventHandler(obj)</span>
                                }
                        },
                },
        )
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">factory.Start(stopC)
        factory.WaitForCacheSync(stopC)

        return trC</span>
}

func pipelinerunOpts(name string) func(opts *metav1.ListOptions) <span class="cov8" title="1">{
        return func(opts *metav1.ListOptions) </span><span class="cov8" title="1">{
                opts.FieldSelector = fields.OneTermEqualSelector("metadata.name", name).String()
        }</span>

}

// handles changes to pipelinerun and pushes the Run information to the
// channel if the task is new and is in the allowed list of tasks
// returns true if the pipelinerun has finished
func (t *Tracker) findNewTaskruns(pr *v1.PipelineRun, allowed []string, trStatuses map[string]*v1.PipelineRunTaskRunStatus) []taskrunpkg.Run <span class="cov8" title="1">{
        ret := []taskrunpkg.Run{}
        for tr, trs := range trStatuses </span><span class="cov8" title="1">{
                retries := 0
                if pr.Status.PipelineSpec != nil </span><span class="cov0" title="0">{
                        for _, pipelineTask := range pr.Status.PipelineSpec.Tasks </span><span class="cov0" title="0">{
                                if trs.PipelineTaskName == pipelineTask.Name </span><span class="cov0" title="0">{
                                        retries = pipelineTask.Retries
                                }</span>
                        }
                }
                <span class="cov8" title="1">run := taskrunpkg.Run{Name: tr, Task: trs.PipelineTaskName, Retries: retries}

                if t.loggingInProgress(tr) ||
                        !taskrunpkg.HasScheduled(trs) ||
                        taskrunpkg.IsFiltered(run, allowed) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">t.ongoingTasks[tr] = true
                ret = append(ret, run)</span>
        }

        <span class="cov8" title="1">return ret</span>
}

func hasCompleted(pr *v1.PipelineRun) bool <span class="cov8" title="1">{
        if len(pr.Status.Conditions) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return pr.Status.Conditions[0].Status != corev1.ConditionUnknown</span>
}

func (t *Tracker) loggingInProgress(tr string) bool <span class="cov8" title="1">{
        _, ok := t.ongoingTasks[tr]
        return ok
}</span>

func GetTaskRunsWithStatus(pr *v1.PipelineRun, c *cli.Clients, ns string) (map[string]*v1.PipelineRunTaskRunStatus, error) <span class="cov8" title="1">{
        // If the PipelineRun is nil, just return
        if pr == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // If there are no child references return the existing TaskRuns and Runs maps
        <span class="cov8" title="1">if len(pr.Status.ChildReferences) == 0 </span><span class="cov0" title="0">{
                return map[string]*v1.PipelineRunTaskRunStatus{}, nil
        }</span>

        <span class="cov8" title="1">trStatuses := make(map[string]*v1.PipelineRunTaskRunStatus)
        for _, cr := range pr.Status.ChildReferences </span><span class="cov8" title="1">{
                //TODO: Needs to handle Run, CustomRun later
                if cr.Kind == "TaskRun" </span><span class="cov8" title="1">{
                        tr, err := taskrunpkg.GetTaskRun(taskrunGroupResource, c, cr.Name, ns)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">trStatuses[cr.Name] = &amp;v1.PipelineRunTaskRunStatus{
                                PipelineTaskName: cr.PipelineTaskName,
                                Status:           &amp;tr.Status,
                        }</span>

                }
        }

        <span class="cov8" title="1">return trStatuses, nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package plugins

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/mitchellh/go-homedir"
)

const (
        pluginDirEnv = "TKN_PLUGINS_DIR"
        pluginDir    = "~/.config/tkn/plugins"
        tknPrefix    = "tkn-"
)

func getPluginDir() (string, error) <span class="cov8" title="1">{
        dir := os.Getenv(pluginDirEnv)
        // if TKN_PLUGINS_DIR is set, follow it
        if dir != "" </span><span class="cov8" title="1">{
                return dir, nil
        }</span>
        // Respect XDG_CONFIG_HOME if set
        <span class="cov8" title="1">if xdgHome := os.Getenv("XDG_CONFIG_HOME"); xdgHome != "" </span><span class="cov8" title="1">{
                return filepath.Join(xdgHome, "tkn", "plugins"), nil
        }</span>
        // Fallback to default pluginDir (~/.config/tkn/plugins)
        <span class="cov0" title="0">return homedir.Expand(pluginDir)</span>
}

// Find a binary in plugin homedir directory or user paths.
func FindPlugin(pluginame string) (string, error) <span class="cov8" title="1">{
        cmd := tknPrefix + pluginame
        dir, _ := getPluginDir()
        path := filepath.Join(dir, cmd)
        _, err := os.Stat(path)
        if err == nil </span><span class="cov8" title="1">{
                // Found in dir
                return path, nil
        }</span>

        <span class="cov8" title="1">path, err = exec.LookPath(cmd)
        if err == nil </span><span class="cov8" title="1">{
                return path, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("cannot find plugin in path or %s: %s", pluginDir, cmd)</span>
}

func GetAllTknPluginFromPaths() []string <span class="cov8" title="1">{
        pluginlist := []string{}
        paths := filepath.SplitList(os.Getenv("PATH"))
        if dir, err := getPluginDir(); err == nil </span><span class="cov8" title="1">{
                paths = append(paths, dir)
        }</span>
        // go over all paths in the PATH environment
        // and add them to the completion command
        <span class="cov8" title="1">for _, path := range paths </span><span class="cov8" title="1">{
                // list all files in path
                files, err := os.ReadDir(path)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                // add all files that start with tkn-
                <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                        if strings.HasPrefix(file.Name(), tknPrefix) </span><span class="cov8" title="1">{
                                basep := strings.TrimLeft(file.Name(), tknPrefix)
                                if contains(pluginlist, basep) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">fpath := filepath.Join(path, file.Name())
                                info, err := os.Stat(fpath)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if info.Mode()&amp;0o111 != 0 </span><span class="cov8" title="1">{
                                        pluginlist = append(pluginlist, basep)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return pluginlist</span>
}

func contains(s []string, e string) bool <span class="cov8" title="1">{
        for _, a := range s </span><span class="cov0" title="0">{
                if a == e </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pods

import (
        "bufio"
        "fmt"
        "io"

        "github.com/tektoncd/cli/pkg/pods/stream"
        corev1 "k8s.io/api/core/v1"
)

type Container struct {
        name        string
        NewStreamer stream.NewStreamerFunc
        pod         *Pod
}

func (c *Container) Status() error <span class="cov0" title="0">{
        pod, err := c.pod.Get()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">container := c.name
        for _, cs := range pod.Status.ContainerStatuses </span><span class="cov0" title="0">{
                if cs.Name != container </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if cs.State.Terminated != nil &amp;&amp; cs.State.Terminated.ExitCode == 1 </span><span class="cov0" title="0">{
                        msg := ""

                        if cs.State.Terminated.Reason != "" &amp;&amp; cs.State.Terminated.Reason != "Error" </span><span class="cov0" title="0">{
                                msg = msg + " : " + cs.State.Terminated.Reason
                        }</span>

                        <span class="cov0" title="0">if cs.State.Terminated.Message != "" &amp;&amp; cs.State.Terminated.Message != "Error" </span><span class="cov0" title="0">{
                                msg = msg + " : " + cs.State.Terminated.Message
                        }</span>

                        <span class="cov0" title="0">return fmt.Errorf("container %s has failed %s", container, msg)</span>
                }
        }

        <span class="cov0" title="0">for _, cs := range pod.Status.InitContainerStatuses </span><span class="cov0" title="0">{
                if cs.Name != container </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if cs.State.Terminated != nil &amp;&amp; cs.State.Terminated.ExitCode == 1 </span><span class="cov0" title="0">{
                        return fmt.Errorf("container %s has failed: %s", container, cs.State.Terminated.Reason)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Log represents one log message from a pod
type Log struct {
        PodName       string
        ContainerName string
        Log           string
}
type LogReader struct {
        containerName string
        pod           *Pod
        follow        bool
        timestamps    bool
}

func (c *Container) LogReader(follow, timestamps bool) *LogReader <span class="cov8" title="1">{
        return &amp;LogReader{c.name, c.pod, follow, timestamps}
}</span>

func (lr *LogReader) Read() (&lt;-chan Log, &lt;-chan error, error) <span class="cov8" title="1">{
        pod := lr.pod
        opts := &amp;corev1.PodLogOptions{
                Follow:     lr.follow,
                Container:  lr.containerName,
                Timestamps: lr.timestamps,
        }

        stream, err := pod.Stream(opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error getting logs for pod %s(%s) : %s", pod.Name, lr.containerName, err)
        }</span>

        <span class="cov8" title="1">logC := make(chan Log)
        errC := make(chan error)

        go func() </span><span class="cov8" title="1">{
                defer close(logC)
                defer close(errC)
                defer stream.Close()

                r := bufio.NewReader(stream)
                for </span><span class="cov8" title="1">{
                        line, _, err := r.ReadLine()

                        if err != nil </span><span class="cov8" title="1">{
                                if err != io.EOF </span><span class="cov0" title="0">{
                                        errC &lt;- err
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }

                        <span class="cov8" title="1">logC &lt;- Log{
                                PodName:       pod.Name,
                                ContainerName: lr.containerName,
                                Log:           string(line),
                        }</span>
                }
        }()

        <span class="cov8" title="1">return logC, errC, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fake

type Log struct {
        PodName    string
        Containers []Container
}

func Logs(logs ...Log) []Log <span class="cov0" title="0">{
        ret := []Log{}
        ret = append(ret, logs...)
        return ret
}</span>

func Task(name string, containers ...Container) Log <span class="cov0" title="0">{
        return Log{
                PodName:    name,
                Containers: containers,
        }
}</span>

func Step(name string, logs ...string) Container <span class="cov0" title="0">{
        return Container{
                Name: name,
                Logs: logs,
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fake

func PodLog(name string, containers ...Container) Log <span class="cov0" title="0">{
        return Log{
                PodName:    name,
                Containers: containers,
        }
}</span>

type Container struct {
        Name string
        Logs []string
}

func NewContainer(name string, logs ...string) Container <span class="cov0" title="0">{
        return Container{
                Name: name,
                Logs: logs,
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fake

import (
        "fmt"
        "io"
        "strings"

        "github.com/tektoncd/cli/pkg/pods/stream"
        corev1 "k8s.io/api/core/v1"
        typedv1 "k8s.io/client-go/kubernetes/typed/core/v1"
)

type PodStream struct {
        logs []Log
        pods typedv1.PodInterface
        name string
        opts *corev1.PodLogOptions
}

func (ps *PodStream) Stream() (io.ReadCloser, error) <span class="cov0" title="0">{
        for _, fl := range ps.logs </span><span class="cov0" title="0">{
                if fl.PodName != ps.name </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">for _, c := range fl.Containers </span><span class="cov0" title="0">{
                        if c.Name == ps.opts.Container </span><span class="cov0" title="0">{
                                log := strings.Join(c.Logs, "\n")
                                return io.NopCloser(strings.NewReader(log)), nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("failed to stream container logs")</span>
}

func Streamer(l []Log) stream.NewStreamerFunc <span class="cov0" title="0">{
        return func(pods typedv1.PodInterface, name string, opts *corev1.PodLogOptions) stream.Streamer </span><span class="cov0" title="0">{
                return &amp;PodStream{
                        logs: l,
                        pods: pods,
                        name: name,
                        opts: opts,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pods

import (
        "context"
        "fmt"
        "io"
        "sync"
        "time"

        "github.com/tektoncd/cli/pkg/pods/stream"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/fields"
        "k8s.io/client-go/informers"
        k8s "k8s.io/client-go/kubernetes"
        typedv1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/tools/cache"
)

type Stream struct {
        name string
        pods typedv1.PodInterface
        opts *corev1.PodLogOptions
}

func NewStream(pods typedv1.PodInterface, name string, opts *corev1.PodLogOptions) stream.Streamer <span class="cov0" title="0">{
        return &amp;Stream{name, pods, opts}
}</span>

// Stream Creates a stream object which allows reading the logs
func (s *Stream) Stream() (io.ReadCloser, error) <span class="cov0" title="0">{
        return s.pods.GetLogs(s.name, s.opts).Stream(context.Background())
}</span>

type Pod struct {
        Name     string
        Ns       string
        Kc       k8s.Interface
        Streamer stream.NewStreamerFunc
}

func New(name, ns string, client k8s.Interface, streamer stream.NewStreamerFunc) *Pod <span class="cov8" title="1">{
        return &amp;Pod{
                Name: name, Ns: ns,
                Kc:       client,
                Streamer: streamer,
        }
}</span>

func NewWithDefaults(name, ns string, client k8s.Interface) *Pod <span class="cov8" title="1">{
        return &amp;Pod{
                Name: name, Ns: ns,
                Kc:       client,
                Streamer: NewStream,
        }
}</span>

// podResult holds the result of pod status check
type podResult struct {
        pod *corev1.Pod
        err error
}

// Wait wait for the pod to get up and running
func (p *Pod) Wait() (*corev1.Pod, error) <span class="cov8" title="1">{
        // ensure pod exists before we actually check for it
        if _, err := p.Get(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stopC := make(chan struct{})
        mu := sync.Mutex{}

        var result podResult

        // Start watcher in a goroutine
        go func() </span><span class="cov8" title="1">{
                p.watcher(stopC, &amp;result, &amp;mu)
        }</span>()

        // Wait for stopC
        <span class="cov8" title="1">&lt;-stopC
        return result.pod, result.err</span>
}

func (p *Pod) watcher(stopC chan struct{}, result *podResult, mu *sync.Mutex) <span class="cov8" title="1">{
        factory := informers.NewSharedInformerFactoryWithOptions(
                p.Kc, time.Second*10,
                informers.WithNamespace(p.Ns),
                informers.WithTweakListOptions(podOpts(p.Name)))

        updatePodStatus := func(obj interface{}) </span><span class="cov8" title="1">{
                mu.Lock()
                defer mu.Unlock()

                pod, err := checkPodStatus(obj)
                if pod != nil || err != nil </span><span class="cov8" title="1">{
                        result.pod = pod
                        result.err = err
                        close(stopC)
                }</span>
        }

        <span class="cov8" title="1">_, err := factory.Core().V1().Pods().Informer().AddEventHandler(
                cache.ResourceEventHandlerFuncs{
                        AddFunc: func(obj interface{}) </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-stopC:<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        updatePodStatus(obj)</span>
                                }
                        },
                        UpdateFunc: func(_, newObj interface{}) <span class="cov8" title="1">{
                                select </span>{
                                case &lt;-stopC:<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        updatePodStatus(newObj)</span>
                                }
                        },
                        DeleteFunc: func(obj interface{}) <span class="cov8" title="1">{
                                select </span>{
                                case &lt;-stopC:<span class="cov0" title="0">
                                        return</span>
                                default:<span class="cov8" title="1">
                                        updatePodStatus(obj)</span>
                                }
                        },
                })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">factory.Start(stopC)
        factory.WaitForCacheSync(stopC)</span>
}

func podOpts(name string) func(opts *metav1.ListOptions) <span class="cov8" title="1">{
        return func(opts *metav1.ListOptions) </span><span class="cov8" title="1">{
                opts.FieldSelector = fields.OneTermEqualSelector("metadata.name", name).String()
        }</span>
}

func checkPodStatus(obj interface{}) (*corev1.Pod, error) <span class="cov8" title="1">{
        pod, ok := obj.(*corev1.Pod)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to cast to pod object")
        }</span>

        <span class="cov8" title="1">if pod.DeletionTimestamp != nil </span><span class="cov8" title="1">{
                return pod, fmt.Errorf("failed to run the pod %s ", pod.Name)
        }</span>

        <span class="cov8" title="1">if pod.Status.Phase == corev1.PodSucceeded ||
                pod.Status.Phase == corev1.PodRunning ||
                pod.Status.Phase == corev1.PodFailed </span><span class="cov8" title="1">{
                return pod, nil
        }</span>

        // Handle any issues with pulling images that may fail
        <span class="cov8" title="1">for _, c := range pod.Status.Conditions </span><span class="cov0" title="0">{
                if c.Type == corev1.PodInitialized || c.Type == corev1.ContainersReady </span><span class="cov0" title="0">{
                        if c.Status == corev1.ConditionUnknown </span><span class="cov0" title="0">{
                                return pod, fmt.Errorf("%s", c.Message)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil, nil</span>
}

// Get gets the pod
func (p *Pod) Get() (*corev1.Pod, error) <span class="cov8" title="1">{
        return p.Kc.CoreV1().Pods(p.Ns).Get(context.Background(), p.Name, metav1.GetOptions{})
}</span>

// Container returns the an instance of Container
func (p *Pod) Container(c string) *Container <span class="cov8" title="1">{
        return &amp;Container{
                name:        c,
                pod:         p,
                NewStreamer: p.Streamer,
        }
}</span>

// Stream returns the stream object for given container and mode
// in order to fetch the logs
func (p *Pod) Stream(opt *corev1.PodLogOptions) (io.ReadCloser, error) <span class="cov8" title="1">{
        pods := p.Kc.CoreV1().Pods(p.Ns)
        if pods == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error getting pods")
        }</span>

        <span class="cov8" title="1">return p.Streamer(pods, p.Name, opt).Stream()</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pods

import (
        "net/http"

        "github.com/tektoncd/cli/pkg/file"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/pod"
        "sigs.k8s.io/yaml"
)

func ParsePodTemplate(httpClient http.Client, podTemplateLocation string, validate file.TypeValidator, errorMsg error) (pod.PodTemplate, error) <span class="cov8" title="1">{
        podTemplate := pod.PodTemplate{}
        b, err := file.LoadFileContent(httpClient, podTemplateLocation, validate, errorMsg)
        if err != nil </span><span class="cov8" title="1">{
                return podTemplate, err
        }</span>

        <span class="cov8" title="1">if err := yaml.UnmarshalStrict(b, &amp;podTemplate); err != nil </span><span class="cov8" title="1">{
                return podTemplate, err
        }</span>

        <span class="cov8" title="1">return podTemplate, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package suggestion

import (
        "fmt"
        "strings"

        "github.com/spf13/cobra"
)

// SubcommandsRequiredWithSuggestions will ensure we have a subcommand provided by the user and augments it with
// suggestion for commands, alias and help on root command.
func SubcommandsRequiredWithSuggestions(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        requireMsg := "unknown command \"%s\" for \"%s\""
        typedName := ""
        // This will be triggered if cobra didn't find any subcommands.
        // Find some suggestions.
        var suggestions []string

        if len(args) != 0 &amp;&amp; !cmd.DisableSuggestions </span><span class="cov8" title="1">{
                typedName += args[0]
                if cmd.SuggestionsMinimumDistance &lt;= 0 </span><span class="cov8" title="1">{
                        cmd.SuggestionsMinimumDistance = 2
                }</span>
                // subcommand suggestions
                <span class="cov8" title="1">suggestions = cmd.SuggestionsFor(args[0])

                // subcommand alias suggestions (with distance, not exact)
                for _, c := range cmd.Commands() </span><span class="cov8" title="1">{
                        if c.IsAvailableCommand() </span><span class="cov8" title="1">{
                                candidate := suggestsByPrefixOrLd(typedName, c.Name(), cmd.SuggestionsMinimumDistance)
                                if candidate == "" </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">_, found := Find(suggestions, candidate)
                                if !found </span><span class="cov0" title="0">{
                                        suggestions = append(suggestions, candidate)
                                }</span>
                        }
                }

                // help for root command
                <span class="cov8" title="1">if !cmd.HasParent() </span><span class="cov8" title="1">{
                        candidate := suggestsByPrefixOrLd(typedName, "help", cmd.SuggestionsMinimumDistance)
                        if candidate != "" </span><span class="cov0" title="0">{
                                suggestions = append(suggestions, candidate)
                        }</span>
                }
        }

        <span class="cov8" title="1">var suggestionsMsg string
        if len(suggestions) &gt; 0 </span><span class="cov8" title="1">{
                suggestionsMsg += "\nDid you mean this?\n"
                for _, s := range suggestions </span><span class="cov8" title="1">{
                        suggestionsMsg += fmt.Sprintf("\t%v\n", s)
                }</span>
        }

        <span class="cov8" title="1">if suggestionsMsg != "" </span><span class="cov8" title="1">{
                requireMsg = fmt.Sprintf("%s\n%s", requireMsg, suggestionsMsg)
                return fmt.Errorf(requireMsg, typedName, cmd.CommandPath())
        }</span>

        <span class="cov0" title="0">if typedName == "" </span><span class="cov0" title="0">{
                return cmd.Help()
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("command %s %s doesn't exist. Run %s help for available commands", cmd.Name(), typedName, cmd.Root().Name())</span>
}

// suggestsByPrefixOrLd suggests a command by levenshtein distance or by prefix.
// It returns an empty string if nothing was found
func suggestsByPrefixOrLd(typedName, candidate string, minDistance int) string <span class="cov8" title="1">{
        levenshteinVariable := levenshteinDistance(typedName, candidate, true)
        suggestByLevenshtein := levenshteinVariable &lt;= minDistance
        suggestByPrefix := strings.HasPrefix(strings.ToLower(candidate), strings.ToLower(typedName))
        if !suggestByLevenshtein &amp;&amp; !suggestByPrefix </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return candidate</span>
}

// ld compares two strings and returns the levenshtein distance between them.
func levenshteinDistance(s, t string, ignoreCase bool) int <span class="cov8" title="1">{
        if ignoreCase </span><span class="cov8" title="1">{
                s = strings.ToLower(s)
                t = strings.ToLower(t)
        }</span>
        <span class="cov8" title="1">d := make([][]int, len(s)+1)
        for i := range d </span><span class="cov8" title="1">{
                d[i] = make([]int, len(t)+1)
        }</span>
        <span class="cov8" title="1">for i := range d </span><span class="cov8" title="1">{
                d[i][0] = i
        }</span>
        <span class="cov8" title="1">for j := range d[0] </span><span class="cov8" title="1">{
                d[0][j] = j
        }</span>
        <span class="cov8" title="1">for j := 1; j &lt;= len(t); j++ </span><span class="cov8" title="1">{
                for i := 1; i &lt;= len(s); i++ </span><span class="cov8" title="1">{
                        if s[i-1] == t[j-1] </span><span class="cov8" title="1">{
                                d[i][j] = d[i-1][j-1]
                        }</span> else<span class="cov8" title="1"> {
                                minCost := d[i-1][j]
                                if d[i][j-1] &lt; minCost </span><span class="cov8" title="1">{
                                        minCost = d[i][j-1]
                                }</span>
                                <span class="cov8" title="1">if d[i-1][j-1] &lt; minCost </span><span class="cov8" title="1">{
                                        minCost = d[i-1][j-1]
                                }</span>
                                <span class="cov8" title="1">d[i][j] = minCost + 1</span>
                        }
                }

        }
        <span class="cov8" title="1">return d[len(s)][len(t)]</span>
}

// Find takes a slice and looks for an element in it. If found it will
// return it's key, otherwise it will return -1 and a bool of false.
func Find(slice []string, val string) (int, bool) <span class="cov8" title="1">{
        for i, item := range slice </span><span class="cov8" title="1">{
                if item == val </span><span class="cov8" title="1">{
                        return i, true
                }</span>
        }
        <span class="cov0" title="0">return -1, false</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package task

import (
        "fmt"
        "os"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var taskGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "tasks"}

func GetAllTaskNames(gr schema.GroupVersionResource, c *cli.Clients, ns string) ([]string, error) <span class="cov8" title="1">{
        var tasks *v1.TaskList
        if err := actions.ListV1(gr, c, metav1.ListOptions{}, ns, &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list Tasks from namespace %s: %v", ns, err)
        }</span>

        <span class="cov8" title="1">ret := []string{}
        for _, item := range tasks.Items </span><span class="cov8" title="1">{
                ret = append(ret, item.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

// TODO: remove as all the function uses are moved to new func
// Get will fetch the task resource based on the task name
func Get(c *cli.Clients, taskname string, opts metav1.GetOptions, ns string) (*v1beta1.Task, error) <span class="cov0" title="0">{
        unstructuredT, err := actions.Get(taskGroupResource, c.Dynamic, c.Tekton.Discovery(), taskname, ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var task *v1beta1.Task
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredT.UnstructuredContent(), &amp;task); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to get task from %s namespace \n", ns)
                return nil, err
        }</span>
        <span class="cov0" title="0">return task, nil</span>
}

func Create(c *cli.Clients, t *v1beta1.Task, opts metav1.CreateOptions, ns string) (*v1beta1.Task, error) <span class="cov8" title="1">{
        object, err := runtime.DefaultUnstructuredConverter.ToUnstructured(t)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">unstructuredT := &amp;unstructured.Unstructured{
                Object: object,
        }
        newUnstructuredT, err := actions.Create(taskGroupResource, c, unstructuredT, ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var task *v1beta1.Task
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredT.UnstructuredContent(), &amp;task); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return task, nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package task

import (
        "fmt"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var taskrunGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "taskruns"}

// LastRun returns the name of last taskrun for a given task
func LastRunName(cs *cli.Clients, resourceName, ns, kind string) (string, error) <span class="cov8" title="1">{
        latest, err := LastRun(cs, resourceName, ns, kind)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return latest.Name, nil</span>
}

// LastRun returns the last taskrun for a given task
func LastRun(cs *cli.Clients, resourceName, ns, kind string) (*v1.TaskRun, error) <span class="cov8" title="1">{
        options := metav1.ListOptions{}

        label := "task"

        if resourceName != "" </span><span class="cov8" title="1">{
                options = metav1.ListOptions{
                        LabelSelector: fmt.Sprintf("tekton.dev/%s=%s", label, resourceName),
                }
        }</span>

        <span class="cov8" title="1">var trs *v1.TaskRunList
        if err := actions.ListV1(taskrunGroupResource, cs, options, ns, &amp;trs); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(trs.Items) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no TaskRuns related to %s %s found in namespace %s", kind, resourceName, ns)
        }</span>

        <span class="cov8" title="1">if kind == "Task" </span><span class="cov8" title="1">{
                trs.Items = FilterByRef(trs.Items, kind)
        }</span>

        <span class="cov8" title="1">latest := trs.Items[0]
        for _, tr := range trs.Items </span><span class="cov8" title="1">{
                if tr.CreationTimestamp.Time.After(latest.CreationTimestamp.Time) </span><span class="cov8" title="1">{
                        latest = tr
                }</span>
        }

        <span class="cov8" title="1">return &amp;latest, nil</span>
}

// this will filter the taskrun which have reference to Task
func FilterByRef(taskruns []v1.TaskRun, kind string) []v1.TaskRun <span class="cov8" title="1">{
        var filtered []v1.TaskRun
        for _, taskrun := range taskruns </span><span class="cov8" title="1">{
                if string(taskrun.Spec.TaskRef.Kind) == kind </span><span class="cov8" title="1">{
                        filtered = append(filtered, taskrun)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package taskrun

import (
        "context"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
)

func Create(c *cli.Clients, tr *v1beta1.TaskRun, opts metav1.CreateOptions, ns string) (*v1beta1.TaskRun, error) <span class="cov0" title="0">{
        gvr, err := actions.GetGroupVersionResource(taskrunGroupResource, c.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if gvr.Version == "v1" </span><span class="cov0" title="0">{
                trv1 := v1.TaskRun{}
                err = tr.ConvertTo(context.Background(), &amp;trv1)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">trv1.Kind = "TaskRun"
                trv1.APIVersion = "tekton.dev/v1"

                object, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(&amp;trv1)
                unstructuredTR := &amp;unstructured.Unstructured{
                        Object: object,
                }
                newUnstructuredTR, err := actions.Create(taskrunGroupResource, c, unstructuredTR, ns, opts)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">var taskrun v1.TaskRun
                if err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredTR.UnstructuredContent(), &amp;taskrun); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">taskrunv1beta1 := v1beta1.TaskRun{}
                err = taskrunv1beta1.ConvertFrom(context.Background(), &amp;taskrun)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">taskrunv1beta1.Kind = "TaskRun"
                taskrunv1beta1.APIVersion = "tekton.dev/v1beta1"
                return &amp;taskrunv1beta1, nil</span>
        }

        <span class="cov0" title="0">object, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(tr)
        unstructuredTR := &amp;unstructured.Unstructured{
                Object: object,
        }
        newUnstructuredTR, err := actions.Create(taskrunGroupResource, c, unstructuredTR, ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var taskrun *v1beta1.TaskRun
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredTR.UnstructuredContent(), &amp;taskrun); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return taskrun, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package taskrun

import (
        "context"
        "fmt"
        "io"
        "sort"
        "text/tabwriter"
        "text/template"

        "github.com/jonboulle/clockwork"
        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/formatted"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const templ = `{{decorate "bold" "Name"}}:        {{ .TaskRun.Name }}
{{decorate "bold" "Namespace"}}:        {{ .TaskRun.Namespace }}
{{- $tRefName := taskRefExists .TaskRun.Spec }}{{- if ne $tRefName "" }}
{{decorate "bold" "Task Ref"}}:        {{ $tRefName }}
{{- end }}
{{- if ne .TaskRun.Spec.ServiceAccountName "" }}
{{decorate "bold" "Service Account"}}:        {{ .TaskRun.Spec.ServiceAccountName }}
{{- end }}

{{- $timeout := getTimeout .TaskRun -}}
{{- if and (ne $timeout "") (ne $timeout "0s") }}
{{decorate "bold" "Timeout"}}:        {{ .TaskRun.Spec.Timeout.Duration.String }}
{{- end }}
{{- $l := len .TaskRun.Labels }}{{ if eq $l 0 }}
{{- else }}
{{decorate "bold" "Labels"}}:
{{- range $k, $v := .TaskRun.Labels }}
 {{ $k }}={{ $v }}
{{- end }}
{{- end }}
{{- $annotations := removeLastAppliedConfig .TaskRun.Annotations -}}
{{- if $annotations }}
{{decorate "bold" "Annotations"}}:
{{- range $k, $v := $annotations }}
 {{ $k }}={{ $v }}
{{- end }}
{{- end }}

{{decorate "status" ""}}{{decorate "underline bold" "Status"}}

STARTED         DURATION         STATUS
{{ formatAge .TaskRun.Status.StartTime  .Time }}        {{ formatDuration .TaskRun.Status.StartTime .TaskRun.Status.CompletionTime }}        {{ formatCondition .TaskRun.Status.Conditions }}
{{- $msg := hasFailed .TaskRun -}}
{{-  if ne $msg "" }}

{{decorate "underline bold" "Message"}}

{{ $msg }}
{{- end }}

{{- if ne (len .TaskRun.Spec.Params) 0 }}

{{decorate "params" ""}}{{decorate "underline bold" "Params"}}

 NAME        VALUE
{{- range $i, $p := .TaskRun.Spec.Params }}
{{- if eq $p.Value.Type "string" }}
 {{decorate "bullet" $p.Name }}        {{ $p.Value.StringVal }}
{{- else if eq $p.Value.Type "array" }}
 {{decorate "bullet" $p.Name }}        {{ $p.Value.ArrayVal }}
{{- else }}
 {{decorate "bullet" $p.Name }}        {{ $p.Value.ObjectVal }}
{{- end }}
{{- end }}
{{- end }}

{{- if ne (len .TaskRun.Status.Results) 0 }}

{{decorate "results" ""}}{{decorate "underline bold" "Results"}}

 NAME        VALUE
{{- range $result := .TaskRun.Status.Results }}
 {{decorate "bullet" $result.Name }}        {{ formatResult $result.Value }}
{{- end }}
{{- end }}

{{- if ne (len .TaskRun.Spec.Workspaces) 0 }}

{{decorate "workspaces" ""}}{{decorate "underline bold" "Workspaces"}}

 NAME        SUB PATH        WORKSPACE BINDING
{{- range $workspace := .TaskRun.Spec.Workspaces }}
{{- if not $workspace.SubPath }}
 {{ decorate "bullet" $workspace.Name }}        {{ "---" }}        {{ formatWorkspace $workspace }}
{{- else }}
 {{ decorate "bullet" $workspace.Name }}        {{ $workspace.SubPath }}        {{ formatWorkspace $workspace }}
{{- end }}
{{- end }}
{{- end }}

{{- $sortedSteps := sortStepStates .TaskRun.Status.Steps }}
{{- if ne (len $sortedSteps) 0 }}

{{decorate "steps" ""}}{{decorate "underline bold" "Steps"}}

 NAME        STATUS
{{- range $step := $sortedSteps }}
{{- $reason := stepReasonExists $step }}
 {{decorate "bullet" $step.Name }}        {{ $reason }}
{{- end }}
{{- end }}

{{- $sidecars := .TaskRun.Status.Sidecars }}
{{- if ne (len $sidecars) 0 }}

{{decorate "sidecars" ""}}{{decorate "underline bold" "Sidecars"}}

 NAME        STATUS
{{- range $sidecar := $sidecars }}
{{- $reason := sidecarReasonExists $sidecar }}
 {{decorate "bullet" $sidecar.Name }}        {{ $reason }}
{{- end }}
{{- end }}
`

func sortStepStatesByStartTime(steps []v1.StepState) []v1.StepState <span class="cov8" title="1">{
        sort.Slice(steps, func(i, j int) bool </span><span class="cov8" title="1">{
                if steps[j].Waiting != nil &amp;&amp; steps[i].Waiting != nil </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">var jStartTime metav1.Time
                jRunning := false
                var iStartTime metav1.Time
                iRunning := false
                if steps[j].Terminated == nil </span><span class="cov8" title="1">{
                        if steps[j].Running != nil </span><span class="cov8" title="1">{
                                jStartTime = steps[j].Running.StartedAt
                                jRunning = true
                        }</span> else<span class="cov8" title="1"> {
                                return true
                        }</span>
                }

                <span class="cov8" title="1">if steps[i].Terminated == nil </span><span class="cov8" title="1">{
                        if steps[i].Running != nil </span><span class="cov8" title="1">{
                                iStartTime = steps[i].Running.StartedAt
                                iRunning = true
                        }</span> else<span class="cov8" title="1"> {
                                return false
                        }</span>
                }

                <span class="cov8" title="1">if !jRunning </span><span class="cov8" title="1">{
                        jStartTime = steps[j].Terminated.StartedAt
                }</span>

                <span class="cov8" title="1">if !iRunning </span><span class="cov8" title="1">{
                        iStartTime = steps[i].Terminated.StartedAt
                }</span>

                <span class="cov8" title="1">return iStartTime.Before(&amp;jStartTime)</span>
        })

        <span class="cov8" title="1">return steps</span>
}

func PrintTaskRunDescription(out io.Writer, c *cli.Clients, ns string, trName string, time clockwork.Clock) error <span class="cov0" title="0">{
        tr, err := GetTaskRun(taskrunGroupResource, c, trName, ns)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get TaskRun %s: %v", trName, err)
        }</span>

        <span class="cov0" title="0">var data = struct {
                TaskRun *v1.TaskRun
                Time    clockwork.Clock
        }{
                TaskRun: tr,
                Time:    time,
        }

        funcMap := template.FuncMap{
                "formatAge":               formatted.Age,
                "formatDuration":          formatted.Duration,
                "formatCondition":         formatted.Condition,
                "formatResult":            formatted.Result,
                "formatWorkspace":         formatted.Workspace,
                "hasFailed":               hasFailed,
                "taskRefExists":           formatted.TaskRefExists,
                "stepReasonExists":        stepReasonExists,
                "sidecarReasonExists":     sidecarReasonExists,
                "decorate":                formatted.DecorateAttr,
                "sortStepStates":          sortStepStatesByStartTime,
                "getTimeout":              getTimeoutValue,
                "removeLastAppliedConfig": formatted.RemoveLastAppliedConfig,
        }

        w := tabwriter.NewWriter(out, 0, 5, 3, ' ', tabwriter.TabIndent)
        t := template.Must(template.New("Describe TaskRun").Funcs(funcMap).Parse(templ))

        err = t.Execute(w, data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return w.Flush()</span>
}

func hasFailed(tr *v1.TaskRun) string <span class="cov0" title="0">{
        if len(tr.Status.Conditions) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if tr.Status.Conditions[0].Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                return tr.Status.Conditions[0].Message
        }</span>

        <span class="cov0" title="0">return ""</span>
}

func getTimeoutValue(tr *v1.TaskRun) string <span class="cov0" title="0">{
        if tr.Spec.Timeout != nil </span><span class="cov0" title="0">{
                return tr.Spec.Timeout.Duration.String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Check if step is in waiting, running, or terminated state by checking StepState of the step.
func stepReasonExists(state v1.StepState) string <span class="cov8" title="1">{
        if state.Waiting == nil </span><span class="cov8" title="1">{
                if state.Running != nil </span><span class="cov8" title="1">{
                        return formatted.ColorStatus("Running")
                }</span>

                <span class="cov8" title="1">if state.Terminated != nil </span><span class="cov8" title="1">{
                        return formatted.ColorStatus(state.Terminated.Reason)
                }</span>

                <span class="cov8" title="1">return formatted.ColorStatus("---")</span>
        }

        <span class="cov8" title="1">return formatted.ColorStatus(state.Waiting.Reason)</span>
}

// Check if sidecar is in waiting, running, or terminated state by checking SidecarState of the sidecar.
func sidecarReasonExists(state v1.SidecarState) string <span class="cov8" title="1">{
        if state.Waiting == nil </span><span class="cov8" title="1">{

                if state.Running != nil </span><span class="cov8" title="1">{
                        return formatted.ColorStatus("Running")
                }</span>

                <span class="cov8" title="1">if state.Terminated != nil </span><span class="cov8" title="1">{
                        return formatted.ColorStatus(state.Terminated.Reason)
                }</span>

                <span class="cov8" title="1">return formatted.ColorStatus("---")</span>
        }

        <span class="cov8" title="1">return formatted.ColorStatus(state.Waiting.Reason)</span>
}

func GetTaskRun(gr schema.GroupVersionResource, c *cli.Clients, trName, ns string) (*v1.TaskRun, error) <span class="cov0" title="0">{
        var taskrun v1.TaskRun
        gvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if gvr.Version == "v1" </span><span class="cov0" title="0">{
                err := actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, &amp;taskrun)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;taskrun, nil</span>
        }

        <span class="cov0" title="0">var taskrunV1beta1 v1beta1.TaskRun
        err = actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, &amp;taskrunV1beta1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = taskrunV1beta1.ConvertTo(context.Background(), &amp;taskrun)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;taskrun, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package taskrun

import (
        "fmt"

        "github.com/jonboulle/clockwork"
        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/cli/pkg/formatted"
        trsort "github.com/tektoncd/cli/pkg/taskrun/sort"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var taskrunGroupResource = schema.GroupVersionResource{Group: "tekton.dev", Resource: "taskruns"}

func GetAllTaskRuns(gr schema.GroupVersionResource, opts metav1.ListOptions, c *cli.Clients, ns string, limit int, time clockwork.Clock) ([]string, error) <span class="cov8" title="1">{
        var taskruns *v1.TaskRunList
        if err := actions.ListV1(gr, c, opts, ns, &amp;taskruns); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list TaskRuns from namespace %s: %v", ns, err)
        }</span>

        <span class="cov8" title="1">runslen := len(taskruns.Items)
        if limit &gt; runslen </span><span class="cov8" title="1">{
                limit = runslen
        }</span>

        <span class="cov8" title="1">trsort.SortByStartTime(taskruns.Items)
        ret := []string{}
        for i, run := range taskruns.Items </span><span class="cov8" title="1">{
                if i &lt; limit </span><span class="cov8" title="1">{
                        ret = append(ret, run.ObjectMeta.Name+" started "+formatted.Age(run.Status.StartTime, time))
                }</span>
        }
        <span class="cov8" title="1">return ret, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package taskrun

import (
        "sort"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func SortByNamespace(trs []v1.TaskRun) <span class="cov8" title="1">{
        sort.Sort(byNamespace(trs))
}</span>

type byNamespace []v1.TaskRun

func (trs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) <span class="cov8" title="1">{
        lt, eq = ins &lt; jns, ins == jns
        return lt, eq
}</span>

func (trs byNamespace) Len() int      <span class="cov8" title="1">{ return len(trs) }</span>
func (trs byNamespace) Swap(i, j int) <span class="cov8" title="1">{ trs[i], trs[j] = trs[j], trs[i] }</span>
func (trs byNamespace) Less(i, j int) bool <span class="cov8" title="1">{
        var lt, eq bool
        if lt, eq = trs.compareNamespace(trs[i].Namespace, trs[j].Namespace); eq </span><span class="cov8" title="1">{
                if trs[j].Status.StartTime == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if trs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return trs[j].Status.StartTime.Before(trs[i].Status.StartTime)</span>
        }
        <span class="cov8" title="1">return lt</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package taskrun

import (
        "sort"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func SortByStartTime(trs []v1.TaskRun) <span class="cov8" title="1">{
        sort.Sort(byStartTime(trs))
}</span>

type byStartTime []v1.TaskRun

func (trs byStartTime) Len() int      <span class="cov8" title="1">{ return len(trs) }</span>
func (trs byStartTime) Swap(i, j int) <span class="cov8" title="1">{ trs[i], trs[j] = trs[j], trs[i] }</span>
func (trs byStartTime) Less(i, j int) bool <span class="cov8" title="1">{
        if trs[j].Status.StartTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if trs[i].Status.StartTime == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return trs[j].Status.StartTime.Before(trs[i].Status.StartTime)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">// Copyright © 2019 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package taskrun

import (
        "sort"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type Run struct {
        Name           string
        Task           string
        Retries        int
        StartTime      *metav1.Time
        CompletionTime *metav1.Time
}

type Runs []Run

func (r Runs) Len() int <span class="cov0" title="0">{
        return len(r)
}</span>

func (r Runs) Less(i, j int) bool <span class="cov0" title="0">{
        if r[i].CompletionTime != nil &amp;&amp; r[j].CompletionTime != nil </span><span class="cov0" title="0">{
                return r[i].CompletionTime.Before(r[j].CompletionTime)
        }</span>
        <span class="cov0" title="0">return r[i].StartTime.Before(r[j].StartTime)</span>
}

func (r Runs) Swap(i, j int) <span class="cov0" title="0">{
        r[i], r[j] = r[j], r[i]
}</span>

func IsFiltered(tr Run, allowed []string) bool <span class="cov0" title="0">{
        trs := []Run{tr}
        return len(Filter(trs, allowed)) == 0
}</span>

func HasScheduled(trs *v1.PipelineRunTaskRunStatus) bool <span class="cov0" title="0">{
        if trs.Status != nil </span><span class="cov0" title="0">{
                return trs.Status.PodName != ""
        }</span>
        <span class="cov0" title="0">return false</span>
}

func Filter(trs []Run, ts []string) []Run <span class="cov0" title="0">{
        if len(ts) == 0 </span><span class="cov0" title="0">{
                return trs
        }</span>

        <span class="cov0" title="0">filter := map[string]bool{}
        for _, t := range ts </span><span class="cov0" title="0">{
                filter[t] = true
        }</span>

        <span class="cov0" title="0">filtered := []Run{}
        for _, tr := range trs </span><span class="cov0" title="0">{
                if filter[tr.Task] </span><span class="cov0" title="0">{
                        filtered = append(filtered, tr)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}

func SortTasksBySpecOrder(pipelineTasks []v1.PipelineTask, pipelinesTaskRuns map[string]*v1.PipelineRunTaskRunStatus) []Run <span class="cov0" title="0">{
        trNames := map[string]string{}

        for name, t := range pipelinesTaskRuns </span><span class="cov0" title="0">{
                trNames[t.PipelineTaskName] = name
        }</span>
        <span class="cov0" title="0">trs := Runs{}

        for _, ts := range pipelineTasks </span><span class="cov0" title="0">{
                if n, ok := trNames[ts.Name]; ok </span><span class="cov0" title="0">{
                        trStatusFields := pipelinesTaskRuns[n].Status.TaskRunStatusFields
                        trs = append(trs, Run{
                                Task:           ts.Name,
                                Name:           n,
                                Retries:        ts.Retries,
                                StartTime:      trStatusFields.StartTime,
                                CompletionTime: trStatusFields.CompletionTime,
                        })
                }</span>
        }
        <span class="cov0" title="0">sort.Sort(trs)
        return trs</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package triggerbinding

import (
        "fmt"
        "os"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var triggerbindingGroupResource = schema.GroupVersionResource{Group: "triggers.tekton.dev", Resource: "triggerbindings"}

func GetAllTriggerBindingNames(client *cli.Clients, namespace string) ([]string, error) <span class="cov8" title="1">{
        ps, err := List(client, metav1.ListOptions{}, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ret := []string{}
        for _, item := range ps.Items </span><span class="cov8" title="1">{
                ret = append(ret, item.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func List(c *cli.Clients, opts metav1.ListOptions, ns string) (*v1beta1.TriggerBindingList, error) <span class="cov8" title="1">{
        unstructuredTB, err := actions.List(triggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var triggerbindings *v1beta1.TriggerBindingList
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTB.UnstructuredContent(), &amp;triggerbindings); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to list triggerbindings from %s namespace \n", ns)
                return nil, err
        }</span>

        <span class="cov8" title="1">return triggerbindings, nil</span>
}

func Get(c *cli.Clients, tbname string, opts metav1.GetOptions, ns string) (*v1beta1.TriggerBinding, error) <span class="cov8" title="1">{
        unstructuredTB, err := actions.Get(triggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), tbname, ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var tb *v1beta1.TriggerBinding
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTB.UnstructuredContent(), &amp;tb); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to get triggerbinding from %s namespace \n", ns)
                return nil, err
        }</span>
        <span class="cov8" title="1">return tb, nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// Copyright © 2021 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package triggertemplate

import (
        "fmt"
        "os"

        "github.com/tektoncd/cli/pkg/actions"
        "github.com/tektoncd/cli/pkg/cli"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

var triggertemplateGroupResource = schema.GroupVersionResource{Group: "triggers.tekton.dev", Resource: "triggertemplates"}

func GetAllTriggerTemplateNames(client *cli.Clients, namespace string) ([]string, error) <span class="cov8" title="1">{
        ps, err := List(client, metav1.ListOptions{}, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ret := []string{}
        for _, item := range ps.Items </span><span class="cov8" title="1">{
                ret = append(ret, item.ObjectMeta.Name)
        }</span>
        <span class="cov8" title="1">return ret, nil</span>
}

func List(c *cli.Clients, opts metav1.ListOptions, ns string) (*v1beta1.TriggerTemplateList, error) <span class="cov8" title="1">{
        unstructuredTT, err := actions.List(triggertemplateGroupResource, c.Dynamic, c.Triggers.Discovery(), ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var triggertemplates *v1beta1.TriggerTemplateList
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTT.UnstructuredContent(), &amp;triggertemplates); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failed to list triggertemplates from %s namespace \n", ns)
                return nil, err
        }</span>

        <span class="cov8" title="1">return triggertemplates, nil</span>
}

func Get(c *cli.Clients, ttname string, opts metav1.GetOptions, ns string) (*v1beta1.TriggerTemplate, error) <span class="cov8" title="1">{
        unstructuredTT, err := actions.Get(triggertemplateGroupResource, c.Dynamic, c.Triggers.Discovery(), ttname, ns, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var tt *v1beta1.TriggerTemplate
        if err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTT.UnstructuredContent(), &amp;tt); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "failed to get triggertemplate from %s namespace \n", ns)
                return nil, err
        }</span>
        <span class="cov8" title="1">return tt, nil</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">// Copyright © 2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package trustedresources

import (
        "bytes"
        "context"
        "crypto"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "syscall"

        "github.com/sigstore/sigstore/pkg/signature"
        "github.com/sigstore/sigstore/pkg/signature/kms"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "golang.org/x/term"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/yaml"
)

const (
        // SignatureAnnotation is the key of signature in annotation map
        SignatureAnnotation = "tekton.dev/signature"
)

var (
        // Read is for fuzzing
        read = readPasswordFn
)

// Sign the crd and output signed bytes to writer
func Sign(o metav1.Object, keyfile, kmsKey, targetFile string) error <span class="cov8" title="1">{
        // Load signer
        var signer signature.Signer
        var err error
        if keyfile != "" </span><span class="cov8" title="1">{
                signer, err = signature.LoadSignerFromPEMFile(keyfile, crypto.SHA256, getPass)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting signer from key file: %v", err)
                }</span>
        }
        <span class="cov8" title="1">if kmsKey != "" </span><span class="cov0" title="0">{
                ctx := context.Background()
                signer, err = kms.Get(ctx, kmsKey, crypto.SHA256)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting kms signer: %v", err)
                }</span>
        }

        // Get annotation
        <span class="cov8" title="1">a := o.GetAnnotations()
        if a == nil </span><span class="cov8" title="1">{
                a = map[string]string{}
        }</span>

        // Sign object
        <span class="cov8" title="1">sig, err := signInterface(signer, o)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">a[SignatureAnnotation] = base64.StdEncoding.EncodeToString(sig)
        o.SetAnnotations(a)
        signedBuf, err := yaml.Marshal(o)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // save signed file
        <span class="cov8" title="1">f, err := os.OpenFile(targetFile, os.O_WRONLY|os.O_CREATE, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error opening output file: %v", err)
        }</span>
        <span class="cov8" title="1">defer f.Close()
        _, err = f.Write(signedBuf)

        return err</span>
}

// signInterface returns the encoded signature for the given object.
func signInterface(signer signature.Signer, i interface{}) ([]byte, error) <span class="cov8" title="1">{
        if signer == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("signer is nil")
        }</span>
        <span class="cov8" title="1">b, err := json.Marshal(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">h := sha256.New()
        h.Write(b)

        sig, err := signer.SignMessage(bytes.NewReader(h.Sum(nil)))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return sig, nil</span>
}

// UnmarshalCRD will get the task/pipeline from buffer and extract the signature.
func UnmarshalCRD(buf []byte, kind string) (metav1.Object, []byte, error) <span class="cov8" title="1">{
        var resource metav1.Object
        var signature []byte

        switch kind </span>{
        case "Task":<span class="cov8" title="1">
                resource = &amp;v1beta1.Task{}
                if err := yaml.Unmarshal(buf, &amp;resource); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        case "Pipeline":<span class="cov8" title="1">
                resource = &amp;v1beta1.Pipeline{}
                if err := yaml.Unmarshal(buf, &amp;resource); err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }
        <span class="cov8" title="1">annotations := resource.GetAnnotations()
        signature, err := base64.StdEncoding.DecodeString(annotations[SignatureAnnotation])
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">delete(annotations, SignatureAnnotation)

        return resource, signature, nil</span>
}

func getPass(confirm bool) ([]byte, error) <span class="cov8" title="1">{
        read := read(confirm)
        return read()
}</span>

func readPasswordFn(confirm bool) func() ([]byte, error) <span class="cov8" title="1">{
        pw, ok := os.LookupEnv("PRIVATE_PASSWORD")
        switch </span>{
        case ok:<span class="cov8" title="1">
                return func() ([]byte, error) </span><span class="cov8" title="1">{
                        return []byte(pw), nil
                }</span>
        case isTerminal():<span class="cov0" title="0">
                return func() ([]byte, error) </span><span class="cov0" title="0">{
                        return getPassFromTerm(confirm)
                }</span>
        // Handle piped in passwords.
        default:<span class="cov0" title="0">
                return func() ([]byte, error) </span><span class="cov0" title="0">{
                        return io.ReadAll(os.Stdin)
                }</span>
        }
}

func getPassFromTerm(confirm bool) ([]byte, error) <span class="cov0" title="0">{
        fmt.Fprint(os.Stderr, "Enter password for private key: ")
        // Unnecessary convert of syscall.Stdin on *nix, but Windows is a uintptr
        // nolint:unconvert
        pw1, err := term.ReadPassword(int(syscall.Stdin))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fmt.Fprintln(os.Stderr)
        if !confirm </span><span class="cov0" title="0">{
                return pw1, nil
        }</span>
        <span class="cov0" title="0">fmt.Fprint(os.Stderr, "Enter password for private key again: ")
        // Unnecessary convert of syscall.Stdin on *nix, but Windows is a uintptr
        // nolint:unconvert
        confirmpw, err := term.ReadPassword(int(syscall.Stdin))
        fmt.Fprintln(os.Stderr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if string(pw1) != string(confirmpw) </span><span class="cov0" title="0">{
                return nil, errors.New("passwords do not match")
        }</span>
        <span class="cov0" title="0">return pw1, nil</span>
}

func isTerminal() bool <span class="cov0" title="0">{
        stat, _ := os.Stdin.Stat()
        return (stat.Mode() &amp; os.ModeCharDevice) != 0
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">// Copyright © 2022 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package trustedresources

import (
        "bytes"
        "context"
        "crypto"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "fmt"

        cosignsignature "github.com/sigstore/cosign/v2/pkg/signature"
        "github.com/sigstore/sigstore/pkg/signature"
        "github.com/sigstore/sigstore/pkg/signature/kms"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Verify the crd
func Verify(o metav1.Object, keyfile, kmsKey string) error <span class="cov8" title="1">{
        var verifier signature.Verifier
        var err error
        if keyfile != "" </span><span class="cov8" title="1">{
                // Load signer from key files
                ctx := context.Background()
                verifier, err = cosignsignature.LoadPublicKey(ctx, keyfile)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting verifier from key file: %v", err)
                }</span>

        }
        <span class="cov8" title="1">if kmsKey != "" </span><span class="cov0" title="0">{
                ctx := context.Background()
                verifier, err = kms.Get(ctx, kmsKey, crypto.SHA256)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error getting kms verifier: %v", err)
                }</span>
        }

        // Get raw signature
        <span class="cov8" title="1">a := o.GetAnnotations()
        sigString := a[SignatureAnnotation]
        signatureBytes, err := base64.StdEncoding.DecodeString(sigString)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">delete(a, SignatureAnnotation)
        o.SetAnnotations(a)
        // Verify signature
        return VerifyInterface(o, verifier, signatureBytes)</span>
}

// VerifyInterface get the checksum of json marshalled object and verify it.
func VerifyInterface(
        obj interface{},
        verifier signature.Verifier,
        signature []byte,
) error <span class="cov8" title="1">{
        ts, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">h := sha256.New()
        h.Write(ts)
        return verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(h.Sum(nil)))</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">// Copyright © 2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package version

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/cli/pkg/cli"
        v1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
        pipelinesControllerSelector    string = "app.kubernetes.io/part-of=tekton-pipelines,app.kubernetes.io/component=controller,app.kubernetes.io/name=controller"
        oldPipelinesControllerSelector string = "app.kubernetes.io/component=controller,app.kubernetes.io/name=tekton-pipelines"
        triggersControllerSelector     string = "app.kubernetes.io/part-of=tekton-triggers,app.kubernetes.io/component=controller,app.kubernetes.io/name=controller"
        oldTriggersControllerSelector  string = "app.kubernetes.io/component=controller,app.kubernetes.io/name=tekton-triggers"
        dashboardControllerSelector    string = "app.kubernetes.io/part-of=tekton-dashboard,app.kubernetes.io/component=dashboard,app.kubernetes.io/name=dashboard"
        oldDashboardControllerSelector string = "app=tekton-dashboard"
        chainsInfo                     string = "chains-info"
        pipelinesInfo                  string = "pipelines-info"
        triggersInfo                   string = "triggers-info"
        dashboardInfo                  string = "dashboard-info"
        operatorInfo                   string = "tekton-operator-info"
        hubInfo                        string = "hub-info"
)

var defaultNamespaces = []string{"tekton-pipelines", "openshift-pipelines", "tekton-chains", "tekton-operator", "openshift-operators"}

// GetPipelineVersion Get pipeline version, functions imported from Dashboard
func GetPipelineVersion(c *cli.Clients, ns string) (string, error) <span class="cov8" title="1">{

        var version string
        // for Tekton Pipelines version 0.25.0+
        configMap, err := getConfigMap(c, pipelinesInfo, ns)
        if err == nil </span><span class="cov8" title="1">{
                version = configMap.Data["version"]
        }</span>

        <span class="cov8" title="1">if version != "" </span><span class="cov8" title="1">{
                return version, nil
        }</span>

        <span class="cov8" title="1">deploymentsList, err := getDeployments(c, pipelinesControllerSelector, oldPipelinesControllerSelector, ns)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">version = findPipelineVersion(deploymentsList.Items)

        if version == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("error getting the tekton pipelines deployment version. Version is unknown")
        }</span>

        <span class="cov8" title="1">return version, nil</span>
}

// Get deployments for either Tekton Triggers, Tekton Dashboard or Tekton Pipelines
func getDeployments(c *cli.Clients, newLabel, oldLabel, ns string) (*v1.DeploymentList, error) <span class="cov8" title="1">{
        var (
                err         error
                deployments *v1.DeploymentList
        )
        if ns != "" </span><span class="cov8" title="1">{
                deployments, err = getDeploy(c, newLabel, oldLabel, ns)
                return deployments, err
        }</span>
        // If ldflag and flag doesn't specify the namespace fallback to default.
        <span class="cov8" title="1">for _, n := range defaultNamespaces </span><span class="cov8" title="1">{
                deployments, err = getDeploy(c, newLabel, oldLabel, n)
                if err != nil </span><span class="cov0" title="0">{
                        if strings.Contains(err.Error(), fmt.Sprintf(`cannot list resource "deployments" in API group "apps" in the namespace "%s"`, n)) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">if len(deployments.Items) != 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return deployments, err</span>
}

func getDeploy(c *cli.Clients, newLabel, oldLabel, ns string) (*v1.DeploymentList, error) <span class="cov8" title="1">{
        deployments, err := c.Kube.AppsV1().Deployments(ns).List(context.Background(), metav1.ListOptions{LabelSelector: newLabel})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // NOTE: If the new labels selector returned nothing, try with old labels selector
        // The old labels selectors are deprecated and should be removed at some point
        <span class="cov8" title="1">if deployments == nil || len(deployments.Items) == 0 </span><span class="cov8" title="1">{
                deployments, err = c.Kube.AppsV1().Deployments(ns).List(context.Background(), metav1.ListOptions{LabelSelector: oldLabel})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return deployments, err</span>
}

func getConfigMap(c *cli.Clients, name, ns string) (*corev1.ConfigMap, error) <span class="cov8" title="1">{

        var (
                err       error
                configMap *corev1.ConfigMap
        )

        if ns != "" </span><span class="cov8" title="1">{
                configMap, err = c.Kube.CoreV1().ConfigMaps(ns).Get(context.Background(), name, metav1.GetOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return configMap, nil</span>
        }

        <span class="cov8" title="1">for _, n := range defaultNamespaces </span><span class="cov8" title="1">{
                configMap, err = c.Kube.CoreV1().ConfigMaps(n).Get(context.Background(), name, metav1.GetOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if strings.Contains(err.Error(), fmt.Sprintf(`cannot get resource "configmaps" in API group "" in the namespace "%s"`, n)) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">if configMap != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if configMap == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ConfigMap with name %s not found in the namespace %s", name, ns)
        }</span>
        <span class="cov8" title="1">return configMap, nil</span>
}

func findPipelineVersion(deployments []v1.Deployment) string <span class="cov8" title="1">{
        version := ""
        for _, deployment := range deployments </span><span class="cov8" title="1">{
                deploymentLabels := deployment.Spec.Template.GetLabels()
                deploymentAnnotations := deployment.Spec.Template.GetAnnotations()

                // For master of Tekton Pipelines
                version = deploymentLabels["app.kubernetes.io/version"]

                // For Tekton Pipelines 0.11.*
                if version == "" </span><span class="cov8" title="1">{
                        version = deploymentLabels["pipeline.tekton.dev/release"]
                }</span>

                // For Tekton Pipelines 0.10.0 + 0.10.1 tekton.dev/release has been set as annotation
                <span class="cov8" title="1">if version == "" </span><span class="cov8" title="1">{
                        version = deploymentAnnotations["tekton.dev/release"]
                }</span>

                // For Tekton Pipelines 0.9.0 - 0.9.2
                <span class="cov8" title="1">if version == "" </span><span class="cov8" title="1">{
                        deploymentImage := deployment.Spec.Template.Spec.Containers[0].Image
                        if strings.Contains(deploymentImage, "pipeline/cmd/controller") &amp;&amp; strings.Contains(deploymentImage, ":") &amp;&amp; strings.Contains(deploymentImage, "@") </span><span class="cov8" title="1">{
                                s := strings.SplitAfter(deploymentImage, ":")
                                if strings.Contains(s[1], "@") </span><span class="cov8" title="1">{
                                        t := strings.Split(s[1], "@")
                                        version = t[0]
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return version</span>
}

// GetChainsVersion Get chains version
func GetChainsVersion(c *cli.Clients, ns string) (string, error) <span class="cov8" title="1">{

        configMap, err := getConfigMap(c, chainsInfo, ns)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">version := configMap.Data["version"]
        return version, nil</span>
}

// GetTriggerVersion Get triggers version.
func GetTriggerVersion(c *cli.Clients, ns string) (string, error) <span class="cov8" title="1">{

        var version string

        // for latest pipelines version
        configMap, err := getConfigMap(c, triggersInfo, ns)
        if err == nil </span><span class="cov8" title="1">{
                version = configMap.Data["version"]
        }</span>

        <span class="cov8" title="1">if version != "" </span><span class="cov8" title="1">{
                return version, nil
        }</span>

        <span class="cov8" title="1">deploymentsList, err := getDeployments(c, triggersControllerSelector, oldTriggersControllerSelector, ns)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">version = findTriggersVersion(deploymentsList.Items)

        if version == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("error getting the tekton triggers deployment version. Version is unknown")
        }</span>

        <span class="cov8" title="1">return version, nil</span>
}

func findTriggersVersion(deployments []v1.Deployment) string <span class="cov8" title="1">{
        version := ""
        for _, deployment := range deployments </span><span class="cov8" title="1">{
                deploymentLabels := deployment.Spec.Template.GetLabels()

                // For master of Tekton Triggers
                if version = deploymentLabels["app.kubernetes.io/version"]; version == "" </span><span class="cov8" title="1">{
                        // For Tekton Triggers 0.3.*
                        version = deploymentLabels["triggers.tekton.dev/release"]
                }</span>
        }
        <span class="cov8" title="1">return version</span>
}

// GetDashboardVersion Get dashboard version.
func GetDashboardVersion(c *cli.Clients, ns string) (string, error) <span class="cov8" title="1">{

        var version string

        // for latest pipelines version
        configMap, err := getConfigMap(c, dashboardInfo, ns)
        if err == nil </span><span class="cov8" title="1">{
                version = configMap.Data["version"]
        }</span>

        <span class="cov8" title="1">if version != "" </span><span class="cov8" title="1">{
                return version, nil
        }</span>

        <span class="cov8" title="1">deploymentsList, err := getDeployments(c, dashboardControllerSelector, oldDashboardControllerSelector, ns)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">version = findDashboardVersion(deploymentsList.Items)
        if version == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("error getting the tekton dashboard deployment version. Version is unknown")
        }</span>

        <span class="cov8" title="1">return version, nil</span>
}

func findDashboardVersion(deployments []v1.Deployment) string <span class="cov8" title="1">{
        version := ""
        for _, deployment := range deployments </span><span class="cov8" title="1">{
                deploymentLabels := deployment.Spec.Template.GetLabels()

                // For master of Tekton Dashboard
                if version = deploymentLabels["app.kubernetes.io/version"]; version == "" </span><span class="cov8" title="1">{
                        // For Tekton Dashboard 0.6.*
                        deploymentMetaLabels := deployment.GetObjectMeta().GetLabels()
                        version = deploymentMetaLabels["version"]
                }</span>
        }
        <span class="cov8" title="1">return version</span>
}

// GetOperatorVersion Get operator version
func GetOperatorVersion(c *cli.Clients, ns string) (string, error) <span class="cov8" title="1">{
        configMap, err := getConfigMap(c, operatorInfo, ns)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">version := configMap.Data["version"]
        return version, nil</span>
}

func GetHubVersion(c *cli.Clients, ns string) (string, error) <span class="cov0" title="0">{
        configMap, err := getConfigMap(c, hubInfo, ns)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">version := configMap.Data["version"]
        return version, nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">// Copyright © 2019-2020 The Tekton Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package workspaces

import (
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/tektoncd/cli/pkg/file"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        "sigs.k8s.io/yaml"
)

var (
        nameParam               = "name"
        claimNameParam          = "claimName"
        subPathParam            = "subPath"
        emptyDirParam           = "emptyDir"
        configParam             = "config"
        secretParam             = "secret"
        configItemParam         = "item"
        volumeClaimTemplateFile = "volumeClaimTemplateFile"
        csiFile                 = "csiFile"
)

const invalidWorkspace = "invalid input format for workspace : "

var errNotFoundParam = errors.New("param not found")

// Merge merges workspacebinding already in pipelineruns with given options
func Merge(ws []v1beta1.WorkspaceBinding, optWS []string, httpClient http.Client) ([]v1beta1.WorkspaceBinding,
        error) <span class="cov8" title="1">{
        workspaces, err := parseWorkspace(optWS, httpClient)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(workspaces) == 0 </span><span class="cov8" title="1">{
                return ws, nil
        }</span>

        <span class="cov8" title="1">for i := range ws </span><span class="cov8" title="1">{
                if v, ok := workspaces[ws[i].Name]; ok </span><span class="cov8" title="1">{
                        ws[i] = v
                        delete(workspaces, v.Name)
                }</span>
        }

        <span class="cov8" title="1">for _, v := range workspaces </span><span class="cov8" title="1">{
                ws = append(ws, v)
        }</span>

        <span class="cov8" title="1">return ws, nil</span>
}

func parseWorkspace(w []string, httpClient http.Client) (map[string]v1beta1.WorkspaceBinding, error) <span class="cov8" title="1">{
        ws := map[string]v1beta1.WorkspaceBinding{}
        for _, v := range w </span><span class="cov8" title="1">{

                r := strings.Split(v, ",")
                name, err := getPar(r, nameParam)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, errors.New("Name not found for workspace")
                }</span>

                <span class="cov8" title="1">wB := v1beta1.WorkspaceBinding{
                        Name: name,
                }
                nWB := 0
                subPath, err := getPar(r, subPathParam)
                if err == nil </span><span class="cov8" title="1">{
                        wB.SubPath = subPath
                }</span> else<span class="cov8" title="1"> if err != errNotFoundParam </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if vctFile, err := getPar(r, volumeClaimTemplateFile); err == nil </span><span class="cov8" title="1">{
                        err = setWorkspaceVCTemplate(&amp;wB, vctFile, httpClient)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">ws[name] = wB
                        continue</span>
                }

                <span class="cov8" title="1">if csiFile, err := getPar(r, csiFile); err == nil </span><span class="cov8" title="1">{
                        err = setWorkspaceCSITemplate(&amp;wB, csiFile, httpClient)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">ws[name] = wB
                        continue</span>
                }

                <span class="cov8" title="1">err = setWorkspaceConfig(r, &amp;wB)
                if err == nil </span><span class="cov8" title="1">{
                        ws[name] = wB
                        nWB++
                }</span> else<span class="cov8" title="1"> if err != errNotFoundParam </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">err = setWorkspaceSecret(r, &amp;wB)
                if err == nil </span><span class="cov8" title="1">{
                        ws[name] = wB
                        nWB++
                }</span> else<span class="cov8" title="1"> if err != errNotFoundParam </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if err = setWorkspaceEmptyDir(r, &amp;wB); err == nil </span><span class="cov8" title="1">{
                        ws[name] = wB
                        nWB++
                }</span>

                <span class="cov8" title="1">if err = setWorkspacePVC(r, &amp;wB); err == nil </span><span class="cov8" title="1">{
                        ws[name] = wB
                        nWB++
                }</span>

                <span class="cov8" title="1">if nWB != 1 </span><span class="cov8" title="1">{
                        return nil, errors.New(invalidWorkspace + v)
                }</span>

        }

        <span class="cov8" title="1">return ws, nil</span>
}

func setWorkspaceSecret(r []string, wB *v1beta1.WorkspaceBinding) error <span class="cov8" title="1">{
        secret, err := getPar(r, secretParam)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">items, err := getItems(r)
        if err != nil &amp;&amp; err != errNotFoundParam </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">wB.Secret = &amp;corev1.SecretVolumeSource{
                SecretName: secret,
                Items:      items,
        }
        return nil</span>
}

func setWorkspaceConfig(r []string, wB *v1beta1.WorkspaceBinding) error <span class="cov8" title="1">{
        config, err := getPar(r, configParam)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">items, err := getItems(r)
        if err != nil &amp;&amp; err != errNotFoundParam </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">wB.ConfigMap = &amp;corev1.ConfigMapVolumeSource{
                LocalObjectReference: corev1.LocalObjectReference{
                        Name: config},
                Items: items,
        }
        return nil</span>
}

func getItems(r []string) ([]corev1.KeyToPath, error) <span class="cov8" title="1">{
        var kp []corev1.KeyToPath
        for i := range r </span><span class="cov8" title="1">{
                if !strings.Contains(r[i], configItemParam) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">s := strings.SplitN(r[i], "=", 2)
                if s[0] != configItemParam </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(s) != 2 </span><span class="cov0" title="0">{
                        return nil, errors.New("invalid item")
                }</span>
                <span class="cov8" title="1">key, path, err := getKeyValue(s[1])
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">kp = append(kp, corev1.KeyToPath{
                        Key:  key,
                        Path: path,
                })</span>
        }
        <span class="cov8" title="1">return kp, nil</span>
}

func setWorkspacePVC(r []string, wB *v1beta1.WorkspaceBinding) error <span class="cov8" title="1">{
        claimName, err := getPar(r, claimNameParam)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">wB.PersistentVolumeClaim = &amp;corev1.PersistentVolumeClaimVolumeSource{
                ClaimName: claimName,
        }
        return nil</span>
}

func getKeyValue(s string) (string, string, error) <span class="cov8" title="1">{
        r := strings.SplitN(s, "=", 2)
        if len(r) != 2 </span><span class="cov8" title="1">{
                return "", "", errors.New("invalid key value")
        }</span>
        <span class="cov8" title="1">return r[0], r[1], nil</span>
}

func setWorkspaceEmptyDir(r []string, wB *v1beta1.WorkspaceBinding) error <span class="cov8" title="1">{
        emptyDir, err := getPar(r, emptyDirParam)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var sM corev1.StorageMedium
        switch emptyDir </span>{
        case "":<span class="cov8" title="1">
                sM = corev1.StorageMediumDefault</span>
        case "Memory":<span class="cov8" title="1">
                sM = corev1.StorageMediumMemory</span>
        case "HugePages":<span class="cov8" title="1">
                sM = corev1.StorageMediumHugePages</span>
        default:<span class="cov8" title="1">
                return errors.New(invalidWorkspace + emptyDirParam)</span>
        }

        <span class="cov8" title="1">wB.EmptyDir = &amp;corev1.EmptyDirVolumeSource{
                Medium: sM,
        }
        return nil</span>
}

func setWorkspaceVCTemplate(wB *v1beta1.WorkspaceBinding, vctFile string, httpClient http.Client) error <span class="cov8" title="1">{
        pvc, err := parseVolumeClaimTemplate(vctFile, httpClient)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">wB.VolumeClaimTemplate = pvc
        return nil</span>
}

func setWorkspaceCSITemplate(wB *v1beta1.WorkspaceBinding, vctFile string, httpClient http.Client) error <span class="cov8" title="1">{
        csi, err := parseCSITemplate(vctFile, httpClient)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">wB.CSI = csi
        return nil</span>
}

func parseVolumeClaimTemplate(filePath string, httpClient http.Client) (*corev1.PersistentVolumeClaim, error) <span class="cov8" title="1">{
        b, err := file.LoadFileContent(httpClient, filePath, file.IsYamlFile(), fmt.Errorf("invalid file format for %s: .yaml or .yml file extension and format required", filePath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := map[string]interface{}{}
        err = yaml.UnmarshalStrict(b, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pvc := corev1.PersistentVolumeClaim{}
        if err := yaml.UnmarshalStrict(b, &amp;pvc); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;pvc, nil</span>
}

func parseCSITemplate(filePath string, httpClient http.Client) (*corev1.CSIVolumeSource, error) <span class="cov8" title="1">{
        b, err := file.LoadFileContent(httpClient, filePath, file.IsYamlFile(), fmt.Errorf("invalid file format for %s: .yaml or .yml file extension and format required", filePath))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := map[string]interface{}{}
        err = yaml.UnmarshalStrict(b, &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">csi := corev1.CSIVolumeSource{}
        if err := yaml.UnmarshalStrict(b, &amp;csi); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;csi, nil</span>
}

func getPar(r []string, par string) (string, error) <span class="cov8" title="1">{
        var p string
        for i := range r </span><span class="cov8" title="1">{
                if !strings.Contains(r[i], par) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">s := strings.SplitN(r[i], "=", 2)
                if s[0] != par </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if len(s) != 2 </span><span class="cov8" title="1">{
                        return p, errors.New(invalidWorkspace + r[i])
                }</span>
                <span class="cov8" title="1">p = s[1]
                return p, nil</span>
        }
        <span class="cov8" title="1">return p, errNotFoundParam</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
