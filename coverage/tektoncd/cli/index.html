<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coverage Report</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <style>
      :root {
  --sidebar-width: 280px;
  --topbar-height: 48px;
  --line-height: 20px;
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
}

[data-theme="dark"] {
  --bg: #1e1e1e;
  --bg-secondary: #252526;
  --bg-tertiary: #2d2d2d;
  --text: #d4d4d4;
  --text-muted: #808080;
  --border: #3c3c3c;
  --covered: rgba(35, 134, 54, 0.25);
  --covered-gutter: #238636;
  --uncovered: rgba(218, 54, 51, 0.25);
  --uncovered-gutter: #da3633;
  --highlight: #264f78;
  --highlight-match: #613214;
  --accent: #569cd6;
  --hover: #2a2d2e;
}

[data-theme="light"] {
  --bg: #ffffff;
  --bg-secondary: #f3f3f3;
  --bg-tertiary: #e8e8e8;
  --text: #24292f;
  --text-muted: #656d76;
  --border: #d0d7de;
  --covered: rgba(35, 134, 54, 0.15);
  --covered-gutter: #1a7f37;
  --uncovered: rgba(218, 54, 51, 0.15);
  --uncovered-gutter: #cf222e;
  --highlight: #ddf4ff;
  --highlight-match: #fff8c5;
  --accent: #0969da;
  --hover: #f6f8fa;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  font-size: 14px;
  background: var(--bg);
  color: var(--text);
}

#app {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  height: 100%;
}

/* Sidebar */
#sidebar {
  display: flex;
  flex-direction: column;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  overflow: hidden;
}

#sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
}

/* Logo link */
#logo-link {
  text-decoration: none;
  color: inherit;
  display: block;
}

#logo-link:hover #logo-container {
  opacity: 0.8;
}

#logo-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  transition: opacity 0.15s ease;
}

#logo-container .github-icon {
  flex-shrink: 0;
  color: var(--text-muted);
  transition: color 0.15s ease;
}

#logo-link:hover .github-icon {
  color: var(--accent);
}

#logo {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

#logo-text {
  flex: 1;
  min-width: 0;
}

#sidebar-header h1 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  line-height: 1.2;
}

#tagline {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  margin: 2px 0 0 0;
  line-height: 1.3;
}

#summary {
  font-size: 13px;
  color: var(--text-muted);
}

#summary .percent {
  font-weight: 600;
  color: var(--text);
}

#search-box {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
}

#search-input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 13px;
}

#search-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Sort controls */
#sort-controls {
  display: flex;
  gap: 0;
  margin: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}

.sort-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 6px 8px;
  background: var(--bg-secondary);
  color: var(--text);
  border: none;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.2s, color 0.2s;
}

.sort-btn:hover {
  background: var(--hover);
}

.sort-btn.active {
  background: var(--accent);
  color: #fff;
}

.sort-btn .icon {
  font-weight: 600;
}

.sort-btn .label {
  font-size: 11px;
}

/* Coverage badges for directories */
.coverage-badge {
  margin-left: auto;
  padding-left: 8px;
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  font-family: var(--font-mono);
}

#file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}

/* Sidebar footer */
#sidebar-footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  font-size: 12px;
  text-align: center;
}

#sidebar-footer a {
  color: var(--text-muted);
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

#sidebar-footer a:hover {
  color: var(--accent);
  text-decoration: underline;
}

#sidebar-footer .github-icon {
  flex-shrink: 0;
}

.tree-node {
  cursor: pointer;
  user-select: none;
}

.tree-item {
  display: flex;
  align-items: center;
  padding: 4px 16px;
  gap: 6px;
  white-space: nowrap;
}

.tree-item:hover {
  background: var(--hover);
}

.tree-item.selected {
  background: var(--highlight);
}

.tree-item .icon {
  width: 16px;
  text-align: center;
  font-size: 12px;
  color: var(--text-muted);
}

.tree-item .name {
  font-size: 13px;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.tree-children {
  display: none;
}

.tree-node.expanded > .tree-children {
  display: block;
}

.tree-children .tree-item {
  padding-left: calc(16px + var(--depth, 0) * 16px);
}

.tree-node.hidden {
  display: none;
}

/* Canvas */
#canvas {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--topbar-height);
  padding: 0 16px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  gap: 16px;
}

#file-path {
  font-size: 13px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#topbar-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

#in-file-search {
  display: flex;
  align-items: center;
  gap: 8px;
}

#content-search {
  width: 180px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 12px;
}

#content-search:focus {
  outline: none;
  border-color: var(--accent);
}

#match-info {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
}

#prev-match, #next-match {
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 10px;
}

#prev-match:hover, #next-match:hover {
  background: var(--hover);
}

#theme-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 16px;
}

#theme-toggle:hover {
  background: var(--hover);
}

#syntax-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-family: var(--font-mono);
}

#syntax-toggle:hover {
  background: var(--hover);
}

#syntax-toggle.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

#help-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
}

#help-toggle:hover {
  background: var(--hover);
}

/* Override highlight.js to use theme-aware colors */
.hljs { background: transparent !important; }

[data-theme="dark"] .hljs-keyword { color: #569cd6; }
[data-theme="dark"] .hljs-type { color: #4ec9b0; }
[data-theme="dark"] .hljs-string { color: #ce9178; }
[data-theme="dark"] .hljs-number { color: #b5cea8; }
[data-theme="dark"] .hljs-comment { color: #6a9955; }
[data-theme="dark"] .hljs-built_in { color: #dcdcaa; }
[data-theme="dark"] .hljs-literal { color: #569cd6; }
[data-theme="dark"] .hljs-function { color: #dcdcaa; }

[data-theme="light"] .hljs-keyword { color: #0000ff; }
[data-theme="light"] .hljs-type { color: #267f99; }
[data-theme="light"] .hljs-string { color: #a31515; }
[data-theme="light"] .hljs-number { color: #098658; }
[data-theme="light"] .hljs-comment { color: #008000; }
[data-theme="light"] .hljs-built_in { color: #795e26; }
[data-theme="light"] .hljs-literal { color: #0000ff; }
[data-theme="light"] .hljs-function { color: #795e26; }

/* Viewport */
#viewport {
  flex: 1;
  overflow: auto;
  background: var(--bg);
  outline: none;
}

#viewport::-webkit-scrollbar {
  width: 14px;
  height: 14px;
}

#viewport::-webkit-scrollbar-track {
  background: var(--bg);
}

#viewport::-webkit-scrollbar-thumb {
  background: var(--border);
  border: 3px solid var(--bg);
  border-radius: 7px;
}

#viewport::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

.code-container {
  display: table;
  min-width: 100%;
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: var(--line-height);
}

.code-line {
  display: table-row;
}

.code-line:hover {
  background: var(--hover);
}

.code-line.covered {
  background: var(--covered);
}

.code-line.uncovered {
  background: var(--uncovered);
}

.code-line.covered:hover {
  background: var(--covered);
}

.code-line.uncovered:hover {
  background: var(--uncovered);
}

.gutter {
  display: table-cell;
  width: 4px;
  min-width: 4px;
}

.code-line.covered .gutter {
  background: var(--covered-gutter);
}

.code-line.uncovered .gutter {
  background: var(--uncovered-gutter);
}

.line-number {
  display: table-cell;
  width: 50px;
  min-width: 50px;
  padding: 0 12px 0 8px;
  text-align: right;
  color: var(--text-muted);
  user-select: none;
  vertical-align: top;
}

.line-content {
  display: table-cell;
  padding-right: 16px;
  white-space: pre;
  tab-size: 4;
}

.match-highlight {
  background: var(--highlight-match);
  border-radius: 2px;
}

.current-match {
  background: var(--accent);
  color: #fff;
}

/* Empty state */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-muted);
  gap: 8px;
}

.empty-state .icon {
  font-size: 48px;
  opacity: 0.5;
}

/* Scrollbar for file tree */
#file-tree::-webkit-scrollbar {
  width: 8px;
}

#file-tree::-webkit-scrollbar-track {
  background: transparent;
}

#file-tree::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

#file-tree::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Help modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  max-width: 400px;
  width: 90%;
}

.modal-content h2 {
  margin-bottom: 16px;
  font-size: 18px;
}

.modal-content dl {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px 16px;
}

.modal-content dt {
  font-family: var(--font-mono);
  background: var(--bg-tertiary);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
}

.modal-content dd {
  color: var(--text-muted);
}

.modal-content button {
  margin-top: 20px;
  padding: 8px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  width: 100%;
}

/* Selected line range (multi-line selection) */
.code-line.selected-line {
  background-color: var(--highlight);
}

.code-line.selected-line.covered {
  background-color: var(--highlight);
}

.code-line.selected-line.uncovered {
  background-color: var(--highlight);
}

/* Line number click indicator */
.line-number {
  cursor: pointer;
}

.line-number:hover {
  color: var(--accent);
}

    </style>
  </head>
  <body data-theme="dark">
    <div id="app">
      <aside id="sidebar">
        <div id="sidebar-header">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            id="logo-link"
            target="_blank"
            rel="noopener"
          >
            <div id="logo-container">
              <svg id="logo" viewBox="0 0 32 32" width="32" height="32">
                <defs>
                  <linearGradient
                    id="logoGradient"
                    x1="0%"
                    y1="0%"
                    x2="100%"
                    y2="100%"
                  >
                    <stop
                      offset="0%"
                      style="stop-color: var(--accent); stop-opacity: 1"
                    />
                    <stop
                      offset="100%"
                      style="stop-color: var(--accent); stop-opacity: 0.7"
                    />
                  </linearGradient>
                </defs>
                
                <circle
                  cx="16"
                  cy="16"
                  r="14"
                  fill="none"
                  stroke="url(#logoGradient)"
                  stroke-width="2"
                  opacity="0.3"
                />
                
                <path
                  d="M 10 17 L 14 21 L 22 11"
                  fill="none"
                  stroke="var(--accent)"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                
                <circle
                  cx="24"
                  cy="10"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
                <circle
                  cx="26"
                  cy="12"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
              </svg>
              <div id="logo-text">
                <h1>GO Coverage</h1>
                <div id="tagline">A better HTML Go Coverage</div>
              </div>
            </div>
          </a>
          <div id="summary"></div>
        </div>
        <div id="search-box">
          <input type="text" id="search-input" placeholder="Search files..." />
        </div>
        <div id="sort-controls">
          <button
            class="sort-btn active"
            data-sort="name"
            title="Sort alphabetically"
          >
            <span class="icon">A→Z</span>
            <span class="label">Name</span>
          </button>
          <button
            class="sort-btn"
            data-sort="coverage"
            title="Sort by coverage percentage"
          >
            <span class="icon">%</span>
            <span class="label">Coverage</span>
          </button>
        </div>
        <div id="file-tree"></div>
        <footer id="sidebar-footer">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            target="_blank"
            rel="noopener"
          >
            <svg
              class="github-icon"
              viewBox="0 0 16 16"
              width="14"
              height="14"
              fill="currentColor"
            >
              <path
                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
              />
            </svg>
            chmouel/go-better-html-coverage
          </a>
        </footer>
      </aside>
      <main id="canvas">
        <header id="topbar">
          <div id="file-path"></div>
          <div id="topbar-actions">
            <div id="in-file-search">
              <input
                type="text"
                id="content-search"
                placeholder="Search in file..."
              />
              <span id="match-info"></span>
              <button id="prev-match" title="Previous match">&#9650;</button>
              <button id="next-match" title="Next match">&#9660;</button>
            </div>
            <button id="syntax-toggle" title="Toggle syntax highlighting">
              &lt;/&gt;
            </button>
            <button id="theme-toggle" title="Toggle theme">&#9788;</button>
            <button id="help-toggle" title="Keyboard shortcuts">?</button>
          </div>
        </header>
        <div id="viewport" tabindex="-1"></div>
      </main>
      <div id="help-modal" class="modal hidden">
        <div class="modal-content">
          <h2>Keyboard Shortcuts</h2>
          <dl>
            <dt>Ctrl+P</dt>
            <dd>Focus file search</dd>
            <dt>Ctrl+F</dt>
            <dd>Search in file</dd>
            <dt>Enter</dt>
            <dd>Next match</dd>
            <dt>Shift+Enter</dt>
            <dd>Previous match</dd>
            <dt>?</dt>
            <dd>Show this help</dd>
            <dt>Esc</dt>
            <dd>Close modal</dd>
          </dl>
          <h2>Permalinks</h2>
          <dl>
            <dt>Click line</dt>
            <dd>Select line, update URL</dd>
            <dt>Shift+Click</dt>
            <dd>Select line range</dd>
          </dl>
          <button id="close-help">Close</button>
        </div>
      </div>
    </div>
    <script>
      window.COVERAGE_DATA = {"files":[{"id":0,"path":"pkg/actions/create.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package actions","","import (","\t\"context\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","// Create is used to take a partial resource and an unstructured object and create it in the cluster using the dynamic client.","func Create(gr schema.GroupVersionResource, clients *cli.Clients, object *unstructured.Unstructured, ns string, op metav1.CreateOptions) (*unstructured.Unstructured, error) {","\tgvr, err := GetGroupVersionResource(gr, clients.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","\tobj, err := clients.Dynamic.Resource(*gvr).Namespace(ns).Create(context.Background(), object, op)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn obj, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":1,"path":"pkg/actions/delete.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package actions","","import (","\t\"context\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/client-go/discovery\"","\t\"k8s.io/client-go/dynamic\"",")","","// Delete is used to take a partial resource and the name of an object in the cluster and delete it using the dynamic client.","func Delete(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, objname, ns string, op metav1.DeleteOptions) error {","\tgvr, err := GetGroupVersionResource(gr, discovery)","\tif err != nil {","\t\treturn err","\t}","","\terr = dynamic.Resource(*gvr).Namespace(ns).Delete(context.Background(), objname, op)","\tif err != nil {","\t\treturn err","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0]},{"id":2,"path":"pkg/actions/get.go","lines":["// Copyright © 2019-2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package actions","","import (","\t\"context\"","\t\"io\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/cli-runtime/pkg/printers\"","\t\"k8s.io/client-go/discovery\"","\t\"k8s.io/client-go/dynamic\"",")","","// TODO: remove as all the function uses are moved to new func","// PrintObject is used to take a partial resource and the name of an object in the cluster, fetch it using the dynamic client, and print out the object.","func PrintObject(groupResource schema.GroupVersionResource, obj string, w io.Writer, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, p printers.ResourcePrinter, ns string) error {","\tres, err := Get(groupResource, dynamic, discovery, obj, ns, metav1.GetOptions{})","\tif err != nil {","\t\treturn err","\t}","","\treturn p.PrintObj(res, w)","}","","// PrintObject is used to take a partial resource and the name of an object in the cluster, fetch it using the dynamic client, and print out the object.","func PrintObjectV1(groupResource schema.GroupVersionResource, obj string, w io.Writer, client *cli.Clients, p printers.ResourcePrinter, ns string) error {","\tres, err := GetUnstructured(groupResource, client, obj, ns, metav1.GetOptions{})","\tif err != nil {","\t\treturn err","\t}","","\treturn p.PrintObj(res, w)","}","","// GetV1 is used to take a partial resource and the name of an object in the cluster and fetch it from the cluster using the dynamic client.","func GetV1(gr schema.GroupVersionResource, c *cli.Clients, objname, ns string, op metav1.GetOptions, obj interface{}) error {","\tunstructuredObj, err := GetUnstructured(gr, c, objname, ns, op)","\tif err != nil {","\t\treturn err","\t}","\treturn runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)","}","","func GetUnstructured(gr schema.GroupVersionResource, c *cli.Clients, objname, ns string, op metav1.GetOptions) (*unstructured.Unstructured, error) {","\tgvr, err := GetGroupVersionResource(gr, c.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tunstructuredObj, err := c.Dynamic.Resource(*gvr).Namespace(ns).Get(context.Background(), objname, op)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn unstructuredObj, nil","}","","// TODO: remove as all the function uses are moved to new func","// Get is used to take a partial resource and the name of an object in the cluster and fetch it from the cluster using the dynamic client.","func Get(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, objname, ns string, op metav1.GetOptions) (*unstructured.Unstructured, error) {","\tgvr, err := GetGroupVersionResource(gr, discovery)","\tif err != nil {","\t\treturn nil, err","\t}","","\tobj, err := dynamic.Resource(*gvr).Namespace(ns).Get(context.Background(), objname, op)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn obj, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0]},{"id":3,"path":"pkg/actions/gvr.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package actions","","import (","\t\"sync\"","","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/client-go/discovery\"","\t\"k8s.io/client-go/restmapper\"",")","","var (","\tdoOnce      sync.Once","\tapiGroupRes []*restmapper.APIGroupResources",")","","// GetGroupVersionResource takes a partial resource, and returns the full resource matching the partial resource, if there's only one match.","func GetGroupVersionResource(gr schema.GroupVersionResource, discovery discovery.DiscoveryInterface) (*schema.GroupVersionResource, error) {","\tvar err error","\tdoOnce.Do(func() {","\t\terr = InitializeAPIGroupRes(discovery)","\t})","\tif err != nil {","\t\treturn nil, err","\t}","","\trm := restmapper.NewDiscoveryRESTMapper(apiGroupRes)","\tgvr, err := rm.ResourceFor(gr)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn \u0026gvr, nil","}","","// InitializeAPIGroupRes initializes and populates the discovery client.","func InitializeAPIGroupRes(discovery discovery.DiscoveryInterface) error {","\tvar err error","\tapiGroupRes, err = restmapper.GetAPIGroupResources(discovery)","\tif err != nil {","\t\treturn err","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,0]},{"id":4,"path":"pkg/actions/list.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package actions","","import (","\t\"context\"","\t\"io\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/cli-runtime/pkg/printers\"","\t\"k8s.io/client-go/discovery\"","\t\"k8s.io/client-go/dynamic\"",")","","// PrintObjects takes a partial resource, fetches a list of that resource's objects in the cluster using the dynamic client, and prints out the objects.","func PrintObjects(groupResource schema.GroupVersionResource, w io.Writer, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, p printers.ResourcePrinter, ns string) error {","\tallres, err := list(groupResource, dynamic, discovery, ns, metav1.ListOptions{})","\tif err != nil {","\t\treturn err","\t}","","\treturn p.PrintObj(allres, w)","}","","// List fetches the resource and convert it to respective object","func ListV1(gr schema.GroupVersionResource, c *cli.Clients, opts metav1.ListOptions, ns string, obj interface{}) error {","\tunstructuredObj, err := list(gr, c.Dynamic, c.Tekton.Discovery(), ns, opts)","\tif err != nil {","\t\treturn err","\t}","","\treturn runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)","}","","// list takes a partial resource and fetches a list of that resource's objects in the cluster using the dynamic client.","func list(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, ns string, op metav1.ListOptions) (*unstructured.UnstructuredList, error) {","\tgvr, err := GetGroupVersionResource(gr, discovery)","\tif err != nil {","\t\treturn nil, err","\t}","","\tallRes, err := dynamic.Resource(*gvr).Namespace(ns).List(context.Background(), op)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn allRes, nil","}","","// TODO: remove as all the function uses are moved to new func","// List takes a partial resource and fetches a list of that resource's objects in the cluster using the dynamic client.","func List(gr schema.GroupVersionResource, dynamic dynamic.Interface, discovery discovery.DiscoveryInterface, ns string, op metav1.ListOptions) (*unstructured.UnstructuredList, error) {","\tgvr, err := GetGroupVersionResource(gr, discovery)","\tif err != nil {","\t\treturn nil, err","\t}","","\tallRes, err := dynamic.Resource(*gvr).Namespace(ns).List(context.Background(), op)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn allRes, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0]},{"id":5,"path":"pkg/actions/patch.go","lines":["// Copyright © 2019-2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package actions","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"",")","","// Patch takes a partial resource, an object name in the cluster, and patch data to be applied to that object, and patches the object using the dynamic client.","func Patch(gr schema.GroupVersionResource, clients *cli.Clients, objName string, data []byte, opt metav1.PatchOptions, ns string, obj interface{}) error {","\tgvr, err := GetGroupVersionResource(gr, clients.Tekton.Discovery())","\tif err != nil {","\t\treturn err","\t}","\tunstructuredObj, err := clients.Dynamic.Resource(*gvr).Namespace(ns).Patch(context.Background(), objName, types.JSONPatchType, data, opt)","\tif err != nil {","\t\tfmt.Fprintf(os.Stderr, \"Failed to patch object from %s namespace \\n\", ns)","\t\treturn err","\t}","","\treturn runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredObj.UnstructuredContent(), obj)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":6,"path":"pkg/actions/watch.go","lines":["// Copyright © 2019-2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package actions","","import (","\t\"context\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/watch\"",")","","// Watch takes a partial resource, and returns a watcher interface for that resource using the dynamic client","func Watch(gr schema.GroupVersionResource, clients *cli.Clients, ns string, op metav1.ListOptions) (watch.Interface, error) {","\tgvr, err := GetGroupVersionResource(gr, clients.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\twatch, err := clients.Dynamic.Resource(*gvr).Namespace(ns).Watch(context.Background(), op)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn watch, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0]},{"id":7,"path":"pkg/bundle/builder.go","lines":["package bundle","","import (","\t\"archive/tar\"","\t\"bytes\"","\t\"crypto/sha256\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"sort\"","\t\"strings\"","\t\"time\"","","\tv1 \"github.com/google/go-containerregistry/pkg/v1\"","\t\"github.com/google/go-containerregistry/pkg/v1/empty\"","\t\"github.com/google/go-containerregistry/pkg/v1/mutate\"","\t\"github.com/google/go-containerregistry/pkg/v1/tarball\"","\ttkremote \"github.com/tektoncd/pipeline/pkg/remote/oci\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","// BuildTektonBundle will return a complete OCI Image usable as a Tekton Bundle built by parsing, decoding, and","// compressing the provided contents as Tekton objects.","func BuildTektonBundle(contents []string, annotations, labels map[string]string, ctime time.Time, log io.Writer) (v1.Image, error) {","\timg := mutate.Annotations(empty.Image, annotations).(v1.Image)","\timg, err := mutate.Config(img, v1.Config{","\t\tLabels: labels,","\t})","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"setting labels: %w\", err)","\t}","","\tif len(contents) \u003e tkremote.MaximumBundleObjects {","\t\treturn nil, fmt.Errorf(\"bundle contains more than the maximum %d allow objects\", tkremote.MaximumBundleObjects)","\t}","","\tfmt.Fprint(log, \"Creating Tekton Bundle:\\n\")","","\t// sort the contents based on the digest of the content, this keeps the layer","\t// order in the image manifest deterministic","\tsort.Slice(contents, func(i, j int) bool {","\t\tiDigest := sha256.Sum256([]byte(contents[i]))","\t\tjDigest := sha256.Sum256([]byte(contents[j]))","","\t\treturn bytes.Compare(iDigest[:], jDigest[:]) \u003c 0","\t})","","\t// For each block of input, attempt to parse all of the YAML/JSON objects as Tekton objects and compress them into","\t// the OCI image as a tar layer.","\tfor _, content := range contents {","\t\tif err := decodeObjects(content, func(gvr *schema.GroupVersionKind, element runtime.Object, raw []byte) error {","\t\t\tname, err := getObjectName(element)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\t// Tar up this object before writing it to the layer.","\t\t\tvar tarbundle bytes.Buffer","\t\t\twriter := tar.NewWriter(\u0026tarbundle)","\t\t\tif err := writer.WriteHeader(\u0026tar.Header{","\t\t\t\tName:     name,","\t\t\t\tMode:     0600,","\t\t\t\tSize:     int64(len(raw)),","\t\t\t\tTypeflag: tar.TypeReg,","\t\t\t}); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tif _, err := writer.Write(raw); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tif err := writer.Close(); err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\t// nolint: staticcheck","\t\t\tl, err := tarball.LayerFromReader(\u0026tarbundle)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\t// Add this layer to the image with all of the required annotations.","\t\t\timg, err = mutate.Append(img, mutate.Addendum{","\t\t\t\tLayer: l,","\t\t\t\tAnnotations: map[string]string{","\t\t\t\t\ttkremote.APIVersionAnnotation: gvr.Version,","\t\t\t\t\ttkremote.KindAnnotation:       strings.ToLower(gvr.Kind),","\t\t\t\t\ttkremote.TitleAnnotation:      name,","\t\t\t\t},","\t\t\t})","\t\t\tif err != nil {","\t\t\t\treturn fmt.Errorf(\"failed to add %q to Tekton Bundle: %w\", string(raw), err)","\t\t\t}","","\t\t\tfmt.Fprintf(log, \"\\t- Added %s: %s to image\\n\", gvr.Kind, name)","","\t\t\treturn nil","\t\t}); err != nil {","\t\t\treturn nil, err","\t\t}","\t}","","\t// Set created time for bundle image","\timg, err = mutate.CreatedAt(img, v1.Time{Time: ctime})","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to add created time to image: %w\", err)","\t}","","\treturn img, nil","}","","// Return the ObjectMetadata.Name field which every resource should have.","func getObjectName(obj runtime.Object) (string, error) {","\tmetaObj, ok := obj.(metav1.Object)","\tif !ok {","\t\treturn \"\", errors.New(\"object is not a registered kubernetes resource\")","\t}","\tname := metaObj.GetName()","\tif name == \"\" {","\t\treturn \"\", errors.New(\"kubernetes resources should have a name\")","\t}","\treturn name, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,1,1,2,1,1,2,1,1,0,0,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,0,0,0,2,2,1,1,0,2,0,0,0,2,2,2,1,1,2,2,2,2,2,0]},{"id":8,"path":"pkg/bundle/flags.go","lines":["package bundle","","import (","\t\"net/http\"","","\t\"github.com/google/go-containerregistry/pkg/authn\"","\tremoteimg \"github.com/google/go-containerregistry/pkg/v1/remote\"","\t\"github.com/spf13/pflag\"",")","","// RemoteOptions is a set of flags that are used configure the connection options to a registry.","type RemoteOptions struct {","\tbearerToken   string","\tbasicUsername string","\tbasicPassword string","","\tskipTLS bool","}","","// ToOptions outputs a list of `remoteimg.Option`s that can be passed into various fetch/write calls to a remote","// registry.","func (r *RemoteOptions) ToOptions() []remoteimg.Option {","\tvar opts []remoteimg.Option","","\t// Set the auth chain based on the flags.","\tif r.bearerToken != \"\" {","\t\topts = append(opts, remoteimg.WithAuth(\u0026authn.Bearer{Token: r.bearerToken}))","\t}","\tif r.basicUsername != \"\" \u0026\u0026 r.basicPassword != \"\" {","\t\topts = append(opts, remoteimg.WithAuth(\u0026authn.Basic{","\t\t\tUsername: r.basicUsername,","\t\t\tPassword: r.basicPassword,","\t\t}))","\t}","","\t// Use local keychain if no auth is provided. It's not allowed to use both.","\tif len(opts) == 0 {","\t\tkeychains := authn.NewMultiKeychain(authn.DefaultKeychain, PodmanKeyChain)","\t\topts = []remoteimg.Option{remoteimg.WithAuthFromKeychain(keychains)}","\t}","","\ttransport := http.DefaultTransport.(*http.Transport)","\tif r.skipTLS {","\t\ttransport.TLSClientConfig.InsecureSkipVerify = r.skipTLS","\t}","\t// TODO: consider adding CA overrides for self-signed or private registries.","\topts = append(opts, remoteimg.WithTransport(transport))","\treturn opts","}","","// AddRemoteFlags will define a common set of flags that can be used to change how images are pushed/fetched from remote","// image repositories.","func AddRemoteFlags(flags *pflag.FlagSet, opts *RemoteOptions) {","\tflags.StringVar(\u0026opts.bearerToken, \"remote-bearer\", \"\", \"A Bearer token to authenticate against the repository\")","\tflags.StringVar(\u0026opts.basicUsername, \"remote-username\", \"\", \"A username to pass to the registry for basic auth. Must be used with --remote-password\")","\tflags.StringVar(\u0026opts.basicPassword, \"remote-password\", \"\", \"A password to pass to the registry for basic auth. Must be used with --remote-username\")","","\t// TLS related flags.","\tflags.BoolVar(\u0026opts.skipTLS, \"remote-skip-tls\", false, \"If set to true, skips TLS check when connecting to the registry\")","}","","// PullOptions configure how an image is cached once it is fetched from the remote.","type CacheOptions struct {","\tcacheDir string","\tnoCache  bool","}","","// AddCacheFlags will define a set of flags to control how Tekton Bundle caching is done.","func AddCacheFlags(flags *pflag.FlagSet, opts *CacheOptions) {","\tflags.StringVar(\u0026opts.cacheDir, \"cache-dir\", \"~/.tekton/bundles\", \"A directory to cache Tekton bundles in.\")","\tflags.BoolVar(\u0026opts.noCache, \"no-cache\", false, \"If set to true, pulls a Tekton bundle from the remote even its exact digest is available in the cache.\")","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1]},{"id":9,"path":"pkg/bundle/keychain.go","lines":["package bundle","","import (","\t\"errors\"","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","\t\"runtime\"","\t\"sync\"","","\t\"github.com/docker/cli/cli/config\"","\t\"github.com/docker/cli/cli/config/types\"","\t\"github.com/docker/docker/pkg/homedir\"","\t\"github.com/google/go-containerregistry/pkg/authn\"",")","","type podmanKeychain struct {","\tmu sync.Mutex","}","","var PodmanKeyChain authn.Keychain = \u0026podmanKeychain{}","","func (pk *podmanKeychain) Resolve(target authn.Resource) (authn.Authenticator, error) {","\tpk.mu.Lock()","\tdefer pk.mu.Unlock()","","\tauthFile, err := os.Open(getPathToPodmanAuth())","\t// Return error only when the auth file is there but somehow unable to read.","\tif err != nil {","\t\tif errors.Is(err, os.ErrNotExist) {","\t\t\treturn authn.Anonymous, nil","\t\t}","\t\treturn nil, err","\t}","\tdefer authFile.Close()","","\tcf, err := config.LoadFromReader(authFile)","\tif err != nil {","\t\treturn nil, err","\t}","","\tkey := target.RegistryStr()","\tcfg, err := cf.GetAuthConfig(key)","\tif err != nil {","\t\treturn nil, err","\t}","","\tempty := types.AuthConfig{}","\tif cfg == empty {","\t\treturn authn.Anonymous, nil","\t}","\treturn authn.FromConfig(authn.AuthConfig{","\t\tUsername:      cfg.Username,","\t\tPassword:      cfg.Password,","\t\tAuth:          cfg.Auth,","\t\tIdentityToken: cfg.IdentityToken,","\t\tRegistryToken: cfg.RegistryToken,","\t}), nil","}","","func getPathToPodmanAuth() string {","\tvar (","\t\tdefaultPerUIDPathFormat = filepath.FromSlash(\"/run/containers/%d/auth.json\")","\t\txdgRuntimeDirPath       = filepath.FromSlash(\"containers/auth.json\")","\t\tnonLinuxAuthFilePath    = filepath.FromSlash(\".config/containers/auth.json\")","\t)","","\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"darwin\" {","\t\treturn filepath.Join(homedir.Get(), nonLinuxAuthFilePath)","\t}","","\truntimeDir := os.Getenv(\"XDG_RUNTIME_DIR\")","\tif runtimeDir != \"\" {","\t\treturn filepath.Join(runtimeDir, xdgRuntimeDirPath)","\t}","\treturn fmt.Sprintf(defaultPerUIDPathFormat, os.Getuid())","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,0,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,0]},{"id":10,"path":"pkg/bundle/parser.go","lines":["package bundle","","import (","\t\"bytes\"","\t\"fmt\"","\t\"io\"","\t\"strings\"","","\t\"github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/runtime/serializer\"","\t\"k8s.io/apimachinery/pkg/util/yaml\"",")","","// decodedElementHandler is a function type that processes a single decoded resource from #decodeObjects. Errors are","// returned as is. Each invocation is given the GVR of the element, the parsed struct, and the raw JSON bytes.","type decodedElementHandler func(gvr *schema.GroupVersionKind, element runtime.Object, raw []byte) error","","func decodeObjects(contents string, handler decodedElementHandler) error {","\tyamlDecoder := yaml.NewYAMLOrJSONDecoder(strings.NewReader(contents), 4096)","\ttektonDecoder := serializer.NewCodecFactory(scheme.Scheme).UniversalDeserializer()","","\t// Scratch object to decode raw manifest into.","\tspec := runtime.RawExtension{}","\tfor {","\t\t// Note that the code below mostly mirrors","\t\t// https://github.com/kubernetes/cli-runtime/blob/b4586cbefd3668543b8b2b56845419e39ad1792f/pkg/resource/visitor.go#L572","\t\tif err := yamlDecoder.Decode(\u0026spec); err != nil {","\t\t\tif err == io.EOF {","\t\t\t\tbreak","\t\t\t}","\t\t\treturn fmt.Errorf(\"found a spec that isn't YAML or JSON parseable: %q\", contents)","\t\t}","","\t\tspec.Raw = bytes.TrimSpace(spec.Raw)","\t\tif len(spec.Raw) == 0 || bytes.Equal(spec.Raw, []byte(\"null\")) {","\t\t\tcontinue","\t\t}","","\t\tspecInJSON := string(spec.Raw)","\t\tobj, gvr, err := tektonDecoder.Decode(spec.Raw, nil, nil)","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"failed to parse string as a Tekton object: %q\", specInJSON)","\t\t}","","\t\tif gvr == nil {","\t\t\treturn fmt.Errorf(\"failed to parse raw tekton object with no kind or apiVersion: %s\", specInJSON)","\t\t}","","\t\tif err = handler(gvr, obj, spec.Raw); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,1,0,0,2,2,1,0,0,2,2,2,2,2,0,2,1,1,0,2,2,2,0,2,0]},{"id":11,"path":"pkg/bundle/reader.go","lines":["package bundle","","import (","\t\"archive/tar\"","\t\"fmt\"","\t\"io\"","","\tv1 \"github.com/google/go-containerregistry/pkg/v1\"","\t\"github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme\"","\ttkremote \"github.com/tektoncd/pipeline/pkg/remote/oci\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","// ObjectVisitor is an input function that callers of this file's methods can implement to act on the read contents of a","// Tekton bundle. The `version`, `kind`, and `name` fields map 1:1 with the same named fields in the Tekton Bundle spec.","type ObjectVisitor func(version, kind, name string, element runtime.Object, raw []byte)","","// List will call visitor for every single layer in the img.","func List(img v1.Image, visitor ObjectVisitor) error {","\tmanifest, err := img.Manifest()","\tif err != nil {","\t\treturn err","\t}","","\tlayers, err := img.Layers()","\tif err != nil {","\t\treturn err","\t}","","\tlayerMap := map[string]v1.Layer{}","\tfor _, l := range layers {","\t\tdigest, err := l.Digest()","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tlayerMap[digest.String()] = l","\t}","","\tfor _, l := range manifest.Layers {","\t\trawLayer, ok := layerMap[l.Digest.String()]","\t\tif !ok {","\t\t\treturn fmt.Errorf(\"no image layer with digest %s exists in the bundle\", l.Digest.String())","\t\t}","","\t\tcontents, err := readTarLayer(rawLayer)","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"failed to read layer %s: %w\", l.Digest, err)","\t\t}","","\t\tobj, _, err := scheme.Codecs.UniversalDeserializer().Decode(contents, nil, nil)","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"failed to decode layer %s to a Tekton object: %w\", l.Digest, err)","\t\t}","\t\tvisitor(","\t\t\tl.Annotations[tkremote.APIVersionAnnotation],","\t\t\tl.Annotations[tkremote.KindAnnotation],","\t\t\tl.Annotations[tkremote.TitleAnnotation],","\t\t\tobj,","\t\t\tcontents,","\t\t)","\t}","","\treturn nil","}","","// ListKind is like #List but only returns elements of a single kind. Kind will be lowercased to conform to the Tekton","// Bundle spec.","func ListKind(img v1.Image, pkind string, visitor ObjectVisitor) error {","\tlistedItems := 0","\tif err := List(img, func(version, kind string, name string, element runtime.Object, raw []byte) {","\t\tif kind == pkind {","\t\t\tlistedItems++","\t\t\tvisitor(version, kind, name, element, raw)","\t\t}","\t}); err != nil {","\t\treturn err","\t}","","\tif listedItems == 0 {","\t\treturn fmt.Errorf(\"no objects of kind %q found in img\", pkind)","\t}","\treturn nil","}","","// Get returns a single named element of a specific kind from the Tekton Bundle.","func Get(img v1.Image, pkind, name string, visitor ObjectVisitor) error {","\tobjectFound := false","\tif err := ListKind(img, pkind, func(version, kind, foundName string, element runtime.Object, raw []byte) {","\t\tif foundName == name {","\t\t\tobjectFound = true","\t\t\tvisitor(version, kind, foundName, element, raw)","\t\t}","\t}); err != nil {","\t\treturn err","\t}","","\tif !objectFound {","\t\treturn fmt.Errorf(\"no objects of kind %q named %q found in img\", pkind, name)","\t}","\treturn nil","}","","// readTarLayer is a helper function to read the contents of a tar'ed layer.","func readTarLayer(l v1.Layer) ([]byte, error) {","\trc, err := l.Uncompressed()","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"Failed to read image layer: %w\", err)","\t}","\tdefer rc.Close()","","\t// If the user bundled this up as a tar file then we need to untar it.","\ttreader := tar.NewReader(rc)","\theader, err := treader.Next()","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"layer is not a tarball\")","\t}","","\tcontents := make([]byte, header.Size)","\tif _, err := io.ReadFull(treader, contents); err != nil \u0026\u0026 err != io.EOF {","\t\t// We only allow 1 resource per layer so this tar bundle should have one and only one file.","\t\treturn nil, fmt.Errorf(\"failed to read tar bundle: %w\", err)","\t}","\treturn contents, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,1,1,0,2,2,2,2,1,1,2,0,0,2,2,2,1,1,0,2,2,1,1,0,2,2,1,1,2,2,2,2,2,2,2,0,0,2,0,0,0,0,2,2,2,2,2,2,2,1,1,1,0,2,1,1,2,0,0,0,2,2,2,2,2,2,2,1,1,1,0,2,1,1,2,0,0,0,2,2,2,1,1,2,2,2,2,2,2,1,1,0,2,2,1,1,1,2,0]},{"id":12,"path":"pkg/bundle/remote.go","lines":["package bundle","","import (","\t\"fmt\"","","\t\"github.com/google/go-containerregistry/pkg/name\"","\tv1 \"github.com/google/go-containerregistry/pkg/v1\"","\t\"github.com/google/go-containerregistry/pkg/v1/cache\"","\tremoteimg \"github.com/google/go-containerregistry/pkg/v1/remote\"","\thomedir \"github.com/mitchellh/go-homedir\"",")","","// Write will publish an OCI image to a remote registry using the provided options and reference.","func Write(img v1.Image, ref name.Reference, opts ...remoteimg.Option) (string, error) {","\tif err := remoteimg.Write(ref, img, opts...); err != nil {","\t\treturn \"\", fmt.Errorf(\"could not push image to registry as %q: %w\", ref.String(), err)","\t}","","\tdigest, err := img.Digest()","\tif err != nil {","\t\treturn \"\", fmt.Errorf(\"could not read image digest: %w\", err)","\t}","","\treturn ref.Context().Digest(digest.String()).String(), nil","}","","// Read looks up an image from a remote registry and fetches layers from a local cache if we have seen it before.","func Read(ref name.Reference, cacheOptions *CacheOptions, opts ...remoteimg.Option) (v1.Image, error) {","\timg, err := remoteimg.Image(ref, opts...)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to fetch image: %w\", err)","\t}","","\tif cacheOptions.noCache {","\t\treturn img, nil","\t}","","\t// Construct a new cache and wrap this image in that.","\tdir, err := homedir.Expand(cacheOptions.cacheDir)","\tif err != nil {","\t\treturn nil, err","\t}","\tfsCache := cache.NewFilesystemCache(dir)","\treturn cache.Image(img, fsCache), nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,0,2,2,1,1,0,2,0,0,0,2,2,2,1,1,0,2,1,1,0,0,2,2,1,1,2,2,0]},{"id":13,"path":"pkg/chain/chain.go","lines":["// Copyright © 2022 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package chain","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","","\t\"go.uber.org/zap/zapcore\"","","\t\"github.com/tektoncd/chains/pkg/chains/storage\"","\t\"github.com/tektoncd/chains/pkg/config\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"go.uber.org/zap\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","// ConfigMapToContext returns a context initialized with the Chains ConfigMap.","func ConfigMapToContext(cs *cli.Clients, namespace string) (context.Context, error) {","\tcfg, err := getChainsConfig(cs, namespace)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn config.ToContext(context.Background(), cfg), nil","}","","func GetTaskRunBackends(cs *cli.Clients, namespace string, tr *v1.TaskRun) (map[string]storage.Backend, config.StorageOpts, error) {","\t// Prepare the logger.","\tencoderCfg := zapcore.EncoderConfig{","\t\tMessageKey: \"msg\",","\t}","\tcore := zapcore.NewCore(zapcore.NewConsoleEncoder(encoderCfg), os.Stderr, zapcore.DebugLevel)","\tlogger := zap.New(core).WithOptions()","","\t// flushes buffer, if any","\tdefer func() {","\t\t// intentionally ignoring error here, see https://github.com/uber-go/zap/issues/328","\t\t_ = logger.Sync()","\t}()","","\t// Get the storage backend.","\tbackends, err := initializeBackends(cs, namespace)","\tif err != nil {","\t\treturn nil, config.StorageOpts{}, fmt.Errorf(\"failed to retrieve the backend storage: %v\", err)","\t}","","\t// Initialize the storage options.","\topts := config.StorageOpts{","\t\tShortKey: fmt.Sprintf(\"taskrun-%s\", tr.UID),","\t}","","\treturn backends, opts, nil","}","","func initializeBackends(cs *cli.Clients, namespace string) (map[string]storage.Backend, error) {","\t// Retrieve the Chains configuration.","\tcfg, err := getChainsConfig(cs, namespace)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Initialize the backend.","\tbackends, err := storage.InitializeBackends(context.Background(), cs.Tekton, cs.Kube, *cfg)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"error initializing backends: %s\", err)","\t}","","\t// Return the configured backend.","\treturn backends, nil","}","","// getChainsConfig returns the chains config configmap","func getChainsConfig(cs *cli.Clients, namespace string) (*config.Config, error) {","\tchainsConfig, err := cs.Kube.CoreV1().ConfigMaps(namespace).Get(context.Background(), \"chains-config\", metav1.GetOptions{})","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"error retrieving tekton chains configmap: %s\", err)","\t}","\tcfg, err := config.NewConfigFromConfigMap(chainsConfig)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"error creating tekton chains configuration: %s\", err)","\t}","\treturn cfg, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":14,"path":"pkg/cli/params.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package cli","","import (","\t\"github.com/fatih/color\"","\t\"github.com/jonboulle/clockwork\"","\t\"github.com/pkg/errors\"","\t\"github.com/tektoncd/pipeline/pkg/client/clientset/versioned\"","\tversionedTriggers \"github.com/tektoncd/triggers/pkg/client/clientset/versioned\"","\t\"k8s.io/client-go/dynamic\"","\tk8s \"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/rest\"","\t\"k8s.io/client-go/tools/clientcmd\"",")","","type TektonParams struct {","\tclients        *Clients","\tkubeConfigPath string","\tkubeContext    string","\tnamespace      string","}","","// ensure that TektonParams complies with cli.Params interface","var _ Params = (*TektonParams)(nil)","","func (p *TektonParams) SetKubeConfigPath(path string) {","\tp.kubeConfigPath = path","}","","func (p *TektonParams) SetKubeContext(context string) {","\tp.kubeContext = context","}","","func (p *TektonParams) tektonClient(config *rest.Config) (versioned.Interface, error) {","\tcs, err := versioned.NewForConfig(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn cs, nil","}","","func (p *TektonParams) triggersClient(config *rest.Config) (versionedTriggers.Interface, error) {","\tcs, err := versionedTriggers.NewForConfig(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn cs, nil","}","","// Set kube client based on config","func (p *TektonParams) kubeClient(config *rest.Config) (k8s.Interface, error) {","\tk8scs, err := k8s.NewForConfig(config)","\tif err != nil {","\t\treturn nil, errors.Wrapf(err, \"failed to create k8s client from config\")","\t}","","\treturn k8scs, nil","}","","func (p *TektonParams) dynamicClient(config *rest.Config) (dynamic.Interface, error) {","\tdynamicClient, err := dynamic.NewForConfig(config)","\tif err != nil {","\t\treturn nil, errors.Wrapf(err, \"failed to create dynamic client from config\")","","\t}","\treturn dynamicClient, err","}","","// Only returns kube client, not tekton client","func (p *TektonParams) KubeClient() (k8s.Interface, error) {","\tconfig, err := p.config()","\tif err != nil {","\t\treturn nil, err","\t}","","\tkube, err := p.kubeClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn kube, nil","}","","func (p *TektonParams) Clients(cfg ...*rest.Config) (*Clients, error) {","\tif p.clients != nil {","\t\treturn p.clients, nil","\t}","\tvar config *rest.Config","","\tif len(cfg) != 0 \u0026\u0026 cfg[0] != nil {","\t\tconfig = cfg[0]","\t} else {","\t\tdefaultConfig, err := p.config()","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tconfig = defaultConfig","\t}","","\ttekton, err := p.tektonClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\ttriggers, err := p.triggersClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\tkube, err := p.kubeClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\tdynamic, err := p.dynamicClient(config)","\tif err != nil {","\t\treturn nil, err","\t}","","\tp.clients = \u0026Clients{","\t\tTekton:   tekton,","\t\tKube:     kube,","\t\tTriggers: triggers,","\t\tDynamic:  dynamic,","\t}","","\treturn p.clients, nil","}","","func (p *TektonParams) config() (*rest.Config, error) {","\tloadingRules := clientcmd.NewDefaultClientConfigLoadingRules()","\tif p.kubeConfigPath != \"\" {","\t\tloadingRules.ExplicitPath = p.kubeConfigPath","\t}","\tconfigOverrides := \u0026clientcmd.ConfigOverrides{}","\tif p.kubeContext != \"\" {","\t\tconfigOverrides.CurrentContext = p.kubeContext","\t}","\tkubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)","\tif p.namespace == \"\" {","\t\tnamespace, _, err := kubeConfig.Namespace()","\t\tif err != nil {","\t\t\treturn nil, errors.Wrap(err, \"Couldn't get kubeConfiguration namespace\")","\t\t}","\t\tp.namespace = namespace","\t}","\tconfig, err := kubeConfig.ClientConfig()","\tif err != nil {","\t\treturn nil, errors.Wrap(err, \"Parsing kubeconfig failed\")","\t}","","\t// set values as done in kubectl","\tconfig.QPS = 50.0","\tconfig.Burst = 300","","\treturn config, nil","}","","func (p *TektonParams) SetNoColour(b bool) {","\tcolor.NoColor = b","}","","func (p *TektonParams) SetNamespace(ns string) {","\tp.namespace = ns","}","","func (p *TektonParams) Namespace() string {","\treturn p.namespace","}","","func (p *TektonParams) Time() clockwork.Clock {","\treturn clockwork.NewRealClock()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1]},{"id":15,"path":"pkg/cli/prerun/prerun.go","lines":["package prerun","","import (","\t\"fmt\"","","\t\"github.com/spf13/cobra\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/flags\"",")","","func PersistentPreRunE(p cli.Params) func(*cobra.Command, []string) error {","\treturn func(cmd *cobra.Command, _ []string) error {","\t\tif err := WarnExperimental(cmd); err != nil {","\t\t\treturn err","\t\t}","\t\treturn flags.InitParams(p, cmd)","\t}","}","","func WarnExperimental(cmd *cobra.Command) error {","\tif IsExperimental(cmd) {","\t\tfmt.Fprintf(cmd.OutOrStderr(), \"*Warning*: This is an experimental command, its usage and behavior can change in the next release(s)\\n\")","\t}","\treturn nil","}","","func IsExperimental(cmd *cobra.Command) bool {","\tif _, ok := cmd.Annotations[\"experimental\"]; ok {","\t\treturn true","\t}","\tvar experimental bool","\tcmd.VisitParents(func(cmd *cobra.Command) {","\t\tif _, ok := cmd.Annotations[\"experimental\"]; ok {","\t\t\texperimental = true","\t\t}","\t})","\treturn experimental","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":16,"path":"pkg/clustertriggerbinding/clustertriggerbinding.go","lines":["// Copyright © 2021 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package clustertriggerbinding","","import (","\t\"fmt\"","\t\"os\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var clustertriggerbindingGroupResource = schema.GroupVersionResource{Group: \"triggers.tekton.dev\", Resource: \"clustertriggerbindings\"}","","func GetAllClusterTriggerBindingNames(client *cli.Clients) ([]string, error) {","\tps, err := List(client, metav1.ListOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tret := []string{}","\tfor _, item := range ps.Items {","\t\tret = append(ret, item.ObjectMeta.Name)","\t}","\treturn ret, nil","}","","func List(c *cli.Clients, opts metav1.ListOptions) (*v1beta1.ClusterTriggerBindingList, error) {","\tunstructuredCTB, err := actions.List(clustertriggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), \"\", opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar clustertriggerbindings *v1beta1.ClusterTriggerBindingList","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredCTB.UnstructuredContent(), \u0026clustertriggerbindings); err != nil {","\t\treturn nil, err","\t}","\tif err != nil {","\t\tfmt.Fprintf(os.Stderr, \"Failed to list clustertriggerbindings\\n\")","\t\treturn nil, err","\t}","","\treturn clustertriggerbindings, nil","}","","func Get(c *cli.Clients, ctbname string, opts metav1.GetOptions) (*v1beta1.ClusterTriggerBinding, error) {","\tunstructuredCTB, err := actions.Get(clustertriggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), ctbname, \"\", opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar ctb *v1beta1.ClusterTriggerBinding","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredCTB.UnstructuredContent(), \u0026ctb); err != nil {","\t\tfmt.Fprintf(os.Stderr, \"failed to get clustertriggerbinding\\n\")","\t\treturn nil, err","\t}","\treturn ctb, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,1,1,0,2,2,1,1,2,1,1,1,0,2,0,0,2,2,2,1,1,0,2,2,1,1,1,2,0]},{"id":17,"path":"pkg/customrun/sort/by_namespace.go","lines":["// Copyright © 2023 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//\thttp://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package customrun","","import (","\t\"sort\"","","\tv1beta1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"",")","","func SortByNamespace(crs []v1beta1.CustomRun) {","\tsort.Sort(byNamespace(crs))","}","","type byNamespace []v1beta1.CustomRun","","func (crs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) {","\tlt, eq = ins \u003c jns, ins == jns","\treturn lt, eq","}","","func (crs byNamespace) Len() int      { return len(crs) }","func (crs byNamespace) Swap(i, j int) { crs[i], crs[j] = crs[j], crs[i] }","func (crs byNamespace) Less(i, j int) bool {","\tvar lt, eq bool","\tif lt, eq = crs.compareNamespace(crs[i].Namespace, crs[j].Namespace); eq {","\t\tif crs[j].Status.StartTime == nil {","\t\t\treturn false","\t\t}","\t\tif crs[i].Status.StartTime == nil {","\t\t\treturn true","\t\t}","\t\treturn crs[j].Status.StartTime.Before(crs[i].Status.StartTime)","\t}","\treturn lt","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,0,2,2,2,2,2,2,1,1,2,1,1,2,0,2,0]},{"id":18,"path":"pkg/customrun/sort/by_start_time.go","lines":["// Copyright © 2023 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package customrun","","import (","\t\"sort\"","","\tv1beta1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"",")","","func SortByStartTime(crs []v1beta1.CustomRun) {","\tsort.Sort(byStartTime(crs))","}","","type byStartTime []v1beta1.CustomRun","","func (crs byStartTime) Len() int      { return len(crs) }","func (crs byStartTime) Swap(i, j int) { crs[i], crs[j] = crs[j], crs[i] }","func (crs byStartTime) Less(i, j int) bool {","\tif crs[j].Status.StartTime == nil {","\t\treturn false","\t}","\tif crs[i].Status.StartTime == nil {","\t\treturn true","\t}","\treturn crs[j].Status.StartTime.Before(crs[i].Status.StartTime)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,1,1,2,0]},{"id":19,"path":"pkg/deleter/deleter.go","lines":["package deleter","","import (","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/names\"","\t\"go.uber.org/multierr\"",")","","// Deleter encapsulates behaviour around deleting resources and their relations.","// While actually performing a deletion is left to calling code, this helper","// type standardizes the sequencing, messaging and error handling related to","// deletions.","type Deleter struct {","\terrors                   []error","\tsuccessfulDeletes        []string","\tsuccessfulRelatedDeletes []string","","\tkind        string","\trelatedKind string","","\tdelete func(string) error","","\tlistRelated   func(string) ([]string, error)","\tdeleteRelated func(string) error","}","","// New returns a Deleter that will delete resources of kind with the given","// delete func when Execute is called.","func New(kind string, deleteFunc func(string) error) *Deleter {","\treturn \u0026Deleter{","\t\tkind:   kind,","\t\tdelete: deleteFunc,","\t}","}","","// WithRelated tells this Deleter that it should also delete related resources","// when Execute is called. Related resources will be of given kind, the names of","// those resources must be provided by listFunc and each related resource will be","// passed to deleteFunc for deletion.","func (d *Deleter) WithRelated(kind string, listFunc func(string) ([]string, error), deleteFunc func(string) error) {","\td.relatedKind = kind","\td.listRelated = listFunc","\td.deleteRelated = deleteFunc","}","","// Delete performs the deletion of resources. Errors are printed to stderr of","// the passed in streams struct and are also aggregated for later access","// with d.Errors(). The names of successfully deleted resources are","// returned.","func (d *Deleter) Delete(resourceNames []string) []string {","\tfor _, name := range resourceNames {","\t\tif err := d.delete(name); err != nil {","\t\t\td.appendError(fmt.Errorf(\"failed to delete %s %q: %s\", d.kind, name, err))","\t\t} else {","\t\t\td.successfulDeletes = append(d.successfulDeletes, name)","\t\t}","\t}","\treturn d.successfulDeletes","}","","// DeleteRelated performs the deletion of resources related to d's kind. Errors are","// aggregated and can be accessed with d.Errors().","func (d *Deleter) DeleteRelated(resourceNames []string) {","\tif d.relatedKind != \"\" \u0026\u0026 d.listRelated != nil \u0026\u0026 d.deleteRelated != nil {","\t\tfor _, name := range resourceNames {","\t\t\td.deleteRelatedList(name)","\t\t}","\t}","}","","// deleteRelatedList gets the list of resources related to resourceName using the","// provided listFunc and then calls the deleteRelated func for each relation.","func (d *Deleter) deleteRelatedList(resourceName string) {","\tif related, err := d.listRelated(resourceName); err != nil {","\t\terr = fmt.Errorf(\"failed to list %ss: %s\", strings.ToLower(d.relatedKind), err)","\t\td.appendError(err)","\t} else {","\t\tif len(related) \u003e 0 {","\t\t\tfor _, subresource := range related {","\t\t\t\tif err := d.deleteRelated(subresource); err != nil {","\t\t\t\t\terr = fmt.Errorf(\"failed to delete %s %q: %s\", d.relatedKind, subresource, err)","\t\t\t\t\td.appendError(err)","\t\t\t\t} else {","\t\t\t\t\td.successfulRelatedDeletes = append(d.successfulRelatedDeletes, subresource)","\t\t\t\t}","\t\t\t}","\t\t} else {","\t\t\terr = fmt.Errorf(\"no %ss associated with %s %q\", d.relatedKind, d.kind, resourceName)","\t\t\td.appendError(err)","\t\t}","\t}","}","","// PrintSuccesses writes success messages to the provided stdout stream.","func (d *Deleter) PrintSuccesses(streams *cli.Stream) {","\tif len(d.successfulRelatedDeletes) \u003e 0 {","\t\tfmt.Fprintf(streams.Out, \"%ss deleted: %s\\n\", d.relatedKind, names.QuotedList(d.successfulRelatedDeletes))","\t}","\tif len(d.successfulDeletes) \u003e 0 {","\t\tfmt.Fprintf(streams.Out, \"%ss deleted: %s\\n\", d.kind, names.QuotedList(d.successfulDeletes))","\t}","}","","// appendError adds that error to the list of accumulated errors that","// have occurred during execution.","func (d *Deleter) appendError(err error) {","\td.errors = append(d.errors, err)","}","","// Errors returns any accumulated errors in the operation of this deleter.","func (d *Deleter) Errors() error {","\treturn multierr.Combine(d.errors...)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,0,0,0,0,0,2,2,2,1,2,2,2,0,2,0,0,0,0,2,2,2,2,2,0,0,0,0,0,2,2,1,1,2,2,2,2,1,1,2,2,2,0,1,1,1,1,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,1,1,1,0,0,2,2,2]},{"id":20,"path":"pkg/eventlistener/eventlistener.go","lines":["// Copyright © 2021 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package eventlistener","","import (","\t\"fmt\"","\t\"os\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var eventlistenerGroupResource = schema.GroupVersionResource{Group: \"triggers.tekton.dev\", Resource: \"eventlisteners\"}","","func GetAllEventListenerNames(client *cli.Clients, namespace string) ([]string, error) {","\tps, err := List(client, metav1.ListOptions{}, namespace)","\tif err != nil {","\t\treturn nil, err","\t}","","\tret := []string{}","\tfor _, item := range ps.Items {","\t\tret = append(ret, item.ObjectMeta.Name)","\t}","\treturn ret, nil","}","","func List(c *cli.Clients, opts metav1.ListOptions, ns string) (*v1beta1.EventListenerList, error) {","\tunstructuredEL, err := actions.List(eventlistenerGroupResource, c.Dynamic, c.Triggers.Discovery(), ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar eventlisteners *v1beta1.EventListenerList","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredEL.UnstructuredContent(), \u0026eventlisteners); err != nil {","\t\treturn nil, err","\t}","\tif err != nil {","\t\tfmt.Fprintf(os.Stderr, \"Failed to list eventlisteners from %s namespace \\n\", ns)","\t\treturn nil, err","\t}","","\treturn eventlisteners, nil","}","","func Get(c *cli.Clients, elName string, opts metav1.GetOptions, ns string) (*v1beta1.EventListener, error) {","\tunstructuredEl, err := actions.Get(eventlistenerGroupResource, c.Dynamic, c.Triggers.Discovery(), elName, ns, opts)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to get EventListener %s: %v\", elName, err)","\t}","","\tvar el *v1beta1.EventListener","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredEl.UnstructuredContent(), \u0026el); err != nil {","\t\tfmt.Fprintf(os.Stderr, \"failed to get eventlistener from %s namespace \\n\", ns)","\t\treturn nil, err","\t}","\treturn el, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,1,1,0,2,2,1,1,2,1,1,1,0,2,0,0,2,2,2,2,2,0,2,2,1,1,1,2,0]},{"id":21,"path":"pkg/export/export.go","lines":["// Copyright © 2022 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package export","","import (","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"",")","","func RemoveFieldForExport(obj *unstructured.Unstructured) error {","\tcontent := obj.UnstructuredContent()","","\t// remove the status from pipelinerun and taskrun","\tunstructured.RemoveNestedField(content, \"status\")","","\t// remove some metadata information of previous resource","\tmetadataFields := []string{","\t\t\"managedFields\",","\t\t\"resourceVersion\",","\t\t\"uid\",","\t\t\"finalizers\",","\t\t\"generation\",","\t\t\"namespace\",","\t\t\"creationTimestamp\",","\t\t\"ownerReferences\",","\t}","\tfor _, field := range metadataFields {","\t\tunstructured.RemoveNestedField(content, \"metadata\", field)","\t}","\tunstructured.RemoveNestedField(content, \"metadata\", \"annotations\", \"kubectl.kubernetes.io/last-applied-configuration\")","","\t// check if generateName exists and remove name if it does","\tif _, exist, err := unstructured.NestedString(content, \"metadata\", \"generateName\"); err != nil {","\t\treturn err","\t} else if exist {","\t\tunstructured.RemoveNestedField(content, \"metadata\", \"name\")","\t}","","\t// remove the status from spec which are related to status","\tspecFields := []string{\"status\", \"statusMessage\"}","\tfor _, field := range specFields {","\t\tunstructured.RemoveNestedField(content, \"spec\", field)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,0,0,2,2,2,2,0,2,0]},{"id":22,"path":"pkg/file/file.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package file","","import (","\t\"bytes\"","\t\"fmt\"","\t\"log\"","\t\"net/http\"","\t\"os\"","\t\"strings\"",")","","type TypeValidator func(target string) bool","","func IsYamlFile() TypeValidator {","\treturn func(target string) bool {","\t\tif strings.HasSuffix(target, \".yaml\") || strings.HasSuffix(target, \".yml\") {","\t\t\treturn true","\t\t}","\t\treturn false","\t}","}","","func LoadFileContent(httpClient http.Client, target string, validate TypeValidator, errorMsg error) ([]byte, error) {","\tif !validate(target) {","\t\treturn nil, errorMsg","\t}","","\tvar content []byte","\tvar err error","\tif strings.HasPrefix(target, \"http\") {","\t\tcontent, err = getRemoteContent(httpClient, target)","\t} else {","\t\tcontent, err = os.ReadFile(target)","\t}","","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn content, nil","}","","func getRemoteContent(httpClient http.Client, url string) ([]byte, error) {","\tresp, err := httpClient.Get(url)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif resp.StatusCode == 404 {","\t\treturn nil, fmt.Errorf(\"url specified returned a 404: not found\")","\t}","","\tdefer func() {","\t\terr := resp.Body.Close()","\t\tif err != nil {","\t\t\tlog.Fatal(err)","\t\t}","\t}()","","\tbuf := new(bytes.Buffer)","\t_, err = buf.ReadFrom(resp.Body)","\tif err != nil {","\t\treturn nil, err","\t}","","\tcontent := buf.Bytes()","\treturn content, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,0,0,0,2,2,1,1,0,2,2,2,2,2,2,2,0,2,2,2,0,2,0,0,2,2,2,2,2,0,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0]},{"id":23,"path":"pkg/flags/flags.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package flags","","import (","\t\"os\"","\t\"runtime\"","","\t\"github.com/spf13/cobra\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/formatted\"","\t\"golang.org/x/term\"",")","","const (","\tkubeConfig = \"kubeconfig\"","\tcontext    = \"context\"","\tnamespace  = \"namespace\"","\tnocolour   = \"nocolour\"","\tnocolor    = \"no-color\"",")","","// TektonOptions all global tekton options","type TektonOptions struct {","\tKubeConfig, Context, Namespace string","\tNocolour                       bool","}","","// AddTektonOptions amends command to add flags required to initialise a cli.Param","func AddTektonOptions(cmd *cobra.Command) {","\tcmd.PersistentFlags().StringP(","\t\tkubeConfig, \"k\", \"\",","\t\t\"kubectl config file (default: $HOME/.kube/config)\")","","\tcmd.PersistentFlags().StringP(","\t\tcontext, \"c\", \"\",","\t\t\"name of the kubeconfig context to use (default: kubectl config current-context)\")","","\tcmd.PersistentFlags().StringP(","\t\tnamespace, \"n\", \"\",","\t\t\"namespace to use (default: from $KUBECONFIG)\")","\t_ = cmd.RegisterFlagCompletionFunc(namespace,","\t\tfunc(_ *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) {","\t\t\treturn formatted.BaseCompletion(\"namespace\", args)","\t\t},","\t)","","\tcmd.PersistentFlags().BoolP(","\t\tnocolour, \"\", false,","\t\t\"disable colouring (default: false)\")","","\t// Since nocolour was the old name for the --no-color flag, mark","\t// the flag as hidden to make the option backwards compatible while","\t// only showing --no-color option in help output.","\t_ = cmd.PersistentFlags().MarkHidden(\"nocolour\")","","\tcmd.PersistentFlags().BoolP(","\t\t\"no-color\", \"C\", false,","\t\t\"disable coloring (default: false)\")","}","","// GetTektonOptions get the global tekton Options that are not passed to a subcommands","func GetTektonOptions(cmd *cobra.Command) TektonOptions {","\tkcPath, _ := cmd.Flags().GetString(kubeConfig)","\tkubeContext, _ := cmd.Flags().GetString(context)","\tns, _ := cmd.Flags().GetString(namespace)","\tnocolourFlag, _ := cmd.Flags().GetBool(nocolor)","\treturn TektonOptions{","\t\tKubeConfig: kcPath,","\t\tContext:    kubeContext,","\t\tNamespace:  ns,","\t\tNocolour:   nocolourFlag,","\t}","}","","// InitParams initialises cli.Params based on flags defined in command","func InitParams(p cli.Params, cmd *cobra.Command) error {","\t// NOTE: breaks symmetry with AddTektonOptions as this uses Flags instead of","\t// PersistentFlags as it could be the sub command that is trying to access","\t// the flags defined by the parent and hence need to use `Flag` instead","\t// e.g. `list` accessing kubeconfig defined by `pipeline`","\tkcPath, err := cmd.Flags().GetString(kubeConfig)","\tif err != nil {","\t\treturn err","\t}","\tp.SetKubeConfigPath(kcPath)","","\tkubeContext, err := cmd.Flags().GetString(context)","\tif err != nil {","\t\treturn err","\t}","\tp.SetKubeContext(kubeContext)","","\t// ensure that the config is valid by creating a client but skip for bundle cmd","\t// as bundle cmd does not need k8s client and config","\t// if this annotation is available on cmd and value is false then client","\t// will not be initialized","\tif cmd.Annotations[\"kubernetes\"] != \"false\" {","\t\tif _, err := p.Clients(); err != nil {","\t\t\treturn err","\t\t}","\t}","","\tns, err := cmd.Flags().GetString(namespace)","\tif err != nil {","\t\treturn err","\t}","\tif ns != \"\" {","\t\tp.SetNamespace(ns)","\t}","","\tnocolourFlag, err := cmd.Flags().GetBool(nocolor)","\tif err != nil {","\t\treturn err","\t}","\tif !nocolourFlag {","\t\t// Check to see if --nocolour option was passed instead of --no-color or -C","\t\tnocolourFlag, err = cmd.Flags().GetBool(nocolour)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\tp.SetNoColour(nocolourFlag)","","\t// Make sure we set as Nocolour if we don't have a terminal (ie redirection)","\t// nolint","\t// this conversion is throwing error for golangci-lint G115","\tif !term.IsTerminal(int(os.Stdout.Fd())) {","\t\tp.SetNoColour(true)","\t}","","\tif runtime.GOOS == \"windows\" {","\t\tp.SetNoColour(true)","\t}","","\tif _, ok := os.LookupEnv(\"NO_COLOR\"); ok {","\t\tp.SetNoColour(true)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,0]},{"id":24,"path":"pkg/formatted/address.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","func FormatAddress(addressURL string) string {","\tif addressURL == \"\" {","\t\treturn \"---\"","\t}","","\treturn addressURL","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,0]},{"id":25,"path":"pkg/formatted/color.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\t\"fmt\"","\t\"io\"","\t\"sync\"","\t\"sync/atomic\"","","\t\"github.com/fatih/color\"",")","","var (","\t// Palette of colors for rainbow's tasks, Red is avoided as keeping it for errors","\tpalette = []color.Attribute{","\t\tcolor.FgHiGreen,","\t\tcolor.FgHiYellow,","\t\tcolor.FgHiBlue,","\t\tcolor.FgHiMagenta,","\t\tcolor.FgHiCyan,","\t}",")","","// DecorateAttr decorate strings with a color or an emoji, respecting the user","// preference if no colour needed.","func DecorateAttr(attrString, message string) string {","\tif color.NoColor {","\t\treturn message","\t}","","\tswitch attrString {","\tcase \"bullet\":","\t\treturn fmt.Sprintf(\"∙ %s\", message)","\tcase \"check\":","\t\treturn \"✔ ️\"","\tcase \"resources\":","\t\treturn \"📦 \"","\tcase \"params\":","\t\treturn \"⚓ \"","\tcase \"tasks\":","\t\treturn \"🗒  \"","\tcase \"pipelineruns\":","\t\treturn \"⛩  \"","\tcase \"status\":","\t\treturn \"🌡️  \"","\tcase \"inputresources\":","\t\treturn \"📨 \"","\tcase \"outputresources\":","\t\treturn \"📡 \"","\tcase \"steps\":","\t\treturn \"🦶 \"","\tcase \"message\":","\t\treturn \"💌 \"","\tcase \"taskruns\":","\t\treturn \"🗂  \"","\tcase \"sidecars\":","\t\treturn \"🚗 \"","\tcase \"results\":","\t\treturn \"📝 \"","\tcase \"workspaces\":","\t\treturn \"📂 \"","\tcase \"skippedtasks\":","\t\treturn \"⏭️  \"","\tcase \"timeouts\":","\t\treturn \"⏱  \"","\t}","","\tattr := color.Reset","\tswitch attrString {","\tcase \"underline\":","\t\tattr = color.Underline","\tcase \"underline bold\":","\t\treturn color.New(color.Underline).Add(color.Bold).Sprintf(\"%s\", message)","\tcase \"bold\":","\t\tattr = color.Bold","\tcase \"yellow\":","\t\tattr = color.FgHiYellow","\tcase \"green\":","\t\tattr = color.FgHiGreen","\tcase \"red\":","\t\tattr = color.FgHiRed","\tcase \"blue\":","\t\tattr = color.FgHiBlue","\tcase \"magenta\":","\t\tattr = color.FgHiMagenta","\tcase \"cyan\":","\t\tattr = color.FgHiCyan","\tcase \"black\":","\t\tattr = color.FgHiBlack","\tcase \"white\":","\t\tattr = color.FgHiWhite","\t}","","\treturn color.New(attr).Sprintf(\"%s\", message)","}","","type atomicCounter struct {","\tvalue     uint32","\tthreshold int","}","","func (c *atomicCounter) next() int {","\tv := atomic.AddUint32(\u0026c.value, 1)","\tnext := int(v-1) % c.threshold","\t// nolint","\t// this conversion is throwing error for golangci-lint G115","\tatomic.CompareAndSwapUint32(\u0026c.value, uint32(c.threshold), 0)","\treturn next","","}","","type rainbow struct {","\tcache   sync.Map","\tcounter atomicCounter","}","","func newRainbow() *rainbow {","\treturn \u0026rainbow{","\t\tcounter: atomicCounter{threshold: len(palette)},","\t}","}","","func (r *rainbow) get(x string) color.Attribute {","\tif value, ok := r.cache.Load(x); ok {","\t\treturn value.(color.Attribute)","\t}","","\tclr := palette[r.counter.next()]","\tr.cache.Store(x, clr)","\treturn clr","}","","// Fprintf formats according to a format specifier and writes to w.","// the first argument is a label to keep the same colour on.","func (r *rainbow) Fprintf(label string, w io.Writer, format string, args ...interface{}) {","\tattribute := r.get(label)","\tcrainbow := color.Set(attribute).Add(color.Bold)","\tcrainbow.Fprintf(w, format, args...)","}","","// Color formatter to print the colored output on streams","type Color struct {","\tRainbow *rainbow","","\tred  *color.Color","\tblue *color.Color","}","","// NewColor returns a new instance color formatter","func NewColor() *Color {","\treturn \u0026Color{","\t\tRainbow: newRainbow(),","","\t\tred:  color.New(color.FgRed),","\t\tblue: color.New(color.FgBlue),","\t}","}","","// PrintRed prints the formatted content to given destination in red color","func (c *Color) PrintRed(w io.Writer, format string, args ...interface{}) {","\tc.red.Fprintf(w, format, args...)","}","","// Error prints the formatted content to given destination in red color","func (c *Color) Error(w io.Writer, format string, args ...interface{}) {","\tc.PrintRed(w, format, args...)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,1,1,1,1,1,1,1,1,2,2,1,1,1,1,1,1,1,1,1,1,0,0,2,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,0,2,2,2,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":26,"path":"pkg/formatted/completion.go","lines":["package formatted","","import (","\t\"os/exec\"","\t\"strings\"","","\t\"github.com/spf13/cobra\"",")","","// GetObjectsWithKubectl return completions with kubectl, we are doing this with","// kubectl since we have caching and without it completion is way too slow","func GetObjectsWithKubectl(obj string) []string {","\tout, err := exec.Command(\"kubectl\", \"get\", obj, \"-o=jsonpath={range .items[*]}{.metadata.name} {end}\").Output()","\tif err != nil {","\t\treturn nil","\t}","\treturn strings.Fields(string(out))","}","","// BaseCompletion return a completion for a kubernetes object using Kubectl","func BaseCompletion(target string, args []string) ([]string, cobra.ShellCompDirective) {","\tif len(args) != 0 {","\t\treturn nil, cobra.ShellCompDirectiveNoFileComp","\t}","\treturn GetObjectsWithKubectl(target), cobra.ShellCompDirectiveNoFileComp","}","","// ParentCompletion do completion of command to the Parent","func ParentCompletion(cmd *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) {","\treturn BaseCompletion(cmd.Parent().Name(), args)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1]},{"id":27,"path":"pkg/formatted/description.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tcorev1 \"k8s.io/api/core/v1\"",")","","// If description is longer than 20 char then it will return","// initial 20 chars suffixed by ...","func FormatDesc(desc string) string {","\tif len(desc) \u003e 20 {","\t\treturn desc[0:19] + \"...\"","\t}","\treturn desc","}","","func RemoveLastAppliedConfig(annotations map[string]string) map[string]string {","\tremoved := map[string]string{}","\tfor k, v := range annotations {","\t\tif k != corev1.LastAppliedConfigAnnotation {","\t\t\tremoved[k] = v","\t\t}","\t}","\treturn removed","}","","// Check if PipelineRef exists on a PipelineRunSpec. Returns empty string if not present.","func PipelineRefExists(spec v1.PipelineRunSpec) string {","\tif spec.PipelineRef == nil {","\t\treturn \"\"","\t}","","\treturn spec.PipelineRef.Name","}","","// Check if TaskRef exists on a TaskRunSpec. Returns empty string if not present.","func TaskRefExists(spec v1.TaskRunSpec) string {","\tif spec.TaskRef == nil {","\t\treturn \"\"","\t}","","\treturn spec.TaskRef.Name","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,0,2,0,0,0,2,2,2,2,0,2,0,0,0,2,2,2,2,0,2,0]},{"id":28,"path":"pkg/formatted/k8s.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\t\"fmt\"","\t\"sync/atomic\"","","\t\"github.com/fatih/color\"","\tcorev1 \"k8s.io/api/core/v1\"","\tv1 \"knative.dev/pkg/apis/duck/v1\"",")","","var ConditionColor = map[string]color.Attribute{","\t\"Failed\":    color.FgHiRed,","\t\"Succeeded\": color.FgHiGreen,","\t\"Running\":   color.FgHiBlue,","\t\"Cancelled\": color.FgHiYellow,","\t\"Completed\": color.FgHiMagenta,","\t\"Pending\":   color.FgHiYellow,","\t\"Started\":   color.FgHiCyan,","}","","var stepCounter uint64","","// ColorStatus Get a status coloured","func ColorStatus(status string) string {","\treturn color.New(ConditionColor[status]).Sprint(status)","}","","// AutoStepName when our stepName is empty return a generated name as generated","// on pipeLine","func AutoStepName(stepName string) string {","\tunnamedStep := fmt.Sprintf(\"unnamed-%d\", stepCounter)","\tatomic.AddUint64(\u0026stepCounter, 1)","\tif stepName != \"\" {","\t\treturn stepName","\t}","\treturn unnamedStep","}","","// Condition returns a human readable text based on the status of the Condition","func Condition(c v1.Conditions) string {","\tvar status string","\tif len(c) == 0 {","\t\treturn \"---\"","\t}","","\tswitch c[0].Status {","\tcase corev1.ConditionFalse:","\t\tstatus = \"Failed\"","\tcase corev1.ConditionTrue:","\t\tstatus = \"Succeeded\"","\tcase corev1.ConditionUnknown:","\t\tstatus = \"Running\"","\t}","","\tif c[0].Reason == \"Completed\" \u0026\u0026 status == \"Succeeded\" {","\t\treturn ColorStatus(status)","\t} else if c[0].Reason != \"\" \u0026\u0026 c[0].Reason != status {","\t\tswitch c[0].Reason {","\t\tcase \"PipelineRunCancelled\", \"TaskRunCancelled\", \"Cancelled\":","\t\t\tif c[0].Reason == \"Cancelled\" {","\t\t\t\treturn ColorStatus(\"Cancelled\")","\t\t\t}","\t\t\treturn ColorStatus(\"Cancelled\") + \"(\" + c[0].Reason + \")\"","\t\tcase \"PipelineRunStopping\", \"TaskRunStopping\":","\t\t\tif c[0].Reason == \"Failed\" {","\t\t\t\treturn ColorStatus(\"Failed\")","\t\t\t}","\t\t\treturn ColorStatus(\"Failed\") + \"(\" + c[0].Reason + \")\"","\t\tcase \"CreateContainerConfigError\", \"ExceededNodeResources\", \"ExceededResourceQuota\":","\t\t\tif c[0].Reason == \"Pending\" {","\t\t\t\treturn ColorStatus(\"Pending\")","\t\t\t}","\t\t\treturn ColorStatus(\"Pending\") + \"(\" + c[0].Reason + \")\"","\t\tcase \"PipelineRunPending\":","\t\t\treturn ColorStatus(\"Pending\")","\t\tdefault:","\t\t\treturn ColorStatus(status) + \"(\" + c[0].Reason + \")\"","\t\t}","\t}","\treturn ColorStatus(status)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,1,2,2,2,2,2,0,0,2,0]},{"id":29,"path":"pkg/formatted/param.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\t\"fmt\"","\t\"strings\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"",")","","// Param returns params with their values. If user value is not defined then returns default value,","// if default value is not defined then returns param's type","func Param(params []v1.Param, paramSpec []v1.ParamSpec) string {","\tif len(params) == 0 {","\t\treturn \"---\"","\t}","\tvar str string","\tfor i, param := range params {","\t\tparamValue := \"\"","\t\tswitch param.Value.Type {","\t\tcase \"string\":","\t\t\tparamValue = CheckParamDefaultValue(param.Value.StringVal, paramSpec)","\t\tcase \"array\":","\t\t\tparamValue = \"[\"","\t\t\tfor j, pv := range param.Value.ArrayVal {","\t\t\t\tpv = CheckParamDefaultValue(pv, paramSpec)","\t\t\t\tif j == len(param.Value.ArrayVal)-1 {","\t\t\t\t\tparamValue += \" \" + pv + \" ]\"","\t\t\t\t} else {","\t\t\t\t\tparamValue += \" \" + pv + \",\"","\t\t\t\t}","\t\t\t}","\t\tdefault:","\t\t\tparamValue = \"{\"","\t\t\tj := 0","\t\t\tfor k, v := range param.Value.ObjectVal {","\t\t\t\tpv := CheckParamDefaultValue(v, paramSpec)","\t\t\t\tif j == len(param.Value.ObjectVal)-1 {","\t\t\t\t\tparamValue += fmt.Sprintf(\" %s: %s }\", k, pv)","\t\t\t\t} else {","\t\t\t\t\tparamValue += fmt.Sprintf(\" %s: %s ,\", k, pv)","\t\t\t\t}","\t\t\t\tj++","\t\t\t}","\t\t}","\t\tif i == len(params)-1 {","\t\t\tstr += fmt.Sprintf(\"%s: %s\", param.Name, paramValue)","\t\t} else {","\t\t\tstr += fmt.Sprintf(\"%s: %s, \", param.Name, paramValue)","\t\t}","\t}","\treturn str","}","","// CheckParamDefaultValue returns param's value if defined, if not then checks for default value","// If default value is not defined then returns param's type","func CheckParamDefaultValue(param string, paramSpec []v1.ParamSpec) string {","\tif strings.ContainsAny(param, \"$\") {","\t\tparamValue := \"\"","\t\treplacer := strings.NewReplacer(\"$\", \"\", \"(\", \"\", \")\", \"\", \"params.\", \"\")","\t\tparamName := replacer.Replace(param)","\t\tfor _, spec := range paramSpec {","\t\t\tif spec.Name == paramName {","\t\t\t\tif spec.Default == nil {","\t\t\t\t\tparamValue = string(spec.Type)","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t\tswitch spec.Default.Type {","\t\t\t\tcase \"string\":","\t\t\t\t\tparamValue = spec.Default.StringVal","\t\t\t\tcase \"array\":","\t\t\t\t\tpv := \"\"","\t\t\t\t\tfor k, val := range spec.Default.ArrayVal {","\t\t\t\t\t\tif k == 0 {","\t\t\t\t\t\t\tpv += val","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\tpv += \" \" + val","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tparamValue = pv","\t\t\t\tdefault:","\t\t\t\t\tpv := \"{\"","\t\t\t\t\tfirst := true","\t\t\t\t\tfor k, val := range spec.Default.ObjectVal {","\t\t\t\t\t\tif !first {","\t\t\t\t\t\t\tpv += \",\"","\t\t\t\t\t\t}","\t\t\t\t\t\tpv += k + \":\" + val","\t\t\t\t\t\tfirst = false","\t\t\t\t\t}","\t\t\t\t\tparamValue = pv + \"}\"","\t\t\t\t}","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\treturn paramValue","\t}","\treturn param","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,2,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,1,1,1,1,1,1,1,1,1,0,1,0,2,0,0,2,0,2,0]},{"id":30,"path":"pkg/formatted/results.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\t\"encoding/json\"","\t\"strings\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"",")","","// Result will format a given result value","func Result(value v1.ParamValue) string {","\tswitch value.Type {","\tcase v1.ParamTypeString:","\t\t// remove trailing new-line from value","\t\treturn strings.TrimSuffix(value.StringVal, \"\\n\")","\tcase v1.ParamTypeArray:","\t\treturn strings.Join(value.ArrayVal, \", \")","\tcase v1.ParamTypeObject:","\t\t// FIXME: do not ignore the error","\t\tv, _ := json.Marshal(value.ObjectVal)","\t\treturn string(v)","\t}","\treturn \"\u003cinvalid result type\u003e\"","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,1,0]},{"id":31,"path":"pkg/formatted/task.go","lines":["// Copyright © 2021 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"",")","","func GetTaskRefName(task *v1.PipelineTask) string {","\tif task.TaskRef != nil {","\t\treturn task.TaskRef.Name","\t}","\treturn \"EMBEDDED\"","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0]},{"id":32,"path":"pkg/formatted/time.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\t\"github.com/hako/durafmt\"","\t\"github.com/jonboulle/clockwork\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","func Age(t *metav1.Time, c clockwork.Clock) string {","\tif t.IsZero() {","\t\treturn \"---\"","\t}","","\tdur := c.Since(t.Time)","\treturn durafmt.ParseShort(dur).String() + \" ago\"","}","","func Duration(t1, t2 *metav1.Time) string {","\tif t1.IsZero() || t2.IsZero() {","\t\treturn \"---\"","\t}","","\tdur := t2.Time.Sub(t1.Time)","\treturn dur.String()","}","","func Timeout(t *metav1.Duration) string {","\tif t == nil {","\t\treturn \"---\"","\t}","","\treturn durafmt.Parse(t.Duration).String()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,0,2,2,2,2,0,2,2,0,0,2,2,2,2,0,2,0]},{"id":33,"path":"pkg/formatted/version.go","lines":["// Copyright © 2021 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","func FindVersion(version map[string]string) string {","\tif _, ok := version[\"app.kubernetes.io/version\"]; ok {","\t\treturn version[\"app.kubernetes.io/version\"]","\t}","\treturn \"\"","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0]},{"id":34,"path":"pkg/formatted/workspace.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package formatted","","import (","\t\"fmt\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tcorev1 \"k8s.io/api/core/v1\"",")","","func Workspace(ws v1.WorkspaceBinding) string {","\tif ws.VolumeClaimTemplate != nil {","\t\treturn \"VolumeClaimTemplate\"","\t}","\tif ws.PersistentVolumeClaim != nil {","\t\tclaimName := ws.PersistentVolumeClaim.ClaimName","\t\treturn fmt.Sprintf(\"PersistentVolumeClaim (claimName=%s)\", claimName)","\t}","\tif ws.EmptyDir != nil {","\t\tdirType := getWorkspaceEmptyDir(ws.EmptyDir)","\t\treturn fmt.Sprintf(\"EmptyDir (emptyDir=%s)\", dirType)","\t}","\tif ws.ConfigMap != nil {","\t\tcm := getWorkspaceConfig(ws.ConfigMap)","\t\treturn fmt.Sprintf(\"ConfigMap (%s)\", cm)","\t}","\tif ws.Secret != nil {","\t\tsecret := getWorkspaceSecret(ws.Secret)","\t\treturn fmt.Sprintf(\"Secret (%s)\", secret)","\t}","\tif ws.CSI != nil {","\t\treturn fmt.Sprintf(\"CSI (Driver=%s)\", ws.CSI.Driver)","\t}","\treturn \"\"","}","","func getWorkspaceEmptyDir(ed *corev1.EmptyDirVolumeSource) string {","\tsM := ed.Medium","\tvar dirType string","\tif sM == corev1.StorageMediumDefault {","\t\tdirType = \"\"","\t}","\tif sM == corev1.StorageMediumMemory {","\t\tdirType = \"Memory\"","\t}","\tif sM == corev1.StorageMediumHugePages {","\t\tdirType = \"HugePages\"","\t}","\treturn dirType","}","","func getWorkspaceConfig(cm *corev1.ConfigMapVolumeSource) string {","\tcmName := cm.LocalObjectReference.Name","\tcmItems := cm.Items","\tstr := fmt.Sprintf(\"config=%s\", cmName)","\tif len(cmItems) != 0 {","\t\tstr = fmt.Sprintf(\"%s%s\", str, getItems(cmItems))","\t}","\treturn str","}","","func getWorkspaceSecret(secret *corev1.SecretVolumeSource) string {","\tsecretName := secret.SecretName","\tsecretItems := secret.Items","\tstr := fmt.Sprintf(\"secret=%s\", secretName)","\tif len(secretItems) != 0 {","\t\tstr = fmt.Sprintf(\"%s%s\", str, getItems(secretItems))","\t}","\treturn str","}","","func getItems(items []corev1.KeyToPath) string {","\tstr := \"\"","\tfor i := range items {","\t\tkp := items[i]","\t\tkey := kp.Key","\t\tvalue := kp.Path","\t\tstr = fmt.Sprintf(\"%s,item=%s=%s\", str, key, value)","\t}","\treturn str","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,0,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,2,1,1,2,0,0,2,2,2,2,2,1,1,2,0,0,1,1,1,1,1,1,1,1,1,0]},{"id":35,"path":"pkg/labels/mergelabels.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package labels","","import (","\t\"errors\"","\t\"strings\"",")","","const invalidLabel = \"invalid input format for label parameter: \"","","func MergeLabels(l map[string]string, optLabel []string) (map[string]string, error) {","\tlabels, err := parseLabels(optLabel)","\tif err != nil {","\t\treturn nil, err","\t}","\tif len(labels) == 0 {","\t\treturn l, nil","\t}","","\tif l == nil {","\t\treturn labels, nil","\t}","","\tfor k, v := range labels {","\t\tl[k] = v","\t}","\treturn l, nil","}","","func parseLabels(p []string) (map[string]string, error) {","\tlabels := map[string]string{}","\tfor _, v := range p {","\t\tr := strings.SplitN(v, \"=\", 2)","\t\tif len(r) != 2 {","\t\t\treturn nil, errors.New(invalidLabel + v)","\t\t}","\t\tlabels[r[0]] = r[1]","\t}","\treturn labels, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,0,2,0]},{"id":36,"path":"pkg/log/pipeline_reader.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package log","","import (","\t\"fmt\"","\t\"sync\"","\t\"time\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\tpipelinepkg \"github.com/tektoncd/cli/pkg/pipeline\"","\tpipelinerunpkg \"github.com/tektoncd/cli/pkg/pipelinerun\"","\ttaskrunpkg \"github.com/tektoncd/cli/pkg/taskrun\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/fields\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","func (r *Reader) readPipelineLog() (\u003c-chan Log, \u003c-chan error, error) {","\tpr, err := pipelinerunpkg.GetPipelineRun(pipelineRunGroupResource, r.clients, r.run, r.ns)","\tif err != nil {","\t\treturn nil, nil, err","\t}","","\tif !pr.IsDone() \u0026\u0026 r.follow {","\t\treturn r.readLivePipelineLogs(pr)","\t}","\treturn r.readAvailablePipelineLogs(pr)","}","","func (r *Reader) readLivePipelineLogs(pr *v1.PipelineRun) (\u003c-chan Log, \u003c-chan error, error) {","\tlogC := make(chan Log)","\terrC := make(chan error)","","\tgo func() {","\t\tdefer close(logC)","\t\tdefer close(errC)","","\t\tprTracker := pipelinerunpkg.NewTracker(pr.Name, r.ns, r.clients)","\t\ttrC := prTracker.Monitor(r.tasks)","","\t\twg := sync.WaitGroup{}","\t\ttaskIndex := 0","","\t\tfor trs := range trC {","\t\t\twg.Add(len(trs))","","\t\t\tfor _, run := range trs {","\t\t\t\ttaskIndex++","\t\t\t\t// NOTE: passing tr, taskIdx to avoid data race","\t\t\t\tgo func(tr taskrunpkg.Run, taskNum int) {","\t\t\t\t\tdefer wg.Done()","","\t\t\t\t\t// clone the object to keep task number and name separately","\t\t\t\t\tc := r.clone()","\t\t\t\t\tc.setUpTask(taskNum, tr)","\t\t\t\t\tc.pipeLogs(logC, errC)","\t\t\t\t}(run, taskIndex)","\t\t\t}","\t\t}","","\t\twg.Wait()","","\t\tif !empty(pr.Status) \u0026\u0026 pr.Status.Conditions[0].Status == corev1.ConditionFalse {","\t\t\terrC \u003c- fmt.Errorf(\"%s\", pr.Status.Conditions[0].Message)","\t\t}","\t}()","","\treturn logC, errC, nil","}","","func (r *Reader) readAvailablePipelineLogs(pr *v1.PipelineRun) (\u003c-chan Log, \u003c-chan error, error) {","\tif err := r.waitUntilAvailable(); err != nil {","\t\treturn nil, nil, err","\t}","","\tordered, err := r.getOrderedTasks(pr)","\tif err != nil {","\t\treturn nil, nil, err","\t}","","\ttaskRuns := taskrunpkg.Filter(ordered, r.tasks)","\tif len(taskRuns) == 0 \u0026\u0026 len(r.tasks) != 0 {","\t\tavailTasks := []string{}","\t\tfor _, o := range ordered {","\t\t\tavailTasks = append(availTasks, o.Task)","\t\t}","\t\treturn nil, nil, fmt.Errorf(\"passed filtered tasks: %v is not available, available tasks are: %v\", r.tasks, availTasks)","\t}","","\tlogC := make(chan Log)","\terrC := make(chan error)","","\tgo func() {","\t\tdefer close(logC)","\t\tdefer close(errC)","","\t\t// clone the object to keep task number and name separately","\t\tc := r.clone()","\t\tfor i, tr := range taskRuns {","\t\t\tc.setUpTask(i+1, tr)","\t\t\tc.pipeLogs(logC, errC)","\t\t}","","\t\tif !empty(pr.Status) \u0026\u0026 pr.Status.Conditions[0].Status == corev1.ConditionFalse {","\t\t\terrC \u003c- fmt.Errorf(\"%s\", pr.Status.Conditions[0].Message)","\t\t}","\t}()","","\treturn logC, errC, nil","}","","// reading of logs should wait till the status of run is unknown","// only if run status is unknown, open a watch channel on run","// and keep checking the status until it changes to true|false","// or the reach timeout","func (r *Reader) waitUntilAvailable() error {","\tfirst := true","\topts := metav1.ListOptions{","\t\tFieldSelector: fields.OneTermEqualSelector(\"metadata.name\", r.run).String(),","\t}","\trun, err := pipelinerunpkg.GetPipelineRun(pipelineRunGroupResource, r.clients, r.run, r.ns)","\tif err != nil {","\t\treturn err","\t}","\tif empty(run.Status) {","\t\treturn nil","\t}","\tif run.Status.Conditions[0].Status != corev1.ConditionUnknown {","\t\treturn nil","\t}","","\twatchRun, err := actions.Watch(pipelineRunGroupResource, r.clients, r.ns, opts)","\tif err != nil {","\t\treturn err","\t}","\tfor {","\t\tselect {","\t\tcase event := \u003c-watchRun.ResultChan():","\t\t\trun, err := cast2pipelinerun(event.Object)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tif run.IsDone() {","\t\t\t\twatchRun.Stop()","\t\t\t\treturn nil","\t\t\t}","\t\t\tif first {","\t\t\t\tfirst = false","\t\t\t\tfmt.Fprintln(r.stream.Out, \"Pipeline still running ...\")","\t\t\t}","\t\tcase \u003c-time.After(r.activityTimeout):","\t\t\twatchRun.Stop()","\t\t\tif isPipelineRunRunning(run.Status.Conditions) {","\t\t\t\tfmt.Fprintln(r.stream.Out, \"PipelineRun is still running:\", run.Status.Conditions[0].Message)","\t\t\t\treturn nil","\t\t\t}","\t\t\tif err = hasPipelineRunFailed(run.Status.Conditions); err != nil {","\t\t\t\treturn fmt.Errorf(\"PipelineRun %s has failed: %s\", run.Name, err.Error())","\t\t\t}","\t\t\treturn fmt.Errorf(\"PipelineRun has not started yet\")","\t\t}","\t}","}","","func (r *Reader) pipeLogs(logC chan\u003c- Log, errC chan\u003c- error) {","\ttlogC, terrC, err := r.readTaskLog()","\tif err != nil {","\t\terrC \u003c- err","\t\treturn","\t}","","\tfor tlogC != nil || terrC != nil {","\t\tselect {","\t\tcase l, ok := \u003c-tlogC:","\t\t\tif !ok {","\t\t\t\ttlogC = nil","\t\t\t\tcontinue","\t\t\t}","\t\t\tlogC \u003c- Log{Task: l.Task, Step: l.Step, Log: l.Log}","","\t\tcase e, ok := \u003c-terrC:","\t\t\tif !ok {","\t\t\t\tterrC = nil","\t\t\t\tcontinue","\t\t\t}","\t\t\terrC \u003c- fmt.Errorf(\"failed to get logs for task %s : %s\", r.task, e)","\t\t}","\t}","}","","func (r *Reader) setUpTask(taskNumber int, tr taskrunpkg.Run) {","\tr.setNumber(taskNumber)","\tr.setRun(tr.Name)","\tr.setTask(tr.Task)","\tr.setRetries(tr.Retries)","}","","// getOrderedTasks get Tasks in order from Spec.PipelineRef or Spec.PipelineSpec","// and return trh.Run after converted taskruns into trh.Run.","func (r *Reader) getOrderedTasks(pr *v1.PipelineRun) ([]taskrunpkg.Run, error) {","\tvar tasks []v1.PipelineTask","\tswitch {","\tcase pr.Spec.PipelineRef != nil:","\t\tif pr.Spec.PipelineRef.Resolver != \"\" {","\t\t\tif pr.Status.PipelineSpec != nil {","\t\t\t\ttasks = append(tasks, pr.Status.PipelineSpec.Tasks...)","\t\t\t} else {","\t\t\t\treturn nil, fmt.Errorf(\"pipelinerun %s does not have the PipelineRunSpec\", pr.Name)","\t\t\t}","\t\t} else {","\t\t\tpl, err := pipelinepkg.GetPipeline(pipelineGroupResource, r.clients, pr.Spec.PipelineRef.Name, r.ns)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\ttasks = pl.Spec.Tasks","\t\t\ttasks = append(tasks, pl.Spec.Finally...)","\t\t}","\tcase pr.Spec.PipelineSpec != nil:","\t\ttasks = pr.Spec.PipelineSpec.Tasks","\t\ttasks = append(tasks, pr.Spec.PipelineSpec.Finally...)","\tdefault:","\t\treturn nil, fmt.Errorf(\"pipelinerun %s did not provide PipelineRef or PipelineSpec\", pr.Name)","\t}","","\ttrsMap, err := pipelinerunpkg.GetTaskRunsWithStatus(pr, r.clients, r.ns)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Sort taskruns, to display the taskrun logs as per pipeline tasks order","\treturn taskrunpkg.SortTasksBySpecOrder(tasks, trsMap), nil","}","","func empty(status v1.PipelineRunStatus) bool {","\tif status.Conditions == nil {","\t\treturn true","\t}","\treturn len(status.Conditions) == 0","}","","func hasPipelineRunFailed(prConditions duckv1.Conditions) error {","\tif len(prConditions) != 0 \u0026\u0026 prConditions[0].Status == corev1.ConditionFalse {","\t\treturn fmt.Errorf(\"pipelinerun has failed: %s\", prConditions[0].Message)","\t}","\treturn nil","}","","func isPipelineRunRunning(prConditions duckv1.Conditions) bool {","\tif len(prConditions) != 0 \u0026\u0026 prConditions[0].Status == corev1.ConditionUnknown {","\t\treturn true","\t}","\treturn false","}","","func cast2pipelinerun(obj runtime.Object) (*v1.PipelineRun, error) {","\tvar run *v1.PipelineRun","\tunstruct, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)","\tif err != nil {","\t\treturn nil, err","\t}","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstruct, \u0026run); err != nil {","\t\treturn nil, err","\t}","\treturn run, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":37,"path":"pkg/log/reader.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package log","","import (","\t\"fmt\"","\t\"time\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/options\"","\t\"github.com/tektoncd/cli/pkg/pods\"","\t\"github.com/tektoncd/cli/pkg/pods/stream\"",")","","type Reader struct {","\trun             string","\tns              string","\tclients         *cli.Clients","\tstreamer        stream.NewStreamerFunc","\tstream          *cli.Stream","\tallSteps        bool","\tfollow          bool","\ttimestamps      bool","\ttasks           []string","\tsteps           []string","\tlogType         string","\ttask            string","\tnumber          int","\tactivityTimeout time.Duration","\tretries         int","}","","func NewReader(logType string, opts *options.LogOptions) (*Reader, error) {","\tstreamer := pods.NewStream","\tif opts.Streamer != nil {","\t\tstreamer = opts.Streamer","\t}","","\tcs, err := opts.Params.Clients()","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar run string","\tswitch logType {","\tcase LogTypePipeline:","\t\trun = opts.PipelineRunName","\tcase LogTypeTask:","\t\trun = opts.TaskrunName","\t}","","\tat := 10 * time.Second","\tif opts.ActivityTimeout != 0 {","\t\tat = opts.ActivityTimeout","\t}","","\treturn \u0026Reader{","\t\trun:             run,","\t\tns:              opts.Params.Namespace(),","\t\tclients:         cs,","\t\tstreamer:        streamer,","\t\tstream:          opts.Stream,","\t\tfollow:          opts.Follow,","\t\ttimestamps:      opts.Timestamps,","\t\tallSteps:        opts.AllSteps,","\t\ttasks:           opts.Tasks,","\t\tsteps:           opts.Steps,","\t\tlogType:         logType,","\t\tactivityTimeout: at,","\t}, nil","}","","func (r *Reader) Read() (\u003c-chan Log, \u003c-chan error, error) {","\tswitch r.logType {","\tcase LogTypePipeline:","\t\treturn r.readPipelineLog()","\tcase LogTypeTask:","\t\treturn r.readTaskLog()","\t}","\treturn nil, nil, fmt.Errorf(\"unknown log type\")","}","","func (r *Reader) setNumber(number int) {","\tr.number = number","}","","func (r *Reader) setRetries(retries int) {","\tr.retries = retries","}","","func (r *Reader) setRun(run string) {","\tr.run = run","}","","func (r *Reader) setTask(task string) {","\tr.task = task","}","","func (r *Reader) clone() *Reader {","\tc := *r","\treturn \u0026c","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1]},{"id":38,"path":"pkg/log/task_reader.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package log","","import (","\t\"fmt\"","\t\"strings\"","\t\"sync\"","\t\"time\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/pods\"","\ttaskrunpkg \"github.com/tektoncd/cli/pkg/taskrun\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/fields\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","const (","\tMsgTRNotFoundErr = \"Unable to get TaskRun\"",")","","type step struct {","\tname      string","\tcontainer string","\tstate     corev1.ContainerState","}","","func (s *step) hasStarted() bool {","\treturn s.state.Waiting == nil","}","","func (r *Reader) readTaskLog() (\u003c-chan Log, \u003c-chan error, error) {","\ttr, err := taskrunpkg.GetTaskRun(taskrunGroupResource, r.clients, r.run, r.ns)","\tif err != nil {","\t\treturn nil, nil, fmt.Errorf(\"%s: %s\", MsgTRNotFoundErr, err)","\t}","","\tr.formTaskName(tr)","","\tif !tr.IsDone() \u0026\u0026 r.follow {","\t\treturn r.readLiveTaskLogs(tr)","\t}","\treturn r.readAvailableTaskLogs(tr)","}","","func (r *Reader) formTaskName(tr *v1.TaskRun) {","\tif r.task != \"\" {","\t\treturn","\t}","","\tif name, ok := tr.Labels[\"tekton.dev/pipelineTask\"]; ok {","\t\tr.task = name","\t\treturn","\t}","","\tif tr.Spec.TaskRef != nil {","\t\tr.task = tr.Spec.TaskRef.Name","\t\treturn","\t}","","\tr.task = fmt.Sprintf(\"Task %d\", r.number)","}","","func (r *Reader) readLiveTaskLogs(tr *v1.TaskRun) (\u003c-chan Log, \u003c-chan error, error) {","\tpodC, podErrC, err := r.getTaskRunPodNames(tr)","\tif err != nil {","\t\treturn nil, nil, err","\t}","\tlogC, errC := r.readPodLogs(podC, podErrC, r.follow, r.timestamps)","\treturn logC, errC, nil","}","","func (r *Reader) readAvailableTaskLogs(tr *v1.TaskRun) (\u003c-chan Log, \u003c-chan error, error) {","\tif !tr.HasStarted() {","\t\treturn nil, nil, fmt.Errorf(\"task %s has not started yet\", r.task)","\t}","","\t// Check if taskrun failed on start up","\tif err := hasTaskRunFailed(tr, r.task); err != nil {","\t\tif r.stream != nil {","\t\t\tfmt.Fprintf(r.stream.Err, \"%s\\n\", err.Error())","\t\t} else {","\t\t\treturn nil, nil, err","\t\t}","\t}","","\tif tr.Status.PodName == \"\" {","\t\treturn nil, nil, fmt.Errorf(\"pod for taskrun %s not available yet\", tr.Name)","\t}","","\tpodC := make(chan string)","\tgo func() {","\t\tdefer close(podC)","\t\tif tr.Status.PodName != \"\" {","\t\t\tif len(tr.Status.RetriesStatus) != 0 {","\t\t\t\tfor _, retryStatus := range tr.Status.RetriesStatus {","\t\t\t\t\tpodC \u003c- retryStatus.PodName","\t\t\t\t}","\t\t\t}","\t\t\tpodC \u003c- tr.Status.PodName","\t\t}","\t}()","","\tlogC, errC := r.readPodLogs(podC, nil, false, r.timestamps)","\treturn logC, errC, nil","}","","func (r *Reader) readStepsLogs(logC chan\u003c- Log, errC chan\u003c- error, steps []*step, pod *pods.Pod, follow, timestamps bool) {","\tfor _, step := range steps {","\t\tif !follow \u0026\u0026 !step.hasStarted() {","\t\t\tcontinue","\t\t}","","\t\tcontainer := pod.Container(step.container)","\t\tcontainerLogC, containerLogErrC, err := container.LogReader(follow, timestamps).Read()","\t\tif err != nil {","\t\t\terrC \u003c- fmt.Errorf(\"error in getting logs for step %s: %s\", step.name, err)","\t\t\tcontinue","\t\t}","","\t\tfor containerLogC != nil || containerLogErrC != nil {","\t\t\tselect {","\t\t\tcase l, ok := \u003c-containerLogC:","\t\t\t\tif !ok {","\t\t\t\t\tcontainerLogC = nil","\t\t\t\t\tlogC \u003c- Log{Task: r.task, Step: step.name, Log: \"EOFLOG\"}","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tlogC \u003c- Log{Task: r.task, Step: step.name, Log: l.Log}","","\t\t\tcase e, ok := \u003c-containerLogErrC:","\t\t\t\tif !ok {","\t\t\t\t\tcontainerLogErrC = nil","\t\t\t\t\tcontinue","\t\t\t\t}","","\t\t\t\terrC \u003c- fmt.Errorf(\"failed to get logs for %s: %s\", step.name, e)","\t\t\t}","\t\t}","","\t\tif err := container.Status(); err != nil {","\t\t\terrC \u003c- err","\t\t\treturn","\t\t}","\t}","}","","func (r *Reader) readPodLogs(podC \u003c-chan string, podErrC \u003c-chan error, follow, timestamps bool) (\u003c-chan Log, \u003c-chan error) {","\tlogC := make(chan Log)","\terrC := make(chan error)","\tvar wg sync.WaitGroup","","\twg.Add(1)","\tgo func() {","\t\t// forward pod error to error stream","\t\tif podErrC != nil {","\t\t\tfor podErr := range podErrC {","\t\t\t\terrC \u003c- podErr","\t\t\t}","\t\t}","\t\twg.Done()","","\t\t// wait for all goroutines to close before closing errC channel","\t\twg.Wait()","\t\tclose(errC)","\t}()","","\twg.Add(1)","\tgo func() {","\t\tdefer func() {","\t\t\tclose(logC)","\t\t\twg.Done()","\t\t}()","","\t\tfor podName := range podC {","\t\t\tp := pods.New(podName, r.ns, r.clients.Kube, r.streamer)","\t\t\tvar pod *corev1.Pod","\t\t\tvar err error","","\t\t\tif follow {","\t\t\t\tpod, err = p.Wait()","\t\t\t} else {","\t\t\t\tpod, err = p.Get()","\t\t\t}","\t\t\tif err != nil {","\t\t\t\terrC \u003c- fmt.Errorf(\"task %s failed: %s. Run tkn tr desc %s for more details\", r.task, strings.TrimSpace(err.Error()), r.run)","\t\t\t\tcontinue","\t\t\t}","\t\t\tsteps := filterSteps(pod, r.allSteps, r.steps)","\t\t\tif len(steps) == 0 {","\t\t\t\terrC \u003c- fmt.Errorf(\"no steps found for task %s\", r.task)","\t\t\t\tcontinue","\t\t\t}","\t\t\tr.readStepsLogs(logC, errC, steps, p, follow, timestamps)","\t\t}","\t}()","","\treturn logC, errC","}","","// Reading of logs should wait until the name of the pod is","// updated in the status. Open a watch channel on the task run","// and keep checking the status until the taskrun completes","// or the timeout is reached.","func (r *Reader) getTaskRunPodNames(run *v1.TaskRun) (\u003c-chan string, \u003c-chan error, error) {","\topts := metav1.ListOptions{","\t\tFieldSelector: fields.OneTermEqualSelector(\"metadata.name\", r.run).String(),","\t}","","\twatchRun, err := actions.Watch(taskrunGroupResource, r.clients, r.ns, opts)","\tif err != nil {","\t\treturn nil, nil, err","\t}","","\tpodC := make(chan string)","\terrC := make(chan error)","","\tgo func() {","\t\tdefer func() {","\t\t\tclose(podC)","\t\t\tclose(errC)","\t\t\twatchRun.Stop()","\t\t}()","","\t\tpodMap := make(map[string]bool)","\t\taddPod := func(name string) {","\t\t\tif _, ok := podMap[name]; !ok {","\t\t\t\tpodMap[name] = true","\t\t\t\tpodC \u003c- name","\t\t\t}","\t\t}","","\t\tif len(run.Status.RetriesStatus) != 0 {","\t\t\tfor _, retryStatus := range run.Status.RetriesStatus {","\t\t\t\taddPod(retryStatus.PodName)","\t\t\t}","\t\t}","\t\tif run.Status.PodName != \"\" {","\t\t\taddPod(run.Status.PodName)","\t\t}","","\t\ttimeout := time.After(r.activityTimeout)","","\t\tfor {","\t\t\tselect {","\t\t\tcase event := \u003c-watchRun.ResultChan():","\t\t\t\tvar err error","\t\t\t\trun, err = cast2taskrun(event.Object)","\t\t\t\tif err != nil {","\t\t\t\t\terrC \u003c- err","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\tif run.Status.PodName != \"\" {","\t\t\t\t\taddPod(run.Status.PodName)","\t\t\t\t\tif !areRetriesScheduled(run, r.retries) {","\t\t\t\t\t\treturn","\t\t\t\t\t}","\t\t\t\t}","\t\t\tcase \u003c-timeout:","\t\t\t\t// Check if taskrun failed on start up","\t\t\t\tif err := hasTaskRunFailed(run, r.task); err != nil {","\t\t\t\t\terrC \u003c- err","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\t// check if pod has been started and has a name","\t\t\t\tif run.HasStarted() \u0026\u0026 run.Status.PodName != \"\" {","\t\t\t\t\tif areRetriesScheduled(run, r.retries) {","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\terrC \u003c- fmt.Errorf(\"task %s has not started yet or pod for task not yet available\", r.task)","\t\t\t\treturn","\t\t\t}","\t\t}","\t}()","","\treturn podC, errC, nil","}","","func filterSteps(pod *corev1.Pod, allSteps bool, stepsGiven []string) []*step {","\tsteps := []*step{}","\tif pod == nil {","\t\tfmt.Printf(\"pod not found\")","\t\treturn steps","\t}","\tstepsInPod := getSteps(pod)","","\tif allSteps {","\t\tsteps = append(steps, getInitSteps(pod)...)","\t}","","\tif len(stepsGiven) == 0 {","\t\tsteps = append(steps, stepsInPod...)","\t\treturn steps","\t}","","\tstepsToAdd := map[string]bool{}","\tfor _, s := range stepsGiven {","\t\tstepsToAdd[s] = true","\t}","","\tfor _, sp := range stepsInPod {","\t\tif stepsToAdd[sp.name] {","\t\t\tsteps = append(steps, sp)","\t\t}","\t}","","\treturn steps","}","","func getInitSteps(pod *corev1.Pod) []*step {","\tstatus := map[string]corev1.ContainerState{}","\tfor _, ics := range pod.Status.InitContainerStatuses {","\t\tstatus[ics.Name] = ics.State","\t}","","\tsteps := []*step{}","\tfor _, ic := range pod.Spec.InitContainers {","\t\tsteps = append(steps, \u0026step{","\t\t\tname:      strings.TrimPrefix(ic.Name, \"step-\"),","\t\t\tcontainer: ic.Name,","\t\t\tstate:     status[ic.Name],","\t\t})","\t}","","\treturn steps","}","","func getSteps(pod *corev1.Pod) []*step {","\tstatus := map[string]corev1.ContainerState{}","\tfor _, cs := range pod.Status.ContainerStatuses {","\t\tstatus[cs.Name] = cs.State","\t}","","\tsteps := []*step{}","\tfor _, c := range pod.Spec.Containers {","\t\tsteps = append(steps, \u0026step{","\t\t\tname:      strings.TrimPrefix(c.Name, \"step-\"),","\t\t\tcontainer: c.Name,","\t\t\tstate:     status[c.Name],","\t\t})","\t}","","\treturn steps","}","","func hasTaskRunFailed(tr *v1.TaskRun, taskName string) error {","\tif isFailure(tr) {","\t\treturn fmt.Errorf(\"task %s has failed: %s\", taskName, tr.Status.Conditions[0].Message)","\t}","\treturn nil","}","","func cast2taskrun(obj runtime.Object) (*v1.TaskRun, error) {","\tvar run *v1.TaskRun","\tunstruct, err := runtime.DefaultUnstructuredConverter.ToUnstructured(obj)","\tif err != nil {","\t\treturn nil, err","\t}","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstruct, \u0026run); err != nil {","\t\treturn nil, err","\t}","\treturn run, nil","}","","func isFailure(tr *v1.TaskRun) bool {","\tconditions := tr.Status.Conditions","\treturn len(conditions) != 0 \u0026\u0026 conditions[0].Status == corev1.ConditionFalse","}","","func areRetriesScheduled(tr *v1.TaskRun, retries int) bool {","\tif tr.IsDone() {","\t\treturn false","\t}","\tretriesDone := len(tr.Status.RetriesStatus)","\treturn retriesDone \u003c retries","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,0]},{"id":39,"path":"pkg/log/writer.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package log","","import (","\t\"fmt\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/formatted\"",")","","// Writer helps logging pod\"s log","type Writer struct {","\tfmt       *formatted.Color","\tlogType   string","\tprefixing bool","}","","// NewWriter returns the new instance of LogWriter","func NewWriter(logType string, prefixing bool) *Writer {","\treturn \u0026Writer{","\t\tfmt:       formatted.NewColor(),","\t\tlogType:   logType,","\t\tprefixing: prefixing,","\t}","}","","// Write formatted pod's logs","func (lw *Writer) Write(s *cli.Stream, logC \u003c-chan Log, errC \u003c-chan error) {","\tfor logC != nil || errC != nil {","\t\tselect {","\t\tcase l, ok := \u003c-logC:","\t\t\tif !ok {","\t\t\t\tlogC = nil","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif l.Log == \"EOFLOG\" {","\t\t\t\tfmt.Fprintf(s.Out, \"\\n\")","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif lw.prefixing {","\t\t\t\tswitch lw.logType {","\t\t\t\tcase LogTypePipeline:","\t\t\t\t\tlw.fmt.Rainbow.Fprintf(l.Step, s.Out, \"[%s : %s] \", l.Task, l.Step)","\t\t\t\tcase LogTypeTask:","\t\t\t\t\tlw.fmt.Rainbow.Fprintf(l.Step, s.Out, \"[%s] \", l.Step)","\t\t\t\t}","\t\t\t}","","\t\t\tfmt.Fprintf(s.Out, \"%s\\n\", l.Log)","\t\tcase e, ok := \u003c-errC:","\t\t\tif !ok {","\t\t\t\terrC = nil","\t\t\t\tcontinue","\t\t\t}","\t\t\tlw.fmt.Error(s.Err, \"%s\\n\", e)","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,0]},{"id":40,"path":"pkg/names/formats.go","lines":["package names","","import (","\t\"fmt\"","\t\"strings\"",")","","func QuotedList(names []string) string {","\tquoted := make([]string, len(names))","\tfor i := range names {","\t\tquoted[i] = fmt.Sprintf(\"%q\", names[i])","\t}","\treturn strings.Join(quoted, \", \")","}"],"coverage":[0,0,0,0,0,0,0,1,1,1,1,1,1,0]},{"id":41,"path":"pkg/options/delete.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package options","","import (","\t\"bufio\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/names\"",")","","type DeleteOptions struct {","\tResource                 string","\tParentResource           string","\tParentResourceName       string","\tForceDelete              bool","\tDeleteRelated            bool","\tDeleteAllNs              bool","\tDeleteAll                bool","\tKeep                     int","\tKeepSince                int","\tIgnoreRunning            bool","\tIgnoreRunningPipelinerun bool","\tLabelSelector            string","}","","func (o *DeleteOptions) CheckOptions(s *cli.Stream, resourceNames []string, ns string) error {","\tnamesLen := len(resourceNames)","","\t// make sure no resource names are provided when using --keep flag","\tif namesLen \u003e 0 \u0026\u0026 o.Keep \u003e 0 {","\t\treturn fmt.Errorf(\"--keep flag should not have any arguments specified with it\")","\t}","","\t// make sure no resource names are provided when using --all flag","\tif namesLen \u003e 0 \u0026\u0026 (o.DeleteAllNs || o.DeleteAll) || (o.DeleteAllNs \u0026\u0026 o.DeleteRelated) {","\t\treturn fmt.Errorf(\"--all flag should not have any arguments or flags specified with it\")","\t}","","\t// make sure either resource names are provided, name of related resource,","\t// or --all specified if deleting PipelineRuns or TaskRuns","\tif namesLen == 0 \u0026\u0026 o.ParentResource != \"\" \u0026\u0026 o.ParentResourceName == \"\" \u0026\u0026 !o.DeleteAllNs {","\t\treturn fmt.Errorf(\"must provide %s name(s) or use --%s flag or --all flag to use delete\", o.Resource, strings.ToLower(o.ParentResource))","\t}","","\t// make sure that resource name or --all flag is specified to use delete","\t// in non PipelineRun or TaskRun deletions","\tif namesLen == 0 \u0026\u0026 o.ParentResource == \"\" \u0026\u0026 o.ParentResourceName == \"\" \u0026\u0026 !o.DeleteAllNs \u0026\u0026 !o.DeleteAll {","\t\treturn fmt.Errorf(\"must provide %s name(s) or use --all flag with delete\", o.Resource)","\t}","","\tif o.ForceDelete {","\t\treturn nil","\t}","","\tformattedNames := names.QuotedList(resourceNames)","","\tkeepStr := \"\"","\tif o.Keep \u003e 0 {","\t\tkeepStr = fmt.Sprintf(\" keeping %d %ss\", o.Keep, o.Resource)","\t}","\tif o.KeepSince \u003e 0 {","\t\tkeepStr = fmt.Sprintf(\" except for ones created in last %d minutes\", o.KeepSince)","\t}","\tif o.Keep \u003e 0 \u0026\u0026 o.KeepSince \u003e 0 {","\t\tkeepStr = fmt.Sprintf(\" except for ones created in last %d minutes and keeping %d %ss\", o.KeepSince, o.Keep, o.Resource)","\t}","\tswitch {","\tcase o.DeleteAllNs:","\t\tfmt.Fprintf(s.Out, \"Are you sure you want to delete all %ss in namespace %q%s (y/n): \", o.Resource, ns, keepStr)","\tcase o.DeleteAll:","\t\tfmt.Fprintf(s.Out, \"Are you sure you want to delete all %ss%s (y/n): \", o.Resource, keepStr)","\tcase o.ParentResource != \"\" \u0026\u0026 o.ParentResourceName != \"\":","\t\tfmt.Fprintf(s.Out, \"Are you sure you want to delete all %ss related to %s %q%s (y/n): \", o.Resource, o.ParentResource, o.ParentResourceName, keepStr)","\tcase o.DeleteRelated:","\t\tfmt.Fprintf(s.Out, \"Are you sure you want to delete %s(s) %s and related resources (y/n): \", o.Resource, formattedNames)","\tdefault:","\t\tfmt.Fprintf(s.Out, \"Are you sure you want to delete %s(s) %s (y/n): \", o.Resource, formattedNames)","\t}","","\treturn o.TakeInput(s, formattedNames)","}","","func (o *DeleteOptions) TakeInput(s *cli.Stream, formattedNames string) error {","\tscanner := bufio.NewScanner(s.In)","\tfor scanner.Scan() {","\t\tt := strings.TrimSpace(scanner.Text())","\t\tif t == \"y\" {","\t\t\treturn nil","\t\t} else if t == \"n\" {","\t\t\treturn fmt.Errorf(\"canceled deleting %s(s) %s\", o.Resource, formattedNames)","\t\t}","\t\tfmt.Fprint(s.Out, \"Please enter (y/n): \")","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,2,2,2,0,0,0,2,2,2,0,0,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0,0,2,2,2,2,2,2,2,2,2,1,0,1,0]},{"id":42,"path":"pkg/options/describe.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package options","","import (","\t\"bytes\"","\t\"fmt\"","\t\"os\"","\t\"strings\"","","\t\"github.com/AlecAivazis/survey/v2\"","\t\"github.com/AlecAivazis/survey/v2/terminal\"","\t\"github.com/fatih/color\"","\t\"github.com/ktr0731/go-fuzzyfinder\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tpipelinerunpkg \"github.com/tektoncd/cli/pkg/pipelinerun\"","\ttaskrunpkg \"github.com/tektoncd/cli/pkg/taskrun\"",")","","type DescribeOptions struct {","\tParams                    cli.Params","\tPipelineName              string","\tPipelineRunName           string","\tTaskName                  string","\tTaskrunName               string","\tTasks                     []string","\tTriggerTemplateName       string","\tTriggerBindingName        string","\tEventListenerName         string","\tClusterTriggerBindingName string","\tLimit                     int","\tAskOpts                   survey.AskOpt","\tFzf                       bool","\tLast                      bool","}","","func NewDescribeOptions(p cli.Params) *DescribeOptions {","\treturn \u0026DescribeOptions{Params: p,","\t\tAskOpts: func(opt *survey.AskOptions) error {","\t\t\topt.Stdio = terminal.Stdio{","\t\t\t\tIn:  os.Stdin,","\t\t\t\tOut: os.Stdout,","\t\t\t\tErr: os.Stderr,","\t\t\t}","\t\t\treturn nil","\t\t},","\t}","}","","func (opts *DescribeOptions) ValidateOpts() error {","\tif opts.Limit \u003c= 0 {","\t\treturn fmt.Errorf(\"limit was %d but must be a positive number\", opts.Limit)","\t}","\treturn nil","}","","func (opts *DescribeOptions) Ask(resource string, options []string) error {","\tvar ans string","\tvar qs = []*survey.Question{","\t\t{","\t\t\tName: resource,","\t\t\tPrompt: \u0026survey.Select{","\t\t\t\tMessage: fmt.Sprintf(\"Select %s:\", resource),","\t\t\t\tOptions: options,","\t\t\t},","\t\t},","\t}","","\tif err := survey.Ask(qs, \u0026ans, opts.AskOpts); err != nil {","\t\treturn err","\t}","","\t// The Resource constants are defined in resource_names.go","\tswitch resource {","\tcase ResourceNamePipeline:","\t\topts.PipelineName = ans","\tcase ResourceNamePipelineRun:","\t\topts.PipelineRunName = strings.Fields(ans)[0]","\tcase ResourceNameTask:","\t\topts.TaskName = ans","\tcase ResourceNameTaskRun:","\t\topts.TaskrunName = strings.Fields(ans)[0]","\tcase ResourceNameTriggerTemplate:","\t\topts.TriggerTemplateName = ans","\tcase ResourceNameTriggerBinding:","\t\topts.TriggerBindingName = ans","\tcase ResourceNameClusterTriggerBinding:","\t\topts.ClusterTriggerBindingName = ans","\tcase ResourceNameEventListener:","\t\topts.EventListenerName = ans","\t}","","\treturn nil","}","","func (opts *DescribeOptions) FuzzyAsk(resource string, options []string) error {","\tchosencolouring := color.NoColor","\tdefer func() {","\t\tcolor.NoColor = chosencolouring","\t}()","\t// Remove colors as fuzzyfinder doesn't support it","\tcolor.NoColor = true","","\tidx, err := fuzzyfinder.FindMulti(options,","\t\tfunc(i int) string {","\t\t\treturn strings.Fields(options[i])[0]","\t\t},","\t\tfuzzyfinder.WithPreviewWindow(func(i, _, _ int) string {","\t\t\tif i == -1 {","\t\t\t\treturn \"\"","\t\t\t}","","\t\t\tbuf := new(bytes.Buffer)","\t\t\ts := cli.Stream{","\t\t\t\tOut: buf,","\t\t\t}","","\t\t\tbname := strings.Fields(options[i])[0]","\t\t\tcs, err := opts.Params.Clients()","\t\t\tif err != nil {","\t\t\t\treturn fmt.Sprintf(\"Cannot initialize client: %s\", err.Error())","\t\t\t}","\t\t\tswitch resource {","\t\t\tcase ResourceNameTaskRun:","\t\t\t\terr := taskrunpkg.PrintTaskRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())","\t\t\t\tif err != nil {","\t\t\t\t\treturn fmt.Sprintf(\"Cannot get taskrun description for %s: %s\", bname, err.Error())","\t\t\t\t}","\t\t\tcase ResourceNamePipelineRun:","\t\t\t\terr = pipelinerunpkg.PrintPipelineRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())","\t\t\t\tif err != nil {","\t\t\t\t\treturn fmt.Sprintf(\"Cannot get pipelinerun description for %s: %s\", bname, err.Error())","\t\t\t\t}","\t\t\t}","\t\t\treturn buf.String()","\t\t}))","\tif err != nil {","\t\treturn err","\t}","\tans := options[idx[0]]","\tfmt.Println(ans)","\tswitch resource {","\tcase ResourceNamePipeline:","\t\topts.PipelineName = ans","\tcase ResourceNamePipelineRun:","\t\topts.PipelineRunName = strings.Fields(ans)[0]","\tcase ResourceNameTask:","\t\topts.TaskName = ans","\tcase ResourceNameTaskRun:","\t\topts.TaskrunName = strings.Fields(ans)[0]","\tcase ResourceNameTriggerTemplate:","\t\topts.TriggerTemplateName = ans","\tcase ResourceNameTriggerBinding:","\t\topts.TriggerBindingName = ans","\tcase ResourceNameClusterTriggerBinding:","\t\topts.ClusterTriggerBindingName = ans","\tcase ResourceNameEventListener:","\t\topts.EventListenerName = ans","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0]},{"id":43,"path":"pkg/options/logs.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package options","","import (","\t\"bytes\"","\t\"fmt\"","\t\"os\"","\t\"strings\"","\t\"time\"","","\t\"github.com/AlecAivazis/survey/v2\"","\t\"github.com/AlecAivazis/survey/v2/terminal\"","\t\"github.com/fatih/color\"","\t\"github.com/ktr0731/go-fuzzyfinder\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tpipelinerunpkg \"github.com/tektoncd/cli/pkg/pipelinerun\"","\t\"github.com/tektoncd/cli/pkg/pods/stream\"","\ttaskrunpkg \"github.com/tektoncd/cli/pkg/taskrun\"",")","","type LogOptions struct {","\tAllSteps        bool","\tFollow          bool","\tParams          cli.Params","\tPipelineName    string","\tPipelineRunName string","\tTaskName        string","\tTaskrunName     string","\tStream          *cli.Stream","\tStreamer        stream.NewStreamerFunc","\tTasks           []string","\tSteps           []string","\tLast            bool","\tLimit           int","\tAskOpts         survey.AskOpt","\tFzf             bool","\tTail            int64","\tTimestamps      bool","\tPrefixing       bool","\tExitWithPrError bool","\t// ActivityTimeout is the amount of time to wait for some activity","\t// (e.g. Pod ready) before giving up.","\tActivityTimeout time.Duration","}","","func NewLogOptions(p cli.Params) *LogOptions {","\treturn \u0026LogOptions{Params: p,","\t\tAskOpts: func(opt *survey.AskOptions) error {","\t\t\topt.Stdio = terminal.Stdio{","\t\t\t\tIn:  os.Stdin,","\t\t\t\tOut: os.Stdout,","\t\t\t\tErr: os.Stderr,","\t\t\t}","\t\t\treturn nil","\t\t},","\t}","}","","func (opts *LogOptions) ValidateOpts() error {","\tif opts.Limit \u003c= 0 {","\t\treturn fmt.Errorf(\"limit was %d but must be a positive number\", opts.Limit)","\t}","\treturn nil","}","","func (opts *LogOptions) Ask(resource string, options []string) error {","\tvar ans string","\tvar qs = []*survey.Question{","\t\t{","\t\t\tName: resource,","\t\t\tPrompt: \u0026survey.Select{","\t\t\t\tMessage: fmt.Sprintf(\"Select %s:\", resource),","\t\t\t\tOptions: options,","\t\t\t},","\t\t},","\t}","","\tif err := survey.Ask(qs, \u0026ans, opts.AskOpts); err != nil {","\t\treturn err","\t}","","\tswitch resource {","\tcase ResourceNamePipeline:","\t\topts.PipelineName = ans","\tcase ResourceNamePipelineRun:","\t\topts.PipelineRunName = strings.Fields(ans)[0]","\tcase ResourceNameTask:","\t\topts.TaskName = ans","\tcase ResourceNameTaskRun:","\t\topts.TaskrunName = strings.Fields(ans)[0]","\t}","","\treturn nil","}","","func (opts *LogOptions) FuzzyAsk(resource string, options []string) error {","\tchosencolouring := color.NoColor","\tdefer func() {","\t\tcolor.NoColor = chosencolouring","\t}()","\t// Remove colors as fuzzyfinder doesn't support it!","\tcolor.NoColor = true","","\tidx, err := fuzzyfinder.FindMulti(options,","\t\tfunc(i int) string {","\t\t\treturn strings.Fields(options[i])[0]","\t\t},","\t\tfuzzyfinder.WithPreviewWindow(func(i, _, _ int) string {","\t\t\tif i == -1 {","\t\t\t\treturn \"\"","\t\t\t}","","\t\t\tbuf := new(bytes.Buffer)","\t\t\ts := cli.Stream{","\t\t\t\tOut: buf,","\t\t\t}","","\t\t\tbname := strings.Fields(options[i])[0]","\t\t\tcs, err := opts.Params.Clients()","\t\t\tif err != nil {","\t\t\t\treturn fmt.Sprintf(\"Cannot initialize client: %s\", err.Error())","\t\t\t}","\t\t\tswitch resource {","\t\t\tcase ResourceNameTaskRun:","\t\t\t\terr := taskrunpkg.PrintTaskRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())","\t\t\t\tif err != nil {","\t\t\t\t\treturn fmt.Sprintf(\"Cannot get taskrun description for %s: %s\", bname, err.Error())","\t\t\t\t}","\t\t\tcase ResourceNamePipelineRun:","\t\t\t\terr = pipelinerunpkg.PrintPipelineRunDescription(s.Out, cs, opts.Params.Namespace(), bname, opts.Params.Time())","\t\t\t\tif err != nil {","\t\t\t\t\treturn fmt.Sprintf(\"Cannot get pipelinerun description for %s: %s\", bname, err.Error())","\t\t\t\t}","\t\t\t}","\t\t\treturn buf.String()","\t\t}))","\tif err != nil {","\t\treturn err","\t}","\tans := options[idx[0]]","\tswitch resource {","\tcase ResourceNamePipeline:","\t\topts.PipelineName = ans","\tcase ResourceNamePipelineRun:","\t\topts.PipelineRunName = strings.Fields(ans)[0]","\tcase ResourceNameTask:","\t\topts.TaskName = ans","\tcase ResourceNameTaskRun:","\t\topts.TaskrunName = strings.Fields(ans)[0]","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,0,0,2,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0]},{"id":44,"path":"pkg/options/start.go","lines":["package options","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/AlecAivazis/survey/v2\"","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/task\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var taskrunGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"taskruns\"}","","type InteractiveOpts struct {","\tStream                *cli.Stream","\tCliParams             cli.Params","\tInputResources        []string","\tOutputResources       []string","\tParams                []string","\tWorkspaces            []string","\tAskOpts               survey.AskOpt","\tNs                    string","\tSkipOptionalWorkspace bool","}","","type TaskRunOpts struct {","\tCliParams  cli.Params","\tLast       bool","\tUseTaskRun string","\tPrefixName string","}","","func (taskRunOpts *TaskRunOpts) UseTaskRunFrom(tr *v1beta1.TaskRun, cs *cli.Clients, tname string, taskKind string) error {","\tvar (","\t\ttrUsed *v1beta1.TaskRun","\t\terr    error","\t)","\tif taskRunOpts.Last {","\t\tname, err := task.LastRunName(cs, tname, taskRunOpts.CliParams.Namespace(), taskKind)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\ttrUsed, err = getTaskRunV1beta1(taskrunGroupResource, cs, name, taskRunOpts.CliParams.Namespace())","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t} else if taskRunOpts.UseTaskRun != \"\" {","\t\ttrUsed, err = getTaskRunV1beta1(taskrunGroupResource, cs, taskRunOpts.UseTaskRun, taskRunOpts.CliParams.Namespace())","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\tif trUsed.Spec.TaskRef.Kind != v1beta1.TaskKind(taskKind) {","\t\treturn fmt.Errorf(\"%s doesn't belong to %s of kind %s\", trUsed.ObjectMeta.Name, tname, taskKind)","\t}","","\tif len(trUsed.ObjectMeta.GenerateName) \u003e 0 \u0026\u0026 taskRunOpts.PrefixName == \"\" {","\t\ttr.ObjectMeta.GenerateName = trUsed.ObjectMeta.GenerateName","\t} else if taskRunOpts.PrefixName == \"\" {","\t\ttr.ObjectMeta.GenerateName = trUsed.ObjectMeta.Name + \"-\"","\t}","\t// Copy over spec from last or previous TaskRun to use same values for this TaskRun","\ttr.Spec = trUsed.Spec","\t// Reapply blank status in case TaskRun used was cancelled","\ttr.Spec.Status = \"\"","\treturn nil","}","","func (intOpts *InteractiveOpts) TaskParams(task *v1beta1.Task, skipParams map[string]string, useParamDefaults bool) error {","\tfor _, param := range task.Spec.Params {","\t\tif param.Default == nil \u0026\u0026 useParamDefaults || !useParamDefaults {","\t\t\tif _, toSkip := skipParams[param.Name]; toSkip {","\t\t\t\tcontinue","\t\t\t}","\t\t\tvar ans, ques, defaultValue string","\t\t\tques = fmt.Sprintf(\"Value for param `%s` of type `%s`?\", param.Name, param.Type)","\t\t\tinput := \u0026survey.Input{}","\t\t\tif param.Default != nil {","\t\t\t\tif param.Type == \"string\" {","\t\t\t\t\tdefaultValue = param.Default.StringVal","\t\t\t\t}","\t\t\t\tif param.Type == \"array\" {","\t\t\t\t\tdefaultValue = strings.Join(param.Default.ArrayVal, \",\")","\t\t\t\t}","\t\t\t\tif param.Type == \"object\" {","\t\t\t\t\tdefaultValue = fmt.Sprintf(\"%+v\", param.Default.ObjectVal)","\t\t\t\t}","\t\t\t\tques += fmt.Sprintf(\" (Default is `%s`)\", defaultValue)","\t\t\t\tinput.Default = defaultValue","\t\t\t}","\t\t\tinput.Message = ques","","\t\t\tvar qs = []*survey.Question{","\t\t\t\t{","\t\t\t\t\tName:   \"pipeline param\",","\t\t\t\t\tPrompt: input,","\t\t\t\t},","\t\t\t}","","\t\t\tif err := survey.Ask(qs, \u0026ans, intOpts.AskOpts); err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\tintOpts.Params = append(intOpts.Params, param.Name+\"=\"+ans)","\t\t}","","\t}","\treturn nil","}","","func (intOpts *InteractiveOpts) TaskWorkspaces(task *v1beta1.Task) error {","\tfor _, ws := range task.Spec.Workspaces {","\t\tif ws.Optional \u0026\u0026 intOpts.SkipOptionalWorkspace {","\t\t\tcontinue","\t\t}","\t\tif ws.Optional {","\t\t\tisOptional, err := askParam(fmt.Sprintf(\"Do you want to give specifications for the optional workspace `%s`: (y/N)\", ws.Name), intOpts.AskOpts)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tif strings.ToLower(isOptional) == \"n\" {","\t\t\t\tcontinue","\t\t\t}","\t\t}","\t\tfmt.Fprintf(intOpts.Stream.Out, \"Please give specifications for the workspace: %s \\n\", ws.Name)","\t\tname, err := askParam(\"Name for the workspace :\", intOpts.AskOpts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tworkspace := \"name=\" + name","\t\tsubPath, err := askParam(\"Value of the Sub Path :\", intOpts.AskOpts, \" \")","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif subPath != \" \" {","\t\t\tworkspace = workspace + \",subPath=\" + subPath","\t\t}","","\t\tvar kind string","\t\tvar qs = []*survey.Question{","\t\t\t{","\t\t\t\tName: \"workspace param\",","\t\t\t\tPrompt: \u0026survey.Select{","\t\t\t\t\tMessage: \"Type of the Workspace :\",","\t\t\t\t\tOptions: []string{\"config\", \"emptyDir\", \"secret\", \"pvc\"},","\t\t\t\t\tDefault: \"emptyDir\",","\t\t\t\t},","\t\t\t},","\t\t}","\t\tif err := survey.Ask(qs, \u0026kind, intOpts.AskOpts); err != nil {","\t\t\treturn err","\t\t}","\t\tswitch kind {","\t\tcase \"pvc\":","\t\t\tclaimName, err := askParam(\"Value of Claim Name :\", intOpts.AskOpts)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tworkspace = workspace + \",claimName=\" + claimName","\t\tcase \"emptyDir\":","\t\t\tkind, err := askParam(\"Type of EmptyDir :\", intOpts.AskOpts, \"\")","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tworkspace = workspace + \",emptyDir=\" + kind","\t\tcase \"config\":","\t\t\tconfig, err := askParam(\"Name of the configmap :\", intOpts.AskOpts)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tworkspace = workspace + \",config=\" + config","\t\t\titems, err := getItems(intOpts.AskOpts)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tworkspace += items","\t\tcase \"secret\":","\t\t\tsecret, err := askParam(\"Name of the secret :\", intOpts.AskOpts)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tworkspace = workspace + \",secret=\" + secret","\t\t\titems, err := getItems(intOpts.AskOpts)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tworkspace += items","\t\t}","\t\tintOpts.Workspaces = append(intOpts.Workspaces, workspace)","","\t}","\treturn nil","}","","func getItems(askOpts survey.AskOpt) (string, error) {","\tvar items string","\tfor {","\t\tit, err := askParam(\"Item Value:\", askOpts, \" \")","\t\tif err != nil {","\t\t\treturn \"\", err","\t\t}","\t\tif it != \" \" {","\t\t\titems = items + \",item=\" + it","\t\t} else {","\t\t\treturn items, nil","\t\t}","\t}","}","","func askParam(ques string, askOpts survey.AskOpt, def ...string) (string, error) {","\tvar ans string","\tinput := \u0026survey.Input{","\t\tMessage: ques,","\t}","\tif len(def) != 0 {","\t\tinput.Default = def[0]","\t}","","\tvar qs = []*survey.Question{","\t\t{","\t\t\tName:   \"workspace param\",","\t\t\tPrompt: input,","\t\t},","\t}","\tif err := survey.Ask(qs, \u0026ans, askOpts); err != nil {","\t\treturn \"\", err","\t}","","\treturn ans, nil","}","","func getTaskRunV1beta1(gr schema.GroupVersionResource, c *cli.Clients, trName, ns string) (*v1beta1.TaskRun, error) {","\tvar taskrun v1beta1.TaskRun","\tgvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tif gvr.Version == \"v1beta1\" {","\t\terr := actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, \u0026taskrun)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn \u0026taskrun, nil","\t}","","\tvar taskrunV1 v1.TaskRun","\terr = actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, \u0026taskrunV1)","\tif err != nil {","\t\treturn nil, err","\t}","\terr = taskrun.ConvertFrom(context.Background(), \u0026taskrunV1)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn \u0026taskrun, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":45,"path":"pkg/params/mergeparams.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package params","","import (","\t\"errors\"","\t\"fmt\"","\t\"sort\"","\t\"strings\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"",")","","const invalidParam = \"invalid input format for param parameter: \"","","var paramByType = map[string]v1beta1.ParamType{}","","func MergeParam(p []v1beta1.Param, optPar []string) ([]v1beta1.Param, error) {","\tparams, err := parseParam(optPar)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif len(params) == 0 {","\t\treturn p, nil","\t}","","\tfor i := range p {","\t\tif v, ok := params[p[i].Name]; ok {","\t\t\tp[i] = v","\t\t\tdelete(params, v.Name)","\t\t}","\t}","","\tfor _, v := range params {","\t\tp = append(p, v)","\t}","\tsort.Slice(p, func(i, j int) bool { return p[i].Name \u003c p[j].Name })","\treturn p, nil","}","","func parseParam(p []string) (map[string]v1beta1.Param, error) {","\tparams := map[string]v1beta1.Param{}","\tfor _, v := range p {","\t\tr := strings.SplitN(v, \"=\", 2)","\t\tif len(r) != 2 {","\t\t\treturn nil, errors.New(invalidParam + v)","\t\t}","","\t\tif _, ok := paramByType[r[0]]; !ok {","\t\t\treturn nil, fmt.Errorf(\"param '%s' not present in spec\", r[0])","\t\t}","","\t\tparam := v1beta1.Param{","\t\t\tName: r[0],","\t\t\tValue: v1beta1.ParamValue{","\t\t\t\tType: paramByType[r[0]],","\t\t\t},","\t\t}","","\t\tif paramByType[r[0]] == \"string\" {","\t\t\tparam.Value.StringVal = r[1]","\t\t}","","\t\tif paramByType[r[0]] == \"array\" {","\t\t\tif len(r[1]) == 0 {","\t\t\t\tparam.Value.ArrayVal = make([]string, 0)","\t\t\t} else {","\t\t\t\tparam.Value.ArrayVal = strings.Split(r[1], \",\")","\t\t\t}","\t\t}","","\t\tif paramByType[r[0]] == \"object\" {","\t\t\tfields := strings.Split(r[1], \",\")","\t\t\tobject := map[string]string{}","\t\t\tfor _, field := range fields {","\t\t\t\tr := strings.SplitN(field, \":\", 2)","\t\t\t\tif len(r) != 2 {","\t\t\t\t\treturn nil, errors.New(invalidParam + v)","\t\t\t\t}","\t\t\t\tobject[strings.TrimSpace(r[0])] = strings.TrimSpace(r[1])","\t\t\t}","\t\t\tparam.Value.ObjectVal = object","\t\t}","\t\tparams[r[0]] = param","\t}","\treturn params, nil","}","","func FilterParamsByType(params []v1beta1.ParamSpec) {","\tfor _, p := range params {","\t\tif p.Type == \"string\" {","\t\t\tparamByType[p.Name] = v1beta1.ParamTypeString","\t\t\tcontinue","\t\t}","\t\tif p.Type == \"array\" {","\t\t\tparamByType[p.Name] = v1beta1.ParamTypeArray","\t\t\tcontinue","\t\t}","\t\tparamByType[p.Name] = v1beta1.ParamTypeObject","\t}","}","","// ParseParams parse the params and return as map","func ParseParams(params []string) (map[string]string, error) {","\tparsedParams := make(map[string]string)","\tfor _, p := range params {","\t\tr := strings.SplitN(p, \"=\", 2)","\t\tif len(r) != 2 {","\t\t\treturn nil, errors.New(invalidParam + p)","\t\t}","\t\tkey := strings.TrimSpace(r[0])","\t\tval := strings.TrimSpace(r[1])","\t\tif key == \"\" {","\t\t\treturn nil, errors.New(invalidParam + p)","\t\t}","\t\tparsedParams[key] = val","\t}","\treturn parsedParams, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,0,0,2,1,1,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,2,0,2,0,2,0,2,0,0,2,2,2,2,2,0,2,2,2,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0]},{"id":46,"path":"pkg/params/validation.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package params","","import (","\t\"fmt\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\t\"k8s.io/apimachinery/pkg/util/sets\"",")","","var allowedParamTypes = sets.NewString(\"string\", \"array\", \"object\")","","func ValidateParamType(params []v1beta1.ParamSpec) error {","\tparamsWithInvalidType := make([]v1beta1.ParamSpec, 0)","\tfor _, param := range params {","\t\tif !allowedParamTypes.Has(string(param.Type)) {","\t\t\tparamsWithInvalidType = append(paramsWithInvalidType, param)","\t\t}","\t}","","\tif len(paramsWithInvalidType) \u003e 0 {","\t\terrString := \"params does not have a valid type -\"","\t\tfor _, param := range paramsWithInvalidType {","\t\t\terrString += fmt.Sprintf(\" '%s'\", param.Name)","\t\t}","\t\treturn fmt.Errorf(\"%s\", errString)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0]},{"id":47,"path":"pkg/pipeline/pipeline.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pipeline","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var pipelineGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"pipelines\"}","var pipelineRunGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"pipelineruns\"}","","func GetAllPipelineNames(gr schema.GroupVersionResource, c *cli.Clients, ns string) ([]string, error) {","\tvar pipelines *v1.PipelineList","\tif err := actions.ListV1(gr, c, metav1.ListOptions{}, ns, \u0026pipelines); err != nil {","\t\treturn nil, fmt.Errorf(\"failed to list Tasks from namespace %s: %v\", ns, err)","\t}","","\tret := []string{}","\tfor _, item := range pipelines.Items {","\t\tret = append(ret, item.ObjectMeta.Name)","\t}","\treturn ret, nil","}","","func GetPipeline(gr schema.GroupVersionResource, c *cli.Clients, pName, ns string) (*v1.Pipeline, error) {","\tvar pipeline v1.Pipeline","\tgvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tif gvr.Version == \"v1\" {","\t\terr := actions.GetV1(gr, c, pName, ns, metav1.GetOptions{}, \u0026pipeline)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn \u0026pipeline, nil","","\t}","","\tvar pipelineV1beta1 v1beta1.Pipeline","\terr = actions.GetV1(gr, c, pName, ns, metav1.GetOptions{}, \u0026pipelineV1beta1)","\tif err != nil {","\t\treturn nil, err","\t}","\terr = pipelineV1beta1.ConvertTo(context.Background(), \u0026pipeline)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn \u0026pipeline, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":48,"path":"pkg/pipeline/pipelinelastrun.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pipeline","","import (","\t\"fmt\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","// LastRun returns the name of last pipelinerun for a given pipeline","func LastRunName(cs *cli.Clients, resourceName, ns string) (string, error) {","\tlatest, err := LastRun(cs, resourceName, ns)","\tif err != nil {","\t\treturn \"\", err","\t}","\treturn latest.Name, nil","}","","// DynamicLastRun returns the last run for a given pipeline","func LastRun(cs *cli.Clients, pipeline string, ns string) (*v1.PipelineRun, error) {","\toptions := metav1.ListOptions{}","\tif pipeline != \"\" {","\t\toptions = metav1.ListOptions{","\t\t\tLabelSelector: fmt.Sprintf(\"tekton.dev/pipeline=%s\", pipeline),","\t\t}","\t}","","\tvar runs *v1.PipelineRunList","\terr := actions.ListV1(pipelineRunGroupResource, cs, options, ns, \u0026runs)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif len(runs.Items) == 0 {","\t\treturn nil, fmt.Errorf(\"no pipelineruns related to pipeline %s found in namespace %s\", pipeline, ns)","\t}","","\tlatest := runs.Items[0]","\tfor _, run := range runs.Items {","\t\tif run.CreationTimestamp.Time.After(latest.CreationTimestamp.Time) {","\t\t\tlatest = run","\t\t}","\t}","","\treturn \u0026latest, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,2,0,0,0,2,2,2,2,2,2,2,0,2,2,2,1,1,0,2,2,2,0,2,2,2,2,2,0,0,2,0]},{"id":49,"path":"pkg/pipelinerun/description.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pipelinerun","","import (","\t\"context\"","\t\"fmt\"","\t\"io\"","\t\"sort\"","\t\"strings\"","\t\"text/tabwriter\"","\t\"text/template\"","","\t\"github.com/jonboulle/clockwork\"","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/formatted\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","const describeTemplate = `{{decorate \"bold\" \"Name\"}}:\t{{ .PipelineRun.Name }}","{{decorate \"bold\" \"Namespace\"}}:\t{{ .PipelineRun.Namespace }}","{{- $pRefName := pipelineRefExists .PipelineRun.Spec }}{{- if ne $pRefName \"\" }}","{{decorate \"bold\" \"Pipeline Ref\"}}:\t{{ $pRefName }}","{{- end }}","{{- if ne .PipelineRun.Spec.TaskRunTemplate.ServiceAccountName \"\" }}","{{decorate \"bold\" \"Service Account\"}}:\t{{ .PipelineRun.Spec.TaskRunTemplate.ServiceAccountName }}","{{- end }}","","{{- $l := len .PipelineRun.Labels }}{{ if eq $l 0 }}","{{- else }}","{{decorate \"bold\" \"Labels\"}}:","{{- range $k, $v := .PipelineRun.Labels }}"," {{ $k }}={{ $v }}","{{- end }}","{{- end }}","{{- $annotations := removeLastAppliedConfig .PipelineRun.Annotations -}}","{{- if $annotations }}","{{decorate \"bold\" \"Annotations\"}}:","{{- range $k, $v := $annotations }}"," {{ $k }}={{ $v }}","{{- end }}","{{- end }}","","{{decorate \"status\" \"\"}}{{decorate \"underline bold\" \"Status\\n\"}}","STARTED\tDURATION\tSTATUS","{{ formatAge .PipelineRun.Status.StartTime  .Time }}\t{{ formatDuration .PipelineRun.Status.StartTime .PipelineRun.Status.CompletionTime }}\t{{ formatCondition .PipelineRun.Status.Conditions }}","{{- $msg := hasFailed .PipelineRun .TaskrunList -}}","{{-  if ne $msg \"\" }}","","{{decorate \"message\" \"\"}}{{decorate \"underline bold\" \"Message\\n\"}}","{{ $msg }}","{{- end }}","","","{{- if .PipelineRun.Spec.Timeouts }}","","{{decorate \"timeouts\" \"\"}}{{decorate \"underline bold\" \"Timeouts\"}}","{{- $timeout := .PipelineRun.Spec.Timeouts.Pipeline -}}","{{- if $timeout }}"," {{decorate \"bold\" \"Pipeline\"}}:\t{{ $timeout.Duration.String }}","{{- end }}","{{- $timeout := .PipelineRun.Spec.Timeouts.Tasks -}}","{{- if $timeout }}"," {{decorate \"bold\" \"Tasks\"}}:\t{{ $timeout.Duration.String }}","{{- end }}","{{- $timeout := .PipelineRun.Spec.Timeouts.Finally -}}","{{- if $timeout }}"," {{decorate \"bold\" \"Finally\"}}:\t{{ $timeout.Duration.String }}","{{- end }}","{{- end }}","","{{- if ne (len .PipelineRun.Spec.Params) 0 }}","","{{decorate \"params\" \"\"}}{{decorate \"underline bold\" \"Params\\n\"}}"," NAME\tVALUE","{{- range $i, $p := .PipelineRun.Spec.Params }}","{{- if eq $p.Value.Type \"string\" }}"," {{decorate \"bullet\" $p.Name }}\t{{ $p.Value.StringVal }}","{{- else if eq $p.Value.Type \"array\" }}"," {{decorate \"bullet\" $p.Name }}\t{{ $p.Value.ArrayVal }}","{{- else }}"," {{decorate \"bullet\" $p.Name }}\t{{ $p.Value.ObjectVal }}","{{- end }}","{{- end }}","{{- end }}","","{{- if ne (len .PipelineRun.Status.Results) 0 }}","","{{decorate \"results\" \"\"}}{{decorate \"underline bold\" \"Results\\n\"}}"," NAME\tVALUE","{{- range $result := .PipelineRun.Status.Results }}","{{- if eq $result.Value.Type \"string\" }}"," {{decorate \"bullet\" $result.Name }}\t{{ $result.Value.StringVal }}","{{- else }}"," {{decorate \"bullet\" $result.Name }}\t{{ $result.Value.ArrayVal }}","{{- end }}","{{- end }}","{{- end }}","","{{- if ne (len .PipelineRun.Spec.Workspaces) 0 }}","","{{decorate \"workspaces\" \"\"}}{{decorate \"underline bold\" \"Workspaces\\n\"}}"," NAME\tSUB PATH\tWORKSPACE BINDING","{{- range $workspace := .PipelineRun.Spec.Workspaces }}","{{- if not $workspace.SubPath }}"," {{ decorate \"bullet\" $workspace.Name }}\t{{ \"---\" }}\t{{ formatWorkspace $workspace }}","{{- else }}"," {{ decorate \"bullet\" $workspace.Name }}\t{{ $workspace.SubPath }}\t{{ formatWorkspace $workspace }}","{{- end }}","{{- end }}","{{- end }}","","{{- if ne (len .TaskrunList) 0 }}","","{{decorate \"taskruns\" \"\"}}{{decorate \"underline bold\" \"Taskruns\\n\"}}"," NAME\tTASK NAME\tSTARTED\tDURATION\tSTATUS","{{- range $taskrun := .TaskrunList }}{{ if checkTRStatus $taskrun }}"," {{decorate \"bullet\" $taskrun.TaskRunName }}\t{{ $taskrun.PipelineTaskName }}\t{{ formatAge $taskrun.Status.StartTime $.Time }}\t{{ formatDuration $taskrun.Status.StartTime $taskrun.Status.CompletionTime }}\t{{ formatCondition $taskrun.Status.Conditions }}","{{- end }}","{{- end }}","{{- end }}","","{{- if ne (len .PipelineRun.Status.SkippedTasks) 0 }}","","{{decorate \"skippedtasks\" \"\"}}{{decorate \"underline bold\" \"Skipped Tasks\\n\"}}"," NAME","{{- range $skippedTask := .PipelineRun.Status.SkippedTasks }}"," {{decorate \"bullet\" $skippedTask.Name }}","{{- end }}","{{- end }}","`","","type TaskRunWithStatus struct {","\tTaskRunName      string","\tPipelineTaskName string","\tStatus           *v1.TaskRunStatus","}","","type TaskRunWithStatusList []TaskRunWithStatus","","func (trs TaskRunWithStatusList) Len() int      { return len(trs) }","func (trs TaskRunWithStatusList) Swap(i, j int) { trs[i], trs[j] = trs[j], trs[i] }","func (trs TaskRunWithStatusList) Less(i, j int) bool {","\tif trs[j].Status == nil || trs[j].Status.StartTime == nil {","\t\treturn false","\t}","","\tif trs[i].Status == nil || trs[i].Status.StartTime == nil {","\t\treturn true","\t}","","\treturn trs[j].Status.StartTime.Before(trs[i].Status.StartTime)","}","","func PrintPipelineRunDescription(out io.Writer, c *cli.Clients, ns string, prName string, time clockwork.Clock) error {","\tpr, err := GetPipelineRun(pipelineRunGroupResource, c, prName, ns)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to find pipelinerun %q\", prName)","\t}","","\tvar taskRunList TaskRunWithStatusList","\tfor _, child := range pr.Status.ChildReferences {","\t\tif child.Kind == \"TaskRun\" {","\t\t\tvar tr *v1.TaskRun","\t\t\terr = actions.GetV1(taskrunGroupResource, c, child.Name, ns, metav1.GetOptions{}, \u0026tr)","\t\t\tif err != nil {","\t\t\t\treturn fmt.Errorf(\"failed to find get taskruns of the pipelineruns\")","\t\t\t}","\t\t\ttaskRunList = append(taskRunList, TaskRunWithStatus{","\t\t\t\ttr.Name,","\t\t\t\tchild.PipelineTaskName,","\t\t\t\t\u0026tr.Status,","\t\t\t})","\t\t}","\t}","","\tif len(taskRunList) != 0 {","\t\tsort.Sort(taskRunList)","\t}","","\tvar data = struct {","\t\tPipelineRun *v1.PipelineRun","\t\tTime        clockwork.Clock","\t\tTaskrunList TaskRunWithStatusList","\t}{","\t\tPipelineRun: pr,","\t\tTime:        time,","\t\tTaskrunList: taskRunList,","\t}","","\tfuncMap := template.FuncMap{","\t\t\"formatAge\":               formatted.Age,","\t\t\"formatDuration\":          formatted.Duration,","\t\t\"formatCondition\":         formatted.Condition,","\t\t\"formatWorkspace\":         formatted.Workspace,","\t\t\"hasFailed\":               hasFailed,","\t\t\"pipelineRefExists\":       formatted.PipelineRefExists,","\t\t\"decorate\":                formatted.DecorateAttr,","\t\t\"checkTRStatus\":           checkTaskRunStatus,","\t\t\"removeLastAppliedConfig\": formatted.RemoveLastAppliedConfig,","\t}","","\tw := tabwriter.NewWriter(out, 0, 5, 3, ' ', tabwriter.TabIndent)","\tt := template.Must(template.New(\"Describe Pipelinerun\").Funcs(funcMap).Parse(describeTemplate))","","\tif err = t.Execute(w, data); err != nil {","\t\treturn err","\t}","\treturn w.Flush()","}","","func GetPipelineRun(gr schema.GroupVersionResource, c *cli.Clients, prName, ns string) (*v1.PipelineRun, error) {","\tvar pipelinerun v1.PipelineRun","\tgvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tif gvr.Version == \"v1\" {","\t\terr := actions.GetV1(pipelineRunGroupResource, c, prName, ns, metav1.GetOptions{}, \u0026pipelinerun)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn \u0026pipelinerun, nil","\t}","","\tvar pipelinerunV1beta1 v1beta1.PipelineRun","\terr = actions.GetV1(pipelineRunGroupResource, c, prName, ns, metav1.GetOptions{}, \u0026pipelinerunV1beta1)","\tif err != nil {","\t\treturn nil, err","\t}","","\terr = pipelinerunV1beta1.ConvertTo(context.Background(), \u0026pipelinerun)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn \u0026pipelinerun, nil","}","","func hasFailed(pr *v1.PipelineRun, taskruns TaskRunWithStatusList) string {","\tif len(pr.Status.Conditions) == 0 {","\t\treturn \"\"","\t}","","\tif pr.Status.Conditions[0].Status == corev1.ConditionFalse {","\t\tvar trNames []string","\t\tfor _, taskrun := range taskruns {","\t\t\tif taskrun.Status == nil {","\t\t\t\tcontinue","\t\t\t}","\t\t\tif len(taskrun.Status.Conditions) == 0 {","\t\t\t\tcontinue","\t\t\t}","\t\t\tif taskrun.Status.Conditions[0].Status == corev1.ConditionFalse {","\t\t\t\ttrNames = append(trNames, taskrun.TaskRunName)","\t\t\t}","\t\t}","\t\tmessage := pr.Status.Conditions[0].Message","\t\tif len(trNames) != 0 {","\t\t\tsort.Strings(trNames)","\t\t\tmessage += fmt.Sprintf(\"\\nTaskRun(s) cancelled: %s\", strings.Join(trNames, \", \"))","\t\t}","\t\treturn message","\t}","\treturn \"\"","}","","func checkTaskRunStatus(taskRun TaskRunWithStatus) bool {","\treturn taskRun.Status != nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,0,2,2,1,1,0,2,2,2,2,1,0,2,1,0,2,2,2,0,2,2,2,2,2,2,0,1,0,0,1,1,1]},{"id":50,"path":"pkg/pipelinerun/pipelinerun.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pipelinerun","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","","\t\"github.com/jonboulle/clockwork\"","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/formatted\"","\tprsort \"github.com/tektoncd/cli/pkg/pipelinerun/sort\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var pipelineRunGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"pipelineruns\"}","var taskrunGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"taskruns\"}","","// GetAllPipelineRuns returns all pipelinesruns running in a namespace","func GetAllPipelineRuns(gr schema.GroupVersionResource, opts metav1.ListOptions, c *cli.Clients, ns string, limit int, time clockwork.Clock) ([]string, error) {","\tvar pipelineruns *v1.PipelineRunList","\tif err := actions.ListV1(gr, c, opts, ns, \u0026pipelineruns); err != nil {","\t\treturn nil, fmt.Errorf(\"failed to list PipelineRuns from namespace %s: %v\", ns, err)","\t}","","\trunslen := len(pipelineruns.Items)","\tif limit \u003e runslen {","\t\tlimit = runslen","\t}","","\tif runslen \u003e 1 {","\t\tprsort.SortByStartTime(pipelineruns.Items)","\t}","\tret := []string{}","\tfor i, run := range pipelineruns.Items {","\t\tif i \u003c limit {","\t\t\tret = append(ret, run.ObjectMeta.Name+\" started \"+formatted.Age(run.Status.StartTime, time))","\t\t}","\t}","\treturn ret, nil","}","","type patchStringValue struct {","\tOp    string `json:\"op\"`","\tPath  string `json:\"path\"`","\tValue string `json:\"value\"`","}","","func Cancel(c *cli.Clients, prname string, opts metav1.PatchOptions, cancelStatus, ns string) (*v1.PipelineRun, error) {","\tpayload := []patchStringValue{{","\t\tOp:    \"replace\",","\t\tPath:  \"/spec/status\",","\t\tValue: cancelStatus,","\t}}","","\tdata, _ := json.Marshal(payload)","\tprGroupResource := schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"pipelineruns\"}","\tvar pipelinerun *v1.PipelineRun","\terr := actions.Patch(prGroupResource, c, prname, data, opts, ns, \u0026pipelinerun)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn pipelinerun, nil","}","","// It will create the resource based on the api available.","func Create(c *cli.Clients, pr *v1beta1.PipelineRun, opts metav1.CreateOptions, ns string) (*v1beta1.PipelineRun, error) {","\tgvr, err := actions.GetGroupVersionResource(pipelineRunGroupResource, c.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tif gvr.Version == \"v1\" {","\t\tprv1 := v1.PipelineRun{}","\t\terr = pr.ConvertTo(context.Background(), \u0026prv1)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tprv1.Kind = \"PipelineRun\"","\t\tprv1.APIVersion = \"tekton.dev/v1\"","","\t\tobject, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(\u0026prv1)","\t\tunstructuredPR := \u0026unstructured.Unstructured{","\t\t\tObject: object,","\t\t}","\t\tnewUnstructuredPR, err := actions.Create(pipelineRunGroupResource, c, unstructuredPR, ns, opts)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tvar pipelinerun v1.PipelineRun","\t\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredPR.UnstructuredContent(), \u0026pipelinerun); err != nil {","\t\t\treturn nil, err","\t\t}","","\t\tpipelinerunv1beta1 := v1beta1.PipelineRun{}","\t\terr = pipelinerunv1beta1.ConvertFrom(context.Background(), \u0026pipelinerun)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tpipelinerunv1beta1.Kind = \"PipelineRun\"","\t\tpipelinerunv1beta1.APIVersion = \"tekton.dev/v1beta1\"","\t\treturn \u0026pipelinerunv1beta1, nil","\t}","","\tobject, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(pr)","\tunstructuredPR := \u0026unstructured.Unstructured{","\t\tObject: object,","\t}","","\tnewUnstructuredPR, err := actions.Create(pipelineRunGroupResource, c, unstructuredPR, ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar pipelinerun *v1beta1.PipelineRun","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredPR.UnstructuredContent(), \u0026pipelinerun); err != nil {","\t\treturn nil, err","\t}","","\treturn pipelinerun, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,2,2,2,1,1,0,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,1,1,0,2,2,1,1,0,2,0]},{"id":51,"path":"pkg/pipelinerun/sort/by_namespace.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pipelinerun","","import (","\t\"sort\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"",")","","func SortByNamespace(prs []v1.PipelineRun) {","\tsort.Sort(byNamespace(prs))","}","","type byNamespace []v1.PipelineRun","","func (prs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) {","\tlt, eq = ins \u003c jns, ins == jns","\treturn lt, eq","}","","func (prs byNamespace) Len() int      { return len(prs) }","func (prs byNamespace) Swap(i, j int) { prs[i], prs[j] = prs[j], prs[i] }","func (prs byNamespace) Less(i, j int) bool {","\tvar lt, eq bool","\tif lt, eq = prs.compareNamespace(prs[i].Namespace, prs[j].Namespace); eq {","\t\tif prs[j].Status.StartTime == nil {","\t\t\treturn false","\t\t}","\t\tif prs[i].Status.StartTime == nil {","\t\t\treturn true","\t\t}","\t\treturn prs[j].Status.StartTime.Before(prs[i].Status.StartTime)","\t}","\treturn lt","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,0,2,2,2,2,2,2,1,1,2,1,1,2,0,2,0]},{"id":52,"path":"pkg/pipelinerun/sort/by_start_time.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pipelinerun","","import (","\t\"sort\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"",")","","func SortByStartTime(prs []v1.PipelineRun) {","\tsort.Sort(byStartTime(prs))","}","","type byStartTime []v1.PipelineRun","","func (prs byStartTime) Len() int      { return len(prs) }","func (prs byStartTime) Swap(i, j int) { prs[i], prs[j] = prs[j], prs[i] }","func (prs byStartTime) Less(i, j int) bool {","\tif prs[j].Status.StartTime == nil {","\t\treturn false","\t}","\tif prs[i].Status.StartTime == nil {","\t\treturn true","\t}","\treturn prs[j].Status.StartTime.Before(prs[i].Status.StartTime)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,1,1,2,0]},{"id":53,"path":"pkg/pipelinerun/tracker.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pipelinerun","","import (","\t\"context\"","\t\"errors\"","\t\"sync\"","\t\"time\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\ttaskrunpkg \"github.com/tektoncd/cli/pkg/taskrun\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tinformers \"github.com/tektoncd/pipeline/pkg/client/informers/externalversions\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/fields\"","\t\"k8s.io/client-go/tools/cache\"",")","","// Tracker tracks the progress of a PipelineRun","type Tracker struct {","\tName         string","\tNs           string","\tClient       *cli.Clients","\tongoingTasks map[string]bool","}","","// NewTracker returns a new instance of Tracker","func NewTracker(name string, ns string, client *cli.Clients) *Tracker {","\treturn \u0026Tracker{","\t\tName:         name,","\t\tNs:           ns,","\t\tClient:       client,","\t\tongoingTasks: map[string]bool{},","\t}","}","","// Monitor to observe the progress of PipelineRun. It emits","// an event upon starting of a new Pipeline's Task.","// allowed containers the name of the Pipeline tasks, which used as filter","// limit the events to only those tasks","func (t *Tracker) Monitor(allowed []string) \u003c-chan []taskrunpkg.Run {","","\tfactory := informers.NewSharedInformerFactoryWithOptions(","\t\tt.Client.Tekton,","\t\ttime.Second*10,","\t\tinformers.WithNamespace(t.Ns),","\t\tinformers.WithTweakListOptions(pipelinerunOpts(t.Name)))","","\tgvr, _ := actions.GetGroupVersionResource(","\t\tpipelineRunGroupResource,","\t\tt.Client.Tekton.Discovery(),","\t)","","\tgenericInformer, _ := factory.ForResource(*gvr)","\tinformer := genericInformer.Informer()","","\t// Set a custom watch error handler that ignores context.Canceled errors","\t// to prevent \"Failed to watch\" log messages when the informer is stopped intentionally","\t_ = informer.SetWatchErrorHandlerWithContext(watchErrorHandler)","","\tmu := \u0026sync.Mutex{}","\tstopC := make(chan struct{})","\ttrC := make(chan []taskrunpkg.Run)","\tgo func() {","\t\t\u003c-stopC","\t\tclose(trC)","\t}()","","\teventHandler := func(obj interface{}) {","\t\tvar pipelinerunConverted v1.PipelineRun","\t\tpr, ok := obj.(*v1.PipelineRun)","\t\tif !ok || pr == nil {","\t\t\tprV1beta1, ok := obj.(*v1beta1.PipelineRun)","\t\t\tif !ok || prV1beta1 == nil {","\t\t\t\treturn","\t\t\t}","\t\t\tvar prv1 v1.PipelineRun","\t\t\terr := prV1beta1.ConvertTo(context.Background(), \u0026prv1)","\t\t\tif err != nil {","\t\t\t\treturn","\t\t\t}","\t\t\tpr = \u0026prv1","\t\t}","","\t\ttrsMap, err := GetTaskRunsWithStatus(pr, t.Client, t.Ns)","\t\tif err != nil {","\t\t\treturn","\t\t}","\t\tpr.DeepCopyInto(\u0026pipelinerunConverted)","\t\ttrC \u003c- t.findNewTaskruns(\u0026pipelinerunConverted, allowed, trsMap)","","\t\tif hasCompleted(\u0026pipelinerunConverted) {","\t\t\tclose(stopC) // should close trC","\t\t}","\t}","","\t_, err := informer.AddEventHandler(","\t\tcache.ResourceEventHandlerFuncs{","\t\t\tAddFunc: func(obj interface{}) {","\t\t\t\t// To ensure synchonization and checks is the stopC channel has received a signal to stop","\t\t\t\t// If it receives a signal then return and does nothing","\t\t\t\tmu.Lock()","\t\t\t\tdefer mu.Unlock()","\t\t\t\tselect {","\t\t\t\tcase \u003c-stopC:","\t\t\t\t\treturn","\t\t\t\tdefault:","\t\t\t\t\teventHandler(obj)","\t\t\t\t}","\t\t\t},","\t\t\tUpdateFunc: func(_, newObj interface{}) {","\t\t\t\tmu.Lock()","\t\t\t\tdefer mu.Unlock()","\t\t\t\tselect {","\t\t\t\tcase \u003c-stopC:","\t\t\t\t\treturn","\t\t\t\tdefault:","\t\t\t\t\teventHandler(newObj)","\t\t\t\t}","\t\t\t},","\t\t\tDeleteFunc: func(obj interface{}) {","\t\t\t\tmu.Lock()","\t\t\t\tdefer mu.Unlock()","\t\t\t\tselect {","\t\t\t\tcase \u003c-stopC:","\t\t\t\t\treturn","\t\t\t\tdefault:","\t\t\t\t\teventHandler(obj)","\t\t\t\t}","\t\t\t},","\t\t},","\t)","\tif err != nil {","\t\treturn nil","\t}","","\tfactory.Start(stopC)","\tfactory.WaitForCacheSync(stopC)","","\treturn trC","}","","func pipelinerunOpts(name string) func(opts *metav1.ListOptions) {","\treturn func(opts *metav1.ListOptions) {","\t\topts.FieldSelector = fields.OneTermEqualSelector(\"metadata.name\", name).String()","\t}","}","","// watchErrorHandler is a custom watch error handler that filters out context.Canceled errors","// to prevent \"Failed to watch\" log messages when the informer is stopped intentionally.","// Other errors are passed to the default handler.","func watchErrorHandler(ctx context.Context, r *cache.Reflector, err error) {","\tif !errors.Is(err, context.Canceled) {","\t\tcache.DefaultWatchErrorHandler(ctx, r, err)","\t}","}","","// handles changes to pipelinerun and pushes the Run information to the","// channel if the task is new and is in the allowed list of tasks","// returns true if the pipelinerun has finished","func (t *Tracker) findNewTaskruns(pr *v1.PipelineRun, allowed []string, trStatuses map[string]*v1.PipelineRunTaskRunStatus) []taskrunpkg.Run {","\tret := []taskrunpkg.Run{}","\tfor tr, trs := range trStatuses {","\t\tretries := 0","\t\tif pr.Status.PipelineSpec != nil {","\t\t\tfor _, pipelineTask := range pr.Status.PipelineSpec.Tasks {","\t\t\t\tif trs.PipelineTaskName == pipelineTask.Name {","\t\t\t\t\tretries = pipelineTask.Retries","\t\t\t\t}","\t\t\t}","\t\t}","\t\trun := taskrunpkg.Run{Name: tr, Task: trs.PipelineTaskName, Retries: retries}","","\t\tif t.loggingInProgress(tr) ||","\t\t\t!taskrunpkg.HasScheduled(trs) ||","\t\t\ttaskrunpkg.IsFiltered(run, allowed) {","\t\t\tcontinue","\t\t}","","\t\tt.ongoingTasks[tr] = true","\t\tret = append(ret, run)","\t}","","\treturn ret","}","","func hasCompleted(pr *v1.PipelineRun) bool {","\tif len(pr.Status.Conditions) == 0 {","\t\treturn false","\t}","\treturn pr.Status.Conditions[0].Status != corev1.ConditionUnknown","}","","func (t *Tracker) loggingInProgress(tr string) bool {","\t_, ok := t.ongoingTasks[tr]","\treturn ok","}","","func GetTaskRunsWithStatus(pr *v1.PipelineRun, c *cli.Clients, ns string) (map[string]*v1.PipelineRunTaskRunStatus, error) {","\t// If the PipelineRun is nil, just return","\tif pr == nil {","\t\treturn nil, nil","\t}","","\t// If there are no child references return the existing TaskRuns and Runs maps","\tif len(pr.Status.ChildReferences) == 0 {","\t\treturn map[string]*v1.PipelineRunTaskRunStatus{}, nil","\t}","","\ttrStatuses := make(map[string]*v1.PipelineRunTaskRunStatus)","\tfor _, cr := range pr.Status.ChildReferences {","\t\t//TODO: Needs to handle Run, CustomRun later","\t\tif cr.Kind == \"TaskRun\" {","\t\t\ttr, err := taskrunpkg.GetTaskRun(taskrunGroupResource, c, cr.Name, ns)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","","\t\t\ttrStatuses[cr.Name] = \u0026v1.PipelineRunTaskRunStatus{","\t\t\t\tPipelineTaskName: cr.PipelineTaskName,","\t\t\t\tStatus:           \u0026tr.Status,","\t\t\t}","","\t\t}","\t}","","\treturn trStatuses, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,2,2,1,1,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,1,1,2,2,0,0,2,2,2,2,1,1,2,2,0,0,1,1,1,1,1,1,1,1,0,0,0,0,2,1,1,0,2,2,2,2,0,0,2,2,2,2,0,0,0,0,0,2,2,1,1,0,0,0,0,0,2,2,2,2,2,1,1,1,1,0,0,2,2,2,2,2,2,0,0,2,2,0,0,2,0,0,2,2,1,1,2,0,0,2,2,2,2,0,2,2,2,1,1,0,0,2,1,1,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,0,0,0,2,0]},{"id":54,"path":"pkg/plugins/plugins.go","lines":["package plugins","","import (","\t\"fmt\"","\t\"os\"","\t\"os/exec\"","\t\"path/filepath\"","\t\"strings\"","","\t\"github.com/mitchellh/go-homedir\"",")","","const (","\tpluginDirEnv = \"TKN_PLUGINS_DIR\"","\tpluginDir    = \"~/.config/tkn/plugins\"","\ttknPrefix    = \"tkn-\"",")","","func getPluginDir() (string, error) {","\tdir := os.Getenv(pluginDirEnv)","\t// if TKN_PLUGINS_DIR is set, follow it","\tif dir != \"\" {","\t\treturn dir, nil","\t}","\t// Respect XDG_CONFIG_HOME if set","\tif xdgHome := os.Getenv(\"XDG_CONFIG_HOME\"); xdgHome != \"\" {","\t\treturn filepath.Join(xdgHome, \"tkn\", \"plugins\"), nil","\t}","\t// Fallback to default pluginDir (~/.config/tkn/plugins)","\treturn homedir.Expand(pluginDir)","}","","// Find a binary in plugin homedir directory or user paths.","func FindPlugin(pluginame string) (string, error) {","\tcmd := tknPrefix + pluginame","\tdir, _ := getPluginDir()","\tpath := filepath.Join(dir, cmd)","\t_, err := os.Stat(path)","\tif err == nil {","\t\t// Found in dir","\t\treturn path, nil","\t}","","\tpath, err = exec.LookPath(cmd)","\tif err == nil {","\t\treturn path, nil","\t}","","\treturn \"\", fmt.Errorf(\"cannot find plugin in path or %s: %s\", pluginDir, cmd)","}","","func GetAllTknPluginFromPaths() []string {","\tpluginlist := []string{}","\tpaths := filepath.SplitList(os.Getenv(\"PATH\"))","\tif dir, err := getPluginDir(); err == nil {","\t\tpaths = append(paths, dir)","\t}","\t// go over all paths in the PATH environment","\t// and add them to the completion command","\tfor _, path := range paths {","\t\t// list all files in path","\t\tfiles, err := os.ReadDir(path)","\t\tif err != nil {","\t\t\tcontinue","\t\t}","\t\t// add all files that start with tkn-","\t\tfor _, file := range files {","\t\t\tif strings.HasPrefix(file.Name(), tknPrefix) {","\t\t\t\tbasep := strings.TrimLeft(file.Name(), tknPrefix)","\t\t\t\tif contains(pluginlist, basep) {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tfpath := filepath.Join(path, file.Name())","\t\t\t\tinfo, err := os.Stat(fpath)","\t\t\t\tif err != nil {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tif info.Mode()\u00260o111 != 0 {","\t\t\t\t\tpluginlist = append(pluginlist, basep)","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\treturn pluginlist","}","","func contains(s []string, e string) bool {","\tfor _, a := range s {","\t\tif a == e {","\t\t\treturn true","\t\t}","\t}","\treturn false","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,2,2,2,0,1,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,1,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,0,2,2,2,2,1,0,2,2,2,1,0,2,2,2,0,0,0,2,0,0,2,2,1,1,1,0,2,0]},{"id":55,"path":"pkg/pods/container.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pods","","import (","\t\"bufio\"","\t\"fmt\"","\t\"io\"","","\t\"github.com/tektoncd/cli/pkg/pods/stream\"","\tcorev1 \"k8s.io/api/core/v1\"",")","","type Container struct {","\tname        string","\tNewStreamer stream.NewStreamerFunc","\tpod         *Pod","}","","func (c *Container) Status() error {","\tpod, err := c.pod.Get()","\tif err != nil {","\t\treturn err","\t}","","\tcontainer := c.name","\tfor _, cs := range pod.Status.ContainerStatuses {","\t\tif cs.Name != container {","\t\t\tcontinue","\t\t}","","\t\tif cs.State.Terminated != nil \u0026\u0026 cs.State.Terminated.ExitCode == 1 {","\t\t\tmsg := \"\"","","\t\t\tif cs.State.Terminated.Reason != \"\" \u0026\u0026 cs.State.Terminated.Reason != \"Error\" {","\t\t\t\tmsg = msg + \" : \" + cs.State.Terminated.Reason","\t\t\t}","","\t\t\tif cs.State.Terminated.Message != \"\" \u0026\u0026 cs.State.Terminated.Message != \"Error\" {","\t\t\t\tmsg = msg + \" : \" + cs.State.Terminated.Message","\t\t\t}","","\t\t\treturn fmt.Errorf(\"container %s has failed %s\", container, msg)","\t\t}","\t}","","\tfor _, cs := range pod.Status.InitContainerStatuses {","\t\tif cs.Name != container {","\t\t\tcontinue","\t\t}","","\t\tif cs.State.Terminated != nil \u0026\u0026 cs.State.Terminated.ExitCode == 1 {","\t\t\treturn fmt.Errorf(\"container %s has failed: %s\", container, cs.State.Terminated.Reason)","\t\t}","\t}","","\treturn nil","}","","// Log represents one log message from a pod","type Log struct {","\tPodName       string","\tContainerName string","\tLog           string","}","type LogReader struct {","\tcontainerName string","\tpod           *Pod","\tfollow        bool","\ttimestamps    bool","}","","func (c *Container) LogReader(follow, timestamps bool) *LogReader {","\treturn \u0026LogReader{c.name, c.pod, follow, timestamps}","}","","func (lr *LogReader) Read() (\u003c-chan Log, \u003c-chan error, error) {","\tpod := lr.pod","\topts := \u0026corev1.PodLogOptions{","\t\tFollow:     lr.follow,","\t\tContainer:  lr.containerName,","\t\tTimestamps: lr.timestamps,","\t}","","\tstream, err := pod.Stream(opts)","\tif err != nil {","\t\treturn nil, nil, fmt.Errorf(\"error getting logs for pod %s(%s) : %s\", pod.Name, lr.containerName, err)","\t}","","\tlogC := make(chan Log)","\terrC := make(chan error)","","\tgo func() {","\t\tdefer close(logC)","\t\tdefer close(errC)","\t\tdefer stream.Close()","","\t\tr := bufio.NewReader(stream)","\t\tfor {","\t\t\tline, _, err := r.ReadLine()","","\t\t\tif err != nil {","\t\t\t\tif err != io.EOF {","\t\t\t\t\terrC \u003c- err","\t\t\t\t}","\t\t\t\treturn","\t\t\t}","","\t\t\tlogC \u003c- Log{","\t\t\t\tPodName:       pod.Name,","\t\t\t\tContainerName: lr.containerName,","\t\t\t\tLog:           string(line),","\t\t\t}","\t\t}","\t}()","","\treturn logC, errC, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,2,0,0,0,2,0]},{"id":56,"path":"pkg/pods/fake/log.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package fake","","type Log struct {","\tPodName    string","\tContainers []Container","}","","func Logs(logs ...Log) []Log {","\tret := []Log{}","\tret = append(ret, logs...)","\treturn ret","}","","func Task(name string, containers ...Container) Log {","\treturn Log{","\t\tPodName:    name,","\t\tContainers: containers,","\t}","}","","func Step(name string, logs ...string) Container {","\treturn Container{","\t\tName: name,","\t\tLogs: logs,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1]},{"id":57,"path":"pkg/pods/fake/pod.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package fake","","func PodLog(name string, containers ...Container) Log {","\treturn Log{","\t\tPodName:    name,","\t\tContainers: containers,","\t}","}","","type Container struct {","\tName string","\tLogs []string","}","","func NewContainer(name string, logs ...string) Container {","\treturn Container{","\t\tName: name,","\t\tLogs: logs,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1]},{"id":58,"path":"pkg/pods/fake/stream.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package fake","","import (","\t\"fmt\"","\t\"io\"","\t\"strings\"","","\t\"github.com/tektoncd/cli/pkg/pods/stream\"","\tcorev1 \"k8s.io/api/core/v1\"","\ttypedv1 \"k8s.io/client-go/kubernetes/typed/core/v1\"",")","","type PodStream struct {","\tlogs []Log","\tpods typedv1.PodInterface","\tname string","\topts *corev1.PodLogOptions","}","","func (ps *PodStream) Stream() (io.ReadCloser, error) {","\tfor _, fl := range ps.logs {","\t\tif fl.PodName != ps.name {","\t\t\tcontinue","\t\t}","","\t\tfor _, c := range fl.Containers {","\t\t\tif c.Name == ps.opts.Container {","\t\t\t\tlog := strings.Join(c.Logs, \"\\n\")","\t\t\t\treturn io.NopCloser(strings.NewReader(log)), nil","\t\t\t}","\t\t}","\t}","","\treturn nil, fmt.Errorf(\"failed to stream container logs\")","}","","func Streamer(l []Log) stream.NewStreamerFunc {","\treturn func(pods typedv1.PodInterface, name string, opts *corev1.PodLogOptions) stream.Streamer {","\t\treturn \u0026PodStream{","\t\t\tlogs: l,","\t\t\tpods: pods,","\t\t\tname: name,","\t\t\topts: opts,","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,0]},{"id":59,"path":"pkg/pods/pod.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pods","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"sync\"","\t\"time\"","","\t\"github.com/tektoncd/cli/pkg/pods/stream\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/fields\"","\t\"k8s.io/client-go/informers\"","\tk8s \"k8s.io/client-go/kubernetes\"","\ttypedv1 \"k8s.io/client-go/kubernetes/typed/core/v1\"","\t\"k8s.io/client-go/tools/cache\"",")","","type Stream struct {","\tname string","\tpods typedv1.PodInterface","\topts *corev1.PodLogOptions","}","","func NewStream(pods typedv1.PodInterface, name string, opts *corev1.PodLogOptions) stream.Streamer {","\treturn \u0026Stream{name, pods, opts}","}","","// Stream Creates a stream object which allows reading the logs","func (s *Stream) Stream() (io.ReadCloser, error) {","\treturn s.pods.GetLogs(s.name, s.opts).Stream(context.Background())","}","","type Pod struct {","\tName     string","\tNs       string","\tKc       k8s.Interface","\tStreamer stream.NewStreamerFunc","}","","func New(name, ns string, client k8s.Interface, streamer stream.NewStreamerFunc) *Pod {","\treturn \u0026Pod{","\t\tName: name, Ns: ns,","\t\tKc:       client,","\t\tStreamer: streamer,","\t}","}","","func NewWithDefaults(name, ns string, client k8s.Interface) *Pod {","\treturn \u0026Pod{","\t\tName: name, Ns: ns,","\t\tKc:       client,","\t\tStreamer: NewStream,","\t}","}","","// podResult holds the result of pod status check","type podResult struct {","\tpod *corev1.Pod","\terr error","}","","// Wait wait for the pod to get up and running","func (p *Pod) Wait() (*corev1.Pod, error) {","\t// ensure pod exists before we actually check for it","\tif _, err := p.Get(); err != nil {","\t\treturn nil, err","\t}","","\tstopC := make(chan struct{})","\tmu := sync.Mutex{}","","\tvar result podResult","","\t// Start watcher in a goroutine","\tgo func() {","\t\tp.watcher(stopC, \u0026result, \u0026mu)","\t}()","","\t// Wait for stopC","\t\u003c-stopC","\treturn result.pod, result.err","}","","func (p *Pod) watcher(stopC chan struct{}, result *podResult, mu *sync.Mutex) {","\tfactory := informers.NewSharedInformerFactoryWithOptions(","\t\tp.Kc, time.Second*10,","\t\tinformers.WithNamespace(p.Ns),","\t\tinformers.WithTweakListOptions(podOpts(p.Name)))","","\tupdatePodStatus := func(obj interface{}) {","\t\tmu.Lock()","\t\tdefer mu.Unlock()","","\t\tpod, err := checkPodStatus(obj)","\t\tif pod != nil || err != nil {","\t\t\tresult.pod = pod","\t\t\tresult.err = err","\t\t\tclose(stopC)","\t\t}","\t}","","\tinformer := factory.Core().V1().Pods().Informer()","\t// Set a custom watch error handler that ignores context.Canceled errors","\t// to prevent \"Failed to watch\" log messages when the informer is stopped intentionally","\t_ = informer.SetWatchErrorHandlerWithContext(watchErrorHandler)","","\t_, err := informer.AddEventHandler(","\t\tcache.ResourceEventHandlerFuncs{","\t\t\tAddFunc: func(obj interface{}) {","\t\t\t\tselect {","\t\t\t\tcase \u003c-stopC:","\t\t\t\t\treturn","\t\t\t\tdefault:","\t\t\t\t\tupdatePodStatus(obj)","\t\t\t\t}","\t\t\t},","\t\t\tUpdateFunc: func(_, newObj interface{}) {","\t\t\t\tselect {","\t\t\t\tcase \u003c-stopC:","\t\t\t\t\treturn","\t\t\t\tdefault:","\t\t\t\t\tupdatePodStatus(newObj)","\t\t\t\t}","\t\t\t},","\t\t\tDeleteFunc: func(obj interface{}) {","\t\t\t\tselect {","\t\t\t\tcase \u003c-stopC:","\t\t\t\t\treturn","\t\t\t\tdefault:","\t\t\t\t\tupdatePodStatus(obj)","\t\t\t\t}","\t\t\t},","\t\t})","\tif err != nil {","\t\treturn","\t}","","\tfactory.Start(stopC)","\tfactory.WaitForCacheSync(stopC)","}","","func podOpts(name string) func(opts *metav1.ListOptions) {","\treturn func(opts *metav1.ListOptions) {","\t\topts.FieldSelector = fields.OneTermEqualSelector(\"metadata.name\", name).String()","\t}","}","","// watchErrorHandler is a custom watch error handler that filters out context.Canceled errors","// to prevent \"Failed to watch\" log messages when the informer is stopped intentionally.","// Other errors are passed to the default handler.","func watchErrorHandler(ctx context.Context, r *cache.Reflector, err error) {","\tif !errors.Is(err, context.Canceled) {","\t\tcache.DefaultWatchErrorHandler(ctx, r, err)","\t}","}","","func checkPodStatus(obj interface{}) (*corev1.Pod, error) {","\tpod, ok := obj.(*corev1.Pod)","\tif !ok {","\t\treturn nil, fmt.Errorf(\"failed to cast to pod object\")","\t}","","\tif pod.DeletionTimestamp != nil {","\t\treturn pod, fmt.Errorf(\"failed to run the pod %s \", pod.Name)","\t}","","\tif pod.Status.Phase == corev1.PodSucceeded ||","\t\tpod.Status.Phase == corev1.PodRunning ||","\t\tpod.Status.Phase == corev1.PodFailed {","\t\treturn pod, nil","\t}","","\t// Handle any issues with pulling images that may fail","\tfor _, c := range pod.Status.Conditions {","\t\tif c.Type == corev1.PodInitialized || c.Type == corev1.ContainersReady {","\t\t\tif c.Status == corev1.ConditionUnknown {","\t\t\t\treturn pod, fmt.Errorf(\"%s\", c.Message)","\t\t\t}","\t\t}","\t}","","\treturn nil, nil","}","","// Get gets the pod","func (p *Pod) Get() (*corev1.Pod, error) {","\treturn p.Kc.CoreV1().Pods(p.Ns).Get(context.Background(), p.Name, metav1.GetOptions{})","}","","// Container returns the an instance of Container","func (p *Pod) Container(c string) *Container {","\treturn \u0026Container{","\t\tname:        c,","\t\tpod:         p,","\t\tNewStreamer: p.Streamer,","\t}","}","","// Stream returns the stream object for given container and mode","// in order to fetch the logs","func (p *Pod) Stream(opt *corev1.PodLogOptions) (io.ReadCloser, error) {","\tpods := p.Kc.CoreV1().Pods(p.Ns)","\tif pods == nil {","\t\treturn nil, fmt.Errorf(\"error getting pods\")","\t}","","\treturn p.Streamer(pods, p.Name, opt).Stream()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,0,0,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,1,1,2,2,0,0,2,2,1,1,2,2,0,0,2,2,1,1,2,2,0,0,0,2,1,1,0,2,2,0,0,2,2,2,2,0,0,0,0,0,2,2,1,1,0,0,2,2,2,1,1,0,2,2,2,0,2,2,2,2,2,0,0,2,1,1,1,1,0,0,0,2,0,0,0,2,2,2,0,0,2,2,2,2,2,2,2,0,0,0,2,2,2,1,1,0,2,0]},{"id":60,"path":"pkg/pods/pod_template.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package pods","","import (","\t\"net/http\"","","\t\"github.com/tektoncd/cli/pkg/file\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/pod\"","\t\"sigs.k8s.io/yaml\"",")","","func ParsePodTemplate(httpClient http.Client, podTemplateLocation string, validate file.TypeValidator, errorMsg error) (pod.PodTemplate, error) {","\tpodTemplate := pod.PodTemplate{}","\tb, err := file.LoadFileContent(httpClient, podTemplateLocation, validate, errorMsg)","\tif err != nil {","\t\treturn podTemplate, err","\t}","","\tif err := yaml.UnmarshalStrict(b, \u0026podTemplate); err != nil {","\t\treturn podTemplate, err","\t}","","\treturn podTemplate, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,2,2,2,0,2,0]},{"id":61,"path":"pkg/suggestion/suggest.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package suggestion","","import (","\t\"fmt\"","\t\"strings\"","","\t\"github.com/spf13/cobra\"",")","","// SubcommandsRequiredWithSuggestions will ensure we have a subcommand provided by the user and augments it with","// suggestion for commands, alias and help on root command.","func SubcommandsRequiredWithSuggestions(cmd *cobra.Command, args []string) error {","\trequireMsg := \"unknown command \\\"%s\\\" for \\\"%s\\\"\"","\ttypedName := \"\"","\t// This will be triggered if cobra didn't find any subcommands.","\t// Find some suggestions.","\tvar suggestions []string","","\tif len(args) != 0 \u0026\u0026 !cmd.DisableSuggestions {","\t\ttypedName += args[0]","\t\tif cmd.SuggestionsMinimumDistance \u003c= 0 {","\t\t\tcmd.SuggestionsMinimumDistance = 2","\t\t}","\t\t// subcommand suggestions","\t\tsuggestions = cmd.SuggestionsFor(args[0])","","\t\t// subcommand alias suggestions (with distance, not exact)","\t\tfor _, c := range cmd.Commands() {","\t\t\tif c.IsAvailableCommand() {","\t\t\t\tcandidate := suggestsByPrefixOrLd(typedName, c.Name(), cmd.SuggestionsMinimumDistance)","\t\t\t\tif candidate == \"\" {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\t_, found := Find(suggestions, candidate)","\t\t\t\tif !found {","\t\t\t\t\tsuggestions = append(suggestions, candidate)","\t\t\t\t}","\t\t\t}","\t\t}","","\t\t// help for root command","\t\tif !cmd.HasParent() {","\t\t\tcandidate := suggestsByPrefixOrLd(typedName, \"help\", cmd.SuggestionsMinimumDistance)","\t\t\tif candidate != \"\" {","\t\t\t\tsuggestions = append(suggestions, candidate)","\t\t\t}","\t\t}","\t}","","\tvar suggestionsMsg string","\tif len(suggestions) \u003e 0 {","\t\tsuggestionsMsg += \"\\nDid you mean this?\\n\"","\t\tfor _, s := range suggestions {","\t\t\tsuggestionsMsg += fmt.Sprintf(\"\\t%v\\n\", s)","\t\t}","\t}","","\tif suggestionsMsg != \"\" {","\t\trequireMsg = fmt.Sprintf(\"%s\\n%s\", requireMsg, suggestionsMsg)","\t\treturn fmt.Errorf(requireMsg, typedName, cmd.CommandPath())","\t}","","\tif typedName == \"\" {","\t\treturn cmd.Help()","\t}","\treturn fmt.Errorf(\"command %s %s doesn't exist. Run %s help for available commands\", cmd.Name(), typedName, cmd.Root().Name())","}","","// suggestsByPrefixOrLd suggests a command by levenshtein distance or by prefix.","// It returns an empty string if nothing was found","func suggestsByPrefixOrLd(typedName, candidate string, minDistance int) string {","\tlevenshteinVariable := levenshteinDistance(typedName, candidate, true)","\tsuggestByLevenshtein := levenshteinVariable \u003c= minDistance","\tsuggestByPrefix := strings.HasPrefix(strings.ToLower(candidate), strings.ToLower(typedName))","\tif !suggestByLevenshtein \u0026\u0026 !suggestByPrefix {","\t\treturn \"\"","\t}","\treturn candidate","}","","// ld compares two strings and returns the levenshtein distance between them.","func levenshteinDistance(s, t string, ignoreCase bool) int {","\tif ignoreCase {","\t\ts = strings.ToLower(s)","\t\tt = strings.ToLower(t)","\t}","\td := make([][]int, len(s)+1)","\tfor i := range d {","\t\td[i] = make([]int, len(t)+1)","\t}","\tfor i := range d {","\t\td[i][0] = i","\t}","\tfor j := range d[0] {","\t\td[0][j] = j","\t}","\tfor j := 1; j \u003c= len(t); j++ {","\t\tfor i := 1; i \u003c= len(s); i++ {","\t\t\tif s[i-1] == t[j-1] {","\t\t\t\td[i][j] = d[i-1][j-1]","\t\t\t} else {","\t\t\t\tminCost := d[i-1][j]","\t\t\t\tif d[i][j-1] \u003c minCost {","\t\t\t\t\tminCost = d[i][j-1]","\t\t\t\t}","\t\t\t\tif d[i-1][j-1] \u003c minCost {","\t\t\t\t\tminCost = d[i-1][j-1]","\t\t\t\t}","\t\t\t\td[i][j] = minCost + 1","\t\t\t}","\t\t}","","\t}","\treturn d[len(s)][len(t)]","}","","// Find takes a slice and looks for an element in it. If found it will","// return it's key, otherwise it will return -1 and a bool of false.","func Find(slice []string, val string) (int, bool) {","\tfor i, item := range slice {","\t\tif item == val {","\t\t\treturn i, true","\t\t}","\t}","\treturn -1, false","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,2,1,1,0,0,0,0,2,2,2,1,1,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,0,1,1,1,1,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,0,0,0,0,2,2,2,2,2,0,1,0]},{"id":62,"path":"pkg/task/task.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package task","","import (","\t\"fmt\"","\t\"os\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var taskGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"tasks\"}","","func GetAllTaskNames(gr schema.GroupVersionResource, c *cli.Clients, ns string) ([]string, error) {","\tvar tasks *v1.TaskList","\tif err := actions.ListV1(gr, c, metav1.ListOptions{}, ns, \u0026tasks); err != nil {","\t\treturn nil, fmt.Errorf(\"failed to list Tasks from namespace %s: %v\", ns, err)","\t}","","\tret := []string{}","\tfor _, item := range tasks.Items {","\t\tret = append(ret, item.ObjectMeta.Name)","\t}","\treturn ret, nil","}","","// TODO: remove as all the function uses are moved to new func","// Get will fetch the task resource based on the task name","func Get(c *cli.Clients, taskname string, opts metav1.GetOptions, ns string) (*v1beta1.Task, error) {","\tunstructuredT, err := actions.Get(taskGroupResource, c.Dynamic, c.Tekton.Discovery(), taskname, ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar task *v1beta1.Task","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredT.UnstructuredContent(), \u0026task); err != nil {","\t\tfmt.Fprintf(os.Stderr, \"failed to get task from %s namespace \\n\", ns)","\t\treturn nil, err","\t}","\treturn task, nil","}","","func Create(c *cli.Clients, t *v1beta1.Task, opts metav1.CreateOptions, ns string) (*v1beta1.Task, error) {","\tobject, err := runtime.DefaultUnstructuredConverter.ToUnstructured(t)","\tif err != nil {","\t\treturn nil, err","\t}","\tunstructuredT := \u0026unstructured.Unstructured{","\t\tObject: object,","\t}","\tnewUnstructuredT, err := actions.Create(taskGroupResource, c, unstructuredT, ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","\tvar task *v1beta1.Task","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredT.UnstructuredContent(), \u0026task); err != nil {","\t\treturn nil, err","\t}","\treturn task, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,2,2,2,1,1,2,2,2,2,2,1,1,2,2,1,1,2,0]},{"id":63,"path":"pkg/task/tasklastrun.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package task","","import (","\t\"fmt\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var taskrunGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"taskruns\"}","","// LastRun returns the name of last taskrun for a given task","func LastRunName(cs *cli.Clients, resourceName, ns, kind string) (string, error) {","\tlatest, err := LastRun(cs, resourceName, ns, kind)","\tif err != nil {","\t\treturn \"\", err","\t}","\treturn latest.Name, nil","}","","// LastRun returns the last taskrun for a given task","func LastRun(cs *cli.Clients, resourceName, ns, kind string) (*v1.TaskRun, error) {","\toptions := metav1.ListOptions{}","","\tlabel := \"task\"","","\tif resourceName != \"\" {","\t\toptions = metav1.ListOptions{","\t\t\tLabelSelector: fmt.Sprintf(\"tekton.dev/%s=%s\", label, resourceName),","\t\t}","\t}","","\tvar trs *v1.TaskRunList","\tif err := actions.ListV1(taskrunGroupResource, cs, options, ns, \u0026trs); err != nil {","\t\treturn nil, err","\t}","","\tif len(trs.Items) == 0 {","\t\treturn nil, fmt.Errorf(\"no TaskRuns related to %s %s found in namespace %s\", kind, resourceName, ns)","\t}","","\tif kind == \"Task\" {","\t\ttrs.Items = FilterByRef(trs.Items, kind)","\t}","","\tlatest := trs.Items[0]","\tfor _, tr := range trs.Items {","\t\tif tr.CreationTimestamp.Time.After(latest.CreationTimestamp.Time) {","\t\t\tlatest = tr","\t\t}","\t}","","\treturn \u0026latest, nil","}","","// this will filter the taskrun which have reference to Task","func FilterByRef(taskruns []v1.TaskRun, kind string) []v1.TaskRun {","\tvar filtered []v1.TaskRun","\tfor _, taskrun := range taskruns {","\t\tif string(taskrun.Spec.TaskRef.Kind) == kind {","\t\t\tfiltered = append(filtered, taskrun)","\t\t}","\t}","\treturn filtered","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,1,1,0,2,2,2,0,2,2,2,0,2,2,2,2,2,0,0,2,0,0,0,2,2,2,2,2,2,0,2,0]},{"id":64,"path":"pkg/taskrun/create.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package taskrun","","import (","\t\"context\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","func Create(c *cli.Clients, tr *v1beta1.TaskRun, opts metav1.CreateOptions, ns string) (*v1beta1.TaskRun, error) {","\tgvr, err := actions.GetGroupVersionResource(taskrunGroupResource, c.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tif gvr.Version == \"v1\" {","\t\ttrv1 := v1.TaskRun{}","\t\terr = tr.ConvertTo(context.Background(), \u0026trv1)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\ttrv1.Kind = \"TaskRun\"","\t\ttrv1.APIVersion = \"tekton.dev/v1\"","","\t\tobject, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(\u0026trv1)","\t\tunstructuredTR := \u0026unstructured.Unstructured{","\t\t\tObject: object,","\t\t}","\t\tnewUnstructuredTR, err := actions.Create(taskrunGroupResource, c, unstructuredTR, ns, opts)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tvar taskrun v1.TaskRun","\t\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredTR.UnstructuredContent(), \u0026taskrun); err != nil {","\t\t\treturn nil, err","\t\t}","","\t\ttaskrunv1beta1 := v1beta1.TaskRun{}","\t\terr = taskrunv1beta1.ConvertFrom(context.Background(), \u0026taskrun)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\ttaskrunv1beta1.Kind = \"TaskRun\"","\t\ttaskrunv1beta1.APIVersion = \"tekton.dev/v1beta1\"","\t\treturn \u0026taskrunv1beta1, nil","\t}","","\tobject, _ := runtime.DefaultUnstructuredConverter.ToUnstructured(tr)","\tunstructuredTR := \u0026unstructured.Unstructured{","\t\tObject: object,","\t}","\tnewUnstructuredTR, err := actions.Create(taskrunGroupResource, c, unstructuredTR, ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","\tvar taskrun *v1beta1.TaskRun","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(newUnstructuredTR.UnstructuredContent(), \u0026taskrun); err != nil {","\t\treturn nil, err","\t}","\treturn taskrun, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":65,"path":"pkg/taskrun/description.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package taskrun","","import (","\t\"context\"","\t\"fmt\"","\t\"io\"","\t\"sort\"","\t\"text/tabwriter\"","\t\"text/template\"","","\t\"github.com/jonboulle/clockwork\"","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/formatted\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","const templ = `{{decorate \"bold\" \"Name\"}}:\t{{ .TaskRun.Name }}","{{decorate \"bold\" \"Namespace\"}}:\t{{ .TaskRun.Namespace }}","{{- $tRefName := taskRefExists .TaskRun.Spec }}{{- if ne $tRefName \"\" }}","{{decorate \"bold\" \"Task Ref\"}}:\t{{ $tRefName }}","{{- end }}","{{- if ne .TaskRun.Spec.ServiceAccountName \"\" }}","{{decorate \"bold\" \"Service Account\"}}:\t{{ .TaskRun.Spec.ServiceAccountName }}","{{- end }}","","{{- $timeout := getTimeout .TaskRun -}}","{{- if and (ne $timeout \"\") (ne $timeout \"0s\") }}","{{decorate \"bold\" \"Timeout\"}}:\t{{ .TaskRun.Spec.Timeout.Duration.String }}","{{- end }}","{{- $l := len .TaskRun.Labels }}{{ if eq $l 0 }}","{{- else }}","{{decorate \"bold\" \"Labels\"}}:","{{- range $k, $v := .TaskRun.Labels }}"," {{ $k }}={{ $v }}","{{- end }}","{{- end }}","{{- $annotations := removeLastAppliedConfig .TaskRun.Annotations -}}","{{- if $annotations }}","{{decorate \"bold\" \"Annotations\"}}:","{{- range $k, $v := $annotations }}"," {{ $k }}={{ $v }}","{{- end }}","{{- end }}","","{{decorate \"status\" \"\"}}{{decorate \"underline bold\" \"Status\"}}","","STARTED \tDURATION \tSTATUS","{{ formatAge .TaskRun.Status.StartTime  .Time }}\t{{ formatDuration .TaskRun.Status.StartTime .TaskRun.Status.CompletionTime }}\t{{ formatCondition .TaskRun.Status.Conditions }}","{{- $msg := hasFailed .TaskRun -}}","{{-  if ne $msg \"\" }}","","{{decorate \"underline bold\" \"Message\"}}","","{{ $msg }}","{{- end }}","","{{- if ne (len .TaskRun.Spec.Params) 0 }}","","{{decorate \"params\" \"\"}}{{decorate \"underline bold\" \"Params\"}}",""," NAME\tVALUE","{{- range $i, $p := .TaskRun.Spec.Params }}","{{- if eq $p.Value.Type \"string\" }}"," {{decorate \"bullet\" $p.Name }}\t{{ $p.Value.StringVal }}","{{- else if eq $p.Value.Type \"array\" }}"," {{decorate \"bullet\" $p.Name }}\t{{ $p.Value.ArrayVal }}","{{- else }}"," {{decorate \"bullet\" $p.Name }}\t{{ $p.Value.ObjectVal }}","{{- end }}","{{- end }}","{{- end }}","","{{- if ne (len .TaskRun.Status.Results) 0 }}","","{{decorate \"results\" \"\"}}{{decorate \"underline bold\" \"Results\"}}",""," NAME\tVALUE","{{- range $result := .TaskRun.Status.Results }}"," {{decorate \"bullet\" $result.Name }}\t{{ formatResult $result.Value }}","{{- end }}","{{- end }}","","{{- if ne (len .TaskRun.Spec.Workspaces) 0 }}","","{{decorate \"workspaces\" \"\"}}{{decorate \"underline bold\" \"Workspaces\"}}",""," NAME\tSUB PATH\tWORKSPACE BINDING","{{- range $workspace := .TaskRun.Spec.Workspaces }}","{{- if not $workspace.SubPath }}"," {{ decorate \"bullet\" $workspace.Name }}\t{{ \"---\" }}\t{{ formatWorkspace $workspace }}","{{- else }}"," {{ decorate \"bullet\" $workspace.Name }}\t{{ $workspace.SubPath }}\t{{ formatWorkspace $workspace }}","{{- end }}","{{- end }}","{{- end }}","","{{- $sortedSteps := sortStepStates .TaskRun.Status.Steps }}","{{- if ne (len $sortedSteps) 0 }}","","{{decorate \"steps\" \"\"}}{{decorate \"underline bold\" \"Steps\"}}",""," NAME\tSTATUS","{{- range $step := $sortedSteps }}","{{- $reason := stepReasonExists $step }}"," {{decorate \"bullet\" $step.Name }}\t{{ $reason }}","{{- end }}","{{- end }}","","{{- $sidecars := .TaskRun.Status.Sidecars }}","{{- if ne (len $sidecars) 0 }}","","{{decorate \"sidecars\" \"\"}}{{decorate \"underline bold\" \"Sidecars\"}}",""," NAME\tSTATUS","{{- range $sidecar := $sidecars }}","{{- $reason := sidecarReasonExists $sidecar }}"," {{decorate \"bullet\" $sidecar.Name }}\t{{ $reason }}","{{- end }}","{{- end }}","`","","func sortStepStatesByStartTime(steps []v1.StepState) []v1.StepState {","\tsort.Slice(steps, func(i, j int) bool {","\t\tif steps[j].Waiting != nil \u0026\u0026 steps[i].Waiting != nil {","\t\t\treturn false","\t\t}","","\t\tvar jStartTime metav1.Time","\t\tjRunning := false","\t\tvar iStartTime metav1.Time","\t\tiRunning := false","\t\tif steps[j].Terminated == nil {","\t\t\tif steps[j].Running != nil {","\t\t\t\tjStartTime = steps[j].Running.StartedAt","\t\t\t\tjRunning = true","\t\t\t} else {","\t\t\t\treturn true","\t\t\t}","\t\t}","","\t\tif steps[i].Terminated == nil {","\t\t\tif steps[i].Running != nil {","\t\t\t\tiStartTime = steps[i].Running.StartedAt","\t\t\t\tiRunning = true","\t\t\t} else {","\t\t\t\treturn false","\t\t\t}","\t\t}","","\t\tif !jRunning {","\t\t\tjStartTime = steps[j].Terminated.StartedAt","\t\t}","","\t\tif !iRunning {","\t\t\tiStartTime = steps[i].Terminated.StartedAt","\t\t}","","\t\treturn iStartTime.Before(\u0026jStartTime)","\t})","","\treturn steps","}","","func PrintTaskRunDescription(out io.Writer, c *cli.Clients, ns string, trName string, time clockwork.Clock) error {","\ttr, err := GetTaskRun(taskrunGroupResource, c, trName, ns)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to get TaskRun %s: %v\", trName, err)","\t}","","\tvar data = struct {","\t\tTaskRun *v1.TaskRun","\t\tTime    clockwork.Clock","\t}{","\t\tTaskRun: tr,","\t\tTime:    time,","\t}","","\tfuncMap := template.FuncMap{","\t\t\"formatAge\":               formatted.Age,","\t\t\"formatDuration\":          formatted.Duration,","\t\t\"formatCondition\":         formatted.Condition,","\t\t\"formatResult\":            formatted.Result,","\t\t\"formatWorkspace\":         formatted.Workspace,","\t\t\"hasFailed\":               hasFailed,","\t\t\"taskRefExists\":           formatted.TaskRefExists,","\t\t\"stepReasonExists\":        stepReasonExists,","\t\t\"sidecarReasonExists\":     sidecarReasonExists,","\t\t\"decorate\":                formatted.DecorateAttr,","\t\t\"sortStepStates\":          sortStepStatesByStartTime,","\t\t\"getTimeout\":              getTimeoutValue,","\t\t\"removeLastAppliedConfig\": formatted.RemoveLastAppliedConfig,","\t}","","\tw := tabwriter.NewWriter(out, 0, 5, 3, ' ', tabwriter.TabIndent)","\tt := template.Must(template.New(\"Describe TaskRun\").Funcs(funcMap).Parse(templ))","","\terr = t.Execute(w, data)","\tif err != nil {","\t\treturn err","\t}","\treturn w.Flush()","}","","func hasFailed(tr *v1.TaskRun) string {","\tif len(tr.Status.Conditions) == 0 {","\t\treturn \"\"","\t}","","\tif tr.Status.Conditions[0].Status == corev1.ConditionFalse {","\t\treturn tr.Status.Conditions[0].Message","\t}","","\treturn \"\"","}","","func getTimeoutValue(tr *v1.TaskRun) string {","\tif tr.Spec.Timeout != nil {","\t\treturn tr.Spec.Timeout.Duration.String()","\t}","\treturn \"\"","}","","// Check if step is in waiting, running, or terminated state by checking StepState of the step.","func stepReasonExists(state v1.StepState) string {","\tif state.Waiting == nil {","\t\tif state.Running != nil {","\t\t\treturn formatted.ColorStatus(\"Running\")","\t\t}","","\t\tif state.Terminated != nil {","\t\t\treturn formatted.ColorStatus(state.Terminated.Reason)","\t\t}","","\t\treturn formatted.ColorStatus(\"---\")","\t}","","\treturn formatted.ColorStatus(state.Waiting.Reason)","}","","// Check if sidecar is in waiting, running, or terminated state by checking SidecarState of the sidecar.","func sidecarReasonExists(state v1.SidecarState) string {","\tif state.Waiting == nil {","","\t\tif state.Running != nil {","\t\t\treturn formatted.ColorStatus(\"Running\")","\t\t}","","\t\tif state.Terminated != nil {","\t\t\treturn formatted.ColorStatus(state.Terminated.Reason)","\t\t}","","\t\treturn formatted.ColorStatus(\"---\")","\t}","","\treturn formatted.ColorStatus(state.Waiting.Reason)","}","","func GetTaskRun(gr schema.GroupVersionResource, c *cli.Clients, trName, ns string) (*v1.TaskRun, error) {","\tvar taskrun v1.TaskRun","\tgvr, err := actions.GetGroupVersionResource(gr, c.Tekton.Discovery())","\tif err != nil {","\t\treturn nil, err","\t}","","\tif gvr.Version == \"v1\" {","\t\terr := actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, \u0026taskrun)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn \u0026taskrun, nil","\t}","","\tvar taskrunV1beta1 v1beta1.TaskRun","\terr = actions.GetV1(gr, c, trName, ns, metav1.GetOptions{}, \u0026taskrunV1beta1)","\tif err != nil {","\t\treturn nil, err","\t}","","\terr = taskrunV1beta1.ConvertTo(context.Background(), \u0026taskrun)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn \u0026taskrun, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,0,2,0,0,2,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,2,2,2,2,2,0,2,2,2,0,2,0,0,2,0,0,0,2,2,2,2,2,2,0,2,2,2,0,2,0,0,2,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0]},{"id":66,"path":"pkg/taskrun/list.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package taskrun","","import (","\t\"fmt\"","","\t\"github.com/jonboulle/clockwork\"","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/cli/pkg/formatted\"","\ttrsort \"github.com/tektoncd/cli/pkg/taskrun/sort\"","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var taskrunGroupResource = schema.GroupVersionResource{Group: \"tekton.dev\", Resource: \"taskruns\"}","","func GetAllTaskRuns(gr schema.GroupVersionResource, opts metav1.ListOptions, c *cli.Clients, ns string, limit int, time clockwork.Clock) ([]string, error) {","\tvar taskruns *v1.TaskRunList","\tif err := actions.ListV1(gr, c, opts, ns, \u0026taskruns); err != nil {","\t\treturn nil, fmt.Errorf(\"failed to list TaskRuns from namespace %s: %v\", ns, err)","\t}","","\trunslen := len(taskruns.Items)","\tif limit \u003e runslen {","\t\tlimit = runslen","\t}","","\ttrsort.SortByStartTime(taskruns.Items)","\tret := []string{}","\tfor i, run := range taskruns.Items {","\t\tif i \u003c limit {","\t\t\tret = append(ret, run.ObjectMeta.Name+\" started \"+formatted.Age(run.Status.StartTime, time))","\t\t}","\t}","\treturn ret, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,0,2,2,2,2,2,2,0,2,0]},{"id":67,"path":"pkg/taskrun/sort/by_namespace.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package taskrun","","import (","\t\"sort\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"",")","","func SortByNamespace(trs []v1.TaskRun) {","\tsort.Sort(byNamespace(trs))","}","","type byNamespace []v1.TaskRun","","func (trs byNamespace) compareNamespace(ins, jns string) (lt, eq bool) {","\tlt, eq = ins \u003c jns, ins == jns","\treturn lt, eq","}","","func (trs byNamespace) Len() int      { return len(trs) }","func (trs byNamespace) Swap(i, j int) { trs[i], trs[j] = trs[j], trs[i] }","func (trs byNamespace) Less(i, j int) bool {","\tvar lt, eq bool","\tif lt, eq = trs.compareNamespace(trs[i].Namespace, trs[j].Namespace); eq {","\t\tif trs[j].Status.StartTime == nil {","\t\t\treturn false","\t\t}","\t\tif trs[i].Status.StartTime == nil {","\t\t\treturn true","\t\t}","\t\treturn trs[j].Status.StartTime.Before(trs[i].Status.StartTime)","\t}","\treturn lt","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,0,2,2,2,2,2,2,1,1,2,1,1,2,0,2,0]},{"id":68,"path":"pkg/taskrun/sort/by_start_time.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package taskrun","","import (","\t\"sort\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"",")","","func SortByStartTime(trs []v1.TaskRun) {","\tsort.Sort(byStartTime(trs))","}","","type byStartTime []v1.TaskRun","","func (trs byStartTime) Len() int      { return len(trs) }","func (trs byStartTime) Swap(i, j int) { trs[i], trs[j] = trs[j], trs[i] }","func (trs byStartTime) Less(i, j int) bool {","\tif trs[j].Status.StartTime == nil {","\t\treturn false","\t}","\tif trs[i].Status.StartTime == nil {","\t\treturn true","\t}","\treturn trs[j].Status.StartTime.Before(trs[i].Status.StartTime)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,1,1,2,0]},{"id":69,"path":"pkg/taskrun/taskrun.go","lines":["// Copyright © 2019 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package taskrun","","import (","\t\"sort\"","","\tv1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","type Run struct {","\tName           string","\tTask           string","\tRetries        int","\tStartTime      *metav1.Time","\tCompletionTime *metav1.Time","}","","type Runs []Run","","func (r Runs) Len() int {","\treturn len(r)","}","","func (r Runs) Less(i, j int) bool {","\tif r[i].CompletionTime != nil \u0026\u0026 r[j].CompletionTime != nil {","\t\treturn r[i].CompletionTime.Before(r[j].CompletionTime)","\t}","\treturn r[i].StartTime.Before(r[j].StartTime)","}","","func (r Runs) Swap(i, j int) {","\tr[i], r[j] = r[j], r[i]","}","","func IsFiltered(tr Run, allowed []string) bool {","\ttrs := []Run{tr}","\treturn len(Filter(trs, allowed)) == 0","}","","func HasScheduled(trs *v1.PipelineRunTaskRunStatus) bool {","\tif trs.Status != nil {","\t\treturn trs.Status.PodName != \"\"","\t}","\treturn false","}","","func Filter(trs []Run, ts []string) []Run {","\tif len(ts) == 0 {","\t\treturn trs","\t}","","\tfilter := map[string]bool{}","\tfor _, t := range ts {","\t\tfilter[t] = true","\t}","","\tfiltered := []Run{}","\tfor _, tr := range trs {","\t\tif filter[tr.Task] {","\t\t\tfiltered = append(filtered, tr)","\t\t}","\t}","","\treturn filtered","}","","func SortTasksBySpecOrder(pipelineTasks []v1.PipelineTask, pipelinesTaskRuns map[string]*v1.PipelineRunTaskRunStatus) []Run {","\ttrNames := map[string]string{}","","\tfor name, t := range pipelinesTaskRuns {","\t\ttrNames[t.PipelineTaskName] = name","\t}","\ttrs := Runs{}","","\tfor _, ts := range pipelineTasks {","\t\tif n, ok := trNames[ts.Name]; ok {","\t\t\ttrStatusFields := pipelinesTaskRuns[n].Status.TaskRunStatusFields","\t\t\ttrs = append(trs, Run{","\t\t\t\tTask:           ts.Name,","\t\t\t\tName:           n,","\t\t\t\tRetries:        ts.Retries,","\t\t\t\tStartTime:      trStatusFields.StartTime,","\t\t\t\tCompletionTime: trStatusFields.CompletionTime,","\t\t\t})","\t\t}","\t}","\tsort.Sort(trs)","\treturn trs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0]},{"id":70,"path":"pkg/triggerbinding/triggerbinding.go","lines":["package triggerbinding","","import (","\t\"fmt\"","\t\"os\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var triggerbindingGroupResource = schema.GroupVersionResource{Group: \"triggers.tekton.dev\", Resource: \"triggerbindings\"}","","func GetAllTriggerBindingNames(client *cli.Clients, namespace string) ([]string, error) {","\tps, err := List(client, metav1.ListOptions{}, namespace)","\tif err != nil {","\t\treturn nil, err","\t}","","\tret := []string{}","\tfor _, item := range ps.Items {","\t\tret = append(ret, item.ObjectMeta.Name)","\t}","\treturn ret, nil","}","","func List(c *cli.Clients, opts metav1.ListOptions, ns string) (*v1beta1.TriggerBindingList, error) {","\tunstructuredTB, err := actions.List(triggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar triggerbindings *v1beta1.TriggerBindingList","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTB.UnstructuredContent(), \u0026triggerbindings); err != nil {","\t\treturn nil, err","\t}","\tif err != nil {","\t\tfmt.Fprintf(os.Stderr, \"Failed to list triggerbindings from %s namespace \\n\", ns)","\t\treturn nil, err","\t}","","\treturn triggerbindings, nil","}","","func Get(c *cli.Clients, tbname string, opts metav1.GetOptions, ns string) (*v1beta1.TriggerBinding, error) {","\tunstructuredTB, err := actions.Get(triggerbindingGroupResource, c.Dynamic, c.Triggers.Discovery(), tbname, ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar tb *v1beta1.TriggerBinding","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTB.UnstructuredContent(), \u0026tb); err != nil {","\t\tfmt.Fprintf(os.Stderr, \"failed to get triggerbinding from %s namespace \\n\", ns)","\t\treturn nil, err","\t}","\treturn tb, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,1,1,0,2,2,1,1,2,1,1,1,0,2,0,0,2,2,2,1,1,0,2,2,1,1,1,2,0]},{"id":71,"path":"pkg/triggertemplate/triggertemplate.go","lines":["// Copyright © 2021 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package triggertemplate","","import (","\t\"fmt\"","\t\"os\"","","\t\"github.com/tektoncd/cli/pkg/actions\"","\t\"github.com/tektoncd/cli/pkg/cli\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","var triggertemplateGroupResource = schema.GroupVersionResource{Group: \"triggers.tekton.dev\", Resource: \"triggertemplates\"}","","func GetAllTriggerTemplateNames(client *cli.Clients, namespace string) ([]string, error) {","\tps, err := List(client, metav1.ListOptions{}, namespace)","\tif err != nil {","\t\treturn nil, err","\t}","","\tret := []string{}","\tfor _, item := range ps.Items {","\t\tret = append(ret, item.ObjectMeta.Name)","\t}","\treturn ret, nil","}","","func List(c *cli.Clients, opts metav1.ListOptions, ns string) (*v1beta1.TriggerTemplateList, error) {","\tunstructuredTT, err := actions.List(triggertemplateGroupResource, c.Dynamic, c.Triggers.Discovery(), ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar triggertemplates *v1beta1.TriggerTemplateList","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTT.UnstructuredContent(), \u0026triggertemplates); err != nil {","\t\treturn nil, err","\t}","\tif err != nil {","\t\tfmt.Fprintf(os.Stderr, \"Failed to list triggertemplates from %s namespace \\n\", ns)","\t\treturn nil, err","\t}","","\treturn triggertemplates, nil","}","","func Get(c *cli.Clients, ttname string, opts metav1.GetOptions, ns string) (*v1beta1.TriggerTemplate, error) {","\tunstructuredTT, err := actions.Get(triggertemplateGroupResource, c.Dynamic, c.Triggers.Discovery(), ttname, ns, opts)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar tt *v1beta1.TriggerTemplate","\tif err := runtime.DefaultUnstructuredConverter.FromUnstructured(unstructuredTT.UnstructuredContent(), \u0026tt); err != nil {","\t\tfmt.Fprintf(os.Stderr, \"failed to get triggertemplate from %s namespace \\n\", ns)","\t\treturn nil, err","\t}","\treturn tt, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,1,1,0,2,2,1,1,2,1,1,1,0,2,0,0,2,2,2,1,1,0,2,2,1,1,1,2,0]},{"id":72,"path":"pkg/trustedresources/sign.go","lines":["// Copyright © 2022 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package trustedresources","","import (","\t\"bytes\"","\t\"context\"","\t\"crypto\"","\t\"crypto/sha256\"","\t\"encoding/base64\"","\t\"encoding/json\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"os\"","\t\"syscall\"","","\t\"github.com/sigstore/sigstore/pkg/signature\"","\t\"github.com/sigstore/sigstore/pkg/signature/kms\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\t\"golang.org/x/term\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"sigs.k8s.io/yaml\"",")","","const (","\t// SignatureAnnotation is the key of signature in annotation map","\tSignatureAnnotation = \"tekton.dev/signature\"",")","","var (","\t// Read is for fuzzing","\tread = readPasswordFn",")","","// Sign the crd and output signed bytes to writer","func Sign(o metav1.Object, keyfile, kmsKey, targetFile string) error {","\t// Load signer","\tvar signer signature.Signer","\tvar err error","\tif keyfile != \"\" {","\t\tsigner, err = signature.LoadSignerFromPEMFile(keyfile, crypto.SHA256, getPass)","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"error getting signer from key file: %v\", err)","\t\t}","\t}","\tif kmsKey != \"\" {","\t\tctx := context.Background()","\t\tsigner, err = kms.Get(ctx, kmsKey, crypto.SHA256)","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"error getting kms signer: %v\", err)","\t\t}","\t}","","\t// Get annotation","\ta := o.GetAnnotations()","\tif a == nil {","\t\ta = map[string]string{}","\t}","","\t// Sign object","\tsig, err := signInterface(signer, o)","\tif err != nil {","\t\treturn err","\t}","\ta[SignatureAnnotation] = base64.StdEncoding.EncodeToString(sig)","\to.SetAnnotations(a)","\tsignedBuf, err := yaml.Marshal(o)","\tif err != nil {","\t\treturn err","\t}","","\t// save signed file","\tf, err := os.OpenFile(targetFile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)","\tif err != nil {","\t\treturn fmt.Errorf(\"error opening output file: %v\", err)","\t}","\tdefer f.Close()","\t_, err = f.Write(signedBuf)","","\treturn err","}","","// signInterface returns the encoded signature for the given object.","func signInterface(signer signature.Signer, i interface{}) ([]byte, error) {","\tif signer == nil {","\t\treturn nil, fmt.Errorf(\"signer is nil\")","\t}","\tb, err := json.Marshal(i)","\tif err != nil {","\t\treturn nil, err","\t}","\th := sha256.New()","\th.Write(b)","","\tsig, err := signer.SignMessage(bytes.NewReader(h.Sum(nil)))","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn sig, nil","}","","// UnmarshalCRD will get the task/pipeline from buffer and extract the signature.","func UnmarshalCRD(buf []byte, kind string) (metav1.Object, []byte, error) {","\tvar resource metav1.Object","\tvar signature []byte","","\tswitch kind {","\tcase \"Task\":","\t\tresource = \u0026v1beta1.Task{}","\t\tif err := yaml.Unmarshal(buf, \u0026resource); err != nil {","\t\t\treturn nil, nil, err","\t\t}","\tcase \"Pipeline\":","\t\tresource = \u0026v1beta1.Pipeline{}","\t\tif err := yaml.Unmarshal(buf, \u0026resource); err != nil {","\t\t\treturn nil, nil, err","\t\t}","\t}","\tannotations := resource.GetAnnotations()","\tsignature, err := base64.StdEncoding.DecodeString(annotations[SignatureAnnotation])","\tif err != nil {","\t\treturn nil, nil, err","\t}","\tdelete(annotations, SignatureAnnotation)","","\treturn resource, signature, nil","}","","func getPass(confirm bool) ([]byte, error) {","\tread := read(confirm)","\treturn read()","}","","func readPasswordFn(confirm bool) func() ([]byte, error) {","\tpw, ok := os.LookupEnv(\"PRIVATE_PASSWORD\")","\tswitch {","\tcase ok:","\t\treturn func() ([]byte, error) {","\t\t\treturn []byte(pw), nil","\t\t}","\tcase isTerminal():","\t\treturn func() ([]byte, error) {","\t\t\treturn getPassFromTerm(confirm)","\t\t}","\t// Handle piped in passwords.","\tdefault:","\t\treturn func() ([]byte, error) {","\t\t\treturn io.ReadAll(os.Stdin)","\t\t}","\t}","}","","func getPassFromTerm(confirm bool) ([]byte, error) {","\tfmt.Fprint(os.Stderr, \"Enter password for private key: \")","\t// Unnecessary convert of syscall.Stdin on *nix, but Windows is a uintptr","\t// nolint:unconvert","\tpw1, err := term.ReadPassword(int(syscall.Stdin))","\tif err != nil {","\t\treturn nil, err","\t}","\tfmt.Fprintln(os.Stderr)","\tif !confirm {","\t\treturn pw1, nil","\t}","\tfmt.Fprint(os.Stderr, \"Enter password for private key again: \")","\t// Unnecessary convert of syscall.Stdin on *nix, but Windows is a uintptr","\t// nolint:unconvert","\tconfirmpw, err := term.ReadPassword(int(syscall.Stdin))","\tfmt.Fprintln(os.Stderr)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif string(pw1) != string(confirmpw) {","\t\treturn nil, errors.New(\"passwords do not match\")","\t}","\treturn pw1, nil","}","","func isTerminal() bool {","\tstat, _ := os.Stdin.Stat()","\treturn (stat.Mode() \u0026 os.ModeCharDevice) != 0","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,1,0,2,1,1,1,1,1,0,0,0,2,2,2,2,0,0,2,2,1,1,2,2,2,2,1,1,0,0,2,2,1,1,2,2,2,2,0,0,0,2,2,1,1,2,2,1,1,2,2,2,2,2,1,1,0,2,0,0,0,2,2,2,2,2,2,2,2,1,1,2,2,2,1,1,0,2,2,2,1,1,2,2,2,0,0,2,2,2,2,0,2,2,2,2,2,2,2,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1]},{"id":73,"path":"pkg/trustedresources/verify.go","lines":["// Copyright © 2022 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package trustedresources","","import (","\t\"bytes\"","\t\"context\"","\t\"crypto\"","\t\"crypto/sha256\"","\t\"encoding/base64\"","\t\"encoding/json\"","\t\"fmt\"","","\tcosignsignature \"github.com/sigstore/cosign/v2/pkg/signature\"","\t\"github.com/sigstore/sigstore/pkg/signature\"","\t\"github.com/sigstore/sigstore/pkg/signature/kms\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","// Verify the crd","func Verify(o metav1.Object, keyfile, kmsKey string) error {","\tvar verifier signature.Verifier","\tvar err error","\tif keyfile != \"\" {","\t\t// Load signer from key files","\t\tctx := context.Background()","\t\tverifier, err = cosignsignature.LoadPublicKey(ctx, keyfile)","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"error getting verifier from key file: %v\", err)","\t\t}","","\t}","\tif kmsKey != \"\" {","\t\tctx := context.Background()","\t\tverifier, err = kms.Get(ctx, kmsKey, crypto.SHA256)","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"error getting kms verifier: %v\", err)","\t\t}","\t}","","\t// Get raw signature","\ta := o.GetAnnotations()","\tsigString := a[SignatureAnnotation]","\tsignatureBytes, err := base64.StdEncoding.DecodeString(sigString)","\tif err != nil {","\t\treturn err","\t}","\tdelete(a, SignatureAnnotation)","\to.SetAnnotations(a)","\t// Verify signature","\treturn VerifyInterface(o, verifier, signatureBytes)","}","","// VerifyInterface get the checksum of json marshalled object and verify it.","func VerifyInterface(","\tobj interface{},","\tverifier signature.Verifier,","\tsignature []byte,",") error {","\tts, err := json.Marshal(obj)","\tif err != nil {","\t\treturn err","\t}","","\th := sha256.New()","\th.Write(ts)","\treturn verifier.VerifySignature(bytes.NewReader(signature), bytes.NewReader(h.Sum(nil)))","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,0,0,2,1,1,1,1,1,0,0,0,2,2,2,2,1,1,2,2,2,2,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,0]},{"id":74,"path":"pkg/version/version.go","lines":["// Copyright © 2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package version","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/cli/pkg/cli\"","\tv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","const (","\tpipelinesControllerSelector    string = \"app.kubernetes.io/part-of=tekton-pipelines,app.kubernetes.io/component=controller,app.kubernetes.io/name=controller\"","\toldPipelinesControllerSelector string = \"app.kubernetes.io/component=controller,app.kubernetes.io/name=tekton-pipelines\"","\ttriggersControllerSelector     string = \"app.kubernetes.io/part-of=tekton-triggers,app.kubernetes.io/component=controller,app.kubernetes.io/name=controller\"","\toldTriggersControllerSelector  string = \"app.kubernetes.io/component=controller,app.kubernetes.io/name=tekton-triggers\"","\tdashboardControllerSelector    string = \"app.kubernetes.io/part-of=tekton-dashboard,app.kubernetes.io/component=dashboard,app.kubernetes.io/name=dashboard\"","\toldDashboardControllerSelector string = \"app=tekton-dashboard\"","\tchainsInfo                     string = \"chains-info\"","\tpipelinesInfo                  string = \"pipelines-info\"","\ttriggersInfo                   string = \"triggers-info\"","\tdashboardInfo                  string = \"dashboard-info\"","\toperatorInfo                   string = \"tekton-operator-info\"","\thubInfo                        string = \"hub-info\"",")","","var defaultNamespaces = []string{\"tekton-pipelines\", \"openshift-pipelines\", \"tekton-chains\", \"tekton-operator\", \"openshift-operators\"}","","// GetPipelineVersion Get pipeline version, functions imported from Dashboard","func GetPipelineVersion(c *cli.Clients, ns string) (string, error) {","","\tvar version string","\t// for Tekton Pipelines version 0.25.0+","\tconfigMap, err := getConfigMap(c, pipelinesInfo, ns)","\tif err == nil {","\t\tversion = configMap.Data[\"version\"]","\t}","","\tif version != \"\" {","\t\treturn version, nil","\t}","","\tdeploymentsList, err := getDeployments(c, pipelinesControllerSelector, oldPipelinesControllerSelector, ns)","","\tif err != nil {","\t\treturn \"\", err","\t}","","\tversion = findPipelineVersion(deploymentsList.Items)","","\tif version == \"\" {","\t\treturn \"\", fmt.Errorf(\"error getting the tekton pipelines deployment version. Version is unknown\")","\t}","","\treturn version, nil","}","","// Get deployments for either Tekton Triggers, Tekton Dashboard or Tekton Pipelines","func getDeployments(c *cli.Clients, newLabel, oldLabel, ns string) (*v1.DeploymentList, error) {","\tvar (","\t\terr         error","\t\tdeployments *v1.DeploymentList","\t)","\tif ns != \"\" {","\t\tdeployments, err = getDeploy(c, newLabel, oldLabel, ns)","\t\treturn deployments, err","\t}","\t// If ldflag and flag doesn't specify the namespace fallback to default.","\tfor _, n := range defaultNamespaces {","\t\tdeployments, err = getDeploy(c, newLabel, oldLabel, n)","\t\tif err != nil {","\t\t\tif strings.Contains(err.Error(), fmt.Sprintf(`cannot list resource \"deployments\" in API group \"apps\" in the namespace \"%s\"`, n)) {","\t\t\t\tcontinue","\t\t\t}","\t\t\treturn nil, err","\t\t}","\t\tif len(deployments.Items) != 0 {","\t\t\tbreak","\t\t}","\t}","\treturn deployments, err","}","","func getDeploy(c *cli.Clients, newLabel, oldLabel, ns string) (*v1.DeploymentList, error) {","\tdeployments, err := c.Kube.AppsV1().Deployments(ns).List(context.Background(), metav1.ListOptions{LabelSelector: newLabel})","\tif err != nil {","\t\treturn nil, err","\t}","","\t// NOTE: If the new labels selector returned nothing, try with old labels selector","\t// The old labels selectors are deprecated and should be removed at some point","\tif deployments == nil || len(deployments.Items) == 0 {","\t\tdeployments, err = c.Kube.AppsV1().Deployments(ns).List(context.Background(), metav1.ListOptions{LabelSelector: oldLabel})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t}","\treturn deployments, err","}","","func getConfigMap(c *cli.Clients, name, ns string) (*corev1.ConfigMap, error) {","","\tvar (","\t\terr       error","\t\tconfigMap *corev1.ConfigMap","\t)","","\tif ns != \"\" {","\t\tconfigMap, err = c.Kube.CoreV1().ConfigMaps(ns).Get(context.Background(), name, metav1.GetOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn configMap, nil","\t}","","\tfor _, n := range defaultNamespaces {","\t\tconfigMap, err = c.Kube.CoreV1().ConfigMaps(n).Get(context.Background(), name, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tif errors.IsNotFound(err) {","\t\t\t\tcontinue","\t\t\t}","\t\t\tif strings.Contains(err.Error(), fmt.Sprintf(`cannot get resource \"configmaps\" in API group \"\" in the namespace \"%s\"`, n)) {","\t\t\t\tcontinue","\t\t\t}","\t\t\treturn nil, err","\t\t}","\t\tif configMap != nil {","\t\t\tbreak","\t\t}","\t}","","\tif configMap == nil {","\t\treturn nil, fmt.Errorf(\"ConfigMap with name %s not found in the namespace %s\", name, ns)","\t}","\treturn configMap, nil","}","","func findPipelineVersion(deployments []v1.Deployment) string {","\tversion := \"\"","\tfor _, deployment := range deployments {","\t\tdeploymentLabels := deployment.Spec.Template.GetLabels()","\t\tdeploymentAnnotations := deployment.Spec.Template.GetAnnotations()","","\t\t// For master of Tekton Pipelines","\t\tversion = deploymentLabels[\"app.kubernetes.io/version\"]","","\t\t// For Tekton Pipelines 0.11.*","\t\tif version == \"\" {","\t\t\tversion = deploymentLabels[\"pipeline.tekton.dev/release\"]","\t\t}","","\t\t// For Tekton Pipelines 0.10.0 + 0.10.1 tekton.dev/release has been set as annotation","\t\tif version == \"\" {","\t\t\tversion = deploymentAnnotations[\"tekton.dev/release\"]","\t\t}","","\t\t// For Tekton Pipelines 0.9.0 - 0.9.2","\t\tif version == \"\" {","\t\t\tdeploymentImage := deployment.Spec.Template.Spec.Containers[0].Image","\t\t\tif strings.Contains(deploymentImage, \"pipeline/cmd/controller\") \u0026\u0026 strings.Contains(deploymentImage, \":\") \u0026\u0026 strings.Contains(deploymentImage, \"@\") {","\t\t\t\ts := strings.SplitAfter(deploymentImage, \":\")","\t\t\t\tif strings.Contains(s[1], \"@\") {","\t\t\t\t\tt := strings.Split(s[1], \"@\")","\t\t\t\t\tversion = t[0]","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\treturn version","}","","// GetChainsVersion Get chains version","func GetChainsVersion(c *cli.Clients, ns string) (string, error) {","","\tconfigMap, err := getConfigMap(c, chainsInfo, ns)","\tif err != nil {","\t\treturn \"\", err","\t}","\tversion := configMap.Data[\"version\"]","\treturn version, nil","}","","// GetTriggerVersion Get triggers version.","func GetTriggerVersion(c *cli.Clients, ns string) (string, error) {","","\tvar version string","","\t// for latest pipelines version","\tconfigMap, err := getConfigMap(c, triggersInfo, ns)","\tif err == nil {","\t\tversion = configMap.Data[\"version\"]","\t}","","\tif version != \"\" {","\t\treturn version, nil","\t}","","\tdeploymentsList, err := getDeployments(c, triggersControllerSelector, oldTriggersControllerSelector, ns)","","\tif err != nil {","\t\treturn \"\", err","\t}","","\tversion = findTriggersVersion(deploymentsList.Items)","","\tif version == \"\" {","\t\treturn \"\", fmt.Errorf(\"error getting the tekton triggers deployment version. Version is unknown\")","\t}","","\treturn version, nil","}","","func findTriggersVersion(deployments []v1.Deployment) string {","\tversion := \"\"","\tfor _, deployment := range deployments {","\t\tdeploymentLabels := deployment.Spec.Template.GetLabels()","","\t\t// For master of Tekton Triggers","\t\tif version = deploymentLabels[\"app.kubernetes.io/version\"]; version == \"\" {","\t\t\t// For Tekton Triggers 0.3.*","\t\t\tversion = deploymentLabels[\"triggers.tekton.dev/release\"]","\t\t}","\t}","\treturn version","}","","// GetDashboardVersion Get dashboard version.","func GetDashboardVersion(c *cli.Clients, ns string) (string, error) {","","\tvar version string","","\t// for latest pipelines version","\tconfigMap, err := getConfigMap(c, dashboardInfo, ns)","\tif err == nil {","\t\tversion = configMap.Data[\"version\"]","\t}","","\tif version != \"\" {","\t\treturn version, nil","\t}","","\tdeploymentsList, err := getDeployments(c, dashboardControllerSelector, oldDashboardControllerSelector, ns)","","\tif err != nil {","\t\treturn \"\", err","\t}","","\tversion = findDashboardVersion(deploymentsList.Items)","\tif version == \"\" {","\t\treturn \"\", fmt.Errorf(\"error getting the tekton dashboard deployment version. Version is unknown\")","\t}","","\treturn version, nil","}","","func findDashboardVersion(deployments []v1.Deployment) string {","\tversion := \"\"","\tfor _, deployment := range deployments {","\t\tdeploymentLabels := deployment.Spec.Template.GetLabels()","","\t\t// For master of Tekton Dashboard","\t\tif version = deploymentLabels[\"app.kubernetes.io/version\"]; version == \"\" {","\t\t\t// For Tekton Dashboard 0.6.*","\t\t\tdeploymentMetaLabels := deployment.GetObjectMeta().GetLabels()","\t\t\tversion = deploymentMetaLabels[\"version\"]","\t\t}","\t}","\treturn version","}","","// GetOperatorVersion Get operator version","func GetOperatorVersion(c *cli.Clients, ns string) (string, error) {","\tconfigMap, err := getConfigMap(c, operatorInfo, ns)","\tif err != nil {","\t\treturn \"\", err","\t}","\tversion := configMap.Data[\"version\"]","\treturn version, nil","}","","func GetHubVersion(c *cli.Clients, ns string) (string, error) {","\tconfigMap, err := getConfigMap(c, hubInfo, ns)","\tif err != nil {","\t\treturn \"\", err","\t}","\tversion := configMap.Data[\"version\"]","\treturn version, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,1,1,0,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,0,1,0,2,2,0,0,2,0,0,2,2,2,1,1,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,1,1,0,1,0,2,2,0,0,0,2,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,0,0,0,2,0,0,0,2,2,2,2,1,1,2,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,1,1,0,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,1,1,0,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,0,2,2,2,1,1,2,2,0,0,1,1,1,1,1,1,1,0]},{"id":75,"path":"pkg/workspaces/workspaces.go","lines":["// Copyright © 2019-2020 The Tekton Authors.","//","// Licensed under the Apache License, Version 2.0 (the \"License\");","// you may not use this file except in compliance with the License.","// You may obtain a copy of the License at","//","//     http://www.apache.org/licenses/LICENSE-2.0","//","// Unless required by applicable law or agreed to in writing, software","// distributed under the License is distributed on an \"AS IS\" BASIS,","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","// See the License for the specific language governing permissions and","// limitations under the License.","","package workspaces","","import (","\t\"errors\"","\t\"fmt\"","\t\"net/http\"","\t\"strings\"","","\t\"github.com/tektoncd/cli/pkg/file\"","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"sigs.k8s.io/yaml\"",")","","var (","\tnameParam               = \"name\"","\tclaimNameParam          = \"claimName\"","\tsubPathParam            = \"subPath\"","\temptyDirParam           = \"emptyDir\"","\tconfigParam             = \"config\"","\tsecretParam             = \"secret\"","\tconfigItemParam         = \"item\"","\tvolumeClaimTemplateFile = \"volumeClaimTemplateFile\"","\tcsiFile                 = \"csiFile\"",")","","const invalidWorkspace = \"invalid input format for workspace : \"","","var errNotFoundParam = errors.New(\"param not found\")","","// Merge merges workspacebinding already in pipelineruns with given options","func Merge(ws []v1beta1.WorkspaceBinding, optWS []string, httpClient http.Client) ([]v1beta1.WorkspaceBinding,","\terror) {","\tworkspaces, err := parseWorkspace(optWS, httpClient)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif len(workspaces) == 0 {","\t\treturn ws, nil","\t}","","\tfor i := range ws {","\t\tif v, ok := workspaces[ws[i].Name]; ok {","\t\t\tws[i] = v","\t\t\tdelete(workspaces, v.Name)","\t\t}","\t}","","\tfor _, v := range workspaces {","\t\tws = append(ws, v)","\t}","","\treturn ws, nil","}","","func parseWorkspace(w []string, httpClient http.Client) (map[string]v1beta1.WorkspaceBinding, error) {","\tws := map[string]v1beta1.WorkspaceBinding{}","\tfor _, v := range w {","","\t\tr := strings.Split(v, \",\")","\t\tname, err := getPar(r, nameParam)","\t\tif err != nil {","\t\t\treturn nil, errors.New(\"Name not found for workspace\")","\t\t}","","\t\twB := v1beta1.WorkspaceBinding{","\t\t\tName: name,","\t\t}","\t\tnWB := 0","\t\tsubPath, err := getPar(r, subPathParam)","\t\tif err == nil {","\t\t\twB.SubPath = subPath","\t\t} else if err != errNotFoundParam {","\t\t\treturn nil, err","\t\t}","","\t\tif vctFile, err := getPar(r, volumeClaimTemplateFile); err == nil {","\t\t\terr = setWorkspaceVCTemplate(\u0026wB, vctFile, httpClient)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tws[name] = wB","\t\t\tcontinue","\t\t}","","\t\tif csiFile, err := getPar(r, csiFile); err == nil {","\t\t\terr = setWorkspaceCSITemplate(\u0026wB, csiFile, httpClient)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tws[name] = wB","\t\t\tcontinue","\t\t}","","\t\terr = setWorkspaceConfig(r, \u0026wB)","\t\tif err == nil {","\t\t\tws[name] = wB","\t\t\tnWB++","\t\t} else if err != errNotFoundParam {","\t\t\treturn nil, err","\t\t}","","\t\terr = setWorkspaceSecret(r, \u0026wB)","\t\tif err == nil {","\t\t\tws[name] = wB","\t\t\tnWB++","\t\t} else if err != errNotFoundParam {","\t\t\treturn nil, err","\t\t}","","\t\tif err = setWorkspaceEmptyDir(r, \u0026wB); err == nil {","\t\t\tws[name] = wB","\t\t\tnWB++","\t\t}","","\t\tif err = setWorkspacePVC(r, \u0026wB); err == nil {","\t\t\tws[name] = wB","\t\t\tnWB++","\t\t}","","\t\tif nWB != 1 {","\t\t\treturn nil, errors.New(invalidWorkspace + v)","\t\t}","","\t}","","\treturn ws, nil","}","","func setWorkspaceSecret(r []string, wB *v1beta1.WorkspaceBinding) error {","\tsecret, err := getPar(r, secretParam)","\tif err != nil {","\t\treturn err","\t}","\titems, err := getItems(r)","\tif err != nil \u0026\u0026 err != errNotFoundParam {","\t\treturn err","\t}","\twB.Secret = \u0026corev1.SecretVolumeSource{","\t\tSecretName: secret,","\t\tItems:      items,","\t}","\treturn nil","}","","func setWorkspaceConfig(r []string, wB *v1beta1.WorkspaceBinding) error {","\tconfig, err := getPar(r, configParam)","\tif err != nil {","\t\treturn err","\t}","\titems, err := getItems(r)","\tif err != nil \u0026\u0026 err != errNotFoundParam {","\t\treturn err","\t}","","\twB.ConfigMap = \u0026corev1.ConfigMapVolumeSource{","\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\tName: config},","\t\tItems: items,","\t}","\treturn nil","}","","func getItems(r []string) ([]corev1.KeyToPath, error) {","\tvar kp []corev1.KeyToPath","\tfor i := range r {","\t\tif !strings.Contains(r[i], configItemParam) {","\t\t\tcontinue","\t\t}","\t\ts := strings.SplitN(r[i], \"=\", 2)","\t\tif s[0] != configItemParam {","\t\t\tcontinue","\t\t}","\t\tif len(s) != 2 {","\t\t\treturn nil, errors.New(\"invalid item\")","\t\t}","\t\tkey, path, err := getKeyValue(s[1])","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tkp = append(kp, corev1.KeyToPath{","\t\t\tKey:  key,","\t\t\tPath: path,","\t\t})","\t}","\treturn kp, nil","}","","func setWorkspacePVC(r []string, wB *v1beta1.WorkspaceBinding) error {","\tclaimName, err := getPar(r, claimNameParam)","\tif err != nil {","\t\treturn err","\t}","\twB.PersistentVolumeClaim = \u0026corev1.PersistentVolumeClaimVolumeSource{","\t\tClaimName: claimName,","\t}","\treturn nil","}","","func getKeyValue(s string) (string, string, error) {","\tr := strings.SplitN(s, \"=\", 2)","\tif len(r) != 2 {","\t\treturn \"\", \"\", errors.New(\"invalid key value\")","\t}","\treturn r[0], r[1], nil","}","","func setWorkspaceEmptyDir(r []string, wB *v1beta1.WorkspaceBinding) error {","\temptyDir, err := getPar(r, emptyDirParam)","\tif err != nil {","\t\treturn err","\t}","","\tvar sM corev1.StorageMedium","\tswitch emptyDir {","\tcase \"\":","\t\tsM = corev1.StorageMediumDefault","\tcase \"Memory\":","\t\tsM = corev1.StorageMediumMemory","\tcase \"HugePages\":","\t\tsM = corev1.StorageMediumHugePages","\tdefault:","\t\treturn errors.New(invalidWorkspace + emptyDirParam)","\t}","","\twB.EmptyDir = \u0026corev1.EmptyDirVolumeSource{","\t\tMedium: sM,","\t}","\treturn nil","}","","func setWorkspaceVCTemplate(wB *v1beta1.WorkspaceBinding, vctFile string, httpClient http.Client) error {","\tpvc, err := parseVolumeClaimTemplate(vctFile, httpClient)","\tif err != nil {","\t\treturn err","\t}","","\twB.VolumeClaimTemplate = pvc","\treturn nil","}","","func setWorkspaceCSITemplate(wB *v1beta1.WorkspaceBinding, vctFile string, httpClient http.Client) error {","\tcsi, err := parseCSITemplate(vctFile, httpClient)","\tif err != nil {","\t\treturn err","\t}","","\twB.CSI = csi","\treturn nil","}","","func parseVolumeClaimTemplate(filePath string, httpClient http.Client) (*corev1.PersistentVolumeClaim, error) {","\tb, err := file.LoadFileContent(httpClient, filePath, file.IsYamlFile(), fmt.Errorf(\"invalid file format for %s: .yaml or .yml file extension and format required\", filePath))","\tif err != nil {","\t\treturn nil, err","\t}","\tm := map[string]interface{}{}","\terr = yaml.UnmarshalStrict(b, \u0026m)","\tif err != nil {","\t\treturn nil, err","\t}","","\tpvc := corev1.PersistentVolumeClaim{}","\tif err := yaml.UnmarshalStrict(b, \u0026pvc); err != nil {","\t\treturn nil, err","\t}","\treturn \u0026pvc, nil","}","","func parseCSITemplate(filePath string, httpClient http.Client) (*corev1.CSIVolumeSource, error) {","\tb, err := file.LoadFileContent(httpClient, filePath, file.IsYamlFile(), fmt.Errorf(\"invalid file format for %s: .yaml or .yml file extension and format required\", filePath))","\tif err != nil {","\t\treturn nil, err","\t}","\tm := map[string]interface{}{}","\terr = yaml.UnmarshalStrict(b, \u0026m)","\tif err != nil {","\t\treturn nil, err","\t}","","\tcsi := corev1.CSIVolumeSource{}","\tif err := yaml.UnmarshalStrict(b, \u0026csi); err != nil {","\t\treturn nil, err","\t}","\treturn \u0026csi, nil","}","","func getPar(r []string, par string) (string, error) {","\tvar p string","\tfor i := range r {","\t\tif !strings.Contains(r[i], par) {","\t\t\tcontinue","\t\t}","\t\ts := strings.SplitN(r[i], \"=\", 2)","\t\tif s[0] != par {","\t\t\tcontinue","\t\t}","\t\tif len(s) != 2 {","\t\t\treturn p, errors.New(invalidWorkspace + r[i])","\t\t}","\t\tp = s[1]","\t\treturn p, nil","\t}","\treturn p, errNotFoundParam","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,0,0,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,0,2,2,2,0,0,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,1,0,2,1,1,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,2,0,2,2,0,0,2,2,2,2,2,0,2,2,0,0,2,2,2,1,1,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,1,1,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,0,2,0]}],"tree":{"name":".","type":"dir","children":[{"name":"pkg","type":"dir","children":[{"name":"actions","type":"dir","children":[{"name":"create.go","type":"file","fileId":0},{"name":"delete.go","type":"file","fileId":1},{"name":"get.go","type":"file","fileId":2},{"name":"gvr.go","type":"file","fileId":3},{"name":"list.go","type":"file","fileId":4},{"name":"patch.go","type":"file","fileId":5},{"name":"watch.go","type":"file","fileId":6}]},{"name":"bundle","type":"dir","children":[{"name":"builder.go","type":"file","fileId":7},{"name":"flags.go","type":"file","fileId":8},{"name":"keychain.go","type":"file","fileId":9},{"name":"parser.go","type":"file","fileId":10},{"name":"reader.go","type":"file","fileId":11},{"name":"remote.go","type":"file","fileId":12}]},{"name":"chain","type":"dir","children":[{"name":"chain.go","type":"file","fileId":13}]},{"name":"cli","type":"dir","children":[{"name":"prerun","type":"dir","children":[{"name":"prerun.go","type":"file","fileId":15}]},{"name":"params.go","type":"file","fileId":14}]},{"name":"clustertriggerbinding","type":"dir","children":[{"name":"clustertriggerbinding.go","type":"file","fileId":16}]},{"name":"customrun","type":"dir","children":[{"name":"sort","type":"dir","children":[{"name":"by_namespace.go","type":"file","fileId":17},{"name":"by_start_time.go","type":"file","fileId":18}]}]},{"name":"deleter","type":"dir","children":[{"name":"deleter.go","type":"file","fileId":19}]},{"name":"eventlistener","type":"dir","children":[{"name":"eventlistener.go","type":"file","fileId":20}]},{"name":"export","type":"dir","children":[{"name":"export.go","type":"file","fileId":21}]},{"name":"file","type":"dir","children":[{"name":"file.go","type":"file","fileId":22}]},{"name":"flags","type":"dir","children":[{"name":"flags.go","type":"file","fileId":23}]},{"name":"formatted","type":"dir","children":[{"name":"address.go","type":"file","fileId":24},{"name":"color.go","type":"file","fileId":25},{"name":"completion.go","type":"file","fileId":26},{"name":"description.go","type":"file","fileId":27},{"name":"k8s.go","type":"file","fileId":28},{"name":"param.go","type":"file","fileId":29},{"name":"results.go","type":"file","fileId":30},{"name":"task.go","type":"file","fileId":31},{"name":"time.go","type":"file","fileId":32},{"name":"version.go","type":"file","fileId":33},{"name":"workspace.go","type":"file","fileId":34}]},{"name":"labels","type":"dir","children":[{"name":"mergelabels.go","type":"file","fileId":35}]},{"name":"log","type":"dir","children":[{"name":"pipeline_reader.go","type":"file","fileId":36},{"name":"reader.go","type":"file","fileId":37},{"name":"task_reader.go","type":"file","fileId":38},{"name":"writer.go","type":"file","fileId":39}]},{"name":"names","type":"dir","children":[{"name":"formats.go","type":"file","fileId":40}]},{"name":"options","type":"dir","children":[{"name":"delete.go","type":"file","fileId":41},{"name":"describe.go","type":"file","fileId":42},{"name":"logs.go","type":"file","fileId":43},{"name":"start.go","type":"file","fileId":44}]},{"name":"params","type":"dir","children":[{"name":"mergeparams.go","type":"file","fileId":45},{"name":"validation.go","type":"file","fileId":46}]},{"name":"pipeline","type":"dir","children":[{"name":"pipeline.go","type":"file","fileId":47},{"name":"pipelinelastrun.go","type":"file","fileId":48}]},{"name":"pipelinerun","type":"dir","children":[{"name":"sort","type":"dir","children":[{"name":"by_namespace.go","type":"file","fileId":51},{"name":"by_start_time.go","type":"file","fileId":52}]},{"name":"description.go","type":"file","fileId":49},{"name":"pipelinerun.go","type":"file","fileId":50},{"name":"tracker.go","type":"file","fileId":53}]},{"name":"plugins","type":"dir","children":[{"name":"plugins.go","type":"file","fileId":54}]},{"name":"pods","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"log.go","type":"file","fileId":56},{"name":"pod.go","type":"file","fileId":57},{"name":"stream.go","type":"file","fileId":58}]},{"name":"container.go","type":"file","fileId":55},{"name":"pod.go","type":"file","fileId":59},{"name":"pod_template.go","type":"file","fileId":60}]},{"name":"suggestion","type":"dir","children":[{"name":"suggest.go","type":"file","fileId":61}]},{"name":"task","type":"dir","children":[{"name":"task.go","type":"file","fileId":62},{"name":"tasklastrun.go","type":"file","fileId":63}]},{"name":"taskrun","type":"dir","children":[{"name":"sort","type":"dir","children":[{"name":"by_namespace.go","type":"file","fileId":67},{"name":"by_start_time.go","type":"file","fileId":68}]},{"name":"create.go","type":"file","fileId":64},{"name":"description.go","type":"file","fileId":65},{"name":"list.go","type":"file","fileId":66},{"name":"taskrun.go","type":"file","fileId":69}]},{"name":"triggerbinding","type":"dir","children":[{"name":"triggerbinding.go","type":"file","fileId":70}]},{"name":"triggertemplate","type":"dir","children":[{"name":"triggertemplate.go","type":"file","fileId":71}]},{"name":"trustedresources","type":"dir","children":[{"name":"sign.go","type":"file","fileId":72},{"name":"verify.go","type":"file","fileId":73}]},{"name":"version","type":"dir","children":[{"name":"version.go","type":"file","fileId":74}]},{"name":"workspaces","type":"dir","children":[{"name":"workspaces.go","type":"file","fileId":75}]}]}]},"summary":{"totalLines":4220,"coveredLines":1984,"percent":47.014218009478675}};
    </script>
    <script>
      window.COVERAGE_CONFIG = {"syntaxEnabled":true};
    </script>
    <script>
      (function() {
  'use strict';

  const data = window.COVERAGE_DATA;
  const config = window.COVERAGE_CONFIG || { syntaxEnabled: true };

  // State
  let currentFileId = null;
  let searchQuery = '';
  let contentSearchQuery = '';
  let matches = [];
  let currentMatchIndex = -1;
  let expandedDirs = new Set();
  let syntaxHighlightEnabled = config.syntaxEnabled;
  let sortMode = 'name'; // 'name' or 'coverage'
  let anchorLine = null;        // First line clicked (anchor for shift-select)
  let selectedRange = null;     // { start: N, end: M } or null

  // DOM elements
  const fileTree = document.getElementById('file-tree');
  const viewport = document.getElementById('viewport');
  const filePath = document.getElementById('file-path');
  const summary = document.getElementById('summary');
  const searchInput = document.getElementById('search-input');
  const contentSearch = document.getElementById('content-search');
  const matchInfo = document.getElementById('match-info');
  const prevMatch = document.getElementById('prev-match');
  const nextMatch = document.getElementById('next-match');
  const themeToggle = document.getElementById('theme-toggle');
  const syntaxToggle = document.getElementById('syntax-toggle');
  const helpModal = document.getElementById('help-modal');
  const closeHelp = document.getElementById('close-help');
  const helpToggle = document.getElementById('help-toggle');

  // Coverage cache: fileId -> percentage
  let coverageCache = new Map();

  function initCoverageCache() {
    data.files.forEach((file, idx) => {
      coverageCache.set(idx, calculateFileCoverage(idx));
    });
  }

  function calculateFileCoverage(fileId) {
    const file = data.files[fileId];
    let totalStatements = 0;
    let coveredStatements = 0;

    file.coverage.forEach(cov => {
      if (cov > 0) totalStatements++;
      if (cov === 2) coveredStatements++;
    });

    return totalStatements === 0 ? 0 : (coveredStatements / totalStatements) * 100;
  }

  function calculateDirectoryCoverage(node) {
    if (node.type === 'file') {
      return coverageCache.get(node.fileId) || 0;
    }

    let totalCoverage = 0;
    let fileCount = 0;

    node.children?.forEach(child => {
      const childCov = calculateDirectoryCoverage(child);
      totalCoverage += childCov;
      fileCount++;
    });

    return fileCount === 0 ? 0 : totalCoverage / fileCount;
  }

  function sortTreeNodes(node, mode) {
    if (!node.children || node.children.length === 0) return node;

    // Deep copy to avoid mutating original
    const sorted = { ...node };
    sorted.children = [...node.children].map(child => sortTreeNodes(child, mode));

    // Sort children
    sorted.children.sort((a, b) => {
      // Directories always first
      if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;

      if (mode === 'coverage') {
        const aCov = calculateDirectoryCoverage(a);
        const bCov = calculateDirectoryCoverage(b);
        console.log('Sorting:', a.name, '('+aCov.toFixed(1)+'%) vs', b.name, '('+bCov.toFixed(1)+'%)', '=', bCov - aCov);
        // Descending: high coverage first
        return aCov !== bCov ? bCov - aCov : a.name.localeCompare(b.name);
      }

      return a.name.localeCompare(b.name);
    });

    return sorted;
  }

  // Initialize
  function init() {
    initCoverageCache();
    loadSortPreference();
    renderSummary();
    renderTree();
    setupEventListeners();
    loadTheme();
    loadSyntaxPreference();

    // Check for deep link hash first, otherwise select first file
    if (!navigateToHash() && data.files.length > 0) {
      selectFile(0);
    }

    // Listen for hash changes (browser back/forward)
    window.addEventListener('hashchange', navigateToHash);
  }

  // Deep linking: parse URL hash
  function parseHash() {
    const hash = window.location.hash.slice(1);
    if (!hash) return null;

    const match = hash.match(/^file-(\d+)(?::line-(\d+)(?:-(\d+))?)?$/);
    if (!match) return null;

    return {
      fileId: parseInt(match[1], 10),
      lineStart: match[2] ? parseInt(match[2], 10) : null,
      lineEnd: match[3] ? parseInt(match[3], 10) : null
    };
  }

  // Deep linking: navigate to hash location
  function navigateToHash() {
    const target = parseHash();
    if (!target) return false;

    if (target.fileId < 0 || target.fileId >= data.files.length) return false;

    selectFile(target.fileId);

    if (target.lineStart) {
      requestAnimationFrame(() => {
        const lineEnd = target.lineEnd || target.lineStart;
        anchorLine = target.lineStart;
        selectedRange = { start: target.lineStart, end: lineEnd };
        selectLineRange(target.lineStart, lineEnd);
        scrollToLine(target.lineStart);
      });
    }

    return true;
  }

  // Deep linking: scroll to and highlight a line
  function scrollToLine(lineNum) {
    const lineEl = document.querySelector('.code-line[data-line="' + lineNum + '"]');
    if (!lineEl) return;

    lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  // Clear all selected lines
  function clearLineSelection() {
    document.querySelectorAll('.code-line.selected-line').forEach(el => {
      el.classList.remove('selected-line');
    });
  }

  // Select a range of lines (inclusive)
  function selectLineRange(start, end) {
    clearLineSelection();
    const minLine = Math.min(start, end);
    const maxLine = Math.max(start, end);
    for (let i = minLine; i <= maxLine; i++) {
      const lineEl = document.querySelector('.code-line[data-line="' + i + '"]');
      if (lineEl) {
        lineEl.classList.add('selected-line');
      }
    }
  }

  // Deep linking: update URL hash
  function updateHash(fileId, lineStart, lineEnd) {
    let hash = 'file-' + fileId;
    if (lineStart) {
      hash += ':line-' + lineStart;
      if (lineEnd && lineEnd !== lineStart) {
        // Normalise so start < end
        const minLine = Math.min(lineStart, lineEnd);
        const maxLine = Math.max(lineStart, lineEnd);
        hash = 'file-' + fileId + ':line-' + minLine + '-' + maxLine;
      }
    }
    history.replaceState(null, '', '#' + hash);
  }

  function renderSummary() {
    // Build summary safely using DOM methods
    summary.textContent = '';
    const span = document.createElement('span');
    span.className = 'percent';
    span.textContent = data.summary.percent.toFixed(1) + '%';
    summary.appendChild(span);
    summary.appendChild(document.createTextNode(
      ' coverage (' + data.summary.coveredLines + '/' + data.summary.totalLines + ' lines)'
    ));
  }

  function renderTree() {
    fileTree.textContent = '';
    // Auto-expand all top-level directories
    if (data.tree.children && data.tree.children.length > 0) {
      data.tree.children.forEach(child => {
        if (child.type === 'dir') {
          expandedDirs.add(getNodePath(child, 0));
        }
      });
    }
    const sortedTree = sortTreeNodes(data.tree, sortMode);
    renderNode(sortedTree, fileTree, 0);
  }

  function renderNode(node, container, depth) {
    if (node.name === '.' && node.type === 'dir') {
      // Root node, render children directly
      node.children.forEach(child => renderNode(child, container, depth));
      return;
    }

    const nodeEl = document.createElement('div');
    nodeEl.className = 'tree-node';
    nodeEl.dataset.name = node.name.toLowerCase();

    const item = document.createElement('div');
    item.className = 'tree-item';
    item.style.setProperty('--depth', depth);

    const icon = document.createElement('span');
    icon.className = 'icon';

    const name = document.createElement('span');
    name.className = 'name';
    name.textContent = node.name;

    if (node.type === 'dir') {
      const dirPath = getNodePath(node, depth);
      icon.textContent = expandedDirs.has(dirPath) ? '\u25BC' : '\u25B6';
      if (expandedDirs.has(dirPath)) {
        nodeEl.classList.add('expanded');
      }

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleDir(nodeEl, dirPath, icon);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to all directories
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);

      if (node.children && node.children.length > 0) {
        const children = document.createElement('div');
        children.className = 'tree-children';
        node.children.forEach(child => renderNode(child, children, depth + 1));
        nodeEl.appendChild(children);
      }
    } else {
      icon.textContent = '\uD83D\uDCC4';
      nodeEl.dataset.fileId = node.fileId;

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        selectFile(node.fileId);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to files
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);
    }

    container.appendChild(nodeEl);
  }

  function getNodePath(node, depth) {
    return node.name + '_' + depth;
  }

  function toggleDir(nodeEl, path, icon) {
    if (nodeEl.classList.contains('expanded')) {
      nodeEl.classList.remove('expanded');
      expandedDirs.delete(path);
      icon.textContent = '\u25B6';
    } else {
      nodeEl.classList.add('expanded');
      expandedDirs.add(path);
      icon.textContent = '\u25BC';
    }
  }

  function selectFile(fileId) {
    currentFileId = fileId;
    matches = [];
    currentMatchIndex = -1;
    matchInfo.textContent = '';
    contentSearch.value = '';
    contentSearchQuery = '';
    anchorLine = null;
    selectedRange = null;

    // Update selection in tree
    document.querySelectorAll('.tree-item.selected').forEach(el => {
      el.classList.remove('selected');
    });
    const selected = document.querySelector('[data-file-id="' + fileId + '"] .tree-item');
    if (selected) {
      selected.classList.add('selected');
    }

    const file = data.files[fileId];
    if (!file) return;

    filePath.textContent = file.path;
    renderCode(file);

    // Update URL hash for deep linking
    updateHash(fileId, null);
  }

  function renderCode(file) {
    viewport.textContent = '';

    if (!file.lines || file.lines.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty-state';
      const iconDiv = document.createElement('div');
      iconDiv.className = 'icon';
      iconDiv.textContent = '\uD83D\uDCED';
      const textDiv = document.createElement('div');
      textDiv.textContent = 'No content';
      empty.appendChild(iconDiv);
      empty.appendChild(textDiv);
      viewport.appendChild(empty);
      return;
    }

    const container = document.createElement('div');
    container.className = 'code-container';

    file.lines.forEach((line, idx) => {
      const lineEl = document.createElement('div');
      lineEl.className = 'code-line';
      lineEl.dataset.line = idx + 1;

      const cov = file.coverage[idx];
      if (cov === 2) {
        lineEl.classList.add('covered');
      } else if (cov === 1) {
        lineEl.classList.add('uncovered');
      }

      const gutter = document.createElement('div');
      gutter.className = 'gutter';

      const lineNum = document.createElement('div');
      lineNum.className = 'line-number';
      lineNum.textContent = idx + 1;
      lineNum.title = 'Click to select line, Shift+Click for range';

      // Add click handler for line number deep linking
      const lineNumber = idx + 1;
      lineNum.addEventListener('click', (e) => {
        e.stopPropagation();

        if (e.shiftKey && anchorLine !== null) {
          // Shift-click: select range from anchor to clicked line
          const start = Math.min(anchorLine, lineNumber);
          const end = Math.max(anchorLine, lineNumber);
          selectedRange = { start: start, end: end };
          selectLineRange(start, end);
          updateHash(currentFileId, start, end);
        } else {
          // Regular click: set anchor and select single line
          anchorLine = lineNumber;
          selectedRange = { start: lineNumber, end: lineNumber };
          selectLineRange(lineNumber, lineNumber);
          updateHash(currentFileId, lineNumber, null);
        }
      });

      const content = document.createElement('div');
      content.className = 'line-content';
      content.textContent = line || ' ';

      lineEl.appendChild(gutter);
      lineEl.appendChild(lineNum);
      lineEl.appendChild(content);
      container.appendChild(lineEl);
    });

    viewport.appendChild(container);

    // Apply syntax highlighting after rendering if enabled
    if (syntaxHighlightEnabled) {
      applySyntaxHighlighting();
    }
  }

  function setupEventListeners() {
    // File search
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchQuery = e.target.value.toLowerCase();
        filterTree();
      }, 300);
    });

    // Content search
    let contentTimeout;
    contentSearch.addEventListener('input', (e) => {
      clearTimeout(contentTimeout);
      contentTimeout = setTimeout(() => {
        contentSearchQuery = e.target.value;
        searchInFile();
      }, 300);
    });

    contentSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (e.shiftKey) {
          goToPrevMatch();
        } else {
          goToNextMatch();
        }
      }
    });

    prevMatch.addEventListener('click', goToPrevMatch);
    nextMatch.addEventListener('click', goToNextMatch);

    // Theme toggle
    themeToggle.addEventListener('click', toggleTheme);

    // Syntax toggle
    syntaxToggle.addEventListener('click', toggleSyntax);

    // Sort controls
    const sortButtons = document.querySelectorAll('.sort-btn');
    console.log('Found', sortButtons.length, 'sort buttons');
    sortButtons.forEach(btn => {
      console.log('Attaching click handler to button:', btn.dataset.sort);
      btn.addEventListener('click', () => {
        console.log('Sort button clicked:', btn.dataset.sort);
        changeSortMode(btn.dataset.sort);
      });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f' && currentFileId !== null) {
        e.preventDefault();
        contentSearch.focus();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        searchInput.focus();
      }
      // Help modal
      if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        showHelp();
      }
      if (e.key === 'Escape') {
        // Exit search if focused
        if (document.activeElement === searchInput) {
          searchInput.value = '';
          searchQuery = '';
          filterTree();
          searchInput.blur();
          viewport.focus();
          return;
        }
        if (document.activeElement === contentSearch) {
          contentSearch.value = '';
          contentSearchQuery = '';
          matchInfo.textContent = '';
          matches = [];
          currentMatchIndex = -1;
          if (currentFileId !== null) {
            renderCode(data.files[currentFileId]);
          }
          contentSearch.blur();
          viewport.focus();
          return;
        }
        hideHelp();
      }
    });

    closeHelp.addEventListener('click', hideHelp);
    helpToggle.addEventListener('click', showHelp);
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) hideHelp();
    });
  }

  function filterTree() {
    const nodes = document.querySelectorAll('.tree-node');

    if (!searchQuery) {
      nodes.forEach(n => n.classList.remove('hidden'));
      return;
    }

    nodes.forEach(node => {
      const name = node.dataset.name || '';
      const fileId = node.dataset.fileId;

      if (fileId !== undefined) {
        const file = data.files[parseInt(fileId)];
        const matchesQuery = file && file.path.toLowerCase().includes(searchQuery);
        node.classList.toggle('hidden', !matchesQuery);
      } else {
        const hasVisibleChild = Array.from(node.querySelectorAll('[data-file-id]')).some(f => {
          const fid = parseInt(f.dataset.fileId);
          const file = data.files[fid];
          return file && file.path.toLowerCase().includes(searchQuery);
        });
        node.classList.toggle('hidden', !hasVisibleChild);
        if (hasVisibleChild && searchQuery) {
          node.classList.add('expanded');
          const icon = node.querySelector('.icon');
          if (icon && icon.textContent === '\u25B6') {
            icon.textContent = '\u25BC';
          }
        }
      }
    });
  }

  function searchInFile() {
    matches = [];
    currentMatchIndex = -1;

    // Re-render code to clear highlights
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }

    if (!contentSearchQuery || currentFileId === null) {
      matchInfo.textContent = '';
      return;
    }

    const file = data.files[currentFileId];
    if (!file) return;

    const query = contentSearchQuery.toLowerCase();

    file.lines.forEach((line, idx) => {
      const text = line || '';
      const lowerText = text.toLowerCase();
      let pos = 0;
      let matchIndex;

      while ((matchIndex = lowerText.indexOf(query, pos)) !== -1) {
        matches.push({ line: idx, start: matchIndex, length: query.length });
        pos = matchIndex + 1;
      }
    });

    if (matches.length > 0) {
      highlightMatches();
      currentMatchIndex = 0;
      scrollToMatch(0);
      updateMatchInfo();
    } else {
      matchInfo.textContent = 'No matches';
    }
  }

  function highlightMatches() {
    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    // Group matches by line
    const matchesByLine = {};
    matches.forEach((m, idx) => {
      if (!matchesByLine[m.line]) matchesByLine[m.line] = [];
      matchesByLine[m.line].push({ ...m, idx });
    });

    Object.keys(matchesByLine).forEach(lineIdx => {
      const lineEl = lineEls[parseInt(lineIdx)];
      if (!lineEl) return;

      const content = lineEl.querySelector('.line-content');
      if (!content) return;

      const text = file.lines[parseInt(lineIdx)] || '';
      const lineMatches = matchesByLine[lineIdx].sort((a, b) => a.start - b.start);

      // Build content using DOM nodes for safety
      content.textContent = '';
      let lastEnd = 0;

      lineMatches.forEach(m => {
        // Text before match
        if (m.start > lastEnd) {
          content.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
        }
        // Match span
        const span = document.createElement('span');
        span.className = 'match-highlight';
        span.dataset.matchIdx = m.idx;
        span.textContent = text.substring(m.start, m.start + m.length);
        content.appendChild(span);
        lastEnd = m.start + m.length;
      });

      // Text after last match
      if (lastEnd < text.length) {
        content.appendChild(document.createTextNode(text.substring(lastEnd)));
      }

      // Handle empty line
      if (content.childNodes.length === 0) {
        content.textContent = ' ';
      }
    });
  }

  function scrollToMatch(idx) {
    document.querySelectorAll('.current-match').forEach(el => {
      el.classList.remove('current-match');
    });

    const matchEl = document.querySelector('[data-match-idx="' + idx + '"]');
    if (matchEl) {
      matchEl.classList.add('current-match');
      matchEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function updateMatchInfo() {
    if (matches.length === 0) {
      matchInfo.textContent = 'No matches';
    } else {
      matchInfo.textContent = (currentMatchIndex + 1) + '/' + matches.length;
    }
  }

  function goToNextMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex + 1) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function goToPrevMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex - 1 + matches.length) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function toggleTheme() {
    const body = document.body;
    const current = body.dataset.theme;
    const next = current === 'dark' ? 'light' : 'dark';
    body.dataset.theme = next;
    localStorage.setItem('coverage-theme', next);
  }

  function loadTheme() {
    const saved = localStorage.getItem('coverage-theme');
    if (saved) {
      document.body.dataset.theme = saved;
    }
  }

  function applySyntaxHighlighting() {
    if (!syntaxHighlightEnabled || currentFileId === null) return;
    if (typeof hljs === 'undefined') return;

    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    lineEls.forEach((lineEl, idx) => {
      const cov = file.coverage[idx];
      // Only highlight lines with no coverage info
      if (cov !== 0) return;

      const content = lineEl.querySelector('.line-content');
      if (!content || !content.textContent.trim()) return;

      const text = content.textContent;

      // Use hljs.highlight() which returns result object
      const result = hljs.highlight(text, { language: 'go' });

      // Parse the highlighted HTML safely using DOMParser
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + result.value + '</div>', 'text/html');
      const wrapper = doc.body.firstChild;

      // Clear and append parsed nodes
      content.textContent = '';
      while (wrapper.firstChild) {
        content.appendChild(wrapper.firstChild);
      }
    });
  }

  function toggleSyntax() {
    syntaxHighlightEnabled = !syntaxHighlightEnabled;
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
    localStorage.setItem('coverage-syntax', syntaxHighlightEnabled ? 'on' : 'off');

    // Re-render current file
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }
  }

  function loadSyntaxPreference() {
    const saved = localStorage.getItem('coverage-syntax');
    if (saved !== null) {
      // User preference overrides default
      syntaxHighlightEnabled = saved === 'on';
    }
    // Update button state
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
  }

  function changeSortMode(mode) {
    if (sortMode === mode) return;

    console.log('Changing sort mode from', sortMode, 'to', mode);
    sortMode = mode;
    localStorage.setItem('coverage-sort-mode', mode);

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === mode);
    });

    // Re-render tree
    renderTree();
  }

  function loadSortPreference() {
    const saved = localStorage.getItem('coverage-sort-mode');
    if (saved && (saved === 'name' || saved === 'coverage')) {
      sortMode = saved;
    }

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === sortMode);
    });
  }

  function showHelp() {
    helpModal.classList.remove('hidden');
  }

  function hideHelp() {
    helpModal.classList.add('hidden');
  }

  // Start the app
  init();
})();

    </script>
  </body>
</html>
