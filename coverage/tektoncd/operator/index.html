<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coverage Report</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <style>
      :root {
  --sidebar-width: 280px;
  --topbar-height: 48px;
  --line-height: 20px;
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
}

[data-theme="dark"] {
  --bg: #1e1e1e;
  --bg-secondary: #252526;
  --bg-tertiary: #2d2d2d;
  --text: #d4d4d4;
  --text-muted: #808080;
  --border: #3c3c3c;
  --covered: rgba(35, 134, 54, 0.25);
  --covered-gutter: #238636;
  --uncovered: rgba(218, 54, 51, 0.25);
  --uncovered-gutter: #da3633;
  --highlight: #264f78;
  --highlight-match: #613214;
  --accent: #569cd6;
  --hover: #2a2d2e;
}

[data-theme="light"] {
  --bg: #ffffff;
  --bg-secondary: #f3f3f3;
  --bg-tertiary: #e8e8e8;
  --text: #24292f;
  --text-muted: #656d76;
  --border: #d0d7de;
  --covered: rgba(35, 134, 54, 0.15);
  --covered-gutter: #1a7f37;
  --uncovered: rgba(218, 54, 51, 0.15);
  --uncovered-gutter: #cf222e;
  --highlight: #ddf4ff;
  --highlight-match: #fff8c5;
  --accent: #0969da;
  --hover: #f6f8fa;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  font-size: 14px;
  background: var(--bg);
  color: var(--text);
}

#app {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  height: 100%;
}

/* Sidebar */
#sidebar {
  display: flex;
  flex-direction: column;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  overflow: hidden;
}

#sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
}

/* Logo link */
#logo-link {
  text-decoration: none;
  color: inherit;
  display: block;
}

#logo-link:hover #logo-container {
  opacity: 0.8;
}

#logo-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  transition: opacity 0.15s ease;
}

#logo-container .github-icon {
  flex-shrink: 0;
  color: var(--text-muted);
  transition: color 0.15s ease;
}

#logo-link:hover .github-icon {
  color: var(--accent);
}

#logo {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

#logo-text {
  flex: 1;
  min-width: 0;
}

#sidebar-header h1 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  line-height: 1.2;
}

#tagline {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  margin: 2px 0 0 0;
  line-height: 1.3;
}

#summary {
  font-size: 13px;
  color: var(--text-muted);
}

#summary .percent {
  font-weight: 600;
  color: var(--text);
}

#search-box {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
}

#search-input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 13px;
}

#search-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Sort controls */
#sort-controls {
  display: flex;
  gap: 0;
  margin: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}

.sort-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 6px 8px;
  background: var(--bg-secondary);
  color: var(--text);
  border: none;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.2s, color 0.2s;
}

.sort-btn:hover {
  background: var(--hover);
}

.sort-btn.active {
  background: var(--accent);
  color: #fff;
}

.sort-btn .icon {
  font-weight: 600;
}

.sort-btn .label {
  font-size: 11px;
}

/* Coverage badges for directories */
.coverage-badge {
  margin-left: auto;
  padding-left: 8px;
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  font-family: var(--font-mono);
}

#file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}

/* Sidebar footer */
#sidebar-footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  font-size: 12px;
  text-align: center;
}

#sidebar-footer a {
  color: var(--text-muted);
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

#sidebar-footer a:hover {
  color: var(--accent);
  text-decoration: underline;
}

#sidebar-footer .github-icon {
  flex-shrink: 0;
}

.tree-node {
  cursor: pointer;
  user-select: none;
}

.tree-item {
  display: flex;
  align-items: center;
  padding: 4px 16px;
  gap: 6px;
  white-space: nowrap;
}

.tree-item:hover {
  background: var(--hover);
}

.tree-item.selected {
  background: var(--highlight);
}

.tree-item .icon {
  width: 16px;
  text-align: center;
  font-size: 12px;
  color: var(--text-muted);
}

.tree-item .name {
  font-size: 13px;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.tree-children {
  display: none;
}

.tree-node.expanded > .tree-children {
  display: block;
}

.tree-children .tree-item {
  padding-left: calc(16px + var(--depth, 0) * 16px);
}

.tree-node.hidden {
  display: none;
}

/* Canvas */
#canvas {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--topbar-height);
  padding: 0 16px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  gap: 16px;
}

#file-path {
  font-size: 13px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#topbar-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

#in-file-search {
  display: flex;
  align-items: center;
  gap: 8px;
}

#content-search {
  width: 180px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 12px;
}

#content-search:focus {
  outline: none;
  border-color: var(--accent);
}

#match-info {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
}

#prev-match, #next-match {
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 10px;
}

#prev-match:hover, #next-match:hover {
  background: var(--hover);
}

#theme-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 16px;
}

#theme-toggle:hover {
  background: var(--hover);
}

#syntax-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-family: var(--font-mono);
}

#syntax-toggle:hover {
  background: var(--hover);
}

#syntax-toggle.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

#help-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
}

#help-toggle:hover {
  background: var(--hover);
}

/* Override highlight.js to use theme-aware colors */
.hljs { background: transparent !important; }

[data-theme="dark"] .hljs-keyword { color: #569cd6; }
[data-theme="dark"] .hljs-type { color: #4ec9b0; }
[data-theme="dark"] .hljs-string { color: #ce9178; }
[data-theme="dark"] .hljs-number { color: #b5cea8; }
[data-theme="dark"] .hljs-comment { color: #6a9955; }
[data-theme="dark"] .hljs-built_in { color: #dcdcaa; }
[data-theme="dark"] .hljs-literal { color: #569cd6; }
[data-theme="dark"] .hljs-function { color: #dcdcaa; }

[data-theme="light"] .hljs-keyword { color: #0000ff; }
[data-theme="light"] .hljs-type { color: #267f99; }
[data-theme="light"] .hljs-string { color: #a31515; }
[data-theme="light"] .hljs-number { color: #098658; }
[data-theme="light"] .hljs-comment { color: #008000; }
[data-theme="light"] .hljs-built_in { color: #795e26; }
[data-theme="light"] .hljs-literal { color: #0000ff; }
[data-theme="light"] .hljs-function { color: #795e26; }

/* Viewport */
#viewport {
  flex: 1;
  overflow: auto;
  background: var(--bg);
  outline: none;
}

#viewport::-webkit-scrollbar {
  width: 14px;
  height: 14px;
}

#viewport::-webkit-scrollbar-track {
  background: var(--bg);
}

#viewport::-webkit-scrollbar-thumb {
  background: var(--border);
  border: 3px solid var(--bg);
  border-radius: 7px;
}

#viewport::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

.code-container {
  display: table;
  min-width: 100%;
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: var(--line-height);
}

.code-line {
  display: table-row;
}

.code-line:hover {
  background: var(--hover);
}

.code-line.covered {
  background: var(--covered);
}

.code-line.uncovered {
  background: var(--uncovered);
}

.code-line.covered:hover {
  background: var(--covered);
}

.code-line.uncovered:hover {
  background: var(--uncovered);
}

.gutter {
  display: table-cell;
  width: 4px;
  min-width: 4px;
}

.code-line.covered .gutter {
  background: var(--covered-gutter);
}

.code-line.uncovered .gutter {
  background: var(--uncovered-gutter);
}

.line-number {
  display: table-cell;
  width: 50px;
  min-width: 50px;
  padding: 0 12px 0 8px;
  text-align: right;
  color: var(--text-muted);
  user-select: none;
  vertical-align: top;
}

.line-content {
  display: table-cell;
  padding-right: 16px;
  white-space: pre;
  tab-size: 4;
}

.match-highlight {
  background: var(--highlight-match);
  border-radius: 2px;
}

.current-match {
  background: var(--accent);
  color: #fff;
}

/* Empty state */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-muted);
  gap: 8px;
}

.empty-state .icon {
  font-size: 48px;
  opacity: 0.5;
}

/* Scrollbar for file tree */
#file-tree::-webkit-scrollbar {
  width: 8px;
}

#file-tree::-webkit-scrollbar-track {
  background: transparent;
}

#file-tree::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

#file-tree::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Help modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  max-width: 400px;
  width: 90%;
}

.modal-content h2 {
  margin-bottom: 16px;
  font-size: 18px;
}

.modal-content dl {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px 16px;
}

.modal-content dt {
  font-family: var(--font-mono);
  background: var(--bg-tertiary);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
}

.modal-content dd {
  color: var(--text-muted);
}

.modal-content button {
  margin-top: 20px;
  padding: 8px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  width: 100%;
}

/* Selected line range (multi-line selection) */
.code-line.selected-line {
  background-color: var(--highlight);
}

.code-line.selected-line.covered {
  background-color: var(--highlight);
}

.code-line.selected-line.uncovered {
  background-color: var(--highlight);
}

/* Line number click indicator */
.line-number {
  cursor: pointer;
}

.line-number:hover {
  color: var(--accent);
}

    </style>
  </head>
  <body data-theme="dark">
    <div id="app">
      <aside id="sidebar">
        <div id="sidebar-header">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            id="logo-link"
            target="_blank"
            rel="noopener"
          >
            <div id="logo-container">
              <svg id="logo" viewBox="0 0 32 32" width="32" height="32">
                <defs>
                  <linearGradient
                    id="logoGradient"
                    x1="0%"
                    y1="0%"
                    x2="100%"
                    y2="100%"
                  >
                    <stop
                      offset="0%"
                      style="stop-color: var(--accent); stop-opacity: 1"
                    />
                    <stop
                      offset="100%"
                      style="stop-color: var(--accent); stop-opacity: 0.7"
                    />
                  </linearGradient>
                </defs>
                
                <circle
                  cx="16"
                  cy="16"
                  r="14"
                  fill="none"
                  stroke="url(#logoGradient)"
                  stroke-width="2"
                  opacity="0.3"
                />
                
                <path
                  d="M 10 17 L 14 21 L 22 11"
                  fill="none"
                  stroke="var(--accent)"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                
                <circle
                  cx="24"
                  cy="10"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
                <circle
                  cx="26"
                  cy="12"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
              </svg>
              <div id="logo-text">
                <h1>GO Coverage</h1>
                <div id="tagline">A better HTML Go Coverage</div>
              </div>
            </div>
          </a>
          <div id="summary"></div>
        </div>
        <div id="search-box">
          <input type="text" id="search-input" placeholder="Search files..." />
        </div>
        <div id="sort-controls">
          <button
            class="sort-btn active"
            data-sort="name"
            title="Sort alphabetically"
          >
            <span class="icon">Aâ†’Z</span>
            <span class="label">Name</span>
          </button>
          <button
            class="sort-btn"
            data-sort="coverage"
            title="Sort by coverage percentage"
          >
            <span class="icon">%</span>
            <span class="label">Coverage</span>
          </button>
        </div>
        <div id="file-tree"></div>
        <footer id="sidebar-footer">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            target="_blank"
            rel="noopener"
          >
            <svg
              class="github-icon"
              viewBox="0 0 16 16"
              width="14"
              height="14"
              fill="currentColor"
            >
              <path
                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
              />
            </svg>
            chmouel/go-better-html-coverage
          </a>
        </footer>
      </aside>
      <main id="canvas">
        <header id="topbar">
          <div id="file-path"></div>
          <div id="topbar-actions">
            <div id="in-file-search">
              <input
                type="text"
                id="content-search"
                placeholder="Search in file..."
              />
              <span id="match-info"></span>
              <button id="prev-match" title="Previous match">&#9650;</button>
              <button id="next-match" title="Next match">&#9660;</button>
            </div>
            <button id="syntax-toggle" title="Toggle syntax highlighting">
              &lt;/&gt;
            </button>
            <button id="theme-toggle" title="Toggle theme">&#9788;</button>
            <button id="help-toggle" title="Keyboard shortcuts">?</button>
          </div>
        </header>
        <div id="viewport" tabindex="-1"></div>
      </main>
      <div id="help-modal" class="modal hidden">
        <div class="modal-content">
          <h2>Keyboard Shortcuts</h2>
          <dl>
            <dt>Ctrl+P</dt>
            <dd>Focus file search</dd>
            <dt>Ctrl+F</dt>
            <dd>Search in file</dd>
            <dt>Enter</dt>
            <dd>Next match</dd>
            <dt>Shift+Enter</dt>
            <dd>Previous match</dd>
            <dt>?</dt>
            <dd>Show this help</dd>
            <dt>Esc</dt>
            <dd>Close modal</dd>
          </dl>
          <h2>Permalinks</h2>
          <dl>
            <dt>Click line</dt>
            <dd>Select line, update URL</dd>
            <dt>Shift+Click</dt>
            <dd>Select line range</dd>
          </dl>
          <button id="close-help">Close</button>
        </div>
      </div>
    </div>
    <script>
      window.COVERAGE_DATA = {"files":[{"id":0,"path":"pkg/apis/operator/v1alpha1/additional_options_validation.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"fmt\"","","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"knative.dev/pkg/apis\"",")","","var (","\tvalidatePipelineWebhookConfigurationFailurePolicy = sets.NewString(\"Ignore\", \"Fail\")","\tvalidatePipelineWebhookConfigurationSideEffects   = sets.NewString(\"NoneOnDryRun\", \"None\", \"Unknown\", \"Some\")",")","","func (w *WebhookConfigurationOptions) validate(path string) (errs *apis.FieldError) {","\tif w.FailurePolicy != nil \u0026\u0026 !validatePipelineWebhookConfigurationFailurePolicy.Has(string(*w.FailurePolicy)) {","\t\terrs = errs.Also(apis.ErrInvalidValue(*w.FailurePolicy, fmt.Sprintf(\"%s.webhookconfigurationoptions.failurePolicy\", path)))","\t}","\tif w.SideEffects != nil \u0026\u0026 !validatePipelineWebhookConfigurationSideEffects.Has(string(*w.SideEffects)) {","\t\terrs = errs.Also(apis.ErrInvalidValue(*w.SideEffects, fmt.Sprintf(\"%s.webhookconfigurationoptions.sideEffects\", path)))","\t}","\treturn errs","}","","func (op *AdditionalOptions) validate(path string) (errs *apis.FieldError) {","\tif op.WebhookConfigurationOptions != nil {","\t\tfor _, webhookConfig := range op.WebhookConfigurationOptions {","\t\t\treturn webhookConfig.validate(path)","\t\t}","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,1,2,0,0,2,2,2,2,2,0,2,0]},{"id":1,"path":"pkg/apis/operator/v1alpha1/common.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"os\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","const (","\t// InstallSucceeded is a Condition indiciating that the installation of the component","\t// itself has been successful.","\tInstallSucceeded apis.ConditionType = \"InstallSucceeded\"",")","","// TektonComponent is a common interface for accessing meta, spec and status of all known types.","type TektonComponent interface {","\tmetav1.Object","\tschema.ObjectKind","","\t// GetSpec returns the common spec for all known types.","\tGetSpec() TektonComponentSpec","\t// GetStatus returns the common status of all known types.","\tGetStatus() TektonComponentStatus","}","","// TektonComponentSpec is a common interface for accessing the common spec of all known types.","type TektonComponentSpec interface {","\t// GetTargetNamespace gets the version to be installed","\tGetTargetNamespace() string","}","","// TektonComponentStatus is a common interface for status mutations of all known types.","type TektonComponentStatus interface {","\tMarkNotReady(string)","\tMarkInstallerSetReady()","","\tMarkInstallerSetNotReady(string)","\tMarkInstallerSetAvailable()","","\tMarkPreReconcilerFailed(string)","\tMarkPostReconcilerFailed(string)","","\t// GetVersion gets the currently installed version of the component.","\tGetVersion() string","\t// SetVersion sets the currently installed version of the component.","\tSetVersion(version string)","\t// IsReady return true if all conditions are satisfied","\tIsReady() bool","\t// ConditionAccessor Implement to interact with a condition","\tapis.ConditionAccessor","}","","// CommonSpec unifies common fields and functions on the Spec.","type CommonSpec struct {","\t// TargetNamespace is where resources will be installed","\t// +optional","\tTargetNamespace string `json:\"targetNamespace,omitempty\"`","}","","// GetTargetNamespace implements KComponentSpec.","func (c *CommonSpec) GetTargetNamespace() string {","\treturn c.TargetNamespace","}","","// Param declares an string value to use for the parameter called name.","type Param struct {","\tName  string `json:\"name,omitempty\"`","\tValue string `json:\"value,omitempty\"`","}","","// ParamValue defines a default value and possible values for a param","type ParamValue struct {","\tDefault  string","\tPossible []string","}","","// ParseParams returns the params array as map","func ParseParams(params []Param) map[string]string {","\tparamsMap := map[string]string{}","\tfor _, p := range params {","\t\tparamsMap[p.Name] = p.Value","\t}","\treturn paramsMap","}","","func IsOpenShiftPlatform() bool {","\treturn os.Getenv(\"PLATFORM\") == \"openshift\"","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,2,2,2]},{"id":2,"path":"pkg/apis/operator/v1alpha1/common_validation.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"fmt\"","","\t\"knative.dev/pkg/apis\"",")","","func (ta *CommonSpec) validate(path string) *apis.FieldError {","\tvar errs *apis.FieldError","\ttargetNamespacePath := fmt.Sprintf(\"%s.targetNamespace\", path)","\tif ta.GetTargetNamespace() == \"\" {","\t\terrs = errs.Also(apis.ErrMissingField(targetNamespacePath))","\t} else if IsOpenShiftPlatform() {","\t\t// \"openshift-operators\" namespace restricted in openshift environment","\t\tif ta.GetTargetNamespace() == \"openshift-operators\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(ta.GetTargetNamespace(), targetNamespacePath, \"'openshift-operators' namespace is not allowed\"))","\t\t}","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,2,0]},{"id":3,"path":"pkg/apis/operator/v1alpha1/manualapprovalgate_lifecycle.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\t_ TektonComponentStatus = (*ManualApprovalGateStatus)(nil)","","\tmagCondSet = apis.NewLivingConditionSet(","\t\tDependenciesInstalled,","\t\tPreReconciler,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","// GroupVersionKind returns SchemeGroupVersion of a ManualApprovalGate","func (mag *ManualApprovalGate) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindManualApprovalGate)","}","","func (mag *ManualApprovalGate) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindManualApprovalGate)","}","","// GetCondition returns the current condition of a given condition type","func (mag *ManualApprovalGateStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn magCondSet.Manage(mag).GetCondition(t)","}","","// InitializeConditions initializes conditions of an ManualApprovalGateStatus","func (mag *ManualApprovalGateStatus) InitializeConditions() {","\tmagCondSet.Manage(mag).InitializeConditions()","}","","// IsReady looks at the conditions returns true if they are all true.","func (mag *ManualApprovalGateStatus) IsReady() bool {","\treturn magCondSet.Manage(mag).IsHappy()","}","","func (mag *ManualApprovalGateStatus) MarkPreReconcilerComplete() {","\tmagCondSet.Manage(mag).MarkTrue(PreReconciler)","}","","func (mag *ManualApprovalGateStatus) MarkInstallerSetAvailable() {","\tmagCondSet.Manage(mag).MarkTrue(InstallerSetAvailable)","}","","func (mag *ManualApprovalGateStatus) MarkInstallerSetReady() {","\tmagCondSet.Manage(mag).MarkTrue(InstallerSetReady)","}","","func (mag *ManualApprovalGateStatus) MarkPostReconcilerComplete() {","\tmagCondSet.Manage(mag).MarkTrue(PostReconciler)","}","","// MarkDependenciesInstalled marks the DependenciesInstalled status as true.","func (mag *ManualApprovalGateStatus) MarkDependenciesInstalled() {","\tmagCondSet.Manage(mag).MarkTrue(DependenciesInstalled)","}","","func (mag *ManualApprovalGateStatus) MarkNotReady(msg string) {","\tmagCondSet.Manage(mag).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (mag *ManualApprovalGateStatus) MarkPreReconcilerFailed(msg string) {","\tmag.MarkNotReady(\"PreReconciliation failed\")","\tmagCondSet.Manage(mag).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (mag *ManualApprovalGateStatus) MarkInstallerSetNotAvailable(msg string) {","\tmag.MarkNotReady(\"TektonInstallerSet not ready\")","\tmagCondSet.Manage(mag).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (mag *ManualApprovalGateStatus) MarkInstallerSetNotReady(msg string) {","\tmag.MarkNotReady(\"TektonInstallerSet not ready\")","\tmagCondSet.Manage(mag).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (mag *ManualApprovalGateStatus) MarkPostReconcilerFailed(msg string) {","\tmag.MarkNotReady(\"PostReconciliation failed\")","\tmagCondSet.Manage(mag).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","// MarkDependencyInstalling marks the DependenciesInstalled status as false with the","// given message.","func (mag *ManualApprovalGateStatus) MarkDependencyInstalling(msg string) {","\tmag.MarkNotReady(\"Dependencies installing\")","\tmagCondSet.Manage(mag).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency installing: %s\", msg)","}","","// MarkDependencyMissing marks the DependenciesInstalled status as false with the","// given message.","func (mag *ManualApprovalGateStatus) MarkDependencyMissing(msg string) {","\tmag.MarkNotReady(\"Missing Dependencies for ManualApprovalGate\")","\tmagCondSet.Manage(mag).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency missing: %s\", msg)","}","","func (mag *ManualApprovalGateStatus) GetTektonInstallerSet() string {","\treturn mag.TektonInstallerSet","}","","func (mag *ManualApprovalGateStatus) SetTektonInstallerSet(installerSet string) {","\tmag.TektonInstallerSet = installerSet","}","","// GetVersion gets the currently installed version of the component.","func (mag *ManualApprovalGateStatus) GetVersion() string {","\treturn mag.Version","}","","// SetVersion sets the currently installed version of the component.","func (mag *ManualApprovalGateStatus) SetVersion(version string) {","\tmag.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":4,"path":"pkg/apis/operator/v1alpha1/manualapprovalgate_types.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","var (","\t_ TektonComponent     = (*ManualApprovalGate)(nil)","\t_ TektonComponentSpec = (*ManualApprovalGateSpec)(nil)",")","","// ManualApprovalGate is the Schema for the ManualApprovalGate API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type ManualApprovalGate struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   ManualApprovalGateSpec   `json:\"spec,omitempty\"`","\tStatus ManualApprovalGateStatus `json:\"status,omitempty\"`","}","","type ManualApprovalGateSpec struct {","\tCommonSpec     `json:\",inline\"`","\tManualApproval `json:\",inline\"`","}","","type ManualApproval struct {","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","// ManualApprovalGateList contains a list of ManualApprovalGate","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type ManualApprovalGateList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []ManualApprovalGate `json:\"items\"`","}","","// GetSpec implements TektonComponent","func (mag *ManualApprovalGate) GetSpec() TektonComponentSpec {","\treturn \u0026mag.Spec","}","","// GetStatus implements TektonComponent","func (mag *ManualApprovalGate) GetStatus() TektonComponentStatus {","\treturn \u0026mag.Status","}","","// ManualApprovalGateStatus defines the observed state of ManualApprovalGate","type ManualApprovalGateStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name for ManualApprovalGate","\t// +optional","\tTektonInstallerSet string `json:\"tektonInstallerSet,omitempty\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":5,"path":"pkg/apis/operator/v1alpha1/openshiftpipelinesascode_defaults.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strconv\"","\t\"strings\"","\t\"sync\"","","\tpacSettings \"github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"",")","","func (pac *OpenShiftPipelinesAsCode) SetDefaults(ctx context.Context) {","\tif pac.Spec.PACSettings.Settings == nil {","\t\tpac.Spec.PACSettings.Settings = map[string]string{}","\t}","\tif pac.Spec.PACSettings.AdditionalPACControllers == nil {","\t\tpac.Spec.PACSettings.AdditionalPACControllers = map[string]AdditionalPACControllerConfig{}","\t}","\tlogger := logging.FromContext(ctx)","\tpac.Spec.PACSettings.setPACDefaults(logger)","}","","func (set *PACSettings) setPACDefaults(logger *zap.SugaredLogger) {","\tif set.Settings == nil {","\t\tset.Settings = map[string]string{}","\t}","\tdefaultPacSettings := pacSettings.Settings{}","","\terr := pacSettings.SyncConfig(logger, \u0026defaultPacSettings, set.Settings, map[string]func(string) error{})","\tif err != nil {","\t\tlogger.Error(\"error on applying default PAC settings\", err)","\t}","","\t// Remove tektonhub catalog to only keep artifacthub","\tdefaultPacSettings.HubCatalogs.Delete(\"tektonhub\")","","\tset.Settings = ConvertPacStructToConfigMap(\u0026defaultPacSettings)","\tsetAdditionalPACControllerDefault(set.AdditionalPACControllers)","}","","// Set the default values for additional PAc controller resources","func setAdditionalPACControllerDefault(additionalPACController map[string]AdditionalPACControllerConfig) {","\tfor name, additionalPACInfo := range additionalPACController {","\t\tif additionalPACInfo.Enable == nil {","\t\t\tadditionalPACInfo.Enable = ptr.Bool(true)","\t\t}","\t\tif additionalPACInfo.ConfigMapName == \"\" {","\t\t\tadditionalPACInfo.ConfigMapName = fmt.Sprintf(\"%s-pipelines-as-code-configmap\", name)","\t\t}","\t\tif additionalPACInfo.SecretName == \"\" {","\t\t\tadditionalPACInfo.SecretName = fmt.Sprintf(\"%s-pipelines-as-code-secret\", name)","\t\t}","\t\tadditionalPACController[name] = additionalPACInfo","\t}","}","","func ConvertPacStructToConfigMap(settings *pacSettings.Settings) map[string]string {","\tconfig := map[string]string{}","\tif settings == nil {","\t\treturn config","\t}","\tstructValue := reflect.ValueOf(settings).Elem()","\tstructType := reflect.TypeOf(settings).Elem()","","\tfor i := 0; i \u003c structType.NumField(); i++ {","\t\tfield := structType.Field(i)","\t\tfieldName := field.Name","","\t\tjsonTag := field.Tag.Get(\"json\")","\t\tif jsonTag == \"-\" {","\t\t\tcontinue","\t\t}","\t\tkey := strings.ToLower(jsonTag)","\t\telement := structValue.FieldByName(fieldName)","\t\tif !element.IsValid() {","\t\t\tcontinue","\t\t}","","\t\t//nolint","\t\tswitch field.Type.Kind() {","\t\tcase reflect.String:","\t\t\tconfig[key] = element.String()","\t\tcase reflect.Bool:","\t\t\tconfig[key] = strconv.FormatBool(element.Bool())","\t\tcase reflect.Int:","\t\t\tconfig[key] = strconv.FormatInt(element.Int(), 10)","\t\tcase reflect.Ptr:","\t\t\t// for hub catalogs map","\t\t\tif key == \"\" {","\t\t\t\tdata := element.Interface().(*sync.Map)","\t\t\t\tdata.Range(func(key, value any) bool {","\t\t\t\t\tcatalogData := value.(pacSettings.HubCatalog)","\t\t\t\t\tif key == \"default\" {","\t\t\t\t\t\tconfig[pacSettings.HubURLKey] = catalogData.URL","\t\t\t\t\t\tconfig[pacSettings.HubCatalogTypeKey] = catalogData.Type","\t\t\t\t\t\tif catalogData.Name != \"\" {","\t\t\t\t\t\t\tconfig[pacSettings.HubCatalogNameKey] = catalogData.Name","\t\t\t\t\t\t}","\t\t\t\t\t\treturn true","\t\t\t\t\t}","\t\t\t\t\tconfig[fmt.Sprintf(\"%s-%s-%s\", \"catalog\", catalogData.Index, \"id\")] = key.(string)","\t\t\t\t\tconfig[fmt.Sprintf(\"%s-%s-%s\", \"catalog\", catalogData.Index, \"name\")] = catalogData.Name","\t\t\t\t\tconfig[fmt.Sprintf(\"%s-%s-%s\", \"catalog\", catalogData.Index, \"url\")] = catalogData.URL","\t\t\t\t\tconfig[fmt.Sprintf(\"%s-%s-%s\", \"catalog\", catalogData.Index, \"type\")] = catalogData.Type","\t\t\t\t\treturn true","\t\t\t\t})","\t\t\t}","\t\tdefault:","\t\t\t// Skip unsupported field types","\t\t\tcontinue","\t\t}","\t}","","\treturn config","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,0,2,2,2,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,2,2,2,2,2,0,0,1,1,1,0,0,0,2,0]},{"id":6,"path":"pkg/apis/operator/v1alpha1/openshiftpipelinesascode_lifecycle.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\t_ TektonComponentStatus = (*OpenShiftPipelinesAsCodeStatus)(nil)","","\topacCondSet = apis.NewLivingConditionSet(","\t\tDependenciesInstalled,","\t\tPreReconciler,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tAdditionalPACControllerInstalled,","\t\tPostReconciler,","\t)",")","","const (","\tAdditionalPACControllerInstalled apis.ConditionType = \"AdditionalPACControllerInstalled\"",")","","func (pac *OpenShiftPipelinesAsCode) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindOpenShiftPipelinesAsCode)","}","","func (pac *OpenShiftPipelinesAsCode) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindOpenShiftPipelinesAsCode)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn opacCondSet.Manage(pac).GetCondition(t)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) InitializeConditions() {","\topacCondSet.Manage(pac).InitializeConditions()","}","","func (pac *OpenShiftPipelinesAsCodeStatus) IsReady() bool {","\treturn opacCondSet.Manage(pac).IsHappy()","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkPreReconcilerComplete() {","\topacCondSet.Manage(pac).MarkTrue(PreReconciler)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetAvailable() {","\topacCondSet.Manage(pac).MarkTrue(InstallerSetAvailable)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetReady() {","\topacCondSet.Manage(pac).MarkTrue(InstallerSetReady)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkAdditionalPACControllerComplete() {","\topacCondSet.Manage(pac).MarkTrue(AdditionalPACControllerInstalled)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkPostReconcilerComplete() {","\topacCondSet.Manage(pac).MarkTrue(PostReconciler)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkNotReady(msg string) {","\topacCondSet.Manage(pac).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkPreReconcilerFailed(msg string) {","\tpac.MarkNotReady(\"PreReconciliation failed\")","\topacCondSet.Manage(pac).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetNotAvailable(msg string) {","\tpac.MarkNotReady(\"TektonInstallerSet not ready\")","\topacCondSet.Manage(pac).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetNotReady(msg string) {","\tpac.MarkNotReady(\"TektonInstallerSet not ready\")","\topacCondSet.Manage(pac).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkPostReconcilerFailed(msg string) {","\tpac.MarkNotReady(\"PostReconciliation failed\")","\topacCondSet.Manage(pac).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkDependenciesInstalled() {","\topacCondSet.Manage(pac).MarkTrue(DependenciesInstalled)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkDependencyInstalling(msg string) {","\tpac.MarkNotReady(\"Dependencies installing\")","\topacCondSet.Manage(pac).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are installing: %s\", msg)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) MarkDependencyMissing(msg string) {","\tpac.MarkNotReady(\"Missing Dependencies for TektonTriggers\")","\topacCondSet.Manage(pac).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are missing: %s\", msg)","}","","func (pac *OpenShiftPipelinesAsCodeStatus) GetVersion() string {","\treturn pac.Version","}","","func (pac *OpenShiftPipelinesAsCodeStatus) SetVersion(version string) {","\tpac.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1]},{"id":7,"path":"pkg/apis/operator/v1alpha1/openshiftpipelinesascode_types.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// OpenShiftPipelinesAsCode is the Schema for the OpenShiftPipelinesAsCode API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type OpenShiftPipelinesAsCode struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   OpenShiftPipelinesAsCodeSpec   `json:\"spec,omitempty\"`","\tStatus OpenShiftPipelinesAsCodeStatus `json:\"status,omitempty\"`","}","","// GetSpec implements TektonComponent","func (pac *OpenShiftPipelinesAsCode) GetSpec() TektonComponentSpec {","\treturn \u0026pac.Spec","}","","// GetStatus implements TektonComponent","func (pac *OpenShiftPipelinesAsCode) GetStatus() TektonComponentStatus {","\treturn \u0026pac.Status","}","","// OpenShiftPipelinesAsCodeSpec defines the desired state of OpenShiftPipelinesAsCode","type OpenShiftPipelinesAsCodeSpec struct {","\tCommonSpec  `json:\",inline\"`","\tConfig      Config `json:\"config,omitempty\"`","\tPACSettings `json:\",inline\"`","}","","// OpenShiftPipelinesAsCodeStatus defines the observed state of OpenShiftPipelinesAsCode","type OpenShiftPipelinesAsCodeStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","}","","// OpenShiftPipelinesAsCodeList contains a list of OpenShiftPipelinesAsCode","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type OpenShiftPipelinesAsCodeList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []OpenShiftPipelinesAsCode `json:\"items\"`","}","","type PACSettings struct {","\tSettings map[string]string `json:\"settings,omitempty\"`","\t// AdditionalPACControllers allows to deploy additional PAC controller","\t// +optional","\tAdditionalPACControllers map[string]AdditionalPACControllerConfig `json:\"additionalPACControllers,omitempty\"`","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","// AdditionalPACControllerConfig contains config for additionalPACControllers","type AdditionalPACControllerConfig struct {","\t// Enable or disable this additional pipelines as code instance by changing this bool","\t// +optional","\tEnable *bool `json:\"enable,omitempty\"`","\t// Name of the additional controller configMap","\t// +optional","\tConfigMapName string `json:\"configMapName,omitempty\"`","\t// Name of the additional controller Secret","\t// +optional","\tSecretName string `json:\"secretName,omitempty\"`","\t// Setting will contains the configMap data","\t// +optional","\tSettings map[string]string `json:\"settings,omitempty\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":8,"path":"pkg/apis/operator/v1alpha1/openshiftpipelinesascode_validation.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","","\tpacSettings \"github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings\"","\t\"go.uber.org/zap\"","\tkubernetesValidation \"k8s.io/apimachinery/pkg/util/validation\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"",")","","// limit is 25 because this name goes in the installerset name which already have 38 characters, so additional length we","// can have for name is 25, as the kubernetes have restriction for 63","const additionalPACControllerNameMaxLength = 25","","func (pac *OpenShiftPipelinesAsCode) Validate(ctx context.Context) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tvar errs *apis.FieldError","","\tlogger := logging.FromContext(ctx)","","\t// execute common spec validations","\terrs = errs.Also(pac.Spec.CommonSpec.validate(\"spec\"))","","\terrs = errs.Also(pac.Spec.PACSettings.validate(logger, \"spec\"))","","\treturn errs","}","","func (ps *PACSettings) validate(logger *zap.SugaredLogger, path string) *apis.FieldError {","\tvar errs *apis.FieldError","","\tdefaultPacSettings := pacSettings.Settings{}","\tif err := pacSettings.SyncConfig(logger, \u0026defaultPacSettings, ps.Settings, pacSettings.DefaultValidators()); err != nil {","\t\terrs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf(\"%s.settings\", path)))","\t}","","\tfor name, additionalPACControllerConfig := range ps.AdditionalPACControllers {","\t\tif err := validateAdditionalPACControllerName(name); err != nil {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf(\"%s.additionalPACControllers\", path)))","\t\t}","","\t\terrs = errs.Also(additionalPACControllerConfig.validate(fmt.Sprintf(\"%s.additionalPACControllers\", path)))","\t}","","\treturn errs","}","","func (aps AdditionalPACControllerConfig) validate(path string) *apis.FieldError {","\tvar errs *apis.FieldError","","\tif err := validateKubernetesName(aps.ConfigMapName); err != nil {","\t\terrs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf(\"%s.configMapName\", path)))","\t}","","\tif err := validateKubernetesName(aps.SecretName); err != nil {","\t\terrs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf(\"%s.secretName\", path)))","\t}","","\tif err := validateAdditionalPACControllerSettings(aps.Settings); err != nil {","\t\terrs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf(\"%s.settings\", path)))","\t}","","\treturn errs","}","","// validates the name of the controller resource is valid kubernetes name","func validateAdditionalPACControllerName(name string) *apis.FieldError {","\tif err := kubernetesValidation.IsDNS1123Subdomain(name); len(err) \u003e 0 {","\t\treturn \u0026apis.FieldError{","\t\t\tMessage: fmt.Sprintf(\"invalid resource name %q: must be a valid DNS label\", name),","\t\t\tPaths:   []string{\"name\"},","\t\t}","\t}","","\tif len(name) \u003e additionalPACControllerNameMaxLength {","\t\treturn \u0026apis.FieldError{","\t\t\tMessage: fmt.Sprintf(\"invalid resource name %q: length must be no more than %d characters\", name, additionalPACControllerNameMaxLength),","\t\t\tPaths:   []string{\"name\"},","\t\t}","\t}","\treturn nil","}","","// validates the name of the resource is valid kubernetes name","func validateKubernetesName(name string) *apis.FieldError {","\tif err := kubernetesValidation.IsDNS1123Subdomain(name); len(err) \u003e 0 {","\t\treturn \u0026apis.FieldError{","\t\t\tMessage: fmt.Sprintf(\"invalid resource name %q: must be a valid DNS label\", name),","\t\t\tPaths:   []string{\"name\"},","\t\t}","\t}","","\tif len(name) \u003e kubernetesValidation.DNS1123LabelMaxLength {","\t\treturn \u0026apis.FieldError{","\t\t\tMessage: fmt.Sprintf(\"invalid resource name %q: length must be no more than %d characters\", name, kubernetesValidation.DNS1123LabelMaxLength),","\t\t\tPaths:   []string{\"name\"},","\t\t}","\t}","\treturn nil","}","","// validates the settings of the additionalPACController","func validateAdditionalPACControllerSettings(settings map[string]string) *apis.FieldError {","\tvar errs *apis.FieldError","\tvalidators := pacSettings.DefaultValidators()","\tif len(settings) \u003e 0 {","\t\tfieldTagMapDetails := getFieldTagMap()","\t\tfor key, value := range settings {","\t\t\tfieldName, ok := fieldTagMapDetails[key]","\t\t\tif !ok {","\t\t\t\tcontinue","\t\t\t}","\t\t\tif validationFunc, ok := validators[fieldName]; ok \u0026\u0026 value != \"\" {","\t\t\t\tif err := validationFunc(value); err != nil {","\t\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf(\"validation failed for field %s\", key)))","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn errs","\t}","\treturn nil","}","","// this will return map with all the json tags with value equal to their field names","func getFieldTagMap() map[string]string {","\tvar fieldTagMapping = make(map[string]string)","\trt := reflect.TypeOf(pacSettings.Settings{})","\tfor i := 0; i \u003c rt.NumField(); i++ {","\t\tf := rt.Field(i)","\t\tv := f.Tag.Get(\"json\")","\t\tif v == \"\" || v == \"-\" {","\t\t\tcontinue","\t\t}","\t\tfieldTagMapping[v] = f.Name","\t}","\treturn fieldTagMapping","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,1,1,0,2,2,2,2,0,2,0,0,2,0,0,2,2,2,2,2,2,0,2,1,1,0,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,0,2,1,1,1,1,1,2,0,0,0,2,2,2,2,2,2,2,2,1,0,2,2,2,2,0,0,0,2,0,2,0,0,0,2,2,2,2,2,2,2,2,0,2,0,2,0]},{"id":9,"path":"pkg/apis/operator/v1alpha1/performance_validation.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"fmt\"","","\t\"knative.dev/pkg/apis\"",")","","func (ppp *PerformanceProperties) Validate(path string) *apis.FieldError {","\tvar errs *apis.FieldError","","\tbucketsPath := fmt.Sprintf(\"%s.buckets\", path)","\t// minimum and maximum allowed buckets value","\tif ppp.Buckets != nil {","\t\tif *ppp.Buckets \u003c 1 || *ppp.Buckets \u003e MaxBuckets {","\t\t\terrs = errs.Also(apis.ErrOutOfBoundsValue(*ppp.Buckets, 1, 10, bucketsPath))","\t\t}","\t}","","\t// check for StatefulsetOrdinals and Replicas","\tif ppp.StatefulsetOrdinals != nil \u0026\u0026 *ppp.StatefulsetOrdinals {","\t\tif ppp.Replicas != nil {","\t\t\treplicas := uint(*ppp.Replicas)","\t\t\tif ppp.Buckets == nil {","\t\t\t\terrs = errs.Also(apis.ErrMissingField(bucketsPath, \"spec.performance.buckets must be set when statefulset ordinals is enabled\"))","\t\t\t} else if *ppp.Buckets != replicas {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(*ppp.Replicas, fmt.Sprintf(\"%s.replicas\", path), \"spec.performance.replicas must equal spec.performance.buckets for statefulset ordinals\"))","\t\t\t}","\t\t}","\t}","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,1,2,2,2,0,0,0,2,0]},{"id":10,"path":"pkg/apis/operator/v1alpha1/register.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","const (","\t// GroupName is the group of the API.","\tGroupName = \"operator.tekton.dev\"","","\t// SchemaVersion is the current version of the API.","\tSchemaVersion = \"v1alpha1\"","","\t// KindTektonPipeline is the Kind of Tekton Pipeline in a GVK context.","\tKindTektonPipeline = \"TektonPipeline\"","","\t// KindTektonTrigger is the Kind of Tekton Trigger in a GVK context.","\tKindTektonTrigger = \"TektonTrigger\"","","\t// KindTektonDashboard is the Kind of Tekton Dashboard in a GVK context.","\tKindTektonDashboard = \"TektonDashboard\"","","\t// KindTektonAddon is the Kind of Tekton Addon in a GVK context.","\tKindTektonAddon = \"TektonAddon\"","","\t// KindTektonConfig is the Kind of Tekton Config in a GVK context.","\tKindTektonConfig = \"TektonConfig\"","","\t// KindTektonResult is the Kind of Tekton Result in a GVK context.","\tKindTektonResult = \"TektonResult\"","","\t// KindTektonInstallerSet is the Kind of TektonInstallerSet in a GVK context.","\tKindTektonInstallerSet = \"TektonInstallerSet\"","","\t// KindTektonHub is the Kind of TektonHub in a GVK context.","\tKindTektonHub = \"TektonHub\"","","\t// KindTektonChain is the Kind of Tekton Chain in a GVK context.","\tKindTektonChain = \"TektonChain\"","","\t// KindOpenShiftPipelinesAsCode is the Kind of OpenShiftPipelinesAsCode in a GVK context.","\tKindOpenShiftPipelinesAsCode = \"OpenShiftPipelinesAsCode\"","","\t// KindManualApprovalGate is the Kind of KindManualApprovalGate in a GVK context.","\tKindManualApprovalGate = \"ManualApprovalGate\"","","\t// KindTektonPruner is the Kind of TektonPruner in a GVK context.","\tKindTektonPruner = \"TektonPruner\"","","\t// KindTektonScheduler is the Kind of TektonScheduler in a GVK context.","\tKindTektonScheduler = \"TektonScheduler\"",")","","// Resource takes an unqualified resource and returns a Group qualified GroupResource","func Resource(resource string) schema.GroupResource {","\treturn SchemeGroupVersion.WithResource(resource).GroupResource()","}","","// addKnownTypes adds the set of types defined in this package to the supplied","// scheme.","func addKnownTypes(s *runtime.Scheme) error {","\ts.AddKnownTypes(SchemeGroupVersion,","\t\t\u0026TektonPipeline{},","\t\t\u0026TektonPipelineList{},","\t\t\u0026TektonTrigger{},","\t\t\u0026TektonTriggerList{},","\t\t\u0026TektonDashboard{},","\t\t\u0026TektonDashboardList{},","\t\t\u0026TektonAddon{},","\t\t\u0026TektonAddonList{},","\t\t\u0026TektonConfig{},","\t\t\u0026TektonConfigList{},","\t\t\u0026TektonResult{},","\t\t\u0026TektonResultList{},","\t\t\u0026TektonInstallerSet{},","\t\t\u0026TektonInstallerSetList{},","\t\t\u0026TektonHub{},","\t\t\u0026TektonHubList{},","\t\t\u0026TektonChain{},","\t\t\u0026TektonChainList{},","\t\t\u0026OpenShiftPipelinesAsCode{},","\t\t\u0026OpenShiftPipelinesAsCodeList{},","\t\t\u0026ManualApprovalGate{},","\t\t\u0026ManualApprovalGateList{},","\t\t\u0026TektonPruner{},","\t\t\u0026TektonPrunerList{},","\t\t\u0026TektonScheduler{},","\t\t\u0026TektonSchedulerList{},","\t)","\tmetav1.AddToGroupVersion(s, SchemeGroupVersion)","\treturn nil","}","","var (","\t// SchemeGroupVersion is group version used to register these objects","\tSchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: SchemaVersion}","","\t// SchemeBuilder is used to add go types to the GroupVersionKind scheme","\tSchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)","\t// AddToScheme adds the API's types to the Scheme.","\tAddToScheme = SchemeBuilder.AddToScheme",")"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0]},{"id":11,"path":"pkg/apis/operator/v1alpha1/tektonaddon_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"",")","","func (ta *TektonAddon) SetDefaults(ctx context.Context) {","\tsetAddonDefaults(\u0026ta.Spec.Addon)","}","","func setAddonDefaults(addon *Addon) {","","\tparamsMap := ParseParams(addon.Params)","\t_, ptOk := paramsMap[PipelineTemplatesParam]","\trt, rtOk := paramsMap[ResolverTasks]","","\t// If ResolverTask is false and pipelineTemplate is not set, then set it as false","\t// as pipelines templates are created using ResolverTask","\tif rtOk \u0026\u0026 (rt == \"false\" \u0026\u0026 !ptOk) {","\t\taddon.Params = append(addon.Params, Param{","\t\t\tName:  PipelineTemplatesParam,","\t\t\tValue: \"false\",","\t\t})","\t\tparamsMap = ParseParams(addon.Params)","\t}","","\t// set the params with default values if not set in cr","\tfor d := range AddonParams {","\t\t_, ok := paramsMap[d]","\t\tif !ok {","\t\t\taddon.Params = append(addon.Params,","\t\t\t\tParam{","\t\t\t\t\tName:  d,","\t\t\t\t\tValue: AddonParams[d].Default,","\t\t\t\t})","\t\t}","\t}","","\t// Deprecated, will be removed in further releases","\t// moved to OpenShift platform section","\taddon.EnablePAC = nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,0,0,2,0]},{"id":12,"path":"pkg/apis/operator/v1alpha1/tektonaddon_lifecycle.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\taddonsCondSet = apis.NewLivingConditionSet(","\t\tDependenciesInstalled,","\t\tPreReconciler,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","func (tp *TektonAddon) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonAddon)","}","","func (tp *TektonAddon) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonAddon)","}","","func (tas *TektonAddonStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn addonsCondSet.Manage(tas).GetCondition(t)","}","","func (tas *TektonAddonStatus) InitializeConditions() {","\taddonsCondSet.Manage(tas).InitializeConditions()","}","","func (tas *TektonAddonStatus) IsReady() bool {","\treturn addonsCondSet.Manage(tas).IsHappy()","}","","func (tas *TektonAddonStatus) MarkPreReconcilerComplete() {","\taddonsCondSet.Manage(tas).MarkTrue(PreReconciler)","}","","func (tas *TektonAddonStatus) MarkInstallerSetReady() {","\taddonsCondSet.Manage(tas).MarkTrue(InstallerSetReady)","}","","func (tas *TektonAddonStatus) MarkPostReconcilerComplete() {","\taddonsCondSet.Manage(tas).MarkTrue(PostReconciler)","}","","func (tas *TektonAddonStatus) MarkDependenciesInstalled() {","\taddonsCondSet.Manage(tas).MarkTrue(DependenciesInstalled)","}","","func (tas *TektonAddonStatus) MarkNotReady(msg string) {","\taddonsCondSet.Manage(tas).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (tas *TektonAddonStatus) MarkPreReconcilerFailed(msg string) {","\ttas.MarkNotReady(\"PreReconciliation failed\")","\taddonsCondSet.Manage(tas).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (tas *TektonAddonStatus) MarkInstallerSetNotReady(msg string) {","\ttas.MarkNotReady(\"TektonInstallerSet not ready\")","\taddonsCondSet.Manage(tas).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tas *TektonAddonStatus) MarkPostReconcilerFailed(msg string) {","\ttas.MarkNotReady(\"PostReconciliation failed\")","\taddonsCondSet.Manage(tas).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","func (tas *TektonAddonStatus) MarkDependencyInstalling(msg string) {","\ttas.MarkNotReady(\"Dependencies installing\")","\taddonsCondSet.Manage(tas).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are installing: %s\", msg)","}","","func (tas *TektonAddonStatus) MarkDependencyMissing(msg string) {","\ttas.MarkNotReady(\"Missing Dependencies for TektonTriggers\")","\taddonsCondSet.Manage(tas).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are missing: %s\", msg)","}","","func (tas *TektonAddonStatus) GetVersion() string {","\treturn tas.Version","}","","func (tas *TektonAddonStatus) SetVersion(version string) {","\ttas.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1]},{"id":13,"path":"pkg/apis/operator/v1alpha1/tektonaddon_types.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// TektonAddon is the Schema for the tektonaddons API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonAddon struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonAddonSpec   `json:\"spec,omitempty\"`","\tStatus TektonAddonStatus `json:\"status,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tp *TektonAddon) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","// GetStatus implements TektonComponent","func (tp *TektonAddon) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// TektonAddonSpec defines the desired state of TektonAddon","type TektonAddonSpec struct {","\tCommonSpec `json:\",inline\"`","\tAddon      `json:\",inline\"`","\t// Config holds the configuration for resources created by Addon","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","}","","// TektonAddonStatus defines the observed state of TektonAddon","type TektonAddonStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// TektonInstallerSet created to install addons","\t// +optional","\tAddonsInstallerSet map[string]string `json:\"installerSets,omitempty\"`","}","","func (in *TektonAddonStatus) MarkInstallerSetAvailable() {","\t//TODO implement me","\tpanic(\"implement me\")","}","","// Addon defines the field to customize Addon component","type Addon struct {","\t// Params is the list of params passed for Addon customization","\t// +optional","\tParams []Param `json:\"params,omitempty\"`","\t// Deprecated, will be removed in further release","\t// EnablePAC field defines whether to install PAC","\t// +optional","\tEnablePAC *bool `json:\"enablePipelinesAsCode,omitempty\"`","}","","func (a Addon) IsEmpty() bool {","\treturn len(a.Params) == 0","}","","// TektonAddonsList contains a list of TektonAddon","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonAddonList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonAddon `json:\"items\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0]},{"id":14,"path":"pkg/apis/operator/v1alpha1/tektonaddon_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","","\t\"knative.dev/pkg/apis\"",")","","func (ta *TektonAddon) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif ta.GetName() != AddonResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name,  Only one instance of TektonAddon is allowed by name, %s\", AddonResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(ta.GetName(), errMsg))","\t}","","\t// execute common spec validations","\terrs = errs.Also(ta.Spec.CommonSpec.validate(\"spec\"))","","\tif len(ta.Spec.Params) != 0 {","\t\terrs = errs.Also(validateAddonParams(ta.Spec.Params, \"spec.params\"))","\t}","","\treturn errs","}","","func validateAddonParams(params []Param, pathToParams string) *apis.FieldError {","\tvar errs *apis.FieldError","","\tfor i, p := range params {","\t\t// Todo: Remove this in next operator release","\t\tif p.Name == \"clusterTasks\" || p.Name == \"communityClusterTasks\" {","\t\t\tcontinue","\t\t}","\t\tparamValue, ok := AddonParams[p.Name]","\t\tif !ok {","\t\t\terrs = errs.Also(apis.ErrInvalidKeyName(p.Name, pathToParams))","\t\t\tcontinue","\t\t}","\t\tif !isValueInArray(paramValue.Possible, p.Value) {","\t\t\tpath := pathToParams + \".\" + p.Name","\t\t\terrs = errs.Also(apis.ErrInvalidArrayValue(p.Value, path, i))","\t\t}","\t}","\tparamsMap := ParseParams(params)","","\tif (paramsMap[ResolverTasks] == \"false\") \u0026\u0026 (paramsMap[PipelineTemplatesParam] == \"true\") {","\t\terrs = errs.Also(apis.ErrGeneric(\"pipelineTemplates cannot be true if resolverTask is false\", pathToParams))","\t}","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,1,1,1,0,0,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,1,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,0,2,0]},{"id":15,"path":"pkg/apis/operator/v1alpha1/tektonchain_defaults.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"knative.dev/pkg/ptr\"",")","","func (tc *TektonChain) SetDefaults(ctx context.Context) {","\ttc.Spec.Chain.setDefaults()","}","","func (c *Chain) setDefaults() {","\t// chains defaults","\tif c.ArtifactsTaskRunFormat == \"\" {","\t\tc.ArtifactsTaskRunFormat = \"in-toto\"","\t}","\tif c.ArtifactsTaskRunStorage == nil {","\t\tc.ArtifactsTaskRunStorage = ptr.String(\"oci\")","\t}","\tif c.ArtifactsPipelineRunFormat == \"\" {","\t\tc.ArtifactsPipelineRunFormat = \"in-toto\"","\t}","\tif c.ArtifactsPipelineRunStorage == nil {","\t\tc.ArtifactsPipelineRunStorage = ptr.String(\"oci\")","\t}","\tif c.ArtifactsOCIFormat == \"\" {","\t\tc.ArtifactsOCIFormat = \"simplesigning\"","\t}","\tif c.ArtifactsOCIStorage == nil {","\t\tc.ArtifactsOCIStorage = ptr.String(\"oci\")","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0]},{"id":16,"path":"pkg/apis/operator/v1alpha1/tektonchain_lifecycle.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\t_ TektonComponentStatus = (*TektonChainStatus)(nil)","","\tchainCondSet = apis.NewLivingConditionSet(","\t\tDependenciesInstalled,","\t\tPreReconciler,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","// GroupVersionKind returns SchemeGroupVersion of a TektonChain","func (tc *TektonChain) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonChain)","}","","func (tc *TektonChain) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonChain)","}","","// GetCondition returns the current condition of a given condition type","func (tcs *TektonChainStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn chainCondSet.Manage(tcs).GetCondition(t)","}","","// InitializeConditions initializes conditions of an TektonChainStatus","func (tcs *TektonChainStatus) InitializeConditions() {","\tchainCondSet.Manage(tcs).InitializeConditions()","}","","// IsReady looks at the conditions returns true if they are all true.","func (tcs *TektonChainStatus) IsReady() bool {","\treturn chainCondSet.Manage(tcs).IsHappy()","}","","func (tcs *TektonChainStatus) MarkPreReconcilerComplete() {","\tchainCondSet.Manage(tcs).MarkTrue(PreReconciler)","}","","func (tcs *TektonChainStatus) MarkInstallerSetAvailable() {","\tchainCondSet.Manage(tcs).MarkTrue(InstallerSetAvailable)","}","","func (tcs *TektonChainStatus) MarkInstallerSetReady() {","\tchainCondSet.Manage(tcs).MarkTrue(InstallerSetReady)","}","","func (tcs *TektonChainStatus) MarkPostReconcilerComplete() {","\tchainCondSet.Manage(tcs).MarkTrue(PostReconciler)","}","","// MarkDependenciesInstalled marks the DependenciesInstalled status as true.","func (tcs *TektonChainStatus) MarkDependenciesInstalled() {","\tchainCondSet.Manage(tcs).MarkTrue(DependenciesInstalled)","}","","func (tcs *TektonChainStatus) MarkNotReady(msg string) {","\tchainCondSet.Manage(tcs).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (tcs *TektonChainStatus) MarkPreReconcilerFailed(msg string) {","\ttcs.MarkNotReady(\"PreReconciliation failed\")","\tchainCondSet.Manage(tcs).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (tcs *TektonChainStatus) MarkInstallerSetNotAvailable(msg string) {","\ttcs.MarkNotReady(\"TektonInstallerSet not ready\")","\tchainCondSet.Manage(tcs).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tcs *TektonChainStatus) MarkInstallerSetNotReady(msg string) {","\ttcs.MarkNotReady(\"TektonInstallerSet not ready\")","\tchainCondSet.Manage(tcs).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tcs *TektonChainStatus) MarkPostReconcilerFailed(msg string) {","\ttcs.MarkNotReady(\"PostReconciliation failed\")","\tchainCondSet.Manage(tcs).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","// MarkDependencyInstalling marks the DependenciesInstalled status as false with the","// given message.","func (tcs *TektonChainStatus) MarkDependencyInstalling(msg string) {","\ttcs.MarkNotReady(\"Dependencies installing\")","\tchainCondSet.Manage(tcs).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency installing: %s\", msg)","}","","// MarkDependencyMissing marks the DependenciesInstalled status as false with the","// given message.","func (tcs *TektonChainStatus) MarkDependencyMissing(msg string) {","\ttcs.MarkNotReady(\"Missing Dependencies for TektonChain\")","\tchainCondSet.Manage(tcs).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency missing: %s\", msg)","}","","func (tcs *TektonChainStatus) GetTektonInstallerSet() string {","\treturn tcs.TektonInstallerSet","}","","func (tcs *TektonChainStatus) SetTektonInstallerSet(installerSet string) {","\ttcs.TektonInstallerSet = installerSet","}","","// GetVersion gets the currently installed version of the component.","func (tcs *TektonChainStatus) GetVersion() string {","\treturn tcs.Version","}","","// SetVersion sets the currently installed version of the component.","func (tcs *TektonChainStatus) SetVersion(version string) {","\ttcs.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":17,"path":"pkg/apis/operator/v1alpha1/tektonchain_types.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"encoding/json\"","\t\"fmt\"","\t\"strconv\"","","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","var (","\t_ TektonComponent     = (*TektonChain)(nil)","\t_ TektonComponentSpec = (*TektonChainSpec)(nil)",")","","// TektonChain is the Schema for the tektonchain API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonChain struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonChainSpec   `json:\"spec,omitempty\"`","\tStatus TektonChainStatus `json:\"status,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tc *TektonChain) GetSpec() TektonComponentSpec {","\treturn \u0026tc.Spec","}","","// GetStatus implements TektonComponent","func (tc *TektonChain) GetStatus() TektonComponentStatus {","\treturn \u0026tc.Status","}","","// TektonChainSpec defines the desired state of TektonChain","type TektonChainSpec struct {","\tCommonSpec `json:\",inline\"`","\tChain      `json:\",inline\"`","\t// Config holds the configuration for resources created by TektonChain","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","}","","type Chain struct {","\t// enable or disable chains feature","\tDisabled bool `json:\"disabled\"`","","\t// generate signing key","\tGenerateSigningSecret bool `json:\"generateSigningSecret,omitempty\"`","","\tChainProperties `json:\",inline\"`","\tControllerEnvs  []corev1.EnvVar `json:\"controllerEnvs,omitempty\"`","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","// ChainProperties defines the field to provide chain configuration","type ChainProperties struct {","\t// taskrun artifacts config","\tArtifactsTaskRunFormat  string  `json:\"artifacts.taskrun.format,omitempty\"`","\tArtifactsTaskRunStorage *string `json:\"artifacts.taskrun.storage,omitempty\"`","\tArtifactsTaskRunSigner  string  `json:\"artifacts.taskrun.signer,omitempty\"`","","\t// pipelinerun artifacts config","\tArtifactsPipelineRunFormat               string    `json:\"artifacts.pipelinerun.format,omitempty\"`","\tArtifactsPipelineRunStorage              *string   `json:\"artifacts.pipelinerun.storage,omitempty\"`","\tArtifactsPipelineRunSigner               string    `json:\"artifacts.pipelinerun.signer,omitempty\"`","\tArtifactsPipelineRunEnableDeepInspection BoolValue `json:\"artifacts.pipelinerun.enable-deep-inspection,omitempty\"`","","\t// oci artifacts config","\tArtifactsOCIFormat  string  `json:\"artifacts.oci.format,omitempty\"`","\tArtifactsOCIStorage *string `json:\"artifacts.oci.storage,omitempty\"`","\tArtifactsOCISigner  string  `json:\"artifacts.oci.signer,omitempty\"`","","\t// storage configs","\tStorageGCSBucket              string `json:\"storage.gcs.bucket,omitempty\"`","\tStorageOCIRepository          string `json:\"storage.oci.repository,omitempty\"`","\tStorageOCIRepositoryInsecure  *bool  `json:\"storage.oci.repository.insecure,omitempty\"`","\tStorageDocDBURL               string `json:\"storage.docdb.url,omitempty\"`","\tStorageDocDBMongoServerURL    string `json:\"storage.docdb.mongo-server-url,omitempty\"`","\tStorageDocDBMongoServerURLDir string `json:\"storage.docdb.mongo-server-url-dir,omitempty\"`","\tStorageGrafeasProjectID       string `json:\"storage.grafeas.projectid,omitempty\"`","\tStorageGrafeasNoteID          string `json:\"storage.grafeas.noteid,omitempty\"`","\tStorageGrafeasNoteHint        string `json:\"storage.grafeas.notehint,omitempty\"`","","\t// builder config","\tBuilderID                string `json:\"builder.id,omitempty\"`","\tBuildDefinitionBuildType string `json:\"builddefinition.buildtype,omitempty\"`","","\t// x509 signer config","\tX509SignerFulcioEnabled     *bool  `json:\"signers.x509.fulcio.enabled,omitempty\"`","\tX509SignerFulcioAddr        string `json:\"signers.x509.fulcio.address,omitempty\"`","\tX509SignerFulcioOIDCIssuer  string `json:\"signers.x509.fulcio.issuer,omitempty\"`","\tX509SignerFulcioProvider    string `json:\"signers.x509.fulcio.provider,omitempty\"`","\tX509SignerIdentityTokenFile string `json:\"signers.x509.identity.token.file,omitempty\"`","\tX509SignerTUFMirrorURL      string `json:\"signers.x509.tuf.mirror.url,omitempty\"`","","\t// kms signer config","\tKMSRef               string `json:\"signers.kms.kmsref,omitempty\"`","\tKMSAuthAddress       string `json:\"signers.kms.auth.address,omitempty\"`","\tKMSAuthToken         string `json:\"signers.kms.auth.token,omitempty\"`","\tKMSAuthTokenPath     string `json:\"signers.kms.auth.token-path,omitempty\"`","\tKMSAuthOIDCPath      string `json:\"signers.kms.auth.oidc.path,omitempty\"`","\tKMSAuthOIDCRole      string `json:\"signers.kms.auth.oidc.role,omitempty\"`","\tKMSAuthSpireSock     string `json:\"signers.kms.auth.spire.sock,omitempty\"`","\tKMSAuthSpireAudience string `json:\"signers.kms.auth.spire.audience,omitempty\"`","","\tTransparencyConfigEnabled BoolValue `json:\"transparency.enabled,omitempty\"`","\tTransparencyConfigURL     string    `json:\"transparency.url,omitempty\"`","","\t// +optional","\tPerformance PerformanceProperties `json:\"performance,omitempty\"`","}","","type BoolValue string","","func (bv *BoolValue) UnmarshalJSON(value []byte) error {","\tvar a string","\tvar b bool","\tif err := json.Unmarshal(value, \u0026a); err == nil {","\t\t// no error, it's a string","\t\t*bv = BoolValue(a)","\t\treturn nil","\t} else if err := json.Unmarshal(value, \u0026b); err == nil {","\t\t// it is a boolean","\t\t*bv = BoolValue(strconv.FormatBool(b))","\t\treturn nil","\t}","\treturn fmt.Errorf(\"Invalid value\")","}","","func (bv BoolValue) MarshalJson() ([]byte, error) {","\treturn []byte(bv), nil","}","","// TektonChainStatus defines the observed state of TektonChain","type TektonChainStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name for TektonChain","\t// +optional","\tTektonInstallerSet string `json:\"tektonInstallerSet,omitempty\"`","}","","// TektonChainList contains a list of TektonChain","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonChainList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonChain `json:\"items\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":18,"path":"pkg/apis/operator/v1alpha1/tektonchain_validation.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"knative.dev/pkg/apis\"",")","","var (","\tallowedArtifactsTaskRunFormat                   = sets.NewString(\"\", \"in-toto\", \"slsa/v1\", \"slsa/v2alpha2\", \"slsa/v2alpha3\")","\tallowedArtifactsPipelineRunFormat               = sets.NewString(\"\", \"in-toto\", \"slsa/v1\", \"slsa/v2alpha2\", \"slsa/v2alpha3\")","\tallowedX509SignerFulcioProvider                 = sets.NewString(\"\", \"google\", \"spiffe\", \"github\", \"filesystem\")","\tallowedTransparencyConfigEnabled                = sets.NewString(\"\", \"true\", \"false\", \"manual\")","\tallowedArtifactsPipelineRunEnableDeepInspection = sets.NewString(\"\", \"true\", \"false\")","\tallowedArtifactsStorage                         = sets.NewString(\"\", \"tekton\", \"oci\", \"gcs\", \"docdb\", \"grafeas\", \"kafka\")","\tallowedControllerEnvs                           = sets.NewString(\"MONGO_SERVER_URL\")","\tallowedBuildDefinitionType                      = sets.NewString(\"\", \"https://tekton.dev/chains/v2/slsa\", \"https://tekton.dev/chains/v2/slsa-tekton\")",")","","func (tc *TektonChain) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif tc.GetName() != ChainResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name, Only one instance of TektonChain is allowed by name, %s\", ChainResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(tc.GetName(), errMsg))","\t}","","\t// execute common spec validations","\terrs = errs.Also(tc.Spec.CommonSpec.validate(\"spec\"))","","\treturn errs.Also(tc.Spec.ValidateControllerEnv(), tc.Spec.ValidateChainConfig(\"spec\"))","}","","func (tcs *TektonChainSpec) ValidateControllerEnv() (errs *apis.FieldError) {","\tif tcs.ControllerEnvs != nil {","\t\tfor _, v := range tcs.ControllerEnvs {","\t\t\tif !allowedControllerEnvs.Has(v.Name) {","\t\t\t\terrs = errs.Also(apis.ErrInvalidKeyName(v.Name, fmt.Sprintf(\"supported keys are %s\", strings.Join(allowedControllerEnvs.List(), \",\"))))","\t\t\t}","\t\t}","\t}","\treturn errs","}","","func (tcs *TektonChainSpec) ValidateChainConfig(path string) (errs *apis.FieldError) {","","\tif !allowedArtifactsTaskRunFormat.Has(tcs.ArtifactsTaskRunFormat) {","\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsTaskRunFormat, path+\".artifacts.taskrun.format\"))","\t}","","\tif tcs.ArtifactsTaskRunStorage != nil {","\t\tinput := strings.Split(*tcs.ArtifactsTaskRunStorage, \",\")","\t\tfor i, v := range input {","\t\t\tinput[i] = strings.TrimSpace(v)","\t\t\tif !allowedArtifactsStorage.Has(input[i]) {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(input[i], path+\".artifacts.taskrun.storage\"))","\t\t\t}","\t\t}","\t}","","\tif tcs.ArtifactsTaskRunSigner != \"\" {","\t\tif tcs.ArtifactsTaskRunSigner != \"x509\" \u0026\u0026 tcs.ArtifactsTaskRunSigner != \"kms\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsTaskRunSigner, path+\".artifacts.taskrun.signer\"))","\t\t}","\t}","","\tif !allowedArtifactsPipelineRunFormat.Has(tcs.ArtifactsPipelineRunFormat) {","\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsPipelineRunFormat, path+\".artifacts.pipelinerun.format\"))","\t}","","\tif tcs.ArtifactsPipelineRunStorage != nil {","\t\tinput := strings.Split(*tcs.ArtifactsPipelineRunStorage, \",\")","\t\tfor i, v := range input {","\t\t\tinput[i] = strings.TrimSpace(v)","\t\t\tif !allowedArtifactsStorage.Has(input[i]) {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(input[i], path+\".artifacts.pipelinerun.storage\"))","\t\t\t}","\t\t}","\t}","","\tif tcs.ArtifactsPipelineRunSigner != \"\" {","\t\tif tcs.ArtifactsPipelineRunSigner != \"x509\" \u0026\u0026 tcs.ArtifactsPipelineRunSigner != \"kms\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsPipelineRunSigner, path+\".artifacts.pipelinerun.signer\"))","\t\t}","\t}","","\tif tcs.ArtifactsOCIFormat != \"\" {","\t\tif tcs.ArtifactsOCIFormat != \"simplesigning\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsOCIFormat, path+\".artifacts.oci.format\"))","\t\t}","\t}","","\tif tcs.ArtifactsOCIStorage != nil {","\t\tinput := strings.Split(*tcs.ArtifactsOCIStorage, \",\")","\t\tfor i, v := range input {","\t\t\tinput[i] = strings.TrimSpace(v)","\t\t\tif !allowedArtifactsStorage.Has(input[i]) {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(input[i], path+\".artifacts.oci.storage\"))","\t\t\t}","\t\t}","\t}","","\tif tcs.ArtifactsOCISigner != \"\" {","\t\tif tcs.ArtifactsOCISigner != \"x509\" \u0026\u0026 tcs.ArtifactsOCISigner != \"kms\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsOCISigner, path+\".artifacts.oci.signer\"))","\t\t}","\t}","","\tif !allowedX509SignerFulcioProvider.Has(tcs.X509SignerFulcioProvider) {","\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.X509SignerFulcioProvider, path+\".signers.x509.fulcio.provider\"))","\t}","","\tif !allowedTransparencyConfigEnabled.Has(string(tcs.TransparencyConfigEnabled)) {","\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.TransparencyConfigEnabled, path+\".transparency.enabled\"))","\t}","","\tif !allowedArtifactsPipelineRunEnableDeepInspection.Has(string(tcs.ArtifactsPipelineRunEnableDeepInspection)) {","\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsPipelineRunEnableDeepInspection, path+\".artifacts.pipelinerun.enable-deep-inspection\"))","\t}","","\tif !allowedBuildDefinitionType.Has(tcs.BuildDefinitionBuildType) {","\t\terrs = errs.Also(apis.ErrInvalidValue(tcs.BuildDefinitionBuildType, path+\".builddefinition.buildtype\"))","\t}","","\terrs = errs.Also(tcs.Performance.Validate(fmt.Sprintf(\"%s.performance\", path)))","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,1,1,1,0,0,2,2,2,0,0,2,2,2,2,2,2,0,0,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,0,2,1,1,1,0,0,2,2,2,0,2,2,2,2,2,2,2,0,0,0,2,1,1,1,0,0,2,1,1,1,0,0,2,1,1,1,1,1,1,0,0,0,2,1,1,1,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0]},{"id":19,"path":"pkg/apis/operator/v1alpha1/tektonconfig_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"strings\"","","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"",")","","func (tc *TektonConfig) SetDefaults(ctx context.Context) {","\tif tc.Spec.Profile == \"\" {","\t\ttc.Spec.Profile = ProfileBasic","\t}","\ttc.Spec.Pipeline.setDefaults()","\ttc.Spec.Trigger.setDefaults()","\ttc.Spec.Chain.setDefaults()","\ttc.Spec.Result.setDefaults()","\ttc.Spec.TektonPruner.SetDefaults()","\ttc.Spec.Scheduler.SetDefaults()","","\tif IsOpenShiftPlatform() {","\t\tif tc.Spec.Platforms.OpenShift.PipelinesAsCode == nil {","\t\t\ttc.Spec.Platforms.OpenShift.PipelinesAsCode = \u0026PipelinesAsCode{","\t\t\t\tEnable: ptr.Bool(true),","\t\t\t\tPACSettings: PACSettings{","\t\t\t\t\tSettings: map[string]string{},","\t\t\t\t},","\t\t\t}","\t\t} else {","\t\t\ttc.Spec.Addon.EnablePAC = nil","\t\t}","","\t\t// check if PAC is disabled through addon before enabling through OpenShiftPipelinesAsCode","\t\tif tc.Spec.Addon.EnablePAC != nil \u0026\u0026 !*tc.Spec.Addon.EnablePAC {","\t\t\ttc.Spec.Platforms.OpenShift.PipelinesAsCode.Enable = ptr.Bool(false)","\t\t\ttc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Settings = nil","\t\t}","","\t\t// pac defaulting","\t\tif *tc.Spec.Platforms.OpenShift.PipelinesAsCode.Enable {","\t\t\tlogger := logging.FromContext(ctx)","\t\t\ttc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.setPACDefaults(logger)","\t\t}","","\t\t// SCC defaulting","\t\tif tc.Spec.Platforms.OpenShift.SCC == nil {","\t\t\ttc.Spec.Platforms.OpenShift.SCC = \u0026SCC{}","\t\t}","\t\tif tc.Spec.Platforms.OpenShift.SCC.Default == \"\" {","\t\t\ttc.Spec.Platforms.OpenShift.SCC.Default = PipelinesSCC","\t\t}","","\t\tsetAddonDefaults(\u0026tc.Spec.Addon)","\t} else {","\t\ttc.Spec.Addon = Addon{}","\t\ttc.Spec.Platforms.OpenShift = OpenShift{}","\t}","","\t// earlier pruner was disabled with empty schedule or empty resources","\t// now empty schedule, disables only the global cron job,","\t// if a namespace has prune schedule annotation, a cron job will be created for that","\t// to disable the pruner feature, \"disabled\" should be set as \"true\"","\tif !tc.Spec.Pruner.Disabled {","\t\t// if keep and keep-since is nil, update default keep value","\t\tif tc.Spec.Pruner.Keep == nil \u0026\u0026 tc.Spec.Pruner.KeepSince == nil {","\t\t\tkeep := PrunerDefaultKeep","\t\t\ttc.Spec.Pruner.Keep = \u0026keep","\t\t}","","\t\t// if empty resources, update default resources","\t\tif len(tc.Spec.Pruner.Resources) == 0 {","\t\t\ttc.Spec.Pruner.Resources = PruningDefaultResources","\t\t}","","\t\t// trim space and to lower case resource names","\t\tfor index := range tc.Spec.Pruner.Resources {","\t\t\tvalue := tc.Spec.Pruner.Resources[index]","\t\t\tvalue = strings.TrimSpace(value)","\t\t\tvalue = strings.ToLower(value)","\t\t\ttc.Spec.Pruner.Resources[index] = value","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,2,2,0,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,0,0]},{"id":20,"path":"pkg/apis/operator/v1alpha1/tektonconfig_lifecycle.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","const (","\tPreInstall      apis.ConditionType = \"PreInstall\"","\tComponentsReady apis.ConditionType = \"ComponentsReady\"","\tPostInstall     apis.ConditionType = \"PostInstall\"","\tPreUpgrade      apis.ConditionType = \"PreUpgrade\"","\tPostUpgrade     apis.ConditionType = \"PostUpgrade\"",")","","var (","\tconfigCondSet = apis.NewLivingConditionSet(","\t\tPreInstall,","\t\tComponentsReady,","\t\tPostInstall,","\t\tPreUpgrade,","\t\tPostUpgrade,","\t)",")","","func (tc *TektonConfig) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonConfig)","}","","func (tc *TektonConfig) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonConfig)","}","","func (tcs *TektonConfigStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn configCondSet.Manage(tcs).GetCondition(t)","}","","func (tcs *TektonConfigStatus) InitializeConditions() {","\tconfigCondSet.Manage(tcs).InitializeConditions()","}","","func (tcs *TektonConfigStatus) IsReady() bool {","\treturn configCondSet.Manage(tcs).IsHappy()","}","","func (tcs *TektonConfigStatus) MarkPreInstallComplete() {","\tconfigCondSet.Manage(tcs).MarkTrue(PreInstall)","}","","func (tcs *TektonConfigStatus) MarkComponentsReady() {","\tconfigCondSet.Manage(tcs).MarkTrue(ComponentsReady)","}","","func (tcs *TektonConfigStatus) MarkPostInstallComplete() {","\tconfigCondSet.Manage(tcs).MarkTrue(PostInstall)","}","","func (tcs *TektonConfigStatus) MarkNotReady(msg string) {","\tconfigCondSet.Manage(tcs).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (tcs *TektonConfigStatus) MarkPreInstallFailed(msg string) {","\ttcs.MarkNotReady(\"PreReconciliation failed\")","\tconfigCondSet.Manage(tcs).MarkFalse(","\t\tPreInstall,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (tcs *TektonConfigStatus) MarkComponentNotReady(msg string) {","\ttcs.MarkNotReady(\"Components not ready\")","\tconfigCondSet.Manage(tcs).MarkFalse(","\t\tComponentsReady,","\t\t\"Error\",","\t\t\"Components not in ready state: %s\", msg)","}","","func (tcs *TektonConfigStatus) MarkPostInstallFailed(msg string) {","\ttcs.MarkNotReady(\"PostReconciliation failed\")","\tconfigCondSet.Manage(tcs).MarkFalse(","\t\tPostInstall,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","func (tcs *TektonConfigStatus) MarkPreUpgradeComplete() bool {","\tcondition := configCondSet.Manage(tcs).GetCondition(PreUpgrade)","\tif condition != nil \u0026\u0026 condition.Status == corev1.ConditionTrue {","\t\treturn false","\t}","\tconfigCondSet.Manage(tcs).MarkTrue(PreUpgrade)","\treturn true","}","","func (tcs *TektonConfigStatus) MarkPostUpgradeComplete() bool {","\tcondition := configCondSet.Manage(tcs).GetCondition(PostUpgrade)","\tif condition != nil \u0026\u0026 condition.Status == corev1.ConditionTrue {","\t\treturn false","\t}","\tconfigCondSet.Manage(tcs).MarkTrue(PostUpgrade)","\treturn true","}","","func (tcs *TektonConfigStatus) MarkPreUpgradeFalse(reason, msg string) bool {","\tcondition := configCondSet.Manage(tcs).GetCondition(PreUpgrade)","\tif condition != nil \u0026\u0026 condition.Status == corev1.ConditionFalse \u0026\u0026 condition.Reason == reason \u0026\u0026 condition.Message == msg {","\t\treturn false","\t}","\tconfigCondSet.Manage(tcs).MarkFalse(PreUpgrade, reason, \"%s\", msg)","\treturn true","}","","func (tcs *TektonConfigStatus) MarkPostUpgradeFalse(reason, msg string) bool {","\tcondition := configCondSet.Manage(tcs).GetCondition(PostUpgrade)","\tif condition != nil \u0026\u0026 condition.Status == corev1.ConditionFalse \u0026\u0026 condition.Reason == reason \u0026\u0026 condition.Message == msg {","\t\treturn false","\t}","\tconfigCondSet.Manage(tcs).MarkFalse(PostUpgrade, reason, \"%s\", msg)","\treturn true","}","","// GetVersion gets the currently installed version of the component.","func (tcs *TektonConfigStatus) GetVersion() string {","\treturn tcs.Version","}","","// SetVersion sets the currently installed version of the component.","func (tcs *TektonConfigStatus) SetVersion(version string) {","\ttcs.Version = version","}","","// returns pre upgrade version","func (tcs *TektonConfigStatus) GetPreUpgradeVersion() string {","\tif tcs.Annotations == nil {","\t\treturn \"\"","\t}","\treturn tcs.Annotations[PreUpgradeVersionKey]","}","","// updates pre upgrade version","func (tcs *TektonConfigStatus) SetPreUpgradeVersion(appliedUpgradeVersion string) {","\tif tcs.Annotations == nil {","\t\ttcs.Annotations = map[string]string{}","\t}","\ttcs.Annotations[PreUpgradeVersionKey] = appliedUpgradeVersion","}","","// returns post upgrade version","func (tcs *TektonConfigStatus) GetPostUpgradeVersion() string {","\tif tcs.Annotations == nil {","\t\treturn \"\"","\t}","\treturn tcs.Annotations[PostUpgradeVersionKey]","}","","// updates post upgrade version","func (tcs *TektonConfigStatus) SetPostUpgradeVersion(appliedUpgradeVersion string) {","\tif tcs.Annotations == nil {","\t\ttcs.Annotations = map[string]string{}","\t}","\ttcs.Annotations[PostUpgradeVersionKey] = appliedUpgradeVersion","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,0]},{"id":21,"path":"pkg/apis/operator/v1alpha1/tektonconfig_types.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"reflect\"","","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// TektonConfig is the Schema for the TektonConfigs API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonConfig struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonConfigSpec   `json:\"spec,omitempty\"`","\tStatus TektonConfigStatus `json:\"status,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tp *TektonConfig) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","// GetStatus implements TektonComponent","func (tp *TektonConfig) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// Prune defines the pruner","type Prune struct {","\t// enable or disable pruner feature","\tDisabled bool `json:\"disabled\"`","\t// apply the prune job to the individual resources","\t// +optional","\tPrunePerResource bool `json:\"prune-per-resource,omitempty\"`","\t// The resources which need to be pruned","\tResources []string `json:\"resources,omitempty\"`","\t// The number of resource to keep","\t// You dont want to delete all the pipelinerun/taskrun's by a cron","\t// +optional","\tKeep *uint `json:\"keep,omitempty\"`","\t// KeepSince keeps the resources younger than the specified value","\t// Its value is taken in minutes","\t// +optional","\tKeepSince *uint `json:\"keep-since,omitempty\"`","\t// How frequent pruning should happen","\tSchedule string `json:\"schedule,omitempty\"`","\t// Optional deadline in seconds for starting the job if it misses scheduled time for any reason.","\t// Missed jobs executions will be counted as failed ones.","\tStartingDeadlineSeconds *int64 `json:\"startingDeadlineSeconds,omitempty\"`","}","","func (p Prune) IsEmpty() bool {","\treturn reflect.DeepEqual(p, Prune{})","}","","type NamespaceMetadata struct {","\tLabels      map[string]string `json:\"labels,omitempty\"`","\tAnnotations map[string]string `json:\"annotations,omitempty\"`","}","","// TektonConfigSpec defines the desired state of TektonConfig","type TektonConfigSpec struct {","\tProfile string `json:\"profile,omitempty\"`","\t// Config holds the configuration for resources created by TektonConfig","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","\t// Pruner holds the prune config","\t// +optional","\tPruner Prune `json:\"pruner,omitempty\"`","\t// New EventBasedPruner which provides more granular control over TaskRun and PipelineRuns","\tTektonPruner Pruner `json:\"tektonpruner,omitempty\"`","\t// To enable Pipeline Scheduling on Single Cluster or Multiple Clusters","\t// +optional","\tScheduler  Scheduler `json:\"scheduler,omitempty\"`","\tCommonSpec `json:\",inline\"`","\t// Addon holds the addons config","\t// +optional","\tAddon Addon `json:\"addon,omitempty\"`","\t// Hub holds the hub config","\t// +optional","\tHub Hub `json:\"hub,omitempty\"`","\t// Pipeline holds the customizable option for pipeline component","\t// +optional","\tPipeline Pipeline `json:\"pipeline,omitempty\"`","\t// Trigger holds the customizable option for triggers component","\t// +optional","\tTrigger Trigger `json:\"trigger,omitempty\"`","\t// Chain holds the customizable option for chains component","\t// +optional","\tChain Chain `json:\"chain,omitempty\"`","\t// Result holds the customize option for results component","\t// +optional","\tResult Result `json:\"result,omitempty\"`","\t// Dashboard holds the customizable options for dashboards component","\t// +optional","\tDashboard Dashboard `json:\"dashboard,omitempty\"`","\t// Params is the list of params passed for all platforms","\t// +optional","\tParams []Param `json:\"params,omitempty\"`","\t// Platforms allows configuring platform specific configurations","\t// +optional","\tPlatforms Platforms `json:\"platforms,omitempty\"`","\t// holds target namespace metadata","\t// +optional","\tTargetNamespaceMetadata *NamespaceMetadata `json:\"targetNamespaceMetadata,omitempty\"`","}","","// TektonConfigStatus defines the observed state of TektonConfig","type TektonConfigStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The profile installed","\t// +optional","\tProfile string `json:\"profile,omitempty\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name","\t// +optional","\tTektonInstallerSet map[string]string `json:\"tektonInstallerSets,omitempty\"`","}","","func (in *TektonConfigStatus) MarkInstallerSetReady() {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (in *TektonConfigStatus) MarkInstallerSetNotReady(s string) {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (in *TektonConfigStatus) MarkInstallerSetAvailable() {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (in *TektonConfigStatus) MarkPreReconcilerFailed(s string) {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (in *TektonConfigStatus) MarkPostReconcilerFailed(s string) {","\t//TODO implement me","\tpanic(\"implement me\")","}","","// TektonConfigList contains a list of TektonConfig","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonConfigList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonConfig `json:\"items\"`","}","","type Config struct {","\tNodeSelector map[string]string   `json:\"nodeSelector,omitempty\"`","\tTolerations  []corev1.Toleration `json:\"tolerations,omitempty\"`","\t// PriorityClassName holds the priority class to be set to pod template","\t// +optional","\tPriorityClassName string `json:\"priorityClassName,omitempty\"`","}","","type Platforms struct {","\t// OpenShift allows configuring openshift specific components and configurations","\t// +optional","\tOpenShift OpenShift `json:\"openshift,omitempty\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":22,"path":"pkg/apis/operator/v1alpha1/tektonconfig_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/operator/pkg/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/openshift\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/logging\"",")","","func (tc *TektonConfig) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\t// disallow to update the targetNamespace","\tif apis.IsInUpdate(ctx) {","\t\texistingTC := apis.GetBaseline(ctx).(*TektonConfig)","\t\tif existingTC.Spec.GetTargetNamespace() != tc.Spec.GetTargetNamespace() {","\t\t\terrs = errs.Also(apis.ErrGeneric(\"Doesn't allow to update targetNamespace, delete existing TektonConfig and create the updated TektonConfig\", \"spec.targetNamespace\"))","\t\t}","\t}","","\tif tc.GetName() != ConfigResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name,  Only one instance of TektonConfig is allowed by name, %s\", ConfigResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(tc.GetName(), errMsg))","\t}","","\t// execute common spec validations","\terrs = errs.Also(tc.Spec.CommonSpec.validate(\"spec\"))","","\tif tc.Spec.Profile != \"\" {","\t\tif isValid := isValueInArray(Profiles, tc.Spec.Profile); !isValid {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(tc.Spec.Profile, \"spec.profile\"))","\t\t}","\t}","","\tif IsOpenShiftPlatform() \u0026\u0026 tc.Spec.Platforms.OpenShift.PipelinesAsCode != nil {","\t\tlogger := logging.FromContext(ctx)","\t\terrs = errs.Also(tc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.validate(logger, \"spec.platforms.openshift.pipelinesAsCode\"))","\t}","","\t// validate SCC config","\tif IsOpenShiftPlatform() \u0026\u0026 tc.Spec.Platforms.OpenShift.SCC != nil {","\t\tdefaultSCC := PipelinesSCC","\t\tif tc.Spec.Platforms.OpenShift.SCC.Default != \"\" {","\t\t\tdefaultSCC = tc.Spec.Platforms.OpenShift.SCC.Default","\t\t}","","\t\t// verify default SCC exists on the cluster","","\t\t// we don't want to verify pipelines-scc here as it will be created","\t\t// later when the RBAC reconciler will be run","\t\tif defaultSCC != PipelinesSCC {","\t\t\tif err := verifySCCExists(ctx, tc.Spec.Platforms.OpenShift.SCC.Default); err != nil {","\t\t\t\terrs = errs.Also(apis.ErrGeneric(fmt.Sprintf(\"error verifying SCC exists: %s - %v\", tc.Spec.Platforms.OpenShift.SCC.Default, err), \"spec.platforms.openshift.scc.default\"))","\t\t\t}","\t\t}","","\t\tmaxAllowedSCC := tc.Spec.Platforms.OpenShift.SCC.MaxAllowed","\t\tif maxAllowedSCC != \"\" {","\t\t\t// verify maxAllowed SCC exists on the cluster","\t\t\tif err := verifySCCExists(ctx, maxAllowedSCC); err != nil {","\t\t\t\terrs = errs.Also(apis.ErrGeneric(fmt.Sprintf(\"error verifying SCC exists: %s - %v\", maxAllowedSCC, err), \"spec.platforms.openshift.scc.maxAllowed\"))","\t\t\t}","","\t\t\t// Check that maxAllowed SCC and default SCC are compatible wrt priority","\t\t\thasPriority, err := compareSCCAMoreRestrictiveThanB(ctx, defaultSCC, maxAllowedSCC)","\t\t\tif err != nil {","\t\t\t\terrs = errs.Also(apis.ErrGeneric(fmt.Sprintf(\"error comparing priority between maxAllowed and default SCC in TektonConfig: %v\", err), \"spec.platforms.openshift.scc.maxAllowed\"))","\t\t\t} else if !hasPriority {","\t\t\t\terrs = errs.Also(apis.ErrGeneric(fmt.Sprintf(\"maxAllowed SCC (%s) must be less restrictive than the default SCC (%s)\", maxAllowedSCC, defaultSCC), \"spec.platforms.openshift.scc.maxAllowed\"))","\t\t\t}","","\t\t\t// Now validate maxAllowed SCC config with namespaces","\t\t\tsccErrors, err := compareSCCsWithAllNamespaces(ctx, maxAllowedSCC)","\t\t\tif err != nil {","\t\t\t\terrs = errs.Also(apis.ErrGeneric(fmt.Sprintf(\"error comparing priority between maxAllowed and SCCs requested in all namespaces: %v\", err), \"spec.platforms.openshift.scc.maxAllowed\"))","\t\t\t}","\t\t\terrs = errs.Also(sccErrors)","\t\t}","\t}","","\t// validate pruner specifications (legacy job-based pruner)","\terrs = errs.Also(tc.Spec.Pruner.validate())","","\t// validate TektonPruner (event-based) configuration using tektoncd/pruner webhook validation","\t// This ensures that the pruner config in TektonConfig is validated using the same","\t// comprehensive validation logic as the standalone TektonPruner resource","\terrs = errs.Also(tc.Spec.TektonPruner.validate(\"spec.tektonpruner\"))","","\tif !tc.Spec.Addon.IsEmpty() {","\t\terrs = errs.Also(validateAddonParams(tc.Spec.Addon.Params, \"spec.addon.params\"))","\t}","","\tif !tc.Spec.Hub.IsEmpty() {","\t\terrs = errs.Also(validateHubParams(tc.Spec.Hub.Params, \"spec.hub.params\"))","\t}","","\terrs = errs.Also(tc.Spec.Pipeline.PipelineProperties.validate(\"spec.pipeline\"))","","\terrs = errs.Also(tc.Spec.Pipeline.Options.validate(\"spec.pipeline.options\"))","\terrs = errs.Also(tc.Spec.Hub.Options.validate(\"spec.hub.options\"))","\terrs = errs.Also(tc.Spec.Dashboard.Options.validate(\"spec.dashboard.options\"))","\terrs = errs.Also(tc.Spec.Chain.Options.validate(\"spec.chain.options\"))","\terrs = errs.Also(tc.Spec.Trigger.Options.validate(\"spec.trigger.options\"))","\terrs = errs.Also(tc.Spec.Result.Options.validate(\"spec.result.options\"))","","\treturn errs.Also(tc.Spec.Trigger.TriggersProperties.validate(\"spec.trigger\"))","}","","func (p Prune) validate() *apis.FieldError {","\tvar errs *apis.FieldError","","\t// if pruner job disable no validation required","\tif p.Disabled {","\t\treturn errs","\t}","","\tif len(p.Resources) != 0 {","\t\tfor i, r := range p.Resources {","\t\t\tif !isValueInArray(PruningResource, r) {","\t\t\t\terrs = errs.Also(apis.ErrInvalidArrayValue(r, \"spec.pruner.resources\", i))","\t\t\t}","\t\t}","\t} else {","\t\terrs = errs.Also(apis.ErrMissingField(\"spec.pruner.resources\"))","\t}","","\t// tkn cli supports both \"keep\" and \"keep-since\", even though there is an issue with the logic","\t// when we supply both \"keep\" and \"keep-since\", the outcome always equivalent to \"keep\", \"keep-since\" ignored","\t// hence we strict with a single flag support until the issue is fixed in tkn cli","\t// issue: https://github.com/tektoncd/cli/issues/1990","\tif p.Keep != nil \u0026\u0026 p.KeepSince != nil {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"spec.pruner.keep\", \"spec.pruner.keep-since\"))","\t}","","\tif p.Keep == nil \u0026\u0026 p.KeepSince == nil {","\t\terrs = errs.Also(apis.ErrMissingOneOf(\"spec.pruner.keep\", \"spec.pruner.keep-since\"))","\t}","\tif p.Keep != nil \u0026\u0026 *p.Keep == 0 {","\t\terrs = errs.Also(apis.ErrInvalidValue(*p.Keep, \"spec.pruner.keep\"))","\t}","\tif p.KeepSince != nil \u0026\u0026 *p.KeepSince == 0 {","\t\terrs = errs.Also(apis.ErrInvalidValue(*p.KeepSince, \"spec.pruner.keep-since\"))","\t}","","\treturn errs","}","","func isValueInArray(arr []string, key string) bool {","\tfor _, p := range arr {","\t\tif p == key {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","func verifySCCExists(ctx context.Context, sccName string) error {","\tsecurityClient := common.GetSecurityClient(ctx)","\t_, err := securityClient.SecurityV1().SecurityContextConstraints().Get(ctx, sccName, metav1.GetOptions{})","\treturn err","}","","func compareSCCAMoreRestrictiveThanB(ctx context.Context, sccA, sccB string) (bool, error) {","\tsecurityClient := common.GetSecurityClient(ctx)","\tprioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, securityClient)","\tif err != nil {","\t\treturn false, err","\t}","\treturn common.SCCAMoreRestrictiveThanB(prioritizedSCCList, sccA, sccB)","}","","func compareSCCsWithAllNamespaces(ctx context.Context, maxAllowedSCC string) (*apis.FieldError, error) {","\tkc := kubeclient.Get(ctx)","\tallNamespaces, err := kc.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar sccErrors *apis.FieldError","\tfor _, ns := range allNamespaces.Items {","\t\tnsSCC := ns.Annotations[openshift.NamespaceSCCAnnotation]","\t\tif nsSCC == \"\" {","\t\t\tcontinue","\t\t}","","\t\t// Compare namespace SCC with maxAllowed","\t\thasPriority, err := compareSCCAMoreRestrictiveThanB(ctx, nsSCC, maxAllowedSCC)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","","\t\tif !hasPriority {","\t\t\tsccErrors = sccErrors.Also(apis.ErrGeneric(fmt.Sprintf(\"SCC requested in namespace %s: %s violates the maxAllowed SCC: %s set in TektonConfig\", ns.Name, nsSCC, maxAllowedSCC)))","\t\t}","\t}","\treturn sccErrors, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,0,0,2,1,1,1,0,0,2,2,2,2,2,2,0,0,2,1,1,1,0,0,2,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,0,1,1,1,0,0,0,0,0,2,1,1,0,2,2,2,2,1,1,2,1,1,0,2,0,0,2,2,2,2,2,0,2,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0]},{"id":23,"path":"pkg/apis/operator/v1alpha1/tektondashboard_lifecycle.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\t_ TektonComponentStatus = (*TektonDashboardStatus)(nil)","","\tdashboardCondSet = apis.NewLivingConditionSet(","\t\tDependenciesInstalled,","\t\tPreReconciler,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","// GroupVersionKind returns SchemeGroupVersion of a TektonDashboard","func (td *TektonDashboard) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonDashboard)","}","","func (td *TektonDashboard) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonDashboard)","}","","// GetCondition returns the current condition of a given condition type","func (tds *TektonDashboardStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn dashboardCondSet.Manage(tds).GetCondition(t)","}","","// InitializeConditions initializes conditions of an TektonDashboardStatus","func (tds *TektonDashboardStatus) InitializeConditions() {","\tdashboardCondSet.Manage(tds).InitializeConditions()","}","","// IsReady looks at the conditions returns true if they are all true.","func (tds *TektonDashboardStatus) IsReady() bool {","\treturn dashboardCondSet.Manage(tds).IsHappy()","}","","func (tds *TektonDashboardStatus) MarkPreReconcilerComplete() {","\tdashboardCondSet.Manage(tds).MarkTrue(PreReconciler)","}","","func (tds *TektonDashboardStatus) MarkInstallerSetAvailable() {","\tdashboardCondSet.Manage(tds).MarkTrue(InstallerSetAvailable)","}","","func (tds *TektonDashboardStatus) MarkInstallerSetReady() {","\tdashboardCondSet.Manage(tds).MarkTrue(InstallerSetReady)","}","","func (tds *TektonDashboardStatus) MarkPostReconcilerComplete() {","\tdashboardCondSet.Manage(tds).MarkTrue(PostReconciler)","}","","// MarkDependenciesInstalled marks the DependenciesInstalled status as true.","func (tds *TektonDashboardStatus) MarkDependenciesInstalled() {","\tdashboardCondSet.Manage(tds).MarkTrue(DependenciesInstalled)","}","","func (tds *TektonDashboardStatus) MarkNotReady(msg string) {","\tdashboardCondSet.Manage(tds).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (tds *TektonDashboardStatus) MarkPreReconcilerFailed(msg string) {","\ttds.MarkNotReady(\"PreReconciliation failed\")","\tdashboardCondSet.Manage(tds).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (tds *TektonDashboardStatus) MarkInstallerSetNotAvailable(msg string) {","\ttds.MarkNotReady(\"TektonInstallerSet not ready\")","\tdashboardCondSet.Manage(tds).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tds *TektonDashboardStatus) MarkInstallerSetNotReady(msg string) {","\ttds.MarkNotReady(\"TektonInstallerSet not ready\")","\tdashboardCondSet.Manage(tds).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tds *TektonDashboardStatus) MarkPostReconcilerFailed(msg string) {","\ttds.MarkNotReady(\"PostReconciliation failed\")","\tdashboardCondSet.Manage(tds).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","// MarkDependencyInstalling marks the DependenciesInstalled status as false with the","// given message.","func (tds *TektonDashboardStatus) MarkDependencyInstalling(msg string) {","\ttds.MarkNotReady(\"Dependencies installing\")","\tdashboardCondSet.Manage(tds).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency installing: %s\", msg)","}","","// MarkDependencyMissing marks the DependenciesInstalled status as false with the","// given message.","func (tds *TektonDashboardStatus) MarkDependencyMissing(msg string) {","\ttds.MarkNotReady(\"Missing Dependencies for TektonDashboard\")","\tdashboardCondSet.Manage(tds).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency missing: %s\", msg)","}","","func (tds *TektonDashboardStatus) GetTektonInstallerSet() string {","\treturn tds.TektonInstallerSet","}","","func (tds *TektonDashboardStatus) SetTektonInstallerSet(installerSet string) {","\ttds.TektonInstallerSet = installerSet","}","","// GetVersion gets the currently installed version of the component.","func (tds *TektonDashboardStatus) GetVersion() string {","\treturn tds.Version","}","","// SetVersion sets the currently installed version of the component.","func (tds *TektonDashboardStatus) SetVersion(version string) {","\ttds.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":24,"path":"pkg/apis/operator/v1alpha1/tektondashboard_types.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","var (","\t_ TektonComponent     = (*TektonDashboard)(nil)","\t_ TektonComponentSpec = (*TektonDashboardSpec)(nil)",")","","// TektonDashboard is the Schema for the tektondashboards API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonDashboard struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonDashboardSpec   `json:\"spec,omitempty\"`","\tStatus TektonDashboardStatus `json:\"status,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tp *TektonDashboard) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","// GetStatus implements TektonComponent","func (tp *TektonDashboard) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// TektonDashboardSpec defines the desired state of TektonDashboard","type TektonDashboardSpec struct {","\tCommonSpec `json:\",inline\"`","\tDashboard  `json:\",inline\"`","\t// Config holds the configuration for resources created by TektonDashboard","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","}","","// TektonDashboardStatus defines the observed state of TektonDashboard","type TektonDashboardStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name for TektonDashboard","\t// +optional","\tTektonInstallerSet string `json:\"tektonInstallerSet,omitempty\"`","}","","// TektonDashboardsList contains a list of TektonDashboard","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonDashboardList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonDashboard `json:\"items\"`","}","","// Dashboard degines the fields to customize the Dashboard component","type Dashboard struct {","\tDashboardProperties `json:\",inline\"`","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","// Dashboard degines the fields to customize the Dashboard component","type DashboardProperties struct {","\t// Readonly when set to true configures the Tekton dashboard in read-only mode","\tReadonly bool `json:\"readonly\"`","\t// +optional","\tExternalLogs string `json:\"external-logs,omitempty\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":25,"path":"pkg/apis/operator/v1alpha1/tektondashboard_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","","\t\"knative.dev/pkg/apis\"",")","","func (td *TektonDashboard) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif td.GetName() != DashboardResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name,  Only one instance of TektonDashboard is allowed by name, %s\", DashboardResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(td.GetName(), errMsg))","\t}","","\t// execute common spec validations","\terrs = errs.Also(td.Spec.CommonSpec.validate(\"spec\"))","","\treturn errs","}","","func (td *TektonDashboard) SetDefaults(ctx context.Context) {","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,1,1,1,0,0,2,2,2,0,0,0,0]},{"id":26,"path":"pkg/apis/operator/v1alpha1/tektonhub_defaults.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"os\"",")","","func (th *TektonHub) SetDefaults(ctx context.Context) {","","\tif th.Spec.Api.ApiSecretName == \"\" {","\t\tth.Spec.Api.ApiSecretName = HubApiSecretName","\t}","","\tif th.Spec.CommonSpec.TargetNamespace == \"\" {","\t\tth.Spec.CommonSpec.TargetNamespace = os.Getenv(\"DEFAULT_TARGET_NAMESPACE\")","\t}","","\tif th.Spec.Api.CatalogRefreshInterval == \"\" {","\t\tth.Spec.Api.CatalogRefreshInterval = \"30m\"","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,0,2,2,2,0]},{"id":27,"path":"pkg/apis/operator/v1alpha1/tektonhub_lifecycle.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","const (","\t// DB","\tDbDependenciesInstalled apis.ConditionType = \"DbDependenciesInstalled\"","\tDbInstallerSetAvailable apis.ConditionType = \"DbInstallSetAvailable\"","\t// DB-migration","\t// TODO: fix the typo on the value: \"DatabasebMigrationDone\"","\tDatabaseMigrationDone apis.ConditionType = \"DatabasebMigrationDone\"","\t// API","\tApiDependenciesInstalled apis.ConditionType = \"ApiDependenciesInstalled\"","\tApiInstallerSetAvailable apis.ConditionType = \"ApiInstallSetAvailable\"","\t// UI","\tUiInstallerSetAvailable apis.ConditionType = \"UiInstallSetAvailable\"",")","","var (","\t// TODO: Add this back after refactoring all components","\t// and updating TektonComponentStatus to have updated","\t// conditions","\t// _ TektonComponentStatus = (*TektonHubStatus)(nil)","","\thubCondSet = apis.NewLivingConditionSet(","\t\tDbDependenciesInstalled,","\t\tDbInstallerSetAvailable,","\t\tDatabaseMigrationDone,","\t\tPreReconciler,","\t\tApiDependenciesInstalled,","\t\tApiInstallerSetAvailable,","\t\tUiInstallerSetAvailable,","\t\tPostReconciler,","\t)",")","","// GroupVersionKind returns SchemeGroupVersion of a TektonHub","func (th *TektonHub) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonHub)","}","","// required by new type of FilterController","// might have to keep this and remove previous or vice-versa","func (th *TektonHub) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonHub)","}","","// GetCondition returns the current condition of a given condition type","func (ths *TektonHubStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn hubCondSet.Manage(ths).GetCondition(t)","}","","// InitializeConditions initializes conditions of an TektonHubStatus","func (ths *TektonHubStatus) InitializeConditions() {","\thubCondSet.Manage(ths).InitializeConditions()","}","","func (ths *TektonHubStatus) MarkNotReady(msg string) {","\thubCondSet.Manage(ths).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","// IsReady looks at the conditions returns true if they are all true.","func (ths *TektonHubStatus) IsReady() bool {","\treturn hubCondSet.Manage(ths).IsHappy()","}","","// Lifecycle for the DB component of Tekton Hub","func (ths *TektonHubStatus) MarkDbDependencyInstalling(msg string) {","\tths.MarkNotReady(\"Dependencies installing for DB\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tDbDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are installing for DB: %s\", msg)","}","","func (ths *TektonHubStatus) MarkDbDependencyMissing(msg string) {","\tths.MarkNotReady(\"Missing Dependencies for DB\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tDbDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are missing for DB: %s\", msg)","}","","func (ths *TektonHubStatus) MarkDbDependenciesInstalled() {","\thubCondSet.Manage(ths).MarkTrue(DbDependenciesInstalled)","}","","func (ths *TektonHubStatus) MarkDbInstallerSetNotAvailable(msg string) {","\tths.MarkNotReady(\"TektonInstallerSet not ready for DB\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tDbInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (ths *TektonHubStatus) MarkDbInstallerSetAvailable() {","\thubCondSet.Manage(ths).MarkTrue(DbInstallerSetAvailable)","}","","// Lifecycle for the DB migration component of Tekton Hub","func (ths *TektonHubStatus) MarkDatabaseMigrationFailed(msg string) {","\tths.MarkNotReady(\"Database migration job not ready\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tDatabaseMigrationDone,","\t\t\"Error\",","\t\t\"Database migration job not ready: %s\", msg)","}","","func (ths *TektonHubStatus) MarkDatabaseMigrationDone() {","\thubCondSet.Manage(ths).MarkTrue(DatabaseMigrationDone)","}","","// Lifecycle for the API component of Tekton Hub","func (ths *TektonHubStatus) MarkApiDependencyInstalling(msg string) {","\tths.MarkNotReady(\"Dependencies installing for API\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tApiDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are installing for API: %s\", msg)","}","","func (ths *TektonHubStatus) MarkApiDependencyMissing(msg string) {","\tths.MarkNotReady(\"Missing Dependencies for API\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tApiDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are missing for API: %s\", msg)","}","","func (ths *TektonHubStatus) MarkApiDependenciesInstalled() {","\thubCondSet.Manage(ths).MarkTrue(ApiDependenciesInstalled)","}","","func (ths *TektonHubStatus) MarkApiInstallerSetNotAvailable(msg string) {","\tths.MarkNotReady(\"TektonInstallerSet not ready for API\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tApiInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready for API: %s\", msg)","}","","func (ths *TektonHubStatus) MarkApiInstallerSetAvailable() {","\thubCondSet.Manage(ths).MarkTrue(ApiInstallerSetAvailable)","}","","func (ths *TektonHubStatus) MarkUiInstallerSetNotAvailable(msg string) {","\tths.MarkNotReady(\"TektonInstallerSet not ready for UI\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tUiInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready for UI: %s\", msg)","}","","func (ths *TektonHubStatus) MarkUiInstallerSetAvailable() {","\thubCondSet.Manage(ths).MarkTrue(UiInstallerSetAvailable)","}","","// GetManifests gets the url links of the manifests.","func (ths *TektonHubStatus) GetUiRoute() string {","\treturn ths.UiRouteUrl","}","","// SetManifests sets the url links of the manifests.","func (ths *TektonHubStatus) SetUiRoute(routeUrl string) {","\tths.UiRouteUrl = routeUrl","}","","func (ths *TektonHubStatus) MarkPreReconcilerFailed(msg string) {","\tths.MarkNotReady(\"PreReconciliation failed\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (ths *TektonHubStatus) MarkPreReconcilerComplete() {","\thubCondSet.Manage(ths).MarkTrue(PreReconciler)","}","","func (ths *TektonHubStatus) MarkPostReconcilerFailed(msg string) {","\tths.MarkNotReady(\"PostReconciliation failed\")","\thubCondSet.Manage(ths).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","func (ths *TektonHubStatus) MarkPostReconcilerComplete() {","\thubCondSet.Manage(ths).MarkTrue(PostReconciler)","}","","// Get the API route URL","func (ths *TektonHubStatus) GetApiRoute() string {","\treturn ths.ApiRouteUrl","}","","// Set the API route URL","func (ths *TektonHubStatus) SetApiRoute(routeUrl string) {","\tths.ApiRouteUrl = routeUrl","}","","// Get the Auth route URL","func (ths *TektonHubStatus) GetAuthRoute() string {","\treturn ths.AuthRouteUrl","}","","// Set the Auth route URL","func (ths *TektonHubStatus) SetAuthRoute(routeUrl string) {","\tths.AuthRouteUrl = routeUrl","}","","// GetVersion gets the currently installed version of the component.","func (ths *TektonHubStatus) GetVersion() string {","\treturn ths.Version","}","","// SetVersion sets the currently installed version of the component.","func (ths *TektonHubStatus) SetVersion(version string) {","\tths.Version = version","}","","// GetManifests gets the url links of the manifests.","func (ths *TektonHubStatus) GetManifests() []string {","\treturn ths.Manifests","}","","// SetManifests sets the url links of the manifests.","func (ths *TektonHubStatus) SetManifests(manifests []string) {","\tths.Manifests = manifests","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,0,0,2,2,2,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":28,"path":"pkg/apis/operator/v1alpha1/tektonhub_types.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","const (","\tHubDbSecretName  = \"tekton-hub-db\"","\tHubApiSecretName = \"tekton-hub-api\"",")","","var (","\t_ TektonComponent     = (*TektonHub)(nil)","\t_ TektonComponentSpec = (*TektonHubSpec)(nil)",")","","// TektonHub is the Schema for the tektonhub API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonHub struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonHubSpec   `json:\"spec,omitempty\"`","\tStatus TektonHubStatus `json:\"status,omitempty\"`","}","","type TektonHubSpec struct {","\tCommonSpec `json:\",inline\"`","\tHub        `json:\",inline\"`","\tCategories []string       `json:\"categories,omitempty\"`","\tCatalogs   []Catalog      `json:\"catalogs,omitempty\"`","\tScopes     []Scope        `json:\"scopes,omitempty\"`","\tDefault    Default        `json:\"default,omitempty\"`","\tDb         DbSpec         `json:\"db,omitempty\"`","\tApi        ApiSpec        `json:\"api,omitempty\"`","\tCustomLogo CustomLogoSpec `json:\"customLogo,omitempty\"`","}","","// Hub defines the field to customize Hub component","type Hub struct {","\t// Params is the list of params passed for Hub customization","\t// +optional","\tParams []Param `json:\"params,omitempty\"`","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","type DbSpec struct {","\tDbSecretName string `json:\"secret,omitempty\"`","}","","type ApiSpec struct {","\t// Deprecated, will be removed in further release","\tHubConfigUrl           string `json:\"hubConfigUrl,omitempty\"`","\tApiSecretName          string `json:\"secret,omitempty\"`","\tRouteHostUrl           string `json:\"routeHostUrl,omitempty\"`","\tCatalogRefreshInterval string `json:\"catalogRefreshInterval,omitempty\"`","}","","type Category struct {","\tName string `json:\"name,omitempty\"`","}","","type Catalog struct {","\tName       string `json:\"name,omitempty\"`","\tOrg        string `json:\"org,omitempty\"`","\tType       string `json:\"type,omitempty\"`","\tURL        string `json:\"url,omitempty\"`","\tSshUrl     string `json:\"sshUrl,omitempty\"`","\tContextDir string `json:\"contextDir,omitempty\"`","\tRevision   string `json:\"revision,omitempty\"`","\tProvider   string `json:\"provider,omitempty\"`","}","","type Scope struct {","\tName  string   `json:\"name,omitempty\"`","\tUsers []string `json:\"users,omitempty\"`","}","","type Default struct {","\tScopes []string `json:\"scopes,omitempty\"`","}","","// The Base64 Encode data and mediaType of the Custom Logo","type CustomLogoSpec struct {","\tBase64Data string `json:\"base64Data,omitempty\"`","\tMediaType  string `json:\"mediaType,omitempty\"`","}","","// TektonHubStatus defines the observed state of TektonHub","type TektonHubStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The url links of the manifests, separated by comma","\t// +optional","\tManifests []string `json:\"manifests,omitempty\"`","","\t// The URL route for API which needs to be exposed","\t// +optional","\tApiRouteUrl string `json:\"apiUrl,omitempty\"`","","\t// The URL route for Auth server","\t// +optional","\tAuthRouteUrl string `json:\"authUrl,omitempty\"`","","\t// The URL route for UI which needs to be exposed","\t// +optional","\tUiRouteUrl string `json:\"uiUrl,omitempty\"`","","\t// The current installer set name","\t// +optional","\tHubInstallerSet map[string]string `json:\"hubInstallerSets,omitempty\"`","}","","func (in *TektonHubStatus) MarkInstallerSetReady() {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (in *TektonHubStatus) MarkInstallerSetNotReady(s string) {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (in *TektonHubStatus) MarkInstallerSetAvailable() {","\t//TODO implement me","\tpanic(\"implement me\")","}","","// TektonHubList contains a list of TektonHub","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonHubList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonHub `json:\"items\"`","}","","// GetSpec implements TektonComponent","func (th *TektonHub) GetSpec() TektonComponentSpec {","\treturn \u0026th.Spec","}","","// GetStatus implements TektonComponent","func (th *TektonHub) GetStatus() TektonComponentStatus {","\treturn \u0026th.Status","}","","func (h Hub) IsEmpty() bool {","\treturn len(h.Params) == 0","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,2,2,2]},{"id":29,"path":"pkg/apis/operator/v1alpha1/tektonhub_validation.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"knative.dev/pkg/apis\"",")","","func validateHubParams(params []Param, pathToParams string) *apis.FieldError {","\tvar errs *apis.FieldError","","\tfor i, p := range params {","\t\tparamValue, ok := HubParams[p.Name]","\t\tif !ok {","\t\t\terrs = errs.Also(apis.ErrInvalidKeyName(p.Name, pathToParams))","\t\t\tcontinue","\t\t}","\t\tif !isValueInArray(paramValue.Possible, p.Value) {","\t\t\tpath := pathToParams + \".\" + p.Name","\t\t\terrs = errs.Also(apis.ErrInvalidArrayValue(p.Value, path, i))","\t\t}","\t}","","\treturn errs","}","","func (th *TektonHub) Validate(ctx context.Context) (errs *apis.FieldError) {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\t// disallow to update the targetNamespace","\tif apis.IsInUpdate(ctx) {","\t\texistingTC := apis.GetBaseline(ctx).(*TektonHub)","\t\tif existingTC.Spec.GetTargetNamespace() != th.Spec.GetTargetNamespace() {","\t\t\terrs = errs.Also(apis.ErrGeneric(\"doesn't allow to update targetNamespace, delete existing TektonHub object and create the updated TektonHub object\", \"spec.targetNamespace\"))","\t\t}","\t}","","\t// execute common spec validations","\terrs = errs.Also(th.Spec.CommonSpec.validate(\"spec\"))","","\t// validate database secret name","\tif th.Spec.Db.DbSecretName != \"\" \u0026\u0026 th.Spec.Db.DbSecretName != HubDbSecretName {","\t\terrs = errs.Also(apis.ErrInvalidValue(th.Spec.Db.DbSecretName, \"spec.db.secret\"))","\t}","","\t// validate api secret name","\tif th.Spec.Api.ApiSecretName != \"\" \u0026\u0026 th.Spec.Api.ApiSecretName != HubApiSecretName {","\t\terrs = errs.Also(apis.ErrInvalidValue(th.Spec.Api.ApiSecretName, \"spec.api.secret\"))","\t}","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,2,2,2,2,0,0,2,0,0,2,2,1,1,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,2,2,2,0,2,0]},{"id":30,"path":"pkg/apis/operator/v1alpha1/tektoninstallerset_lifecycle.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","const (","\tCrdInstalled         apis.ConditionType = \"CrdsInstalled\"","\tClustersScoped       apis.ConditionType = \"ClusterScopedResourcesInstalled\"","\tNamespaceScoped      apis.ConditionType = \"NamespaceScopedResourcesInstalled\"","\tDeploymentsAvailable apis.ConditionType = \"DeploymentsAvailable\"","\tStatefulSetReady     apis.ConditionType = \"StatefulSetReady\"","\tWebhookReady         apis.ConditionType = \"WebhooksReady\"","\tControllerReady      apis.ConditionType = \"ControllersReady\"","\tAllDeploymentsReady  apis.ConditionType = \"AllDeploymentsReady\"","\tJobsInstalled        apis.ConditionType = \"JobsInstalled\"",")","","var (","\tinstallerSetCondSet = apis.NewLivingConditionSet(","\t\tCrdInstalled,","\t\tClustersScoped,","\t\tNamespaceScoped,","\t\tDeploymentsAvailable,","\t\tStatefulSetReady,","\t\tWebhookReady,","\t\tControllerReady,","\t\tAllDeploymentsReady,","\t\tJobsInstalled,","\t)",")","","func (tis *TektonInstallerSet) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonInstallerSet)","}","","func (tis *TektonInstallerSetStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn installerSetCondSet.Manage(tis).GetCondition(t)","}","","func (tis *TektonInstallerSetStatus) InitializeConditions() {","\tinstallerSetCondSet.Manage(tis).InitializeConditions()","}","","func (tis *TektonInstallerSetStatus) IsReady() bool {","\treturn installerSetCondSet.Manage(tis).IsHappy()","}","","func (tis *TektonInstallerSetStatus) MarkReady() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(apis.ConditionReady)","}","","func (tis *TektonInstallerSetStatus) MarkCRDsInstalled() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(CrdInstalled)","}","","func (tis *TektonInstallerSetStatus) MarkClustersScopedResourcesInstalled() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(ClustersScoped)","}","","func (tis *TektonInstallerSetStatus) MarkNamespaceScopedResourcesInstalled() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(NamespaceScoped)","}","","func (tis *TektonInstallerSetStatus) MarkDeploymentsAvailable() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(DeploymentsAvailable)","}","","func (tis *TektonInstallerSetStatus) MarkStatefulSetReady() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(StatefulSetReady)","}","","func (tis *TektonInstallerSetStatus) MarkWebhookReady() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(WebhookReady)","}","","func (tis *TektonInstallerSetStatus) MarkControllerReady() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(ControllerReady)","}","","func (tis *TektonInstallerSetStatus) MarkAllDeploymentsReady() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(AllDeploymentsReady)","}","","func (tis *TektonInstallerSetStatus) MarkJobsInstalled() {","\tinstallerSetCondSet.Manage(tis).MarkTrue(JobsInstalled)","}","","func (tis *TektonInstallerSetStatus) MarkNotReady(msg string) {","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkCRDsInstallationFailed(msg string) {","\ttis.MarkNotReady(\"CRDs installation failed\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tCrdInstalled,","\t\t\"Error\",","\t\t\"Install failed with message: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkClustersScopedInstallationFailed(msg string) {","\ttis.MarkNotReady(\"Cluster Scoped resources installation failed\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tClustersScoped,","\t\t\"Error\",","\t\t\"Install failed with message: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkNamespaceScopedInstallationFailed(msg string) {","\ttis.MarkNotReady(\"Namespace Scoped resources installation failed\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tNamespaceScoped,","\t\t\"Error\",","\t\t\"Install failed with message: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkDeploymentsAvailableFailed(msg string) {","\ttis.MarkNotReady(\"Deployment resources installation failed\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tDeploymentsAvailable,","\t\t\"Error\",","\t\t\"Install failed with message: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkStatefulSetNotReady(msg string) {","\ttis.MarkNotReady(\"StatefulSet resources is not available\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tStatefulSetReady,","\t\t\"Error\",","\t\t\"Install failed with message: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkWebhookNotReady(msg string) {","\ttis.MarkNotReady(\"Webhooks not available\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tWebhookReady,","\t\t\"Error\",","\t\t\"Webhook: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkControllerNotReady(msg string) {","\ttis.MarkNotReady(\"Controller Deployment not available\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tControllerReady,","\t\t\"Error\",","\t\t\"Controller: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkAllDeploymentsNotReady(msg string) {","\ttis.MarkNotReady(\"All Deployments not available\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tAllDeploymentsReady,","\t\t\"Error\",","\t\t\"Deployment: %s\", msg)","}","","func (tis *TektonInstallerSetStatus) MarkJobsInstallationFailed(msg string) {","\ttis.MarkNotReady(\"Job resources installation failed\")","\tinstallerSetCondSet.Manage(tis).MarkFalse(","\t\tJobsInstalled,","\t\t\"Error\",","\t\t\"Install failed with message: %s\", msg)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1]},{"id":31,"path":"pkg/apis/operator/v1alpha1/tektonpipeline_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/config\"","\t\"knative.dev/pkg/ptr\"",")","","const (","\t// openshift specific","\tenableMetricsKey          = \"enableMetrics\"","\tenableMetricsDefaultValue = \"true\"","\tospDefaultSA              = \"pipeline\"",")","","func (tp *TektonPipeline) SetDefaults(ctx context.Context) {","\ttp.Spec.setDefaults()","}","","func (p *Pipeline) setDefaults() {","\tif p.DisableCredsInit == nil {","\t\tp.DisableCredsInit = ptr.Bool(config.DefaultDisableCredsInit)","\t}","\tif p.AwaitSidecarReadiness == nil {","\t\tp.AwaitSidecarReadiness = ptr.Bool(config.DefaultAwaitSidecarReadiness)","\t}","\tif p.RunningInEnvironmentWithInjectedSidecars == nil {","\t\tp.RunningInEnvironmentWithInjectedSidecars = ptr.Bool(config.DefaultRunningInEnvWithInjectedSidecars)","\t}","\tif p.RequireGitSshSecretKnownHosts == nil {","\t\tp.RequireGitSshSecretKnownHosts = ptr.Bool(config.DefaultRequireGitSSHSecretKnownHosts)","\t}","","\t// not in use, see: https://github.com/tektoncd/pipeline/pull/7789","\t// this field is removed from pipeline component","\t// keeping here to maintain the API compatibility","\tp.EnableTektonOciBundles = nil","","\tif p.EnableCustomTasks == nil {","\t\t// EnableCustomTask is always enable","\t\tp.EnableCustomTasks = ptr.Bool(true)","\t}","\tif p.SendCloudEventsForRuns == nil {","\t\tp.SendCloudEventsForRuns = ptr.Bool(config.DefaultSendCloudEventsForRuns)","\t}","\tif p.EnableApiFields == \"\" {","\t\tp.EnableApiFields = config.DefaultEnableAPIFields","\t}","","\t// \"verification-mode\" is deprecated and never used.","\t// this field will be removed, see https://github.com/tektoncd/operator/issues/1497","\tp.VerificationMode = \"\"","","\tif p.VerificationNoMatchPolicy == \"\" {","\t\tp.VerificationNoMatchPolicy = config.DefaultNoMatchPolicyConfig","\t}","","\tif p.EnableProvenanceInStatus == nil {","\t\tp.EnableProvenanceInStatus = ptr.Bool(config.DefaultEnableProvenanceInStatus)","\t}","","\t// Deprecated: set to nil, remove in further release","\tp.ScopeWhenExpressionsToTask = nil","","\t// Deprecated: disable-affinity-assistant is removed from pipeline component","\t// set to nil, remove in release-v0.80.x","\tp.DisableAffinityAssistant = nil","","\tif p.EnforceNonfalsifiability == \"\" {","\t\tp.EnforceNonfalsifiability = config.DefaultEnforceNonfalsifiability","\t}","","\tif p.EnableKeepPodOnCancel == nil {","\t\tp.EnableKeepPodOnCancel = ptr.Bool(config.DefaultEnableKeepPodOnCancel.Enabled)","\t}","","\tif p.ResultExtractionMethod == \"\" {","\t\tp.ResultExtractionMethod = config.DefaultResultExtractionMethod","\t}","","\tif p.MaxResultSize == nil {","\t\tp.MaxResultSize = ptr.Int32(config.DefaultMaxResultSize)","\t}","","\tif p.SetSecurityContext == nil {","\t\tp.SetSecurityContext = ptr.Bool(config.DefaultSetSecurityContext)","\t}","","\tif p.Coschedule == \"\" {","\t\tp.Coschedule = config.DefaultCoschedule","\t}","","\tif p.EnableCELInWhenExpression == nil {","\t\tp.EnableCELInWhenExpression = ptr.Bool(config.DefaultEnableCELInWhenExpression.Enabled)","\t}","","\tif p.EnableStepActions == nil {","\t\tp.EnableStepActions = ptr.Bool(config.DefaultFeatureFlags.EnableStepActions)","\t}","","\tif p.EnableParamEnum == nil {","\t\tp.EnableParamEnum = ptr.Bool(config.DefaultEnableParamEnum.Enabled)","\t}","","\tif p.DisableInlineSpec == \"\" {","\t\tp.DisableInlineSpec = config.DefaultDisableInlineSpec","\t}","","\tif p.MetricsPipelinerunDurationType == \"\" {","\t\tp.MetricsPipelinerunDurationType = config.DefaultDurationPipelinerunType","\t}","\tif p.MetricsPipelinerunLevel == \"\" {","\t\tp.MetricsPipelinerunLevel = config.DefaultPipelinerunLevel","\t}","\tif p.MetricsTaskrunDurationType == \"\" {","\t\tp.MetricsTaskrunDurationType = config.DefaultDurationTaskrunType","\t}","\tif p.MetricsTaskrunLevel == \"\" {","\t\tp.MetricsTaskrunLevel = config.DefaultTaskrunLevel","\t}","\tif p.CountWithReason == nil {","\t\tp.CountWithReason = ptr.Bool(false)","\t}","","\t// Resolvers","\tif p.EnableBundlesResolver == nil {","\t\tp.EnableBundlesResolver = ptr.Bool(true)","\t}","\tif p.EnableClusterResolver == nil {","\t\tp.EnableClusterResolver = ptr.Bool(true)","\t}","\tif p.EnableHubResolver == nil {","\t\tp.EnableHubResolver = ptr.Bool(true)","\t}","\tif p.EnableGitResolver == nil {","\t\tp.EnableGitResolver = ptr.Bool(true)","\t}","","\t// Statefulset Ordinals","\t// if StatefulSet Ordinals mode, buckets should be equal to replicas","\tif p.Performance.StatefulsetOrdinals != nil \u0026\u0026 *p.Performance.StatefulsetOrdinals {","\t\tif p.Performance.Replicas != nil \u0026\u0026 *p.Performance.Replicas \u003e 1 {","\t\t\treplicas := uint(*p.Performance.Replicas)","\t\t\tp.Performance.Buckets = \u0026replicas","\t\t}","\t}","","\t// run platform specific defaulting","\tif IsOpenShiftPlatform() {","\t\tp.openshiftDefaulting()","\t}","}","","func (p *Pipeline) openshiftDefaulting() {","\tif p.DefaultServiceAccount == \"\" {","\t\tp.DefaultServiceAccount = ospDefaultSA","\t}","","\t// Add params with default values if not defined by user","\tvar found = false","\tfor i, param := range p.Params {","\t\tif param.Name == enableMetricsKey {","\t\t\tfound = true","\t\t\t// If the value set is invalid then set key to default value","\t\t\tif param.Value != \"false\" \u0026\u0026 param.Value != \"true\" {","\t\t\t\tp.Params[i].Value = enableMetricsDefaultValue","\t\t\t}","\t\t\tbreak","\t\t}","\t}","","\tif !found {","\t\tp.Params = append(p.Params, Param{","\t\t\tName:  enableMetricsKey,","\t\t\tValue: enableMetricsDefaultValue,","\t\t})","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,1,1,1,1,0,0,0,2,2,2,0,0,2,2,2,2,0,0,2,2,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,0]},{"id":32,"path":"pkg/apis/operator/v1alpha1/tektonpipeline_lifecycle.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","const (","\tPreReconciler         apis.ConditionType = \"PreReconciler\"","\tInstallerSetAvailable apis.ConditionType = \"InstallerSetAvailable\"","\tInstallerSetReady     apis.ConditionType = \"InstallerSetReady\"","\tPostReconciler        apis.ConditionType = \"PostReconciler\"",")","","var (","\t// TODO: Add this back after refactoring all components","\t// and updating TektonComponentStatus to have updated","\t// conditions","\t//_ TektonComponentStatus = (*TektonPipelineStatus)(nil)","","\tpipelineCondSet = apis.NewLivingConditionSet(","\t\tPreReconciler,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","func (tp *TektonPipeline) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonPipeline)","}","","func (tp *TektonPipeline) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonPipeline)","}","","func (tps *TektonPipelineStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn pipelineCondSet.Manage(tps).GetCondition(t)","}","","func (tps *TektonPipelineStatus) InitializeConditions() {","\tpipelineCondSet.Manage(tps).InitializeConditions()","}","","func (tps *TektonPipelineStatus) IsReady() bool {","\treturn pipelineCondSet.Manage(tps).IsHappy()","}","","func (tps *TektonPipelineStatus) MarkPreReconcilerComplete() {","\tpipelineCondSet.Manage(tps).MarkTrue(PreReconciler)","}","","func (tps *TektonPipelineStatus) MarkInstallerSetAvailable() {","\tpipelineCondSet.Manage(tps).MarkTrue(InstallerSetAvailable)","}","","func (tps *TektonPipelineStatus) MarkInstallerSetReady() {","\tpipelineCondSet.Manage(tps).MarkTrue(InstallerSetReady)","}","","func (tps *TektonPipelineStatus) MarkPostReconcilerComplete() {","\tpipelineCondSet.Manage(tps).MarkTrue(PostReconciler)","}","","func (tps *TektonPipelineStatus) MarkNotReady(msg string) {","\tpipelineCondSet.Manage(tps).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (tps *TektonPipelineStatus) MarkPreReconcilerFailed(msg string) {","\ttps.MarkNotReady(\"PreReconciliation failed\")","\tpipelineCondSet.Manage(tps).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (tps *TektonPipelineStatus) MarkInstallerSetNotAvailable(msg string) {","\ttps.MarkNotReady(\"TektonInstallerSet not ready\")","\tpipelineCondSet.Manage(tps).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tps *TektonPipelineStatus) MarkInstallerSetNotReady(msg string) {","\ttps.MarkNotReady(\"TektonInstallerSet not ready\")","\tpipelineCondSet.Manage(tps).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tps *TektonPipelineStatus) MarkPostReconcilerFailed(msg string) {","\ttps.MarkNotReady(\"PostReconciliation failed\")","\tpipelineCondSet.Manage(tps).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","// TODO: below methods are not required for TektonPipeline","// but as extension implements TektonComponent we need to defined them","// this will be removed","","func (tps *TektonPipelineStatus) GetTektonInstallerSet() string {","\treturn tps.TektonInstallerSet","}","","func (tps *TektonPipelineStatus) SetTektonInstallerSet(installerSet string) {","\ttps.TektonInstallerSet = installerSet","}","","func (tps *TektonPipelineStatus) GetVersion() string {","\treturn tps.Version","}","","func (tps *TektonPipelineStatus) SetVersion(version string) {","\ttps.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1]},{"id":33,"path":"pkg/apis/operator/v1alpha1/tektonpipeline_types.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// TektonPipeline is the Schema for the tektonpipelines API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonPipeline struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonPipelineSpec   `json:\"spec,omitempty\"`","\tStatus TektonPipelineStatus `json:\"status,omitempty\"`","}","","func (tp *TektonPipeline) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","func (tp *TektonPipeline) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// TektonPipelineSpec defines the desired state of TektonPipeline","type TektonPipelineSpec struct {","\tCommonSpec `json:\",inline\"`","\tPipeline   `json:\",inline\"`","\t// Config holds the configuration for resources created by TektonPipeline","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","}","","// TektonPipelineStatus defines the observed state of TektonPipeline","type TektonPipelineStatus struct {","\tduckv1.Status `json:\",inline\"`","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name for TektonPipeline","\t// +optional","\tTektonInstallerSet string `json:\"tektonInstallerSet,omitempty\"`","","\t// The installer sets created for extension components","\t// +optional","\tExtentionInstallerSets map[string]string `json:\"extTektonInstallerSets,omitempty\"`","}","","// TektonPipelineList contains a list of TektonPipeline","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonPipelineList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonPipeline `json:\"items\"`","}","","// Pipeline defines the field to customize Pipeline component","type Pipeline struct {","\tPipelineProperties `json:\",inline\"`","\t// The params to customize different components of Pipelines","\t// +optional","\tParams []Param `json:\"params,omitempty\"`","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","// PipelineProperties defines customizable flags for Pipeline Component.","type PipelineProperties struct {","\tDisableCredsInit                         *bool  `json:\"disable-creds-init,omitempty\"`","\tAwaitSidecarReadiness                    *bool  `json:\"await-sidecar-readiness,omitempty\"`","\tRunningInEnvironmentWithInjectedSidecars *bool  `json:\"running-in-environment-with-injected-sidecars,omitempty\"`","\tRequireGitSshSecretKnownHosts            *bool  `json:\"require-git-ssh-secret-known-hosts,omitempty\"`","\tEnableCustomTasks                        *bool  `json:\"enable-custom-tasks,omitempty\"`","\tEnableApiFields                          string `json:\"enable-api-fields,omitempty\"`","\tEmbeddedStatus                           string `json:\"embedded-status,omitempty\"`","\tSendCloudEventsForRuns                   *bool  `json:\"send-cloudevents-for-runs,omitempty\"`","\t// \"verification-mode\" is deprecated and never used.","\t// This field will be removed, see https://github.com/tektoncd/operator/issues/1497","\t// originally this field was removed in https://github.com/tektoncd/operator/pull/1481","\t// there is no use with this field, just adding back to unblock the upgrade","","\t// not in use, see: https://github.com/tektoncd/pipeline/pull/7789","\t// this field is removed from pipeline component","\t// keeping here to maintain the API compatibility","\tEnableTektonOciBundles *bool `json:\"enable-tekton-oci-bundles,omitempty\"`","","\tVerificationMode          string `json:\"verification-mode,omitempty\"`","\tVerificationNoMatchPolicy string `json:\"trusted-resources-verification-no-match-policy,omitempty\"`","\tEnableProvenanceInStatus  *bool  `json:\"enable-provenance-in-status,omitempty\"`","","\t// ScopeWhenExpressionsToTask is deprecated and never used.","\tScopeWhenExpressionsToTask *bool `json:\"scope-when-expressions-to-task,omitempty\"`","","\t// Deprecated: DisableAffinityAssistant is deprecated and no longer used.","\t// This field is removed from pipeline component.","\t// Keeping here to maintain API compatibility during upgrades.","\t// TODO: Remove this field in release-v0.80.x","\tDisableAffinityAssistant *bool `json:\"disable-affinity-assistant,omitempty\"`","","\tEnforceNonfalsifiability  string `json:\"enforce-nonfalsifiability,omitempty\"`","\tEnableKeepPodOnCancel     *bool  `json:\"keep-pod-on-cancel,omitempty\"`","\tResultExtractionMethod    string `json:\"results-from,omitempty\"`","\tMaxResultSize             *int32 `json:\"max-result-size,omitempty\"`","\tSetSecurityContext        *bool  `json:\"set-security-context,omitempty\"`","\tCoschedule                string `json:\"coschedule,omitempty\"`","\tEnableCELInWhenExpression *bool  `json:\"enable-cel-in-whenexpression,omitempty\"`","\tEnableStepActions         *bool  `json:\"enable-step-actions,omitempty\"`","\tEnableParamEnum           *bool  `json:\"enable-param-enum,omitempty\"`","\tDisableInlineSpec         string `json:\"disable-inline-spec,omitempty\"`","","\tPipelineMetricsProperties `json:\",inline\"`","\t// +optional","\tTracingProperties `json:\",inline\"`","\t// +optional","\tOptionalPipelineProperties `json:\",inline\"`","\t// +optional","\tResolvers `json:\",inline\"`","\t// +optional","\tPerformance PerformanceProperties `json:\"performance,omitempty\"`","}","","// OptionalPipelineProperties defines the fields which are to be","// defined for pipelines only if user pass them","type OptionalPipelineProperties struct {","\tDefaultTimeoutMinutes               *uint  `json:\"default-timeout-minutes,omitempty\"`","\tDefaultServiceAccount               string `json:\"default-service-account,omitempty\"`","\tDefaultManagedByLabelValue          string `json:\"default-managed-by-label-value,omitempty\"`","\tDefaultPodTemplate                  string `json:\"default-pod-template,omitempty\"`","\tDefaultCloudEventsSink              string `json:\"default-cloud-events-sink,omitempty\"`","\tDefaultAffinityAssistantPodTemplate string `json:\"default-affinity-assistant-pod-template,omitempty\"`","\tDefaultTaskRunWorkspaceBinding      string `json:\"default-task-run-workspace-binding,omitempty\"`","\tDefaultMaxMatrixCombinationsCount   string `json:\"default-max-matrix-combinations-count,omitempty\"`","\tDefaultForbiddenEnv                 string `json:\"default-forbidden-env,omitempty\"`","\tDefaultResolverType                 string `json:\"default-resolver-type,omitempty\"`","}","","// WebhookOptions defines options for webhooks","type WebhookConfigurationOptions struct {","\tFailurePolicy  *admissionregistrationv1.FailurePolicyType `json:\"failurePolicy,omitempty\"`","\tTimeoutSeconds *int32                                     `json:\"timeoutSeconds,omitempty\"`","\tSideEffects    *admissionregistrationv1.SideEffectClass   `json:\"sideEffects,omitempty\"`","}","","// PipelineMetricsProperties defines the fields which are configurable for","// metrics","type PipelineMetricsProperties struct {","\tMetricsTaskrunLevel            string `json:\"metrics.taskrun.level,omitempty\"`","\tMetricsTaskrunDurationType     string `json:\"metrics.taskrun.duration-type,omitempty\"`","\tMetricsPipelinerunLevel        string `json:\"metrics.pipelinerun.level,omitempty\"`","\tMetricsPipelinerunDurationType string `json:\"metrics.pipelinerun.duration-type,omitempty\"`","\tCountWithReason                *bool  `json:\"metrics.count.enable-reason,omitempty\"`","}","","// TracingProperties defines the fields which are configurable for tracing","type TracingProperties struct {","\t// Enabled controls whether tracing is enabled or not","\t// +optional","\tEnabled *bool `json:\"traces.enabled,omitempty\"`","\t// Endpoint is the URL for the OpenTelemetry trace collector","\t// +optional","\tEndpoint string `json:\"traces.endpoint,omitempty\"`","\t// CredentialsSecret is the name of the secret containing credentials for the tracing endpoint","\t// +optional","\tCredentialsSecret string `json:\"traces.credentialsSecret,omitempty\"`","}","","// Resolvers defines the fields to configure resolvers","type Resolvers struct {","\tEnableBundlesResolver *bool `json:\"enable-bundles-resolver,omitempty\"`","\tEnableHubResolver     *bool `json:\"enable-hub-resolver,omitempty\"`","\tEnableGitResolver     *bool `json:\"enable-git-resolver,omitempty\"`","\tEnableClusterResolver *bool `json:\"enable-cluster-resolver,omitempty\"`","\tResolversConfig       `json:\",inline\"`","}","","// ResolversConfig defines the fields to configure each of the resolver","type ResolversConfig struct {","\tBundlesResolverConfig map[string]string `json:\"bundles-resolver-config,omitempty\"`","\tHubResolverConfig     map[string]string `json:\"hub-resolver-config,omitempty\"`","\tGitResolverConfig     map[string]string `json:\"git-resolver-config,omitempty\"`","\tClusterResolverConfig map[string]string `json:\"cluster-resolver-config,omitempty\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":34,"path":"pkg/apis/operator/v1alpha1/tektonpipeline_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/config\"","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"knative.dev/pkg/apis\"",")","","var (","\tvalidatePipelineAllowedApiFields          = sets.NewString(\"\", config.AlphaAPIFields, config.BetaAPIFields, config.StableAPIFields)","\tvalidatePipelineVerificationNoMatchPolicy = sets.NewString(\"\", config.FailNoMatchPolicy, config.WarnNoMatchPolicy, config.IgnoreNoMatchPolicy)","\tvalidatePipelineResultExtractionMethod    = sets.NewString(\"\", config.ResultExtractionMethodTerminationMessage, config.ResultExtractionMethodSidecarLogs)","\tvalidatePipelineEnforceNonFalsifiability  = sets.NewString(\"\", config.EnforceNonfalsifiabilityNone, config.EnforceNonfalsifiabilityWithSpire)","\tvalidatePipelineCoschedule                = sets.NewString(\"\", config.CoscheduleDisabled, config.CoscheduleWorkspaces, config.CoschedulePipelineRuns, config.CoscheduleIsolatePipelineRun)","\tvalidatePipelineInlineSpecDisable         = sets.NewString(\"\", \"pipeline\", \"pipelinerun\", \"taskrun\")",")","","func (tp *TektonPipeline) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif tp.GetName() != PipelineResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name, Only one instance of TektonPipeline is allowed by name, %s\", PipelineResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(tp.GetName(), errMsg))","\t}","","\t// execute common spec validations","\terrs = errs.Also(tp.Spec.CommonSpec.validate(\"spec\"))","","\terrs = errs.Also(tp.Spec.PipelineProperties.validate(\"spec\"))","","\terrs = errs.Also(tp.Spec.Options.validate(\"spec\"))","","\treturn errs","}","","func (p *PipelineProperties) validate(path string) (errs *apis.FieldError) {","","\tif !validatePipelineAllowedApiFields.Has(p.EnableApiFields) {","\t\terrs = errs.Also(apis.ErrInvalidValue(p.EnableApiFields, fmt.Sprintf(\"%s.enable-api-fields\", path)))","\t}","","\tif p.DisableInlineSpec != \"\" {","\t\tval := strings.Split(p.DisableInlineSpec, \",\")","\t\tfor _, v := range val {","\t\t\tif !validatePipelineInlineSpecDisable.Has(v) {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(p.DisableInlineSpec, fmt.Sprintf(\"%s.disable-inline-spec\", path)))","\t\t\t}","\t\t}","\t}","","\tif p.DefaultTimeoutMinutes != nil {","\t\tif *p.DefaultTimeoutMinutes == 0 {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(p.DefaultTimeoutMinutes, path+\".default-timeout-minutes\"))","\t\t}","\t}","\tif p.MaxResultSize != nil {","\t\tif *p.MaxResultSize \u003e= 1572864 {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(p.MaxResultSize, path+\".max-result-size\"))","\t\t}","\t}","","\t// validate trusted-resources-verification-no-match-policy","\tif !validatePipelineVerificationNoMatchPolicy.Has(p.VerificationNoMatchPolicy) {","\t\terrs = errs.Also(apis.ErrInvalidValue(p.VerificationNoMatchPolicy, fmt.Sprintf(\"%s.trusted-resources-verification-no-match-policy\", path)))","\t}","","\tif !validatePipelineResultExtractionMethod.Has(p.ResultExtractionMethod) {","\t\terrs = errs.Also(apis.ErrInvalidValue(p.ResultExtractionMethod, fmt.Sprintf(\"%s.results-from\", path)))","\t}","","\tif !validatePipelineEnforceNonFalsifiability.Has(p.EnforceNonfalsifiability) {","\t\terrs = errs.Also(apis.ErrInvalidValue(p.EnforceNonfalsifiability, fmt.Sprintf(\"%s.enforce-nonfalsifiability\", path)))","\t}","","\tif !validatePipelineCoschedule.Has(p.Coschedule) {","\t\terrs = errs.Also(apis.ErrInvalidValue(p.Coschedule, fmt.Sprintf(\"%s.coschedule\", path)))","\t}","","\t// validate performance properties","\terrs = errs.Also(p.Performance.Validate(fmt.Sprintf(\"%s.performance\", path)))","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,1,1,1,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,0,0,0,2,1,1,1,0,2,1,1,1,0,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,2,2,0]},{"id":35,"path":"pkg/apis/operator/v1alpha1/tektonpruner_defaults.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/pruner/pkg/config\"",")","","var DefaultPrunerDisabled = true","","func (tp *TektonPruner) SetDefaults(_ context.Context) {","\ttp.Spec.Pruner.SetDefaults()","}","","func (p *Pruner) SetDefaults() {","\tif p.Disabled == nil {","\t\tp.Disabled = \u0026DefaultPrunerDisabled","\t}","\tif p.GlobalConfig == nil {","\t\tp.GlobalConfig = \u0026config.GlobalConfig{}","\t\tp.GlobalConfig.SetDefaults()","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,2,2,2,2,2,0]},{"id":36,"path":"pkg/apis/operator/v1alpha1/tektonpruner_lifecycle.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\t_ TektonComponentStatus = (*TektonPrunerStatus)(nil)","","\tcondSet = apis.NewLivingConditionSet(","\t\tDependenciesInstalled,","\t\tPreReconciler,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","// GroupVersionKind returns SchemeGroupVersion of a TektonPruner","func (pruner *TektonPruner) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonPruner)","}","","func (pruner *TektonPruner) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonPruner)","}","","// GetCondition returns the current condition of a given condition type","func (pruner *TektonPrunerStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn condSet.Manage(pruner).GetCondition(t)","}","","// InitializeConditions initializes conditions of an TektonPrunerStatus","func (pruner *TektonPrunerStatus) InitializeConditions() {","\tcondSet.Manage(pruner).InitializeConditions()","}","","// IsReady looks at the conditions returns true if they are all true.","func (pruner *TektonPrunerStatus) IsReady() bool {","\treturn condSet.Manage(pruner).IsHappy()","}","","func (pruner *TektonPrunerStatus) MarkPreReconcilerComplete() {","\tcondSet.Manage(pruner).MarkTrue(PreReconciler)","}","","func (pruner *TektonPrunerStatus) MarkInstallerSetAvailable() {","\tcondSet.Manage(pruner).MarkTrue(InstallerSetAvailable)","}","","func (pruner *TektonPrunerStatus) MarkInstallerSetReady() {","\tcondSet.Manage(pruner).MarkTrue(InstallerSetReady)","}","","func (pruner *TektonPrunerStatus) MarkPostReconcilerComplete() {","\tcondSet.Manage(pruner).MarkTrue(PostReconciler)","}","","// MarkDependenciesInstalled marks the DependenciesInstalled status as true.","func (pruner *TektonPrunerStatus) MarkDependenciesInstalled() {","\tcondSet.Manage(pruner).MarkTrue(DependenciesInstalled)","}","","func (pruner *TektonPrunerStatus) MarkNotReady(msg string) {","\tcondSet.Manage(pruner).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (pruner *TektonPrunerStatus) MarkPreReconcilerFailed(msg string) {","\tpruner.MarkNotReady(\"PreReconciliation failed\")","\tcondSet.Manage(pruner).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (pruner *TektonPrunerStatus) MarkInstallerSetNotAvailable(msg string) {","\tpruner.MarkNotReady(\"TektonInstallerSet not ready\")","\tcondSet.Manage(pruner).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (pruner *TektonPrunerStatus) MarkInstallerSetNotReady(msg string) {","\tpruner.MarkNotReady(\"TektonInstallerSet not ready\")","\tcondSet.Manage(pruner).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (pruner *TektonPrunerStatus) MarkPostReconcilerFailed(msg string) {","\tpruner.MarkNotReady(\"PostReconciliation failed\")","\tcondSet.Manage(pruner).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","// MarkDependencyInstalling marks the DependenciesInstalled status as false with the","// given message.","func (pruner *TektonPrunerStatus) MarkDependencyInstalling(msg string) {","\tpruner.MarkNotReady(\"Dependencies installing\")","\tcondSet.Manage(pruner).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency installing: %s\", msg)","}","","// MarkDependencyMissing marks the DependenciesInstalled status as false with the","// given message.","func (pruner *TektonPrunerStatus) MarkDependencyMissing(msg string) {","\tpruner.MarkNotReady(\"Missing Dependencies for TektonPruner\")","\tcondSet.Manage(pruner).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency missing: %s\", msg)","}","","func (pruner *TektonPrunerStatus) GetTektonInstallerSet() string {","\treturn pruner.TektonInstallerSet","}","","func (pruner *TektonPrunerStatus) SetTektonInstallerSet(installerSet string) {","\tpruner.TektonInstallerSet = installerSet","}","","// GetVersion gets the currently installed version of the component.","func (pruner *TektonPrunerStatus) GetVersion() string {","\treturn pruner.Version","}","","// SetVersion sets the currently installed version of the component.","func (pruner *TektonPrunerStatus) SetVersion(version string) {","\tpruner.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":37,"path":"pkg/apis/operator/v1alpha1/tektonpruner_types.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"github.com/tektoncd/pruner/pkg/config\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","var (","\t_ TektonComponent     = (*TektonPruner)(nil)","\t_ TektonComponentSpec = (*TektonPrunerSpec)(nil)",")","","// TektonPruner is the Schema for the TektonPruner API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","// +kubebuilder:resource:scope=Cluster","","type TektonPruner struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\tSpec              TektonPrunerSpec   `json:\"spec,omitempty\"`","\tStatus            TektonPrunerStatus `json:\"status,omitempty\"`","}","","type TektonPrunerConfig struct {","\tGlobalConfig *config.GlobalConfig `json:\"global-config\"`","}","","type Pruner struct {","\t// enable or disable TektonPruner Component","\tDisabled           *bool `json:\"disabled\"`","\tTektonPrunerConfig `json:\",inline\"`","","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","// TektonPrunerList contains a list of TektonPruner","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonPrunerList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonPruner `json:\"items\"`","}","","type TektonPrunerSpec struct {","\tCommonSpec `json:\",inline\"`","\tPruner     `json:\",inline\"`","\t// Config holds the configuration for resources created by TektonPruner","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","}","","// TektonPrunerStatus defines the observed state of TektonPruner","type TektonPrunerStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name for TektonPruner","\t// +optional","\tTektonInstallerSet string `json:\"tektonInstallerSet,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tp *TektonPruner) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","func (tp *TektonPruner) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// IsDisabled returns true if the TektonPruner is disabled","func (p *Pruner) IsDisabled() bool {","\tif p == nil || p.Disabled == nil {","\t\t// When the Pruner is nil or Disabled is nil, we assume it is the default state.","\t\treturn DefaultPrunerDisabled","\t}","\treturn *p.Disabled","}","","func (in *TektonPrunerConfig) DeepCopyInto(out *TektonPrunerConfig) {","\t*out = *in","\treturn","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,2,2,2,2,2,2,0,0,1,1,1,1]},{"id":38,"path":"pkg/apis/operator/v1alpha1/tektonpruner_validation.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"knative.dev/pkg/apis\"",")","","// Validate performs comprehensive validation on TektonPruner","func (tp *TektonPruner) Validate(ctx context.Context) (errs *apis.FieldError) {","\t// Skip validation when deleting","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\t// Validate that only one instance exists with the correct name","\t// Skip this check if the pruner is disabled","\tif !tp.Spec.Pruner.IsDisabled() \u0026\u0026 tp.GetName() != TektonPrunerResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name, Only one instance of TektonPruner is allowed by name, %s\", TektonPrunerResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(tp.GetName(), errMsg))","\t}","","\t// Execute common spec validations","\terrs = errs.Also(tp.Spec.CommonSpec.validate(\"spec\"))","","\t// Validate pruner configuration using direct struct validation","\terrs = errs.Also(tp.Spec.Pruner.validate(\"spec.pruner\"))","","\treturn errs","}","","// validate validates the Pruner configuration using direct struct validation","// This ensures consistency with the upstream pruner validation logic","// This method is used by both TektonPruner.Validate() and TektonConfig.Validate()","func (p *Pruner) validate(path string) *apis.FieldError {","\t// Skip validation if pruner is disabled","\tif p.IsDisabled() {","\t\treturn nil","\t}","","\t// Use the new ValidateGlobalConfig function from pruner package","\t// This validates the GlobalConfig struct directly without ConfigMap conversion","\t// This is the recommended approach for operator CRDs as documented in pruner PR #57","\tif err := config.ValidateGlobalConfig(p.TektonPrunerConfig.GlobalConfig); err != nil {","\t\treturn apis.ErrGeneric(","\t\t\tfmt.Sprintf(\"pruner config validation failed: %v\", err),","\t\t\tpath+\".global-config\",","\t\t)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,0,2,0]},{"id":39,"path":"pkg/apis/operator/v1alpha1/tektonresult_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"",")","","func (tp *TektonResult) SetDefaults(ctx context.Context) {","\t// Deprecate TLSHostnameOverride","\tif tp.Spec.TLSHostnameOverride != \"\" {","\t\ttp.Spec.TLSHostnameOverride = \"\"","\t}","}","","// Sets default values of Result","func (c *Result) setDefaults() {","\t// Set default values for route configuration","\tif c.RouteEnabled == nil {","\t\t// Default to true for OpenShift platforms to automatically create routes","\t\tenabled := IsOpenShiftPlatform()","\t\tc.RouteEnabled = \u0026enabled","\t}","","\tif c.RouteTLSTermination == \"\" {","\t\tc.RouteTLSTermination = \"edge\"","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,0,2,2,2,0]},{"id":40,"path":"pkg/apis/operator/v1alpha1/tektonresult_lifecycle.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    httr://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\t_              TektonComponentStatus = (*TektonResultStatus)(nil)","\tresultsCondSet                       = apis.NewLivingConditionSet(","\t\tPreReconciler,","\t\tDependenciesInstalled,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","// GroupVersionKind returns SchemeGroupVersion of a TektonResult","func (tr *TektonResult) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonResult)","}","","func (tr *TektonResult) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonResult)","}","","// GetCondition returns the current condition of a given condition type","func (trs *TektonResultStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn resultsCondSet.Manage(trs).GetCondition(t)","}","","// InitializeConditions initializes conditions of an TektonResultStatus","func (trs *TektonResultStatus) InitializeConditions() {","\tresultsCondSet.Manage(trs).InitializeConditions()","}","","// IsReady looks at the conditions returns true if they are all true.","func (trs *TektonResultStatus) IsReady() bool {","\treturn resultsCondSet.Manage(trs).IsHappy()","}","","func (trs *TektonResultStatus) MarkNotReady(msg string) {","\tresultsCondSet.Manage(trs).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (trs *TektonResultStatus) MarkPreReconcilerComplete() {","\taddonsCondSet.Manage(trs).MarkTrue(PreReconciler)","}","","func (trs *TektonResultStatus) MarkInstallerSetAvailable() {","\tresultsCondSet.Manage(trs).MarkTrue(InstallerSetAvailable)","}","","func (trs *TektonResultStatus) MarkInstallerSetReady() {","\tresultsCondSet.Manage(trs).MarkTrue(InstallerSetReady)","}","","func (trs *TektonResultStatus) MarkInstallerSetNotAvailable(msg string) {","\ttrs.MarkNotReady(\"TektonInstallerSet not ready\")","\tresultsCondSet.Manage(trs).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (trs *TektonResultStatus) MarkInstallerSetNotReady(msg string) {","\ttrs.MarkNotReady(\"TektonInstallerSet not ready\")","\tresultsCondSet.Manage(trs).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (trs *TektonResultStatus) MarkPostReconcilerComplete() {","\tresultsCondSet.Manage(trs).MarkTrue(PostReconciler)","}","","// MarkDependenciesInstalled marks the DependenciesInstalled status as true.","func (trs *TektonResultStatus) MarkDependenciesInstalled() {","\tresultsCondSet.Manage(trs).MarkTrue(DependenciesInstalled)","}","","// MarkDependencyInstalling marks the DependenciesInstalled status as false with the","// given message.","func (trs *TektonResultStatus) MarkDependencyInstalling(msg string) {","\tresultsCondSet.Manage(trs).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Installing\",","\t\t\"Dependency installing: %s\", msg)","}","","// MarkDependencyMissing marks the DependenciesInstalled status as false with the","// given message.","func (trs *TektonResultStatus) MarkDependencyMissing(msg string) {","\tresultsCondSet.Manage(trs).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency missing: %s\", msg)","}","","func (trs *TektonResultStatus) GetTektonInstallerSet() string {","\treturn trs.TektonInstallerSet","}","","func (trs *TektonResultStatus) SetTektonInstallerSet(installerSet string) {","\ttrs.TektonInstallerSet = installerSet","}","","// GetVersion gets the currently installed version of the component.","func (trs *TektonResultStatus) GetVersion() string {","\treturn trs.Version","}","","// SetVersion sets the currently installed version of the component.","func (trs *TektonResultStatus) SetVersion(version string) {","\ttrs.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,1,1,1,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,2,2,2,0,0,2,2,2,0,0,0,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":41,"path":"pkg/apis/operator/v1alpha1/tektonresult_types.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","var (","\t_ TektonComponent     = (*TektonResult)(nil)","\t_ TektonComponentSpec = (*TektonResultSpec)(nil)",")","","// TektonResult is the Schema for the tektonresults API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonResult struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonResultSpec   `json:\"spec,omitempty\"`","\tStatus TektonResultStatus `json:\"status,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tp *TektonResult) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","// GetStatus implements TektonComponent","func (tp *TektonResult) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// TektonResultSpec defines the desired state of TektonResult","type TektonResultSpec struct {","\tCommonSpec `json:\",inline\"`","\tResult     `json:\",inline\"`","\t// Config holds the configuration for resources created by TektonResult","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","}","","type LokiStackProperties struct {","\tLokiStackName      string `json:\"loki_stack_name,omitempty\"`","\tLokiStackNamespace string `json:\"loki_stack_namespace,omitempty\"`","}","","// Result defines the field to customize Result component","type Result struct {","\t// enable or disable Result Component","\tDisabled bool `json:\"disabled\"`","\t// ResultsAPIProperties holds configuration properties for Result API","\tResultsAPIProperties `json:\",inline\"`","\t// LokiStackProperties holds configuration for LokiStack","\tLokiStackProperties `json:\",inline\"`","\t// Options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","\t// +optional","\tPerformance PerformanceProperties `json:\"performance,omitempty\"`","}","","// ResultsAPIProperties defines the fields which are configurable for","// Results API server config","type ResultsAPIProperties struct {","\tDBHost                string `json:\"db_host,omitempty\"`","\tDBPort                *int64 `json:\"db_port,omitempty\"`","\tDBName                string `json:\"db_name,omitempty\"`","\tDBSSLMode             string `json:\"db_sslmode,omitempty\"`","\tDBSSLRootCert         string `json:\"db_sslrootcert,omitempty\"`","\tDBEnableAutoMigration *bool  `json:\"db_enable_auto_migration,omitempty\"`","\tDBSecretName          string `json:\"db_secret_name,omitempty\"`","\tDBSecretUserKey       string `json:\"db_secret_user_key,omitempty\"`","\tDBSecretPasswordKey   string `json:\"db_secret_password_key,omitempty\"`","\tServerPort            *int64 `json:\"server_port,omitempty\"`","\tPrometheusPort        *int64 `json:\"prometheus_port,omitempty\"`","\tPrometheusHistogram   *bool  `json:\"prometheus_histogram,omitempty\"`","\tLogLevel              string `json:\"log_level,omitempty\"`","\tLogsAPI               *bool  `json:\"logs_api,omitempty\"`","\tLogsType              string `json:\"logs_type,omitempty\"`","\tLogsBufferSize        *int64 `json:\"logs_buffer_size,omitempty\"`","\tLogsPath              string `json:\"logs_path,omitempty\"`","\tTLSHostnameOverride   string `json:\"tls_hostname_override,omitempty\"`","\tAuthDisable           *bool  `json:\"auth_disable,omitempty\"`","\tAuthImpersonate       *bool  `json:\"auth_impersonate,omitempty\"`","\tLoggingPVCName        string `json:\"logging_pvc_name,omitempty\"`","\tGcsBucketName         string `json:\"gcs_bucket_name,omitempty\"`","\tStorageEmulatorHost   string `json:\"storage_emulator_host,omitempty\"`","\t// name of the secret used to get S3 credentials and","\t// pass it as environment variables to the \"tekton-results-api\" deployment under \"api\" container","\tSecretName         string `json:\"secret_name,omitempty\"`","\tGCSCredsSecretName string `json:\"gcs_creds_secret_name,omitempty\"`","\tGCSCredsSecretKey  string `json:\"gcs_creds_secret_key,omitempty\"`","\tIsExternalDB       bool   `json:\"is_external_db\"`","","\tLoggingPluginTLSVerificationDisable bool   `json:\"logging_plugin_tls_verification_disable,omitempty\"`","\tLoggingPluginProxyPath              string `json:\"logging_plugin_proxy_path,omitempty\"`","\tLoggingPluginAPIURL                 string `json:\"logging_plugin_api_url,omitempty\"`","\tLoggingPluginTokenPath              string `json:\"logging_plugin_token_path,omitempty\"`","\tLoggingPluginNamespaceKey           string `json:\"logging_plugin_namespace_key,omitempty\"`","\tLoggingPluginStaticLabels           string `json:\"logging_plugin_static_labels,omitempty\"`","\tLoggingPluginCACert                 string `json:\"logging_plugin_ca_cert,omitempty\"`","\tLoggingPluginForwarderDelayDuration *uint  `json:\"logging_plugin_forwarder_delay_duration,omitempty\"`","\tLoggingPluginQueryLimit             *uint  `json:\"logging_plugin_query_limit,omitempty\"`","\tLoggingPluginQueryParams            string `json:\"logging_plugin_query_params,omitempty\"`","\tLoggingPluginMultipartRegex         string `json:\"logging_plugin_multipart_regex,omitempty\"`","","\t// Route configuration for Results API service exposure","\tRouteEnabled *bool  `json:\"route_enabled,omitempty\"`","\tRouteHost    string `json:\"route_host,omitempty\"`","\tRoutePath    string `json:\"route_path,omitempty\"`","\t// +optional","\tRouteTLSTermination string `json:\"route_tls_termination,omitempty\"`","}","","// TektonResultStatus defines the observed state of TektonResult","type TektonResultStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name for TektonResult","\t// +optional","\tTektonInstallerSet string `json:\"tektonInstallerSet,omitempty\"`","}","","func (trs *TektonResultStatus) MarkPreReconcilerFailed(msg string) {","\ttrs.MarkNotReady(\"PreReconciliation failed\")","\tresultsCondSet.Manage(trs).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\tmsg)","}","","func (trs *TektonResultStatus) MarkPostReconcilerFailed(msg string) {","\ttrs.MarkNotReady(\"PostReconciliation failed\")","\tresultsCondSet.Manage(trs).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\tmsg)","}","","// TektonResultsList contains a list of TektonResult","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonResultList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonResult `json:\"items\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]},{"id":42,"path":"pkg/apis/operator/v1alpha1/tektonresult_validation.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"knative.dev/pkg/apis\"",")","","const (","\tLogsTypeLoki = \"loki\"",")","","func (tp *TektonResult) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif tp.GetName() != ResultResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name, Only one instance of TektonResult is allowed by name, %s\", ResultResourceName)","\t\treturn errs.Also(apis.ErrInvalidValue(tp.GetName(), errMsg))","\t}","\terrs = errs.Also(tp.Spec.validate(\"spec\"))","\treturn errs","}","","func (trs *TektonResultSpec) validate(path string) (errs *apis.FieldError) {","\tif trs.LokiStackName != \"\" {","\t\tif strings.ToLower(trs.LogsType) != LogsTypeLoki \u0026\u0026 trs.LogsType != \"\" {","\t\t\terrMsg := fmt.Sprintf(\"Loki stack is only supported when logs_type is loki or empty, got logs_type: %s\", trs.LogsType)","\t\t\terrs = errs.Also(apis.ErrInvalidValue(trs.LogsType, fmt.Sprintf(\"%s.logs_type\", path), errMsg))","\t\t}","\t\tif trs.LokiStackNamespace == \"\" {","\t\t\terrMsg := \"Loki stack namespace is required when loki_stack_name is provided\"","\t\t\terrs = errs.Also(apis.ErrInvalidValue(trs.LokiStackNamespace, fmt.Sprintf(\"%s.loki_stack_namespace\", path), errMsg))","\t\t}","\t}","","\t// validate performance properties","\terrs = errs.Also(trs.Performance.Validate(fmt.Sprintf(\"%s.performance\", path)))","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,2,0,0,2,2,1,1,1,1,1,1,1,1,0,0,0,2,2,2,0]},{"id":43,"path":"pkg/apis/operator/v1alpha1/tektonscheduler_defaults.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/konflux-ci/tekton-kueue/pkg/common\"","\t\"k8s.io/utils/ptr\"",")","","const (","\tSchedulerConfigMapName                       = common.ConfigMapName","\tSchedulerConfigInstallerSet                  = \"scheduler-config\"","\tDefaultQueueName                             = \"pipelines-queue\"","\tDefaultMultiClusterDisabled                  = true","\tDefaultSchedulerDisabled                     = true","\tSchedulerCreatedByValue                      = \"TektonScheduler\"","\tMultiClusterRoleSpoke       MultiClusterRole = \"Spoke\"","\tMultiClusterRoleHub         MultiClusterRole = \"Hub\"",")","","func (tp *TektonScheduler) SetDefaults(_ context.Context) {","\ttp.Spec.Scheduler.SetDefaults()","}","","func (s *Scheduler) SetDefaults() {","\tif s.Disabled == nil {","\t\ts.Disabled = ptr.To(DefaultSchedulerDisabled)","\t\ts.MultiClusterDisabled = DefaultMultiClusterDisabled","\t\ts.QueueName = DefaultQueueName","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,2,2,2,0]},{"id":44,"path":"pkg/apis/operator/v1alpha1/tektonscheduler_lifecycle.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","var (","\t_ TektonComponentStatus = (*TektonSchedulerStatus)(nil)",")","","// GroupVersionKind returns SchemeGroupVersion of a TektonScheduler","func (Scheduler *TektonScheduler) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonScheduler)","}","","func (Scheduler *TektonScheduler) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonScheduler)","}","","// GetCondition returns the current condition of a given condition type","func (Scheduler *TektonSchedulerStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn condSet.Manage(Scheduler).GetCondition(t)","}","","// InitializeConditions initializes conditions of an TektonSchedulerStatus","func (Scheduler *TektonSchedulerStatus) InitializeConditions() {","\tcondSet.Manage(Scheduler).InitializeConditions()","}","","// IsReady looks at the conditions returns true if they are all true.","func (Scheduler *TektonSchedulerStatus) IsReady() bool {","\treturn condSet.Manage(Scheduler).IsHappy()","}","","func (Scheduler *TektonSchedulerStatus) MarkPreReconcilerComplete() {","\tcondSet.Manage(Scheduler).MarkTrue(PreReconciler)","}","","func (Scheduler *TektonSchedulerStatus) MarkInstallerSetAvailable() {","\tcondSet.Manage(Scheduler).MarkTrue(InstallerSetAvailable)","}","","func (Scheduler *TektonSchedulerStatus) MarkInstallerSetReady() {","\tcondSet.Manage(Scheduler).MarkTrue(InstallerSetReady)","}","","func (Scheduler *TektonSchedulerStatus) MarkPostReconcilerComplete() {","\tcondSet.Manage(Scheduler).MarkTrue(PostReconciler)","}","","// MarkDependenciesInstalled marks the DependenciesInstalled status as true.","func (Scheduler *TektonSchedulerStatus) MarkDependenciesInstalled() {","\tcondSet.Manage(Scheduler).MarkTrue(DependenciesInstalled)","}","","func (Scheduler *TektonSchedulerStatus) MarkNotReady(msg string) {","\tcondSet.Manage(Scheduler).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (Scheduler *TektonSchedulerStatus) MarkPreReconcilerFailed(msg string) {","\tScheduler.MarkNotReady(\"PreReconciliation failed\")","\tcondSet.Manage(Scheduler).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (Scheduler *TektonSchedulerStatus) MarkInstallerSetNotAvailable(msg string) {","\tScheduler.MarkNotReady(\"TektonScheduler not ready\")","\tcondSet.Manage(Scheduler).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (Scheduler *TektonSchedulerStatus) MarkInstallerSetNotReady(msg string) {","\tScheduler.MarkNotReady(\"TektonScheduler not ready\")","\tcondSet.Manage(Scheduler).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (Scheduler *TektonSchedulerStatus) MarkPostReconcilerFailed(msg string) {","\tScheduler.MarkNotReady(\"PostReconciliation failed\")","\tcondSet.Manage(Scheduler).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","// MarkDependencyInstalling marks the DependenciesInstalled status as false with the","// given message.","func (Scheduler *TektonSchedulerStatus) MarkDependencyInstalling(msg string) {","\tScheduler.MarkNotReady(\"Dependencies installing\")","\tcondSet.Manage(Scheduler).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency installing: %s\", msg)","}","","// MarkDependencyMissing marks the DependenciesInstalled status as false with the","// given message.","func (Scheduler *TektonSchedulerStatus) MarkDependencyMissing(msg string) {","\tScheduler.MarkNotReady(\"Missing Dependencies for TektonScheduler\")","\tcondSet.Manage(Scheduler).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependency missing: %s\", msg)","}","","func (Scheduler *TektonSchedulerStatus) GetTektonScheduler() string {","\treturn Scheduler.TektonScheduler","}","","func (Scheduler *TektonSchedulerStatus) SetTektonScheduler(installerSet string) {","\tScheduler.TektonScheduler = installerSet","}","","// GetVersion gets the currently installed version of the component.","func (Scheduler *TektonSchedulerStatus) GetVersion() string {","\treturn Scheduler.Version","}","","// SetVersion sets the currently installed version of the component.","func (Scheduler *TektonSchedulerStatus) SetVersion(version string) {","\tScheduler.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1]},{"id":45,"path":"pkg/apis/operator/v1alpha1/tektonscheduler_types.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"github.com/konflux-ci/tekton-kueue/pkg/config\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","var (","\t_ TektonComponent     = (*TektonScheduler)(nil)","\t_ TektonComponentSpec = (*TektonSchedulerSpec)(nil)",")","","// TektonScheduler is the Schema for the TektonScheduler API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","// +kubebuilder:resource:scope=Cluster","","type TektonScheduler struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\tSpec              TektonSchedulerSpec   `json:\"spec,omitempty\"`","\tStatus            TektonSchedulerStatus `json:\"status,omitempty\"`","}","","// Scheduler Configuration  to manage Scheduler Configuration.","type Scheduler struct {","\t// enable or disable TektonScheduler Component","\tDisabled           *bool `json:\"disabled\"`","\tSchedulerConfig    `json:\",inline\"`","\tMultiClusterConfig `json:\",inline\"`","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","type SchedulerConfig struct {","\t// This hold the config data from tekton-kueue. ConfigMap in tekton kueue is loaded as config.yaml so we need to","\t//match the key here","\tconfig.Config `json:\"config.yaml\"`","}","","// MultiClusterConfig Configuration to enable/disable MultiCluster Configuration","type MultiClusterConfig struct {","\tMultiClusterDisabled bool             `json:\"multi-cluster-disabled\"`","\tMultiClusterRole     MultiClusterRole `json:\"multi-cluster-role\"`","}","","// MultiClusterRole Define the role of current cluster in multi-cluster environment. The MultiClusterRole","// can be one of Hub or Spoke","type MultiClusterRole string","","// TektonSchedulerList contains a list of TektonScheduler","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonSchedulerList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonScheduler `json:\"items\"`","}","","type TektonSchedulerSpec struct {","\tCommonSpec `json:\",inline\"`","\tScheduler  `json:\",inline\"`","}","","// TektonSchedulerStatus defines the observed state of TektonScheduler","type TektonSchedulerStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name for TektonScheduler","\t// +optional","\tTektonScheduler string `json:\"tekton-scheduler,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tp *TektonScheduler) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","func (tp *TektonScheduler) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// IsDisabled returns true if the TektonScheduler is disabled","func (p *Scheduler) IsDisabled() bool {","\tif p == nil || p.Disabled == nil {","\t\t// When the Scheduler is nil or Disabled is nil, we assume it is the default state.","\t\treturn DefaultSchedulerDisabled","\t}","\treturn *p.Disabled","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0]},{"id":46,"path":"pkg/apis/operator/v1alpha1/tektonscheduler_validation.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","","\t\"knative.dev/pkg/apis\"",")","","func (ts *TektonScheduler) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif ts.GetName() != TektonSchedulerResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name,  Only one instance of TektonScheduler is allowed by name, %s\", TektonSchedulerResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(ts.GetName(), errMsg))","\t}","","\t// execute common spec validations","\terrs = errs.Also(ts.Spec.MultiClusterConfig.validate())","\treturn errs","}","","func (mcc *MultiClusterConfig) validate() (errs *apis.FieldError) {","\tif mcc.MultiClusterDisabled \u0026\u0026 mcc.MultiClusterRole != \"\" {","\t\terrs = errs.Also(apis.ErrInvalidValue(\"MultiClusterConfig\", \"multicluster-role\",","\t\t\t\"multicluster-role should be blank when MultiClusterConfig.MultiClusterDisabled is true\"))","\t} else if !mcc.MultiClusterDisabled \u0026\u0026 !(mcc.MultiClusterRole == MultiClusterRoleHub || mcc.MultiClusterRole == MultiClusterRoleSpoke) {","\t\terrs = errs.Also(apis.ErrInvalidValue(\"MultiClusterConfig\", \"multicluster-role\",","\t\t\t\"multicluster-role should be 'Hub' or 'Spoke' when MultiClusterConfig.MultiClusterDisabled is false\"))","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,2,0,0,2,2,0,0,2,2,2,2,2,2,2,2,2,0]},{"id":47,"path":"pkg/apis/operator/v1alpha1/tektontrigger_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"",")","","var (","\t// DefaultOpenshiftSA is the default service account for openshift","\tDefaultOpenshiftSA = \"pipeline\"",")","","func (tt *TektonTrigger) SetDefaults(ctx context.Context) {","\ttt.Spec.Trigger.setDefaults()","}","","func (t *Trigger) setDefaults() {","\tif t.EnableApiFields == \"\" {","\t\tt.EnableApiFields = config.DefaultEnableAPIFields","\t}","","\t// run platform specific defaulting","\tif IsOpenShiftPlatform() {","\t\tt.openshiftDefaulting()","\t}","}","","func (t *Trigger) openshiftDefaulting() {","\tif t.DefaultServiceAccount == \"\" {","\t\tt.DefaultServiceAccount = DefaultOpenshiftSA","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,2,0,0,2,2,2,0,0,2,2,2,2,0]},{"id":48,"path":"pkg/apis/operator/v1alpha1/tektontrigger_lifecycle.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"",")","","const (","\tDependenciesInstalled apis.ConditionType = \"DependenciesInstalled\"",")","","var (","\t// TODO: Add this back after refactoring all components","\t// and updating TektonComponentStatus to have updated","\t// conditions","\t//_ TektonComponentStatus = (*TektonTriggerStatus)(nil)","","\ttriggersCondSet = apis.NewLivingConditionSet(","\t\tDependenciesInstalled,","\t\tPreReconciler,","\t\tInstallerSetAvailable,","\t\tInstallerSetReady,","\t\tPostReconciler,","\t)",")","","func (tr *TektonTrigger) GroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonTrigger)","}","","func (tr *TektonTrigger) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(KindTektonTrigger)","}","","func (tts *TektonTriggerStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn triggersCondSet.Manage(tts).GetCondition(t)","}","","func (tts *TektonTriggerStatus) InitializeConditions() {","\ttriggersCondSet.Manage(tts).InitializeConditions()","}","","func (tts *TektonTriggerStatus) IsReady() bool {","\treturn triggersCondSet.Manage(tts).IsHappy()","}","","func (tts *TektonTriggerStatus) IsNewInstallation() bool {","\treturn tts.Status.GetCondition(apis.ConditionReady).IsUnknown()","}","","func (tts *TektonTriggerStatus) MarkPreReconcilerComplete() {","\ttriggersCondSet.Manage(tts).MarkTrue(PreReconciler)","}","","func (tts *TektonTriggerStatus) MarkInstallerSetAvailable() {","\ttriggersCondSet.Manage(tts).MarkTrue(InstallerSetAvailable)","}","","func (tts *TektonTriggerStatus) MarkInstallerSetReady() {","\ttriggersCondSet.Manage(tts).MarkTrue(InstallerSetReady)","}","","func (tts *TektonTriggerStatus) MarkPostReconcilerComplete() {","\ttriggersCondSet.Manage(tts).MarkTrue(PostReconciler)","}","","func (tts *TektonTriggerStatus) MarkDependenciesInstalled() {","\ttriggersCondSet.Manage(tts).MarkTrue(DependenciesInstalled)","}","","func (tts *TektonTriggerStatus) MarkNotReady(msg string) {","\ttriggersCondSet.Manage(tts).MarkFalse(","\t\tapis.ConditionReady,","\t\t\"Error\",","\t\t\"Ready: %s\", msg)","}","","func (tts *TektonTriggerStatus) MarkPreReconcilerFailed(msg string) {","\ttts.MarkNotReady(\"PreReconciliation failed\")","\ttriggersCondSet.Manage(tts).MarkFalse(","\t\tPreReconciler,","\t\t\"Error\",","\t\t\"PreReconciliation failed with message: %s\", msg)","}","","func (tts *TektonTriggerStatus) MarkInstallerSetNotAvailable(msg string) {","\ttts.MarkNotReady(\"TektonInstallerSet not ready\")","\ttriggersCondSet.Manage(tts).MarkFalse(","\t\tInstallerSetAvailable,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tts *TektonTriggerStatus) MarkInstallerSetNotReady(msg string) {","\ttts.MarkNotReady(\"TektonInstallerSet not ready\")","\ttriggersCondSet.Manage(tts).MarkFalse(","\t\tInstallerSetReady,","\t\t\"Error\",","\t\t\"Installer set not ready: %s\", msg)","}","","func (tts *TektonTriggerStatus) MarkPostReconcilerFailed(msg string) {","\ttts.MarkNotReady(\"PostReconciliation failed\")","\ttriggersCondSet.Manage(tts).MarkFalse(","\t\tPostReconciler,","\t\t\"Error\",","\t\t\"PostReconciliation failed with message: %s\", msg)","}","","func (tts *TektonTriggerStatus) MarkDependencyInstalling(msg string) {","\ttts.MarkNotReady(\"Dependencies installing\")","\ttriggersCondSet.Manage(tts).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are installing: %s\", msg)","}","","func (tts *TektonTriggerStatus) MarkDependencyMissing(msg string) {","\ttts.MarkNotReady(\"Missing Dependencies for TektonTriggers\")","\ttriggersCondSet.Manage(tts).MarkFalse(","\t\tDependenciesInstalled,","\t\t\"Error\",","\t\t\"Dependencies are missing: %s\", msg)","}","","func (tts *TektonTriggerStatus) GetVersion() string {","\treturn tts.Version","}","","func (tts *TektonTriggerStatus) SetVersion(version string) {","\ttts.Version = version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1]},{"id":49,"path":"pkg/apis/operator/v1alpha1/tektontrigger_types.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// TektonTrigger is the Schema for the tektontriggers API","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +genclient:nonNamespaced","type TektonTrigger struct {","\tmetav1.TypeMeta   `json:\",inline\"`","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec   TektonTriggerSpec   `json:\"spec,omitempty\"`","\tStatus TektonTriggerStatus `json:\"status,omitempty\"`","}","","// GetSpec implements TektonComponent","func (tp *TektonTrigger) GetSpec() TektonComponentSpec {","\treturn \u0026tp.Spec","}","","// GetStatus implements TektonComponent","func (tp *TektonTrigger) GetStatus() TektonComponentStatus {","\treturn \u0026tp.Status","}","","// TektonTriggerSpec defines the desired state of TektonTrigger","type TektonTriggerSpec struct {","\tCommonSpec `json:\",inline\"`","\tTrigger    `json:\",inline\"`","\t// Config holds the configuration for resources created by TektonTrigger","\t// +optional","\tConfig Config `json:\"config,omitempty\"`","}","","// TektonTriggerStatus defines the observed state of TektonTrigger","type TektonTriggerStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// The version of the installed release","\t// +optional","\tVersion string `json:\"version,omitempty\"`","","\t// The current installer set name","\t// +optional","\tTektonInstallerSet string `json:\"tektonInstallerSet,omitempty\"`","}","","// TektonTriggersList contains a list of TektonTrigger","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type TektonTriggerList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TektonTrigger `json:\"items\"`","}","","// Trigger defines the field to customize Trigger component","type Trigger struct {","\t// enable or disable Trigger Component","\tDisabled           bool `json:\"disabled\"`","\tTriggersProperties `json:\",inline\"`","\t// options holds additions fields and these fields will be updated on the manifests","\tOptions AdditionalOptions `json:\"options\"`","}","","// TriggersProperties defines the fields which are to be","// defined for triggers only if user pass them","type TriggersProperties struct {","\tEnableApiFields string `json:\"enable-api-fields,omitempty\"`","\t// +optional","\tOptionalTriggersProperties `json:\",inline\"`","}","","// OptionalTriggersProperties defines the fields which are to be","// defined for triggers only if user pass them","type OptionalTriggersProperties struct {","\tDefaultServiceAccount string `json:\"default-service-account,omitempty\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":50,"path":"pkg/apis/operator/v1alpha1/tektontrigger_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"knative.dev/pkg/apis\"",")","","func (tr *TektonTrigger) Validate(ctx context.Context) (errs *apis.FieldError) {","","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif tr.GetName() != TriggerResourceName {","\t\terrMsg := fmt.Sprintf(\"metadata.name,  Only one instance of TektonTrigger is allowed by name, %s\", TriggerResourceName)","\t\terrs = errs.Also(apis.ErrInvalidValue(tr.GetName(), errMsg))","\t}","","\t// execute common spec validations","\terrs = errs.Also(tr.Spec.CommonSpec.validate(\"spec\"))","","\treturn errs.Also(tr.Spec.TriggersProperties.validate(\"spec\"))","}","","func (tr *TriggersProperties) validate(path string) (errs *apis.FieldError) {","","\tif tr.EnableApiFields != \"\" {","\t\tif tr.EnableApiFields != config.StableAPIFieldValue \u0026\u0026 tr.EnableApiFields != config.AlphaAPIFieldValue {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(tr.EnableApiFields, path+\".enable-api-fields\"))","\t\t}","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,1,1,1,0,0,2,2,2,0,0,2,2,2,2,2,2,0,2,0]},{"id":51,"path":"pkg/common/scc.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","\t\"fmt\"","\t\"sort\"","","\tsecurityv1 \"github.com/openshift/api/security/v1\"","\tsccSort \"github.com/openshift/apiserver-library-go/pkg/securitycontextconstraints/util/sort\"","\tsecurity \"github.com/openshift/client-go/security/clientset/versioned\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/rest\"","\t\"knative.dev/pkg/logging\"",")","","func GetSecurityClient(ctx context.Context) security.Interface {","\trestConfig, err := rest.InClusterConfig()","\tif err != nil {","\t\tlogging.FromContext(ctx).Panic(err)","\t}","\tsecurityClient, err := security.NewForConfig(restConfig)","\tif err != nil {","\t\tlogging.FromContext(ctx).Panic(err)","\t}","\treturn securityClient","}","","func VerifySCCExists(ctx context.Context, sccName string, securityClient security.Interface) error {","\t_, err := securityClient.SecurityV1().SecurityContextConstraints().Get(ctx, sccName, metav1.GetOptions{})","\treturn err","}","","func GetSCCRestrictiveList(ctx context.Context, securityClient security.Interface) ([]*securityv1.SecurityContextConstraints, error) {","\tlogger := logging.FromContext(ctx)","\tsccList, err := securityClient.SecurityV1().SecurityContextConstraints().List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\tlogger.Error(\"Error listing SCCs\")","\t\treturn nil, err","\t}","\tvar sccPointerList []*securityv1.SecurityContextConstraints","\tfor i := range sccList.Items {","\t\tsccPointerList = append(sccPointerList, \u0026sccList.Items[i])","\t}","","\t// This will sort the sccPointerList from most restrictive to least restrictive.","\t// ByRestrictions implements the sort interface so sort.Sort() can be run on it.","\tsort.Sort(sccSort.ByRestrictions(sccPointerList))","","\tsccLog := \"SCCs sorted from most restrictive to least restrictive:\"","\tfor _, sortedSCC := range sccPointerList {","\t\tsccLog = fmt.Sprintf(\"%s %s\", sccLog, sortedSCC.Name)","\t}","\tlogger.Info(sccLog)","\treturn sccPointerList, nil","}","","func SCCAMoreRestrictiveThanB(prioritizedSCCList []*securityv1.SecurityContextConstraints, sccA string, sccB string) (bool, error) {","\tvar sccAIndex, sccBIndex int","\tvar sccAFound, sccBFound bool","\tfor i, scc := range prioritizedSCCList {","\t\tif scc.Name == sccA {","\t\t\tsccAFound = true","\t\t\tsccAIndex = i","\t\t}","\t\tif scc.Name == sccB {","\t\t\tsccBFound = true","\t\t\tsccBIndex = i","\t\t}","\t\tif sccAFound \u0026\u0026 sccBFound {","\t\t\tbreak","\t\t}","\t}","","\tif !sccAFound || !sccBFound {","\t\treturn false, fmt.Errorf(\"SCCs not found while looking up priorities, found SCC %s: %t, found SCC %s: %t\", sccA, sccAFound, sccB, sccBFound)","\t}","","\treturn sccAIndex \u003c= sccBIndex, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,2,0]},{"id":52,"path":"pkg/reconciler/common/certificates.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"path/filepath\"","\t\"strings\"","","\tcorev1 \"k8s.io/api/core/v1\"","\t\"knative.dev/pkg/ptr\"",")","","const (","\t// user-provided and system CA certificates","\tTrustedCAConfigMapName   = \"config-trusted-cabundle\"","\tTrustedCAConfigMapVolume = \"config-trusted-cabundle-volume\"","\tTrustedCAKey             = \"ca-bundle.crt\"","","\t// service serving certificates (required to talk to the internal registry)","\tServiceCAConfigMapName   = \"config-service-cabundle\"","\tServiceCAConfigMapVolume = \"config-service-cabundle-volume\"","\tServiceCAKey             = \"service-ca.crt\"",")","","// NewVolumeWithConfigMap creates a new volume with the given ConfigMap","func NewVolumeWithConfigMap(volumeName, configMapName, configMapKey, configMapPath string) corev1.Volume {","\treturn corev1.Volume{","\t\tName: volumeName,","\t\tVolumeSource: corev1.VolumeSource{","\t\t\tConfigMap: \u0026corev1.ConfigMapVolumeSource{","\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{Name: configMapName},","\t\t\t\tItems: []corev1.KeyToPath{","\t\t\t\t\t{","\t\t\t\t\t\tKey:  configMapKey,","\t\t\t\t\t\tPath: configMapPath,","\t\t\t\t\t},","\t\t\t\t},","\t\t\t},","\t\t},","\t}","}","","// NewVolumeWithConfigMapOptional creates a new volume with the given ConfigMap marked as optional","// This allows the pod to start even if the ConfigMap doesn't exist","func NewVolumeWithConfigMapOptional(volumeName, configMapName, configMapKey, configMapPath string) corev1.Volume {","\treturn corev1.Volume{","\t\tName: volumeName,","\t\tVolumeSource: corev1.VolumeSource{","\t\t\tConfigMap: \u0026corev1.ConfigMapVolumeSource{","\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{Name: configMapName},","\t\t\t\tItems: []corev1.KeyToPath{","\t\t\t\t\t{","\t\t\t\t\t\tKey:  configMapKey,","\t\t\t\t\t\tPath: configMapPath,","\t\t\t\t\t},","\t\t\t\t},","\t\t\t\tOptional: ptr.Bool(true),","\t\t\t},","\t\t},","\t}","}","","// AddCABundleConfigMapsToVolumes adds the config-trusted-cabundle and config-service-cabundle","// ConfigMaps to the given list of volumes and removes duplicates, if any","func AddCABundleConfigMapsToVolumes(volumes []corev1.Volume) []corev1.Volume {","\t// If CA bundle volumes already exists in the pod's volumes, then remove it","\tfor _, newVolume := range []corev1.Volume{","\t\tNewVolumeWithConfigMap(TrustedCAConfigMapVolume, TrustedCAConfigMapName, TrustedCAKey, TrustedCAKey),","\t\tNewVolumeWithConfigMap(ServiceCAConfigMapVolume, ServiceCAConfigMapName, ServiceCAKey, ServiceCAKey),","\t} {","\t\tvolumes = AddOrReplaceInList(","\t\t\tvolumes,","\t\t\tnewVolume,","\t\t\tfunc(v corev1.Volume) string { return v.Name },","\t\t)","\t}","","\treturn volumes","}","","// AddCABundleConfigMapsToVolumesOptional adds the config-trusted-cabundle and config-service-cabundle","// ConfigMaps to the given list of volumes as optional volumes and removes duplicates, if any.","// Using optional volumes allows pods to start even when ConfigMaps don't exist, eliminating the need","// for API calls to check ConfigMap existence.","func AddCABundleConfigMapsToVolumesOptional(volumes []corev1.Volume) []corev1.Volume {","\t// If CA bundle volumes already exists in the pod's volumes, then remove it","\tfor _, volumeName := range []string{TrustedCAConfigMapVolume, ServiceCAConfigMapVolume} {","\t\tfor i, v := range volumes {","\t\t\tif v.Name == volumeName {","\t\t\t\tvolumes = append(volumes[:i], volumes[i+1:]...)","\t\t\t\tbreak","\t\t\t}","\t\t}","\t}","","\treturn append(","\t\tvolumes,","\t\tNewVolumeWithConfigMapOptional(TrustedCAConfigMapVolume, TrustedCAConfigMapName, TrustedCAKey, TrustedCAKey),","\t\tNewVolumeWithConfigMapOptional(ServiceCAConfigMapVolume, ServiceCAConfigMapName, ServiceCAKey, ServiceCAKey),","\t)","}","","// AddCABundlesToContainerVolumes adds the CA bundles to the container via VolumeMounts.","// SSL_CERT_DIR environment variable is also set if it does not exist already.","func AddCABundlesToContainerVolumes(c *corev1.Container) {","\t// We will mount the certs at /tekton-custom-certs so we don't override the existing certs","\tsslCertDir := \"/tekton-custom-certs\"","\tcertEnvAvailable := false","","\tfor _, env := range c.Env {","\t\t// If SSL_CERT_DIR env var already exists, then we don't mess with","\t\t// it and simply carry it forward as it is","\t\tif env.Name == \"SSL_CERT_DIR\" {","\t\t\tsslCertDir = env.Value","\t\t\tcertEnvAvailable = true","\t\t\tbreak","\t\t}","\t}","","\tif !certEnvAvailable {","\t\t// Here, we need to set the default value for SSL_CERT_DIR.","\t\t// Keep in mind that if SSL_CERT_DIR is set, then it overrides the","\t\t// system default, i.e. the system default directories will \"NOT\"","\t\t// be scanned for certificates. This is risky and we don't want to","\t\t// do this because users mount certificates at these locations or","\t\t// build images with certificates \"in\" them and expect certificates","\t\t// to get picked up, and rightfully so since this is the documented","\t\t// way of achieving this.","\t\t// So, let's keep the system wide default locations in place and","\t\t// \"append\" our custom location to those.","\t\t//","\t\t// certDirectories copied from","\t\t// https://golang.org/src/crypto/x509/root_linux.go","\t\tvar certDirectories = []string{","\t\t\t// Ordering is important here - we will be using the \"first\"","\t\t\t// element in SSL_CERT_DIR to do the volume mounts.","\t\t\tsslCertDir,           // /tekton-custom-certs","\t\t\t\"/etc/ssl/certs\",     // SLES10/SLES11, https://golang.org/issue/12139","\t\t\t\"/etc/pki/tls/certs\", // Fedora/RHEL","\t\t}","","\t\t// SSL_CERT_DIR accepts a colon separated list of directories","\t\tsslCertDir = strings.Join(certDirectories, \":\")","\t\tc.Env = append(c.Env, corev1.EnvVar{","\t\t\tName:  \"SSL_CERT_DIR\",","\t\t\tValue: sslCertDir,","\t\t})","\t}","","\t// We only want the first entry in SSL_CERT_DIR for the mount","\tmountDir := strings.Split(sslCertDir, \":\")[0]","\tfor _, newVolumeMount := range []corev1.VolumeMount{","\t\t{","\t\t\tName:      TrustedCAConfigMapVolume,","\t\t\tMountPath: filepath.Join(mountDir, TrustedCAKey),","\t\t\tSubPath:   TrustedCAKey,","\t\t\tReadOnly:  true,","\t\t},","\t\t{","\t\t\tName:      ServiceCAConfigMapVolume,","\t\t\tMountPath: filepath.Join(mountDir, ServiceCAKey),","\t\t\tSubPath:   ServiceCAKey,","\t\t\tReadOnly:  true,","\t\t},","\t} {","\t\tc.VolumeMounts = AddOrReplaceInList(","\t\t\tc.VolumeMounts,","\t\t\tnewVolumeMount,","\t\t\tfunc(v corev1.VolumeMount) string { return v.Name },","\t\t)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,2,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0]},{"id":53,"path":"pkg/reconciler/common/common.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"errors\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\t\"knative.dev/pkg/apis\"",")","","const (","\tPipelineNotReady       = \"tekton-pipelines not ready\"","\tPipelineNotFound       = \"tekton-pipelines not installed\"","\tTriggerNotReady        = \"tekton-triggers not ready\"","\tTriggerNotFound        = \"tekton-triggers not installed\"","\tNamespaceIgnorePattern = \"^(openshift|kube)-|^open-cluster-management-agent-addon$|^open-cluster-management-agent$|^dedicated-admin$|^kube-node-lease$|^kube-public$|^kube-system$\"",")","","func PipelineReady(informer informer.TektonPipelineInformer) (*v1alpha1.TektonPipeline, error) {","\tppln, err := getPipelineRes(informer)","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\treturn nil, errors.New(PipelineNotFound)","\t\t}","\t\treturn nil, err","\t}","\tif isUpgradePending(ppln.GetStatus()) {","\t\treturn nil, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t}","\tif !ppln.Status.IsReady() {","\t\treturn nil, errors.New(PipelineNotReady)","\t}","\treturn ppln, nil","}","","// isUpgradePending checks if the component status indicates an upgrade is pending","func isUpgradePending(status v1alpha1.TektonComponentStatus) bool {","\tif status == nil {","\t\treturn false","\t}","\treadyCondition := status.GetCondition(apis.ConditionReady)","\tif readyCondition == nil {","\t\treturn false","\t}","\treturn strings.Contains(readyCondition.Message, v1alpha1.UpgradePending)","}","","func PipelineTargetNamspace(informer informer.TektonPipelineInformer) (string, error) {","\tppln, err := getPipelineRes(informer)","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\treturn \"\", nil","\t\t}","\t\treturn \"\", err","\t}","\treturn ppln.Spec.TargetNamespace, nil","}","","func getPipelineRes(informer informer.TektonPipelineInformer) (*v1alpha1.TektonPipeline, error) {","\tres, err := informer.Lister().Get(v1alpha1.PipelineResourceName)","\treturn res, err","}","","func TriggerReady(informer informer.TektonTriggerInformer) (*v1alpha1.TektonTrigger, error) {","\ttrigger, err := getTriggerRes(informer)","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\treturn nil, errors.New(TriggerNotFound)","\t\t}","\t\treturn nil, err","\t}","\tif trigger.GetStatus() != nil \u0026\u0026 strings.Contains(trigger.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\treturn nil, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t}","\tif !trigger.Status.IsReady() {","\t\treturn nil, errors.New(TriggerNotReady)","\t}","\treturn trigger, nil","}","","func getTriggerRes(informer informer.TektonTriggerInformer) (*v1alpha1.TektonTrigger, error) {","\tres, err := informer.Lister().Get(v1alpha1.TriggerResourceName)","\treturn res, err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1]},{"id":54,"path":"pkg/reconciler/common/deadlockbreaker.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/client-go/kubernetes\"",")","","var webhookNames = map[string]string{","\tv1alpha1.PipelineResourceName: \"config.webhook.pipeline.tekton.dev\",","\tv1alpha1.TriggerResourceName:  \"config.webhook.triggers.tekton.dev\",","}","","var webhookServiceNames = map[string]string{","\tv1alpha1.PipelineResourceName: \"tekton-pipelines-webhook\",","\tv1alpha1.TriggerResourceName:  \"tekton-triggers-webhook\",","}","","func PreemptDeadlock(ctx context.Context, m *manifestival.Manifest, kc kubernetes.Interface, component string) error {","","\t// check if there are pod endpoints populated for webhhook service","\twebhookServiceName, ok := webhookServiceNames[component]","\tif !ok {","\t\treturn fmt.Errorf(\"no webhook service name found for component %s\", component)","\t}","\tok, err := isWebhookEndpointsActive(ctx, m, kc, webhookServiceName)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to check webhook endpoints: %w\", err)","\t}","\t// If endpoints are active, no deadlock prevention needed","\tif ok {","\t\treturn nil","\t}","","\t// If endpoints are empty, set webhook definition rules","\t// to the initial state where the webhook pod can refill the rules when it comes up","\twebhookName, ok := webhookNames[component]","\tif !ok {","\t\treturn fmt.Errorf(\"no webhook name found for component %s\", component)","\t}","","\terr = removeValidatingWebhookRules(m, kc, webhookName)","\tif err != nil {","\t\treturn err","\t}","\treturn nil","}","","// isWebhookEndpointsActive checks if the there are valid Endpoint resources associated with a webhook service","func isWebhookEndpointsActive(ctx context.Context, m *manifestival.Manifest, kc kubernetes.Interface, svcName string) (bool, error) {","\tsvcResource := m.Filter(manifestival.ByKind(\"Service\"), manifestival.ByName(svcName))","\tif len(svcResource.Resources()) == 0 {","\t\treturn false, fmt.Errorf(\"service %s not found in manifest\", svcName)","\t}","\ttargetNamespace := svcResource.Resources()[0].GetNamespace()","\tendPoint, err := kc.CoreV1().Endpoints(targetNamespace).Get(ctx, svcName, v1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\treturn false, nil","\t\t}","\t\treturn false, fmt.Errorf(\"failed to get endpoint %s in namespace %s: %w\", svcName, targetNamespace, err)","\t}","","\treturn len(endPoint.Subsets) \u003e 0, nil","}","","// removeValidatingWebhookRules remove \"rules\" from config.webhook.** webhook definiton(s)","func removeValidatingWebhookRules(m *manifestival.Manifest, kc kubernetes.Interface, webhookName string) error {","\tcmValidationWebHookManifest := m.Filter(manifestival.ByName(webhookName))","\ttransformed, err := cmValidationWebHookManifest.Transform(removeWebhooks)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to transform manifest for config webhook %s: %w\", webhookName, err)","\t}","\tif err := transformed.Apply(); err != nil {","\t\treturn fmt.Errorf(\"failed to remove webhook rules on config webhook %s: %w\", webhookName, err)","\t}","\treturn nil","}","","// removeWebhooks is a Transformer function which clears our webhooks[...].rules","func removeWebhooks(u *unstructured.Unstructured) error {","\tunstructured.RemoveNestedField(u.Object, \"webhooks\")","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,1,2,2,2,2,0,2,2,2,0,0,0,2,2,1,1,0,2,2,1,1,2,0,0,0,2,2,2,2,2,2,2,2,1,1,1,1,0,0,2,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,0,2,2,2,2]},{"id":55,"path":"pkg/reconciler/common/extensions.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"",")","","// Extension enables platform-specific features","type Extension interface {","\tTransformers(v1alpha1.TektonComponent) []mf.Transformer","\tPreReconcile(context.Context, v1alpha1.TektonComponent) error","\tPostReconcile(context.Context, v1alpha1.TektonComponent) error","\tFinalize(context.Context, v1alpha1.TektonComponent) error","}","","// ExtensionGenerator creates an Extension from a Context","type ExtensionGenerator func(context.Context) Extension","","// NoPlatform \"generates\" a NilExtension","func NoExtension(context.Context) Extension {","\treturn nilExtension{}","}","","type nilExtension struct{}","","func (nilExtension) Transformers(v1alpha1.TektonComponent) []mf.Transformer {","\treturn nil","}","func (nilExtension) PreReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (nilExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (nilExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2]},{"id":56,"path":"pkg/reconciler/common/initcontroller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","\t\"os\"","\t\"path/filepath\"","\t\"strings\"","","\tmfc \"github.com/manifestival/client-go-client\"","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const ReleaseVersionUnknown = \"Unknown\"","","type Controller struct {","\tManifest         *mf.Manifest","\tLogger           *zap.SugaredLogger","\tVersionConfigMap string","}","","type PayloadOptions struct {","\tReadOnly bool","}","","func OperatorVersion(ctx context.Context) (string, error) {","\tlogger := logging.FromContext(ctx)","\toperatorVersion, ok := os.LookupEnv(v1alpha1.VersionEnvKey)","\tif !ok || operatorVersion == \"\" {","\t\tlogger.Errorf(v1alpha1.VERSION_ENV_NOT_SET_ERR.Error())","\t\treturn \"\", v1alpha1.VERSION_ENV_NOT_SET_ERR","\t}","\treturn operatorVersion, nil","}","","func (ctrl Controller) InitController(ctx context.Context, opts PayloadOptions) (mf.Manifest, string) {","","\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\tif err != nil {","\t\tctrl.Logger.Fatalw(\"Error creating client from injected config\", zap.Error(err))","\t}","","\tmanifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient))","\tif err != nil {","\t\tctrl.Logger.Fatalw(\"Error creating initial manifest\", zap.Error(err))","\t}","","\tctrl.Manifest = \u0026manifest","\tif err := ctrl.fetchSourceManifests(ctx, opts); err != nil {","\t\tctrl.Logger.Fatalw(\"failed to read manifest\", err)","\t}","","\tvar releaseVersion string","\t// Read the release version of component","\treleaseVersion, err = FetchVersionFromConfigMap(manifest, ctrl.VersionConfigMap)","\tif err != nil {","\t\tif IsFetchVersionError(err) {","\t\t\tctrl.Logger.Warnf(\"failed to read version information from ConfigMap %s: %v\", ctrl.VersionConfigMap, err)","\t\t\treleaseVersion = ReleaseVersionUnknown","\t\t} else {","\t\t\tctrl.Logger.Fatalw(\"Error while reading ConfigMap\", zap.Error(err))","\t\t}","\t}","","\treturn manifest, releaseVersion","}","","// fetchSourceManifests mutates the passed manifest by appending one","// appropriate for the passed TektonComponent","func (ctrl Controller) fetchSourceManifests(ctx context.Context, opts PayloadOptions) error {","\tcomponent := strings.TrimSuffix(ctrl.VersionConfigMap, \"-info\")","\tswitch component {","\tcase \"pipelines\":","\t\tvar pipeline *v1alpha1.TektonPipeline","\t\tif err := AppendTarget(ctx, ctrl.Manifest, pipeline); err != nil {","\t\t\treturn err","\t\t}","\t\tif strings.EqualFold(os.Getenv(\"DISABLE_PROXY_WEBHOOK\"), \"true\") {","\t\t\treturn nil","\t\t}","\t\treturn addProxy(ctrl.Manifest)","\tcase \"triggers\":","\t\tvar trigger *v1alpha1.TektonTrigger","\t\treturn AppendTarget(ctx, ctrl.Manifest, trigger)","\tcase \"dashboard\":","\t\tif opts.ReadOnly {","\t\t\tvar dashboard v1alpha1.TektonDashboard","\t\t\tdashboard.Spec.Readonly = true","\t\t\treturn AppendTarget(ctx, ctrl.Manifest, \u0026dashboard)","\t\t} else {","\t\t\tvar dashboard v1alpha1.TektonDashboard","\t\t\tdashboard.Spec.Readonly = false","\t\t\treturn AppendTarget(ctx, ctrl.Manifest, \u0026dashboard)","\t\t}","\tcase \"chains\":","\t\tvar chain v1alpha1.TektonChain","\t\treturn AppendTarget(ctx, ctrl.Manifest, \u0026chain)","\tcase \"tekton-results\":","\t\tvar results v1alpha1.TektonResult","\t\treturn AppendTarget(ctx, ctrl.Manifest, \u0026results)","\tcase \"pipelines-as-code\":","\t\tpacLocation := filepath.Join(os.Getenv(KoEnvKey), \"tekton-addon\", \"pipelines-as-code\")","\t\treturn AppendManifest(ctrl.Manifest, pacLocation)","\tcase \"manual-approval-gate\":","\t\tvar mag v1alpha1.ManualApprovalGate","\t\treturn AppendTarget(ctx, ctrl.Manifest, \u0026mag)","\tcase v1alpha1.TektonPrunerResourceName:","\t\tvar pruner v1alpha1.TektonPruner","\t\treturn AppendTarget(ctx, ctrl.Manifest, \u0026pruner)","\tcase v1alpha1.TektonSchedulerResourceName:","\t\tvar scheduler v1alpha1.TektonScheduler","\t\treturn AppendTarget(ctx, ctrl.Manifest, \u0026scheduler)","\t}","","\treturn nil","}","","func addProxy(manifest *mf.Manifest) error {","\tkoDataDir := os.Getenv(KoEnvKey)","\tproxyLocation := filepath.Join(koDataDir, \"webhook\")","\treturn AppendManifest(manifest, proxyLocation)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1]},{"id":57,"path":"pkg/reconciler/common/labels.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"fmt\"","\t\"strings\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/selection\"",")","","func LabelSelector(ls metav1.LabelSelector) (string, error) {","\tvar (","\t\terr error","\t\treq *labels.Requirement","\t\ts   []string","\t)","\tfor k, v := range ls.MatchLabels {","\t\treq, err = labels.NewRequirement(k, selection.Equals, []string{v})","\t\tif err != nil {","\t\t\treturn \"\", fmt.Errorf(\"failed to create requirement: %w\", err)","\t\t}","\t\ts = append(s, labels.NewSelector().Add(*req).String())","\t}","\treturn strings.Join(s, \",\"), err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,1,2,0,2,0]},{"id":58,"path":"pkg/reconciler/common/name.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"fmt\"","\t\"regexp\"","","\tutilrand \"k8s.io/apimachinery/pkg/util/rand\"",")","","// NameGenerator generates names for objects. Some backends may have more information","// available to guide selection of new names and this interface hides those details.","type NameGenerator interface {","\t// RestrictLengthWithRandomSuffix generates a valid name from the base name, adding a random suffix to the","\t// base. If base is valid, the returned name must also be valid. The generator is","\t// responsible for knowing the maximum valid name length.","\tRestrictLengthWithRandomSuffix(base string) string","","\t// RestrictLength generates a valid name from the name of a step specified in a Task,","\t// shortening it to the maximum valid name length if needed.","\tRestrictLength(base string) string","}","","// simpleNameGenerator generates random names.","type simpleNameGenerator struct{}","","// SimpleNameGenerator is a generator that returns the name plus a random suffix of five alphanumerics","// when a name is requested. The string is guaranteed to not exceed the length of a standard Kubernetes","// name (63 characters)","var SimpleNameGenerator NameGenerator = simpleNameGenerator{}","","const (","\t// TODO: make this flexible for non-core resources with alternate naming rules.","\tmaxNameLength          = 63","\trandomLength           = 5","\tmaxGeneratedNameLength = maxNameLength - randomLength - 1",")","","func (simpleNameGenerator) RestrictLengthWithRandomSuffix(base string) string {","\tif len(base) \u003e maxGeneratedNameLength {","\t\tbase = base[:maxGeneratedNameLength]","\t}","\treturn fmt.Sprintf(\"%s-%s\", base, utilrand.String(randomLength))","}","","var alphaNumericRE = regexp.MustCompile(`^[a-zA-Z0-9]+$`)","","func (simpleNameGenerator) RestrictLength(base string) string {","\tif len(base) \u003e maxNameLength {","\t\tbase = base[:maxNameLength]","\t}","","\tfor !alphaNumericRE.MatchString(base[len(base)-1:]) {","\t\tbase = base[:len(base)-1]","\t}","\treturn base","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,0,2,2,2,2,0]},{"id":59,"path":"pkg/reconciler/common/nometrics.go","lines":["/*","Copyright 2022 The Tekton Authors","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","    http://www.apache.org/licenses/LICENSE-2.0","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import \"go.uber.org/zap\"","","type Recorder struct {","}","","func NoMetrics() (*Recorder, error) {","\treturn \u0026Recorder{}, nil","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\t// TODO","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0]},{"id":60,"path":"pkg/reconciler/common/proxy.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","package common","","import (","\t\"os\"","\t\"sort\"","","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"",")","","// ApplyProxySettings is a transformer that propagate any proxy environment variables","// set on the operator deployment to the underlying deployment.","func ApplyProxySettings(u *unstructured.Unstructured) error {","\tif u.GetKind() != \"Deployment\" {","\t\t// Don't do anything on something else than Deployment","\t\treturn nil","\t}","","\tvar proxyEnv = []corev1.EnvVar{{","\t\tName:  \"HTTPS_PROXY\",","\t\tValue: os.Getenv(\"HTTPS_PROXY\"),","\t}, {","\t\tName:  \"HTTP_PROXY\",","\t\tValue: os.Getenv(\"HTTP_PROXY\"),","\t}, {","\t\tName:  \"NO_PROXY\",","\t\tValue: os.Getenv(\"NO_PROXY\"),","\t}}","","\tm := u.Object","\tcontainers, found, err := unstructured.NestedSlice(m, \"spec\", \"template\", \"spec\", \"containers\")","\tif err != nil {","\t\treturn err","\t}","\tif !found {","\t\t// No containers in the deployment, it is weird but let's not fail","\t\treturn nil","\t}","\tfor _, c := range containers {","\t\tenvs, err := extractEnvs(c.(map[string]interface{}))","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tfor _, e := range proxyEnv {","\t\t\tif e.Value == \"\" {","\t\t\t\t// Remove existing envvar if they are not set.","\t\t\t\t// This probably means the proxy configuration has been removed","\t\t\t\tdelete(envs, e.Name)","\t\t\t\tcontinue","\t\t\t}","\t\t\tenvs[e.Name] = e.Value","\t\t}","\t\tif len(envs) == 0 {","\t\t\tunstructured.RemoveNestedField(c.(map[string]interface{}), \"env\")","\t\t} else if err := unstructured.SetNestedSlice(c.(map[string]interface{}), toUnstructured(envs), \"env\"); err != nil {","\t\t\treturn err","\t\t}","\t}","\tif err := unstructured.SetNestedField(m, containers, \"spec\", \"template\", \"spec\", \"containers\"); err != nil {","\t\treturn err","\t}","","\tu.SetUnstructuredContent(m)","\treturn nil","}","","func extractEnvs(uc map[string]interface{}) (map[string]interface{}, error) {","\tcurrentEnv, found, err := unstructured.NestedSlice(uc, \"env\")","\tif err != nil {","\t\treturn nil, err","\t}","\tif !found {","\t\treturn map[string]interface{}{}, nil","\t}","\tenvs := make(map[string]interface{}, len(currentEnv))","\tfor _, e := range currentEnv {","\t\tem := e.(map[string]interface{})","\t\tenvs[em[\"name\"].(string)] = em","","\t}","\treturn envs, nil","}","","func toUnstructured(envs map[string]interface{}) []interface{} {","\tnewEnv := []interface{}{}","\tfor n, v := range envs {","\t\tswitch va := v.(type) {","\t\tcase map[string]interface{}:","\t\t\tnewEnv = append(newEnv, va)","\t\tcase map[string]string:","\t\t\tnewEnv = append(newEnv, va)","\t\tdefault:","\t\t\tnewEnv = append(newEnv, map[string]interface{}{","\t\t\t\t\"name\":  n,","\t\t\t\t\"value\": va,","\t\t\t})","\t\t}","\t}","\tsort.Slice(newEnv, func(i, j int) bool {","\t\treturn newEnv[i].(map[string]interface{})[\"name\"].(string) \u003c newEnv[j].(map[string]interface{})[\"name\"].(string)","\t})","\treturn newEnv","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,1,2,2,2,1,1,2,2,2,2,2,2,0,2,0,2,2,2,1,1,0,2,1,1,0,2,2,0,0,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,2,2,2,2,2,0,0,2,2,2,2,0]},{"id":61,"path":"pkg/reconciler/common/prune.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"regexp\"","\t\"sort\"","\t\"strconv\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\t\"go.uber.org/zap\"","\tbatchv1 \"k8s.io/api/batch/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"",")","","const (","\t// cron job and service account name","\tprunerCronJobName        = \"tekton-resource-pruner\"","\tprunerServiceAccountName = \"tekton-resource-pruner\"","","\t// tkn container image via environment key","\tprunerContainerImageEnvKey = \"IMAGE_JOB_PRUNER_TKN\"","","\t// namespace annotations","\tpruneAnnotationSkip             = \"operator.tekton.dev/prune.skip\"","\tpruneAnnotationSchedule         = \"operator.tekton.dev/prune.schedule\"","\tpruneAnnotationKeep             = \"operator.tekton.dev/prune.keep\"","\tpruneAnnotationKeepSince        = \"operator.tekton.dev/prune.keep-since\"","\tpruneAnnotationPrunePerResource = \"operator.tekton.dev/prune.prune-per-resource\"","\tpruneAnnotationResources        = \"operator.tekton.dev/prune.resources\"","\tpruneAnnotationStrategy         = \"operator.tekton.dev/prune.strategy\"","","\t// labels used in resources managed by pruner","\tpruneCronLabel = \"tektonconfig.operator.tekton.dev/pruner\"","","\t// prune strategy used in namespace annotation","\tpruneStrategyKeep      = \"keep\"","\tpruneStrategyKeepSince = \"keep-since\"","","\t// script to be executed inside container","\t//nolint:dupword","\tprunerCommand = `","\tfunction prune() {","\t\tnamespace=$1","\t\tflags=$2","\t\tresources=$3","\t\tprune_per_resource=$4","\t\tupdated_flags=$(echo $flags | tr ',' ' ')","\t\tfor resource in ${resources//,/ }; do","\t\t\techo \"\"\t","\t\t\tif [[ \"$prune_per_resource\" == \"true\" ]]; then","\t\t\t\tparent_resource=$(echo $resource | sed \"s/run$//\")","\t\t\t\tresource_names=$(tkn $parent_resource list --namespace=$namespace --no-headers --output=jsonpath={.items[*].metadata.name})","\t\t\t\tif [ $? -ne 0 ]; then","\t\t\t\t\techo \"error on getting list of '$parent_resource'\"","\t\t\t\t\terror_status=1","\t\t\t\t\tcontinue","\t\t\t\tfi","\t\t\t\tif [[ \"$resource_names\" == \"\" ]]; then","\t\t\t\t\techo \"there is no '$parent_resource' available in '$namespace'\"","\t\t\t\t\tcontinue","\t\t\t\tfi","\t\t\t\tfor resource_name in $resource_names; do","\t\t\t\t\techo \"\"","\t\t\t\t\ttarget_cmd=\"tkn $resource delete --$parent_resource=\\\"$resource_name\\\" $updated_flags --namespace=$namespace --force\"","\t\t\t\t\techo \"\\$ ${target_cmd}\"","\t\t\t\t\teval $target_cmd","\t\t\t\t\tif [ $? -ne 0 ]; then","\t\t\t\t\t\terror_status=1","\t\t\t\t\tfi","\t\t\t\tdone","\t\t\telse","\t\t\t\ttarget_cmd=\"tkn $resource delete $updated_flags --namespace=$namespace --force\"","\t\t\t\techo \"\\$ ${target_cmd}\"","\t\t\t\teval $target_cmd","\t\t\t\tif [ $? -ne 0 ]; then","\t\t\t\t\terror_status=1","\t\t\t\tfi","\t\t\tfi","\t\tdone","\t}","\t","\terror_status=0","\tfor c in $*; do","\t\tnamespace=$(echo $c | cut -d ';' -f 1)","\t\tflags=$(echo $c | cut -d ';' -f 2)","\t\tresources=$(echo $c | cut -d ';' -f 3)","\t\tprune_per_resource=$(echo $c | cut -d ';' -f 4)","\t\tprune $namespace $flags $resources $prune_per_resource","\tdone","\texit $error_status","\t`",")","","var (","\t// normalize resources","\tpruneResourceNameMap = map[string]string{","\t\t\"pipelineruns\": \"pipelinerun\",","\t\t\"pipelinerun\":  \"pipelinerun\",","\t\t\"pr\":           \"pipelinerun\",","\t\t\"taskruns\":     \"taskrun\",","\t\t\"taskrun\":      \"taskrun\",","\t\t\"tr\":           \"taskrun\",","\t}",")","","type Pruner struct {","\ttektonConfig    *v1alpha1.TektonConfig","\tkubeClientset   kubernetes.Interface","\ttknImage        string","\ttargetNamespace string","\townerRef        metav1.OwnerReference","\tlogger          *zap.SugaredLogger","}","","type pruneConfig struct {","\tSchedule         string","\tNamespace        string","\tKeep             *uint","\tKeepSince        *uint","\tResources        []string","\tPrunePerResource bool","\tTknImage         string","}","","func Prune(ctx context.Context, k kubernetes.Interface, tektonConfig *v1alpha1.TektonConfig) error {","\tpruner, err := getPruner(ctx, k, tektonConfig)","\tif err != nil {","\t\treturn err","\t}","","\treturn pruner.reconcile(ctx)","}","","func getPruner(ctx context.Context, k kubernetes.Interface, tektonConfig *v1alpha1.TektonConfig) (*Pruner, error) {","\tpruner := \u0026Pruner{","\t\ttektonConfig:    tektonConfig,","\t\tkubeClientset:   k,","\t\ttargetNamespace: tektonConfig.Spec.TargetNamespace,","\t\townerRef:        *metav1.NewControllerRef(tektonConfig, tektonConfig.GetGroupVersionKind()),","\t\tlogger:          logging.FromContext(ctx),","\t}","\treturn pruner, nil","}","","func (pr *Pruner) reconcile(ctx context.Context) error {","\t// get tkn cli container image name from environment","\ttknImageFromEnv := os.Getenv(prunerContainerImageEnvKey)","\tif tknImageFromEnv == \"\" {","\t\treturn fmt.Errorf(\"tkn image '%s' environment variable is not set\", prunerContainerImageEnvKey)","\t}","\tpr.tknImage = tknImageFromEnv","","\t// reconcile cron jobs","\terr := pr.reconcileCronJobs(ctx)","\treturn err","}","","func (pr *Pruner) getOwnerReferences() []metav1.OwnerReference {","\treturn []metav1.OwnerReference{pr.ownerRef}","}","","func (pr *Pruner) reconcileCronJobs(ctx context.Context) error {","\t// group prune config by schedule cron expression","\t// use schedule cron expression as map key","\t// grouping by this way we can limit number of cron jobs","\t// example: {\"* * * * *\": []{}, \"*/2 * * * *\": []{}}","\tpruneConfigsMap := make(map[string][]pruneConfig)","","\t// verify prune job enabled in TektonConfig CR","\tif !pr.tektonConfig.Spec.Pruner.Disabled {","\t\t// collect namespace details","\t\tnamespaceList, err := pr.kubeClientset.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// ignore namespace where pipeline never configured","\t\tignorePattern := regexp.MustCompile(NamespaceIgnorePattern)","\t\tfor _, namespace := range namespaceList.Items {","\t\t\tif ignorePattern.MatchString(namespace.GetName()) {","\t\t\t\tcontinue","\t\t\t}","","\t\t\tprunerCfg := pr.getPruneConfig(\u0026namespace)","\t\t\tif prunerCfg == nil {","\t\t\t\t// prune job skipped for this namespace","\t\t\t\t// may be annotation skip enabled or some error on the config","\t\t\t\t// error details will be printed, if any","\t\t\t\tcontinue","\t\t\t}","","\t\t\t// add prune config into the map","\t\t\tif _, found := pruneConfigsMap[prunerCfg.Schedule]; !found {","\t\t\t\tpruneConfigsMap[prunerCfg.Schedule] = make([]pruneConfig, 0)","\t\t\t}","\t\t\tconfigSlice := pruneConfigsMap[prunerCfg.Schedule]","\t\t\tconfigSlice = append(configSlice, *prunerCfg)","\t\t\tpruneConfigsMap[prunerCfg.Schedule] = configSlice","\t\t}","\t}","","\t// compute hash for the grouped prune configurations","\tcomputedHashMap := make(map[string]string)","\tfor schedule := range pruneConfigsMap {","\t\tpruneConfigs := pruneConfigsMap[schedule]","\t\t// order pruneConfigs by namespace to keep a constant hash value","\t\tsort.SliceStable(pruneConfigs, func(i, j int) bool {","\t\t\treturn pruneConfigs[i].Namespace \u003c pruneConfigs[j].Namespace","\t\t})","","\t\tcomputedHash, err := pr.computeHash(pruneConfigs)","\t\tif err != nil {","\t\t\tpr.logger.Errorw(\"error on computing hash value, skipping this schedule\",","\t\t\t\t\"schedule\", schedule,","\t\t\t\t\"pruneConfigs\", pruneConfigs,","\t\t\t\terr,","\t\t\t)","\t\t\tcontinue","\t\t}","\t\tcomputedHashMap[schedule] = computedHash","\t}","","\t// remove the existing outdated cron jobs","\tcronJobsToBeCreated, err := pr.deleteOutdatedCronJobs(ctx, computedHashMap)","\tif err != nil {","\t\tpr.logger.Errorw(\"error on deleting outdated cron jobs\", err)","\t\treturn err","\t}","","\t// create cron jobs that is modified [or] not exists","\tpr.createCronJobs(ctx, cronJobsToBeCreated, pruneConfigsMap)","","\treturn nil","}","","// to compute hash include, pruneConfigs, startingDeadlineSeconds, nodeSelector, toleration, priorityClass","func (pr *Pruner) computeHash(pruneConfigs []pruneConfig) (string, error) {","\t// to compute hash additionally include, nodeSelector, tolerations, priorityClassName","\t// to update cronjobs if there is a change on those fields","\ttargetObject := struct {","\t\tPruneConfigs            []pruneConfig","\t\tStartingDeadlineSeconds *int64","\t\tNodeSelector            map[string]string","\t\tTolerations             []corev1.Toleration","\t\tPriorityClassName       string","\t\tScript                  string","\t}{","\t\tPruneConfigs:      pruneConfigs,","\t\tNodeSelector:      pr.tektonConfig.Spec.Config.NodeSelector,","\t\tTolerations:       pr.tektonConfig.Spec.Config.Tolerations,","\t\tPriorityClassName: pr.tektonConfig.Spec.Config.PriorityClassName,","\t\tScript:            prunerCommand,","\t}","\t// update StartingDeadlineSeconds","\tif pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds != nil {","\t\ttargetObject.StartingDeadlineSeconds = ptr.Int64(*pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds)","\t}","\treturn hash.Compute(targetObject)","}","","// update prune config from namespace annotations and global pruner config","func (pr *Pruner) getPruneConfig(namespace *corev1.Namespace) *pruneConfig {","\t// create prune config and update some values from global config","\t// note these values may be replaced with namespace annotations value","\tdefaultPruneConfig := pr.tektonConfig.Spec.Pruner","\tpruneCfg := pruneConfig{","\t\tNamespace:        namespace.GetName(),","\t\tTknImage:         pr.tknImage,","\t\tSchedule:         defaultPruneConfig.Schedule,","\t\tPrunePerResource: defaultPruneConfig.PrunePerResource,","\t}","","\tannotations := namespace.GetAnnotations()","","\t// asked to skip for this namespace?","\tif pr.getMapString(annotations, pruneAnnotationSkip, \"\") == \"true\" {","\t\treturn nil","\t}","","\t// if the global schedule is disabled and there is no prune schedule annotation present in a namespace","\t// skip that namespace","\tif defaultPruneConfig.Schedule == \"\" \u0026\u0026 pr.getMapString(annotations, pruneAnnotationSchedule, \"\") == \"\" {","\t\treturn nil","\t}","","\t// update missing values from defaults","\tif defaultPruneConfig.Keep == nil \u0026\u0026 defaultPruneConfig.KeepSince == nil {","\t\tkeep := v1alpha1.PrunerDefaultKeep","\t\tdefaultPruneConfig.Keep = \u0026keep","\t}","\tif len(defaultPruneConfig.Resources) == 0 {","\t\tdefaultPruneConfig.Resources = v1alpha1.PruningDefaultResources","\t}","","\t// update keep and keep-since based on the strategy","\tpruneStrategy := pr.getMapString(annotations, pruneAnnotationStrategy, \"\")","\t// update keep value","\tif pruneStrategy == pruneStrategyKeep || pruneStrategy == \"\" {","\t\t// if value a not found on the namespace annotation, take it from global configuration","\t\t_keep, err := pr.getMapUint(annotations, pruneAnnotationKeep, defaultPruneConfig.Keep)","\t\tif err != nil {","\t\t\tpr.logger.Errorw(\"invalid keep value received\",","\t\t\t\t\"keepValue\", pr.getMapString(annotations, pruneAnnotationKeep, \"\"),","\t\t\t\t\"namespace\", namespace.GetName(),","\t\t\t)","\t\t\treturn nil","\t\t}","\t\tpruneCfg.Keep = _keep","\t}","\t// update keepSince value","\tif pruneStrategy == pruneStrategyKeepSince || pruneStrategy == \"\" {","\t\t// if value a not found on the namespace annotation, take it from global configuration","\t\t_keepSince, err := pr.getMapUint(annotations, pruneAnnotationKeepSince, defaultPruneConfig.KeepSince)","\t\tif err != nil {","\t\t\tpr.logger.Errorw(\"invalid keep-since value received\",","\t\t\t\t\"keepSinceValue\", pr.getMapString(annotations, pruneAnnotationKeepSince, \"\"),","\t\t\t\t\"namespace\", namespace.GetName(),","\t\t\t)","\t\t\treturn nil","\t\t}","\t\tpruneCfg.KeepSince = _keepSince","\t}","","\t// update schedule","\tpruneCfg.Schedule = pr.getMapString(annotations, pruneAnnotationSchedule, defaultPruneConfig.Schedule)","","\t// update resources","\tresourcesString := pr.getMapString(annotations, pruneAnnotationResources, \"\")","\tif resourcesString == \"\" {","\t\tpruneCfg.Resources = defaultPruneConfig.Resources","\t} else {","\t\tresources := strings.Split(resourcesString, \",\")","\t\tpruneCfg.Resources = resources","\t}","","\t// update prune-per-resource, if annotation set on this namespace","\tprunePerResourceString := pr.getMapString(annotations, pruneAnnotationPrunePerResource, \"\")","\tif prunePerResourceString != \"\" {","\t\tpruneCfg.PrunePerResource = prunePerResourceString == \"true\"","\t}","","\t// normalize resource values","\tnormalizedResources := []string{}","\tfor _, resource := range pruneCfg.Resources {","\t\t// trim and lowercase the resource","\t\tresource = strings.ToLower(strings.TrimSpace(resource))","\t\tnormalizedResource, found := pruneResourceNameMap[resource]","\t\tif !found {","\t\t\tpr.logger.Errorw(\"invalid resource value received\",","\t\t\t\t\"resourceValue\", resource,","\t\t\t\t\"namespace\", namespace.GetName(),","\t\t\t)","\t\t\tcontinue","\t\t}","\t\tnormalizedResources = append(normalizedResources, normalizedResource)","\t}","\tpruneCfg.Resources = normalizedResources","","\t// if there is no resource provided, there is no meaning to proceed further","\t// return nil, will not be created a cron job for this namespace","\tif len(pruneCfg.Resources) == 0 {","\t\tpr.logger.Warnw(\"there is no resource defined\",","\t\t\t\"namespace\", namespace.GetName(),","\t\t)","\t\treturn nil","\t}","","\t// if keep and keep-since is nil or either one is zero, skip that namespace","\tif pruneCfg.Keep == nil \u0026\u0026 pruneCfg.KeepSince == nil {","\t\tpr.logger.Warnw(\"flags keep and keep-since can not be nil\",","\t\t\t\"namespace\", namespace.GetName(),","\t\t)","\t\treturn nil","\t} else if pruneCfg.Keep != nil \u0026\u0026 *pruneCfg.Keep == 0 {","\t\tpr.logger.Warnw(\"flag keep can not be 0\",","\t\t\t\"namespace\", namespace.GetName(),","\t\t)","\t\treturn nil","\t} else if pruneCfg.KeepSince != nil \u0026\u0026 *pruneCfg.KeepSince == 0 {","\t\tpr.logger.Warnw(\"flag keep-since can not be 0\",","\t\t\t\"namespace\", namespace.GetName(),","\t\t)","\t\treturn nil","\t}","","\t// sort resources to keep a constant hash value","\tsort.Strings(pruneCfg.Resources)","","\treturn \u0026pruneCfg","}","","func (pr *Pruner) getMapString(data map[string]string, key, defaultValue string) string {","\tvalue, found := data[key]","\tif !found {","\t\treturn defaultValue","\t}","\treturn strings.ToLower(strings.TrimSpace(value))","}","","func (pr *Pruner) getMapUint(data map[string]string, key string, defaultValue *uint) (*uint, error) {","\t// break the defaultValue pointer reference","\tvar defaultValueCloned *uint","\tif defaultValue != nil {","\t\tdValue := *defaultValue","\t\tdefaultValueCloned = \u0026dValue","\t}","","\tvalue, found := data[key]","\tif !found {","\t\treturn defaultValueCloned, nil","\t}","\tuintValue, err := strconv.ParseUint(value, 10, 32)","\tif err != nil {","\t\treturn defaultValueCloned, err","\t}","","\tnewValue := uint(uintValue)","\treturn \u0026newValue, nil","}","","// deletes absolute cron jobs and returns cron schedule to be (re)created","func (pr *Pruner) deleteOutdatedCronJobs(ctx context.Context, computedHashMap map[string]string) (map[string]string, error) {","\t// filter only the jobs owned by this operator","\tlabelsFilter := fmt.Sprintf(\"%s=true\", pruneCronLabel)","\tcronJobs, err := pr.kubeClientset.BatchV1().CronJobs(pr.targetNamespace).List(ctx, metav1.ListOptions{LabelSelector: labelsFilter})","\tif err != nil {","\t\treturn nil, err","\t}","","\tfor _, cronJob := range cronJobs.Items {","\t\tmarkedForDeletion := false","\t\tannotations := cronJob.GetAnnotations()","\t\texistingHash, found := annotations[v1alpha1.LastAppliedHashKey]","\t\tif !found {","\t\t\tmarkedForDeletion = true","\t\t}","","\t\t// check existing hash availability in comptedHashMap","\t\tif !markedForDeletion {","\t\t\thasValidHash := false","\t\t\tfor schedule, computedHash := range computedHashMap {","\t\t\t\t// if hash value found. cron job up to date, no action needed","\t\t\t\t// and remove it from the computedHashMap","\t\t\t\tif computedHash == existingHash {","\t\t\t\t\tdelete(computedHashMap, schedule)","\t\t\t\t\thasValidHash = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\t// hash value not found, mark it for deletion","\t\t\tif !hasValidHash {","\t\t\t\tmarkedForDeletion = true","\t\t\t}","\t\t}","","\t\tif markedForDeletion {","\t\t\tpr.logger.Debugw(\"deleting an outdated cron job\",","\t\t\t\t\"name\", cronJob.GetName(),","\t\t\t\t\"schedule\", cronJob.Spec.Schedule,","\t\t\t)","\t\t\terr = pr.kubeClientset.BatchV1().CronJobs(pr.targetNamespace).Delete(ctx, cronJob.GetName(), metav1.DeleteOptions{})","\t\t\tif err != nil {","\t\t\t\tpr.logger.Errorw(\"error on deleting an outdated cron job\",","\t\t\t\t\t\"name\", cronJob.GetName(),","\t\t\t\t\t\"namespace\", cronJob.GetNamespace(),","\t\t\t\t\terr,","\t\t\t\t)","\t\t\t\tcontinue","\t\t\t}","\t\t}","\t}","","\treturn computedHashMap, nil","}","","func (pr *Pruner) createCronJobs(ctx context.Context, cronJobsToBeCreated map[string]string, pruneConfigMap map[string][]pruneConfig) {","\tfor schedule, computedHash := range cronJobsToBeCreated {","\t\tpruneConfigs, found := pruneConfigMap[schedule]","\t\tif !found {","\t\t\tpr.logger.Errorw(\"prune schedule not found\",","\t\t\t\t\"schedule\", schedule,","\t\t\t)","\t\t\tcontinue","\t\t}","","\t\tprunerCommandArgs := pr.generatePrunerCommandArgs(pruneConfigs)","","\t\t// create cron job","\t\tbackOffLimit := int32(1)","\t\tfailedJobsHistoryLimit := int32(2)","\t\tsuccessfulJobsHistoryLimit := int32(2)","\t\tttlSecondsAfterFinished := int32(3600)","\t\trunAsNonRoot := true","\t\tallowPrivilegedEscalation := false","\t\trunAsUser := ptr.Int64(65532)","\t\tfsGroup := ptr.Int64(65532)","\t\tvar startingDeadlineSeconds *int64","","\t\t// update startingDeadlineSeconds","\t\tif pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds != nil {","\t\t\tstartingDeadlineSeconds = ptr.Int64(*pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds)","\t\t}","","\t\t// if it is a openshift platform remove the user and fsGroup ids","\t\t// those ids will be allocated dynamically","\t\tif v1alpha1.IsOpenShiftPlatform() {","\t\t\trunAsUser = nil","\t\t\tfsGroup = nil","\t\t}","","\t\tcronJob := \u0026batchv1.CronJob{","\t\t\tObjectMeta: metav1.ObjectMeta{","\t\t\t\tGenerateName:    fmt.Sprintf(\"%s-\", prunerCronJobName),","\t\t\t\tNamespace:       pr.targetNamespace,","\t\t\t\tOwnerReferences: pr.getOwnerReferences(),","\t\t\t\tLabels:          map[string]string{v1alpha1.CreatedByKey: v1alpha1.PrunerResourceName, pruneCronLabel: \"true\"},","\t\t\t\tAnnotations:     map[string]string{v1alpha1.LastAppliedHashKey: computedHash},","\t\t\t},","\t\t\tSpec: batchv1.CronJobSpec{","\t\t\t\tSchedule:                   schedule,","\t\t\t\tConcurrencyPolicy:          batchv1.ForbidConcurrent,","\t\t\t\tFailedJobsHistoryLimit:     \u0026failedJobsHistoryLimit,","\t\t\t\tSuccessfulJobsHistoryLimit: \u0026successfulJobsHistoryLimit,","\t\t\t\tStartingDeadlineSeconds:    startingDeadlineSeconds,","\t\t\t\tJobTemplate: batchv1.JobTemplateSpec{","\t\t\t\t\tSpec: batchv1.JobSpec{","\t\t\t\t\t\tTTLSecondsAfterFinished: \u0026ttlSecondsAfterFinished,","\t\t\t\t\t\tBackoffLimit:            \u0026backOffLimit,","\t\t\t\t\t\tTemplate: corev1.PodTemplateSpec{","\t\t\t\t\t\t\tSpec: corev1.PodSpec{","\t\t\t\t\t\t\t\tContainers: []corev1.Container{{","\t\t\t\t\t\t\t\t\tName:                     \"tkn-pruner\",","\t\t\t\t\t\t\t\t\tImage:                    pr.tknImage,","\t\t\t\t\t\t\t\t\tCommand:                  []string{\"/bin/sh\", \"-c\", prunerCommand},","\t\t\t\t\t\t\t\t\tArgs:                     []string{\"-s\", prunerCommandArgs},","\t\t\t\t\t\t\t\t\tTerminationMessagePolicy: corev1.TerminationMessageFallbackToLogsOnError,","\t\t\t\t\t\t\t\t\tSecurityContext: \u0026corev1.SecurityContext{","\t\t\t\t\t\t\t\t\t\tAllowPrivilegeEscalation: \u0026allowPrivilegedEscalation,","\t\t\t\t\t\t\t\t\t\tCapabilities: \u0026corev1.Capabilities{","\t\t\t\t\t\t\t\t\t\t\tDrop: []corev1.Capability{\"ALL\"},","\t\t\t\t\t\t\t\t\t\t},","\t\t\t\t\t\t\t\t\t},","\t\t\t\t\t\t\t\t}},","\t\t\t\t\t\t\t\tRestartPolicy:      corev1.RestartPolicyNever,","\t\t\t\t\t\t\t\tServiceAccountName: prunerServiceAccountName,","\t\t\t\t\t\t\t\tNodeSelector:       pr.tektonConfig.Spec.Config.NodeSelector,","\t\t\t\t\t\t\t\tTolerations:        pr.tektonConfig.Spec.Config.Tolerations,","\t\t\t\t\t\t\t\tPriorityClassName:  pr.tektonConfig.Spec.Config.PriorityClassName,","\t\t\t\t\t\t\t\tSecurityContext: \u0026corev1.PodSecurityContext{","\t\t\t\t\t\t\t\t\tRunAsNonRoot: \u0026runAsNonRoot,","\t\t\t\t\t\t\t\t\tSeccompProfile: \u0026corev1.SeccompProfile{","\t\t\t\t\t\t\t\t\t\tType: corev1.SeccompProfileTypeRuntimeDefault,","\t\t\t\t\t\t\t\t\t},","\t\t\t\t\t\t\t\t\tRunAsUser: runAsUser,","\t\t\t\t\t\t\t\t\tFSGroup:   fsGroup,","\t\t\t\t\t\t\t\t},","\t\t\t\t\t\t\t},","\t\t\t\t\t\t},","\t\t\t\t\t},","\t\t\t\t},","\t\t\t},","\t\t}","","\t\t// create a cron job","\t\t_, err := pr.kubeClientset.BatchV1().CronJobs(pr.targetNamespace).Create(ctx, cronJob, metav1.CreateOptions{})","\t\tif err != nil {","\t\t\tpr.logger.Errorw(\"error on creating a cron job\",","\t\t\t\t\"name\", cronJob.GetName(),","\t\t\t\t\"namespace\", cronJob.GetNamespace(),","\t\t\t\terr,","\t\t\t)","\t\t}","\t}","}","","// Generates command arguments for passing to the tkn container.","// Refer to the \"prunerCommand\" constant (at the top of this file) for the actual execution command.","// The command args format (multiple space-separated instances): namespace;tkn_flag_1,tkn_flag_n;resources;prunePerResource.","// NOTE: A space separates each namespace configuration, so spaces are not allowed in the namespace configuration.","//","// examples:","// ns-one;--keep=5;pipelinerun;false","//   - $ tkn pipelinerun delete --keep=5 --namespace=ns-one --force","//","// ns-two;--keep=2;taskrun;false","//   - $ tkn taskrun delete --keep=2 --namespace=ns-two --force","//","// ns-three;--keep=4,--keep-since=300;pipelinerun,taskrun;false","//   - $ tkn pipelinerun delete --keep=4 --keep-since=300 --namespace=ns-three --force","//   - $ tkn taskrun delete --keep=4 --keep-since=300 --namespace=ns-three --force","//","// ns-four;--keep=4;pipelinerun,taskrun;true  \u003c= note the \"true\" - prunePerResource","// resource names will be taken dynamically on the script","//   - $ tkn pipelinerun delete --pipeline=\"pipeline-one\" --keep=5 --namespace=ns-four --force","//   - $ tkn taskrun delete --task=\"task-one\" --keep=5 --namespace=ns-four --force","func (pr *Pruner) generatePrunerCommandArgs(pruneConfigs []pruneConfig) string {","\tcommands := []string{}","\tfor _, pruneCfg := range pruneConfigs {","\t\ttknFlagsSlice := []string{}","\t\tif pruneCfg.Keep != nil \u0026\u0026 *pruneCfg.Keep != 0 {","\t\t\ttknFlagsSlice = append(tknFlagsSlice, fmt.Sprintf(\"--keep=%d\", *pruneCfg.Keep))","\t\t}","\t\tif pruneCfg.KeepSince != nil \u0026\u0026 *pruneCfg.KeepSince != 0 {","\t\t\ttknFlagsSlice = append(tknFlagsSlice, fmt.Sprintf(\"--keep-since=%d\", *pruneCfg.KeepSince))","\t\t}","","\t\ttnkFlags := strings.Join(tknFlagsSlice, \",\")","\t\tresources := strings.Join(pruneCfg.Resources, \",\")","","\t\tcommands = append(commands,","\t\t\tfmt.Sprintf(","\t\t\t\t\"%s;%s;%s;%t\",","\t\t\t\tpruneCfg.Namespace, tnkFlags, resources, pruneCfg.PrunePerResource,","\t\t\t),","\t\t)","\t}","","\t// create space separated group of commands","\treturn strings.Join(commands, \" \")","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,0,2,2,1,1,1,1,1,1,0,2,0,0,0,2,2,1,1,1,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,0,2,2,2,2,2,2,2,2,2,2,0,0,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,2,0,0,0,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,2,2,2,2,2,2,2,1,1,1,1,1,1,0,0,0,0,2,0,0,2,2,2,2,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,0,0,2,0]},{"id":62,"path":"pkg/reconciler/common/releases.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"fmt\"","\t\"os\"","\t\"path\"","\t\"path/filepath\"","\t\"sort\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"golang.org/x/mod/semver\"",")","","const (","\t// KoEnvKey is the key of the environment variable to specify the path to the ko data directory","\tKoEnvKey = \"KO_DATA_PATH\"","\t// COMMA is the character comma","\tCOMMA = \",\"",")","","var cache = map[string]mf.Manifest{}","var cacheRecursive = map[string]mf.Manifest{}","","// TargetVersion returns the version of the manifest to be installed","// per the spec in the component. If spec.version is empty, the latest","// version known to the operator is returned.","func TargetVersion(instance v1alpha1.TektonComponent) string {","\treturn latestRelease(instance)","}","","// TargetManifest returns the manifest for the TargetVersion","func TargetManifest(instance v1alpha1.TektonComponent) (mf.Manifest, error) {","\treturn FetchRecursive(manifestPath(TargetVersion(instance), instance))","}","","// fetchWithCache is a generic function to fetch manifest with caching","func fetchWithCache(path string, cache map[string]mf.Manifest, fetchFn func(string) (mf.Manifest, error)) (mf.Manifest, error) {","\tif m, ok := cache[path]; ok {","\t\treturn m, nil","\t}","\tresult, err := fetchFn(path)","\tif err == nil {","\t\tcache[path] = result","\t}","\treturn result, err","}","","// Fetch returns a manifest from the given path only, not recursively","func Fetch(path string) (mf.Manifest, error) {","\treturn fetchWithCache(path, cache, func(p string) (mf.Manifest, error) {","\t\treturn mf.NewManifest(p)","\t})","}","","// FetchRecursive returns a manifest from the given path recursively","func FetchRecursive(path string) (mf.Manifest, error) {","\treturn fetchWithCache(path, cacheRecursive, func(p string) (mf.Manifest, error) {","\t\treturn mf.ManifestFrom(mf.Recursive(p))","\t})","}","","func ComponentDir(instance v1alpha1.TektonComponent) string {","\tkoDataDir := ComponentBaseDir()","\tswitch ins := instance.(type) {","\tcase *v1alpha1.TektonPipeline:","\t\treturn filepath.Join(koDataDir, \"tekton-pipeline\")","\tcase *v1alpha1.TektonTrigger:","\t\treturn filepath.Join(koDataDir, \"tekton-trigger\")","\tcase *v1alpha1.TektonDashboard:","\t\tif ins.Spec.Readonly {","\t\t\treturn filepath.Join(koDataDir, \"tekton-dashboard/tekton-dashboard-readonly\")","\t\t}","\t\treturn filepath.Join(koDataDir, \"tekton-dashboard/tekton-dashboard-fullaccess\")","\tcase *v1alpha1.TektonAddon:","\t\treturn filepath.Join(koDataDir, \"tekton-addon\")","\tcase *v1alpha1.TektonConfig:","\t\treturn filepath.Join(koDataDir, \"tekton-config\")","\tcase *v1alpha1.TektonResult:","\t\treturn filepath.Join(koDataDir, \"tekton-results\")","\tcase *v1alpha1.TektonHub:","\t\treturn filepath.Join(koDataDir, \"tekton-hub\")","\tcase *v1alpha1.TektonChain:","\t\treturn filepath.Join(koDataDir, \"tekton-chains\")","\tcase *v1alpha1.ManualApprovalGate:","\t\treturn filepath.Join(koDataDir, \"manual-approval-gate\")","\tcase *v1alpha1.TektonPruner:","\t\t// Event-based pruner uses \"pruner\" directory (not \"tekton-pruner\")","\t\t// to avoid conflicts with job-based pruner in \"tekton-pruner\" directory","\t\treturn filepath.Join(koDataDir, \"pruner\")","\tcase *v1alpha1.TektonScheduler:","\t\treturn filepath.Join(koDataDir, \"tekton-scheduler\")","\t}","\treturn \"\"","}","","func ComponentBaseDir() string {","\treturn os.Getenv(KoEnvKey)","}","","func manifestPath(version string, instance v1alpha1.TektonComponent) string {","\tif !semver.IsValid(sanitizeSemver(version)) {","\t\treturn \"\"","\t}","","\tlocalPath := filepath.Join(ComponentDir(instance), version)","\tif _, err := os.Stat(localPath); !os.IsNotExist(err) {","\t\treturn localPath","\t}","","\treturn \"\"","}","","// sanitizeSemver always adds `v` in front of the version.","// x.y.z is the standard format we use as the semantic version for Knative. The letter `v` is added for","// comparison purpose.","func sanitizeSemver(version string) string {","\treturn fmt.Sprintf(\"v%s\", version)","}","","// allReleases returns the all the available release versions","// available under kodata directory for Knative component.","func allReleases(instance v1alpha1.TektonComponent) ([]string, error) {","\t// List all the directories available under kodata","\tpathname := ComponentDir(instance)","\tfileList, err := os.ReadDir(pathname)","\tif err != nil {","\t\treturn nil, err","\t}","","\treleaseTags := make([]string, 0, len(fileList))","\tfor _, file := range fileList {","\t\tname := path.Join(pathname, file.Name())","\t\tpathDirOrFile, err := os.Stat(name)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif pathDirOrFile.IsDir() {","\t\t\treleaseTags = append(releaseTags, file.Name())","\t\t}","\t}","\tif len(releaseTags) == 0 {","\t\treturn nil, fmt.Errorf(\"unable to find any version number for %v\", instance)","\t}","","\t// This function makes sure the versions are sorted in a descending order.","\tsort.Slice(releaseTags, func(i, j int) bool {","\t\t// The index i is the one after the index j. If i is more recent than j, return true to swap.","\t\treturn semver.Compare(sanitizeSemver(releaseTags[i]), sanitizeSemver(releaseTags[j])) == 1","\t})","","\treturn releaseTags, nil","}","","// latestRelease returns the latest release tag available under kodata directory for Knative component.","func latestRelease(instance v1alpha1.TektonComponent) string {","\tvers, err := allReleases(instance)","\tif err != nil {","\t\tpanic(err)","\t}","\t// The versions are in a descending order, so the first one will be the latest version.","\treturn vers[0]","}","","func AppendManifest(manifest *mf.Manifest, yamlLocation string) error {","\tm, err := mf.ManifestFrom(mf.Recursive(yamlLocation))","\tif err != nil {","\t\treturn err","\t}","\t*manifest = manifest.Append(m)","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,1,1,1,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,0,0,0,2,2,2,2,0,0,2,2,2,1,1,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,1,1,0,1,0,0,2,2,2,0,1,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,0,2,1,1,0,0,2,2,2,2,0,2,0,0,0,2,2,2,1,0,0,2,0,0,2,2,2,1,1,2,2,0]},{"id":63,"path":"pkg/reconciler/common/stages.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"knative.dev/pkg/logging\"",")","","// Stage represents a step in the reconcile process","type Stage func(context.Context, *mf.Manifest, v1alpha1.TektonComponent) error","","// Stages are a list of steps","type Stages []Stage","","// Execute each stage in sequence until one returns an error","func (stages Stages) Execute(ctx context.Context, manifest *mf.Manifest, instance v1alpha1.TektonComponent) error {","\tfor _, stage := range stages {","\t\tif err := stage(ctx, manifest, instance); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","// NoOp does nothing","func NoOp(context.Context, *mf.Manifest, v1alpha1.TektonComponent) error {","\treturn nil","}","","// AppendTarget mutates the passed manifest by appending one","// appropriate for the passed TektonComponent","func AppendTarget(ctx context.Context, manifest *mf.Manifest, instance v1alpha1.TektonComponent) error {","\tm, err := TargetManifest(instance)","\tif err != nil {","\t\treturn err","\t}","\t*manifest = manifest.Append(m)","\treturn nil","}","","// ManifestFetcher returns a manifest appropriate for the instance","type ManifestFetcher func(ctx context.Context, instance v1alpha1.TektonComponent) (*mf.Manifest, error)","","// DeleteObsoleteResources returns a Stage after calculating the","// installed manifest from the instance. This is meant to be called","// *before* executing the reconciliation stages so that the proper","// manifest is captured in a closure before any stage might mutate the","// instance status, e.g. Install.","func DeleteObsoleteResources(ctx context.Context, instance v1alpha1.TektonComponent, fetch ManifestFetcher) Stage {","\tif TargetVersion(instance) == instance.GetStatus().GetVersion() {","\t\treturn NoOp","\t}","\tlogger := logging.FromContext(ctx)","\tinstalled, err := fetch(ctx, instance)","\tif err != nil {","\t\tlogger.Error(\"Unable to obtain the installed manifest; obsolete resources may linger\", err)","\t\treturn NoOp","\t}","\treturn func(_ context.Context, manifest *mf.Manifest, _ v1alpha1.TektonComponent) error {","\t\treturn installed.Filter(mf.NoCRDs, mf.Not(mf.In(*manifest))).Delete()","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,2,2,1,1,2,2,2,1,1,1,2,2,2,0]},{"id":64,"path":"pkg/reconciler/common/targetnamespace.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tlabelKeyTargetNamespace = \"operator.tekton.dev/targetNamespace\"",")","","func ReconcileTargetNamespace(ctx context.Context, labels map[string]string, annotations map[string]string, tektonComponent v1alpha1.TektonComponent, kubeClientSet kubernetes.Interface) error {","\t// get logger","\tlogger := logging.FromContext(ctx)","","\tlogger.Debugw(\"reconciling target namespace\",","\t\t\"targetNamespace\", tektonComponent.GetSpec().GetTargetNamespace(),","\t)","","\t// ensure only one namespace with the specified targetNamespace label","\tnsList, err := kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{LabelSelector: fmt.Sprintf(\"%s=true\", labelKeyTargetNamespace)})","\tif err != nil {","\t\tlogger.Errorw(\"error on listing namespaces\",","\t\t\t\"targetNamespace\", tektonComponent.GetSpec().GetTargetNamespace(),","\t\t\terr,","\t\t)","\t\treturn err","\t}","","\tvar targetNamespace *corev1.Namespace","\tnamespaceDeletionInProgress := false","\tfor _, namespace := range nsList.Items {","\t\tif namespace.Name == tektonComponent.GetSpec().GetTargetNamespace() \u0026\u0026 namespace.DeletionTimestamp == nil {","\t\t\t_targetNamespace := namespace.DeepCopy()","\t\t\ttargetNamespace = _targetNamespace","\t\t} else if len(namespace.GetOwnerReferences()) \u003e 0 {","\t\t\t// delete irrelevant namespaces if the owner is the same component","\t\t\t// if deletionTimestamp is not nil, that indicates, the namespace is in deletion state","\t\t\townerReferenceName := namespace.GetOwnerReferences()[0].Name","\t\t\tif namespace.DeletionTimestamp == nil \u0026\u0026 ownerReferenceName == tektonComponent.GetName() {","\t\t\t\tif err := kubeClientSet.CoreV1().Namespaces().Delete(ctx, namespace.Name, metav1.DeleteOptions{}); err != nil {","\t\t\t\t\tlogger.Errorw(\"error on deleting a namespace\",","\t\t\t\t\t\t\"namespace\", namespace.Name,","\t\t\t\t\t\terr,","\t\t\t\t\t)","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t}","\t\t\tif namespace.DeletionTimestamp != nil {","\t\t\t\tlogger.Debugf(\"'%v' namespace is in deletion state\", namespace.Name)","\t\t\t\tnamespaceDeletionInProgress = true","\t\t\t}","\t\t} else {","\t\t\tlogger.Infof(\"'%v' namespace is not owned by any component\", namespace.Name)","\t\t}","\t}","","\t// if some of the namespaces are in deletion state, requeue and try again on next reconcile cycle","\tif namespaceDeletionInProgress {","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\t// verify the target namespace exists, now get with targetNamespace name","\tif targetNamespace == nil {","\t\t_targetNamespace, err := kubeClientSet.CoreV1().Namespaces().Get(ctx, tektonComponent.GetSpec().GetTargetNamespace(), metav1.GetOptions{})","\t\tif err == nil {","\t\t\tif _targetNamespace.DeletionTimestamp != nil {","\t\t\t\tlogger.Infof(\"'%v' namespace is in deletion state\", tektonComponent.GetSpec().GetTargetNamespace())","\t\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t\t}","\t\t\ttargetNamespace = _targetNamespace","\t\t} else if !errors.IsNotFound(err) {","\t\t\treturn err","\t\t}","\t}","","\t// owner reference used for target namespace","\townerRef := *metav1.NewControllerRef(tektonComponent, tektonComponent.GroupVersionKind())","","\t// update required labels","\tif labels == nil {","\t\tlabels = map[string]string{}","\t}","","\t// update required annotations","\tif annotations == nil {","\t\tannotations = map[string]string{}","\t}","","\tlabels[labelKeyTargetNamespace] = \"true\" // include target namespace label","","\t// if a namespace found, update the required fields","\tif targetNamespace != nil {","\t\t// initialize labels and annotations","\t\tif targetNamespace.Labels == nil {","\t\t\ttargetNamespace.Labels = map[string]string{}","\t\t}","\t\tif targetNamespace.Annotations == nil {","\t\t\ttargetNamespace.Annotations = map[string]string{}","\t\t}","","\t\t// verify the existing namespace has the required fields, if not update","\t\tupdateRequired := false","","\t\t// update owner reference, if no one is owned","\t\tif len(targetNamespace.GetOwnerReferences()) == 0 {","\t\t\ttargetNamespace.OwnerReferences = []metav1.OwnerReference{ownerRef}","\t\t\tupdateRequired = true","\t\t}","","\t\t// update labels","\t\tfor expectedKey, expectedValue := range labels {","\t\t\tfound := false","\t\t\tfor actualKey, actualValue := range targetNamespace.GetLabels() {","\t\t\t\tif expectedKey == actualKey \u0026\u0026 expectedValue == actualValue {","\t\t\t\t\tfound = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\t// update label if not found","\t\t\tif !found {","\t\t\t\ttargetNamespace.Labels[expectedKey] = expectedValue","\t\t\t\tupdateRequired = true","\t\t\t}","\t\t}","","\t\t// include annotations from targetNamespaceMetadata","\t\tfor expectedKey, expectedValue := range annotations {","\t\t\tfound := false","\t\t\tfor actualKey, actualValue := range targetNamespace.GetAnnotations() {","\t\t\t\tif expectedKey == actualKey \u0026\u0026 expectedValue == actualValue {","\t\t\t\t\tfound = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\t// update annotation if not found","\t\t\tif !found {","\t\t\t\ttargetNamespace.Annotations[expectedKey] = expectedValue","\t\t\t\tupdateRequired = true","\t\t\t}","\t\t}","","\t\t// update the namespace, if required","\t\tif updateRequired {","\t\t\t_, err = kubeClientSet.CoreV1().Namespaces().Update(ctx, targetNamespace, metav1.UpdateOptions{})","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"error on updating target namespace\",","\t\t\t\t\t\"targetNamespace\", tektonComponent.GetSpec().GetTargetNamespace(),","\t\t\t\t\terr,","\t\t\t\t)","\t\t\t}","\t\t\treturn err","\t\t}","","\t} else {","\t\t// create target namespace","\t\tnamespace := \u0026corev1.Namespace{","\t\t\tObjectMeta: metav1.ObjectMeta{","\t\t\t\tName:            tektonComponent.GetSpec().GetTargetNamespace(),","\t\t\t\tLabels:          labels,","\t\t\t\tAnnotations:     annotations,","\t\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\t},","\t\t}","","\t\tif _, err := kubeClientSet.CoreV1().Namespaces().Create(ctx, namespace, metav1.CreateOptions{}); err != nil {","\t\t\tlogger.Errorw(\"error on creating target namespace\",","\t\t\t\t\"targetNamespace\", tektonComponent.GetSpec().GetTargetNamespace(),","\t\t\t\terr,","\t\t\t)","\t\t\treturn err","\t\t}","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,2,1,1,0,0,0,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,0,0,0,2,2,2,1,1,1,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,0,0,2,0]},{"id":65,"path":"pkg/reconciler/common/tektoninstallerset/defaultinstallerset.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","type DefaultInstaller struct {","\tLabels          map[string]string","\tAnnotations     map[string]string","\tOwnerReferences []metav1.OwnerReference","\tManifest        mf.Manifest","}","","// GetLabels :- Get all the labels","func (di *DefaultInstaller) GetLabels(ctx context.Context) map[string]string {","\treturn di.Labels","}","","// GetAnnotations :- Get all the annotations","func (di *DefaultInstaller) GetAnnotations(ctx context.Context) map[string]string {","\treturn di.Annotations","}","","// GetOwnerReferences :- Get the owner references","func (di *DefaultInstaller) GetOwnerReferences(ctx context.Context) []metav1.OwnerReference {","\treturn di.OwnerReferences","}","","// GetManifest :- Get the manifest","func (di *DefaultInstaller) GetManifest(ctx context.Context) (*mf.Manifest, error) {","\treturn \u0026di.Manifest, nil","}","","func (di *DefaultInstaller) AddLabelKeyVal(key, val string) {","\tdi.Labels[key] = val","}","","func (di *DefaultInstaller) AddLabelsFromMap(labels map[string]string) {","\tfor k, v := range labels {","\t\tdi.AddLabelKeyVal(k, v)","\t}","}","","func (di *DefaultInstaller) AddAnnotationsKeyVal(key, val string) {","\tdi.Annotations[key] = val","}","","func (di *DefaultInstaller) AddAnnotationsFromMap(annotations map[string]string) {","\tfor k, v := range annotations {","\t\tdi.AddAnnotationsKeyVal(k, v)","\t}","}","","func (di *DefaultInstaller) AddOwnerReferences(ownerRef metav1.OwnerReference) {","\tdi.OwnerReferences = append(di.OwnerReferences, ownerRef)","}","","func (di *DefaultInstaller) AddManifest(manifest mf.Manifest) {","\tdi.Manifest = di.Manifest.Append(manifest)","}","","func (di *DefaultInstaller) AddTypeLabel(val string) {","\tdi.AddLabelKeyVal(v1alpha1.InstallerSetType, val)","}","","func (di *DefaultInstaller) AddCreatedByLabel(val string) {","\tdi.AddLabelKeyVal(v1alpha1.CreatedByKey, val)","}","","func (di *DefaultInstaller) AddReleaseVersionLabel(val string) {","\tdi.AddLabelKeyVal(v1alpha1.ReleaseVersionKey, val)","}","","func NewDefaultInstaller() *DefaultInstaller {","\treturn \u0026DefaultInstaller{","\t\tLabels:          map[string]string{},","\t\tAnnotations:     map[string]string{},","\t\tOwnerReferences: []metav1.OwnerReference{},","\t\tManifest:        mf.Manifest{},","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,2,0,0,2,2,2,0,2,2,2,2,0,0,2,2,2,0,2,2,2,0,1,1,1,0,1,1,1,0,1,1,1,0,2,2,2,2,2,2,2,2]},{"id":66,"path":"pkg/reconciler/common/testing/util.go","lines":["/*","Copyright 2020 The Tekton Authors","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","    http://www.apache.org/licenses/LICENSE-2.0","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package testing","","import (","\t\"fmt\"","\t\"reflect\"","\t\"testing\"","","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes/scheme\"","","\tappsv1 \"k8s.io/api/apps/v1\"",")","","func MakeDeployment(name string, podSpec corev1.PodSpec) *appsv1.Deployment {","\treturn \u0026appsv1.Deployment{","\t\tTypeMeta: metav1.TypeMeta{","\t\t\tKind: \"Deployment\",","\t\t},","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName: name,","\t\t},","\t\tSpec: appsv1.DeploymentSpec{","\t\t\tTemplate: corev1.PodTemplateSpec{","\t\t\t\tSpec: podSpec,","\t\t\t},","\t\t},","\t}","}","","func MakeDaemonSet(name string, podSpec corev1.PodSpec) *appsv1.DaemonSet {","\treturn \u0026appsv1.DaemonSet{","\t\tTypeMeta: metav1.TypeMeta{","\t\t\tKind: \"DaemonSet\",","\t\t},","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName: name,","\t\t},","\t\tSpec: appsv1.DaemonSetSpec{","\t\t\tTemplate: corev1.PodTemplateSpec{","\t\t\t\tSpec: podSpec,","\t\t\t},","\t\t},","\t}","}","","func MakeUnstructured(t *testing.T, obj interface{}) unstructured.Unstructured {","\tt.Helper()","\tvar result = unstructured.Unstructured{}","\terr := scheme.Scheme.Convert(obj, \u0026result, nil)","\tif err != nil {","\t\tt.Fatalf(\"Could not create unstructured object: %v, err: %v\", result, err)","\t}","\treturn result","}","","func AssertEqual(t *testing.T, actual, expected interface{}) {","\tt.Helper()","\tif actual == expected {","\t\treturn","\t}","\tt.Fatalf(\"expected does not equal actual. \\nExpected: %v\\nActual: %v\", expected, actual)","}","","func AssertNotEqual(t *testing.T, actual, expected interface{}) {","\tt.Helper()","\tif actual != expected {","\t\treturn","\t}","\tt.Fatalf(\"expected equal actual. \\nExpected: %v\\nActual: %v\", expected, actual)","}","","func AssertDeepEqual(t *testing.T, actual, expected interface{}) {","\tt.Helper()","\tif reflect.DeepEqual(actual, expected) {","\t\treturn","\t}","\tt.Fatalf(\"expected does not deep equal actual. \\nExpected: %T %+v\\nActual:   %T %+v\", expected, expected, actual, actual)","}","","func AssertNoError(t *testing.T, err error) {","\tt.Helper()","\tif err != nil {","\t\tt.Fatalf(\"expected no error, error: %q\", err)","\t}","}","","// PrintWantGot takes a diff string generated by cmp.Diff and returns it","// in a consistent format for reuse across all of our tests. This","// func assumes that the order of arguments passed to cmp.Diff was","// (want, got) or, in other words, the expectedResult then the actualResult.","func PrintWantGot(diff string) string {","\treturn fmt.Sprintf(\"(-want, +got): %s\", diff)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1]},{"id":67,"path":"pkg/reconciler/common/transformer_additional_options.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\t\"go.uber.org/zap\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tautoscalingv2 \"k8s.io/api/autoscaling/v2\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\tapimachineryRuntime \"k8s.io/apimachinery/pkg/runtime\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"",")","","const (","\tKindConfigMap                      = \"ConfigMap\"","\tKindDeployment                     = \"Deployment\"","\tKindStatefulSet                    = \"StatefulSet\"","\tKindHorizontalPodAutoscaler        = \"HorizontalPodAutoscaler\"","\tKindValidatingWebhookConfiguration = \"ValidatingWebhookConfiguration\"","\tKindMutatingWebhookConfiguration   = \"MutatingWebhookConfiguration\"",")","","type OptionsTransformer struct {","\toptions v1alpha1.AdditionalOptions","\tlogger  *zap.SugaredLogger","}","","func ExecuteAdditionalOptionsTransformer(ctx context.Context, manifest *mf.Manifest, targetNamespace string, additionalOptions v1alpha1.AdditionalOptions) error {","\tot := \u0026OptionsTransformer{","\t\toptions: additionalOptions,","\t\tlogger:  logging.FromContext(ctx),","\t}","","\tif additionalOptions.Disabled != nil \u0026\u0026 *additionalOptions.Disabled {","\t\treturn nil","\t}","","\t// execute transformer","\tfinalManifest, err := manifest.Transform(ot.transform)","\tif err != nil {","\t\treturn err","\t}","\t*manifest = finalManifest","","\t// create config map, if not found in the existing manifest","\textraConfigMaps, err := ot.createConfigMaps(manifest, targetNamespace, additionalOptions)","\tif err != nil {","\t\treturn err","\t}","\t// update into the manifests","\tif err = ot.addInToManifest(manifest, extraConfigMaps); err != nil {","\t\treturn err","\t}","","\t// create HorizontalPodAutoscaler, if not found in the existing manifest","\textraHPAs, err := ot.createHorizontalPodAutoscalers(manifest, targetNamespace, additionalOptions)","\tif err != nil {","\t\treturn err","\t}","\t// update into the manifests","\tif err = ot.addInToManifest(manifest, extraHPAs); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func (ot *OptionsTransformer) addInToManifest(manifest *mf.Manifest, additionalResources []unstructured.Unstructured) error {","\tif len(additionalResources) \u003e 0 {","\t\tadditionalManifest, err := mf.ManifestFrom(mf.Slice(additionalResources))","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\t*manifest = manifest.Append(additionalManifest)","\t}","\treturn nil","}","","func (ot *OptionsTransformer) transform(u *unstructured.Unstructured) error {","\tswitch u.GetKind() {","\tcase KindConfigMap:","\t\treturn ot.updateConfigMaps(u)","","\tcase KindDeployment:","\t\terr := ot.updateDeployments(u)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\t// update deployment hash value in to template labels","\t\t// this will recreate the pods, if there is a change detected in deployment.spec","\t\treturn ot.updateDeploymentHashValue(u)","","\tcase KindStatefulSet:","\t\treturn ot.updateStatefulSets(u)","","\tcase KindHorizontalPodAutoscaler:","\t\treturn ot.updateHorizontalPodAutoscalers(u)","","\tcase KindValidatingWebhookConfiguration, KindMutatingWebhookConfiguration:","\t\treturn ot.updateWebhookConfiguration(u)","\t}","","\treturn nil","}","","func (ot *OptionsTransformer) updateLabels(u *unstructured.Unstructured, labels map[string]string) error {","\treturn ot.updateMapField(u, labels, \"metadata\", \"labels\")","}","","func (ot *OptionsTransformer) updateAnnotations(u *unstructured.Unstructured, annotations map[string]string) error {","\treturn ot.updateMapField(u, annotations, \"metadata\", \"annotations\")","}","","func (ot *OptionsTransformer) updateMapField(u *unstructured.Unstructured, extraData map[string]string, locationKey ...string) error {","\tif len(extraData) == 0 || len(locationKey) == 0 {","\t\treturn nil","\t}","","\t// get source map data","\tsourceData, _, err := unstructured.NestedMap(u.Object, locationKey...)","\tif err != nil {","\t\treturn err","\t}","","\tif sourceData == nil {","\t\tsourceData = make(map[string]interface{})","\t}","","\t// update source map data","\tfor key, value := range extraData {","\t\tsourceData[key] = value","\t}","","\t// update source map data into the target object","\tunstructured.RemoveNestedField(u.Object, locationKey...)","\treturn unstructured.SetNestedMap(u.Object, sourceData, locationKey...)","}","","func (ot *OptionsTransformer) updateConfigMaps(u *unstructured.Unstructured) error {","","\toptionsConfigMap, found := ot.options.ConfigMaps[u.GetName()]","\tif !found {","\t\treturn nil","\t}","","\t// update labels","\terr := ot.updateLabels(u, optionsConfigMap.Labels)","\tif err != nil {","\t\treturn err","\t}","","\t// update annotations","\terr = ot.updateAnnotations(u, optionsConfigMap.Annotations)","\tif err != nil {","\t\treturn err","\t}","","\t// convert unstructured object to configMap","\ttargetConfigMap := \u0026corev1.ConfigMap{}","\terr = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetConfigMap)","\tif err != nil {","\t\treturn err","\t}","","\t// update data part of the target config map","\tfor dataKey, newValue := range optionsConfigMap.Data {","\t\ttargetConfigMap.Data[dataKey] = newValue","\t}","","\t// convert configMap to unstructured object","\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetConfigMap)","\tif err != nil {","\t\treturn err","\t}","\tu.SetUnstructuredContent(obj)","","\treturn nil","}","","func (ot *OptionsTransformer) createConfigMaps(manifest *mf.Manifest, targetNamespace string, additionalOptions v1alpha1.AdditionalOptions) ([]unstructured.Unstructured, error) {","\textraConfigMaps := []unstructured.Unstructured{}","\texistingConfigMaps := manifest.Filter(mf.Any(mf.ByKind(KindConfigMap)))","\tfor configMapName, providedConfigMap := range additionalOptions.ConfigMaps {","\t\tfound := false","\t\tfor _, resource := range existingConfigMaps.Resources() {","\t\t\tif resource.GetName() == configMapName {","\t\t\t\tfound = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif found {","\t\t\tcontinue","\t\t}","","\t\t// update name","\t\tprovidedConfigMap.SetName(configMapName)","","\t\t// always update namespace to targetNamespace","\t\tprovidedConfigMap.SetNamespace(targetNamespace)","","\t\t// update kind","\t\tif providedConfigMap.TypeMeta.Kind == \"\" {","\t\t\tprovidedConfigMap.TypeMeta.Kind = KindConfigMap","\t\t}","","\t\t// update api version","\t\tif providedConfigMap.TypeMeta.APIVersion == \"\" {","\t\t\tprovidedConfigMap.TypeMeta.APIVersion = corev1.SchemeGroupVersion.Version","\t\t}","","\t\t// convert configMap to unstructured object","\t\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(\u0026providedConfigMap)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tu := unstructured.Unstructured{}","\t\tu.SetUnstructuredContent(obj)","\t\textraConfigMaps = append(extraConfigMaps, u)","\t}","","\treturn extraConfigMaps, nil","}","","func (ot *OptionsTransformer) updateDeployments(u *unstructured.Unstructured) error {","\t// verify the deployment has changes","\tdeploymentOptions, found := ot.options.Deployments[u.GetName()]","\tif !found {","\t\treturn nil","\t}","","\t// update labels","\terr := ot.updateLabels(u, deploymentOptions.Labels)","\tif err != nil {","\t\treturn err","\t}","","\t// update annotations","\terr = ot.updateAnnotations(u, deploymentOptions.Annotations)","\tif err != nil {","\t\treturn err","\t}","","\t// update pod template labels","\terr = ot.updateMapField(u, deploymentOptions.Spec.Template.Labels, \"spec\", \"template\", \"metadata\", \"labels\")","\tif err != nil {","\t\treturn err","\t}","","\t// update pod template annotations","\terr = ot.updateMapField(u, deploymentOptions.Spec.Template.Annotations, \"spec\", \"template\", \"metadata\", \"annotations\")","\tif err != nil {","\t\treturn err","\t}","","\t// convert unstructured object to deployment","\ttargetDeployment := \u0026appsv1.Deployment{}","\terr = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetDeployment)","\tif err != nil {","\t\treturn err","\t}","","\t// update replicas","\tif deploymentOptions.Spec.Replicas != nil {","\t\ttargetDeployment.Spec.Replicas = ptr.Int32(*deploymentOptions.Spec.Replicas)","\t}","","\t// update affinity","\tif deploymentOptions.Spec.Template.Spec.Affinity != nil {","\t\ttargetDeployment.Spec.Template.Spec.Affinity = deploymentOptions.Spec.Template.Spec.Affinity","\t}","","\t// update PriorityClassName","\tif deploymentOptions.Spec.Template.Spec.PriorityClassName != \"\" {","\t\ttargetDeployment.Spec.Template.Spec.PriorityClassName = deploymentOptions.Spec.Template.Spec.PriorityClassName","\t}","","\t// update node selectors","\tif len(deploymentOptions.Spec.Template.Spec.NodeSelector) \u003e 0 {","\t\ttargetDeployment.Spec.Template.Spec.NodeSelector = deploymentOptions.Spec.Template.Spec.NodeSelector","\t}","","\t// update tolerations","\tif len(deploymentOptions.Spec.Template.Spec.Tolerations) \u003e 0 {","\t\ttargetDeployment.Spec.Template.Spec.Tolerations = deploymentOptions.Spec.Template.Spec.Tolerations","\t}","","\t// update Topology Spread Constraints","\tif len(deploymentOptions.Spec.Template.Spec.TopologySpreadConstraints) \u003e 0 {","\t\ttargetDeployment.Spec.Template.Spec.TopologySpreadConstraints = deploymentOptions.Spec.Template.Spec.TopologySpreadConstraints","\t}","","\t// update runTimeClassName","\tif deploymentOptions.Spec.Template.Spec.RuntimeClassName != nil {","\t\ttargetDeployment.Spec.Template.Spec.RuntimeClassName = deploymentOptions.Spec.Template.Spec.RuntimeClassName","\t}","","\t// update volumes","\ttargetDeployment.Spec.Template.Spec.Volumes = ot.updateVolumes(targetDeployment.Spec.Template.Spec.Volumes, deploymentOptions.Spec.Template.Spec.Volumes)","","\t// update init containers","\ttargetDeployment.Spec.Template.Spec.InitContainers = ot.updateContainers(targetDeployment.Spec.Template.Spec.InitContainers, deploymentOptions.Spec.Template.Spec.InitContainers)","","\t// update containers","\ttargetDeployment.Spec.Template.Spec.Containers = ot.updateContainers(targetDeployment.Spec.Template.Spec.Containers, deploymentOptions.Spec.Template.Spec.Containers)","","\t// convert deployment to unstructured object","\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetDeployment)","\tif err != nil {","\t\treturn err","\t}","\tu.SetUnstructuredContent(obj)","","\treturn nil","}","","func (ot *OptionsTransformer) updateVolumes(sourceVolumes, additionalVolumes []corev1.Volume) []corev1.Volume {","\tfor _, newVolume := range additionalVolumes {","\t\titemFound := false","\t\tfor volumeIndex, oldVolume := range sourceVolumes {","\t\t\tif oldVolume.Name == newVolume.Name {","\t\t\t\tsourceVolumes[volumeIndex] = newVolume","\t\t\t\titemFound = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !itemFound {","\t\t\tsourceVolumes = append(sourceVolumes, newVolume)","\t\t}","\t}","\treturn sourceVolumes","}","","func (ot *OptionsTransformer) updateContainers(targetContainers, containersOptions []corev1.Container) []corev1.Container {","\tcontainersToAdd := []corev1.Container{}","\tfor _, containerOptions := range containersOptions {","\t\tcontainerFound := false","\t\tfor containerIndex := range targetContainers {","\t\t\ttargetContainer := targetContainers[containerIndex]","\t\t\tif containerOptions.Name != targetContainer.Name {","\t\t\t\tcontinue","\t\t\t}","\t\t\tcontainerFound = true","","\t\t\t// update resource requirements","\t\t\tif containerOptions.Resources.Size() != 0 {","\t\t\t\ttargetContainers[containerIndex].Resources = containerOptions.Resources","\t\t\t}","","\t\t\t// update environments","\t\t\t{","\t\t\t\tenvVariables := targetContainer.Env","\t\t\t\tfor _, newEnv := range containerOptions.Env {","\t\t\t\t\titemFound := false","\t\t\t\t\tfor envIndex, oldEnv := range envVariables {","\t\t\t\t\t\tif oldEnv.Name == newEnv.Name {","\t\t\t\t\t\t\tenvVariables[envIndex] = newEnv","\t\t\t\t\t\t\titemFound = true","\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tif !itemFound {","\t\t\t\t\t\tenvVariables = append(envVariables, newEnv)","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\ttargetContainers[containerIndex].Env = envVariables","\t\t\t}","","\t\t\t// update volume mounts","\t\t\t{","\t\t\t\tvolumeMounts := targetContainer.VolumeMounts","\t\t\t\tfor _, newVolumeMount := range containerOptions.VolumeMounts {","\t\t\t\t\titemFound := false","\t\t\t\t\tfor volumeMountIndex, oldVolumeMount := range volumeMounts {","\t\t\t\t\t\tif oldVolumeMount.Name == newVolumeMount.Name {","\t\t\t\t\t\t\tvolumeMounts[volumeMountIndex] = newVolumeMount","\t\t\t\t\t\t\titemFound = true","\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t\tif !itemFound {","\t\t\t\t\t\tvolumeMounts = append(volumeMounts, newVolumeMount)","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\ttargetContainers[containerIndex].VolumeMounts = volumeMounts","\t\t\t}","","\t\t\t// update arguments: replace by key, support pair-form, preserve existing style, avoid duplicates","\t\t\tif len(containerOptions.Args) \u003e 0 {","\t\t\t\texisting := targetContainers[containerIndex].Args","\t\t\t\tkeyIndex := make(map[string]int)","\t\t\t\tseenExact := make(map[string]bool)","\t\t\t\t// index existing args by key; track pair-style positions","\t\t\t\tfor i := 0; i \u003c len(existing); i++ {","\t\t\t\t\ta := existing[i]","\t\t\t\t\tseenExact[a] = true","\t\t\t\t\tif !strings.HasPrefix(a, \"-\") {","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\tif eq := strings.Index(a, \"=\"); eq \u003e 0 {","\t\t\t\t\t\tkeyIndex[a[:eq]] = i","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\t// pair-style key then value","\t\t\t\t\tif i+1 \u003c len(existing) \u0026\u0026 !strings.HasPrefix(existing[i+1], \"-\") {","\t\t\t\t\t\tkeyIndex[a] = i","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t// merge options","\t\t\t\tfor i := 0; i \u003c len(containerOptions.Args); {","\t\t\t\t\ta := containerOptions.Args[i]","\t\t\t\t\tif strings.HasPrefix(a, \"-\") {","\t\t\t\t\t\t// key=value from options","\t\t\t\t\t\tif strings.Contains(a, \"=\") {","\t\t\t\t\t\t\tk := a[:strings.Index(a, \"=\")]","\t\t\t\t\t\t\tif pos, ok := keyIndex[k]; ok {","\t\t\t\t\t\t\t\t// preserve existing style","\t\t\t\t\t\t\t\tif existing[pos] == k {","\t\t\t\t\t\t\t\t\tval := a[strings.Index(a, \"=\")+1:]","\t\t\t\t\t\t\t\t\tif pos+1 \u003c len(existing) \u0026\u0026 !strings.HasPrefix(existing[pos+1], \"-\") {","\t\t\t\t\t\t\t\t\t\texisting[pos+1] = val","\t\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\t\texisting = append(existing[:pos+1], append([]string{val}, existing[pos+1:]...)...)","\t\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\texisting[pos] = a","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\tkeyIndex[k] = len(existing)","\t\t\t\t\t\t\t\texisting = append(existing, a)","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\ti++","\t\t\t\t\t\t\tcontinue","\t\t\t\t\t\t}","\t\t\t\t\t\t// pair-style from options: key then value","\t\t\t\t\t\tif i+1 \u003c len(containerOptions.Args) \u0026\u0026 !strings.HasPrefix(containerOptions.Args[i+1], \"-\") {","\t\t\t\t\t\t\tk, val := a, containerOptions.Args[i+1]","\t\t\t\t\t\t\tif pos, ok := keyIndex[k]; ok {","\t\t\t\t\t\t\t\tif existing[pos] == k {","\t\t\t\t\t\t\t\t\tif pos+1 \u003c len(existing) \u0026\u0026 !strings.HasPrefix(existing[pos+1], \"-\") {","\t\t\t\t\t\t\t\t\t\texisting[pos+1] = val","\t\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\t\texisting = append(existing[:pos+1], append([]string{val}, existing[pos+1:]...)...)","\t\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\texisting[pos] = k + \"=\" + val","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\tkeyIndex[k] = len(existing)","\t\t\t\t\t\t\t\texisting = append(existing, k, val)","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\ti += 2","\t\t\t\t\t\t\tcontinue","\t\t\t\t\t\t}","\t\t\t\t\t\t// standalone flag: exact dedupe","\t\t\t\t\t\tif !seenExact[a] {","\t\t\t\t\t\t\tseenExact[a] = true","\t\t\t\t\t\t\texisting = append(existing, a)","\t\t\t\t\t\t}","\t\t\t\t\t\ti++","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\t// non-flag token: exact-string dedupe","\t\t\t\t\tif !seenExact[a] {","\t\t\t\t\t\tseenExact[a] = true","\t\t\t\t\t\texisting = append(existing, a)","\t\t\t\t\t}","\t\t\t\t\ti++","\t\t\t\t}","\t\t\t\ttargetContainers[containerIndex].Args = existing","\t\t\t}","\t\t}","\t\t// add the new container from the options list","\t\tif !containerFound {","\t\t\tcontainersToAdd = append(containersToAdd, containerOptions)","\t\t}","\t}","\ttargetContainers = append(targetContainers, containersToAdd...)","\treturn targetContainers","}","","// calculate deployment spec hash value and update it under pods label(under template).","// If there is change detected in deployment spec, all pods will be recreated, as we the pods label(hash value label) is updated","func (ot *OptionsTransformer) updateDeploymentHashValue(u *unstructured.Unstructured) error {","\t// convert unstructured object to deployment","\tdeployment := \u0026appsv1.Deployment{}","\terr := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, deployment)","\tif err != nil {","\t\treturn err","\t}","","\t// remove some of the fields, that we do not want to calculate hash value","\tdeployment.Spec.Selector = nil","\tdeployment.Spec.Strategy = appsv1.DeploymentStrategy{}","\t// remove existing hash value from template","\tif len(deployment.Spec.Template.Labels) == 0 {","\t\tdeployment.Spec.Template.Labels = map[string]string{}","\t}","\tdeployment.Spec.Template.Labels[v1alpha1.DeploymentSpecHashValueLabelKey] = \"\"","","\t// Compute a stable hash of the deployment spec and set it in a pod-template label","\t// to force a rollout on spec changes.","\t//","\t// Label values are limited to 63 characters; SHA-256 hex output is 64 chars.","\t// Use SHA-256 for FIPS compliance and truncate the hex string to fit as a label.","\tfullHash, err := hash.Compute(deployment.Spec)","\tif err != nil {","\t\treturn err","\t}","\t// Use a safe truncated prefix for the label value","\tconst hashLabelLen = 32","\thashValue := fullHash","\tif len(hashValue) \u003e hashLabelLen {","\t\thashValue = hashValue[:hashLabelLen]","\t}","","\t// update hash value","\tobj := u.Object","\tif err := unstructured.SetNestedField(obj, hashValue, \"spec\", \"template\", \"metadata\", \"labels\", v1alpha1.DeploymentSpecHashValueLabelKey); err != nil {","\t\treturn err","\t}","","\tu.SetUnstructuredContent(obj)","\treturn nil","}","","func (ot *OptionsTransformer) updateStatefulSets(u *unstructured.Unstructured) error {","\t// verify the statefulSet has changes","\tstatefulSetOptions, found := ot.options.StatefulSets[u.GetName()]","\tif !found {","\t\treturn nil","\t}","","\t// update labels","\terr := ot.updateLabels(u, statefulSetOptions.Labels)","\tif err != nil {","\t\treturn err","\t}","","\t// update annotations","\terr = ot.updateAnnotations(u, statefulSetOptions.Annotations)","\tif err != nil {","\t\treturn err","\t}","","\t// update pod template labels","\terr = ot.updateMapField(u, statefulSetOptions.Spec.Template.Labels, \"spec\", \"template\", \"metadata\", \"labels\")","\tif err != nil {","\t\treturn err","\t}","","\t// update pod template annotations","\terr = ot.updateMapField(u, statefulSetOptions.Spec.Template.Annotations, \"spec\", \"template\", \"metadata\", \"annotations\")","\tif err != nil {","\t\treturn err","\t}","","\t// convert unstructured object to statefulSet","\ttargetStatefulSet := \u0026appsv1.StatefulSet{}","\terr = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetStatefulSet)","\tif err != nil {","\t\treturn err","\t}","","\t// update replicas","\tif statefulSetOptions.Spec.Replicas != nil {","\t\ttargetStatefulSet.Spec.Replicas = ptr.Int32(*statefulSetOptions.Spec.Replicas)","\t}","","\t// update affinity","\tif statefulSetOptions.Spec.Template.Spec.Affinity != nil {","\t\ttargetStatefulSet.Spec.Template.Spec.Affinity = statefulSetOptions.Spec.Template.Spec.Affinity","\t}","","\t// update priorityClassName","\tif statefulSetOptions.Spec.Template.Spec.PriorityClassName != \"\" {","\t\ttargetStatefulSet.Spec.Template.Spec.PriorityClassName = statefulSetOptions.Spec.Template.Spec.PriorityClassName","","\t}","","\t// update node selectors","\tif len(statefulSetOptions.Spec.Template.Spec.NodeSelector) \u003e 0 {","\t\ttargetStatefulSet.Spec.Template.Spec.NodeSelector = statefulSetOptions.Spec.Template.Spec.NodeSelector","\t}","","\t// update tolerations","\tif len(statefulSetOptions.Spec.Template.Spec.Tolerations) \u003e 0 {","\t\ttargetStatefulSet.Spec.Template.Spec.Tolerations = statefulSetOptions.Spec.Template.Spec.Tolerations","\t}","","\t// update Topology Spread Constraints","\tif len(statefulSetOptions.Spec.Template.Spec.TopologySpreadConstraints) \u003e 0 {","\t\ttargetStatefulSet.Spec.Template.Spec.TopologySpreadConstraints = statefulSetOptions.Spec.Template.Spec.TopologySpreadConstraints","\t}","","\t// update pod management policy","\tif statefulSetOptions.Spec.PodManagementPolicy != \"\" {","\t\ttargetStatefulSet.Spec.PodManagementPolicy = statefulSetOptions.Spec.PodManagementPolicy","\t}","","\t// update service name","\tif statefulSetOptions.Spec.ServiceName != \"\" {","\t\ttargetStatefulSet.Spec.ServiceName = statefulSetOptions.Spec.ServiceName","\t}","","\t// update volume claim templates","\tif len(statefulSetOptions.Spec.VolumeClaimTemplates) \u003e 0 {","\t\tfor _, newVolumeClaimTpl := range statefulSetOptions.Spec.VolumeClaimTemplates {","\t\t\titemFound := false","\t\t\tfor volumeClaimTplIndex, oldVolumeClaimTpl := range targetStatefulSet.Spec.VolumeClaimTemplates {","\t\t\t\tif oldVolumeClaimTpl.Name == newVolumeClaimTpl.Name {","\t\t\t\t\ttargetStatefulSet.Spec.VolumeClaimTemplates[volumeClaimTplIndex] = newVolumeClaimTpl","\t\t\t\t\titemFound = true","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\tif !itemFound {","\t\t\t\ttargetStatefulSet.Spec.VolumeClaimTemplates = append(targetStatefulSet.Spec.VolumeClaimTemplates, newVolumeClaimTpl)","\t\t\t}","\t\t}","\t}","","\t// update runTimeClassName","\tif statefulSetOptions.Spec.Template.Spec.RuntimeClassName != nil {","\t\ttargetStatefulSet.Spec.Template.Spec.RuntimeClassName = statefulSetOptions.Spec.Template.Spec.RuntimeClassName","\t}","","\t// update volumes","\ttargetStatefulSet.Spec.Template.Spec.Volumes = ot.updateVolumes(targetStatefulSet.Spec.Template.Spec.Volumes, statefulSetOptions.Spec.Template.Spec.Volumes)","","\t// update init containers","\ttargetStatefulSet.Spec.Template.Spec.InitContainers = ot.updateContainers(targetStatefulSet.Spec.Template.Spec.InitContainers, statefulSetOptions.Spec.Template.Spec.InitContainers)","","\t// update containers","\ttargetStatefulSet.Spec.Template.Spec.Containers = ot.updateContainers(targetStatefulSet.Spec.Template.Spec.Containers, statefulSetOptions.Spec.Template.Spec.Containers)","","\t// convert statefulSet to unstructured object","\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetStatefulSet)","\tif err != nil {","\t\treturn err","\t}","\tu.SetUnstructuredContent(obj)","","\treturn nil","}","","func (ot *OptionsTransformer) updateHorizontalPodAutoscalers(u *unstructured.Unstructured) error {","\thpaOptions, found := ot.options.HorizontalPodAutoscalers[u.GetName()]","\tif !found {","\t\treturn nil","\t}","","\t// update labels","\terr := ot.updateLabels(u, hpaOptions.Labels)","\tif err != nil {","\t\treturn err","\t}","","\t// update annotations","\terr = ot.updateAnnotations(u, hpaOptions.Annotations)","\tif err != nil {","\t\treturn err","\t}","","\t// convert unstructured object to statefulSet","\ttargetHpa := autoscalingv2.HorizontalPodAutoscaler{}","\terr = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, \u0026targetHpa)","\tif err != nil {","\t\treturn err","\t}","","\t// update scaling target reference","\tif hpaOptions.Spec.ScaleTargetRef.Kind != \"\" \u0026\u0026 hpaOptions.Spec.ScaleTargetRef.Name != \"\" {","\t\ttargetHpa.Spec.ScaleTargetRef = hpaOptions.Spec.ScaleTargetRef","\t}","","\t// updates min replicas","\tif hpaOptions.Spec.MinReplicas != nil {","\t\ttargetHpa.Spec.MinReplicas = ptr.Int32(*hpaOptions.Spec.MinReplicas)","\t}","","\t// updates max replicas","\tif hpaOptions.Spec.MaxReplicas \u003e 0 {","\t\ttargetHpa.Spec.MaxReplicas = hpaOptions.Spec.MaxReplicas","\t}","","\t// update metrics","\tif len(hpaOptions.Spec.Metrics) \u003e 0 {","\t\ttargetHpa.Spec.Metrics = hpaOptions.Spec.Metrics","\t}","","\t// update behavior","\tif hpaOptions.Spec.Behavior != nil {","\t\t// update behavior, if empty","\t\tif targetHpa.Spec.Behavior == nil {","\t\t\ttargetHpa.Spec.Behavior = \u0026autoscalingv2.HorizontalPodAutoscalerBehavior{}","\t\t}","","\t\t// update scaling down","\t\tif hpaOptions.Spec.Behavior.ScaleDown != nil {","\t\t\ttargetHpa.Spec.Behavior.ScaleDown = hpaOptions.Spec.Behavior.ScaleDown.DeepCopy()","\t\t}","","\t\t// update scaling up","\t\tif hpaOptions.Spec.Behavior.ScaleUp != nil {","\t\t\ttargetHpa.Spec.Behavior.ScaleUp = hpaOptions.Spec.Behavior.ScaleUp.DeepCopy()","\t\t}","\t}","","\t// convert HorizontalPodAutoscaler to unstructured object","\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(\u0026targetHpa)","\tif err != nil {","\t\treturn err","\t}","\tu.SetUnstructuredContent(obj)","","\treturn nil","}","","func (ot *OptionsTransformer) createHorizontalPodAutoscalers(manifest *mf.Manifest, targetNamespace string, additionalOptions v1alpha1.AdditionalOptions) ([]unstructured.Unstructured, error) {","\tnewHPAs := []unstructured.Unstructured{}","\texistingHPAs := manifest.Filter(mf.Any(mf.ByKind(KindHorizontalPodAutoscaler)))","\tfor hpaName, newHPA := range additionalOptions.HorizontalPodAutoscalers {","\t\tfound := false","\t\tfor _, resource := range existingHPAs.Resources() {","\t\t\tif resource.GetName() == hpaName {","\t\t\t\tfound = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif found {","\t\t\tcontinue","\t\t}","","\t\t// update name","\t\tnewHPA.SetName(hpaName)","","\t\t// update the namespace to targetNamespace","\t\tnewHPA.SetNamespace(targetNamespace)","","\t\t// update kind","\t\tif newHPA.TypeMeta.Kind == \"\" {","\t\t\tnewHPA.TypeMeta.Kind = KindHorizontalPodAutoscaler","\t\t}","","\t\t// update api version","\t\tif newHPA.TypeMeta.APIVersion == \"\" {","\t\t\tnewHPA.TypeMeta.APIVersion = autoscalingv2.SchemeGroupVersion.String()","\t\t}","","\t\t// convert hpa to unstructured object","\t\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(\u0026newHPA)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tu := unstructured.Unstructured{}","\t\tu.SetUnstructuredContent(obj)","\t\tnewHPAs = append(newHPAs, u)","\t}","","\treturn newHPAs, nil","}","","func (ot *OptionsTransformer) updateWebhookConfiguration(u *unstructured.Unstructured) error {","\twebhookOptions, found := ot.options.WebhookConfigurationOptions[u.GetName()]","\tif !found {","\t\treturn nil","\t}","","\tswitch u.GetKind() {","\tcase KindValidatingWebhookConfiguration:","\t\ttargetWebhookConfiguration := \u0026admissionregistrationv1.ValidatingWebhookConfiguration{}","\t\terr := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetWebhookConfiguration)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tfor i, w := range targetWebhookConfiguration.Webhooks {","\t\t\tif u.GetName() == w.Name {","\t\t\t\tif webhookOptions.FailurePolicy != nil {","\t\t\t\t\ttargetWebhookConfiguration.Webhooks[i].FailurePolicy = webhookOptions.FailurePolicy","\t\t\t\t}","\t\t\t\tif webhookOptions.TimeoutSeconds != nil {","\t\t\t\t\ttargetWebhookConfiguration.Webhooks[i].TimeoutSeconds = webhookOptions.TimeoutSeconds","\t\t\t\t}","\t\t\t\tif webhookOptions.SideEffects != nil {","\t\t\t\t\ttargetWebhookConfiguration.Webhooks[i].SideEffects = webhookOptions.SideEffects","\t\t\t\t}","\t\t\t}","\t\t}","\t\t// convert webhookconfigurtion to unstructured object","\t\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetWebhookConfiguration)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(obj)","","\tcase KindMutatingWebhookConfiguration:","\t\ttargetWebhookConfiguration := \u0026admissionregistrationv1.MutatingWebhookConfiguration{}","\t\terr := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetWebhookConfiguration)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tfor i, w := range targetWebhookConfiguration.Webhooks {","\t\t\tif u.GetName() == w.Name {","\t\t\t\tif webhookOptions.FailurePolicy != nil {","\t\t\t\t\ttargetWebhookConfiguration.Webhooks[i].FailurePolicy = webhookOptions.FailurePolicy","\t\t\t\t}","\t\t\t\tif webhookOptions.TimeoutSeconds != nil {","\t\t\t\t\ttargetWebhookConfiguration.Webhooks[i].TimeoutSeconds = webhookOptions.TimeoutSeconds","\t\t\t\t}","\t\t\t\tif webhookOptions.SideEffects != nil {","\t\t\t\t\ttargetWebhookConfiguration.Webhooks[i].SideEffects = webhookOptions.SideEffects","\t\t\t\t}","\t\t\t}","\t\t}","\t\t// convert webhookconfigurtion to unstructured object","\t\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetWebhookConfiguration)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(obj)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,1,0,0,2,2,1,1,2,2,2,2,2,1,1,0,2,1,1,0,0,2,2,1,1,0,2,1,1,0,2,0,0,2,2,2,2,1,1,2,0,2,0,0,2,2,2,2,0,2,2,2,1,1,0,0,2,0,2,2,0,2,2,0,2,2,0,0,2,0,0,2,2,2,0,2,2,2,0,2,2,2,2,0,0,2,2,1,1,0,2,2,2,0,0,2,2,2,0,0,2,2,0,0,2,2,2,2,2,2,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,2,1,1,0,0,2,2,2,0,0,2,2,1,1,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,1,1,2,2,2,0,0,2,0,0,2,2,2,2,2,2,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,2,1,1,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,2,1,1,0,0,2,2,2,0,0,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,0,0,2,2,2,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,1,1,1,1,1,0,2,0,0,0,2,2,2,0,2,2,0,0,0,0,2,2,2,2,2,1,1,0,0,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,1,1,0,2,2,0,0,2,2,2,2,1,1,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,2,1,1,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,0,0,2,2,2,1,1,0,0,2,2,1,1,0,0,2,2,1,1,0,0,2,2,2,1,1,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,0,2,2,1,1,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,1,1,2,2,2,0,0,2,0,0,2,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,1,1,2,0,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,1,0,0,0,2,2,1,1,2,0,0,2,0]},{"id":68,"path":"pkg/reconciler/common/transformer_inject_envvar.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"os\"","","\tmf \"github.com/manifestival/manifestival\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"knative.dev/pkg/version\"",")","","func DeploymentEnvVarKubernetesMinVersion() mf.Transformer {","\tvar envVars []corev1.EnvVar","\tif minVersion, exists := os.LookupEnv(version.KubernetesMinVersionKey); exists {","\t\tenvVars = append(envVars, corev1.EnvVar{","\t\t\tName:  version.KubernetesMinVersionKey,","\t\t\tValue: minVersion,","\t\t})","\t}","\treturn deploymentEnvVars(envVars)","}","","func deploymentEnvVars(envVars []corev1.EnvVar) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\tif len(envVars) == 0 {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := d.Spec.Template.Spec.Containers","\t\tfor i := range containers {","\t\t\tfor _, newEnv := range envVars {","\t\t\t\tenvVarExists := false","","\t\t\t\tfor j := range containers[i].Env {","\t\t\t\t\tif containers[i].Env[j].Name == newEnv.Name {","\t\t\t\t\t\tcontainers[i].Env[j].Value = newEnv.Value","\t\t\t\t\t\tcontainers[i].Env[j].ValueFrom = newEnv.ValueFrom","\t\t\t\t\t\tenvVarExists = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif !envVarExists {","\t\t\t\t\tcontainers[i].Env = append(containers[i].Env, newEnv)","\t\t\t\t}","\t\t\t}","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,2,2,2,1,1,0,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,0,2,2,1,1,0,2,2,0,0]},{"id":69,"path":"pkg/reconciler/common/transformer_injectlabel.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/labels\"",")","","func InjectOperandNameLabelPreserveExisting(operandName string) mf.Transformer {","\tpreserveExisting := true","\treturn injectOperandNameLabel(operandName, preserveExisting)","}","","func InjectOperandNameLabelOverwriteExisting(operandName string) mf.Transformer {","\tpreserveExisting := false","\treturn injectOperandNameLabel(operandName, preserveExisting)","}","","func injectOperandNameLabel(operandName string, preserveExisting bool) mf.Transformer {","\tl := labels.Set{","\t\tv1alpha1.LabelOperandName: operandName,","\t}","","\tif preserveExisting {","\t\treturn InjectLabelPreserveExisting(l)","\t}","\treturn InjectLabelOverwriteExisting(l)","}","","func InjectLabelPreserveExisting(newLabels labels.Set, skipChecks ...mf.Predicate) mf.Transformer {","\tpreserverExisting := true","\treturn injectLabel(newLabels, preserverExisting, skipChecks...)","}","","func InjectLabelOverwriteExisting(newLabels labels.Set, skipChecks ...mf.Predicate) mf.Transformer {","\tpreserverExisting := false","\treturn injectLabel(newLabels, preserverExisting, skipChecks...)","}","","func injectLabel(newLabels labels.Set, preserverExisting bool, skipChecks ...mf.Predicate) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tfor _, skipCheck := range skipChecks {","\t\t\tif skipCheck(u) {","\t\t\t\treturn nil","\t\t\t}","\t\t}","\t\tresourceLabels := u.GetLabels()","\t\tif resourceLabels == nil {","\t\t\tresourceLabels = map[string]string{}","\t\t}","\t\tfor key, val := range newLabels {","\t\t\tif !replaceAllowed(preserverExisting, resourceLabels, key) {","\t\t\t\tcontinue","\t\t\t}","\t\t\tresourceLabels[key] = val","\t\t}","\t\tu.SetLabels(resourceLabels)","\t\treturn nil","\t}","}","","func replaceAllowed(preserveExisting bool, existingLabels map[string]string, key string) bool {","\tif !preserveExisting {","\t\treturn true","\t}","\t_, ok := existingLabels[key]","","\t// if key exists (ok = true) then donot allow replace, hence return false","\t// else if key not exists (ok = false) the allow replace, hence return true","\t// ie, return !ok","\treturn !ok","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,2,2,2,2,2,2,1,1,2,0,0,1,1,1,1,0,2,2,2,2,0,2,2,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0]},{"id":70,"path":"pkg/reconciler/common/transformers.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"reflect\"","\t\"sort\"","\t\"strconv\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"go.uber.org/zap\"","\t\"golang.org/x/exp/slices\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tbatchv1 \"k8s.io/api/batch/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\trbacv1 \"k8s.io/api/rbac/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\tapimachineryRuntime \"k8s.io/apimachinery/pkg/runtime\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"","\t\"sigs.k8s.io/yaml\"",")","","const (","\tAnnotationPreserveNS          = \"operator.tekton.dev/preserve-namespace\"","\tAnnotationPreserveRBSubjectNS = \"operator.tekton.dev/preserve-rb-subject-namespace\"","\tImageRegistryOverride         = \"TEKTON_REGISTRY_OVERRIDE\"","\tPipelinesImagePrefix          = \"IMAGE_PIPELINES_\"","\tTriggersImagePrefix           = \"IMAGE_TRIGGERS_\"","\tAddonsImagePrefix             = \"IMAGE_ADDONS_\"","\tPacImagePrefix                = \"IMAGE_PAC_\"","\tChainsImagePrefix             = \"IMAGE_CHAINS_\"","\tManualApprovalGatePrefix      = \"IMAGE_MAG_\"","\tPrunerImagePrefix             = \"IMAGE_PRUNER_\"","\tSchedulerImagePrefix          = \"IMAGE_SCHEDULER_\"","\tResultsImagePrefix            = \"IMAGE_RESULTS_\"","\tHubImagePrefix                = \"IMAGE_HUB_\"","\tDashboardImagePrefix          = \"IMAGE_DASHBOARD_\"","","\tDefaultTargetNamespace = \"tekton-pipelines\"","","\tArgPrefix   = \"arg_\"","\tParamPrefix = \"param_\"","","\trunAsNonRootValue              = true","\tallowPrivilegedEscalationValue = false","\tpipelinesControllerDeployment  = \"tekton-pipelines-controller\"",")","","// transformers that are common to all components.","func transformers(ctx context.Context, obj v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\tmf.InjectOwner(obj),","\t\tinjectNamespaceConditional(AnnotationPreserveNS, obj.GetSpec().GetTargetNamespace()),","\t\tinjectNamespaceCRDWebhookClientConfig(obj.GetSpec().GetTargetNamespace()),","\t\tinjectNamespaceCRClusterInterceptorClientConfig(obj.GetSpec().GetTargetNamespace()),","\t\tinjectNamespaceClusterRole(obj.GetSpec().GetTargetNamespace()),","\t\tReplaceNamespaceInWebhookNamespaceSelector(obj.GetSpec().GetTargetNamespace()),","\t\tAddDeploymentRestrictedPSA(),","\t}","}","","// TODO for now added here but planning to refactor so that we can avoid openshift specific changes as part of common","func roleBindingTransformers(ctx context.Context, obj v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\tmf.InjectOwner(obj),","\t\tinjectNamespaceRoleBindingConditional(AnnotationPreserveNS,","\t\t\tAnnotationPreserveRBSubjectNS, obj.GetSpec().GetTargetNamespace()),","\t}","}","","// Transform will mutate the passed-by-reference manifest with one","// transformed by platform, common, and any extra passed in","func Transform(ctx context.Context, manifest *mf.Manifest, instance v1alpha1.TektonComponent, extra ...mf.Transformer) error {","\tlogger := logging.FromContext(ctx)","\tlogger.Debug(\"Transforming manifest\")","","\troleBindingManifest := manifest.Filter(mf.Any(mf.ByKind(\"RoleBinding\")))","\tremainingManifest := manifest.Filter(mf.Not(mf.Any(mf.ByKind(\"RoleBinding\"))))","","\ttransformers := transformers(ctx, instance)","\ttransformers = append(transformers, extra...)","","\tt1 := roleBindingTransformers(ctx, instance)","","\tremainingManifest, err := remainingManifest.Transform(transformers...)","\tif err != nil {","\t\treturn err","\t}","\troleBindingManifest, err = roleBindingManifest.Transform(t1...)","\tif err != nil {","\t\treturn err","\t}","\t*manifest = remainingManifest.Append(roleBindingManifest)","\treturn nil","}","","func injectNamespaceConditional(preserveNamespace, targetNamespace string) mf.Transformer {","\ttf := mf.InjectNamespace(targetNamespace)","\treturn func(u *unstructured.Unstructured) error {","\t\tannotations := u.GetAnnotations()","\t\tval, ok := annotations[preserveNamespace]","\t\tif ok \u0026\u0026 val == \"true\" {","\t\t\treturn nil","\t\t}","\t\treturn tf(u)","\t}","}","","func injectNamespaceCRDWebhookClientConfig(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"customresourcedefinition\" {","\t\t\treturn nil","\t\t}","\t\tservice, found, err := unstructured.NestedFieldNoCopy(u.Object, \"spec\", \"conversion\", \"webhookClientConfig\", \"service\")","\t\tif !found || err != nil {","\t\t\treturn err","\t\t}","\t\tm := service.(map[string]interface{})","\t\tif _, ok := m[\"namespace\"]; ok {","\t\t\tm[\"namespace\"] = targetNamespace","\t\t}","\t\treturn nil","\t}","}","","func injectNamespaceCRClusterInterceptorClientConfig(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"clusterinterceptor\" {","\t\t\treturn nil","\t\t}","\t\tservice, found, err := unstructured.NestedFieldNoCopy(u.Object, \"spec\", \"clientConfig\", \"service\")","\t\tif !found || err != nil {","\t\t\treturn err","\t\t}","\t\tm := service.(map[string]interface{})","\t\tif _, ok := m[\"namespace\"]; ok {","\t\t\tm[\"namespace\"] = targetNamespace","\t\t}","\t\treturn nil","\t}","}","","// ImagesFromEnv will provide map of key value.","func ImagesFromEnv(prefix string) map[string]string {","\timages := map[string]string{}","\tfor _, env := range os.Environ() {","\t\tif !strings.HasPrefix(env, prefix) {","\t\t\tcontinue","\t\t}","","\t\tkeyValue := strings.Split(env, \"=\")","\t\tname := strings.TrimPrefix(keyValue[0], prefix)","\t\turl := keyValue[1]","\t\timages[name] = url","\t}","","\treturn images","}","","// ImageRegistryDomainOverride will add or override the registry used in the image list","func ImageRegistryDomainOverride(images map[string]string) map[string]string {","\tregistry := os.Getenv(ImageRegistryOverride)","\tif registry == \"\" {","\t\treturn images","\t} else {","\t\tfor key, imageName := range images {","\t\t\tparts := strings.Split(imageName, \"/\")","\t\t\tif len(parts) \u003e 1 {","\t\t\t\t// if image has registry part, replace it","\t\t\t\timages[key] = registry + \"/\" + strings.Join(parts[1:], \"/\")","\t\t\t} else {","\t\t\t\t// if image does not have registry part, add it","\t\t\t\timages[key] = registry + \"/\" + imageName","\t\t\t}","\t\t}","\t\treturn images","\t}","}","","// ToLowerCaseKeys converts key value to lower cases.","func ToLowerCaseKeys(keyValues map[string]string) map[string]string {","\tnewMap := map[string]string{}","","\tfor k, v := range keyValues {","\t\tkey := strings.ToLower(k)","\t\tnewMap[key] = v","\t}","","\treturn newMap","}","","// DeploymentImages replaces container and args images.","func DeploymentImages(images map[string]string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := d.Spec.Template.Spec.Containers","\t\treplaceContainerImages(containers, images)","\t\tinitContainers := d.Spec.Template.Spec.InitContainers","\t\treplaceContainerImages(initContainers, images)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// StatefulSetImages replaces container and args images.","func StatefulSetImages(images map[string]string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"StatefulSet\" {","\t\t\treturn nil","\t\t}","","\t\ts := \u0026appsv1.StatefulSet{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, s)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := s.Spec.Template.Spec.Containers","\t\treplaceContainerImages(containers, images)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(s)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// JobImages replaces container and args images.","func JobImages(images map[string]string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Job\" {","\t\t\treturn nil","\t\t}","","\t\tjb := \u0026batchv1.Job{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := jb.Spec.Template.Spec.Containers","\t\treplaceContainerImages(containers, images)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","func replaceContainerImages(containers []corev1.Container, images map[string]string) {","\tfor i, container := range containers {","\t\tname := formKey(\"\", container.Name)","\t\tif url, exist := images[name]; exist {","\t\t\tcontainers[i].Image = url","\t\t}","","\t\treplaceContainersArgsImage(\u0026container, images)","\t}","}","","func replaceContainersArgsImage(container *corev1.Container, images map[string]string) {","\tfor a, arg := range container.Args {","\t\tif argVal, hasArg := SplitsByEqual(arg); hasArg {","\t\t\targument := formKey(ArgPrefix, argVal[0])","\t\t\tif url, exist := images[argument]; exist {","\t\t\t\tcontainer.Args[a] = argVal[0] + \"=\" + url","\t\t\t}","\t\t\tcontinue","\t\t}","","\t\targument := formKey(ArgPrefix, arg)","\t\tif url, exist := images[argument]; exist {","\t\t\tcontainer.Args[a+1] = url","\t\t}","\t}","}","","func formKey(prefix, arg string) string {","\targument := strings.ToLower(arg)","\tif prefix != \"\" {","\t\targument = prefix + argument","\t}","\treturn strings.ReplaceAll(argument, \"-\", \"_\")","}","","func SplitsByEqual(arg string) ([]string, bool) {","\tvalues := strings.Split(arg, \"=\")","\tif len(values) == 2 {","\t\treturn values, true","\t}","","\treturn values, false","}","","// TaskImages replaces step and params images.","func TaskImages(ctx context.Context, images map[string]string) mf.Transformer {","\tlogger := logging.FromContext(ctx)","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ClusterTask\" \u0026\u0026 u.GetKind() != \"Task\" {","\t\t\treturn nil","\t\t}","","\t\tsteps, found, err := unstructured.NestedSlice(u.Object, \"spec\", \"steps\")","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif !found {","\t\t\treturn nil","\t\t}","\t\treplaceStepsImages(steps, images, logger)","\t\terr = unstructured.SetNestedField(u.Object, steps, \"spec\", \"steps\")","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tparams, found, err := unstructured.NestedSlice(u.Object, \"spec\", \"params\")","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif !found {","\t\t\treturn nil","\t\t}","\t\treplaceParamsImage(params, images, logger)","\t\treturn unstructured.SetNestedField(u.Object, params, \"spec\", \"params\")","\t}","}","","// StepActionImages replaces spec images.","func StepActionImages(ctx context.Context, images map[string]string) mf.Transformer {","\tlogger := logging.FromContext(ctx)","\treturn func(u *unstructured.Unstructured) error {","\t\tstepActionSpec, found, err := unstructured.NestedMap(u.Object, \"spec\")","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif !found {","\t\t\treturn nil","\t\t}","\t\treplaceStepActionImages(stepActionSpec, images, u.GetName(), logger)","\t\treturn unstructured.SetNestedMap(u.Object, stepActionSpec, \"spec\")","\t}","}","","func replaceStepActionImages(stepActionSpec map[string]interface{}, override map[string]string, name string, logger *zap.SugaredLogger) {","\tname = formKey(\"\", name)","\timage, found := override[name]","\tif !found || image == \"\" {","\t\tlogger.Debugf(\"Image not found in stepaction %s action skip\", name)","\t\treturn","\t}","\t// Replace the image in the stepActionSpec if the key exists.","\tif _, ok := stepActionSpec[\"image\"]; ok {","\t\tlogger.Debugf(\"replacing image with %s\", image)","\t\tstepActionSpec[\"image\"] = image","\t}","}","","func replaceStepsImages(steps []interface{}, override map[string]string, logger *zap.SugaredLogger) {","\tfor _, s := range steps {","\t\tstep := s.(map[string]interface{})","\t\tname, ok := step[\"name\"].(string)","\t\tif !ok {","\t\t\tlogger.Debugf(\"Unable to get the step %v step\", s)","\t\t\tcontinue","\t\t}","","\t\tname = formKey(\"\", name)","\t\timage, found := override[name]","\t\tif !found || image == \"\" {","\t\t\tlogger.Debugf(\"Image not found step %s action skip\", name)","\t\t\tcontinue","\t\t}","\t\tstep[\"image\"] = image","\t}","}","","func replaceParamsImage(params []interface{}, override map[string]string, logger *zap.SugaredLogger) {","\tfor _, p := range params {","\t\tparam := p.(map[string]interface{})","\t\tname, ok := param[\"name\"].(string)","\t\tif !ok {","\t\t\tlogger.Debugf(\"Unable to get the pram %v param\", p)","\t\t\tcontinue","\t\t}","","\t\tname = formKey(ParamPrefix, name)","\t\timage, found := override[name]","\t\tif !found || image == \"\" {","\t\t\tlogger.Debugf(\"Image not found step %s action skip\", name)","\t\t\tcontinue","\t\t}","\t\tparam[\"default\"] = image","\t}","}","","func injectNamespaceRoleBindingConditional(preserveNS, preserveRBSubjectNS, targetNamespace string) mf.Transformer {","\ttf := injectNamespaceRoleBindingSubjects(targetNamespace)","","\treturn func(u *unstructured.Unstructured) error {","\t\tannotations := u.GetAnnotations()","\t\tval, ok := annotations[preserveNS]","\t\tif !(ok \u0026\u0026 val == \"true\") {","\t\t\tu.SetNamespace(targetNamespace)","\t\t}","\t\tval, ok = annotations[preserveRBSubjectNS]","\t\tif ok \u0026\u0026 val == \"true\" {","\t\t\treturn nil","\t\t}","\t\treturn tf(u)","\t}","}","","func injectNamespaceRoleBindingSubjects(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"rolebinding\" {","\t\t\treturn nil","\t\t}","\t\tsubjects, found, err := unstructured.NestedFieldNoCopy(u.Object, \"subjects\")","\t\tif !found || err != nil {","\t\t\treturn err","\t\t}","\t\tfor _, subject := range subjects.([]interface{}) {","\t\t\tm := subject.(map[string]interface{})","\t\t\tif _, ok := m[\"namespace\"]; ok {","\t\t\t\tm[\"namespace\"] = targetNamespace","\t\t\t}","\t\t}","\t\treturn nil","\t}","}","","func injectNamespaceClusterRole(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif strings.ToLower(u.GetKind()) != \"clusterrole\" {","\t\t\treturn nil","\t\t}","\t\trules, found, err := unstructured.NestedFieldNoCopy(u.Object, \"rules\")","\t\tif !found || err != nil {","\t\t\treturn err","\t\t}","\t\tfor _, rule := range rules.([]interface{}) {","\t\t\tm := rule.(map[string]interface{})","\t\t\tresources, ok := m[\"resources\"]","\t\t\tif !ok || len(resources.([]interface{})) == 0 {","\t\t\t\tcontinue","\t\t\t}","\t\t\tcontainsNamespaceResource := false","\t\t\tfor _, resource := range resources.([]interface{}) {","\t\t\t\tif strings.HasPrefix(resource.(string), \"namespaces\") {","\t\t\t\t\tcontainsNamespaceResource = true","\t\t\t\t}","\t\t\t}","\t\t\tresourceNames, ok := m[\"resourceNames\"]","\t\t\tif containsNamespaceResource \u0026\u0026 ok {","\t\t\t\tnm := []interface{}{}","\t\t\t\tfor _, rn := range resourceNames.([]interface{}) {","\t\t\t\t\tif rn.(string) == DefaultTargetNamespace {","\t\t\t\t\t\tnm = append(nm, targetNamespace)","\t\t\t\t\t} else {","\t\t\t\t\t\tnm = append(nm, rn)","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tm[\"resourceNames\"] = nm","\t\t\t}","\t\t}","\t\treturn nil","\t}","}","","// ReplaceNamespaceInDeploymentEnv replaces any instance of the default namespace string in the given deployments' env var","func ReplaceNamespaceInDeploymentEnv(deploymentNames []string, targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" || !slices.Contains(deploymentNames, u.GetName()) {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainer := d.Spec.Template.Spec.Containers[0]","\t\td.Spec.Template.Spec.Containers[0].Env = replaceNamespaceInDBAddress(container.Env, targetNamespace)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","func replaceNamespaceInDBAddress(envs []corev1.EnvVar, targetNamespace string) []corev1.EnvVar {","\treq := []string{\"DB_ADDR\", \"TEKTON_RESULTS_API_SERVICE\"}","","\tfor i, e := range envs {","\t\tif slices.Contains(req, e.Name) {","\t\t\tenvs[i].Value = strings.ReplaceAll(e.Value, DefaultTargetNamespace, targetNamespace)","\t\t}","\t}","\treturn envs","}","","// ReplaceNamespaceInDeploymentArgs replaces any instance of the default namespace in the given deployments' args","func ReplaceNamespaceInDeploymentArgs(deploymentNames []string, targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" || !slices.Contains(deploymentNames, u.GetName()) {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainer := d.Spec.Template.Spec.Containers[0]","\t\treplaceNamespaceInContainerArg(\u0026container, targetNamespace)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","func replaceNamespaceInContainerArg(container *corev1.Container, targetNamespace string) {","\tfor i, a := range container.Args {","\t\tif strings.Contains(a, DefaultTargetNamespace) {","\t\t\tcontainer.Args[i] = strings.ReplaceAll(a, DefaultTargetNamespace, targetNamespace)","\t\t}","\t}","}","","// AddConfigMapValues will loop on the interface (should be a struct) and add the fields in to configMap","// the key will be the json tag of the struct field","func AddConfigMapValues(configMapName string, prop interface{}) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ConfigMap\" || u.GetName() != configMapName || prop == nil {","\t\t\treturn nil","\t\t}","","\t\tcm := \u0026corev1.ConfigMap{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif cm.Data == nil {","\t\t\tcm.Data = map[string]string{}","\t\t}","","\t\tvalues := reflect.ValueOf(prop)","\t\t// if the given properties is not struct type, do not proceed","\t\tif values.Kind() != reflect.Struct {","\t\t\treturn nil","\t\t}","","\t\tfor index := 0; index \u003c values.NumField(); index++ {","\t\t\tkey := values.Type().Field(index).Tag.Get(\"json\")","\t\t\tif strings.Contains(key, \",\") {","\t\t\t\tkey = strings.Split(key, \",\")[0]","\t\t\t}","","\t\t\tif key == \"\" {","\t\t\t\tcontinue","\t\t\t}","","\t\t\telement := values.Field(index)","\t\t\tif element.Kind() == reflect.Ptr {","\t\t\t\tif element.IsNil() {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\t// empty string value will not be included in the following switch statement","\t\t\t\t// however, *string pointer can have empty(\"\") string","\t\t\t\t// so copying the actual string value to the configMap, it can be a empty string too","\t\t\t\tif value, ok := element.Interface().(*string); ok {","\t\t\t\t\tif value != nil {","\t\t\t\t\t\tcm.Data[key] = *value","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t// extract the actual element from the pointer","\t\t\t\telement = values.Field(index).Elem()","\t\t\t}","","\t\t\tif !element.IsValid() {","\t\t\t\tcontinue","\t\t\t}","","\t\t\t_value := \"\"","\t\t\tswitch element.Kind() {","\t\t\tcase reflect.Bool:","\t\t\t\t_value = strconv.FormatBool(element.Bool())","","\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:","\t\t\t\t_value = strconv.FormatInt(element.Int(), 10)","","\t\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:","\t\t\t\t_value = strconv.FormatUint(element.Uint(), 10)","","\t\t\tcase reflect.Float32, reflect.Float64:","\t\t\t\t_value = strconv.FormatFloat(element.Float(), 'f', 6, 64)","","\t\t\tcase reflect.String:","\t\t\t\t_value = element.String()","","\t\t\tcase reflect.Struct:","\t\t\t\tout, err := yaml.Marshal(element.Interface())","\t\t\t\tif err != nil {","\t\t\t\t\treturn fmt.Errorf(\"failed to marshal struct field %s: %v\", key, err)","\t\t\t\t}","\t\t\t\t_value = string(out)","\t\t\t}","","\t\t\tif _value != \"\" {","\t\t\t\tcm.Data[key] = _value","\t\t\t}","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// InjectLabelOnNamespace will add a label on tekton-pipelines and","// openshift-pipelines namespace","func InjectLabelOnNamespace(label string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"namespace\" {","\t\t\treturn nil","\t\t}","","\t\tlabels := u.GetLabels()","\t\tarr := strings.Split(label, \"=\")","\t\tlabels[arr[0]] = arr[1]","\t\tu.SetLabels(labels)","","\t\treturn nil","\t}","}","","func AddConfiguration(config v1alpha1.Config) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\td.Spec.Template.Spec.NodeSelector = config.NodeSelector","\t\td.Spec.Template.Spec.Tolerations = config.Tolerations","\t\td.Spec.Template.Spec.PriorityClassName = config.PriorityClassName","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// AddDeploymentRestrictedPSA will add the default restricted spec on Deployment to remove errors/warning","func AddDeploymentRestrictedPSA() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif d.Spec.Template.Spec.SecurityContext == nil {","\t\t\td.Spec.Template.Spec.SecurityContext = \u0026corev1.PodSecurityContext{}","\t\t}","","\t\tif d.Spec.Template.Spec.SecurityContext.RunAsNonRoot == nil {","\t\t\td.Spec.Template.Spec.SecurityContext.RunAsNonRoot = ptr.Bool(runAsNonRootValue)","\t\t}","","\t\tif d.Spec.Template.Spec.SecurityContext.SeccompProfile == nil {","\t\t\td.Spec.Template.Spec.SecurityContext.SeccompProfile = \u0026corev1.SeccompProfile{","\t\t\t\tType: corev1.SeccompProfileTypeRuntimeDefault,","\t\t\t}","\t\t}","","\t\tfor i := range d.Spec.Template.Spec.Containers {","\t\t\tc := \u0026d.Spec.Template.Spec.Containers[i]","\t\t\tif c.SecurityContext == nil {","\t\t\t\tc.SecurityContext = \u0026corev1.SecurityContext{}","\t\t\t}","\t\t\tc.SecurityContext.AllowPrivilegeEscalation = ptr.Bool(allowPrivilegedEscalationValue)","\t\t\tc.SecurityContext.Capabilities = \u0026corev1.Capabilities{Drop: []corev1.Capability{\"ALL\"}}","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","// AddStatefulSetRestrictedPSA will add the default restricted spec on StatefulSet to remove errors/warning","func AddStatefulSetRestrictedPSA() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif strings.ToLower(u.GetKind()) != \"statefulset\" {","\t\t\treturn nil","\t\t}","","\t\ts := \u0026appsv1.StatefulSet{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, s)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif s.Spec.Template.Spec.SecurityContext == nil {","\t\t\ts.Spec.Template.Spec.SecurityContext = \u0026corev1.PodSecurityContext{}","\t\t}","","\t\tif s.Spec.Template.Spec.SecurityContext.RunAsNonRoot == nil {","\t\t\ts.Spec.Template.Spec.SecurityContext.RunAsNonRoot = ptr.Bool(runAsNonRootValue)","\t\t}","","\t\tif s.Spec.Template.Spec.SecurityContext.SeccompProfile == nil {","\t\t\ts.Spec.Template.Spec.SecurityContext.SeccompProfile = \u0026corev1.SeccompProfile{","\t\t\t\tType: corev1.SeccompProfileTypeRuntimeDefault,","\t\t\t}","\t\t}","","\t\tfor i := range s.Spec.Template.Spec.Containers {","\t\t\tc := \u0026s.Spec.Template.Spec.Containers[i]","\t\t\tif c.SecurityContext == nil {","\t\t\t\tc.SecurityContext = \u0026corev1.SecurityContext{}","\t\t\t}","\t\t\tc.SecurityContext.AllowPrivilegeEscalation = ptr.Bool(allowPrivilegedEscalationValue)","\t\t\tc.SecurityContext.Capabilities = \u0026corev1.Capabilities{Drop: []corev1.Capability{\"ALL\"}}","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(s)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","// AddJobRestrictedPSA will add the default restricted spec on Job to remove errors/warning","func AddJobRestrictedPSA() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Job\" {","\t\t\treturn nil","\t\t}","","\t\tjb := \u0026batchv1.Job{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif jb.Spec.Template.Spec.SecurityContext == nil {","\t\t\tjb.Spec.Template.Spec.SecurityContext = \u0026corev1.PodSecurityContext{}","\t\t}","","\t\tif jb.Spec.Template.Spec.SecurityContext.RunAsNonRoot == nil {","\t\t\tjb.Spec.Template.Spec.SecurityContext.RunAsNonRoot = ptr.Bool(runAsNonRootValue)","\t\t}","","\t\tif jb.Spec.Template.Spec.SecurityContext.SeccompProfile == nil {","\t\t\tjb.Spec.Template.Spec.SecurityContext.SeccompProfile = \u0026corev1.SeccompProfile{","\t\t\t\tType: corev1.SeccompProfileTypeRuntimeDefault,","\t\t\t}","\t\t}","","\t\tfor i := range jb.Spec.Template.Spec.Containers {","\t\t\tc := \u0026jb.Spec.Template.Spec.Containers[i]","\t\t\tif c.SecurityContext == nil {","\t\t\t\tc.SecurityContext = \u0026corev1.SecurityContext{}","\t\t\t}","\t\t\tif c.SecurityContext.AllowPrivilegeEscalation == nil {","\t\t\t\tc.SecurityContext.AllowPrivilegeEscalation = ptr.Bool(allowPrivilegedEscalationValue)","\t\t\t}","\t\t\tif c.SecurityContext.Capabilities == nil {","\t\t\t\tc.SecurityContext.Capabilities = \u0026corev1.Capabilities{Drop: []corev1.Capability{\"ALL\"}}","\t\t\t}","\t\t}","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","// CopyConfigMap will copy all the values from the passed configmap to the configmap","// in the manifest and any extra fields will be added in the manifest","func CopyConfigMap(configMapName string, expectedValues map[string]string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"configmap\" {","\t\t\treturn nil","\t\t}","\t\tif u.GetName() != configMapName || len(expectedValues) == 0 {","\t\t\treturn nil","\t\t}","","\t\tcm := \u0026corev1.ConfigMap{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif cm.Data == nil {","\t\t\tcm.Data = map[string]string{}","\t\t}","","\t\tfor key, value := range expectedValues {","\t\t\t// updates values , if the key is found,","\t\t\t// adds key and value, if the key is not found","\t\t\tcm.Data[key] = value","\t\t}","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","func ReplaceDeploymentArg(deploymentName, existingArg, newArg string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","\t\tif u.GetName() != deploymentName {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tfor i, arg := range d.Spec.Template.Spec.Containers[0].Args {","\t\t\tif arg == existingArg {","\t\t\t\td.Spec.Template.Spec.Containers[0].Args[i] = newArg","\t\t\t}","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","// replaces the namespace in serviceAccount","func ReplaceNamespaceInServiceAccount(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ServiceAccount\" {","\t\t\treturn nil","\t\t}","","\t\t// update namespace","\t\tu.SetNamespace(targetNamespace)","","\t\treturn nil","\t}","}","","// replaces the namespace in clusterRoleBinding","func ReplaceNamespaceInClusterRoleBinding(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ClusterRoleBinding\" {","\t\t\treturn nil","\t\t}","","\t\tcrb := \u0026rbacv1.ClusterRoleBinding{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, crb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// update namespace","\t\tfor index := range crb.Subjects {","\t\t\tcrb.Subjects[index].Namespace = targetNamespace","\t\t}","","\t\tobj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(crb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(obj)","\t\treturn nil","\t}","}","","// updates \"metadata.namespace\" and under \"spec\"","// TODO: we have different transformer for each kind","// TODO: replaces all the existing transformers(used to update namespace) with this.","func ReplaceNamespace(newNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\t// update metadata.namespace for all the resources","\t\t// this change will be updated in cluster wide resource too","\t\t// there is no effect on updating namespace on cluster wide resource","\t\tu.SetNamespace(newNamespace)","","\t\tswitch u.GetKind() {","\t\tcase \"ClusterRoleBinding\":","\t\t\tcrb := \u0026rbacv1.ClusterRoleBinding{}","\t\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, crb)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\t// update namespace","\t\t\tfor index := range crb.Subjects {","\t\t\t\tcrb.Subjects[index].Namespace = newNamespace","\t\t\t}","","\t\t\tobj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(crb)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tu.SetUnstructuredContent(obj)","\t\t}","","\t\treturn nil","\t}","}","","// AddSecretData adds the given data and annotations to the Secret object.","func AddSecretData(data map[string][]byte, annotations map[string]string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\t// If input data is empty, do not transform","\t\tif len(data) == 0 {","\t\t\treturn nil","\t\t}","","\t\t// Check if the resource is a Secret","\t\tif u.GetKind() != \"Secret\" {","\t\t\treturn nil","\t\t}","","\t\t// Convert unstructured to Secret","\t\tsecret := \u0026corev1.Secret{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, secret)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// Update the Secret's data only if it is nil or empty","\t\tif len(secret.Data) == 0 {","\t\t\tsecret.Data = data","\t\t}","","\t\t// Update the Secret's annotations","\t\tif secret.Annotations == nil {","\t\t\tsecret.Annotations = make(map[string]string)","\t\t}","\t\tfor key, value := range annotations {","\t\t\tsecret.Annotations[key] = value","\t\t}","","\t\t// Convert back to unstructured","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(secret)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// Update the original unstructured object","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// ConvertDeploymentToStatefulSet converts a Deployment to a StatefulSet with given parameters","func ConvertDeploymentToStatefulSet(controllerName, serviceName string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" || u.GetName() != controllerName {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tss := \u0026appsv1.StatefulSet{","\t\t\tTypeMeta: metav1.TypeMeta{","\t\t\t\tKind:       \"StatefulSet\",","\t\t\t\tAPIVersion: appsv1.SchemeGroupVersion.Group + \"/\" + appsv1.SchemeGroupVersion.Version,","\t\t\t},","\t\t\tObjectMeta: d.ObjectMeta,","\t\t\tSpec: appsv1.StatefulSetSpec{","\t\t\t\tSelector:    d.Spec.Selector,","\t\t\t\tServiceName: serviceName,","\t\t\t\tTemplate:    d.Spec.Template,","\t\t\t\tReplicas:    d.Spec.Replicas,","\t\t\t\tUpdateStrategy: appsv1.StatefulSetUpdateStrategy{","\t\t\t\t\tType: appsv1.RollingUpdateStatefulSetStrategyType,","\t\t\t\t},","\t\t\t},","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(ss)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// AddStatefulEnvVars adds environment variables to the statefulset based on given parameters","func AddStatefulEnvVars(controllerName, serviceName, statefulServiceEnvVar, controllerOrdinalEnvVar string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"StatefulSet\" || u.GetName() != controllerName {","\t\t\treturn nil","\t\t}","","\t\tss := \u0026appsv1.StatefulSet{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, ss)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tnewEnvVars := []corev1.EnvVar{","\t\t\t{","\t\t\t\tName:  statefulServiceEnvVar,","\t\t\t\tValue: serviceName,","\t\t\t},","\t\t\t{","\t\t\t\tName: controllerOrdinalEnvVar,","\t\t\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\t\t\tFieldRef: \u0026corev1.ObjectFieldSelector{","\t\t\t\t\t\tFieldPath: \"metadata.name\",","\t\t\t\t\t},","\t\t\t\t},","\t\t\t},","\t\t}","","\t\tif len(ss.Spec.Template.Spec.Containers) \u003e 0 {","\t\t\tss.Spec.Template.Spec.Containers[0].Env = append(ss.Spec.Template.Spec.Containers[0].Env, newEnvVars...)","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(ss)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// updates performance flags/args into deployment and container given as args","// and leader election config as pod labels into a Deployment, ensuring that any changes trigger a rollout.","// It also updates the replica count if specified in the performanceSpec.","func UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(performanceSpec *v1alpha1.PerformanceProperties, leaderConfig, deploymentName, containerName string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" || u.GetName() != deploymentName {","\t\t\treturn nil","\t\t}","","\t\t// holds the flags needs to be added in the container args section","\t\tflags := map[string]interface{}{}","","\t\t// convert struct to map with json tag","\t\t// so that, we can map the arguments as is","\t\tif err := StructToMap(\u0026performanceSpec.DeploymentPerformanceArgs, \u0026flags); err != nil {","\t\t\treturn err","\t\t}","","\t\t// if there is no flags to update, return from here","\t\tif len(flags) == 0 {","\t\t\treturn nil","\t\t}","","\t\t// convert unstructured object to deployment","\t\tdep := \u0026appsv1.Deployment{}","\t\terr := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// include config-leader-election data into deployment pod label","\t\t// so that pods will be recreated, if there is a change in \"buckets\"","\t\tleaderElectionConfigMapData := map[string]interface{}{}","\t\tif err = StructToMap(\u0026performanceSpec.PerformanceLeaderElectionConfig, \u0026leaderElectionConfigMapData); err != nil {","\t\t\treturn err","\t\t}","\t\tpodLabels := dep.Spec.Template.Labels","\t\tif podLabels == nil {","\t\t\tpodLabels = map[string]string{}","\t\t}","\t\t// sort data keys in an order, to get the consistent hash value in installerset","\t\tlabelKeys := getSortedKeys(leaderElectionConfigMapData)","\t\tfor _, key := range labelKeys {","\t\t\tvalue := leaderElectionConfigMapData[key]","\t\t\tlabelKey := fmt.Sprintf(\"%s.data.%s\", leaderConfig, key)","\t\t\tpodLabels[labelKey] = fmt.Sprintf(\"%v\", value)","\t\t}","\t\tdep.Spec.Template.Labels = podLabels","","\t\t// update replicas, if available","\t\tif performanceSpec.Replicas != nil {","\t\t\tdep.Spec.Replicas = ptr.Int32(*performanceSpec.Replicas)","\t\t}","","\t\t// include it in the pods label, that will recreate all the pods, if there is a change in replica count","\t\tif dep.Spec.Replicas != nil {","\t\t\tdep.Spec.Template.Labels[\"deployment.spec.replicas\"] = fmt.Sprintf(\"%d\", *dep.Spec.Replicas)","\t\t}","","\t\t// sort flag keys in an order, to get the consistent hash value in installerset","\t\tflagKeys := getSortedKeys(flags)","\t\t// update performance arguments into target container","\t\tfor containerIndex, container := range dep.Spec.Template.Spec.Containers {","\t\t\tif container.Name != containerName {","\t\t\t\tcontinue","\t\t\t}","\t\t\tfor _, flagKey := range flagKeys {","\t\t\t\t// update the arg name with \"-\" prefix","\t\t\t\texpectedArg := fmt.Sprintf(\"-%s\", flagKey)","\t\t\t\targStringValue := fmt.Sprintf(\"%v\", flags[flagKey])","","\t\t\t\t// skip deprecated disable-ha flag if not pipelinesControllerDeployment","\t\t\t\t// should be removed when the flag is removed from pipelines controller","\t\t\t\t// we can use this logic incase we need to skip it for other controllers as well here","\t\t\t\tif deploymentName != pipelinesControllerDeployment \u0026\u0026 flagKey == \"disable-ha\" {","\t\t\t\t\tcontinue","\t\t\t\t}","","\t\t\t\targUpdated := false","\t\t\t\tfor argIndex, existingArg := range container.Args {","\t\t\t\t\tif strings.HasPrefix(existingArg, expectedArg) {","\t\t\t\t\t\tcontainer.Args[argIndex] = fmt.Sprintf(\"%s=%s\", expectedArg, argStringValue)","\t\t\t\t\t\targUpdated = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif !argUpdated {","\t\t\t\t\tcontainer.Args = append(container.Args, fmt.Sprintf(\"%s=%s\", expectedArg, argStringValue))","\t\t\t\t}","\t\t\t}","\t\t\tdep.Spec.Template.Spec.Containers[containerIndex] = container","\t\t}","","\t\t// convert deployment to unstructured object","\t\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(obj)","","\t\treturn nil","\t}","}","","// sort keys in an order, to get the consistent hash value in installerset","func getSortedKeys(input map[string]interface{}) []string {","\tkeys := []string{}","\tfor key := range input {","\t\tkeys = append(keys, key)","\t}","\tsort.Strings(keys)","\treturn keys","}","","// replaces the namespace in ValidatingWebhookConfiguration namespaceSelector","func ReplaceNamespaceInWebhookNamespaceSelector(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif !strings.EqualFold(u.GetKind(), \"ValidatingWebhookConfiguration\") {","\t\t\treturn nil","\t\t}","\t\t// Accept either spec.webhooks (some older patterns) or top-level webhooks (current API structure).","\t\twebhooks, foundSpec, errSpec := unstructured.NestedSlice(u.Object, \"spec\", \"webhooks\")","\t\tpathIsSpec := true","\t\tif errSpec != nil || !foundSpec {","\t\t\t// Fallback to top-level","\t\t\twebhooksTop, foundTop, errTop := unstructured.NestedSlice(u.Object, \"webhooks\")","\t\t\tif errTop != nil || !foundTop {","\t\t\t\t// Nothing to transform","\t\t\t\treturn nil","\t\t\t}","\t\t\twebhooks = webhooksTop","\t\t\tpathIsSpec = false","\t\t}","\t\tchanged := false","\t\tfor i := range webhooks {","\t\t\twh, ok := webhooks[i].(map[string]interface{})","\t\t\tif !ok {","\t\t\t\tcontinue","\t\t\t}","\t\t\tnsSel, okNs := wh[\"namespaceSelector\"].(map[string]interface{})","\t\t\tif !okNs {","\t\t\t\tcontinue","\t\t\t}","\t\t\tmatchExprs, okExpr := nsSel[\"matchExpressions\"].([]interface{})","\t\t\tif !okExpr {","\t\t\t\tcontinue","\t\t\t}","\t\t\tfor j := range matchExprs {","\t\t\t\texpr, ok := matchExprs[j].(map[string]interface{})","\t\t\t\tif !ok {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tvalues, okVals := expr[\"values\"].([]interface{})","\t\t\t\tif !okVals || len(values) == 0 {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tfor k := range values {","\t\t\t\t\tvalStr, ok := values[k].(string)","\t\t\t\t\tif !ok || targetNamespace == \"\" {","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\tif strings.Contains(valStr, DefaultTargetNamespace) {","\t\t\t\t\t\tnewVal := strings.ReplaceAll(valStr, DefaultTargetNamespace, targetNamespace)","\t\t\t\t\t\tif newVal != valStr {","\t\t\t\t\t\t\tvalues[k] = newVal","\t\t\t\t\t\t\tchanged = true","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\texpr[\"values\"] = values","\t\t\t\tmatchExprs[j] = expr","\t\t\t}","\t\t\tnsSel[\"matchExpressions\"] = matchExprs","\t\t\twh[\"namespaceSelector\"] = nsSel","\t\t\twebhooks[i] = wh","\t\t}","\t\tif changed {","\t\t\tif pathIsSpec {","\t\t\t\t_ = unstructured.SetNestedSlice(u.Object, webhooks, \"spec\", \"webhooks\")","\t\t\t} else {","\t\t\t\t// Top-level assignment","\t\t\t\tu.Object[\"webhooks\"] = webhooks","\t\t\t}","\t\t}","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,2,2,0,0,2,2,2,2,2,2,1,1,2,0,0,0,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,0,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,2,0,0,0,0,2,2,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,0,2,2,2,1,1,0,2,2,2,2,2,2,2,1,1,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,1,1,2,0,0,2,2,1,1,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,0,0,0,2,2,2,2,1,1,0,2,2,1,1,2,1,1,2,2,2,1,1,0,2,2,1,1,2,1,1,2,2,0,0,0,0,2,2,2,2,2,1,1,2,1,1,2,2,0,0,0,2,2,2,2,1,1,1,0,2,2,2,2,0,0,2,2,2,2,2,1,1,0,0,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,1,1,0,0,2,2,2,2,2,0,2,0,0,0,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,2,2,2,2,2,2,2,1,1,2,2,2,2,1,0,2,2,2,2,2,0,2,2,2,2,2,2,2,1,1,0,2,0,0,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,0,0,0,2,2,2,2,2,2,2,0,2,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,0,0,0,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,0,2,2,2,1,1,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,0,2,2,0,0,2,2,2,2,0,0,0,0,2,2,2,2,0,0,2,0,0,2,1,0,0,2,2,2,2,0,2,2,0,2,2,0,2,2,0,2,2,0,2,2,2,1,1,2,0,0,2,2,2,0,0,2,2,1,1,0,2,2,2,0,0,0,0,0,2,2,2,2,1,1,0,2,2,2,2,2,2,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,2,1,1,2,2,2,0,0,0,0,2,2,2,2,2,0,2,2,2,1,1,0,2,2,2,0,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,2,2,1,1,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,0,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,2,2,1,1,2,2,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,0,2,1,1,0,2,2,2,2,2,2,2,1,1,0,2,2,0,0,0,2,2,2,1,1,2,1,1,0,2,2,2,1,1,0,2,2,2,2,0,0,2,2,1,1,2,2,0,0,0,0,2,2,2,1,1,0,0,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,2,0,2,2,1,1,2,2,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,0,2,2,1,1,2,0,0,2,0,0,0,0,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,1,1,0,0,2,2,2,0,0,2,2,2,2,2,2,0,0,2,2,1,1,0,0,2,2,2,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,0,0,2,2,2,1,1,0,0,2,2,2,2,2,1,1,0,0,2,1,1,0,0,2,2,2,1,1,0,0,0,2,2,1,1,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,1,0,0,2,2,2,2,2,2,0,0,2,2,2,0,2,0,0,0,2,2,1,1,2,2,2,0,0,0,0,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,1,1,1,2,2,0,2,2,2,2,1,0,2,2,1,0,2,2,1,0,2,2,2,1,0,2,2,1,0,2,2,2,1,0,2,2,2,2,2,2,0,0,2,2,0,2,2,2,0,2,2,1,2,2,2,2,0,2,0,0]},{"id":71,"path":"pkg/reconciler/common/unstructured.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"",")","","// namespacedResource is an unstructured resource with the given apiVersion, kind, ns and name.","func namespacedResource(apiVersion, kind, ns, name string) unstructured.Unstructured {","\tresource := unstructured.Unstructured{}","\tresource.SetAPIVersion(apiVersion)","\tresource.SetKind(kind)","\tresource.SetNamespace(ns)","\tresource.SetName(name)","\treturn resource","}","","// clusterScopedResource is an unstructured resource with the given apiVersion, kind and name.","func clusterScopedResource(apiVersion, kind, name string) unstructured.Unstructured {","\treturn namespacedResource(apiVersion, kind, \"\", name)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2]},{"id":72,"path":"pkg/reconciler/common/utils.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"encoding/json\"","\t\"fmt\"","\t\"slices\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"",")","","type VersionError error","","var (","\terrConfigMap VersionError = fmt.Errorf(\"version information could not be determined from ConfigMap\")",")","","func IsFetchVersionError(err error) bool {","\treturn err == errConfigMap","}","","// FetchVersionFromConfigMap finds the component version from the ConfigMap data field. It looks","// for the version key in the ConfigMap and if the ConfigMap or version key is not found","// then return the error.","func FetchVersionFromConfigMap(manifest mf.Manifest, configMapName string) (string, error) {","\tconfigMaps := manifest.Filter(mf.ByKind(\"ConfigMap\"), mf.ByName(configMapName))","","\tif len(configMaps.Resources()) == 0 {","\t\treturn \"\", errConfigMap","\t}","","\tversionConfigMap := configMaps.Resources()[0]","\tdataObj, _, _ := unstructured.NestedStringMap(versionConfigMap.Object, \"data\")","\tversion := dataObj[\"version\"]","","\tif version != \"\" {","\t\treturn version, nil","\t}","","\treturn \"\", errConfigMap","}","","// converts struct to map with json encoding","func StructToMap(in, out interface{}) error {","\tdata, err := json.Marshal(in)","\tif err != nil {","\t\treturn err","\t}","\treturn json.Unmarshal(data, out)","}","","// Helper function to serialize labels map to JSON string","func SerializeLabelsToJSON(labels map[string]string) (string, error) {","\tbytes, err := json.Marshal(labels)","\tif err != nil {","\t\treturn \"\", fmt.Errorf(\"failed to serialize labels to JSON: %v\", err)","\t}","\treturn string(bytes), nil","}","","// AddOrReplaceInList appends newItem to the provided list. If the new item exists in the list then the original","// copy of the item is removed from the list before the new copy is appended. The identityFunc parameter is used","// to uniquely identify an item during comparison.","func AddOrReplaceInList[T any, V comparable](items []T, newItem T, identityFunc func(T) V) []T {","\tnewItemIdentity := identityFunc(newItem)","\tfor i, item := range items {","\t\titemIdentity := identityFunc(item)","\t\tif itemIdentity == newItemIdentity {","\t\t\titems = slices.Delete(items, i, i+1)","\t\t\tbreak","\t\t}","\t}","\treturn append(items, newItem)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,0,0,0,2,2,2,1,1,2,0,0,0,2,2,2,1,1,2,0,0,0,0,0,2,2,2,2,2,2,2,0,0,2,0]},{"id":73,"path":"pkg/reconciler/kubernetes/kubernetesplatform/kubernetesplatform.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package kubernetesplatform","","import (","\t\"github.com/tektoncd/operator/pkg/reconciler/platform\"",")","","// KubernetesPlatform defines basic configuration for a Vanila Kubernetes platform","type KubernetesPlatform struct {","\tplatform.PlatformConfig","\tsupportedControllers platform.ControllerMap","}","","// NewKubernetesPlatform returns an instance of KubernetesPlatform","func NewKubernetesPlatform(pc platform.PlatformConfig) *KubernetesPlatform {","\tplt := KubernetesPlatform{","\t\tsupportedControllers: kubernetesControllers,","\t}","\tplt.PlatformConfig = pc","\tplt.PlatformConfig.Name = PlatformNameKubernetes","\treturn \u0026plt","}","","// AllSupportedControllers returns a platform.ControllerMap of all controllers (reconcilers) of tektoncd/operator","// supported by Vanila Kubernetes","func (kp *KubernetesPlatform) AllSupportedControllers() platform.ControllerMap {","\treturn kp.supportedControllers","}","","// PlatformParams return platform.PlatformConfig of a KubernetesPlatform","func (kp *KubernetesPlatform) PlatformParams() platform.PlatformConfig {","\treturn kp.PlatformConfig","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1]},{"id":74,"path":"pkg/reconciler/kubernetes/manualapprovalgate/controller.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package manualapprovalgate","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\tmanualapprovalgateinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/manualapprovalgate\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\tmanualapprovalgatereconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/manualapprovalgate\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = \"manual-approval-gate-info\"","","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, w configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","","\t\tmanifest, ver := ctrl.InitController(ctx, common.PayloadOptions{})","\t\tif ver == common.ReleaseVersionUnknown {","\t\t\tver = \"devel\"","\t\t}","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\tmetrics, _ := NewRecorder()","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","","\t\tc := \u0026Reconciler{","\t\t\toperatorClientSet:         operatorclient.Get(ctx),","\t\t\tkubeClientSet:             kubeclient.Get(ctx),","\t\t\textension:                 generator(ctx),","\t\t\tmanifest:                  manifest,","\t\t\tinstallerSetClient:        client.NewInstallerSetClient(tisClient, operatorVer, ver, v1alpha1.KindManualApprovalGate, metrics),","\t\t\tpipelineInformer:          tektonPipelineinformer.Get(ctx),","\t\t\toperatorVersion:           operatorVer,","\t\t\tmanualApprovalGateVersion: ver,","\t\t}","\t\timpl := manualapprovalgatereconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for ManualApprovalGate\")","","\t\tif _, err := manualapprovalgateinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register ManualApprovalGate informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.ManualApprovalGate{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":75,"path":"pkg/reconciler/kubernetes/manualapprovalgate/finalize.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package manualapprovalgate","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tmanualapprovalgatereconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/manualapprovalgate\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","var _ manualapprovalgatereconciler.Finalizer = (*Reconciler)(nil)","","// FinalizeKind removes all resources after deletion of a ManualApprovalGate CR.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.ManualApprovalGate) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\t//Delete CRDs before deleting rest of resources so that any instance","\t//of CRDs which has finalizer set will get deleted before we remove","\t//the controller;s deployment for it","\tif err := r.manifest.Filter(mf.CRDs).Delete(); err != nil {","\t\tlogger.Error(\"Failed to deleted CRDs for ManualApprovalGate\")","\t\treturn err","\t}","","\tif err := r.installerSetClient.CleanupMainSet(ctx); err != nil {","\t\tlogger.Error(\"failed to cleanup main installerset: \", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0]},{"id":76,"path":"pkg/reconciler/kubernetes/manualapprovalgate/metrics.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package manualapprovalgate","","import \"go.uber.org/zap\"","","type Recorder struct {","}","","func NewRecorder() (*Recorder, error) {","\treturn \u0026Recorder{}, nil","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\t// TODO","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0]},{"id":77,"path":"pkg/reconciler/kubernetes/manualapprovalgate/reconcile.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package manualapprovalgate","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tpipelineinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\tmanualapprovalgatereconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/manualapprovalgate\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","type Reconciler struct {","\t// kube client to interact with core k8s resources","\tkubeClientSet kubernetes.Interface","\t// operatorClientSet allows us to configure operator objects","\toperatorClientSet clientset.Interface","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// manifest has the source manifest of ManualApprovalGate for a","\t// particular version","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","\t// manualApprovalGateVersion describes the current manualapprovalgate version","\tmanualApprovalGateVersion string","\toperatorVersion           string","\t// pipelineInformer provides access to a shared informer and lister for","\t// TektonPipelines","\tpipelineInformer pipelineinformer.TektonPipelineInformer","}","","// Check that our Reconciler implements controller.Reconciler","var _ manualapprovalgatereconciler.Interface = (*Reconciler)(nil)","","func (r *Reconciler) ReconcileKind(ctx context.Context, mag *v1alpha1.ManualApprovalGate) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"manualapprovalgate\", mag.GetName())","","\tlogger.Debugw(\"Starting ManualApprovalGate reconciliation\",","\t\t\"version\", r.manualApprovalGateVersion,","\t\t\"status\", mag.Status.GetCondition(apis.ConditionReady))","","\tmag.Status.InitializeConditions()","\tmag.Status.SetVersion(r.manualApprovalGateVersion)","","\tif mag.GetName() != v1alpha1.ManualApprovalGates {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.ManualApprovalGates,","\t\t\tmag.GetName(),","\t\t)","\t\tlogger.Errorw(\"Invalid resource name\", \"expectedName\", v1alpha1.ManualApprovalGates, \"actualName\", mag.GetName())","\t\tmag.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// reconcile target namespace","\tlogger.Debug(\"Reconciling target namespace\")","\tif err := common.ReconcileTargetNamespace(ctx, nil, nil, mag, r.kubeClientSet); err != nil {","\t\tlogger.Errorw(\"Failed to reconcile target namespace\", \"error\", err)","\t\treturn err","\t}","\tlogger.Info(\"Target namespace reconciled successfully\")","","\t//Make sure TektonPipeline is installed before proceeding with","\t//ManualApprovalGate","\tlogger.Debug(\"Checking Tekton Pipeline dependency\")","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\tlogger.Infow(\"Tekton Pipeline dependency not ready yet\", \"error\", err)","\t\t\tmag.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\t// (tektonpipeline.operator.tekton.dev instance not available yet)","\t\tlogger.Errorw(\"Tekton Pipeline dependency missing\", \"error\", err)","\t\tmag.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","\tlogger.Info(\"All dependencies installed successfully\")","\tmag.Status.MarkDependenciesInstalled()","","\tlogger.Debug(\"Removing obsolete installer sets\")","\tif err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {","\t\tlogger.Errorw(\"Failed to remove obsolete installer sets\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"Obsolete installer sets removed\")","","\tlogger.Debug(\"Executing pre-reconciliation\")","\tif err := r.extension.PreReconcile(ctx, mag); err != nil {","\t\tmsg := fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Pre-reconciliation failed\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Info(\"Pre-reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmag.Status.MarkPreReconcilerFailed(msg)","\t\treturn nil","\t}","","\tlogger.Info(\"Pre-reconciliation completed successfully\")","\tmag.Status.MarkPreReconcilerComplete()","","\tif err := r.installerSetClient.MainSet(ctx, mag, \u0026r.manifest, filterAndTransform(r.extension)); err != nil {","\t\tmsg := fmt.Sprintf(\"Main Reconcilation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Failed to apply main installer set\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Info(\"Main reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmag.Status.MarkInstallerSetNotReady(msg)","\t\treturn nil","\t}","\tlogger.Info(\"Main manifest applied successfully\")","","\tlogger.Debug(\"Executing post-reconciliation\")","\tif err := r.extension.PostReconcile(ctx, mag); err != nil {","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Post-reconciliation failed\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Info(\"Post-reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmag.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PostReconcile Complete","\tlogger.Info(\"Post-reconciliation completed successfully\")","\tmag.Status.MarkPostReconcilerComplete()","","\tlogger.Info(\"ManualApprovalGate reconciliation completed successfully\")","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0]},{"id":78,"path":"pkg/reconciler/kubernetes/manualapprovalgate/transform.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package manualapprovalgate","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tmagCR := comp.(*v1alpha1.ManualApprovalGate)","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ManualApprovalGatePrefix))","\t\tmagImages := common.ImageRegistryDomainOverride(imagesRaw)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.ManualApprovalGates),","\t\t\tcommon.DeploymentImages(magImages),","\t\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\t\tcommon.AddDeploymentRestrictedPSA(),","\t\t}","\t\textra = append(extra, extension.Transformers(magCR)...)","\t\terr := common.Transform(ctx, manifest, magCR, extra...)","\t\tif err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, magCR.Spec.GetTargetNamespace(), magCR.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0]},{"id":79,"path":"pkg/reconciler/kubernetes/tektonchain/controller.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonchain","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonChaininformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonchain\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\ttektonChainreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonchain\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/tools/cache\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","// chains-info stores the version of Chains installed in the cluster","const versionConfigMap = \"chains-info\"","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","","\t\tmanifest, chainVer := ctrl.InitController(ctx, common.PayloadOptions{})","\t\tif chainVer == common.ReleaseVersionUnknown {","\t\t\tchainVer = \"devel\"","\t\t}","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","","\t\tmetrics, err := NewRecorder()","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\tc := \u0026Reconciler{","\t\t\toperatorClientSet:  operatorclient.Get(ctx),","\t\t\tinstallerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, chainVer, v1alpha1.KindTektonChain, metrics),","\t\t\textension:          generator(ctx),","\t\t\tmanifest:           manifest,","\t\t\tpipelineInformer:   tektonPipelineinformer.Get(ctx),","\t\t\toperatorVersion:    operatorVer,","\t\t\tchainVersion:       chainVer,","\t\t\trecorder:           metrics,","\t\t}","\t\timpl := tektonChainreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for Tekton Chain\")","","\t\tif _, err := tektonChaininformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonChain informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonChain{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":80,"path":"pkg/reconciler/kubernetes/tektonchain/installerset.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonchain","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","func (r *Reconciler) createSecretInstallerSet(ctx context.Context, tc *v1alpha1.TektonChain) (*v1alpha1.TektonInstallerSet, error) {","","\tmanifest := r.manifest","\t// filter only secret for this installerset as this needs","\t// to be restored over upgrade","\tmanifest = manifest.Filter(mf.ByKind(\"Secret\"))","\ttransformer := filterAndTransform(r.extension)","\tif _, err := transformer(ctx, \u0026manifest, tc); err != nil {","\t\ttc.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\treturn nil, err","\t}","","\t// generate installer set","\ttis := makeInstallerSet(tc, manifest, secretChainInstallerset, \"\", r.operatorVersion)","","\t// Add annoation to secret installer set in case the generate secret signing is set to true","\tif tc.Spec.GenerateSigningSecret {","\t\ttis.Annotations[secretTISSigningAnnotation] = \"true\"","\t}","","\t// create installer set","\tcreatedIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, tis, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn createdIs, nil","}","","func (r *Reconciler) createConfigInstallerSet(ctx context.Context, tc *v1alpha1.TektonChain) (*v1alpha1.TektonInstallerSet, error) {","\tmanifest := r.manifest","","\t// remove secret from this installerset as this installerset will be deleted on upgrade","\tmanifest = manifest.Filter(mf.ByKind(\"ConfigMap\"), mf.ByName(\"chains-config\"))","\ttransformer := filterAndTransform(r.extension)","\tif _, err := transformer(ctx, \u0026manifest, tc); err != nil {","\t\ttc.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\treturn nil, err","\t}","","\t// generate installer set","\ttis := makeInstallerSet(tc, manifest, configChainInstallerset, \"\", r.operatorVersion)","","\t// compute the hash of tektonchain spec and store as an annotation","\t// in further reconciliation we compute hash of tc spec and check with","\t// annotation, if they are same then we skip updating the object","\t// otherwise we update the manifest","\tspecHash, err := hash.Compute(tc.Spec)","\tif err != nil {","\t\treturn nil, err","\t}","\ttis.Annotations[v1alpha1.LastAppliedHashKey] = specHash","","\t// create installer set","\tcreatedIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, tis, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn createdIs, nil","","}","","func (r *Reconciler) createInstallerSet(ctx context.Context, tc *v1alpha1.TektonChain) (*v1alpha1.TektonInstallerSet, error) {","","\tmanifest := r.manifest","\t// installerSet adds it's owner as namespace's owner","\t// so deleting tekton chain deletes target namespace too","\t// to skip it we filter out namespace if pipeline have same namespace","\tpipelineNamespace, err := common.PipelineTargetNamspace(r.pipelineInformer)","\tif err != nil {","\t\treturn nil, err","\t}","\tif tc.Spec.GetTargetNamespace() == pipelineNamespace {","\t\tmanifest = manifest.Filter(mf.Not(mf.ByKind(\"Namespace\")))","\t}","","\t// remove secret and `chains-config` configMap from this installerset as this installerset will be deleted on upgrade","\tmanifest = manifest.Filter(mf.Not(mf.ByKind(\"Secret\")),","\t\tmf.Not(mf.All(mf.ByName(\"chains-config\"), mf.ByKind(\"ConfigMap\"))))","","\ttransformer := filterAndTransform(r.extension)","\tif _, err = transformer(ctx, \u0026manifest, tc); err != nil {","\t\ttc.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\treturn nil, err","\t}","","\t// set installerSet installType: deployment or statefulset","\tinstallerSetInstallType := client.InstallerSubTypeDeployment","\tif tc.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *tc.Spec.Performance.StatefulsetOrdinals {","\t\tinstallerSetInstallType = client.InstallerSubTypeStatefulset","\t}","\t// generate installer set","\ttis := makeInstallerSet(tc, manifest, v1alpha1.ChainResourceName, installerSetInstallType, r.operatorVersion)","","\t// compute the hash of tektonchain spec and store as an annotation","\t// in further reconciliation we compute hash of tc spec and check with","\t// annotation, if they are same then we skip updating the object","\t// otherwise we update the manifest","\tspecHash, err := hash.Compute(tc.Spec)","\tif err != nil {","\t\treturn nil, err","\t}","\ttis.Annotations[v1alpha1.LastAppliedHashKey] = specHash","","\t// create installer set","\tcreatedIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, tis, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn createdIs, nil","}","","func makeInstallerSet(tc *v1alpha1.TektonChain, manifest mf.Manifest, installerSetType, installerSetInstallType, releaseVersion string) *v1alpha1.TektonInstallerSet {","\townerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())","\tlabels := map[string]string{","\t\tv1alpha1.CreatedByKey:      createdByValue,","\t\tv1alpha1.ReleaseVersionKey: releaseVersion,","\t\tv1alpha1.InstallerSetType:  installerSetType,","\t}","","\tif installerSetInstallType != \"\" {","\t\tlabels[v1alpha1.InstallerSetInstallType] = installerSetInstallType","\t}","\treturn \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: fmt.Sprintf(\"%s-\", installerSetType),","\t\t\tLabels:       labels,","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":81,"path":"pkg/reconciler/kubernetes/tektonchain/metrics.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonchain","","import (","\t\"context\"","\t\"fmt\"","\t\"time\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"go.opencensus.io/stats\"","\t\"go.opencensus.io/stats/view\"","\t\"go.opencensus.io/tag\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/metrics\"",")","","var (","\trReconcileCount = stats.Float64(\"chains_reconciled\",","\t\t\"metrics of chains reconciled with labels\",","\t\tstats.UnitDimensionless)",")","","// Recorder holds keys for Tekton metrics","type Recorder struct {","\tinitialized        bool","\tversion            tag.Key","\ttaskrunFormat      tag.Key","\ttaskrunStorage     tag.Key","\ttaskrunSigner      tag.Key","\tpipelinerunFormat  tag.Key","\tpipelinerunStorage tag.Key","\tpipelinerunSigner  tag.Key","\tociFormat          tag.Key","\tociStorage         tag.Key","\tociSigner          tag.Key","","\tReportingPeriod time.Duration","}","","// NewRecorder creates a new metrics recorder instance","// to log the PipelineRun related metrics","func NewRecorder() (*Recorder, error) {","\tr := \u0026Recorder{","\t\tinitialized: true,","","\t\t// Default to 30s intervals.","\t\tReportingPeriod: 30 * time.Second,","\t}","","\tversion, err := tag.NewKey(\"version\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.version = version","","\ttaskrunFormat, err := tag.NewKey(\"taskrun_format\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.taskrunFormat = taskrunFormat","","\ttaskrunStorage, err := tag.NewKey(\"taskrun_storage\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.taskrunStorage = taskrunStorage","","\ttaskrunSigner, err := tag.NewKey(\"taskrun_signer\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.taskrunSigner = taskrunSigner","","\tpipelinerunFormat, err := tag.NewKey(\"pipelinerun_format\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.pipelinerunFormat = pipelinerunFormat","","\tpipelinerunStorage, err := tag.NewKey(\"pipelinerun_storage\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.pipelinerunStorage = pipelinerunStorage","","\tpipelinerunSigner, err := tag.NewKey(\"pipelinerun_signer\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.pipelinerunSigner = pipelinerunSigner","","\tociFormat, err := tag.NewKey(\"oci_format\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.ociFormat = ociFormat","","\tociStorage, err := tag.NewKey(\"oci_storage\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.ociStorage = ociStorage","","\tociSigner, err := tag.NewKey(\"oci_signer\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.ociSigner = ociSigner","","\terr = view.Register(","\t\t\u0026view.View{","\t\t\tDescription: rReconcileCount.Description(),","\t\t\tMeasure:     rReconcileCount,","\t\t\tAggregation: view.Count(),","\t\t\tTagKeys: []tag.Key{r.version,","\t\t\t\tr.taskrunFormat, r.taskrunStorage, r.taskrunSigner,","\t\t\t\tr.pipelinerunFormat, r.pipelinerunStorage, r.pipelinerunSigner,","\t\t\t\tr.ociFormat, r.ociStorage, r.ociSigner},","\t\t},","\t)","","\tif err != nil {","\t\tr.initialized = false","\t\treturn r, err","\t}","","\treturn r, nil","}","","// Logs when chains is reconciled with version and","// config labels.","func (r *Recorder) Count(version string, spec v1alpha1.TektonChainSpec) error {","\tif !r.initialized {","\t\treturn fmt.Errorf(","\t\t\t\"ignoring the metrics recording for pipelinee failed to initialize the metrics recorder\")","\t}","","\tvar taskrunStorage, pipelinerunStorage, ociStorage string","\tif spec.ArtifactsTaskRunStorage != nil {","\t\ttaskrunStorage = *spec.ArtifactsTaskRunStorage","\t}","\tif spec.ArtifactsPipelineRunStorage != nil {","\t\tpipelinerunStorage = *spec.ArtifactsPipelineRunStorage","\t}","\tif spec.ArtifactsOCIStorage != nil {","\t\tociStorage = *spec.ArtifactsOCIStorage","\t}","","\tctx, err := tag.New(","\t\tcontext.Background(),","\t\ttag.Insert(r.version, version),","\t\ttag.Insert(r.taskrunFormat, spec.ArtifactsTaskRunFormat),","\t\ttag.Insert(r.taskrunStorage, taskrunStorage),","\t\ttag.Insert(r.taskrunSigner, spec.ArtifactsTaskRunSigner),","\t\ttag.Insert(r.pipelinerunFormat, spec.ArtifactsPipelineRunFormat),","\t\ttag.Insert(r.pipelinerunStorage, pipelinerunStorage),","\t\ttag.Insert(r.pipelinerunSigner, spec.ArtifactsPipelineRunSigner),","\t\ttag.Insert(r.ociFormat, spec.ArtifactsOCIFormat),","\t\ttag.Insert(r.ociStorage, ociStorage),","\t\ttag.Insert(r.ociSigner, spec.ArtifactsOCISigner),","\t)","","\tif err != nil {","\t\treturn err","\t}","","\tmetrics.Record(ctx, rReconcileCount.M(1))","\treturn nil","}","","func (m *Recorder) LogMetricsWithSpec(version string, spec v1alpha1.TektonChainSpec, logger *zap.SugaredLogger) {","\terr := m.Count(version, spec)","\tif err != nil {","\t\tlogger.Warnf(\"%v: Failed to log the metrics : %v\", v1alpha1.KindTektonResult, err)","\t}","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\tvar newSpec v1alpha1.TektonChainSpec","\terr := m.Count(status, newSpec)","\tif err != nil {","\t\tlogger.Warnf(\"%v: Failed to log the metrics : %v\", resourceKind, err)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0]},{"id":82,"path":"pkg/reconciler/kubernetes/tektonchain/tektonchain.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonchain","","import (","\t\"context\"","\t\"crypto/rand\"","\t\"encoding/base64\"","\t\"fmt\"","\t\"strconv\"","","\t\"github.com/sigstore/cosign/v2/pkg/cosign\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tpipelineinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\ttektonchainreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonchain\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const (","\tresourceKind = v1alpha1.KindTektonChain","","\t// Chains ConfigMap","\tChainsConfig = \"chains-config\"","\t// Chains Container Name","\tchainsContainerName = \"tekton-chains-controller\"","\t// Deployment Name","\tchainsDeploymentName = \"tekton-chains-controller\"","","\t// secret installer set additional Annotation","\tsecretTISSigningAnnotation = \"operator.tekton.dev/generated-signing-secret\"","","\t// The number of random bytes we'll generate (before encoding) for the Cosign passphrase.","\tdefaultCosignPasswordLength = 16",")","","// Reconciler implements controller.Reconciler for TektonChain resources.","type Reconciler struct {","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","","\t// operatorClientSet allows us to configure operator objects","\toperatorClientSet clientset.Interface","\t// manifest has the source manifest of Tekton Triggers for a","\t// particular version","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","\t// chainVersion describes the current chain version","\tchainVersion    string","\toperatorVersion string","\t// pipelineInformer provides access to a shared informer and lister for","\t// TektonPipelines","\tpipelineInformer pipelineinformer.TektonPipelineInformer","\t// Metrics Recorder","\trecorder *Recorder","}","","// Check that our Reconciler implements controller.Reconciler","var _ tektonchainreconciler.Interface = (*Reconciler)(nil)","var _ tektonchainreconciler.Finalizer = (*Reconciler)(nil)","","const (","\tcreatedByValue          = \"TektonChain\"","\tsecretChainInstallerset = \"chain-secret\"","\tconfigChainInstallerset = \"chain-config\"",")","","var (","\tls = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     createdByValue,","\t\t\tv1alpha1.InstallerSetType: v1alpha1.ChainResourceName,","\t\t},","\t}","\tsecretLs = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     createdByValue,","\t\t\tv1alpha1.InstallerSetType: secretChainInstallerset,","\t\t},","\t}","\tconfigLs = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     createdByValue,","\t\t\tv1alpha1.InstallerSetType: configChainInstallerset,","\t\t},","\t}",")","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, tc *v1alpha1.TektonChain) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(","\t\t\"name\", tc.GetName(),","\t\t\"generation\", tc.Generation,","\t\t\"namespace\", tc.GetNamespace(),","\t)","\tdefer r.recorder.LogMetricsWithSpec(r.chainVersion, tc.Spec, logger)","","\ttc.Status.InitializeConditions()","\ttc.Status.ObservedGeneration = tc.Generation","","\tlogger.Debugw(\"Starting TektonChain reconciliation\", \"status\", tc.Status.GetCondition(apis.ConditionReady))","","\tif tc.GetName() != v1alpha1.ChainResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.ChainResourceName,","\t\t\ttc.GetName(),","\t\t)","\t\tlogger.Errorw(\"Invalid resource name\", \"expectedName\", v1alpha1.ConfigResourceName, \"actualName\", tc.GetName())","\t\ttc.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// find a valid TektonPipeline installation","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\ttc.Status.MarkDependencyInstalling(\"TektonPipeline is still installing\")","\t\t\tlogger.Debug(\"Waiting for TektonPipeline installation\")","\t\t\treturn fmt.Errorf(common.PipelineNotReady)","\t\t}","\t\t// tektonpipeline.operator.tekton.dev instance not available yet","\t\ttc.Status.MarkDependencyMissing(\"TektonPipeline does not exist\")","\t\tlogger.Errorw(\"TektonPipeline dependency check failed\", \"error\", err)","\t\treturn err","\t}","\ttc.Status.MarkDependenciesInstalled()","\tlogger.Debug(\"TektonPipeline dependency check completed successfully\")","","\t// Pass the object through defaulting","\ttc.SetDefaults(ctx)","","\t// Mark TektonChain Instance as Not Ready if an upgrade is needed","\tif err := r.markUpgrade(ctx, tc); err != nil {","\t\tlogger.Errorw(\"Upgrade check failed\", \"error\", err)","\t\treturn err","\t}","","\tif err := r.extension.PreReconcile(ctx, tc); err != nil {","\t\terrMsg := fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"PreReconcile failed\", \"error\", err)","\t\ttc.Status.MarkPreReconcilerFailed(errMsg)","\t\treturn err","\t}","","\t// Mark PreReconcile Complete","\ttc.Status.MarkPreReconcilerComplete()","\tlogger.Debug(\"PreReconcile completed successfully\")","","\t// Fetching and deleting the chains tektoninstallerset to delete `chains-config` configMap","\t// to handle the scenario when user upgrades i.e. in previous version `chains-config` configMap","\t// installerset was not there and with latest version we create separate installerset for","\t// `chains-config` configMap","\tchainlabelSelector, err := common.LabelSelector(ls)","\tif err != nil {","\t\tlogger.Errorw(\"Invalid chain label selector\", \"error\", err)","\t\treturn err","\t}","","\texistingChainInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, chainlabelSelector)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to retrieve current chain installer set\", \"error\", err)","\t\treturn err","\t}","","\tif existingChainInstallerSet != \"\" {","\t\t// If exists, then fetch the Tekton Chain InstallerSet","\t\tinstalledTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, existingChainInstallerSet, metav1.GetOptions{})","\t\tif err != nil \u0026\u0026 apierrors.IsNotFound(err) {","\t\t\tlogger.Errorw(\"Chain InstallerSet not found\", \"name\", existingChainInstallerSet)","\t\t\treturn err","\t\t}","","\t\tif rv := installedTIS.Labels[v1alpha1.ReleaseVersionKey]; rv != r.operatorVersion {","\t\t\tlogger.Infow(\"Deleting outdated InstallerSet\", \"name\", existingChainInstallerSet, \"currentVersion\", rv, \"expectedVersion\", r.operatorVersion)","\t\t\terr := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tDelete(ctx, existingChainInstallerSet, metav1.DeleteOptions{})","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to delete outdated InstallerSet\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\tif _, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, existingChainInstallerSet, metav1.GetOptions{}); err == nil {","\t\t\t\ttc.Status.MarkNotReady(\"Waiting for previous installer set to get deleted\")","\t\t\t\tlogger.Debugw(\"InstallerSet deletion pending\", \"name\", existingChainInstallerSet)","\t\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t\t} else if !apierrors.IsNotFound(err) {","\t\t\t\tlogger.Errorw(\"Error confirming InstallerSet deletion\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tlogger.Infow(\"Outdated InstallerSet successfully deleted\")","\t\t\treturn nil","\t\t}","\t}","","\t// Check if a Tekton Chain Config InstallerSet already exists, if not then create one","\tconfigLabelSector, err := common.LabelSelector(configLs)","\tif err != nil {","\t\tlogger.Errorw(\"Invalid chain config label selector\", \"error\", err)","\t\treturn err","\t}","","\texistingConfigInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, configLabelSector)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to get config installer set name\", \"error\", err, \"selector\", configLabelSector)","\t\treturn err","\t}","\tif existingConfigInstallerSet == \"\" {","\t\ttc.Status.MarkInstallerSetNotAvailable(\"Chain Config InstallerSet not available\")","\t\tlogger.Infow(\"Creating new Chain Config InstallerSet\", \"targetNamespace\", tc.Spec.TargetNamespace)","","\t\tcreatedIs, err := r.createConfigInstallerSet(ctx, tc)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to create Config InstallerSet\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\treturn r.updateTektonChainStatus(tc, createdIs)","\t}","","\t// If exists, then fetch the Tekton Chain Config InstallerSet","\tinstalledConfigTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tGet(ctx, existingConfigInstallerSet, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\tlogger.Infow(\"Config InstallerSet not found, creating new one\", \"name\", existingConfigInstallerSet)","\t\t\tcreatedIs, err := r.createConfigInstallerSet(ctx, tc)","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to create Config InstallerSet\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tlogger.Infow(\"Chain Config InstallerSet created successfully\", \"name\", createdIs.GetName())","\t\t\treturn r.updateTektonChainStatus(tc, createdIs)","\t\t}","\t\tlogger.Errorw(\"Failed to get Config InstallerSet\", \"name\", existingConfigInstallerSet, \"error\", err)","\t\treturn err","\t}","","\tconfigInstallerSetTargetNamespace := installedConfigTIS.Annotations[v1alpha1.TargetNamespaceKey]","\tconfigInstallerSetReleaseVersion := installedConfigTIS.Labels[v1alpha1.ReleaseVersionKey]","","\t// Check if TargetNamespace of existing Tekton Chain Config InstallerSet is same as expected","\t// Check if Release Version in Tekton Chain Config InstallerSet is same as expected","\t// If any of the above things is not same then delete the existing Tekton Chain InstallerSet","\t// and create a new with expected properties","","\tif configInstallerSetTargetNamespace != tc.Spec.TargetNamespace || configInstallerSetReleaseVersion != r.operatorVersion {","\t\tlogger.Infow(\"Config InstallerSet needs update\",","\t\t\t\"name\", existingConfigInstallerSet,","\t\t\t\"currentNamespace\", configInstallerSetTargetNamespace,","\t\t\t\"expectedNamespace\", tc.Spec.TargetNamespace,","\t\t\t\"currentVersion\", configInstallerSetReleaseVersion,","\t\t\t\"expectedVersion\", r.operatorVersion)","\t\t// Delete the existing Tekton Chain InstallerSet","\t\terr := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tDelete(ctx, existingConfigInstallerSet, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to delete Chains Config InstallerSet\", \"name\", existingConfigInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// Make sure the Tekton Chain Config InstallerSet is deleted","\t\t_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, existingConfigInstallerSet, metav1.GetOptions{})","\t\tif err == nil {","\t\t\ttc.Status.MarkNotReady(\"Waiting for previous installer set to get deleted\")","\t\t\tlogger.Debugw(\"Config InstallerSet deletion pending\", \"name\", existingConfigInstallerSet)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tif !apierrors.IsNotFound(err) {","\t\t\tlogger.Errorw(\"Failed to confirm Config InstallerSet deletion\", \"name\", existingConfigInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","\t\treturn nil","","\t} else {","\t\t// If target namespace and version are not changed then check if Chain","\t\t// spec is changed by checking hash stored as annotation on","\t\t// Tekton Chain InstallerSet with computing new hash of TektonChain Spec","","\t\t// Hash of TektonChain Spec","\t\texpectedSpecHash, err := hash.Compute(tc.Spec)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to compute spec hash\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// spec hash stored on installerSet","\t\tlastAppliedHash := installedConfigTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]","","\t\tif lastAppliedHash != expectedSpecHash {","\t\t\tlogger.Infow(\"Config spec changed, updating InstallerSet\",","\t\t\t\t\"name\", installedConfigTIS.Name,","\t\t\t\t\"oldHash\", lastAppliedHash,","\t\t\t\t\"newHash\", expectedSpecHash)","\t\t\tif err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tDelete(ctx, installedConfigTIS.Name, metav1.DeleteOptions{}); err != nil {","\t\t\t\tlogger.Errorw(\"Failed to delete outdated Config InstallerSet\", \"name\", installedConfigTIS.Name, \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// after updating installer set enqueue after a duration","\t\t\t// to allow changes to get deployed","\t\t\tlogger.Infow(\"Config InstallerSet deleted to apply spec changes\", \"name\", installedConfigTIS.Name)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debugw(\"Config InstallerSet up to date\", \"name\", installedConfigTIS.Name)","\t}","","\t// Chain controller is deployed as statefulset, ensure deployment installerset is deleted","\tif tc.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *tc.Spec.Performance.StatefulsetOrdinals {","\t\tif err := r.installerSetClient.CleanupWithLabelInstallTypeDeployment(ctx, v1alpha1.ChainResourceName); err != nil {","\t\t\tlogger.Errorw(\"Failed to delete chain deployment installer set\", \"error\", err, \"resource\", v1alpha1.ChainResourceName)","\t\t\treturn err","\t\t}","\t\tlogger.Debugw(\"Using statefulset deployment type\", \"resource\", v1alpha1.ChainResourceName)","\t} else {","\t\t// Chain controller is deployed as deployment, ensure statefulset installerset is deleted","\t\tif err := r.installerSetClient.CleanupWithLabelInstallTypeStatefulset(ctx, v1alpha1.ChainResourceName); err != nil {","\t\t\tlogger.Errorw(\"Failed to delete chain statefulset installer set\", \"error\", err, \"resource\", v1alpha1.ChainResourceName)","\t\t\treturn err","\t\t}","\t\tlogger.Debugw(\"Using standard deployment type\", \"resource\", v1alpha1.ChainResourceName)","\t}","","\t// Check if a Tekton Chain InstallerSet already exists, if not then create one","\tlabelSelector, err := common.LabelSelector(ls)","\tif err != nil {","\t\tlogger.Errorw(\"Invalid label selector\", \"error\", err, \"selector\", ls)","\t\treturn err","\t}","\texistingInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to get current installer set name\", \"error\", err, \"selector\", labelSelector)","\t\treturn err","\t}","","\tif existingInstallerSet == \"\" {","\t\ttc.Status.MarkInstallerSetNotAvailable(\"Chain InstallerSet not available\")","\t\tlogger.Infow(\"Creating new Chain InstallerSet\", \"targetNamespace\", tc.Spec.TargetNamespace)","","\t\tcreatedIs, err := r.createInstallerSet(ctx, tc)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to create InstallerSet\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Chain InstallerSet created successfully\", \"name\", createdIs.GetName())","\t\treturn r.updateTektonChainStatus(tc, createdIs)","\t}","","\t// If exists, then fetch the Tekton Chain InstallerSet","\tinstalledTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tGet(ctx, existingInstallerSet, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\tlogger.Infow(\"InstallerSet not found, creating new one\", \"name\", existingInstallerSet)","\t\t\tcreatedIs, err := r.createInstallerSet(ctx, tc)","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to create InstallerSet\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tlogger.Infow(\"Chain InstallerSet created successfully\", \"name\", createdIs.GetName())","\t\t\treturn r.updateTektonChainStatus(tc, createdIs)","\t\t}","\t\tlogger.Errorw(\"Failed to get InstallerSet\", \"name\", existingInstallerSet, \"error\", err)","\t\treturn err","\t}","","\tinstallerSetTargetNamespace := installedTIS.Annotations[v1alpha1.TargetNamespaceKey]","\tinstallerSetReleaseVersion := installedTIS.Labels[v1alpha1.ReleaseVersionKey]","","\t// Check if TargetNamespace of existing Tekton Chain InstallerSet is same as expected","\t// Check if Release Version in Tekton Chain InstallerSet is same as expected","\t// If any of the above things is not same then delete the existing Tekton Chain InstallerSet","\t// and create a new with expected properties","","\tif installerSetTargetNamespace != tc.Spec.TargetNamespace || installerSetReleaseVersion != r.operatorVersion {","\t\tlogger.Infow(\"InstallerSet needs update\",","\t\t\t\"name\", existingInstallerSet,","\t\t\t\"currentNamespace\", installerSetTargetNamespace,","\t\t\t\"expectedNamespace\", tc.Spec.TargetNamespace,","\t\t\t\"currentVersion\", installerSetReleaseVersion,","\t\t\t\"expectedVersion\", r.operatorVersion)","\t\t// Delete the existing Tekton Chain InstallerSet","\t\terr := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tDelete(ctx, existingInstallerSet, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to delete InstallerSet\", \"name\", existingInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// Make sure the Tekton Chain InstallerSet is deleted","\t\t_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, existingInstallerSet, metav1.GetOptions{})","\t\tif err == nil {","\t\t\ttc.Status.MarkNotReady(\"Waiting for previous installer set to get deleted\")","\t\t\tlogger.Debugw(\"InstallerSet deletion pending\", \"name\", existingInstallerSet)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tif !apierrors.IsNotFound(err) {","\t\t\tlogger.Errorw(\"Failed to confirm InstallerSet deletion\", \"name\", existingInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"InstallerSet successfully deleted\", \"name\", existingInstallerSet)","\t\treturn nil","","\t} else {","\t\t// If target namespace and version are not changed then check if Chain","\t\t// spec is changed by checking hash stored as annotation on","\t\t// Tekton Chain InstallerSet with computing new hash of TektonChain Spec","","\t\t// Hash of TektonChain Spec","\t\texpectedSpecHash, err := hash.Compute(tc.Spec)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to compute spec hash\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// spec hash stored on installerSet","\t\tlastAppliedHash := installedTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]","","\t\tif lastAppliedHash != expectedSpecHash {","\t\t\tlogger.Infow(\"Spec changed, updating InstallerSet\",","\t\t\t\t\"name\", installedTIS.Name,","\t\t\t\t\"oldHash\", lastAppliedHash,","\t\t\t\t\"newHash\", expectedSpecHash)","\t\t\tmanifest := r.manifest","\t\t\t// installerSet adds it's owner as namespace's owner","\t\t\t// so deleting tekton chain deletes target namespace too","\t\t\t// to skip it we filter out namespace if pipeline have same namespace","\t\t\tpipelineNamespace, err := common.PipelineTargetNamspace(r.pipelineInformer)","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to fetch pipeline namespace\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tif tc.Spec.GetTargetNamespace() == pipelineNamespace {","\t\t\t\tlogger.Debugw(\"Filtering out namespace resource as it's shared with pipeline\",","\t\t\t\t\t\"namespace\", pipelineNamespace)","\t\t\t\tmanifest = manifest.Filter(mf.Not(mf.ByKind(\"Namespace\")))","\t\t\t}","\t\t\t// remove secret and `chains-config` configMap from this installerset as this installerset will be deleted on upgrade","\t\t\tmanifest = manifest.Filter(mf.Not(mf.ByKind(\"Secret\")),","\t\t\t\tmf.Not(mf.All(mf.ByName(\"chains-config\"), mf.ByKind(\"ConfigMap\"))))","","\t\t\ttransformer := filterAndTransform(r.extension)","\t\t\tif _, err := transformer(ctx, \u0026manifest, tc); err != nil {","\t\t\t\tlogger.Errorw(\"Manifest transformation failed\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// Update the spec hash","\t\t\tcurrent := installedTIS.GetAnnotations()","\t\t\tcurrent[v1alpha1.LastAppliedHashKey] = expectedSpecHash","\t\t\tinstalledTIS.SetAnnotations(current)","","\t\t\t// Update the manifests","\t\t\tinstalledTIS.Spec.Manifests = manifest.Resources()","","\t\t\tif _, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tUpdate(ctx, installedTIS, metav1.UpdateOptions{}); err != nil {","\t\t\t\tlogger.Errorw(\"Failed to update InstallerSet\", \"name\", installedTIS.Name, \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// after updating installer set enqueue after a duration","\t\t\t// to allow changes to get deployed","\t\t\tlogger.Infow(\"InstallerSet successfully updated\", \"name\", installedTIS.Name)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debugw(\"InstallerSet up to date\", \"name\", installedTIS.Name)","\t}","","\t// Check if a Tekton Chain Secret InstallerSet already exists, if not then create one","\tsecretLabelSelector, err := common.LabelSelector(secretLs)","\tif err != nil {","\t\tlogger.Errorw(\"Invalid secret label selector\", \"error\", err, \"selector\", secretLs)","\t\treturn err","\t}","\texistingSecretInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, secretLabelSelector)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to get secret installer set name\", \"error\", err, \"selector\", secretLabelSelector)","\t\treturn err","\t}","\tif existingSecretInstallerSet == \"\" {","\t\ttc.Status.MarkInstallerSetNotAvailable(\"Chain Secret InstallerSet not available\")","\t\tlogger.Infow(\"Creating new Chain Secret InstallerSet\", \"targetNamespace\", tc.Spec.TargetNamespace)","\t\tcreatedIs, err := r.createSecretInstallerSet(ctx, tc)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to create Secret InstallerSet\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Chain Secret InstallerSet created successfully\", \"name\", createdIs.GetName())","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\t// If exists, then fetch the Tekton Chain Secret InstallerSet","\tinstalledSecretTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tGet(ctx, existingSecretInstallerSet, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\tlogger.Infow(\"Secret InstallerSet not found, creating new one\", \"name\", existingSecretInstallerSet)","\t\t\tcreatedIs, err := r.createSecretInstallerSet(ctx, tc)","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to create Secret InstallerSet\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tlogger.Infow(\"Chain Secret InstallerSet created successfully\", \"name\", createdIs.GetName())","\t\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t\t}","\t\tlogger.Errorw(\"Failed to get Secret InstallerSet\", \"name\", existingSecretInstallerSet, \"error\", err)","\t\treturn err","\t}","","\t// if the namespace or generatedSigningSecret has been changed for chainsCR, then delete the Tekton Chain Secret Installerset","\tsecretInstallerSetTargetNamespace := installedSecretTIS.Annotations[v1alpha1.TargetNamespaceKey]","\tif secretInstallerSetTargetNamespace != tc.Spec.TargetNamespace {","\t\tlogger.Infow(\"Secret InstallerSet namespace changed, recreating\",","\t\t\t\"name\", existingSecretInstallerSet,","\t\t\t\"currentNamespace\", secretInstallerSetTargetNamespace,","\t\t\t\"expectedNamespace\", tc.Spec.TargetNamespace)","\t\t// Delete the existing Tekton Chain Secret InstallerSet","\t\terr := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tDelete(ctx, existingSecretInstallerSet, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to delete Secret InstallerSet\", \"name\", existingSecretInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// Make sure the Tekton Chain Secret InstallerSet is deleted","\t\t_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, existingSecretInstallerSet, metav1.GetOptions{})","\t\tif err == nil {","\t\t\ttc.Status.MarkNotReady(\"Waiting for previous installer set to get deleted\")","\t\t\tlogger.Debugw(\"Secret InstallerSet deletion pending\", \"name\", existingSecretInstallerSet)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tif !apierrors.IsNotFound(err) {","\t\t\tlogger.Errorw(\"Failed to confirm Secret InstallerSet deletion\", \"name\", existingSecretInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Secret InstallerSet successfully deleted\", \"name\", existingSecretInstallerSet)","\t\treturn nil","\t}","","\t// if generatedSigningSecret has been changed for chainsCR, then update the Tekton Chain Secret InstallerSet","\tsecretInstallerSetSigningKey, err := strconv.ParseBool(installedSecretTIS.Annotations[secretTISSigningAnnotation])","\tif err != nil {","\t\tsecretInstallerSetSigningKey = false","\t\tlogger.Debugw(\"Failed to parse signing key annotation, defaulting to false\",","\t\t\t\"annotation\", secretTISSigningAnnotation,","\t\t\t\"error\", err)","\t}","\tif secretInstallerSetSigningKey != tc.Spec.GenerateSigningSecret {","\t\tlogger.Infow(\"Signing key configuration changed, updating Secret InstallerSet\",","\t\t\t\"name\", existingSecretInstallerSet,","\t\t\t\"currentValue\", secretInstallerSetSigningKey,","\t\t\t\"newValue\", tc.Spec.GenerateSigningSecret)","\t\tmanifest := r.manifest.Filter(mf.ByKind(\"Secret\"))","\t\ttransformer := filterAndTransform(r.extension)","\t\tif _, err := transformer(ctx, \u0026manifest, tc); err != nil {","\t\t\ttc.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\t\tlogger.Errorw(\"Secret manifest transformation failed\", \"error\", err)","\t\t\treturn err","\t\t}","\t\t// update the installer set annotation","\t\tinstalledSecretTIS.Annotations[secretTISSigningAnnotation] = strconv.FormatBool(tc.Spec.GenerateSigningSecret)","","\t\t// Update the manifests","\t\tinstalledSecretTIS.Spec.Manifests = manifest.Resources()","","\t\tif _, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tUpdate(ctx, installedSecretTIS, metav1.UpdateOptions{}); err != nil {","\t\t\tlogger.Errorw(\"Failed to update Secret InstallerSet\", \"name\", installedSecretTIS.Name, \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Secret InstallerSet successfully updated\", \"name\", installedSecretTIS.Name)","\t}","","\t// Mark InstallerSetAvailable","\ttc.Status.MarkInstallerSetAvailable()","","\tready := installedTIS.Status.GetCondition(apis.ConditionReady)","\tif ready == nil {","\t\ttc.Status.MarkInstallerSetNotReady(\"Waiting for installation\")","\t\tlogger.Debugw(\"InstallerSet status is Unknown\", \"name\", installedTIS.Name)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\tif ready.Status == corev1.ConditionUnknown {","\t\ttc.Status.MarkInstallerSetNotReady(\"Waiting for installation\")","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t} else if ready.Status == corev1.ConditionFalse {","\t\ttc.Status.MarkInstallerSetNotReady(ready.Message)","\t\tlogger.Infow(\"InstallerSet not ready\", \"name\", installedTIS.Name, \"message\", ready.Message)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\t// Mark InstallerSet Ready","\ttc.Status.MarkInstallerSetReady()","\tlogger.Infow(\"InstallerSet not ready\", \"name\", installedTIS.Name, \"message\", ready.Message)","","\tif err := r.extension.PostReconcile(ctx, tc); err != nil {","\t\terrMsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\ttc.Status.MarkPostReconcilerFailed(errMsg)","\t\tlogger.Errorw(\"PostReconcile failed\", \"error\", err, \"component\", \"extension\")","\t\treturn err","\t}","","\t// Mark PostReconcile Complete","\ttc.Status.MarkPostReconcilerComplete()","\tlogger.Debug(\"PostReconcile completed successfully\")","","\t// Update the object for any spec changes","\tif _, err := r.operatorClientSet.OperatorV1alpha1().TektonChains().Update(ctx, tc, metav1.UpdateOptions{}); err != nil {","\t\tlogger.Errorw(\"Failed to update TektonChain status\", \"error\", err)","\t\treturn err","\t}","","\treturn nil","}","","// FinalizeKind removes all resources after deletion of a TektonChain.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonChain) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\t// Delete CRDs before deleting rest of resources so that any instance","\t// of CRDs which has finalizer set will get deleted before we remove","\t// the controller's deployment for it","\tif err := r.manifest.Filter(mf.CRDs).Delete(); err != nil {","\t\tlogger.Error(\"Failed to deleted CRDs for TektonChain\")","\t\treturn err","\t}","","\tlabelSelector, err := common.LabelSelector(ls)","\tif err != nil {","\t\treturn err","\t}","\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tDeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{","\t\t\tLabelSelector: labelSelector,","\t\t}); err != nil {","\t\tlogger.Error(\"Failed to delete installer set created by TektonChain\", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","","\treturn nil","}","","func (r *Reconciler) updateTektonChainStatus(tc *v1alpha1.TektonChain, createdIs *v1alpha1.TektonInstallerSet) error {","\t// update the tc with TektonInstallerSet and releaseVersion","\ttc.Status.SetTektonInstallerSet(createdIs.Name)","\ttc.Status.SetVersion(r.chainVersion)","","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}","","func (r *Reconciler) markUpgrade(ctx context.Context, tc *v1alpha1.TektonChain) error {","\tlabels := tc.GetLabels()","\tver, ok := labels[v1alpha1.ReleaseVersionKey]","\tif ok \u0026\u0026 ver == r.operatorVersion {","\t\treturn nil","\t}","\tif ok \u0026\u0026 ver != r.operatorVersion {","\t\ttc.Status.MarkInstallerSetNotReady(v1alpha1.UpgradePending)","\t\ttc.Status.MarkPreReconcilerFailed(v1alpha1.UpgradePending)","\t\ttc.Status.MarkPostReconcilerFailed(v1alpha1.UpgradePending)","\t\ttc.Status.MarkNotReady(v1alpha1.UpgradePending)","\t}","\tif labels == nil {","\t\tlabels = map[string]string{}","\t}","\tlabels[v1alpha1.ReleaseVersionKey] = r.operatorVersion","\ttc.SetLabels(labels)","","\tif _, err := r.operatorClientSet.OperatorV1alpha1().TektonChains().Update(ctx,","\t\ttc, metav1.UpdateOptions{}); err != nil {","\t\treturn err","\t}","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}","","func AddControllerEnv(controllerEnvs []corev1.EnvVar) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" || len(controllerEnvs) == 0 || u.GetName() != chainsDeploymentName {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tfor i, c := range d.Spec.Template.Spec.Containers {","\t\t\tif c.Name != chainsContainerName {","\t\t\t\tcontinue","\t\t\t}","","\t\t\texistingEnv := c.Env","\t\t\tfor _, v := range controllerEnvs {","\t\t\t\tnewEnv := corev1.EnvVar{","\t\t\t\t\tName:      v.Name,","\t\t\t\t\tValue:     v.Value,","\t\t\t\t\tValueFrom: v.ValueFrom,","\t\t\t\t}","\t\t\t\tappendNewEnv := true","\t\t\t\tfor existingEnvIndex, env := range existingEnv {","\t\t\t\t\t// Check for the key, if found replace it","\t\t\t\t\tif env.Name == newEnv.Name {","\t\t\t\t\t\texistingEnv[existingEnvIndex] = newEnv","\t\t\t\t\t\tappendNewEnv = false","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t// If not found append the new env","\t\t\t\tif appendNewEnv {","\t\t\t\t\texistingEnv = append(existingEnv, newEnv)","\t\t\t\t}","\t\t\t}","","\t\t\t// update the changes into the actual container","\t\t\td.Spec.Template.Spec.Containers[i].Env = existingEnv","\t\t\tbreak","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","// Creates a cryptographically secure random password","// of length defaultCosignPasswordLength, then encodes it using base64","func generateRandomPassword(ctx context.Context) (string, error) {","\tlogger := logging.FromContext(ctx)","","\traw := make([]byte, defaultCosignPasswordLength)","\tif _, err := rand.Read(raw); err != nil {","\t\tlogger.Errorf(\"Failed to generate random bytes: %v\", err)","\t\treturn \"\", err","\t}","","\t// Base64 encode it","\tpass := base64.StdEncoding.EncodeToString(raw)","\treturn pass, nil","}","","func generateSigningSecrets(ctx context.Context) map[string][]byte {","\tlogger := logging.FromContext(ctx)","","\trandomPassword, err := generateRandomPassword(ctx)","\tif err != nil {","\t\tlogger.Error(\"Error generating random password %w:\", err)","\t\treturn nil","\t}","","\t// Define a PassFunc that supplies the generated password to cosign","\tpassFunc := func(confirm bool) ([]byte, error) {","\t\treturn []byte(randomPassword), nil","\t}","","\tkeys, err := cosign.GenerateKeyPair(passFunc)","\tif err != nil {","\t\tlogger.Error(\"Error generating cosign key pair:\", err)","\t\treturn nil","\t}","","\t// Return the cosign keys and password","\treturn map[string][]byte{","\t\t\"cosign.key\":      keys.PrivateBytes,","\t\t\"cosign.pub\":      keys.PublicBytes,","\t\t\"cosign.password\": []byte(randomPassword),","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,0,1,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,0,0,1,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0]},{"id":83,"path":"pkg/reconciler/kubernetes/tektonchain/transform.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonchain","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","const (","\tleaderElectionChainConfig                       = \"tekton-chains-config-leader-election\"","\tchainControllerDeployment                       = \"tekton-chains-controller\"","\tchainControllerContainer                        = \"tekton-chains-controller\"","\ttektonChainsControllerName                      = \"tekton-chains-controller\"","\ttektonChainsServiceName                         = \"tekton-chains-controller\"","\ttektonChainsControllerStatefulServiceName       = \"STATEFUL_SERVICE_NAME\"","\ttektonChainsControllerStatefulControllerOrdinal = \"STATEFUL_CONTROLLER_ORDINAL\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tchainCR := comp.(*v1alpha1.TektonChain)","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ChainsImagePrefix))","\t\tchainImages := common.ImageRegistryDomainOverride(imagesRaw)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdChains),","\t\t\tcommon.DeploymentImages(chainImages),","\t\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\t\tcommon.AddConfiguration(chainCR.Spec.Config),","\t\t\tcommon.AddConfigMapValues(ChainsConfig, chainCR.Spec.Chain.ChainProperties),","\t\t\tcommon.AddDeploymentRestrictedPSA(),","\t\t\tAddControllerEnv(chainCR.Spec.Chain.ControllerEnvs),","\t\t\tcommon.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(\u0026chainCR.Spec.Performance, leaderElectionChainConfig, chainControllerDeployment, chainControllerContainer),","\t\t}","\t\tif chainCR.Spec.GenerateSigningSecret {","\t\t\textra = append(extra, common.AddSecretData(generateSigningSecrets(ctx), map[string]string{","\t\t\t\tsecretTISSigningAnnotation: \"true\",","\t\t\t}))","\t\t}","","\t\tif chainCR.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *chainCR.Spec.Performance.StatefulsetOrdinals {","\t\t\textra = append(extra,","\t\t\t\tcommon.ConvertDeploymentToStatefulSet(tektonChainsControllerName, tektonChainsServiceName),","\t\t\t\tcommon.AddStatefulEnvVars(","\t\t\t\t\ttektonChainsControllerName, tektonChainsServiceName, tektonChainsControllerStatefulServiceName, tektonChainsControllerStatefulControllerOrdinal))","\t\t}","","\t\textra = append(extra, extension.Transformers(chainCR)...)","\t\terr := common.Transform(ctx, manifest, chainCR, extra...)","\t\tif err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, chainCR.Spec.GetTargetNamespace(), chainCR.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,0,2,2,2,2,2,2,0,2,2,2,1,1,0,0,2,1,1,0,2,0,0]},{"id":84,"path":"pkg/reconciler/kubernetes/tektonconfig/controller.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\ttektonDashboardinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektondashboard\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig\"","\t\"k8s.io/client-go/tools/cache\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\tlogger := logging.FromContext(ctx)","\tctrl := tektonconfig.NewExtensibleController(KubernetesExtension)(ctx, cmw)","\tif _, err := tektonDashboardinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterControllerGVK(v1alpha1.SchemeGroupVersion.WithKind(\"TektonConfig\")),","\t\tHandler:    controller.HandleAll(ctrl.EnqueueControllerOf),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register TektonDashboard informer event handler: %w\", err)","\t}","\treturn ctrl","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":85,"path":"pkg/reconciler/kubernetes/tektonconfig/extension.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonconfig/extension\"",")","","func KubernetesExtension(ctx context.Context) common.Extension {","\treturn kubernetesExtension{","\t\toperatorClientSet: operatorclient.Get(ctx),","\t}","}","","type kubernetesExtension struct {","\toperatorClientSet versioned.Interface","}","","func (oe kubernetesExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{}","}","func (oe kubernetesExtension) PreReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe kubernetesExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tconfigInstance := comp.(*v1alpha1.TektonConfig)","","\tif configInstance.Spec.Profile == v1alpha1.ProfileAll {","\t\tif _, err := extension.EnsureTektonDashboardExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonDashboards(), configInstance); err != nil {","\t\t\tconfigInstance.Status.MarkPostInstallFailed(fmt.Sprintf(\"TektonDashboard: %s\", err.Error()))","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t}","","\tif configInstance.Spec.Profile == v1alpha1.ProfileLite || configInstance.Spec.Profile == v1alpha1.ProfileBasic {","\t\treturn extension.EnsureTektonDashboardCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonDashboards())","\t}","","\treturn nil","}","func (oe kubernetesExtension) Finalize(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tconfigInstance := comp.(*v1alpha1.TektonConfig)","\tif configInstance.Spec.Profile == v1alpha1.ProfileAll {","\t\treturn extension.EnsureTektonDashboardCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonDashboards())","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0]},{"id":86,"path":"pkg/reconciler/kubernetes/tektonconfig/extension/dashboard.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package extension","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","func EnsureTektonDashboardExists(ctx context.Context, clients op.TektonDashboardInterface, config *v1alpha1.TektonConfig) (*v1alpha1.TektonDashboard, error) {","\ttdCR, err := GetDashboard(ctx, clients, v1alpha1.DashboardResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif _, err = createDashboard(ctx, clients, config); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\ttdCR, err = updateDashboard(ctx, tdCR, config, clients)","\tif err != nil {","\t\treturn nil, err","\t}","","\tok, err := isTektonDashboardReady(tdCR, err)","\tif err != nil {","\t\treturn nil, err","\t}","\tif !ok {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn tdCR, err","}","","func GetDashboard(ctx context.Context, clients op.TektonDashboardInterface, name string) (*v1alpha1.TektonDashboard, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func createDashboard(ctx context.Context, clients op.TektonDashboardInterface, config *v1alpha1.TektonConfig) (*v1alpha1.TektonDashboard, error) {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","","\ttdCR := \u0026v1alpha1.TektonDashboard{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.DashboardResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonDashboardSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tConfig:    config.Spec.Config,","\t\t\tDashboard: config.Spec.Dashboard,","\t\t},","\t}","\treturn clients.Create(ctx, tdCR, metav1.CreateOptions{})","}","","func updateDashboard(ctx context.Context, tdCR *v1alpha1.TektonDashboard, config *v1alpha1.TektonConfig,","\tclients op.TektonDashboardInterface) (*v1alpha1.TektonDashboard, error) {","\t// if the dashboard spec is changed then update the instance","\tupdated := false","","\tif config.Spec.TargetNamespace != tdCR.Spec.TargetNamespace {","\t\ttdCR.Spec.TargetNamespace = config.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(tdCR.Spec.DashboardProperties, config.Spec.Dashboard.DashboardProperties) {","\t\ttdCR.Spec.DashboardProperties = config.Spec.Dashboard.DashboardProperties","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(tdCR.Spec.Config, config.Spec.Config) {","\t\ttdCR.Spec.Config = config.Spec.Config","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(tdCR.Spec.Dashboard.Options, config.Spec.Dashboard.Options) {","\t\ttdCR.Spec.Dashboard.Options = config.Spec.Dashboard.Options","\t\tupdated = true","\t}","","\tif tdCR.ObjectMeta.OwnerReferences == nil {","\t\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\t\ttdCR.ObjectMeta.OwnerReferences = []metav1.OwnerReference{ownerRef}","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, tdCR, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn tdCR, nil","}","","// isTektonDashboardReady will check the status conditions of the TektonDashboard and return true if the TektonDashboard is ready.","func isTektonDashboardReady(s *v1alpha1.TektonDashboard, err error) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), err","}","","// EnsureTektonDashboardCRNotExists deletes the singleton instance of TektonDashboard","// and ensures the instance is removed checking whether in exists in a subsequent invocation","func EnsureTektonDashboardCRNotExists(ctx context.Context, clients op.TektonDashboardInterface) error {","\tif _, err := GetDashboard(ctx, clients, v1alpha1.DashboardResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonDashBoard CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.DashboardResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonDashBoard CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonDashboard %q failed to delete: %v\", v1alpha1.DashboardResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,1,0,2,2,2,1,1,2,0,0,2,0,0,0,2,2,2,1,1,0,2,0,0,0,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0]},{"id":87,"path":"pkg/reconciler/kubernetes/tektondashboard/controller.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektondashboard","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonDashboardinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektondashboard\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\ttektonDashboardreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektondashboard\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"k8s.io/client-go/tools/cache\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = \"dashboard-info\"","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\ttektonPipelineInformer := tektonPipelineinformer.Get(ctx)","\t\ttektonDashboardInformer := tektonDashboardinformer.Get(ctx)","","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","","\t\treadonlyManifest, dashboardVer := ctrl.InitController(ctx, common.PayloadOptions{ReadOnly: true})","","\t\tfullaccessManifest, _ := ctrl.InitController(ctx, common.PayloadOptions{ReadOnly: false})","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\tmetrics, err := common.NoMetrics()","\t\tif err != nil {","\t\t\tlogger.Errorf(\"Failed to create dashboard metrics recorder %v\", err)","\t\t}","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","\t\tc := \u0026Reconciler{","\t\t\tpipelineInformer:   tektonPipelineInformer,","\t\t\tinstallerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, dashboardVer, v1alpha1.KindTektonDashboard, metrics),","\t\t\toperatorClientSet:  operatorclient.Get(ctx),","\t\t\textension:          generator(ctx),","\t\t\treadonlyManifest:   readonlyManifest,","\t\t\tfullaccessManifest: fullaccessManifest,","\t\t\tdashboardVersion:   dashboardVer,","\t\t\toperatorVersion:    operatorVer,","\t\t}","\t\timpl := tektonDashboardreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for tekton-dashboard\")","","\t\tif _, err := tektonDashboardInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonDashboard informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonDashboard{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":88,"path":"pkg/reconciler/kubernetes/tektondashboard/finalize.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektondashboard","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// FinalizeKind removes all resources after deletion of a TektonDashboards.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonDashboard) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\t// Delete CRDs before deleting rest of resources so that any instance","\t// of CRDs which has finalizer set will get deleted before we remove","\t// the controller;s deployment for it","","\tvar manifest mf.Manifest","\tif original.Spec.Readonly {","\t\tmanifest = r.readonlyManifest","\t} else {","\t\tmanifest = r.fullaccessManifest","\t}","","\tif err := manifest.Filter(mf.CRDs).Delete(); err != nil {","\t\tlogger.Error(\"Failed to deleted CRDs for TektonDashboard\")","\t\treturn err","\t}","","\tif err := r.installerSetClient.CleanupMainSet(ctx); err != nil {","\t\tlogger.Error(\"failed to cleanup main installerset: \", err)","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0]},{"id":89,"path":"pkg/reconciler/kubernetes/tektondashboard/reconcile.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektondashboard","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tpipelineinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\ttektondashboardreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektondashboard\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// Reconciler implements controller.Reconciler for TektonDashboard resources.","type Reconciler struct {","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// operatorClientSet allows us to configure operator objects","\toperatorClientSet clientset.Interface","\t// readOnlyManifest has the source manifest of Tekton Dashboard for","\t// a particular version with readonly value as true","\treadonlyManifest mf.Manifest","\t// fullaccessManifest has the source manifest of Tekton Dashboard for","\t// a particular version with readonly value as false","\tfullaccessManifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension        common.Extension","\tpipelineInformer pipelineinformer.TektonPipelineInformer","\toperatorVersion  string","\tdashboardVersion string","}","","// Check that our Reconciler implements controller.Reconciler","var _ tektondashboardreconciler.Interface = (*Reconciler)(nil)","var _ tektondashboardreconciler.Finalizer = (*Reconciler)(nil)","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, td *v1alpha1.TektonDashboard) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"tektondashboard\", td.GetName())","\ttd.Status.InitializeConditions()","\ttd.Status.ObservedGeneration = td.Generation","\ttd.Status.SetVersion(r.dashboardVersion)","","\tlogger.Debugw(\"Starting TektonDashboard reconciliation\",","\t\t\"version\", r.dashboardVersion,","\t\t\"generation\", td.Generation,","\t\t\"status\", td.Status.GetCondition(apis.ConditionReady))","","\tif td.GetName() != v1alpha1.DashboardResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.DashboardResourceName,","\t\t\ttd.GetName(),","\t\t)","\t\tlogger.Errorw(\"Invalid resource name\", \"expectedName\", v1alpha1.DashboardResourceName, \"actualName\", td.GetName())","\t\ttd.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// find the valid tekton-pipeline installation","\tlogger.Debug(\"Checking Tekton Pipeline dependency\")","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\tlogger.Infow(\"Tekton Pipeline dependency not ready yet\", \"error\", err)","\t\t\ttd.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","","\t\t}","\t\t// (tektonpipeline.opeator.tekton.dev instance not available yet)","\t\tlogger.Errorw(\"Tekton Pipeline dependency missing\", \"error\", err)","\t\ttd.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","\tlogger.Info(\"All dependencies installed successfully\")","\ttd.Status.MarkDependenciesInstalled()","","\tlogger.Debug(\"Removing obsolete installer sets\")","\tif err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {","\t\tlogger.Errorw(\"Failed to remove obsolete installer sets\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"Obsolete installer sets removed\")","","\tlogger.Debug(\"Executing pre-reconciliation\")","\tif err := r.extension.PreReconcile(ctx, td); err != nil {","\t\tlogger.Errorw(\"Pre-reconciliation failed\", \"error\", err)","\t\ttd.Status.MarkPreReconcilerFailed(fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error()))","\t\treturn err","\t}","","\t// Mark PreReconcile Complete","\tlogger.Info(\"Pre-reconciliation completed successfully\")","\ttd.Status.MarkPreReconcilerComplete()","","\tvar manifest mf.Manifest","\tif td.Spec.Readonly {","\t\tlogger.Debugw(\"Using readonly manifest\", \"readonly\", true)","\t\tmanifest = r.readonlyManifest","\t} else {","\t\tlogger.Debugw(\"Using full access manifest\", \"readonly\", false)","\t\tmanifest = r.fullaccessManifest","\t}","","\t// When Tekton Dashboard is insalled targetNamespace is getting updated with the OwnerRef as TektonDashboard","\t// and hence deleting the component in the integration tests, targetNamespace was getting deleted. Hence","\t// filtering out the namespace here","\tlogger.Debug(\"Filtering out namespace from manifest\")","\tmanifest = manifest.Filter(mf.Not(mf.ByKind(\"Namespace\")))","","\tlogger.Debug(\"Applying main manifest\")","\tif err := r.installerSetClient.MainSet(ctx, td, \u0026manifest, filterAndTransform(r.extension)); err != nil {","\t\tmsg := fmt.Sprintf(\"Main Reconcilation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Failed to apply main installer set\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Infow(\"Main reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\ttd.Status.MarkInstallerSetNotReady(msg)","\t\treturn nil","\t}","\tlogger.Info(\"Main manifest applied successfully\")","","\tlogger.Debug(\"Executing post-reconciliation\")","\tif err := r.extension.PostReconcile(ctx, td); err != nil {","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Post-reconciliation failed\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Infow(\"Post-reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Post-reconciliation completed successfully\")","\t\ttd.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\tlogger.Info(\"Post-reconciliation completed successfully\")","\ttd.Status.MarkPostReconcilerComplete()","","\tlogger.Info(\"TektonDashboard reconciliation completed successfully\")","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0]},{"id":90,"path":"pkg/reconciler/kubernetes/tektondashboard/transform.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektondashboard","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","const (","\texternalLogsArg         = \"--external-logs=\"","\tdashboardDeploymentName = \"tekton-dashboard\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tdashboard := comp.(*v1alpha1.TektonDashboard)","\t\ttargetNamespace := dashboard.Spec.GetTargetNamespace()","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.DashboardImagePrefix))","\t\timages := common.ImageRegistryDomainOverride(imagesRaw)","","\t\ttrns := extension.Transformers(dashboard)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdDashboard),","\t\t\tcommon.AddConfiguration(dashboard.Spec.Config),","\t\t\tcommon.AddDeploymentRestrictedPSA(),","\t\t\tcommon.DeploymentImages(images),","\t\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\t\tcommon.ReplaceNamespaceInDeploymentArgs([]string{dashboardDeploymentName}, targetNamespace),","\t\t}","\t\ttrns = append(trns, extra...)","\t\tif dashboard.Spec.ExternalLogs != \"\" {","\t\t\tupdatedExternalLogsArg := externalLogsArg + dashboard.Spec.ExternalLogs","\t\t\ttrns = append(trns, common.ReplaceDeploymentArg(dashboardDeploymentName, externalLogsArg, updatedExternalLogsArg))","\t\t}","\t\tif err := common.Transform(ctx, manifest, dashboard, trns...); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, targetNamespace, dashboard.Spec.Dashboard.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,2,1,1,0,2,0,0]},{"id":91,"path":"pkg/reconciler/kubernetes/tektonhub/controller.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonhub","","import (","\t\"context\"","","\t\"github.com/go-logr/zapr\"","\tmfc \"github.com/manifestival/client-go-client\"","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonHubinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonhub\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonHubReconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonhub\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"go.uber.org/zap\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\ttektonHubInformer := tektonHubinformer.Get(ctx)","\t\tkubeClient := kubeclient.Get(ctx)","\t\tlogger := logging.FromContext(ctx)","","\t\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating client from injected config\", zap.Error(err))","\t\t}","\t\tmflogger := zapr.NewLogger(logger.Named(\"manifestival\").Desugar())","\t\tmanifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating initial manifest\", zap.Error(err))","\t\t}","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\tc := \u0026Reconciler{","\t\t\tkubeClientSet:     kubeClient,","\t\t\toperatorClientSet: operatorclient.Get(ctx),","\t\t\textension:         generator(ctx),","\t\t\tmanifest:          manifest,","\t\t\toperatorVersion:   operatorVer,","\t\t}","\t\timpl := tektonHubReconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers\")","","\t\tif _, err := tektonHubInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonHub informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonHub{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0]},{"id":92,"path":"pkg/reconciler/kubernetes/tektonhub/installerset.go","lines":["package tektonhub","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","// checkIfInstallerSetExist checks if installer set exists for a component and return true/false based on it","// and if installer set which already exist is of older version then it deletes and return false to create a new","// installer set","func (r *Reconciler) checkIfInstallerSetExist(ctx context.Context, oc clientset.Interface, relVersion string, installerSetType string) (bool, error) {","","\tlabels := r.getLabels(installerSetType)","\tlabelSelector, err := common.LabelSelector(labels)","\tif err != nil {","\t\treturn false, err","\t}","","\tcompInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\tif err != nil {","\t\treturn false, err","\t}","","\tif compInstallerSet != \"\" {","\t\t// if already created then check which version it is","\t\tctIs, err := oc.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, compInstallerSet, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tif apierrors.IsNotFound(err) {","\t\t\t\treturn false, nil","\t\t\t}","\t\t\treturn false, err","\t\t}","","\t\tversion, ok := ctIs.Annotations[v1alpha1.ReleaseVersionKey]","\t\tif ok \u0026\u0026 version == relVersion {","\t\t\t// if installer set already exist and release version is same","\t\t\t// then ignore and move on","\t\t\treturn true, nil","\t\t}","","\t\t// release version doesn't exist or is different from expected","\t\t// deleted existing InstallerSet and create a new one","","\t\terr = oc.OperatorV1alpha1().TektonInstallerSets().","\t\t\tDelete(ctx, compInstallerSet, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\treturn false, err","\t\t}","\t}","","\treturn false, nil","}","","func createInstallerSet(ctx context.Context, oc clientset.Interface, th *v1alpha1.TektonHub,","\tmanifest mf.Manifest, releaseVersion, component, installerSetPrefix, namespace string, labels map[string]string, specHash string) error {","","\tis := makeInstallerSet(th, manifest, installerSetPrefix, releaseVersion, namespace, labels, specHash)","\tif is == nil {","\t\treturn fmt.Errorf(\"Unable to create installerset\")","\t}","","\tcreatedIs, err := oc.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, is, metav1.CreateOptions{})","\tif err != nil {","\t\treturn err","\t}","","\tif len(th.Status.HubInstallerSet) == 0 {","\t\tth.Status.HubInstallerSet = map[string]string{}","\t}","","\t// Update the status of addon with created installerSet name","\tth.Status.HubInstallerSet[component] = createdIs.Name","\tth.Status.SetVersion(releaseVersion)","\treturn nil","}","","func makeInstallerSet(th *v1alpha1.TektonHub, manifest mf.Manifest, prefix, releaseVersion, namespace string, labels map[string]string, specHash string) *v1alpha1.TektonInstallerSet {","\townerRef := *metav1.NewControllerRef(th, th.GetGroupVersionKind())","","\ttektonHubCRSpecHash, err := hash.Compute(th.Spec)","\tif err != nil {","\t\treturn nil","\t}","","\tis := \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: fmt.Sprintf(\"%s-\", prefix),","\t\t\tLabels:       labels,","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey:  releaseVersion,","\t\t\t\tv1alpha1.TargetNamespaceKey: namespace,","\t\t\t\tv1alpha1.LastAppliedHashKey: tektonHubCRSpecHash,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","","\tif specHash != \"\" {","\t\tis.Annotations[v1alpha1.DbSecretHash] = specHash","\t}","","\treturn is","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":93,"path":"pkg/reconciler/kubernetes/tektonhub/tektonhub.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonhub","","import (","\t\"bytes\"","\t\"context\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"","\t\"path/filepath\"","\t\"reflect\"","\t\"strings\"","","\tcorev1 \"k8s.io/api/core/v1\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/spf13/viper\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\ttektonhubconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonhub\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// Reconciler implements controller.Reconciler for TektonHub resources.","type Reconciler struct {","\t// kubeClientSet allows us to talk to the k8s for core APIs","\tkubeClientSet kubernetes.Interface","\t// operatorClientSet allows us to configure operator objects","\toperatorClientSet clientset.Interface","\t// manifest is empty, but with a valid client and logger. all","\t// manifests are immutable, and any created during reconcile are","\t// expected to be appended to this one, obviating the passing of","\t// client \u0026 logger","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension       common.Extension","\toperatorVersion string","}","","const (","\t// installerSet labels","\tinstallerSetLabelCreatedByValue = \"TektonHub\"","","\t// installerSet names","\tinstallerSetNameDatabase      = \"DbInstallerSet\"","\tinstallerSetDatabaseMigration = \"DbMigrationInstallerSet\"","\tinstallerSetNameAPI           = \"ApiInstallerSet\"","\tinstallerSetNameUI            = \"UiInstallerSet\"","","\t// installerSet types","\tinstallerSetTypeDatabase          = \"tekton-hub-db\"","\tinstallerSetTypeDatabaseMigration = \"tekton-hub-db-migration\"","\tinstallerSetTypeAPI               = \"tekton-hub-api\"","\tinstallerSetTypeUI                = \"tekton-hub-ui\"","","\t// manifests directory names","\tmanifestDirDatabase          = \"db\"","\tmanifestDirDatabaseMigration = \"db-migration\"","\tmanifestDirAPI               = \"api\"","\tmanifestDirUI                = \"ui\"","\tmanifestDirInfo              = \"hub-info\"","","\t// resource names","\tdatabaseSecretName = \"tekton-hub-db\"","\tapiConfigMapName   = \"tekton-hub-api\"","\tuiConfigMapName    = \"tekton-hub-ui\"","","\t// database secret keys","\tsecretKeyPostgresHost     = \"POSTGRES_HOST\"","\tsecretKeyPostgresDB       = \"POSTGRES_DB\"","\tsecretKeyPostgresUser     = \"POSTGRES_USER\"","\tsecretKeyPostgresPassword = \"POSTGRES_PASSWORD\"","\tsecretKeyPostgresPort     = \"POSTGRES_PORT\"","","\t// default postgres database values","\tdefaultPostgresHost     = \"tekton-hub-db\"","\tdefaultPostgresDB       = \"hub\"","\tdefaultPostgresUser     = \"hub\"","\tdefaultPostgresPassword = \"hub\"","\tdefaultPostgresPort     = \"5432\"",")","","var (","\terrKeyMissing error = fmt.Errorf(\"secret doesn't contains all the keys\")","","\t// Check that our Reconciler implements controller.Reconciler","\t_ tektonhubconciler.Interface = (*Reconciler)(nil)","\t_ tektonhubconciler.Finalizer = (*Reconciler)(nil)","","\tls = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     installerSetLabelCreatedByValue,","\t\t\tv1alpha1.InstallerSetType: v1alpha1.HubResourceName,","\t\t},","\t}","","\tdbKeys = []string{secretKeyPostgresHost, secretKeyPostgresDB, secretKeyPostgresUser, secretKeyPostgresPassword, secretKeyPostgresPort}",")","","type Data struct {","\tCatalogs   []v1alpha1.Catalog","\tCategories []v1alpha1.Category","\tScopes     []v1alpha1.Scope","\tDefault    v1alpha1.Default","}","","// FinalizeKind removes all resources after deletion of a TektonHub.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonHub) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\tlabelSelector, err := common.LabelSelector(ls)","\tif err != nil {","\t\treturn err","\t}","\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tDeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{","\t\t\tLabelSelector: labelSelector,","\t\t}); err != nil {","\t\tlogger.Error(\"Failed to delete installer set created by TektonHub\", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","\treturn nil","}","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, th *v1alpha1.TektonHub) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","\tth.Status.InitializeConditions()","\tth.Status.ObservedGeneration = th.Generation","","\tlogger.Infow(\"Reconciling TektonHub\", \"status\", th.Status)","","\t// we have to maintain only one hub across the cluster and the accepted resource name is \"hub\"","\tif th.GetName() != v1alpha1.HubResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.HubResourceName,","\t\t\tth.GetName(),","\t\t)","\t\tlogger.Error(msg)","\t\tth.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\tth.SetDefaults(ctx)","","\t// reconcile target namespace","\tif err := common.ReconcileTargetNamespace(ctx, nil, nil, th, r.kubeClientSet); err != nil {","\t\tlogger.Errorw(\"error on reconciling targetNamespace\",","\t\t\t\"targetNamespace\", th.Spec.GetTargetNamespace(),","\t\t\terr,","\t\t)","\t\treturn err","\t}","","\t// execute pre-reconcile, used in extension","\tif err := r.extension.PreReconcile(ctx, th); err != nil {","\t\treturn r.handleError(err, th)","\t}","\tth.Status.MarkPreReconcilerComplete()","","\t// get TektonHub version and yaml manifests directory","\tversion := common.TargetVersion(th)","\thubManifestDir := filepath.Join(common.ComponentDir(th), version)","","\t// if user has not supplied external database credentials setup a database","\tif err := r.reconcileDatabaseInstallerSet(ctx, th, hubManifestDir, version); err != nil {","\t\treturn r.handleError(err, th)","\t}","","\tif err := r.setupDatabaseMigrationInstallerSet(ctx, th, hubManifestDir, version); err != nil {","\t\treturn r.handleError(err, th)","\t}","\tth.Status.MarkDatabaseMigrationDone()","","\tif err := r.reconcileApiInstallerSet(ctx, th, hubManifestDir, version); err != nil {","\t\treturn r.handleError(err, th)","\t}","\tth.Status.MarkApiInstallerSetAvailable()","","\tif err := r.reconcileUiInstallerSet(ctx, th, hubManifestDir, version); err != nil {","\t\treturn r.handleError(err, th)","\t}","\tth.Status.MarkUiInstallerSetAvailable()","","\t// execute post-reconcile, used in extension","\tif err := r.extension.PostReconcile(ctx, th); err != nil {","\t\treturn r.handleError(err, th)","\t}","\tth.Status.MarkPostReconcilerComplete()","","\treturn nil","}","","func (r *Reconciler) handleError(err error, th *v1alpha1.TektonHub) error {","\tif err == v1alpha1.RECONCILE_AGAIN_ERR {","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","\treturn err","}","","func (r *Reconciler) reconcileUiInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error {","\texist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeUI)","\tif err != nil {","\t\treturn err","\t}","","\tif !exist {","\t\tth.Status.MarkUiInstallerSetNotAvailable(\"UI installer set not available\")","\t\tuiLocation := filepath.Join(hubDir, manifestDirUI)","","\t\tmanifest, err := r.getManifest(ctx, th, uiLocation)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\terr = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetNameUI, version, installerSetTypeUI)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t}","","\tif exist {","\t\t// Get the installerset, check for the hash of spec","\t\t// if not same delete the installerset.","\t\tlabels := r.getLabels(installerSetTypeUI)","\t\tlabelSelector, err := common.LabelSelector(labels)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcompInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif compInstallerSet != \"\" {","\t\t\tctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, compInstallerSet, metav1.GetOptions{})","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\tlastAppliedTektonHubCRSpecHash := ctIs.Annotations[v1alpha1.LastAppliedHashKey]","\t\t\ttektonHubCRSpecHash, err := hash.Compute(th.Spec)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\tif tektonHubCRSpecHash != lastAppliedTektonHubCRSpecHash {","\t\t\t\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, ctIs.Name, metav1.DeleteOptions{}); err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t\t\t}","\t\t}","\t}","","\terr = r.checkComponentStatus(ctx, th, installerSetTypeUI)","\tif err != nil {","\t\tth.Status.MarkUiInstallerSetNotAvailable(err.Error())","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn nil","}","","func (r *Reconciler) reconcileApiInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error {","","\t// Validate whether the secrets and configmap are created for API","\tif err := r.validateApiDependencies(ctx, th, hubDir, manifestDirAPI); err != nil {","\t\tth.Status.MarkApiDependencyMissing(\"api secrets not present\")","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\tth.Status.MarkApiDependenciesInstalled()","","\texist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeAPI)","\tif err != nil {","\t\treturn err","\t}","","\tif !exist {","\t\tth.Status.MarkApiInstallerSetNotAvailable(\"API installer set not available\")","\t\tapiLocation := filepath.Join(hubDir, manifestDirAPI)","","\t\tmanifest, err := r.getManifest(ctx, th, apiLocation)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tinfoLocation := filepath.Join(hubDir, manifestDirInfo)","","\t\tinfoManifest, err := r.getManifest(ctx, th, infoLocation)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t*manifest = manifest.Append(*infoManifest)","","\t\terr = applyPVC(ctx, manifest, th)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\terr = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetNameAPI, version, installerSetTypeAPI)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\tif exist {","\t\t// Get the installerset, check for the hash of db secret","\t\t// if not same delete the installerset.","\t\tlabels := r.getLabels(installerSetTypeAPI)","\t\tlabelSelector, err := common.LabelSelector(labels)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcompInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif compInstallerSet != \"\" {","\t\t\tctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tGet(ctx, compInstallerSet, metav1.GetOptions{})","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\tlastAppliedDbSecretHash := ctIs.Annotations[v1alpha1.DbSecretHash]","\t\t\tlastAppliedTektonHubCRSpecHash := ctIs.Annotations[v1alpha1.LastAppliedHashKey]","","\t\t\tsecret, err := r.getSecret(ctx, databaseSecretName, th.Spec.GetTargetNamespace(), dbKeys)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\texpectedDbSecretHash, err := hash.Compute(secret.Data)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\ttektonHubCRSpecHash, err := hash.Compute(th.Spec)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\tif lastAppliedDbSecretHash != expectedDbSecretHash || tektonHubCRSpecHash != lastAppliedTektonHubCRSpecHash {","","\t\t\t\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, ctIs.Name, metav1.DeleteOptions{}); err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t\t\t}","\t\t}","\t}","","\terr = r.checkComponentStatus(ctx, th, installerSetTypeAPI)","\tif err != nil {","\t\tth.Status.MarkApiInstallerSetNotAvailable(err.Error())","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn nil","}","","func (r *Reconciler) setupDatabaseMigrationInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error {","\t// Check if the InstallerSet is available for DB-migration","\texist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeDatabaseMigration)","\tif err != nil {","\t\treturn err","\t}","","\tif !exist {","\t\tdbMigrationManifestsDir := filepath.Join(hubDir, manifestDirDatabaseMigration)","\t\tth.Status.MarkDatabaseMigrationFailed(\"DB migration installerset not available\")","","\t\tmanifest, err := r.getManifest(ctx, th, dbMigrationManifestsDir)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\terr = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetDatabaseMigration, version, installerSetTypeDatabaseMigration)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\tif exist {","\t\t// Get the installerset, check for the hash of db secret","\t\t// if not same delete the installerset","","\t\tlabels := r.getLabels(installerSetTypeDatabaseMigration)","\t\tlabelSelector, err := common.LabelSelector(labels)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcompInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif compInstallerSet != \"\" {","\t\t\tctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, compInstallerSet, metav1.GetOptions{})","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\tlastAppliedDbSecretHash := ctIs.Annotations[v1alpha1.DbSecretHash]","","\t\t\tsecret, err := r.getSecret(ctx, databaseSecretName, th.Spec.GetTargetNamespace(), dbKeys)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\texpectedDbSecretHash, err := hash.Compute(secret.Data)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\tif lastAppliedDbSecretHash != expectedDbSecretHash {","\t\t\t\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, ctIs.Name, metav1.DeleteOptions{}); err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\terr = r.checkComponentStatus(ctx, th, installerSetTypeDatabaseMigration)","\tif err != nil {","\t\tth.Status.MarkDatabaseMigrationFailed(err.Error())","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn nil","}","","func (r *Reconciler) setupDatabase(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error {","\t// Check if the DB secrets are created","\tif err := r.validateOrCreateDBSecrets(ctx, th); err != nil {","\t\tth.Status.MarkDbDependencyMissing(\"db secrets are either invalid or not present\")","\t\treturn err","\t}","\tth.Status.MarkDbDependenciesInstalled()","","\texist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeDatabase)","\tif err != nil {","\t\treturn err","\t}","","\tif !exist {","\t\tth.Status.MarkDbInstallerSetNotAvailable(\"DB installer set not available\")","\t\tdbLocation := filepath.Join(hubDir, manifestDirDatabase)","\t\tmanifest, err := r.getManifest(ctx, th, dbLocation)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\terr = applyPVC(ctx, manifest, th)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\terr = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetNameDatabase, version, installerSetTypeDatabase)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\terr = r.checkComponentStatus(ctx, th, installerSetTypeDatabase)","\tif err != nil {","\t\tth.Status.MarkDbInstallerSetNotAvailable(err.Error())","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn nil","}","","// Validate DB are present on the cluster. If DB secrets are present and all the keys don't","// have values then update the remaining values with default values. If the DB secret","// is not present then create a new secret with default values.","func (r *Reconciler) validateOrCreateDBSecrets(ctx context.Context, th *v1alpha1.TektonHub) error {","\tlogger := logging.FromContext(ctx)","\ttargetNamespace := th.Spec.GetTargetNamespace()","","\t// th.Status.MarkDbDependencyInstalling(\"db secrets are being added into the namespace\")","","\tdbSecret, err := r.getSecret(ctx, databaseSecretName, targetNamespace, dbKeys)","\tif err != nil {","\t\tnewDbSecret := createDbSecret(databaseSecretName, targetNamespace, dbSecret, th)","\t\tif apierrors.IsNotFound(err) {","\t\t\t_, err = r.kubeClientSet.CoreV1().Secrets(targetNamespace).Create(ctx, newDbSecret, metav1.CreateOptions{})","\t\t\tif err != nil {","\t\t\t\tlogger.Error(err)","\t\t\t\tth.Status.MarkDbDependencyMissing(fmt.Sprintf(\"%s secret is missing\", databaseSecretName))","\t\t\t\treturn err","\t\t\t}","\t\t\treturn nil","\t\t}","\t\tif err == errKeyMissing {","\t\t\t_, err = r.kubeClientSet.CoreV1().Secrets(targetNamespace).Update(ctx, newDbSecret, metav1.UpdateOptions{})","\t\t\tif err != nil {","\t\t\t\tlogger.Error(err)","\t\t\t\tth.Status.MarkDbDependencyMissing(fmt.Sprintf(\"%s secret is missing\", databaseSecretName))","\t\t\t\treturn err","\t\t\t}","\t\t} else {","\t\t\tlogger.Error(err)","\t\t\treturn err","\t\t}","\t}","","\treturn nil","}","","// TektonHub expects API secrets to be created before installing Tekton Hub API","func (r *Reconciler) validateApiDependencies(ctx context.Context, th *v1alpha1.TektonHub, hubDir, comp string) error {","\tlogger := logging.FromContext(ctx)","\tapiSecretKeys := []string{\"GH_CLIENT_ID\", \"GH_CLIENT_SECRET\", \"JWT_SIGNING_KEY\", \"ACCESS_JWT_EXPIRES_IN\", \"REFRESH_JWT_EXPIRES_IN\", \"GHE_URL\"}","","\tth.Status.MarkApiDependencyInstalling(\"checking for api secrets in the namespace and creating the ConfigMap\")","","\t_, err := r.getSecret(ctx, th.Spec.Api.ApiSecretName, th.Spec.GetTargetNamespace(), apiSecretKeys)","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\tif err := r.createApiSecret(ctx, th, hubDir, comp); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t\tif err == errKeyMissing {","\t\t\tth.Status.MarkApiDependencyMissing(fmt.Sprintf(\"%s secret is missing the keys\", th.Spec.Api.ApiSecretName))","\t\t\treturn err","\t\t} else {","\t\t\tlogger.Error(err)","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func (r *Reconciler) getManifest(ctx context.Context, th *v1alpha1.TektonHub, manifestLocation string) (*mf.Manifest, error) {","\tmanifest := r.manifest.Append()","","\tif err := common.AppendManifest(\u0026manifest, manifestLocation); err != nil {","\t\treturn nil, err","\t}","","\ttransformer := filterAndTransform(r.extension)","\ttransformedManifest, err := transformer(ctx, \u0026manifest, th)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn transformedManifest, nil","}","","func (r *Reconciler) getLabels(componentInstallerSetType string) metav1.LabelSelector {","\treturn metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     installerSetLabelCreatedByValue,","\t\t\tv1alpha1.InstallerSetType: componentInstallerSetType,","\t\t},","\t}","}","","func applyPVC(ctx context.Context, manifest *mf.Manifest, th *v1alpha1.TektonHub) error {","\tlogger := logging.FromContext(ctx)","","\tpvc := manifest.Filter(mf.ByKind(\"PersistentVolumeClaim\"))","\tpvcManifest, err := pvc.Transform(","\t\tmf.InjectOwner(th),","\t\tmf.InjectNamespace(th.Spec.GetTargetNamespace()),","\t)","","\tif err != nil {","\t\tlogger.Error(\"failed to transform manifest\")","\t\treturn err","\t}","","\tif err := pvcManifest.Apply(); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func (r *Reconciler) reconcileDatabaseInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error {","\t// Get the db secret, if not found or if any key is missing,","\t// then manage the db installerset. If the value of db host","\t// is different then user already has the db, hence delete","\t// existing db installerset","\tsecret, err := r.getSecret(ctx, databaseSecretName, th.Spec.GetTargetNamespace(), dbKeys)","\tif err != nil {","\t\t// If not found create db with default db","\t\tif apierrors.IsNotFound(err) || err == errKeyMissing {","\t\t\tif err := r.setupDatabase(ctx, th, hubDir, version); err != nil {","\t\t\t\treturn r.handleError(err, th)","\t\t\t}","\t\t\tth.Status.MarkDbInstallerSetAvailable()","\t\t\treturn nil","\t\t}","\t\treturn err","\t} else if string(secret.Data[secretKeyPostgresHost]) != defaultPostgresHost {","\t\t// Mark the database as ready state as the","\t\t// database is already installed by the user","\t\tth.Status.MarkDbDependenciesInstalled()","\t\tth.Status.MarkDbInstallerSetAvailable()","","\t\t// Get and delete the default db installerset","\t\tif err := r.getAndDeleteInstallerSet(ctx, installerSetTypeDatabase); err != nil {","\t\t\tif apierrors.IsNotFound(err) {","\t\t\t\treturn nil","\t\t\t}","\t\t\treturn err","\t\t}","\t} else {","\t\t// If secret found, with no error, then make sure db is up and running","\t\tif err := r.setupDatabase(ctx, th, hubDir, version); err != nil {","\t\t\treturn r.handleError(err, th)","\t\t}","\t\tth.Status.MarkDbInstallerSetAvailable()","\t}","","\treturn nil","}","","func (r *Reconciler) setUpAndCreateInstallerSet(ctx context.Context, manifest mf.Manifest, th *v1alpha1.TektonHub, installerSetName, version, prefixName string) error {","","\tmanifest = manifest.Filter(mf.Not(mf.Any(mf.ByKind(\"Secret\"), mf.ByKind(\"PersistentVolumeClaim\"), mf.ByKind(\"Namespace\"))))","","\tspecHash := \"\"","\tif prefixName == installerSetTypeDatabaseMigration || prefixName == installerSetTypeAPI {","\t\tsecret, err := r.kubeClientSet.CoreV1().Secrets(th.Spec.GetTargetNamespace()).Get(ctx, databaseSecretName, metav1.GetOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tspecHash, err = hash.Compute(secret.Data)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\tlabels := r.getLabels(prefixName).MatchLabels","\tif err := createInstallerSet(ctx, r.operatorClientSet, th, manifest,","\t\tversion, installerSetName, prefixName, th.Spec.GetTargetNamespace(), labels, specHash); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func (r *Reconciler) getAndDeleteInstallerSet(ctx context.Context, installerSetType string) error {","\tlabels := r.getLabels(installerSetType)","\tlabelSelector, err := common.LabelSelector(labels)","\tif err != nil {","\t\treturn err","\t}","","\tcompInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\tif err != nil {","\t\treturn err","\t}","","\tif compInstallerSet != \"\" {","\t\t_, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, compInstallerSet, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tif apierrors.IsNotFound(err) {","\t\t\t\treturn nil","\t\t\t}","\t\t\treturn err","\t\t}","","\t\terr = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tDelete(ctx, compInstallerSet, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\treturn nil","}","","func (r *Reconciler) checkComponentStatus(ctx context.Context, th *v1alpha1.TektonHub, installerSetType string) error {","","\tlabels := r.getLabels(installerSetType)","\tlabelSelector, err := common.LabelSelector(labels)","\tif err != nil {","\t\treturn err","\t}","","\tcompInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\tif err != nil {","\t\treturn err","\t}","","\tif compInstallerSet != \"\" {","","\t\tctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, compInstallerSet, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tif apierrors.IsNotFound(err) {","\t\t\t\treturn nil","\t\t\t}","\t\t\treturn err","\t\t}","","\t\tready := ctIs.Status.GetCondition(apis.ConditionReady)","\t\tif ready == nil || ready.Status == corev1.ConditionUnknown {","\t\t\treturn fmt.Errorf(\"InstallerSet %s: waiting for installation\", ctIs.Name)","\t\t} else if ready.Status == corev1.ConditionFalse {","\t\t\treturn fmt.Errorf(\"InstallerSet %s: \", ready.Message)","\t\t}","\t}","","\treturn nil","}","","func (r *Reconciler) getSecret(ctx context.Context, name, targetNs string, verifyKeys []string) (*corev1.Secret, error) {","\tsecret, err := r.kubeClientSet.CoreV1().Secrets(targetNs).Get(ctx, name, metav1.GetOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tfor _, key := range verifyKeys {","\t\tif _, ok := secret.Data[key]; !ok {","\t\t\treturn nil, errKeyMissing","\t\t}","\t}","","\treturn secret, nil","}","","func (r *Reconciler) createApiSecret(ctx context.Context, th *v1alpha1.TektonHub, hubDir, comp string) error {","","\tmanifest, err := r.getHubManifest(ctx, th, hubDir, comp)","\tif err != nil {","\t\treturn err","\t}","","\tsecret := manifest.Filter(mf.ByKind(\"Secret\"))","\tsecretManifest, err := secret.Transform(","\t\tmf.InjectNamespace(th.Spec.GetTargetNamespace()),","\t)","\tif err != nil {","\t\treturn err","\t}","","\tif err := secretManifest.Apply(); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func (r *Reconciler) getHubManifest(ctx context.Context, th *v1alpha1.TektonHub, hubDir, comp string) (*mf.Manifest, error) {","\tmanifestLocation := filepath.Join(hubDir, comp)","","\tmanifest, err := r.getManifest(ctx, th, manifestLocation)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn manifest, nil","}","","func createDbSecret(name, namespace string, existingSecret *corev1.Secret, th *v1alpha1.TektonHub) *corev1.Secret {","\ts := \u0026corev1.Secret{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:      name,","\t\t\tNamespace: namespace,","\t\t\tLabels: map[string]string{","\t\t\t\t\"app\": \"db\",","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{getOwnerRef(th)},","\t\t},","\t\tType: corev1.SecretTypeOpaque,","\t}","","\tif existingSecret != nil \u0026\u0026 existingSecret.Data != nil {","\t\ts.Data = existingSecret.Data","\t}","","\ts.StringData = make(map[string]string)","","\tdefaultValues := map[string]string{","\t\tsecretKeyPostgresHost:     defaultPostgresHost,","\t\tsecretKeyPostgresDB:       defaultPostgresDB,","\t\tsecretKeyPostgresUser:     defaultPostgresUser,","\t\tsecretKeyPostgresPassword: defaultPostgresPassword,","\t\tsecretKeyPostgresPort:     defaultPostgresPort,","\t}","","\t// fill default value for absents","\tfor secretKey, defaultValue := range defaultValues {","\t\tif s.Data[secretKey] == nil || len(s.Data[secretKey]) == 0 {","\t\t\ts.StringData[secretKey] = defaultValue","\t\t}","\t}","","\treturn s","}","","// Get an ownerRef of TektonHub","func getOwnerRef(th *v1alpha1.TektonHub) metav1.OwnerReference {","\treturn *metav1.NewControllerRef(th, th.GroupVersionKind())","}","","// add key value pair to the given configmap name","func addConfigMapKeyValue(configMapName, key, value string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"configmap\" {","\t\t\treturn nil","\t\t}","\t\tif u.GetName() != configMapName {","\t\t\treturn nil","\t\t}","","\t\tcm := \u0026corev1.ConfigMap{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif cm.Data == nil {","\t\t\tcm.Data = map[string]string{}","\t\t}","","\t\tcm.Data[key] = value","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","func updateApiConfigMap(th *v1alpha1.TektonHub, configMapName string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"configmap\" {","\t\t\treturn nil","\t\t}","","\t\tif u.GetName() != configMapName {","\t\t\treturn nil","\t\t}","","\t\tcm := \u0026corev1.ConfigMap{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// TODO: Remove this condition in the next release","\t\tif th.Spec.Api.HubConfigUrl != \"\" {","","\t\t\thubUrlConfigdata, err := getConfigDataFromHubURL(th)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tcm = updateConfigMapDataFromHubConfigURL(th, cm, hubUrlConfigdata)","","\t\t} else {","","\t\t\tif len(th.Spec.Categories) \u003e 0 {","\t\t\t\tcategories := \"\"","\t\t\t\tfor _, c := range th.Spec.Categories {","\t\t\t\t\tcategories += fmt.Sprintf(\"- %s\\n\", c)","\t\t\t\t}","\t\t\t\tcm.Data[\"CATEGORIES\"] = categories","\t\t\t}","","\t\t\tif len(th.Spec.Catalogs) \u003e 0 {","\t\t\t\tcatalogs := \"\"","\t\t\t\tfor _, c := range th.Spec.Catalogs {","\t\t\t\t\tcatalogs = catalogs + getCatalogData(c, th)","\t\t\t\t}","\t\t\t\tcm.Data[\"CATALOGS\"] = catalogs","\t\t\t}","","\t\t\tif len(th.Spec.Scopes) \u003e 0 {","\t\t\t\tuserScopes := \"\"","\t\t\t\tfor _, s := range th.Spec.Scopes {","\t\t\t\t\tscope := \"\"","\t\t\t\t\tscope += fmt.Sprintf(\"- name: %s\\n\", s.Name)","\t\t\t\t\tscope += fmt.Sprintf(\"  users: [%s]\\n\", strings.Join(s.Users, \", \"))","\t\t\t\t\tuserScopes = userScopes + scope","\t\t\t\t}","\t\t\t\tcm.Data[\"SCOPES\"] = userScopes","\t\t\t} else {","\t\t\t\tcm.Data[\"SCOPES\"] = \"\"","\t\t\t}","","\t\t\tif len(th.Spec.Default.Scopes) \u003e 0 {","\t\t\t\tdefaultScopes := \"\"","\t\t\t\tscopes := fmt.Sprintf(\"%s\\n\", defaultScopes)","\t\t\t\tfor _, d := range th.Spec.Default.Scopes {","\t\t\t\t\tscopes += fmt.Sprintf(\"  - %s\\n\", d)","\t\t\t\t}","\t\t\t\tdefaultScopes = fmt.Sprintf(\" scopes: \\n%s\", scopes)","\t\t\t\tcm.Data[\"DEFAULT\"] = defaultScopes","\t\t\t}","\t\t}","","\t\tif th.Spec.Api.CatalogRefreshInterval != \"\" {","\t\t\tcm.Data[\"CATALOG_REFRESH_INTERVAL\"] = th.Spec.Api.CatalogRefreshInterval","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// TODO: Remove this function in the next release","// Adds Config Data from HubConfigUrl to API Config Map","func updateConfigMapDataFromHubConfigURL(th *v1alpha1.TektonHub, cm *corev1.ConfigMap, hubUrlConfigdata *Data) *corev1.ConfigMap {","\tcategories := \"\"","\tfor _, c := range hubUrlConfigdata.Categories {","\t\tcategories += fmt.Sprintf(\"- %s\\n\", c.Name)","\t}","\tcm.Data[\"CATEGORIES\"] = categories","","\tcatalogs := \"\"","\tfor _, c := range hubUrlConfigdata.Catalogs {","\t\tcatalogs = catalogs + getCatalogData(c, th)","\t}","\tcm.Data[\"CATALOGS\"] = catalogs","","\tuserScopes := \"\"","\tfor _, s := range hubUrlConfigdata.Scopes {","\t\tscope := \"\"","\t\tscope += fmt.Sprintf(\"- name: %s\\n\", s.Name)","\t\tscope += fmt.Sprintf(\"  users: [%s]\\n\", strings.Join(s.Users, \", \"))","\t\tuserScopes = userScopes + scope","\t}","\tcm.Data[\"SCOPES\"] = userScopes","","\tdefaultScopes := \"\"","\tscopes := fmt.Sprintf(\"%s\\n\", defaultScopes)","\tfor _, d := range hubUrlConfigdata.Default.Scopes {","\t\tscopes += fmt.Sprintf(\"  - %s\\n\", d)","\t}","\tdefaultScopes = fmt.Sprintf(\" scopes: \\n%s\", scopes)","\tcm.Data[\"DEFAULT\"] = defaultScopes","","\treturn cm","}","","func getCatalogData(c v1alpha1.Catalog, th *v1alpha1.TektonHub) string {","\tcatalogs := \"\"","\tv := reflect.ValueOf(c)","","\tfor i := 0; i \u003c v.NumField(); i++ {","\t\tcat := \"\"","\t\tkey := strings.ToLower(v.Type().Field(i).Name)","","\t\tif v.Field(i).Interface() != \"\" {","\t\t\tif key == \"name\" {","\t\t\t\tkey = \"- \" + key","\t\t\t\tcat += fmt.Sprintf(\"%s: %s\\n\", key, v.Field(i).Interface())","\t\t\t} else {","\t\t\t\tcat += fmt.Sprintf(\"  %s: %s\\n\", key, v.Field(i).Interface())","\t\t\t}","\t\t\tcatalogs = catalogs + cat","\t\t}","\t}","\treturn catalogs","}","","// TODO: Remove this function in the next release","func getConfigDataFromHubURL(th *v1alpha1.TektonHub) (*Data, error) {","\tvar data = \u0026Data{}","\tif th.Spec.Api.HubConfigUrl != \"\" {","\t\tresp, err := http.Get(th.Spec.Api.HubConfigUrl)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\tdefer resp.Body.Close()","","\t\tbody, err := io.ReadAll(resp.Body)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","","\t\tviper.SetConfigType(\"yaml\")","\t\tif err := viper.ReadConfig(bytes.NewBuffer(body)); err != nil {","\t\t\treturn nil, err","\t\t}","\t\tif err := viper.Unmarshal(\u0026data); err != nil {","\t\t\treturn nil, err","\t\t}","\t}","","\treturn data, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,0]},{"id":94,"path":"pkg/reconciler/kubernetes/tektonhub/transform.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonhub","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"knative.dev/pkg/logging\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tlogger := logging.FromContext(ctx)","\t\thubCR := comp.(*v1alpha1.TektonHub)","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.HubImagePrefix))","\t\timages := common.ImageRegistryDomainOverride(imagesRaw)","","\t\ttrans := extension.Transformers(hubCR)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdHub),","\t\t\tmf.InjectOwner(hubCR),","\t\t\tmf.InjectNamespace(hubCR.Spec.GetTargetNamespace()),","\t\t\tcommon.DeploymentImages(images),","\t\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\t\tcommon.JobImages(images),","\t\t\tupdateApiConfigMap(hubCR, apiConfigMapName),","\t\t\taddConfigMapKeyValue(uiConfigMapName, \"API_URL\", hubCR.Status.ApiRouteUrl),","\t\t\taddConfigMapKeyValue(uiConfigMapName, \"AUTH_BASE_URL\", hubCR.Status.AuthRouteUrl),","\t\t\taddConfigMapKeyValue(uiConfigMapName, \"API_VERSION\", \"v1\"),","\t\t\taddConfigMapKeyValue(uiConfigMapName, \"REDIRECT_URI\", hubCR.Status.UiRouteUrl),","\t\t\taddConfigMapKeyValue(uiConfigMapName, \"CUSTOM_LOGO_BASE64_DATA\", hubCR.Spec.CustomLogo.Base64Data),","\t\t\taddConfigMapKeyValue(uiConfigMapName, \"CUSTOM_LOGO_MEDIA_TYPE\", hubCR.Spec.CustomLogo.MediaType),","\t\t\tcommon.AddDeploymentRestrictedPSA(),","\t\t\tcommon.AddJobRestrictedPSA(),","\t\t}","","\t\ttrans = append(trans, extra...)","","\t\terr := common.Transform(ctx, manifest, hubCR, trans...)","\t\tif err != nil {","\t\t\tlogger.Error(\"failed to transform manifest\")","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, hubCR.Spec.GetTargetNamespace(), hubCR.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0]},{"id":95,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/check.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\t\"go.uber.org/zap\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/logging\"",")","","func (i *InstallerSetClient) checkSet(ctx context.Context, comp v1alpha1.TektonComponent, isType string) ([]v1alpha1.TektonInstallerSet, error) {","\tlogger := logging.FromContext(ctx)","","\tlabelSelector := i.getSetLabels(isType)","\tlogger.Debugf(\"%v/%v: checking installer sets with labels: %v\", i.resourceKind, isType, labelSelector)","","\tis, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: labelSelector})","\tif err != nil {","\t\treturn nil, err","\t}","","\tlogger.Debugf(\"%v/%v: found %v installer sets\", i.resourceKind, isType, len(is.Items))","","\tiSets := is.Items","","\tif len(iSets) == 0 {","\t\tlogger.Debugf(\"%v/%v: installer sets not found\", i.resourceKind, isType)","\t\treturn nil, ErrNotFound","\t}","","\tif len(iSets) == 1 {","\t\tif iSets[0].DeletionTimestamp != nil {","\t\t\treturn iSets, ErrSetsInDeletionState","\t\t}","\t} else {","\t\tif iSets[0].DeletionTimestamp != nil || iSets[1].DeletionTimestamp != nil {","\t\t\treturn iSets, ErrSetsInDeletionState","\t\t}","\t}","","\tswitch isType {","\tcase InstallerTypeMain:","\t\tif err := verifyMainInstallerSets(iSets); err != nil {","\t\t\tlogger.Errorf(\"%v/%v: failed to verify main sets: %v\", i.resourceKind, isType, err)","\t\t\treturn iSets, err","\t\t}","\tcase InstallerTypePre, InstallerTypePost:","\t\tif len(iSets) != 1 {","\t\t\tlogger.Errorf(\"%v/%v: found multiple sets, expected one\", i.resourceKind, isType)","\t\t\treturn iSets, ErrInvalidState","\t\t}","\tdefault:","\t\tif !strings.HasPrefix(isType, InstallerTypeCustom) {","\t\t\treturn nil, fmt.Errorf(\"invalid installerSet type\")","\t\t}","\t\tif len(iSets) != 1 {","\t\t\tlogger.Errorf(\"%v/%v: found multiple sets, expected one\", i.resourceKind, isType)","\t\t\treturn iSets, ErrInvalidState","\t\t}","\t}","","\tif err := verifyMeta(i.resourceKind, isType, logger, iSets[0], comp, i.releaseVersion); err != nil {","\t\tlogger.Errorf(\"%v/%v: meta check failed for installer type: %v\", i.resourceKind, isType, err)","\t\treturn iSets, err","\t}","\tlogger.Debugf(\"%v/%v: meta check passed\", i.resourceKind, isType)","","\treturn iSets, nil","}","","func verifyMainInstallerSets(iSets []v1alpha1.TektonInstallerSet) error {","\tif len(iSets) != 2 {","\t\treturn ErrInvalidState","\t}","\tvar static, deployment bool","\tif strings.Contains(iSets[0].GetName(), InstallerSubTypeStatic) ||","\t\tstrings.Contains(iSets[1].GetName(), InstallerSubTypeStatic) {","\t\tstatic = true","\t}","\tif strings.Contains(iSets[0].GetName(), InstallerSubTypeDeployment) ||","\t\tstrings.Contains(iSets[1].GetName(), InstallerSubTypeDeployment) ||","\t\tstrings.Contains(iSets[0].GetName(), InstallerSubTypeStatefulset) ||","\t\tstrings.Contains(iSets[1].GetName(), InstallerSubTypeStatefulset) {","\t\tdeployment = true","\t}","\tif !(static \u0026\u0026 deployment) {","\t\treturn ErrInvalidState","\t}","\treturn nil","}","","func verifyMeta(resourceKind, isType string, logger *zap.SugaredLogger, set v1alpha1.TektonInstallerSet, comp v1alpha1.TektonComponent, releaseVersion string) error {","\t// Release Version Check","\tlogger.Debugf(\"%v/%v: release version check\", resourceKind, isType)","","\trVel, ok := set.GetLabels()[v1alpha1.ReleaseVersionKey]","\tif !ok {","\t\treturn ErrInvalidState","\t}","\tif rVel != releaseVersion {","\t\treturn ErrVersionDifferent","\t}","","\t// Target namespace check","\tlogger.Debugf(\"%v/%v: target namespace check\", resourceKind, isType)","","\ttargetNamespace, ok := set.GetAnnotations()[v1alpha1.TargetNamespaceKey]","\tif !ok {","\t\treturn ErrInvalidState","\t}","\tif targetNamespace != comp.GetSpec().GetTargetNamespace() {","\t\treturn ErrNsDifferent","\t}","","\t// Spec Hash Check","\tlogger.Debugf(\"%v/%v: spec hash check\", resourceKind, isType)","","\texpectedHash, err := hash.Compute(comp.GetSpec())","\tif err != nil {","\t\treturn err","\t}","\tonClusterHash, ok := set.GetAnnotations()[v1alpha1.LastAppliedHashKey]","\tif !ok {","\t\treturn ErrInvalidState","\t}","\tif onClusterHash != expectedHash {","\t\treturn ErrUpdateRequired","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,0,2,2,1,1,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,0,0,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,2,2,2,0,0,2,2,2,2,1,1,2,2,2,0,0,2,2,2,2,1,1,2,2,1,1,2,2,2,0,2,0]},{"id":96,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/cleanup.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/selection\"","\t\"knative.dev/pkg/logging\"",")","","var deletePropagationPolicy = metav1.DeletePropagationForeground","","func (i *InstallerSetClient) CleanupMainSet(ctx context.Context) error {","\tlogger := logging.FromContext(ctx).With(\"kind\", i.resourceKind, \"type\", InstallerTypeMain)","","\tlist, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabels(InstallerTypeMain)})","\tif err != nil {","\t\treturn err","\t}","","\tif len(list.Items) == 0 {","\t\tlogger.Debugf(\"no installerSets found for %s, nothing to clean up\", InstallerTypeMain)","\t\treturn nil","\t}","","\tif len(list.Items) != 2 {","\t\tlogger.Warnf(\"found %d installerSets for %s when expecting 2, proceeding with cleanup\",","\t\t\tlen(list.Items), InstallerTypeMain)","\t}","","\t// delete all static installerSet first and then deployment one","\tfor _, is := range list.Items {","\t\tif strings.Contains(is.GetName(), InstallerSubTypeStatic) {","\t\t\tlogger.Debugf(\"deleting main-static installer set: %s\", is.GetName())","\t\t\terr = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{","\t\t\t\tPropagationPolicy: \u0026deletePropagationPolicy,","\t\t\t})","\t\t\tif err != nil {","\t\t\t\treturn fmt.Errorf(\"failed to delete main-static installer set for %s\", is.GetName())","\t\t\t}","\t\t}","\t}","","\t// now delete all deployment installerSet","\tfor _, is := range list.Items {","\t\tif strings.Contains(is.GetName(), InstallerSubTypeDeployment) ||","\t\t\tstrings.Contains(is.GetName(), InstallerSubTypeStatefulset) {","\t\t\tlogger.Debugf(\"deleting main-deployment installer set: %s\", is.GetName())","\t\t\terr = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{","\t\t\t\tPropagationPolicy: \u0026deletePropagationPolicy,","\t\t\t})","\t\t\tif err != nil {","\t\t\t\treturn fmt.Errorf(\"failed to delete main-deployment installer set for %s\", is.GetName())","\t\t\t}","\t\t}","\t}","\treturn nil","}","","func (i *InstallerSetClient) CleanupSet(ctx context.Context, setType string) error {","\treturn i.cleanup(ctx, setType)","}","","func (i *InstallerSetClient) CleanupPreSet(ctx context.Context) error {","\treturn i.cleanup(ctx, InstallerTypePre)","}","","func (i *InstallerSetClient) CleanupPostSet(ctx context.Context) error {","\treturn i.cleanup(ctx, InstallerTypePost)","}","","func (i *InstallerSetClient) CleanupCustomSet(ctx context.Context, customName string) error {","\tsetType := InstallerTypeCustom + \"-\" + strings.ToLower(customName)","\treturn i.cleanup(ctx, setType)","}","","func (i *InstallerSetClient) CleanupAllCustomSet(ctx context.Context) error {","\tlabelSelector := labels.NewSelector()","\tcreatedReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})","\tif createdReq != nil {","\t\tlabelSelector = labelSelector.Add(*createdReq)","\t}","\terr := i.clientSet.DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{","\t\tLabelSelector: labelSelector.String(),","\t})","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to delete %s custom sets: %v\", i.resourceKind, err)","\t}","\treturn nil","}","","func (i *InstallerSetClient) cleanup(ctx context.Context, isType string) error {","\tlogger := logging.FromContext(ctx).With(\"kind\", i.resourceKind, \"type\", isType)","","\tlist, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabels(isType)})","\tif err != nil {","\t\treturn err","\t}","","\tif len(list.Items) == 0 {","\t\tlogger.Debugf(\"no installerSets found for %s, nothing to clean up\", isType)","\t\treturn nil","\t}","","\tif len(list.Items) \u003e 1 {","\t\tlogger.Warnf(\"found %d installerSets for %s when expecting at most 1, cleaning up all matching %s\",","\t\t\tlen(list.Items), isType, isType)","\t}","","\tfor _, is := range list.Items {","\t\tlogger.Debugf(\"deleting %s installer set: %s\", isType, is.GetName())","\t\terr = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{","\t\t\tPropagationPolicy: \u0026deletePropagationPolicy,","\t\t})","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"failed to delete %s set: %s\", isType, is.GetName())","\t\t}","\t}","\treturn nil","}","","func (i *InstallerSetClient) CleanupSubTypeDeployment(ctx context.Context) error {","\treturn i.cleanupSubType(ctx, InstallerTypeMain, InstallerSubTypeDeployment)","}","","func (i *InstallerSetClient) CleanupSubTypeStatefulset(ctx context.Context) error {","\treturn i.cleanupSubType(ctx, InstallerTypeMain, InstallerSubTypeStatefulset)","}","","func (i *InstallerSetClient) cleanupSubType(ctx context.Context, isType string, isSubType string) error {","\tlogger := logging.FromContext(ctx).With(\"kind\", i.resourceKind, \"type\", isType)","","\tlist, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabels(isType)})","\tif err != nil {","\t\treturn err","\t}","","\tif len(list.Items) == 0 {","\t\tlogger.Debugf(\"no installerSets found for %s, nothing to clean up\", isType)","\t\treturn nil","\t}","","\tif len(list.Items) \u003e 1 {","\t\tlogger.Warnf(\"found %d installerSets for %s when expecting at most 1, cleaning up all matching %s\",","\t\t\tlen(list.Items), isType, isSubType)","\t}","","\tfor _, is := range list.Items {","\t\tif strings.Contains(is.GetName(), isSubType) {","\t\t\tlogger.Debugf(\"deleting %s installer set: %s\", isType, is.GetName())","\t\t\terr = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{","\t\t\t\tPropagationPolicy: \u0026deletePropagationPolicy,","\t\t\t})","\t\t\tif err != nil {","\t\t\t\treturn fmt.Errorf(\"failed to delete %s set: %s\", isType, is.GetName())","\t\t\t}","\t\t}","\t}","\treturn nil","}","","func (i *InstallerSetClient) CleanupWithLabelInstallTypeDeployment(ctx context.Context, isType string) error {","\treturn i.cleanupWithLabel(ctx, isType, InstallerSubTypeDeployment)","}","","func (i *InstallerSetClient) CleanupWithLabelInstallTypeStatefulset(ctx context.Context, isType string) error {","\treturn i.cleanupWithLabel(ctx, isType, InstallerSubTypeStatefulset)","}","","// cleanupWithLabel cleans installersets using isType as label selector example","// v1alpha1.InstallerSetType: chain and v1alpha1.InstallerSetInstallType: deployment","func (i *InstallerSetClient) cleanupWithLabel(ctx context.Context, isType string, isInstallType string) error {","\tlogger := logging.FromContext(ctx).With(\"kind\", i.resourceKind, \"type\", isType)","","\tlist, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabelsWithTypeAndInstallType(isType, isInstallType)})","\tif err != nil {","\t\treturn err","\t}","","\tif len(list.Items) == 0 {","\t\tlogger.Debugf(\"no installerSets found for %s, nothing to clean up\", isType)","\t\treturn nil","\t}","","\tif len(list.Items) \u003e 1 {","\t\tlogger.Warnf(\"found %d installerSets for %s when expecting at most 1, cleaning up all matching %s\",","\t\t\tlen(list.Items), isType, isInstallType)","\t}","","\tfor _, is := range list.Items {","\t\tlogger.Debugf(\"deleting %s installer set: %s, of installType: %s\", isType, is.GetName(), isInstallType)","\t\terr = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{","\t\t\tPropagationPolicy: \u0026deletePropagationPolicy,","\t\t})","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"failed to delete %s set: %s\", isType, is.GetName())","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,1,0,2,1,1,1,0,2,1,1,1,0,0,2,2,2,2,2,2,2,1,1,0,0,0,0,2,2,2,2,2,2,2,2,1,1,0,0,2,0,0,2,2,2,0,2,2,2,0,2,2,2,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,1,1,0,2,1,1,1,0,2,1,1,1,0,2,2,2,2,2,2,1,1,0,2,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0]},{"id":97,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/client.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientSet \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"",")","","const (","\tInstallerSubTypeStatic      = \"static\"","\tInstallerSubTypeDeployment  = \"deployment\"","\tInstallerSubTypeStatefulset = \"statefulset\"","","\tInstallerTypeMain   = \"main\"","\tInstallerTypePre    = \"pre\"","\tInstallerTypePost   = \"post\"","\tInstallerTypeCustom = \"custom\"",")","","var (","\tErrInvalidState        = fmt.Errorf(\"installer sets in invalid state\")","\tErrNotFound            = fmt.Errorf(\"installer sets not found\")","\tErrVersionDifferent    = fmt.Errorf(\"installer sets release version doesn't match\")","\tErrNsDifferent         = fmt.Errorf(\"installer sets target namespace doesn't match\")","\tErrUpdateRequired      = fmt.Errorf(\"installer sets needs to be updated\")","\tErrSetsInDeletionState = fmt.Errorf(\"installer sets are in deletion state, will come back\")",")","","type FilterAndTransform func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error)","","type InstallerSetClient struct {","\tclientSet        clientSet.TektonInstallerSetInterface","\treleaseVersion   string","\tcomponentVersion string","\tresourceKind     string","\tmetrics          Metrics","}","","func NewInstallerSetClient(clientSet clientSet.TektonInstallerSetInterface, releaseVersion, componentVersion string, resourceKind string, metrics Metrics) *InstallerSetClient {","\treturn \u0026InstallerSetClient{","\t\tclientSet:        clientSet,","\t\treleaseVersion:   releaseVersion,","\t\tresourceKind:     resourceKind,","\t\tmetrics:          metrics,","\t\tcomponentVersion: componentVersion,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2]},{"id":98,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/create.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","\t\"time\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"",")","","func (i *InstallerSetClient) create(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, isType string, customLabels map[string]string) ([]v1alpha1.TektonInstallerSet, error) {","\tlogger := logging.FromContext(ctx).With(\"kind\", i.resourceKind, \"type\", isType)","","\tif isType == InstallerTypeMain {","\t\tsets, err := i.makeMainSets(ctx, comp, manifest)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"installer set creation failed for main type: %v\", err)","\t\t\treturn sets, err","\t\t}","\t\treturn sets, nil","\t}","","\tkind := strings.ToLower(strings.TrimPrefix(i.resourceKind, \"Tekton\"))","\tisName := fmt.Sprintf(\"%s-%s-\", kind, isType)","","\tiS, err := i.makeInstallerSet(ctx, comp, manifest, isName, isType, customLabels)","\tif err != nil {","\t\treturn nil, err","\t}","","\tiS, err = i.clientSet.Create(ctx, iS, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn []v1alpha1.TektonInstallerSet{*iS}, nil","}","","func (i *InstallerSetClient) makeMainSets(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest) ([]v1alpha1.TektonInstallerSet, error) {","\tstaticManifest := manifest.Filter(mf.Not(mf.ByKind(\"Deployment\")), mf.Not(mf.ByKind(\"Service\")))","\tdeploymentManifest := manifest.Filter(mf.Any(mf.ByKind(\"Deployment\"), mf.ByKind(\"Service\")))","\tstatefulSetManifest := manifest.Filter(mf.Any(mf.ByKind(\"StatefulSet\"), mf.Any(mf.ByKind(\"Deployment\")), mf.ByKind(\"Service\")))","","\tkind := strings.ToLower(strings.TrimPrefix(i.resourceKind, \"Tekton\"))","\tstaticName := fmt.Sprintf(\"%s-%s-%s-\", kind, InstallerTypeMain, InstallerSubTypeStatic)","","\tstaticIS, err := i.makeInstallerSet(ctx, comp, \u0026staticManifest, staticName, InstallerTypeMain, nil)","\tif err != nil {","\t\treturn nil, err","\t}","\tstaticIS, err = i.clientSet.Create(ctx, staticIS, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tif err := i.waitForStatus(ctx, staticIS); err != nil {","\t\treturn nil, err","\t}","","\tdeployName := fmt.Sprintf(\"%s-%s-%s-\", kind, InstallerTypeMain, InstallerSubTypeDeployment)","","\tdeploymentIS, err := i.makeInstallerSet(ctx, comp, \u0026deploymentManifest, deployName, InstallerTypeMain, nil)","\tif err != nil {","\t\treturn nil, err","\t}","","\tdeploymentIS, err = i.clientSet.Create(ctx, deploymentIS, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tstatefulSet := false","\tif pipeline, ok := comp.(*v1alpha1.TektonPipeline); ok {","\t\tstatefulSet = pipeline.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *pipeline.Spec.Performance.StatefulsetOrdinals","\t}","\tif statefulSet {","\t\tstsName := fmt.Sprintf(\"%s-%s-%s-\", kind, InstallerTypeMain, InstallerSubTypeStatefulset)","\t\tstsIS, err := i.makeInstallerSet(ctx, comp, \u0026statefulSetManifest, stsName, InstallerTypeMain, nil)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","","\t\tstsIS, err = i.clientSet.Create(ctx, stsIS, metav1.CreateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn []v1alpha1.TektonInstallerSet{*staticIS, *deploymentIS, *stsIS}, nil","\t}","","\treturn []v1alpha1.TektonInstallerSet{*staticIS, *deploymentIS}, nil","}","","func (i *InstallerSetClient) waitForStatus(ctx context.Context, set *v1alpha1.TektonInstallerSet) error {","\tfor cnt := 0; cnt \u003c 3; cnt++ {","\t\tonClusterSet, err := i.clientSet.Get(ctx, set.GetName(), metav1.GetOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\t// once status is initialised for static set we can create deployment set","\t\tready := onClusterSet.Status.GetCondition(apis.ConditionReady)","\t\tif ready != nil {","\t\t\treturn nil","\t\t}","\t\t// if status is not initialised then wait","\t\ttime.Sleep(3 * time.Second)","\t}","\t// if still the status is not initialised then create the next set and let it fail","\t// there may be something else wrong","\treturn nil","}","","func (i *InstallerSetClient) makeInstallerSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, isName, isType string, customLabels map[string]string) (*v1alpha1.TektonInstallerSet, error) {","\tspecHash, err := hash.Compute(comp.GetSpec())","\tif err != nil {","\t\treturn nil, err","\t}","","\t// get default labels of installerset","\tlabels := i.getDefaultLabels(isType)","\t// append custom labels","\tfor key, value := range customLabels {","\t\tlabels[key] = value","\t}","","\townerRef := *metav1.NewControllerRef(comp, v1alpha1.SchemeGroupVersion.WithKind(i.resourceKind))","\treturn \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: isName,","\t\t\tLabels:       labels,","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: comp.GetSpec().GetTargetNamespace(),","\t\t\t\tv1alpha1.LastAppliedHashKey: specHash,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}, nil","}","","func (i *InstallerSetClient) getDefaultLabels(isType string) map[string]string {","\tlabels := map[string]string{}","\tlabels[v1alpha1.CreatedByKey] = i.resourceKind","\tlabels[v1alpha1.ReleaseVersionKey] = i.releaseVersion","\tlabels[v1alpha1.InstallerSetType] = isType","\treturn labels","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,1,1,1,2,0,0,2,2,2,2,2,1,1,0,2,2,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,0,2,1,1,0,2,2,2,2,1,1,0,2,2,1,1,0,2,2,1,1,2,1,1,1,1,1,0,1,1,1,1,1,0,0,2,0,0,2,2,2,2,1,1,0,2,2,1,1,0,2,0,0,0,2,0,0,2,2,2,1,1,0,0,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2]},{"id":99,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/custom_versioned_clustertask.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    hcompp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/logging\"",")","","// VersionedTaskSet this is an exception case where we create one installer set for one minor version","// not for patch version, and we don't remove older installer sets on upgrade, hence keeping it different","// from custom set otherwise code becomes unnecessarily complex to handle this case","func (i *InstallerSetClient) VersionedTaskSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest,","\tfilterAndTransform FilterAndTransform, insType, insName string) error {","\tlogger := logging.FromContext(ctx)","","\t// perform transformation","\tmanifestUpdated, err := filterAndTransform(ctx, manifest, comp)","\tif err != nil {","\t\tlogger.Errorw(\"error on transforming a manifest\",","\t\t\t\"component\", comp.GroupVersionKind().String(),","\t\t\t\"componentName\", comp.GetName(),","\t\t)","\t\treturn err","\t}","","\tsetType := fmt.Sprintf(\"%s-%s\", InstallerTypeCustom, strings.ToLower(insType))","\tversionedTaskLS := v1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.InstallerSetType:       setType,","\t\t\tv1alpha1.ReleaseMinorVersionKey: getPatchVersionTrimmed(i.releaseVersion),","\t\t},","\t}","\tversionedTaskLabelSelector, err := common.LabelSelector(versionedTaskLS)","\tif err != nil {","\t\treturn err","\t}","\tis, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: versionedTaskLabelSelector})","\tif err != nil {","\t\treturn err","\t}","","\tif len(is.Items) == 0 {","\t\tvctSet, err := i.makeInstallerSet(ctx, comp, manifestUpdated, insName, setType, nil)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tvctSet.Labels[v1alpha1.ReleaseMinorVersionKey] = getPatchVersionTrimmed(i.releaseVersion)","\t\tvctSet.GenerateName = fmt.Sprintf(\"%s-%s-\", insName, getPatchVersionTrimmed(i.releaseVersion))","","\t\t_, err = i.clientSet.Create(ctx, vctSet, metav1.CreateOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\tif err := i.statusCheck(logger, setType, is.Items); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func getPatchVersionTrimmed(version string) string {","\tendIndex := strings.LastIndex(version, \".\")","\tif endIndex != -1 {","\t\tversion = version[:endIndex]","\t}","\treturn version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0]},{"id":100,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/fake/client.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package fake","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tv1alpha12 \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/apimachinery/pkg/watch\"",")","","type fakeClient struct {","\tresource map[string]*v1alpha1.TektonInstallerSet","}","","func NewFakeISClient(is ...*v1alpha1.TektonInstallerSet) v1alpha12.TektonInstallerSetInterface {","\tclient := \u0026fakeClient{","\t\tresource: map[string]*v1alpha1.TektonInstallerSet{},","\t}","\tfor _, r := range is {","\t\tinst := r","\t\tclient.resource[inst.GetName()] = inst","\t}","\treturn client","}","","func (f fakeClient) Create(ctx context.Context, tektonInstallerSet *v1alpha1.TektonInstallerSet, opts metav1.CreateOptions) (*v1alpha1.TektonInstallerSet, error) {","\ttektonInstallerSet.SetName(tektonInstallerSet.GenerateName + \"test\")","\tif _, ok := f.resource[tektonInstallerSet.GetName()]; ok {","\t\treturn nil, errors.NewAlreadyExists(schema.GroupResource{","\t\t\tGroup:    v1alpha1.GroupName,","\t\t\tResource: v1alpha1.KindTektonInstallerSet,","\t\t}, tektonInstallerSet.GetName())","\t}","\tf.resource[tektonInstallerSet.GetName()] = tektonInstallerSet","\treturn tektonInstallerSet, nil","}","","func (f fakeClient) Update(ctx context.Context, tektonInstallerSet *v1alpha1.TektonInstallerSet, opts metav1.UpdateOptions) (*v1alpha1.TektonInstallerSet, error) {","\tf.resource[tektonInstallerSet.GetName()] = tektonInstallerSet","\treturn f.resource[tektonInstallerSet.GetName()], nil","}","","func (f fakeClient) UpdateStatus(ctx context.Context, tektonInstallerSet *v1alpha1.TektonInstallerSet, opts metav1.UpdateOptions) (*v1alpha1.TektonInstallerSet, error) {","\tf.resource[tektonInstallerSet.GetName()] = tektonInstallerSet","\treturn f.resource[tektonInstallerSet.GetName()], nil","}","","func (f fakeClient) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error {","\tdelete(f.resource, name)","\treturn nil","}","","func (f fakeClient) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (f fakeClient) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1alpha1.TektonInstallerSet, error) {","\tif res, ok := f.resource[name]; ok {","\t\treturn res, nil","\t}","\treturn nil, fmt.Errorf(\"resource not found\")","}","","func (f fakeClient) List(ctx context.Context, opts metav1.ListOptions) (*v1alpha1.TektonInstallerSetList, error) {","\tlist := []v1alpha1.TektonInstallerSet{}","\tfor i := range f.resource {","\t\tlist = append(list, *f.resource[i])","\t}","\treturn \u0026v1alpha1.TektonInstallerSetList{Items: list}, nil","}","","func (f fakeClient) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) {","\t//TODO implement me","\tpanic(\"implement me\")","}","","func (f fakeClient) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1alpha1.TektonInstallerSet, err error) {","\t//TODO implement me","\tpanic(\"implement me\")","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,0]},{"id":101,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/labels.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/selection\"",")","","func (i *InstallerSetClient) getSetLabels(setType string) string {","\tlabelSelector := labels.NewSelector()","\tcreatedReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})","\tif createdReq != nil {","\t\tlabelSelector = labelSelector.Add(*createdReq)","\t}","\ttypeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetType, selection.Equals, []string{setType})","\tif typeReq != nil {","\t\tlabelSelector = labelSelector.Add(*typeReq)","\t}","\treturn labelSelector.String()","}","","func (i *InstallerSetClient) getSetLabelsWithTypeAndInstallType(setType, setInstallType string) string {","\tlabelSelector := labels.NewSelector()","\tcreatedReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})","\tif createdReq != nil {","\t\tlabelSelector = labelSelector.Add(*createdReq)","\t}","\ttypeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetType, selection.Equals, []string{setType})","\tif typeReq != nil {","\t\tlabelSelector = labelSelector.Add(*typeReq)","\t}","\tinstalltypeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetInstallType, selection.Equals, []string{setInstallType})","\tif installtypeReq != nil {","\t\tlabelSelector = labelSelector.Add(*installtypeReq)","\t}","\treturn labelSelector.String()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":102,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/list.go","lines":["/*","Copyright 2024 The Tekton Authors","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/logging\"",")","","// ListCustomSet return the lists of custom sets with the provided labelSelector","func (i *InstallerSetClient) ListCustomSet(ctx context.Context, labelSelector string) (*v1alpha1.TektonInstallerSetList, error) {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugf(\"%v: checking installer sets with labels: %v\", i.resourceKind, labelSelector)","","\tis, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: labelSelector})","\tif err != nil {","\t\treturn nil, err","\t}","\tif len(is.Items) == 0 {","\t\tlogger.Debugf(\"%v: no installer sets found with labels: %v\", i.resourceKind, labelSelector)","\t}","\treturn is, nil","}","","// ListPreSet return the lists of Pre sets with the provided labelSelector","func (i *InstallerSetClient) ListPreSet(ctx context.Context, labelSelector string) (*v1alpha1.TektonInstallerSetList, error) {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugf(\"%v: checking installer sets with labels: %v\", i.resourceKind, labelSelector)","","\tis, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: labelSelector})","\tif err != nil {","\t\treturn nil, err","\t}","\tif len(is.Items) == 0 {","\t\tlogger.Debugf(\"%v: no installer sets found with labels: %v\", i.resourceKind, labelSelector)","\t}","\treturn is, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":103,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/main_set.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tmetricsNew     = \"NewInstall\"","\tmetricsUpgrade = \"Upgrade\"",")","","func (i *InstallerSetClient) MainSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, filterAndTransform FilterAndTransform) error {","\tlogger := logging.FromContext(ctx)","\tsetType := InstallerTypeMain","","\t// perform transformation","\tmanifestUpdated, err := filterAndTransform(ctx, manifest, comp)","\tif err != nil {","\t\tlogger.Errorw(\"error on transforming a manifest\",","\t\t\t\"component\", comp.GroupVersionKind().String(),","\t\t\t\"componentName\", comp.GetName(),","\t\t)","\t\treturn err","\t}","","\tsets, err := i.checkSet(ctx, comp, setType)","\tif err == nil {","\t\tlogger.Debugf(\"%v/%v: found %v installer sets\", i.resourceKind, setType, len(sets))","\t}","","\tswitch err {","\tcase ErrNotFound:","\t\tlogger.Debugf(\"%v/%v: installer set not found, creating\", i.resourceKind, setType)","\t\tsets, err = i.create(ctx, comp, manifestUpdated, setType, nil)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"%v/%v: failed to create main installer set: %v\", i.resourceKind, setType, err)","\t\t\treturn err","\t\t}","\t\tif comp.GetStatus().GetCondition(v1alpha1.InstallerSetAvailable).IsUnknown() {","\t\t\ti.metrics.LogMetrics(metricsNew, i.componentVersion, logger)","\t\t}","","\tcase ErrInvalidState, ErrNsDifferent, ErrVersionDifferent:","\t\tlogger.Debugf(\"%v/%v: installer set not in valid state : %v, cleaning up!\", i.resourceKind, setType, err)","\t\tif err := i.CleanupMainSet(ctx); err != nil {","\t\t\tlogger.Errorf(\"%v/%v: failed to cleanup main installer set: %v\", i.resourceKind, setType, err)","\t\t\treturn err","\t\t}","\t\tif err == ErrVersionDifferent {","\t\t\ti.metrics.LogMetrics(metricsUpgrade, i.componentVersion, logger)","\t\t\tmarkComponentStatus(comp, v1alpha1.UpgradePending)","\t\t} else {","\t\t\tmarkComponentStatus(comp, v1alpha1.Reinstalling)","\t\t}","\t\tlogger.Debugf(\"%v/%v: returning, will create main installer sets in further reconcile\", i.resourceKind, setType)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","","\tcase ErrUpdateRequired:","\t\tlogger.Debugf(\"%v/%v: updating installer set\", i.resourceKind, setType)","\t\tsets, err = i.update(ctx, comp, sets, manifestUpdated, setType)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"%v/%v: update failed : %v\", i.resourceKind, setType, err)","\t\t\treturn err","\t\t}","\tcase ErrSetsInDeletionState:","\t\tlogger.Debugf(\"%v/%v: %v\", i.resourceKind, setType, err)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\t//Mark InstallerSet Available","\tcomp.GetStatus().MarkInstallerSetAvailable()","","\tif err := i.statusCheck(logger, setType, sets); err != nil {","\t\treturn err","\t}","","\t//Mark InstallerSet Ready","\tcomp.GetStatus().MarkInstallerSetReady()","","\treturn nil","}","","func (i *InstallerSetClient) statusCheck(logger *zap.SugaredLogger, setType string, sets []v1alpha1.TektonInstallerSet) error {","\tfor _, set := range sets {","\t\tready := set.Status.GetCondition(apis.ConditionReady)","\t\tif ready.IsUnknown() {","\t\t\tlogger.Debugf(\"%v/%v: installer set %v status not set, wait !\", i.resourceKind, setType, set.GetName())","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tif !ready.IsTrue() {","\t\t\tmsg := fmt.Sprintf(\"%v/%v: installer set not ready, will retry: %v\", i.resourceKind, setType, ready.Message)","\t\t\tlogger.Debugf(msg)","\t\t\treturn errors.New(msg)","\t\t}","\t}","\treturn nil","}","","func markComponentStatus(comp v1alpha1.TektonComponent, status string) {","\tcomp.GetStatus().MarkInstallerSetNotReady(status)","\tcomp.GetStatus().MarkInstallerSetNotReady(status)","\tcomp.GetStatus().MarkPostReconcilerFailed(status)","\tcomp.GetStatus().MarkNotReady(status)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,1,1,1,1,1,0,2,2,2,2,0,2,2,2,2,2,1,1,1,2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,1,1,1,1,1,1]},{"id":104,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/obsolete_sets.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/selection\"",")","","func (i *InstallerSetClient) RemoveObsoleteSets(ctx context.Context) error {","\tvar sets []string","","\tswitch i.resourceKind {","\tcase v1alpha1.KindTektonPipeline:","\t\tsets = []string{\"pipeline\", \"PrePipeline\", \"PostPipeline\"}","\tcase v1alpha1.KindTektonTrigger:","\t\tsets = []string{\"trigger\"}","\tcase v1alpha1.KindTektonChain:","\t\tsets = []string{\"chain\"}","\tcase v1alpha1.KindTektonAddon:","\t\t// not adding VersionedClusterTask here, as we keep versioned clustertasks on upgrade","\t\tsets = []string{\"ClusterTask\", \"CommunityClusterTask\", \"PipelinesTemplate\", \"TriggersResources\", \"ConsoleCLI\", \"MiscellaneousResources\", \"PipelinesAsCode\"}","\tcase v1alpha1.KindTektonDashboard:","\t\tsets = []string{\"dashboard\"}","\tcase v1alpha1.KindTektonPruner:","\t\tsets = []string{\"pruner-config\"}","\tcase v1alpha1.ManualApprovalGates:","\t\tsets = []string{\"manualapprovalgate\"}","\t}","","\tlabelSelector := labels.NewSelector()","\tcreatedReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})","\tif createdReq != nil {","\t\tlabelSelector = labelSelector.Add(*createdReq)","\t}","\ttypeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetType, selection.In, sets)","\tif typeReq != nil {","\t\tlabelSelector = labelSelector.Add(*typeReq)","\t}","\terr := i.clientSet.DeleteCollection(ctx, metav1.DeleteOptions{},","\t\tmetav1.ListOptions{LabelSelector: labelSelector.String()})","\tif err != nil {","\t\treturn err","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":105,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/pre_post_custom_set.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"knative.dev/pkg/logging\"",")","","func (i *InstallerSetClient) PostSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, filterAndTransform FilterAndTransform) error {","\treturn i.applyTransformationAndCreateSet(ctx, comp, InstallerTypePost, manifest, filterAndTransform, nil)","}","","func (i *InstallerSetClient) PreSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, filterAndTransform FilterAndTransform) error {","\treturn i.applyTransformationAndCreateSet(ctx, comp, InstallerTypePre, manifest, filterAndTransform, nil)","}","","func (i *InstallerSetClient) CustomSet(ctx context.Context, comp v1alpha1.TektonComponent, customName string, manifest *mf.Manifest, filterAndTransform FilterAndTransform, customLabels map[string]string) error {","\tsetType := InstallerTypeCustom + \"-\" + strings.ToLower(customName)","\treturn i.applyTransformationAndCreateSet(ctx, comp, setType, manifest, filterAndTransform, customLabels)","}","","func (i *InstallerSetClient) applyTransformationAndCreateSet(ctx context.Context, comp v1alpha1.TektonComponent, setType string, manifest *mf.Manifest, filterAndTransform FilterAndTransform, customLabels map[string]string) error {","\t// perform transformation","\tmanifestUpdated, err := filterAndTransform(ctx, manifest, comp)","\tif err != nil {","\t\tlogger := logging.FromContext(ctx)","\t\tlogger.Errorw(\"error on transforming a manifest\",","\t\t\t\"component\", comp.GroupVersionKind().String(),","\t\t\t\"componentName\", comp.GetName(),","\t\t)","\t\treturn err","\t}","\treturn i.createSet(ctx, comp, setType, manifestUpdated, customLabels)","}","","func (i *InstallerSetClient) createSet(ctx context.Context, comp v1alpha1.TektonComponent, setType string, manifest *mf.Manifest, customLabels map[string]string) error {","\tlogger := logging.FromContext(ctx)","","\tsets, err := i.checkSet(ctx, comp, setType)","\tif err == nil {","\t\tlogger.Debugf(\"%v/%v: found %v installer sets\", i.resourceKind, setType, len(sets))","\t}","","\tswitch err {","\tcase ErrNotFound:","\t\tlogger.Debugf(\"%v/%v: installer set not found, creating\", i.resourceKind, setType)","\t\tsets, err = i.create(ctx, comp, manifest, setType, customLabels)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"%v/%v: failed to create installer set: %v\", i.resourceKind, setType, err)","\t\t\treturn err","\t\t}","","\tcase ErrInvalidState, ErrNsDifferent, ErrVersionDifferent:","\t\tlogger.Debugf(\"%v/%v: installer set not in valid state : %v, cleaning up!\", i.resourceKind, setType, err)","\t\tif err := i.CleanupSet(ctx, setType); err != nil {","\t\t\tlogger.Errorf(\"%v/%v: failed to cleanup installer set: %v\", i.resourceKind, setType, err)","\t\t\treturn nil","\t\t}","\t\tlogger.Debugf(\"%v/%v: returning, will create installer sets in further reconcile\", i.resourceKind, setType)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","","\tcase ErrUpdateRequired:","\t\tlogger.Debugf(\"%v/%v: updating installer set\", i.resourceKind, setType)","\t\tsets, err = i.update(ctx, comp, sets, manifest, setType)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"%v/%v: update failed : %v\", i.resourceKind, setType, err)","\t\t\treturn err","\t\t}","\tcase ErrSetsInDeletionState:","\t\tlogger.Debugf(\"%v/%v: %v\", i.resourceKind, setType, err)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\tif err := i.statusCheck(logger, setType, sets); err != nil {","\t\treturn err","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,0,1,1,1,1,0,2,2,2,2,1,1,1,1,1,1,1,2,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,1,1,1,0,2,2,2,1,1,1,2,2,0,2,2,2,2,1,1,1,1,1,1,0,0,2,2,2,2,0]},{"id":106,"path":"pkg/reconciler/kubernetes/tektoninstallerset/client/update.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package client","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/util/retry\"","\t\"knative.dev/pkg/logging\"",")","","func (i *InstallerSetClient) update(ctx context.Context, comp v1alpha1.TektonComponent, toBeUpdatedIS []v1alpha1.TektonInstallerSet, manifest *mf.Manifest, isType string) ([]v1alpha1.TektonInstallerSet, error) {","\tlogger := logging.FromContext(ctx).With(\"kind\", i.resourceKind, \"type\", isType)","","\tif isType == InstallerTypeMain {","\t\tsets, err := i.updateMainSets(ctx, comp, toBeUpdatedIS, manifest)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"installer set update failed for main type: %v\", err)","\t\t\treturn sets, err","\t\t}","\t\treturn sets, nil","\t}","","\tlogger.Debugf(\"updating installer set: %v\", toBeUpdatedIS[0].GetName())","\tupdatedSet, err := i.updateSet(ctx, comp, toBeUpdatedIS[0], manifest)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to update installerset : %v\", err)","\t}","\tlogger.Debugf(\"updated installer set: %v\", toBeUpdatedIS[0].GetName())","\treturn []v1alpha1.TektonInstallerSet{*updatedSet}, nil","}","","func (i *InstallerSetClient) updateMainSets(ctx context.Context, comp v1alpha1.TektonComponent, toBeUpdatedIS []v1alpha1.TektonInstallerSet, manifest *mf.Manifest) ([]v1alpha1.TektonInstallerSet, error) {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugf(\"updating main installersets for %v\", i.resourceKind)","","\tstaticManifest := manifest.Filter(mf.Not(mf.ByKind(\"Deployment\")))","\tdeploymentManifest := manifest.Filter(mf.ByKind(\"Deployment\"))","","\tvar updatedSets []v1alpha1.TektonInstallerSet","","\tfor _, is := range toBeUpdatedIS {","\t\tlogger.Debugf(\"updating installer set: %v\", is.GetName())","","\t\tvar manifest *mf.Manifest","\t\tif strings.Contains(is.GetName(), InstallerSubTypeStatic) {","\t\t\tmanifest = \u0026staticManifest","\t\t} else {","\t\t\tmanifest = \u0026deploymentManifest","\t\t}","","\t\tupdatedSet, err := i.updateSet(ctx, comp, is, manifest)","\t\tif err != nil {","\t\t\treturn nil, fmt.Errorf(\"failed to update installerset : %v\", err)","\t\t}","","\t\tlogger.Debugf(\"updated installer set: %v\", is.GetName())","\t\tupdatedSets = append(updatedSets, *updatedSet)","\t}","\treturn updatedSets, nil","}","","func (i *InstallerSetClient) updateSet(ctx context.Context, comp v1alpha1.TektonComponent, set v1alpha1.TektonInstallerSet, manifest *mf.Manifest) (*v1alpha1.TektonInstallerSet, error) {","\tvar updatedSet *v1alpha1.TektonInstallerSet","\tretryErr := retry.RetryOnConflict(retry.DefaultRetry, func() error {","\t\tonCluster, err := i.clientSet.Get(ctx, set.GetName(), metav1.GetOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tspecHash, err := hash.Compute(comp.GetSpec())","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcurrent := onCluster.GetAnnotations()","\t\tcurrent[v1alpha1.LastAppliedHashKey] = specHash","\t\tonCluster.SetAnnotations(current)","","\t\tonCluster.Spec.Manifests = manifest.Resources()","","\t\tupdatedSet, err = i.clientSet.Update(ctx, onCluster, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\treturn nil","\t})","\tif retryErr != nil {","\t\treturn nil, retryErr","\t}","\treturn updatedSet, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,1,1,1,2,0,0,2,2,2,1,1,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,1,1,0,2,2,0,2,0,0,2,2,2,2,2,1,1,0,2,2,1,1,0,2,2,2,2,2,2,2,2,1,1,2,0,2,1,1,2,0]},{"id":107,"path":"pkg/reconciler/kubernetes/tektoninstallerset/controller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","","\tmfc \"github.com/manifestival/client-go-client\"","\t\"go.uber.org/zap\"","\t\"k8s.io/client-go/tools/cache\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonInstallerReconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektoninstallerset\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tdeploymentinformer \"knative.dev/pkg/client/injection/kube/informers/apps/v1/deployment\"","\tstatefulsetinformer \"knative.dev/pkg/client/injection/kube/informers/apps/v1/statefulset\"","\tserviceAccountInformer \"knative.dev/pkg/client/injection/kube/informers/core/v1/serviceaccount\"","\tclusterRoleInformer \"knative.dev/pkg/client/injection/kube/informers/rbac/v1/clusterrole\"","\tclusterRoleBindingInformer \"knative.dev/pkg/client/injection/kube/informers/rbac/v1/clusterrolebinding\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController()(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController() injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating client from injected config\", zap.Error(err))","\t\t}","","\t\tc := \u0026Reconciler{","\t\t\toperatorClientSet: operatorclient.Get(ctx),","\t\t\tmfClient:          mfclient,","\t\t\tkubeClientSet:     kubeclient.Get(ctx),","\t\t}","\t\timpl := tektonInstallerReconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for TektonInstallerSet\")","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\tif _, err := deploymentinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonInstallerSet{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register Deployment informer event handler: %w\", err)","\t\t}","","\t\tif _, err := statefulsetinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonInstallerSet{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register StatefulSet informer event handler: %w\", err)","\t\t}","","\t\tif _, err := clusterRoleBindingInformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonInstallerSet{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register ClusterRoleBinding informer event handler: %w\", err)","\t\t}","","\t\tif _, err := clusterRoleInformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonInstallerSet{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register ClusterRole informer event handler: %w\", err)","\t\t}","","\t\tif _, err := serviceAccountInformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonInstallerSet{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register ServiceAccount informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":108,"path":"pkg/reconciler/kubernetes/tektoninstallerset/install.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\t\"go.uber.org/zap\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tautoscalingv2 \"k8s.io/api/autoscaling/v2\"","\tbatchv1 \"k8s.io/api/batch/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/kubernetes/scheme\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"",")","","const (","\tannotationsPath = \"metadata.annotations\"","\tlabelsPath      = \"metadata.labels\"",")","","type installer struct {","\tmanifest        *mf.Manifest","\tmfClient        mf.Client","\tkubeClientSet   kubernetes.Interface","\tlogger          *zap.SugaredLogger","\tcrds            []unstructured.Unstructured","\tclusterScoped   []unstructured.Unstructured","\tnamespaceScoped []unstructured.Unstructured","\tdeployment      []unstructured.Unstructured","\tstatefulset     []unstructured.Unstructured","\tjob             []unstructured.Unstructured","}","","func NewInstaller(manifest *mf.Manifest, mfClient mf.Client, kubeClientSet kubernetes.Interface, logger *zap.SugaredLogger) *installer {","\tinstaller := \u0026installer{","\t\tmanifest:        manifest,","\t\tmfClient:        mfClient,","\t\tkubeClientSet:   kubeClientSet,","\t\tlogger:          logger,","\t\tcrds:            []unstructured.Unstructured{},","\t\tclusterScoped:   []unstructured.Unstructured{},","\t\tnamespaceScoped: []unstructured.Unstructured{},","\t\tdeployment:      []unstructured.Unstructured{},","\t\tstatefulset:     []unstructured.Unstructured{},","\t\tjob:             []unstructured.Unstructured{},","\t}","","\t// we filter out resource as some resources are dependent on others","\t// for eg. namespace should be created before configmap","\t// non k8s core resources like openshift resources will be classified as","\t// namespace scoped","\tfor _, res := range manifest.Resources() {","\t\tif strings.ToLower(res.GetKind()) == \"customresourcedefinition\" {","\t\t\tinstaller.crds = append(installer.crds, res)","\t\t\tcontinue","\t\t} else if res.GetKind() == \"Deployment\" {","\t\t\tinstaller.deployment = append(installer.deployment, res)","\t\t\tcontinue","\t\t} else if res.GetKind() == \"StatefulSet\" {","\t\t\tinstaller.statefulset = append(installer.statefulset, res)","\t\t\tcontinue","\t\t} else if res.GetKind() == \"Job\" {","\t\t\tinstaller.job = append(installer.job, res)","\t\t\tcontinue","\t\t}","\t\tif isClusterScoped(res.GetKind()) \u0026\u0026 strings.ToLower(res.GetKind()) != \"clusterrolebinding\" {","\t\t\tinstaller.clusterScoped = append(installer.clusterScoped, res)","\t\t\tcontinue","\t\t}","\t\tinstaller.namespaceScoped = append(installer.namespaceScoped, res)","\t}","\treturn installer","}","","// https://github.com/manifestival/manifestival/blob/af1baacf01ec54390c3cbd46ee561d52b2b4ab14/transform.go#L107","func isClusterScoped(kind string) bool {","\tswitch strings.ToLower(kind) {","\tcase \"componentstatus\",","\t\t\"namespace\",","\t\t\"node\",","\t\t\"persistentvolume\",","\t\t\"mutatingwebhookconfiguration\",","\t\t\"validatingwebhookconfiguration\",","\t\t\"customresourcedefinition\",","\t\t\"apiservice\",","\t\t\"meshpolicy\",","\t\t\"tokenreview\",","\t\t\"selfsubjectaccessreview\",","\t\t\"selfsubjectrulesreview\",","\t\t\"subjectaccessreview\",","\t\t\"certificatesigningrequest\",","\t\t\"clusterrolebinding\",","\t\t\"clusterrole\",","\t\t\"priorityclass\",","\t\t\"storageclass\",","\t\t\"volumeattachment\":","\t\treturn true","\t}","\treturn false","}","","func (i *installer) ensureResources(resources []unstructured.Unstructured) error {","\tfor _, r := range resources {","\t\tressourceLogger := i.logger.With(","\t\t\t\"kind\", r.GetKind(),","\t\t\t\"namespace\", r.GetNamespace(),","\t\t\t\"name\", r.GetName(),","\t\t)","\t\texpectedHash, err := hash.Compute(r.Object)","\t\tif err != nil {","\t\t\tressourceLogger.Error(\"failed to compute resource hash\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tressourceLogger.Debug(\"fetching resource\")","","\t\tres, err := i.mfClient.Get(\u0026r)","\t\tif err != nil {","\t\t\tif apierrs.IsNotFound(err) {","\t\t\t\tressourceLogger.Debug(\"creating new resource\")","\t\t\t\t// add hash on the resource of expected manifest and create","\t\t\t\tanno := r.GetAnnotations()","\t\t\t\tif anno == nil {","\t\t\t\t\tanno = map[string]string{}","\t\t\t\t}","\t\t\t\tanno[v1alpha1.LastAppliedHashKey] = expectedHash","\t\t\t\tr.SetAnnotations(anno)","\t\t\t\terr = i.mfClient.Create(\u0026r)","\t\t\t\tif err != nil {","\t\t\t\t\tressourceLogger.Error(\"failed to create resource\", \"error\", err)","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t\tressourceLogger.Debug(\"resource created successfully\")","\t\t\t\tcontinue","\t\t\t}","\t\t\tressourceLogger.Error(\"failed to get resource\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\tif res.GetDeletionTimestamp() != nil {","\t\t\tressourceLogger.Debug(\"resource is being deleted, will reconcile again\")","\t\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t\t}","","\t\tressourceLogger.Debug(\"resource exists, checking for updates\")","","\t\t// if resource exist then check if expected hash is different from the one","\t\t// on the resource","\t\thashOnResource := res.GetAnnotations()[v1alpha1.LastAppliedHashKey]","","\t\tif expectedHash == hashOnResource {","\t\t\tressourceLogger.Debug(\"resource is up-to-date, no changes needed\")","\t\t\tcontinue","\t\t}","","\t\tressourceLogger.Debug(\"resource needs update\",","\t\t\t\"currentHash\", hashOnResource,","\t\t\t\"expectedHash\", expectedHash)","","\t\tanno := r.GetAnnotations()","\t\tif anno == nil {","\t\t\tanno = map[string]string{}","\t\t}","\t\tanno[v1alpha1.LastAppliedHashKey] = expectedHash","\t\tr.SetAnnotations(anno)","","\t\tinstallManifests, err := mf.ManifestFrom(mf.Slice([]unstructured.Unstructured{r}), mf.UseClient(i.mfClient))","\t\tif err != nil {","\t\t\tressourceLogger.Error(\"failed to create manifest\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tif err := installManifests.Apply(); err != nil {","\t\t\tressourceLogger.Error(\"failed to apply manifest\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tressourceLogger.Debug(\"resource updated successfully\")","\t}","\treturn nil","}","","func (i *installer) EnsureCRDs() error {","\treturn i.ensureResources(i.crds)","}","","func (i *installer) EnsureClusterScopedResources() error {","\treturn i.ensureResources(i.clusterScoped)","}","","func (i *installer) EnsureNamespaceScopedResources() error {","\treturn i.ensureResources(i.namespaceScoped)","}","","func (i *installer) EnsureStatefulSetResources(ctx context.Context) error {","\tfor _, s := range i.statefulset {","\t\tif err := i.ensureResource(ctx, \u0026s); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := i.isStatefulSetAvailable(\u0026s); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func (i *installer) EnsureDeploymentResources(ctx context.Context) error {","\tfor _, d := range i.deployment {","\t\tif err := i.ensureResource(ctx, \u0026d); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func (i *installer) EnsureJobResources() error {","\treturn i.ensureResources(i.job)","}","","// list of fields should be reconciled","func (i *installer) resourceReconcileFields(u *unstructured.Unstructured) []string {","\tswitch u.GetKind() {","\tcase \"Deployment\", \"StatefulSet\":","\t\treturn []string{","\t\t\tannotationsPath,","\t\t\tlabelsPath,","\t\t\t\"spec\",","\t\t}","","\tdefault:","\t\treturn []string{}","\t}","}","","// this method is written as generic to all the resources","// currently tested with deployments and StatefulSet","// TODO: (jkandasa) needs to be tested with other resources too","func (i *installer) ensureResource(ctx context.Context, expected *unstructured.Unstructured) error {","\tloggerWithContext := i.logger.With(","\t\t\"name\", expected.GetName(),","\t\t\"namespace\", expected.GetNamespace(),","\t\t\"kind\", expected.GetKind(),","\t)","\tloggerWithContext.Debug(\"verifying a resource\")","","\t// update specific things to deployments and statefulSets","\tif expected.GetKind() == \"Deployment\" || expected.GetKind() == \"StatefulSet\" {","","\t\t// update proxy settings","\t\terr := common.ApplyProxySettings(expected)","\t\tif err != nil {","\t\t\tloggerWithContext.Errorw(\"failed to apply proxy settings\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// if a deployment or statefulSets managed by HPA, ignore replicas from user input(TektonConfig CR)","\t\t// and take replicas from HPA status(DesiredReplicas)","","\t\t// lists the available HPAs","\t\thpaList, err := i.kubeClientSet.AutoscalingV2().HorizontalPodAutoscalers(expected.GetNamespace()).List(ctx, metav1.ListOptions{})","\t\tif err != nil {","\t\t\tloggerWithContext.Errorw(\"failed to list HPAs\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// check the expected resource configured with HPA","\t\tvar hpa *autoscalingv2.HorizontalPodAutoscaler","\t\tfor _, _hpa := range hpaList.Items {","\t\t\ttarget := _hpa.Spec.ScaleTargetRef","\t\t\tif target.Kind == expected.GetKind() \u0026\u0026 target.Name == expected.GetName() {","\t\t\t\thpa = _hpa.DeepCopy()","\t\t\t\tbreak","\t\t\t}","\t\t}","","\t\t// if a hpa found to this resource, update replicas value from the hpa","\t\tif hpa != nil {","\t\t\thpaLogger := loggerWithContext.With(","\t\t\t\t\"hpaName\", hpa.GetName(),","\t\t\t\t\"hpaNamespace\", hpa.GetNamespace(),","\t\t\t)","\t\t\thpaLogger.Debug(\"HPA found for resource, verifying replicas\")","","\t\t\thpaScalingDisabled := true","\t\t\t// verify HPA status from ScalingActive condition","\t\t\tfor _, condition := range hpa.Status.Conditions {","\t\t\t\tif condition.Type == autoscalingv2.ScalingActive \u0026\u0026 condition.Status != corev1.ConditionFalse {","\t\t\t\t\thpaScalingDisabled = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","","\t\t\t// working description:","\t\t\t//---------------------","\t\t\t// variables description:","\t\t\t// - desiredReplicas - taken from hpa status.desiredReplicas","\t\t\t// - minReplicas - taken from hpa spec.minReplicas. this can be nil or zero. we set it as 1, if the value is nil or zero.","\t\t\t// - maxReplicas - taken from hpa spec.maxReplicas","\t\t\t// - manifestReplicas - taken from expected resource(manifest), can be a deployment or statefulSet the value is from spec.replicas","\t\t\t// The desiredReplicas calculated as follows,","\t\t\t// - if scaling is enabled compares minReplicas and desiredReplicas from hpa, take the higher one","\t\t\t// - if scaling is disabled, take manifestReplicas and compare with scaling range from hpa","\t\t\t// -- if the manifestReplicas value is lesser than the minReplicas, takes minReplicas as desiredReplicas","\t\t\t// -- if the manifestReplicas value is higher than the maxReplicas, takes the maxReplicas as desiredReplicas","\t\t\t// -- if the manifestReplicas value is in range. that is \"minReplicas \u003e= manifestReplicas \u003c= maxReplicas\", takes manifestReplicas as desiredReplicas","","\t\t\tdesiredReplicas := hpa.Status.DesiredReplicas","\t\t\tmaxReplicas := hpa.Spec.MaxReplicas","\t\t\tminReplicas := hpa.Spec.MinReplicas","\t\t\t// minReplicas can be nil or zero. in that case, we keep it as 1","\t\t\tif minReplicas == nil || *minReplicas == 0 {","\t\t\t\tminReplicas = ptr.Int32(1)","\t\t\t}","","\t\t\tif hpaScalingDisabled {","\t\t\t\thpaLogger.Info(\"HPA scaling disabled, adjusting replicas to scaling range\")","","\t\t\t\tmanifestReplicas, manifestReplicasFound, err := unstructured.NestedInt64(expected.Object, \"spec\", \"replicas\")","\t\t\t\tif err != nil {","\t\t\t\t\thpaLogger.Errorw(\"failed to get manifest replicas\", \"error\", err)","\t\t\t\t} else if !manifestReplicasFound {","\t\t\t\t\thpaLogger.Debug(\"manifest replicas not found, defaulting to 1\")","\t\t\t\t\t// set default value as 1","\t\t\t\t\tmanifestReplicas = 1","\t\t\t\t}","","\t\t\t\t// adjust the manifest replicas value to hpa's scaling range","\t\t\t\tif manifestReplicas \u003c int64(*minReplicas) {","\t\t\t\t\toriginalReplicas := manifestReplicas","\t\t\t\t\tmanifestReplicas = int64(*minReplicas)","\t\t\t\t\thpaLogger.Infow(\"adjusted replicas to minReplicas\",","\t\t\t\t\t\t\"originalReplicas\", originalReplicas,","\t\t\t\t\t\t\"newReplicas\", manifestReplicas,","\t\t\t\t\t\t\"minReplicas\", *minReplicas,","\t\t\t\t\t)","\t\t\t\t} else if manifestReplicas \u003e int64(maxReplicas) {","\t\t\t\t\toriginalReplicas := manifestReplicas","\t\t\t\t\tmanifestReplicas = int64(maxReplicas)","\t\t\t\t\thpaLogger.Infow(\"adjusted replicas to maxReplicas\",","\t\t\t\t\t\t\"originalReplicas\", originalReplicas,","\t\t\t\t\t\t\"newReplicas\", manifestReplicas,","\t\t\t\t\t\t\"maxReplicas\", maxReplicas,","\t\t\t\t\t)","\t\t\t\t}","","\t\t\t\t// updates the desiredReplicas","\t\t\t\tdesiredReplicas = int32(manifestReplicas)","","\t\t\t} else { // hpa scaling is enabled","\t\t\t\thpaLogger.Debugw(\"HPA scaling enabled\",","\t\t\t\t\t\"desiredReplicas\", desiredReplicas,","\t\t\t\t\t\"minReplicas\", *minReplicas,","\t\t\t\t\t\"maxReplicas\", maxReplicas,","\t\t\t\t\t\"scaleTargetKind\", hpa.Spec.ScaleTargetRef.Kind,","\t\t\t\t\t\"scaleTargetName\", hpa.Spec.ScaleTargetRef.Name,","\t\t\t\t)","","\t\t\t\t// if there is no metrics data available in the cluster the HPA desiredReplicas will be zero","\t\t\t\t// compare minReplicas and desiredReplicas and take the higher one","\t\t\t\tif desiredReplicas \u003c *minReplicas {","\t\t\t\t\thpaLogger.Debugw(\"HPA desiredReplicas less than minReplicas, adjusting desiredReplicas to minReplicas\",","\t\t\t\t\t\t\"OriginalDesiredReplicas\", desiredReplicas,","\t\t\t\t\t\t\"minReplicas\", *minReplicas,","\t\t\t\t\t\t\"scaleTargetKind\", hpa.Spec.ScaleTargetRef.Kind,","\t\t\t\t\t\t\"scaleTargetName\", hpa.Spec.ScaleTargetRef.Name,","\t\t\t\t\t)","\t\t\t\t\tdesiredReplicas = *minReplicas","\t\t\t\t}","\t\t\t}","","\t\t\thpaLogger.Infow(\"calculated final desired replicas\", \"desiredReplicas\", desiredReplicas, \"hpaScalingEnabled\", !hpaScalingDisabled)","","\t\t\t// update the replicas value from HPA in expected object","\t\t\t// note: converting the replicas value to int64, \"DeepCopyJSONValue\" not accepts int32, it is available inside \"SetNestedField\"","\t\t\terr = unstructured.SetNestedField(expected.Object, int64(desiredReplicas), \"spec\", \"replicas\")","\t\t\tif err != nil {","\t\t\t\thpaLogger.Errorw(\"failed to set replicas value\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t}","\t}","","\t// check if the resource already exists","\texisting, err := i.mfClient.Get(expected)","\tif err != nil {","\t\t// If the resource doesn't exist, then create new","\t\tif apierrs.IsNotFound(err) {","\t\t\tloggerWithContext.Debug(\"resource not found, creating\")","\t\t\terr = i.mfClient.Create(expected)","\t\t\tif err != nil {","\t\t\t\tloggerWithContext.Errorw(\"failed to create resource\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tloggerWithContext.Debug(\"resource created successfully\")","\t\t}","\t\tloggerWithContext.Errorw(\"failed to get resource\", \"error\", err)","\t\treturn err","\t}","","\tloggerWithContext.Debug(\"resource found in cluster, checking for changes\")","","\tif existing.GetDeletionTimestamp() != nil {","\t\tloggerWithContext.Debug(\"resource is being deleted, waiting for completion\")","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\t// get list of reconcile fields","\treconcileFields := i.resourceReconcileFields(expected)","","\t// compute hash value for the expected deployment or statefulset","\texpectedHashValue, err := i.computeResourceHash(expected, reconcileFields...)","\tif err != nil {","\t\tloggerWithContext.Errorw(\"failed to compute hash for expected resource\", \"error\", err)","\t\treturn fmt.Errorf(\"failed to compute hash value for expected resource, name:%s, error: %v\", expected.GetName(), err)","\t}","","\t// compute hash value for the existing resource","\t// remove extra annotations and labels to keep the consistence hash","\texistingCloned := existing.DeepCopy()","\texistingCloned.SetAnnotations(i.removeExtraKeyInMap(existingCloned.GetAnnotations(), expected.GetAnnotations()))","\texistingCloned.SetLabels(i.removeExtraKeyInMap(existingCloned.GetLabels(), expected.GetLabels()))","\t// compute hash","\texistingHashValue, err := i.computeResourceHash(existingCloned, reconcileFields...)","\tif err != nil {","\t\tloggerWithContext.Errorw(\"failed to compute hash for existing resource\", \"error\", err)","\t\treturn fmt.Errorf(\"failed to compute hash value for existing resource, name:%s, namespace:%s, kind:%s error: %v\",","\t\t\texistingCloned.GetName(), existingCloned.GetNamespace(), existingCloned.GetKind(), err,","\t\t)","\t}","","\t// if change detected in hash value, update the resource with changes","\tif existingHashValue != expectedHashValue {","\t\tloggerWithContext.Debugw(\"change detected, updating resource\",","\t\t\t\"existingHash\", existingHashValue,","\t\t\t\"expectedHash\", expectedHashValue,","\t\t)","","\t\terr = i.copyResourceFields(expected, existing, reconcileFields...)","\t\tif err != nil {","\t\t\tloggerWithContext.Errorw(\"failed to copy resource fields\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\terr = i.mfClient.Update(existing)","\t\tif err != nil {","\t\t\tloggerWithContext.Errorw(\"failed to update resource\", \"error\", err)","\t\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t\t}","","\t\tloggerWithContext.Debug(\"resource updated successfully\")","\t\treturn nil","\t}","\tloggerWithContext.Debug(\"no changes detected, resource is up-to-date\")","\treturn nil","}","","func (i *installer) removeExtraKeyInMap(src, dst map[string]string) map[string]string {","\tnewMap := map[string]string{}","\tif len(src) == 0 {","\t\treturn newMap","\t}","\tfor dstKey, dstValue := range dst {","\t\tfor srcKey := range src {","\t\t\tif dstKey == srcKey {","\t\t\t\tnewMap[dstKey] = dstValue","\t\t\t\tbreak","\t\t\t}","\t\t}","\t}","\treturn newMap","}","","func (i *installer) computeResourceHash(u *unstructured.Unstructured, reconcileFieldKeys ...string) (string, error) {","\t// always keep the empty annotations and labels as empty, NOT nil","\tif u.GetAnnotations() == nil {","\t\tu.SetAnnotations(map[string]string{})","\t}","\tif u.GetLabels() == nil {","\t\tu.SetLabels(map[string]string{})","\t}","","\t// if there is no reconcile key specified, compute the hash to the entire object","\tif len(reconcileFieldKeys) == 0 {","\t\treturn hash.Compute(u.Object)","\t}","","\t// holds the required fieldsMap","\tfieldsMap := map[string]interface{}{}","","\t// collect all the required fields to compute hash value","\tfor _, fieldKey := range reconcileFieldKeys {","\t\t// split the fields with comma","\t\tnestedKeys := strings.Split(fieldKey, \".\")","\t\tfieldValue, _, err := unstructured.NestedFieldCopy(u.Object, nestedKeys...)","\t\tif err != nil {","\t\t\treturn \"\", err","\t\t}","\t\tfieldsMap[fieldKey] = fieldValue","\t}","","\t// compute hash to the collected fieldMaps","\treturn hash.Compute(fieldsMap)","}","","func (i *installer) mergeMaps(src, dst map[string]string) map[string]string {","\tif len(dst) == 0 {","\t\treturn src","\t}","\tfor key, value := range src {","\t\tdst[key] = value","\t}","\treturn dst","}","","func (i *installer) copyResourceFields(src, dst *unstructured.Unstructured, reconcileFieldKeys ...string) error {","\t// if there is no reconcile key specified, compute the hash to the entire object","\tif len(reconcileFieldKeys) == 0 {","\t\tsrcCloned := src.DeepCopy()","\t\t// merge annotations","\t\tsrcCloned.SetAnnotations(i.mergeMaps(srcCloned.GetAnnotations(), dst.GetAnnotations()))","\t\t// merge labels","\t\tsrcCloned.SetLabels(i.mergeMaps(srcCloned.GetLabels(), dst.GetLabels()))","","\t\tdst.Object = srcCloned.Object","\t\treturn nil","\t}","","\tfor _, fieldKey := range reconcileFieldKeys {","\t\tswitch fieldKey {","\t\tcase annotationsPath: // merge annotations","\t\t\tdst.SetAnnotations(i.mergeMaps(src.GetAnnotations(), dst.GetAnnotations()))","","\t\tcase labelsPath: // merge labels","\t\t\tdst.SetLabels(i.mergeMaps(src.GetLabels(), dst.GetLabels()))","","\t\tdefault:","\t\t\t// split the fields with comma","\t\t\tnestedKeys := strings.Split(fieldKey, \".\")","\t\t\tfieldValue, found, err := unstructured.NestedFieldCopy(src.Object, nestedKeys...)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tif found {","\t\t\t\terr = unstructured.SetNestedField(dst.Object, fieldValue, nestedKeys...)","\t\t\t\tif err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t} else {","\t\t\t\tunstructured.RemoveNestedField(dst.Object, nestedKeys...)","\t\t\t}","\t\t}","\t}","","\treturn nil","}","","func (i *installer) IsWebhookReady() error {","\tfor _, u := range i.deployment {","\t\tif !strings.Contains(u.GetName(), \"webhook\") {","\t\t\tcontinue","\t\t}","\t\terr := i.isDeploymentReady(\u0026u)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func (i *installer) IsControllerReady() error {","\tfor _, u := range i.deployment {","\t\tif !strings.Contains(u.GetName(), \"controller\") {","\t\t\tcontinue","\t\t}","\t\terr := i.isDeploymentReady(\u0026u)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func (i *installer) AllDeploymentsReady() error {","\tfor _, u := range i.deployment {","\t\tif strings.Contains(u.GetName(), \"controller\") ||","\t\t\tstrings.Contains(u.GetName(), \"webhook\") {","\t\t\tcontinue","\t\t}","\t\terr := i.isDeploymentReady(\u0026u)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func (i *installer) IsJobCompleted(ctx context.Context, labels map[string]string, installSetName string) error {","\tfor _, u := range i.manifest.Filter(mf.ByKind(\"Job\")).Resources() {","\t\tresource, err := i.mfClient.Get(\u0026u)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tjob := \u0026batchv1.Job{}","\t\tif err := scheme.Scheme.Convert(resource, job, nil); err != nil {","\t\t\treturn err","\t\t}","","\t\tlogger := logging.FromContext(ctx)","\t\tif !isJobCompleted(job) {","\t\t\tlogger.Info(\"job not ready in installerset, name: %s, created-by: %s, in namespace: %s\", installSetName, labels[v1alpha1.CreatedByKey], job.GetNamespace())","\t\t\treturn fmt.Errorf(\"Job not successful\")","\t\t}","\t}","","\treturn nil","}","","func (i *installer) isStatefulSetAvailable(sfs *unstructured.Unstructured) error {","\tresource, err := i.mfClient.Get(sfs)","\tif err != nil {","\t\treturn err","\t}","","\tstatefulSet := \u0026appsv1.StatefulSet{}","\terr = runtime.DefaultUnstructuredConverter.FromUnstructured(resource.Object, statefulSet)","\tif err != nil {","\t\treturn err","\t}","","\tif !isStatefulSetReady(statefulSet) {","\t\ti.logger.Infof(\"statefulset %v not ready, returning will retry!\", statefulSet.GetName())","\t\treturn fmt.Errorf(\"%s statefulset is not ready\", statefulSet.GetName())","\t}","\treturn nil","}","","func (i *installer) isDeploymentReady(d *unstructured.Unstructured) error {","\tresource, err := i.mfClient.Get(d)","\tif err != nil {","\t\treturn err","\t}","","\tdeployment := \u0026appsv1.Deployment{}","\terr = runtime.DefaultUnstructuredConverter.FromUnstructured(resource.Object, deployment)","\tif err != nil {","\t\treturn err","\t}","","\tif msg := isFailedToCreateState(deployment); msg != \"\" {","\t\ti.logger.Infof(\"deployment %v is in failed state, deleting! reason: \", msg)","\t\terr := i.mfClient.Delete(resource)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\tif !isDeploymentAvailable(deployment) {","\t\ti.logger.Infof(\"deployment %v not ready, returning will retry!\", deployment.GetName())","\t\treturn fmt.Errorf(\"%s deployment not ready\", deployment.GetName())","\t}","","\treturn nil","}","","func isFailedToCreateState(d *appsv1.Deployment) string {","\tfor _, c := range d.Status.Conditions {","\t\tif string(c.Type) == string(appsv1.ReplicaSetReplicaFailure) \u0026\u0026 c.Status == corev1.ConditionTrue \u0026\u0026 c.Reason == \"FailedCreate\" {","\t\t\treturn c.Message","\t\t}","\t}","\treturn \"\"","}","","func isDeploymentAvailable(d *appsv1.Deployment) bool {","\tfor _, c := range d.Status.Conditions {","\t\tif c.Type == appsv1.DeploymentAvailable \u0026\u0026 c.Status == corev1.ConditionTrue {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","func isStatefulSetReady(sfs *appsv1.StatefulSet) bool {","\tif sfs.Spec.Replicas != nil {","\t\tif sfs.Status.ReadyReplicas == *sfs.Spec.Replicas {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","func isJobCompleted(d *batchv1.Job) bool {","\tfor _, c := range d.Status.Conditions {","\t\tif c.Type == batchv1.JobComplete \u0026\u0026 c.Status == corev1.ConditionTrue {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","// DeleteResources Deletes all resources except CRDs, PVCs and Namespace as they","// are own by owner of TektonInstallerSet.","// They will be deleted when the component CR is deleted","func (i *installer) DeleteResources() error {","\t// delete clusterScope resources first","\tif err := i.delete(i.clusterScoped); err != nil {","\t\treturn err","\t}","\tif err := i.delete(i.namespaceScoped); err != nil {","\t\treturn err","\t}","\tif err := i.deleteWithPolicy(i.job, metav1.DeletePropagationForeground); err != nil {","\t\treturn err","\t}","\tif err := i.delete(i.deployment); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func (i *installer) delete(resources []unstructured.Unstructured) error {","\tfor _, r := range resources {","\t\tif skipDeletion(r.GetKind()) {","\t\t\tcontinue","\t\t}","\t\tresource, err := i.mfClient.Get(\u0026r)","\t\tif err != nil {","\t\t\t// if error occurs log and move on, as we have owner reference set for resources, those","\t\t\t// will be removed eventually and manifestival breaks the pod during uninstallation,","\t\t\t// when CRD is deleted, CRs are removed but when we delete installer set, manifestival","\t\t\t// breaks during deleting those CRs","\t\t\ti.logger.Errorf(\"failed to get resource, skipping deletion: %v/%v: %v \", r.GetKind(), r.GetName(), err)","\t\t\tcontinue","\t\t}","\t\terr = i.mfClient.Delete(resource)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t}","\treturn nil","}","","func (i *installer) deleteWithPolicy(resources []unstructured.Unstructured, policy metav1.DeletionPropagation) error {","\tfor _, r := range resources {","\t\tif skipDeletion(r.GetKind()) {","\t\t\tcontinue","\t\t}","\t\tresource, err := i.mfClient.Get(\u0026r)","\t\tif err != nil {","\t\t\t// if error occurs log and move on, as we have owner reference set for resources, those","\t\t\t// will be removed eventually and manifestival breaks the pod during uninstallation,","\t\t\t// when CRD is deleted, CRs are removed but when we delete installer set, manifestival","\t\t\t// breaks during deleting those CRs","\t\t\ti.logger.Errorf(\"failed to get resource, skipping deletion: %v/%v: %v \", r.GetKind(), r.GetName(), err)","\t\t\tcontinue","\t\t}","","\t\terr = i.mfClient.Delete(resource, mf.DeleteOption(mf.PropagationPolicy(policy)))","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t}","\treturn nil","}","","func skipDeletion(kind string) bool {","\tif kind == \"Namespace\" ||","\t\tkind == \"PersistentVolumeClaim\" ||","\t\tkind == \"CustomResourceDefinition\" {","\t\treturn true","\t}","\treturn false","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,0,2,1,1,0,2,0,2,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,0,1,1,0,0,2,2,2,2,0,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,2,2,1,1,2,2,2,2,2,1,1,1,2,1,1,1,2,0,2,0,0,1,1,1,0,1,1,1,0,2,2,2,0,2,2,2,1,1,2,2,2,0,2,0,0,1,1,1,1,1,0,1,0,0,1,1,1,0,0,2,2,2,2,2,2,2,2,0,1,1,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,0,0,0,2,2,1,1,1,0,0,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,1,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,1,0,0,0,0,0,2,2,2,2,2,2,2,1,1,1,2,0,2,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,1,1,1,0,0,0,2,2,2,2,2,2,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,1,1,1,0,2,2,1,1,1,0,2,2,0,2,2,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,2,0,0,2,2,2,2,2,2,2,2,0,0,2,1,1,0,0,2,2,2,2,2,2,2,2,1,1,2,0,0,0,2,0,0,2,2,1,1,2,2,2,2,0,0,2,2,2,1,1,1,1,1,1,1,1,1,0,2,2,2,2,0,2,2,0,2,2,2,2,2,1,1,2,2,2,1,1,1,1,1,0,0,0,2,0,0,2,2,2,1,0,2,2,2,2,0,2,0,0,2,2,2,1,0,2,2,2,2,0,2,0,0,2,2,2,2,1,0,2,2,2,2,0,2,0,0,2,2,2,2,1,1,2,2,1,1,0,2,2,2,2,2,0,0,2,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,1,1,1,1,1,1,0,0,2,2,2,2,0,2,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,0,2,0,0,2,2,2,2,2,0,2,0,0,2,2,2,2,2,0,2,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,0]},{"id":109,"path":"pkg/reconciler/kubernetes/tektoninstallerset/query.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/selection\"",")","","func CurrentInstallerSetName(ctx context.Context, client clientset.Interface, labelSelector string) (string, error) {","\tiSets, err := client.OperatorV1alpha1().TektonInstallerSets().List(ctx, v1.ListOptions{","\t\tLabelSelector: labelSelector,","\t})","\tif err != nil {","\t\treturn \"\", err","\t}","\tif len(iSets.Items) == 0 {","\t\treturn \"\", nil","\t}","\tif len(iSets.Items) == 1 {","\t\tiSetName := iSets.Items[0].GetName()","\t\treturn iSetName, nil","\t}","","\t// len(iSets.Items) \u003e 1","\t// delete all installerSets as it cannot be decided which one is the desired one","\terr = client.OperatorV1alpha1().TektonInstallerSets().DeleteCollection(ctx,","\t\tv1.DeleteOptions{},","\t\tv1.ListOptions{","\t\t\tLabelSelector: labelSelector,","\t\t})","\tif err != nil {","\t\treturn \"\", err","\t}","\treturn \"\", v1alpha1.RECONCILE_AGAIN_ERR","}","","// CleanUpObsoleteResources cleans up obsolete resources","// this is required because after TektonInstallerSet were introduced","// it was observed that during upgrade multiple installerSets were","// getting created","// now that we have label based query and we have new labels","// this cleanup is just to make sure we delete all older installerSets","// from the cluster","func CleanUpObsoleteResources(ctx context.Context, client clientset.Interface, createdBy string) error {","","\tlabelSelector := labels.NewSelector()","\tcreatedReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{createdBy})","\tif createdReq != nil {","\t\tlabelSelector = labelSelector.Add(*createdReq)","\t}","","\tlist, err := client.OperatorV1alpha1().TektonInstallerSets().List(ctx, v1.ListOptions{LabelSelector: labelSelector.String()})","\tif err != nil {","\t\treturn err","\t}","","\tif len(list.Items) == 0 {","\t\treturn nil","\t}","","\tfor _, i := range list.Items {","\t\t// check if installerSet has InstallerSetType label","\t\t// if it doesn't exist then delete it","\t\tif _, ok := i.Labels[v1alpha1.InstallerSetType]; !ok {","\t\t\terr := client.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, i.Name, v1.DeleteOptions{})","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,1,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,1,1,2,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,1,1,0,2,1,1,0,2,2,2,2,2,2,1,1,0,0,2,0]},{"id":110,"path":"pkg/reconciler/kubernetes/tektoninstallerset/tektoninstallerset.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\ttektonInstallerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektoninstallerset\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// Reconciler implements controller.Reconciler for TektonInstallerSet resources.","type Reconciler struct {","\toperatorClientSet clientset.Interface","\tmfClient          mf.Client","\tkubeClientSet     kubernetes.Interface","}","","// Reconciler implements controller.Reconciler","var _ tektonInstallerreconciler.Interface = (*Reconciler)(nil)","var _ tektonInstallerreconciler.Finalizer = (*Reconciler)(nil)","","// FinalizeKind removes all resources after deletion of a TektonInstallerSet.","func (r *Reconciler) FinalizeKind(ctx context.Context, installerSet *v1alpha1.TektonInstallerSet) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\tdeleteManifests, err := mf.ManifestFrom(installerSet.Spec.Manifests, mf.UseClient(r.mfClient))","\tif err != nil {","\t\tlogger.Error(\"Error creating initial manifest: \", err)","\t\tinstallerSet.Status.MarkNotReady(fmt.Sprintf(\"Internal Error: failed to create manifest: %s\", err.Error()))","\t\treturn err","\t}","","\tinstaller := NewInstaller(\u0026deleteManifests, r.mfClient, r.kubeClientSet, logger)","\terr = installer.DeleteResources()","\tif err != nil {","\t\tlogger.Error(\"failed to delete resources: \", err)","\t\treturn err","\t}","\treturn nil","}","","// Returns ownerReference to add in resource while installing","func getReference(tis *v1alpha1.TektonInstallerSet) []v1.OwnerReference {","\treturn []v1.OwnerReference{*v1.NewControllerRef(tis, tis.GetGroupVersionKind())}","}","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, installerSet *v1alpha1.TektonInstallerSet) pkgreconciler.Event {","\tinstallerSet.Status.InitializeConditions()","\tlogger := logging.FromContext(ctx).With(\"installerSet\", fmt.Sprintf(\"%s/%s\", installerSet.Namespace, installerSet.Name))","","\tlogger.Debugw(\"Starting TektonInstallerSet reconciliation\",","\t\t\"resourceVersion\", installerSet.ResourceVersion,","\t\t\"status\", installerSet.Status.GetCondition(apis.ConditionReady))","","\tinstallManifests, err := mf.ManifestFrom(installerSet.Spec.Manifests, mf.UseClient(r.mfClient))","\tif err != nil {","\t\tmsg := fmt.Sprintf(\"Internal Error: failed to create manifest: %s\", err.Error())","\t\tlogger.Errorw(\"Failed to create initial manifest\", \"error\", err)","\t\tinstallerSet.Status.MarkNotReady(msg)","\t\treturn err","\t}","\tlogger.Debug(\"Successfully created initial manifest\")","","\t// Set owner of InstallerSet as owner of CRDs so that","\t// deleting the installer will not delete the CRDs and Namespace","\t// If installerSet has not set any owner then CRDs will","\t// not have any owner","\tinstallerSetOwner := installerSet.GetOwnerReferences()","\tlogger.Debug(\"Transforming manifest with ownership information\")","\tinstallManifests, err = installManifests.Transform(","\t\tinjectOwner(getReference(installerSet)),","\t\tinjectOwnerForCRDsAndNamespace(installerSetOwner),","\t)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to transform manifest with ownership information\", \"error\", err)","\t\treturn err","\t}","","\tinstaller := NewInstaller(\u0026installManifests, r.mfClient, r.kubeClientSet, logger)","","\t// Install CRDs","\tlogger.Debug(\"Installing CRDs\")","\terr = installer.EnsureCRDs()","\tif err != nil {","\t\tlogger.Errorw(\"CRD installation failed\", \"error\", err)","\t\tinstallerSet.Status.MarkCRDsInstallationFailed(err.Error())","\t\treturn r.handleError(err, installerSet)","\t}","","\t// Update Status for CRD condition","\tinstallerSet.Status.MarkCRDsInstalled()","\tlogger.Debug(\"CRDs installed successfully\")","","\t// Install ClusterScoped Resources","\tlogger.Debug(\"Installing cluster-scoped resources\")","\terr = installer.EnsureClusterScopedResources()","\tif err != nil {","\t\tlogger.Errorw(\"Cluster-scoped resources installation failed\", \"error\", err)","\t\tinstallerSet.Status.MarkClustersScopedInstallationFailed(err.Error())","\t\treturn r.handleError(err, installerSet)","\t}","","\t// Update Status for ClustersScope Condition","\tinstallerSet.Status.MarkClustersScopedResourcesInstalled()","\tlogger.Debug(\"Cluster-scoped resources installed successfully\")","","\t// Install NamespaceScoped Resources","\tlogger.Debug(\"Installing namespace-scoped resources\")","\terr = installer.EnsureNamespaceScopedResources()","\tif err != nil {","\t\tlogger.Errorw(\"Namespace-scoped resources installation failed\", \"error\", err)","\t\tinstallerSet.Status.MarkNamespaceScopedInstallationFailed(err.Error())","\t\treturn r.handleError(err, installerSet)","\t}","","\t// Update Status for NamespaceScope Condition","\tinstallerSet.Status.MarkNamespaceScopedResourcesInstalled()","\tlogger.Debug(\"Namespace-scoped resources installed successfully\")","","\t// Install Job Resources","\tlogger.Debug(\"Installing job resources\")","\terr = installer.EnsureJobResources()","\tif err != nil {","\t\tlogger.Errorw(\"Job resources installation failed\", \"error\", err)","\t\tinstallerSet.Status.MarkJobsInstallationFailed(err.Error())","\t\treturn r.handleError(err, installerSet)","\t}","","\t// Update Status for Job Resources","\tinstallerSet.Status.MarkJobsInstalled()","\tlogger.Debug(\"Job resources installed successfully\")","","\t// Install Deployment Resources","\tlogger.Debug(\"Installing deployment resources\")","\terr = installer.EnsureDeploymentResources(ctx)","\tif err != nil {","\t\tlogger.Errorw(\"Deployment resources installation failed\", \"error\", err)","\t\tinstallerSet.Status.MarkDeploymentsAvailableFailed(err.Error())","\t\treturn r.handleError(err, installerSet)","\t}","","\t// Update Status for Deployment Resources","\tinstallerSet.Status.MarkDeploymentsAvailable()","\tlogger.Debug(\"Deployment resources installed successfully\")","","\t// Install StatefulSet Resources","\tlogger.Debug(\"Installing statefulset resources\")","\terr = installer.EnsureStatefulSetResources(ctx)","\tif err != nil {","\t\tlogger.Errorw(\"StatefulSet resources installation failed\", \"error\", err)","\t\tinstallerSet.Status.MarkStatefulSetNotReady(err.Error())","\t\treturn r.handleError(err, installerSet)","\t}","","\t// Update Status for StatefulSet Resources","\tinstallerSet.Status.MarkStatefulSetReady()","\tlogger.Debug(\"StatefulSet resources installed successfully\")","","\t// Check if webhook is ready","\tlogger.Debugw(\"Checking webhook readiness\")","\terr = installer.IsWebhookReady()","\tif err != nil {","\t\tlogger.Warnw(\"Webhook not ready\", \"error\", err)","\t\tinstallerSet.Status.MarkWebhookNotReady(err.Error())","\t\treturn nil","\t}","","\t// Update Status for Webhook","\tinstallerSet.Status.MarkWebhookReady()","\tlogger.Debug(\"Webhook is ready\")","","\t// Check if controller is ready","\tlogger.Debug(\"Checking controller readiness\")","\terr = installer.IsControllerReady()","\tif err != nil {","\t\tlogger.Warnw(\"Controller not ready\", \"error\", err)","\t\tinstallerSet.Status.MarkControllerNotReady(err.Error())","\t\treturn nil","\t}","","\t// Update Ready status of Controller","\tinstallerSet.Status.MarkControllerReady()","\tlogger.Debug(\"Controller is ready\")","","\t// job","\tlabels := installerSet.GetLabels()","\tinstallSetname := installerSet.GetName()","\tlogger.Debug(\"Checking job completion status\")","\terr = installer.IsJobCompleted(ctx, labels, installSetname)","\tif err != nil {","\t\tlogger.Warnw(\"Jobs not completed\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"All jobs completed successfully\")","","\t// Check if any other deployment exists other than controller","\t// and webhook and is ready","\tlogger.Debug(\"Checking all deployments readiness\")","\terr = installer.AllDeploymentsReady()","\tif err != nil {","\t\tlogger.Warnw(\"Not all deployments are ready\", \"error\", err)","\t\tinstallerSet.Status.MarkAllDeploymentsNotReady(err.Error())","\t\treturn nil","\t}","","\t// Mark all deployments ready","\tinstallerSet.Status.MarkAllDeploymentsReady()","\tlogger.Debug(\"All deployments are ready\")","","\tlogger.Debugw(\"TektonInstallerSet reconciliation completed successfully\",","\t\t\"ready\", installerSet.Status.GetCondition(apis.ConditionReady))","","\treturn nil","}","","func (r *Reconciler) handleError(err error, installerSet *v1alpha1.TektonInstallerSet) error {","\tif err == v1alpha1.RECONCILE_AGAIN_ERR {","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","\treturn err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0]},{"id":111,"path":"pkg/reconciler/kubernetes/tektoninstallerset/transformer.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\tmf \"github.com/manifestival/manifestival\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"",")","","func injectOwner(owner []v1.OwnerReference) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := u.GetKind()","\t\tif kind == \"CustomResourceDefinition\" ||","\t\t\tkind == \"ValidatingWebhookConfiguration\" ||","\t\t\tkind == \"MutatingWebhookConfiguration\" ||","\t\t\tkind == \"Namespace\" {","\t\t\treturn nil","\t\t}","\t\tu.SetOwnerReferences(owner)","\t\treturn nil","\t}","}","","func injectOwnerForCRDsAndNamespace(owner []v1.OwnerReference) mf.Transformer {","\tif len(owner) == 0 {","\t\treturn func(u *unstructured.Unstructured) error { return nil }","\t}","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := u.GetKind()","\t\tif kind != \"CustomResourceDefinition\" \u0026\u0026","\t\t\tkind != \"Namespace\" {","\t\t\treturn nil","\t\t}","\t\tu.SetOwnerReferences(owner)","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,1,0,2,2,2,2,2,2,2,2,0,0]},{"id":112,"path":"pkg/reconciler/kubernetes/tektonpipeline/controller.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpipeline","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineInformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\ttektonPipelineReconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpipeline\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = \"pipelines-info\"","","// NewController initializes the controller and is called by the generated code","// Registers event handlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","","\t\tmanifest, pipelineVer := ctrl.InitController(ctx, common.PayloadOptions{})","","\t\tmetrics, err := NewRecorder()","\t\tif err != nil {","\t\t\tlogger.Errorf(\"Failed to create pipeline metrics recorder %v\", err)","\t\t}","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","","\t\tc := \u0026Reconciler{","\t\t\tkubeClientSet:      kubeclient.Get(ctx),","\t\t\textension:          generator(ctx),","\t\t\tmanifest:           manifest,","\t\t\tpipelineVersion:    pipelineVer,","\t\t\tinstallerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, pipelineVer, v1alpha1.KindTektonPipeline, metrics),","\t\t}","\t\timpl := tektonPipelineReconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for TektonPipeline\")","","\t\tif _, err := tektonPipelineInformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonPipeline informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonPipeline{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":113,"path":"pkg/reconciler/kubernetes/tektonpipeline/finalize.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpipeline","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\ttektonpipelinereconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpipeline\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","var _ tektonpipelinereconciler.Finalizer = (*Reconciler)(nil)","","// FinalizeKind removes all resources after deletion of a TektonPipeline.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonPipeline) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\t// Delete CRDs before deleting rest of resources so that any instance","\t// of CRDs which has finalizer set will get deleted before we remove","\t// the controller;s deployment for it","\tif err := r.manifest.Filter(mf.CRDs).Delete(); err != nil {","\t\tlogger.Error(\"Failed to delete CRDs for TektonPipeline\")","\t\treturn err","\t}","","\tif err := r.installerSetClient.CleanupMainSet(ctx); err != nil {","\t\tlogger.Error(\"failed to cleanup main installerset: \", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources: \", err)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0]},{"id":114,"path":"pkg/reconciler/kubernetes/tektonpipeline/metrics.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpipeline","","import (","\t\"context\"","\t\"fmt\"","\t\"time\"","","\t\"go.opencensus.io/stats\"","\t\"go.opencensus.io/stats/view\"","\t\"go.opencensus.io/tag\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/metrics\"",")","","var (","\tpReconcileCount = stats.Float64(\"pipeline_reconcile_count\",","\t\t\"number of pipeline install\",","\t\tstats.UnitDimensionless)",")","","// Recorder holds keys for Tekton metrics","type Recorder struct {","\tinitialized bool","\tstatus      tag.Key","\tversion     tag.Key","","\tReportingPeriod time.Duration","}","","// NewRecorder creates a new metrics recorder instance","// to log the PipelineRun related metrics","func NewRecorder() (*Recorder, error) {","\tr := \u0026Recorder{","\t\tinitialized: true,","","\t\t// Default to 30s intervals.","\t\tReportingPeriod: 30 * time.Second,","\t}","","\tstatus, err := tag.NewKey(\"status\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.status = status","","\tversion, err := tag.NewKey(\"version\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.version = version","","\terr = view.Register(","\t\t\u0026view.View{","\t\t\tDescription: pReconcileCount.Description(),","\t\t\tMeasure:     pReconcileCount,","\t\t\tAggregation: view.Count(),","\t\t\tTagKeys:     []tag.Key{r.status, r.version},","\t\t},","\t)","","\tif err != nil {","\t\tr.initialized = false","\t\treturn r, err","\t}","","\treturn r, nil","}","","// Count logs number of times a component (pipeline/trigger atm)","// has been installed or failed to install.","func (r *Recorder) Count(status, version string) error {","\tif !r.initialized {","\t\treturn fmt.Errorf(","\t\t\t\"ignoring the metrics recording for pipelinee failed to initialize the metrics recorder\")","\t}","","\tctx, err := tag.New(","\t\tcontext.Background(),","\t\ttag.Insert(r.status, status),","\t\ttag.Insert(r.version, version),","\t)","","\tif err != nil {","\t\treturn err","\t}","","\tmetrics.Record(ctx, pReconcileCount.M(1))","\treturn nil","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\terr := m.Count(status, version)","\tif err != nil {","\t\tlogger.Warnf(\"%v: Failed to log the metrics : %v\", resourceKind, err)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0]},{"id":115,"path":"pkg/reconciler/kubernetes/tektonpipeline/reconcile.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpipeline","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\ttektonpipelinereconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpipeline\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const (","\tresourceKind = v1alpha1.KindTektonPipeline","","\tproxyLabel = \"operator.tekton.dev/disable-proxy=true\"",")","","// Reconciler implements controller.Reconciler for TektonPipeline resources.","type Reconciler struct {","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// manifest has the source manifest of Tekton Pipeline for a","\t// particular version","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","\t// kube client to interact with core k8s resources","\tkubeClientSet kubernetes.Interface","\t// version of pipelines which we are installing","\tpipelineVersion string","}","","// Check that our Reconciler implements controller.Reconciler","var _ tektonpipelinereconciler.Interface = (*Reconciler)(nil)","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, tp *v1alpha1.TektonPipeline) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(","\t\t\"name\", tp.GetName(),","\t\t\"namespace\", tp.GetNamespace(),","\t\t\"resourceVersion\", tp.GetResourceVersion(),","\t)","\tlogger.Debugw(\"Starting TektonPipeline reconciliation\",","\t\t\"version\", r.pipelineVersion,","\t\t\"status\", tp.Status.GetCondition(apis.ConditionReady))","","\ttp.Status.InitializeConditions()","\ttp.Status.SetVersion(r.pipelineVersion)","","\tif tp.GetName() != v1alpha1.PipelineResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored: expected name '%s', got '%s'\",","\t\t\tv1alpha1.PipelineResourceName, tp.GetName())","\t\tlogger.Errorw(\"Invalid resource name\", \"expectedName\", v1alpha1.PipelineResourceName, \"actualName\", tp.GetName())","\t\ttp.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// Pass the object through defaulting","\ttp.SetDefaults(ctx)","","\t// reconcile target namespace","\tlogger.Debug(\"Reconciling target namespace\")","\tif err := common.ReconcileTargetNamespace(ctx, nil, nil, tp, r.kubeClientSet); err != nil {","\t\tlogger.Errorw(\"Failed to reconcile target namespace\", \"error\", err)","\t\treturn err","\t}","","\tif err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {","\t\tlogger.Errorw(\"Failed to remove obsolete installer sets\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"Obsolete installer sets removed\")","","\t// Pipeline controller is deployed as statefulset, ensure deployment installerset is deleted","\tif tp.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *tp.Spec.Performance.StatefulsetOrdinals {","\t\tlogger.Debugw(\"Cleaning up deployment installer set\", \"usingStatefulset\", true)","\t\tif err := r.installerSetClient.CleanupSubTypeDeployment(ctx); err != nil {","\t\t\tlogger.Errorw(\"Failed to delete main deployment installer set\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Debug(\"Deployment installer set deleted\")","\t} else {","\t\t// Pipeline controller is deployed as deployment, ensure statefulset installerset is deleted","\t\tif err := r.installerSetClient.CleanupSubTypeStatefulset(ctx); err != nil {","\t\t\tlogger.Debugw(\"Cleaning up statefulset installer set\", \"usingDeployment\", true)","\t\t\treturn err","\t\t}","\t\tlogger.Debug(\"Statefulset installer set deleted\")","\t}","","\tlogger.Debug(\"Executing pre-reconciliation\")","\tif err := r.extension.PreReconcile(ctx, tp); err != nil {","\t\tmsg := fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Pre-reconciliation failed\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Infow(\"Pre-reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\ttp.Status.MarkPreReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PreReconcile Complete","\tlogger.Debug(\"Pre-reconciliation completed successfully\")","\ttp.Status.MarkPreReconcilerComplete()","","\t// When TektonPipeline component is deleted targetNamespace was getting deleted,","\t// because in pipeline reconciler targetNamespace was updated by adding few labels which","\t// in turn also updated the ownerRef of targetNamespace from TektonConfig to TektonPipeline.","\t// Since namespace is created in TektonConfig reconciler hence deleting TektonPipeline","\t// component should not delete the targetNamespace hence filtering out the namespace here","\tlogger.Debug(\"Filtering out namespace from manifest\")","\tmanifest := r.manifest.Filter(mf.Not(mf.ByKind(\"Namespace\")))","","\t// Ensure webhook deadlock prevention before applying the manifest","\tlogger.Debug(\"Preempting webhook deadlock\")","\tif err := common.PreemptDeadlock(ctx, \u0026manifest, r.kubeClientSet, v1alpha1.PipelineResourceName); err != nil {","\t\tlogger.Errorw(\"Failed to preempt webhook deadlock\", \"error\", err)","\t\treturn err","\t}","","\t//Apply manifest","\tlogger.Debug(\"Applying main manifest\")","\tif err := r.installerSetClient.MainSet(ctx, tp, \u0026manifest, filterAndTransform(r.extension)); err != nil {","\t\tmsg := fmt.Sprintf(\"Main Reconcilation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Failed to apply main installer set\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Debugw(\"Main reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\ttp.Status.MarkInstallerSetNotReady(msg)","\t\treturn nil","\t}","\tlogger.Debug(\"Main manifest applied successfully\")","","\tlogger.Debug(\"Executing post-reconciliation\")","\tif err := r.extension.PostReconcile(ctx, tp); err != nil {","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Post-reconciliation failed\", \"error\", err)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Debug(\"Post-reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\ttp.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PostReconcile Complete","\tlogger.Debug(\"Post-reconciliation completed successfully\")","\ttp.Status.MarkPostReconcilerComplete()","","\tlogger.Debug(\"TektonPipeline reconciliation completed successfully\")","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0]},{"id":116,"path":"pkg/reconciler/kubernetes/tektonpipeline/transform.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpipeline","","import (","\t\"context\"","\t\"sort\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\tapimachineryRuntime \"k8s.io/apimachinery/pkg/runtime\"",")","","const (","\t// Pipelines ConfigMap","\tFeatureFlag                                  = \"feature-flags\"","\tConfigDefaults                               = \"config-defaults\"","\tConfigMetrics                                = \"config-observability\"","\tConfigTracing                                = \"config-tracing\"","\tResolverFeatureFlag                          = \"resolvers-feature-flags\"","\tbundleResolverConfig                         = \"bundleresolver-config\"","\tclusterResolverConfig                        = \"cluster-resolver-config\"","\thubResolverConfig                            = \"hubresolver-config\"","\tgitResolverConfig                            = \"git-resolver-config\"","\tleaderElectionPipelineConfig                 = \"config-leader-election-controller\"","\tleaderElectionResolversConfig                = \"config-leader-election-resolvers\"","\tpipelinesControllerDeployment                = \"tekton-pipelines-controller\"","\tpipelinesControllerContainer                 = \"tekton-pipelines-controller\"","\tpipelinesRemoteResolversControllerDeployment = \"tekton-pipelines-remote-resolvers\"","\tpipelinesRemoteResolverControllerContainer   = \"controller\"","\tresolverEnvKeyTektonHubApi                   = \"tekton-hub-api\"","\tresolverEnvKeyArtifactHubApi                 = \"artifact-hub-api\"","","\ttektonPipelinesControllerName                      = \"tekton-pipelines-controller\"","\ttektonPipelinesServiceName                         = \"tekton-pipelines-controller\"","\ttektonRemoteResolversControllerName                = \"tekton-pipelines-remote-resolvers\"","\ttektonRemoteResolversServiceName                   = \"tekton-pipelines-remote-resolvers\"","\ttektonPipelinesControllerStatefulServiceName       = \"STATEFUL_SERVICE_NAME\"","\ttektonPipelinesControllerStatefulControllerOrdinal = \"STATEFUL_CONTROLLER_ORDINAL\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tpipeline := comp.(*v1alpha1.TektonPipeline)","","\t\t// not in use, see: https://github.com/tektoncd/pipeline/pull/7789","\t\t// this field is removed from pipeline component","\t\t// still keeping types to maintain the API compatibility","\t\tpipeline.Spec.Pipeline.EnableTektonOciBundles = nil","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PipelinesImagePrefix))","\t\timages := common.ImageRegistryDomainOverride(imagesRaw)","\t\tinstance := comp.(*v1alpha1.TektonPipeline)","\t\t// adding extension's transformers first to run them before `extra` transformers","\t\ttrns := extension.Transformers(instance)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdPipeline),","\t\t\tcommon.AddConfigMapValues(FeatureFlag, pipeline.Spec.PipelineProperties),","\t\t\tcommon.AddConfigMapValues(ConfigDefaults, pipeline.Spec.OptionalPipelineProperties),","\t\t\tcommon.AddConfigMapValues(ConfigMetrics, pipeline.Spec.PipelineMetricsProperties),","\t\t\taddTracingConfigValues(pipeline),","\t\t\tcommon.AddConfigMapValues(ResolverFeatureFlag, pipeline.Spec.Resolvers),","\t\t\tcommon.DeploymentImages(images),","\t\t\tcommon.StatefulSetImages(images),","\t\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\t\tcommon.InjectLabelOnNamespace(proxyLabel),","\t\t\tcommon.AddConfiguration(pipeline.Spec.Config),","\t\t\tcommon.CopyConfigMap(bundleResolverConfig, pipeline.Spec.BundlesResolverConfig),","\t\t\tcommon.CopyConfigMap(hubResolverConfig, pipeline.Spec.HubResolverConfig),","\t\t\tcommon.CopyConfigMap(clusterResolverConfig, pipeline.Spec.ClusterResolverConfig),","\t\t\tcommon.CopyConfigMap(gitResolverConfig, pipeline.Spec.GitResolverConfig),","\t\t\tcommon.AddConfigMapValues(leaderElectionPipelineConfig, pipeline.Spec.Performance.PerformanceLeaderElectionConfig),","\t\t\tcommon.AddConfigMapValues(leaderElectionResolversConfig, pipeline.Spec.Performance.PerformanceLeaderElectionConfig),","\t\t\tcommon.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(\u0026pipeline.Spec.Performance, leaderElectionPipelineConfig, pipelinesControllerDeployment, pipelinesControllerContainer),","\t\t\tcommon.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(\u0026pipeline.Spec.Performance, leaderElectionResolversConfig, pipelinesRemoteResolversControllerDeployment, pipelinesRemoteResolverControllerContainer),","\t\t\tupdateResolverConfigEnvironmentsInDeployment(pipeline),","\t\t}","\t\tif pipeline.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *pipeline.Spec.Performance.StatefulsetOrdinals {","\t\t\textra = append(extra, common.ConvertDeploymentToStatefulSet(tektonPipelinesControllerName, tektonPipelinesServiceName), common.AddStatefulEnvVars(","\t\t\t\ttektonPipelinesControllerName, tektonPipelinesServiceName, tektonPipelinesControllerStatefulServiceName, tektonPipelinesControllerStatefulControllerOrdinal))","\t\t\textra = append(extra, common.ConvertDeploymentToStatefulSet(tektonRemoteResolversControllerName, tektonRemoteResolversServiceName), common.AddStatefulEnvVars(","\t\t\t\ttektonRemoteResolversControllerName, tektonRemoteResolversServiceName, tektonPipelinesControllerStatefulServiceName, tektonPipelinesControllerStatefulControllerOrdinal))","\t\t}","","\t\ttrns = append(trns, extra...)","","\t\tif err := common.Transform(ctx, manifest, instance, trns...); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, pipeline.Spec.GetTargetNamespace(), pipeline.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}","","// updates resolver config environment variables","func updateResolverConfigEnvironmentsInDeployment(pipelineCR *v1alpha1.TektonPipeline) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" || u.GetName() != pipelinesRemoteResolversControllerDeployment {","\t\t\treturn nil","\t\t}","","\t\t// holds the variables needs to be added in the container environment section","\t\tenvVariables := map[string]string{}","","\t\t// collect all the required environment keys","\t\trawEnvKeys := []string{resolverEnvKeyTektonHubApi, resolverEnvKeyArtifactHubApi}","\t\t// get values from resolver config","\t\tfor _, rawEnvKey := range rawEnvKeys {","\t\t\tif value, found := pipelineCR.Spec.ResolversConfig.HubResolverConfig[rawEnvKey]; found \u0026\u0026 value != \"\" {","\t\t\t\tenvVariables[rawEnvKey] = value","\t\t\t}","\t\t}","","\t\t// if there is no variables available to update, return from here","\t\tif len(envVariables) == 0 {","\t\t\treturn nil","\t\t}","","\t\t// update environment key to actual format","\t\t// example: tekton-hub-api =\u003e TEKTON_HUB_API","\t\tenvKeys := []string{}","\t\tfor key, value := range envVariables {","\t\t\tnewKey := strings.ToUpper(strings.ReplaceAll(key, \"-\", \"_\"))","\t\t\tdelete(envVariables, key)","\t\t\tenvVariables[newKey] = value","\t\t\tenvKeys = append(envKeys, newKey)","\t\t}","\t\t// sort the keys","\t\tsort.Strings(envKeys)","","\t\t// convert unstructured object to deployment","\t\tdep := \u0026appsv1.Deployment{}","\t\terr := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// update environment keys into the target container","\t\tfor containerIndex, container := range dep.Spec.Template.Spec.Containers {","\t\t\tif container.Name != pipelinesRemoteResolverControllerContainer {","\t\t\t\tcontinue","\t\t\t}","\t\t\tfor _, envKey := range envKeys {","\t\t\t\tenvUpdated := false","\t\t\t\tenvVar := corev1.EnvVar{","\t\t\t\t\tName:  envKey,","\t\t\t\t\tValue: envVariables[envKey],","\t\t\t\t}","\t\t\t\tfor envIndex, existingEnv := range container.Env {","\t\t\t\t\tif existingEnv.Name == envKey {","\t\t\t\t\t\tcontainer.Env[envIndex] = envVar","\t\t\t\t\t\tenvUpdated = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif !envUpdated {","\t\t\t\t\tcontainer.Env = append(container.Env, envVar)","\t\t\t\t}","\t\t\t}","\t\t\tdep.Spec.Template.Spec.Containers[containerIndex] = container","\t\t}","","\t\t// convert deployment to unstructured object","\t\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(obj)","","\t\treturn nil","\t}","}","","// addTracingConfigValues adds tracing configuration to config-tracing ConfigMap","// It strips the \"traces.\" prefix from the JSON tags to match upstream expectations","func addTracingConfigValues(pipelineCR *v1alpha1.TektonPipeline) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ConfigMap\" || u.GetName() != ConfigTracing {","\t\t\treturn nil","\t\t}","","\t\tcm := \u0026corev1.ConfigMap{}","\t\terr := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif cm.Data == nil {","\t\t\tcm.Data = map[string]string{}","\t\t}","","\t\t// Map traces.enabled -\u003e enabled","\t\tif pipelineCR.Spec.TracingProperties.Enabled != nil {","\t\t\tif *pipelineCR.Spec.TracingProperties.Enabled {","\t\t\t\tcm.Data[\"enabled\"] = \"true\"","\t\t\t} else {","\t\t\t\tcm.Data[\"enabled\"] = \"false\"","\t\t\t}","\t\t}","","\t\tif pipelineCR.Spec.TracingProperties.Endpoint != \"\" {","\t\t\tcm.Data[\"endpoint\"] = pipelineCR.Spec.TracingProperties.Endpoint","\t\t}","","\t\tif pipelineCR.Spec.TracingProperties.CredentialsSecret != \"\" {","\t\t\tcm.Data[\"credentialsSecret\"] = pipelineCR.Spec.TracingProperties.CredentialsSecret","\t\t}","","\t\tobj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(obj)","","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,0,2,2,2,1,1,0,0,0,2,1,1,0,2,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,1,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,0,0,0,2,2,1,1,2,2,2,0,0,0,0,0,2,2,2,2,2,0,2,2,2,1,1,2,1,1,0,0,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,1,1,2,2,2,0,0]},{"id":117,"path":"pkg/reconciler/kubernetes/tektonpruner/controller.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import (","\t\"context\"","","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonPrunerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpruner\"","\ttektonPrunerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = v1alpha1.TektonPrunerResourceName + \"-info\"","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","","\t\tmanifest, prunerVer := ctrl.InitController(ctx, common.PayloadOptions{})","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","\t\tmetrics, _ := NewRecorder()","\t\tc := \u0026Reconciler{","\t\t\toperatorClientSet:  operatorclient.Get(ctx),","\t\t\tkubeClientSet:      kubeclient.Get(ctx),","\t\t\tpipelineInformer:   tektonPipelineinformer.Get(ctx),","\t\t\tinstallerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, prunerVer, v1alpha1.KindTektonPruner, metrics),","\t\t\textension:          generator(ctx),","\t\t\tmanifest:           manifest,","\t\t\tprunerVersion:      prunerVer,","\t\t\toperatorVersion:    operatorVer,","\t\t}","\t\timpl := tektonPrunerreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for TektonPruner\")","","\t\tif _, err := tektonPrunerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonPruner informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonPruner{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":118,"path":"pkg/reconciler/kubernetes/tektonpruner/finalize.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","var _ tektonpruner.Finalizer = (*Reconciler)(nil)","","// FinalizeKind removes all resources after deletion of a TektonPruner CR.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonPruner) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\t//Delete CRDs before deleting rest of resources so that any instance","\t//of CRDs which has finalizer set will get deleted before we remove","\t//the controller;s deployment for it","\tif err := r.manifest.Filter(mf.CRDs).Delete(); err != nil {","\t\tlogger.Error(\"Failed to deleted CRDs for TektonPruner\")","\t\treturn err","\t}","","\tif err := r.installerSetClient.CleanupMainSet(ctx); err != nil {","\t\tlogger.Error(\"failed to cleanup main installerset: \", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0]},{"id":119,"path":"pkg/reconciler/kubernetes/tektonpruner/metrics.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import \"go.uber.org/zap\"","","type Recorder struct {","}","","func NewRecorder() (*Recorder, error) {","\treturn \u0026Recorder{}, nil","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\t// TODO","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0]},{"id":120,"path":"pkg/reconciler/kubernetes/tektonpruner/pruner_installerset.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"github.com/tektoncd/pruner/pkg/config\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tPrunerConfigInstallerSet = \"pruner-config\"","\tCreatedByValue           = \"TektonConfig\"","\tPrunerConfigMapName      = config.PrunerConfigMapName",")","","func (r *Reconciler) ensureInstallerSets(ctx context.Context, tp *v1alpha1.TektonPruner) error {","\tlogger := logging.FromContext(ctx)","","\t// Create Config InstallerSet FIRST (containing the ConfigMap that the controller needs)","\t// This ensures the ConfigMap exists before the controller pod starts","\tif err := r.ensureConfigInstallerSet(ctx, tp); err != nil {","\t\tmsg := fmt.Sprintf(\"Config InstallerSet Reconcilation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif errors.Is(err, v1alpha1.REQUEUE_EVENT_AFTER) {","\t\t\treturn err","\t\t}","\t\ttp.Status.MarkInstallerSetNotReady(msg)","\t\treturn err","\t}","","\t// Create Main InstallerSet SECOND (containing controller and webhook deployments)","\t// By this point, the ConfigMap should exist, preventing controller startup failures","\tfilteredManifest := r.manifest.Filter(mf.Not(mf.All(mf.ByKind(\"ConfigMap\"), mf.ByName(config.PrunerConfigMapName))))","\tif err := r.installerSetClient.MainSet(ctx, tp, \u0026filteredManifest, filterAndTransform(r.extension)); err != nil {","\t\tmsg := fmt.Sprintf(\"Main Reconcilation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif errors.Is(err, v1alpha1.REQUEUE_EVENT_AFTER) {","\t\t\treturn err","\t\t}","\t\ttp.Status.MarkInstallerSetNotReady(msg)","\t\treturn err","\t}","","\treturn nil","}","","func (r *Reconciler) ensureConfigInstallerSet(ctx context.Context, tp *v1alpha1.TektonPruner) error {","\tlogger := logging.FromContext(ctx)","\tlabelSelector := metav1.LabelSelector{","\t\tMatchLabels: getLabels(),","\t}","\tconfigLabelSector, err := common.LabelSelector(labelSelector)","\tif err != nil {","\t\tlogger.Errorw(\"Invalid Pruner config label selector\", \"error\", err)","\t\treturn err","\t}","\texistingConfigInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, configLabelSector)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to get config installer set name\", \"error\", err, \"selector\", configLabelSector)","\t\treturn err","\t}","\tif existingConfigInstallerSet == \"\" {","\t\ttp.Status.MarkInstallerSetNotAvailable(PrunerConfigInstallerSet + \" InstallerSet not available\")","\t\tlogger.Infow(\"Creating new InstallerSet\", PrunerConfigInstallerSet, \"targetNamespace\", tp.Spec.TargetNamespace)","","\t\t_, err := r.createConfigInstallerSet(ctx, tp)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to create Config InstallerSet\", \"error\", err)","\t\t\treturn err","\t\t}","","\t} else {","\t\t// If exists, then fetch the Tekton Pruner Config InstallerSet","\t\tinstalledConfigTIS, _ := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, existingConfigInstallerSet, metav1.GetOptions{})","","\t\tconfigInstallerSetTargetNamespace := installedConfigTIS.Annotations[v1alpha1.TargetNamespaceKey]","\t\tconfigInstallerSetReleaseVersion := installedConfigTIS.Labels[v1alpha1.ReleaseVersionKey]","","\t\tif configInstallerSetTargetNamespace != tp.Spec.TargetNamespace || configInstallerSetReleaseVersion != r.operatorVersion {","\t\t\tlogger.Infow(\"Config InstallerSet needs update\",","\t\t\t\t\"name\", existingConfigInstallerSet,","\t\t\t\t\"currentNamespace\", configInstallerSetTargetNamespace,","\t\t\t\t\"expectedNamespace\", tp.Spec.TargetNamespace,","\t\t\t\t\"currentVersion\", configInstallerSetReleaseVersion,","\t\t\t\t\"expectedVersion\", r.operatorVersion)","","\t\t\t// Delete the existing Tekton Pruner InstallerSet","\t\t\terr := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tDelete(ctx, existingConfigInstallerSet, metav1.DeleteOptions{})","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to delete Config InstallerSet\", \"name\", existingConfigInstallerSet, \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// Make sure the Tekton Pruner Config InstallerSet is deleted","\t\t\t_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tGet(ctx, existingConfigInstallerSet, metav1.GetOptions{})","\t\t\tif err == nil {","\t\t\t\ttp.Status.MarkNotReady(\"Waiting for previous installer set to get deleted\")","\t\t\t\tlogger.Debugw(\"Config InstallerSet deletion pending\", \"name\", existingConfigInstallerSet)","\t\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t\t}","\t\t\tif !apierrors.IsNotFound(err) {","\t\t\t\tlogger.Errorw(\"Failed to confirm Config InstallerSet deletion\", \"name\", existingConfigInstallerSet, \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\treturn nil","","\t\t} else {","\t\t\t// If target namespace and version are not changed then check if Pruner","\t\t\t// spec is changed by checking hash stored as annotation on","\t\t\t// Tekton Pruner InstallerSet with computing new hash of TektonPruner Spec","","\t\t\t// Hash of TektonPruner Spec","\t\t\texpectedSpecHash, err := hash.Compute(tp.Spec)","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to compute spec hash\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// spec hash stored on installerSet","\t\t\tlastAppliedHash := installedConfigTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]","\t\t\tif lastAppliedHash != expectedSpecHash {","\t\t\t\tlogger.Infow(\"Config spec changed, updating InstallerSet\",","\t\t\t\t\t\"name\", installedConfigTIS.Name,","\t\t\t\t\t\"oldHash\", lastAppliedHash,","\t\t\t\t\t\"newHash\", expectedSpecHash)","\t\t\t\tif err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\t\tDelete(ctx, installedConfigTIS.Name, metav1.DeleteOptions{}); err != nil {","\t\t\t\t\tlogger.Errorw(\"Failed to delete outdated Config InstallerSet\", \"name\", installedConfigTIS.Name, \"error\", err)","\t\t\t\t\treturn err","\t\t\t\t}","","\t\t\t\t// after updating installer set enqueue after a duration","\t\t\t\t// to allow changes to get deployed","\t\t\t\tlogger.Infow(\"Config InstallerSet deleted to apply spec changes\", \"name\", installedConfigTIS.Name)","\t\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t\t}","\t\t\tlogger.Debugw(\"Config InstallerSet up to date\", \"name\", installedConfigTIS.Name)","\t\t}","\t}","\treturn nil","}","","func (r *Reconciler) createConfigInstallerSet(ctx context.Context, tektonPruner *v1alpha1.TektonPruner) (*v1alpha1.TektonInstallerSet, error) {","\tlogger := logging.FromContext(ctx)","\tmanifest := r.manifest","\tmanifest = manifest.Filter(mf.ByKind(\"ConfigMap\"), mf.ByName(config.PrunerConfigMapName))","","\tlogger.Infow(\"Creating a new ConfigInstallerSet\", \"manifest\", manifest.Resources())","","\ttransformer := filterAndTransform(r.extension)","\tif _, err := transformer(ctx, \u0026manifest, tektonPruner); err != nil {","\t\ttektonPruner.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\treturn nil, err","\t}","","\t// generate installer set","\ttis := r.makeInstallerSet(tektonPruner, manifest, PrunerConfigInstallerSet)","","\t// compute the hash of  spec and store as an annotation","\t// in further reconciliation we compute hash of tektonPruner spec and check with","\t// annotation, if they are same then we skip updating the object","\t// otherwise we update the manifest","\tspecHash, err := hash.Compute(tektonPruner.Spec)","\tif err != nil {","\t\treturn nil, err","\t}","\ttis.Annotations[v1alpha1.LastAppliedHashKey] = specHash","","\t// create installer set","\tcreatedIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, tis, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn createdIs, nil","}","","func (r *Reconciler) makeInstallerSet(tc *v1alpha1.TektonPruner, manifest mf.Manifest, installerSetType string) *v1alpha1.TektonInstallerSet {","\townerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())","\tlabels := getLabels()","","\tlabels[v1alpha1.ReleaseVersionKey] = r.operatorVersion","","\treturn \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: fmt.Sprintf(\"%s-\", installerSetType),","\t\t\tLabels:       labels,","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","}","","func getLabels() map[string]string {","\tlabels := map[string]string{","\t\tv1alpha1.CreatedByKey:     CreatedByValue,","\t\tv1alpha1.InstallerSetType: PrunerConfigInstallerSet,","\t}","\treturn labels","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1]},{"id":121,"path":"pkg/reconciler/kubernetes/tektonpruner/reconcile.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tpipelineinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\ttektonprunerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// Reconciler implements controller.Reconciler for TektonPruner resources.","type Reconciler struct {","\t// operator client to interact with operator resources","\toperatorClientSet operatorclient.Interface","\t// kube client to interact with core k8s resources","\tkubeClientSet kubernetes.Interface","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// pipelineInformer to query for TektonPipeline","\tpipelineInformer pipelineinformer.TektonPipelineInformer","\t// manifest has the source manifest of Tekton Pruners for a","\t// particular version","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","\t// version of pruner which we are installing","\tprunerVersion   string","\toperatorVersion string","}","","// Check that our Reconciler implements controller.Reconciler","var _ tektonprunerreconciler.Interface = (*Reconciler)(nil)","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, tp *v1alpha1.TektonPruner) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"name\", tp.GetName())","\ttp.Status.InitializeConditions()","\ttp.Status.SetVersion(r.prunerVersion)","","\tif tp.GetName() != v1alpha1.TektonPrunerResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.TektonPrunerResourceName,","\t\t\ttp.GetName(),","\t\t)","\t\tlogger.Error(msg)","\t\ttp.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// reconcile target namespace","\tif err := common.ReconcileTargetNamespace(ctx, nil, nil, tp, r.kubeClientSet); err != nil {","\t\treturn err","\t}","\t// Make sure TektonPipeline is installed before proceeding with","\t// TektonPruner","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\ttp.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\t// (tektonpipeline.operator.tekton.dev instance not available yet)","\t\ttp.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","\ttp.Status.MarkDependenciesInstalled()","","\tif err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {","\t\tlogger.Error(\"failed to remove obsolete installer sets: %v\", err)","\t\treturn err","\t}","","\tif err := r.extension.PreReconcile(ctx, tp); err != nil {","\t\tmsg := fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\treturn err","\t\t}","\t\ttp.Status.MarkPreReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PreReconcile Complete","\ttp.Status.MarkPreReconcilerComplete()","","\t//  Create/Update Required TektonInstallerSets","\tif err := r.ensureInstallerSets(ctx, tp); err != nil {","\t\treturn err","\t}","","\tif err := r.extension.PostReconcile(ctx, tp); err != nil {","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\treturn err","\t\t}","\t\ttp.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PostReconcile Complete","\ttp.Status.MarkPostReconcilerComplete()","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,0]},{"id":122,"path":"pkg/reconciler/kubernetes/tektonpruner/transform.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tprunerCR := comp.(*v1alpha1.TektonPruner)","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PrunerImagePrefix))","\t\tprunerImages := common.ImageRegistryDomainOverride(imagesRaw)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.TektonPrunerResourceName),","\t\t\tcommon.DeploymentImages(prunerImages),","\t\t\tcommon.AddDeploymentRestrictedPSA(),","\t\t\tcommon.AddConfigMapValues(PrunerConfigMapName, prunerCR.Spec.TektonPrunerConfig),","\t\t}","\t\textra = append(extra, extension.Transformers(prunerCR)...)","\t\terr := common.Transform(ctx, manifest, prunerCR, extra...)","\t\tif err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, prunerCR.Spec.GetTargetNamespace(), prunerCR.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0]},{"id":123,"path":"pkg/reconciler/kubernetes/tektonresult/controller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineInformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\ttektonResultInformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonresult\"","\ttektonResultReconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonresult\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = \"tekton-results-info\"","","// NewController initializes the controller and is called by the generated code","// Registers event handlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","","\t\tmanifest, resultsVer := ctrl.InitController(ctx, common.PayloadOptions{})","\t\tif resultsVer == common.ReleaseVersionUnknown {","\t\t\tresultsVer = \"devel\"","\t\t}","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\trecorder, err := NewRecorder()","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error starting Results metrics\")","\t\t}","","\t\tmetricsWrapper := NewRecorderWrapper(recorder)","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","","\t\tc := \u0026Reconciler{","\t\t\tinstallerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, resultsVer, v1alpha1.KindTektonResult, metricsWrapper),","\t\t\tkubeClientSet:      kubeclient.Get(ctx),","\t\t\toperatorClientSet:  operatorclient.Get(ctx),","\t\t\textension:          generator(ctx),","\t\t\tmanifest:           \u0026manifest,","\t\t\tpipelineInformer:   tektonPipelineInformer.Get(ctx),","\t\t\toperatorVersion:    operatorVer,","\t\t\tresultsVersion:     resultsVer,","\t\t\trecorder:           recorder,","\t\t}","\t\timpl := tektonResultReconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for tekton-results\")","","\t\tif _, err := tektonResultInformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonResult informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonResult{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":124,"path":"pkg/reconciler/kubernetes/tektonresult/filter.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" B]\u003eSIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"",")","","const (","\tstatefulSetDB     = \"tekton-results-postgres\"","\tservicePostgresDB = \"tekton-results-postgres-service\"",")","","func filterExternalDB(tr *v1alpha1.TektonResult, manifest *mf.Manifest) {","\tif tr.Spec.IsExternalDB {","\t\t*manifest = manifest.Filter(mf.Not(mf.All(mf.ByKind(\"StatefulSet\"), mf.ByName(statefulSetDB))))","\t\t*manifest = manifest.Filter(mf.Not(mf.All(mf.ByKind(\"ConfigMap\"), mf.ByName(configPostgresDB))))","\t\t*manifest = manifest.Filter(mf.Not(mf.All(mf.ByKind(\"Service\"), mf.ByName(servicePostgresDB))))","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0]},{"id":125,"path":"pkg/reconciler/kubernetes/tektonresult/installerset.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","func (r *Reconciler) createInstallerSet(ctx context.Context, tr *v1alpha1.TektonResult, manifest mf.Manifest) (*v1alpha1.TektonInstallerSet, error) {","","\tif err := r.transform(ctx, \u0026manifest, tr); err != nil {","\t\ttr.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\treturn nil, err","\t}","","\t// compute the hash of tektonresult spec and store as an annotation","\t// in further reconciliation we compute hash of td spec and check with","\t// annotation, if they are same then we skip updating the object","\t// otherwise we update the manifest","\tspecHash, err := hash.Compute(tr.Spec)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// create installer set","\ttis := r.makeInstallerSet(tr, manifest, specHash)","\tcreatedIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, tis, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn createdIs, nil","}","","func (r *Reconciler) makeInstallerSet(tr *v1alpha1.TektonResult, manifest mf.Manifest, trSpecHash string) *v1alpha1.TektonInstallerSet {","\townerRef := *metav1.NewControllerRef(tr, tr.GetGroupVersionKind())","\t// Determine the subtype based on statefulset mode.","\tmode := \"deployment\"","\tif tr.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *tr.Spec.Performance.StatefulsetOrdinals {","\t\tmode = \"statefulset\"","\t}","","\treturn \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: fmt.Sprintf(\"%s-\", v1alpha1.ResultResourceName),","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.CreatedByKey:            createdByValue,","\t\t\t\tv1alpha1.InstallerSetType:        v1alpha1.ResultResourceName,","\t\t\t\tv1alpha1.ReleaseVersionKey:       r.operatorVersion,","\t\t\t\tv1alpha1.InstallerSetInstallType: mode,","\t\t\t},","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: tr.Spec.TargetNamespace,","\t\t\t\tv1alpha1.LastAppliedHashKey: trSpecHash,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":126,"path":"pkg/reconciler/kubernetes/tektonresult/metrics.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"go.opencensus.io/stats\"","\t\"go.opencensus.io/stats/view\"","\t\"go.opencensus.io/tag\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/metrics\"",")","","var (","\trReconcileCount = stats.Float64(\"results_reconciled\",","\t\t\"results reconciled with their log type\",","\t\tstats.UnitDimensionless)","\trReconcilerCountView *view.View","","\terrUninitializedRecorder = fmt.Errorf(\"ignoring the metrics recording for result failed to initialize the metrics recorder\")",")","","// Recorder holds keys for Tekton metrics","type Recorder struct {","\tinitialized bool","\tversion     tag.Key","\tlogType     tag.Key","}","","// NewRecorder creates a new metrics recorder instance","// to log the PipelineRun related metrics","func NewRecorder() (*Recorder, error) {","\tr := \u0026Recorder{","\t\tinitialized: true,","\t}","","\tversion, err := tag.NewKey(\"version\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.version = version","","\tlogType, err := tag.NewKey(\"log_type\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.logType = logType","","\trReconcilerCountView = \u0026view.View{","\t\tDescription: rReconcileCount.Description(),","\t\tMeasure:     rReconcileCount,","\t\tAggregation: view.LastValue(),","\t\tTagKeys:     []tag.Key{r.version, r.logType},","\t}","","\terr = view.Register(rReconcilerCountView)","","\tif err != nil {","\t\tr.initialized = false","\t\treturn r, err","\t}","","\treturn r, nil","}","","// Record the Results reconciled with their log type","func (r *Recorder) Count(version, logType string) error {","\tif !r.initialized {","\t\treturn errUninitializedRecorder","\t}","","\tctx, err := tag.New(","\t\tcontext.Background(),","\t\ttag.Insert(r.version, version),","\t\ttag.Insert(r.logType, logType),","\t)","","\tif err != nil {","\t\treturn err","\t}","\tmetrics.Record(ctx, rReconcileCount.M(float64(1)))","\treturn nil","}","","func (m *Recorder) LogMetrics(version string, spec v1alpha1.TektonResultSpec, logger *zap.SugaredLogger) {","\terr := m.Count(version, spec.Result.ResultsAPIProperties.LogsType)","\tif err != nil {","\t\tlogger.Warnf(\"%v: Failed to log the metrics : %v\", v1alpha1.KindTektonResult, err)","\t}","}","","// RecorderWrapper wraps the existing Recorder to implement this interface.","type RecorderWrapper struct {","\trecorder *Recorder","}","","// NewRecorderWrapper creates a new RecorderWrapper instance.","func NewRecorderWrapper(recorder *Recorder) *RecorderWrapper {","\treturn \u0026RecorderWrapper{recorder: recorder}","}","","// LogMetrics implements the Metrics interface by converting the provided logType string","// into a TektonResultSpec before calling the underlying Recorder's LogMetrics method.","func (rw *RecorderWrapper) LogMetrics(logType string, version string, logger *zap.SugaredLogger) {","\tspec := v1alpha1.TektonResultSpec{","\t\tResult: v1alpha1.Result{","\t\t\tResultsAPIProperties: v1alpha1.ResultsAPIProperties{","\t\t\t\tLogsType: logType,","\t\t\t},","\t\t},","\t}","\trw.recorder.LogMetrics(version, spec, logger)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,2,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,1,1,2,2,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1]},{"id":127,"path":"pkg/reconciler/kubernetes/tektonresult/tektonresult.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\t\"context\"","\t\"crypto/ecdsa\"","\t\"crypto/elliptic\"","\t\"crypto/rand\"","\t\"crypto/x509\"","\t\"crypto/x509/pkix\"","\t\"encoding/base64\"","\t\"encoding/pem\"","\t\"errors\"","\t\"fmt\"","\t\"math/big\"","\t\"time\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tpipelineInformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\ttektonresultconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonresult\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const (","\tDefaultDbSecretName          = \"tekton-results-postgres\"","\tTlsSecretName                = \"tekton-results-tls\"","\tCertificateBlockType         = \"CERTIFICATE\"","\tPostgresUser                 = \"result\"","\tECPrivateKeyBlockType        = \"EC PRIVATE KEY\"","\ttektonResultStatefulSetLabel = \"statefulset\"","\ttektonResultDeploymentLabel  = \"deployment\"",")","","// Reconciler implements controller.Reconciler for TektonResult resources.","type Reconciler struct {","\t// kubeClientSet allows us to talk to the k8s for core APIs","\tkubeClientSet kubernetes.Interface","\t// operatorClientSet allows us to configure operator objects","\toperatorClientSet clientset.Interface","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// manifest is empty, but with a valid client and logger. all","\t// manifests are immutable, and any created during reconcile are","\t// expected to be appended to this one, obviating the passing of","\t// client \u0026 logger","\tmanifest *mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","","\tpipelineInformer pipelineInformer.TektonPipelineInformer","","\toperatorVersion string","\tresultsVersion  string","\trecorder        *Recorder","}","","// Check that our Reconciler implements controller.Reconciler","var _ tektonresultconciler.Interface = (*Reconciler)(nil)","var _ tektonresultconciler.Finalizer = (*Reconciler)(nil)","","var (","\tls = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     createdByValue,","\t\t\tv1alpha1.InstallerSetType: v1alpha1.ResultResourceName,","\t\t},","\t}",")","","const createdByValue = \"TektonResult\"","","// FinalizeKind removes all resources after deletion of a TektonResult.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonResult) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\tlabelSelector, err := common.LabelSelector(ls)","\tif err != nil {","\t\treturn err","\t}","\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tDeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{","\t\t\tLabelSelector: labelSelector,","\t\t}); err != nil {","\t\tlogger.Error(\"Failed to delete installer set created by TektonResult\", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","","\treturn nil","}","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, tr *v1alpha1.TektonResult) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"tektonresult\", tr.Name)","\tdefer r.recorder.LogMetrics(r.resultsVersion, tr.Spec, logger)","","\ttr.Status.InitializeConditions()","\ttr.Status.ObservedGeneration = tr.Generation","","\tlogger.Infow(\"Starting TektonResults reconciliation\",","\t\t\"version\", r.resultsVersion,","\t\t\"generation\", tr.Generation,","\t\t\"status\", tr.Status.GetCondition(apis.ConditionReady))","","\tmanifest := *r.manifest","","\tif tr.GetName() != v1alpha1.ResultResourceName {","\t\tlogger.Errorw(\"Invalid resource name\",","\t\t\t\"expectedName\", v1alpha1.ResultResourceName,","\t\t\t\"actualName\", tr.GetName())","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.ResultResourceName, tr.GetName())","\t\ttr.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// find the valid tekton-pipeline installation","\ttp, err := common.PipelineReady(r.pipelineInformer)","\tif err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\tlogger.Infow(\"Waiting for tekton-pipelines installation to complete\")","\t\t\ttr.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn fmt.Errorf(common.PipelineNotReady)","\t\t}","\t\t// tektonpipeline.operator.tekton.dev instance not available yet","\t\tlogger.Errorw(\"Pipeline dependency not found\", \"error\", err)","\t\ttr.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","","\tif tp.GetSpec().GetTargetNamespace() != tr.GetSpec().GetTargetNamespace() {","\t\terrMsg := fmt.Sprintf(\"tekton-pipelines is missing in %s namespace\", tr.GetSpec().GetTargetNamespace())","\t\tlogger.Errorw(\"Namespace mismatch for pipeline dependency\",","\t\t\t\"resultNamespace\", tr.GetSpec().GetTargetNamespace(),","\t\t\t\"pipelineNamespace\", tp.GetSpec().GetTargetNamespace())","\t\ttr.Status.MarkDependencyMissing(errMsg)","\t\treturn errors.New(errMsg)","\t}","","\t// If the external database is disabled, create a default database and a TLS secret.","\t// Otherwise, verify if the default database secret is already created, and ensure the TLS secret is also created.","\tif !tr.Spec.IsExternalDB \u0026\u0026 tr.Spec.DBSecretName == \"\" {","\t\tlogger.Debugw(\"Creating database secret for internal database\")","\t\tif err := r.createDBSecret(ctx, tr); err != nil {","\t\t\tlogger.Errorw(\"Failed to create database secret\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Debugw(\"Creating TLS secret for internal database\")","\t\tif err := r.createTLSSecret(ctx, tr); err != nil {","\t\t\tlogger.Errorw(\"Failed to create TLS secret\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Successfully created database and TLS secrets\")","\t} else {","\t\tcustomDbSecretName := DefaultDbSecretName","\t\tif tr.Spec.DBSecretName != \"\" {","\t\t\tcustomDbSecretName = tr.Spec.DBSecretName","\t\t}","\t\tlogger.Debugw(\"Validating external database secrets\")","\t\tif err := r.validateSecretsAreCreated(ctx, tr, customDbSecretName); err != nil {","\t\t\tlogger.Errorw(\"Failed to validate database secrets\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Debugw(\"Creating TLS secret for external database\")","\t\tif err := r.createTLSSecret(ctx, tr); err != nil {","\t\t\tlogger.Errorw(\"Failed to create TLS secret\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Info(\"Successfully validated database secrets and created TLS secret\")","\t}","","\ttr.Status.MarkDependenciesInstalled()","\tlogger.Info(\"All dependencies installed successfully\")","","\t//Result watcher is deployed as statefulset, ensure deployment installerset is deleted","\tif tr.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *tr.Spec.Performance.StatefulsetOrdinals {","\t\tif err := r.installerSetClient.CleanupWithLabelInstallTypeDeployment(ctx, v1alpha1.ResultResourceName); err != nil {","\t\t\tlogger.Error(\"failed to delete main deployment installer set: %v\", err)","\t\t\treturn err","\t\t}","\t} else {","\t\t// Result watcher is deployed as deployment, ensure statefulset installerset is deleted","\t\tif err := r.installerSetClient.CleanupWithLabelInstallTypeStatefulset(ctx, v1alpha1.ResultResourceName); err != nil {","\t\t\tlogger.Error(\"failed to delete main statefulset installer set: %v\", err)","\t\t\treturn err","\t\t}","\t}","","\tif err := r.extension.PreReconcile(ctx, tr); err != nil {","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Info(\"PreReconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmsg := fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"PreReconciliation failed\", \"error\", err)","\t\ttr.Status.MarkPreReconcilerFailed(msg)","\t\treturn nil","\t}","","\ttr.Status.MarkPreReconcilerComplete()","\tlogger.Info(\"PreReconciliation completed successfully\")","","\t// Check if an tektoninstallerset already exists, if not then create","\tlabelSelector, err := common.LabelSelector(ls)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to create label selector\", \"error\", err)","\t\treturn err","\t}","","\tlogger.Debugw(\"Checking for existing installer set\")","\texistingInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to get current installer set name\", \"error\", err)","\t\treturn err","\t}","","\tif existingInstallerSet == \"\" {","\t\tlogger.Info(\"No existing installer set found, creating new one\")","\t\tcreatedIs, err := r.createInstallerSet(ctx, tr, manifest)","","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to create installer set\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Successfully created installer set\", \"name\", createdIs.Name)","\t\tr.updateTektonResultsStatus(ctx, tr, createdIs)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","\t// If exists, then fetch the TektonInstallerSet","\tlogger.Debugw(\"Fetching existing installer set\", \"name\", existingInstallerSet)","\tinstalledTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tGet(ctx, existingInstallerSet, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\tlogger.Infow(\"Existing installer set not found, creating new one\", \"missingSet\", existingInstallerSet)","\t\t\tcreatedIs, err := r.createInstallerSet(ctx, tr, manifest)","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to create installer set\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tlogger.Infow(\"Successfully created installer set\", \"name\", createdIs.Name)","\t\t\tr.updateTektonResultsStatus(ctx, tr, createdIs)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Errorw(\"Failed to get existing installer set\", \"name\", existingInstallerSet, \"error\", err)","\t\treturn err","\t}","","\tinstallerSetTargetNamespace := installedTIS.Annotations[v1alpha1.TargetNamespaceKey]","\tinstallerSetReleaseVersion := installedTIS.Labels[v1alpha1.ReleaseVersionKey]","","\t// Check if TargetNamespace of existing TektonInstallerSet is same as expected","\t// Check if Release Version in TektonInstallerSet is same as expected","\t// If any of the thing above is not same then delete the existing TektonInstallerSet","\t// and create a new with expected properties","\tif installerSetTargetNamespace != tr.Spec.TargetNamespace || installerSetReleaseVersion != r.operatorVersion {","\t\tlogger.Infow(\"Configuration changed, deleting existing installer set\",","\t\t\t\"existingNamespace\", installerSetTargetNamespace,","\t\t\t\"newNamespace\", tr.Spec.TargetNamespace,","\t\t\t\"existingVersion\", installerSetReleaseVersion,","\t\t\t\"newVersion\", r.operatorVersion)","\t\t// Delete the existing TektonInstallerSet","\t\terr := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tDelete(ctx, existingInstallerSet, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to delete installer set\", \"name\", existingInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Successfully deleted installer set\", \"name\", existingInstallerSet)","","\t\t// Make sure the TektonInstallerSet is deleted","\t\t_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, existingInstallerSet, metav1.GetOptions{})","\t\tif err == nil {","\t\t\tlogger.Infow(\"Waiting for previous installer set to be deleted\", \"name\", existingInstallerSet)","\t\t\ttr.Status.MarkNotReady(\"Waiting for previous installer set to get deleted\")","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tif !apierrors.IsNotFound(err) {","\t\t\tlogger.Errorw(\"Failed to verify installer set deletion\", \"name\", existingInstallerSet, \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Infow(\"Confirmed installer set deletion\", \"name\", existingInstallerSet)","\t\treturn nil","","\t} else {","\t\t// If target namespace and version are not changed then check if spec","\t\t// of TektonResult is changed by checking hash stored as annotation on","\t\t// TektonInstallerSet with computing new hash of TektonResult Spec","\t\tlogger.Debug(\"Checking for spec changes in TektonResult\")","\t\t// Hash of TektonResult Spec","\t\texpectedSpecHash, err := hash.Compute(tr.Spec)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to compute spec hash\", \"error\", err)","\t\t\treturn err","\t\t}","","\t\t// spec hash stored on installerSet","\t\tlastAppliedHash := installedTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]","","\t\tif lastAppliedHash != expectedSpecHash {","\t\t\tlogger.Infow(\"TektonResult spec changed, updating installer set\",","\t\t\t\t\"previousHash\", lastAppliedHash,","\t\t\t\t\"newHash\", expectedSpecHash)","","\t\t\tif err := r.transform(ctx, \u0026manifest, tr); err != nil {","\t\t\t\tlogger.Errorw(\"Manifest transformation failed\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// Update the spec hash","\t\t\tcurrent := installedTIS.GetAnnotations()","\t\t\tcurrent[v1alpha1.LastAppliedHashKey] = expectedSpecHash","\t\t\tinstalledTIS.SetAnnotations(current)","","\t\t\t// Update the manifests","\t\t\tinstalledTIS.Spec.Manifests = manifest.Resources()","\t\t\tupdatedIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tUpdate(ctx, installedTIS, metav1.UpdateOptions{})","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to update installer set\", \"name\", installedTIS.Name, \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\tlogger.Infow(\"Successfully updated installer set with new spec\",","\t\t\t\t\"name\", updatedIS.Name,","\t\t\t\t\"newHash\", expectedSpecHash)","\t\t\t// after updating installer set enqueue after a duration","\t\t\t// to allow changes to get deployed","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t} else {","\t\t\tlogger.Debugw(\"No changes detected in TektonResult spec\", \"hash\", expectedSpecHash)","\t\t}","\t}","","\tr.updateTektonResultsStatus(ctx, tr, installedTIS)","","\t// Mark InstallerSet Available","\ttr.Status.MarkInstallerSetAvailable()","\tlogger.Infow(\"Marked installer set as available\", \"name\", installedTIS.Name)","","\tready := installedTIS.Status.GetCondition(apis.ConditionReady)","\tif ready == nil {","\t\tlogger.Infow(\"Installer set not yet reporting status\", \"name\", installedTIS.Name)","\t\ttr.Status.MarkInstallerSetNotReady(\"Waiting for installation\")","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\tif ready.Status == corev1.ConditionUnknown {","\t\tlogger.Infow(\"Installer set status is unknown, waiting\", \"name\", installedTIS.Name)","\t\ttr.Status.MarkInstallerSetNotReady(\"Waiting for installation\")","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t} else if ready.Status == corev1.ConditionFalse {","\t\tlogger.Warnw(\"Installer set not ready\", \"name\", installedTIS.Name, \"message\", ready.Message)","\t\ttr.Status.MarkInstallerSetNotReady(ready.Message)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\t// MarkInstallerSetReady","\ttr.Status.MarkInstallerSetReady()","\tlogger.Infow(\"Installer set is ready\", \"name\", installedTIS.Name)","","\tif err := r.extension.PostReconcile(ctx, tr); err != nil {","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Infow(\"PostReconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"PostReconciliation failed\", \"error\", err)","\t\ttr.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PostReconcile Complete","\tlogger.Infow(\"PostReconciliation completed successfully\")","\ttr.Status.MarkPostReconcilerComplete()","\tr.updateTektonResultsStatus(ctx, tr, installedTIS)","","\tlogger.Infow(\"TektonResults reconciliation completed successfully\",","\t\t\"ready\", tr.Status.GetCondition(apis.ConditionReady).IsTrue(),","\t\t\"generation\", tr.Status.ObservedGeneration)","","\treturn nil","}","","func (r *Reconciler) updateTektonResultsStatus(ctx context.Context, tr *v1alpha1.TektonResult, createdIs *v1alpha1.TektonInstallerSet) {","\t// update the tr with TektonInstallerSet","\ttr.Status.SetTektonInstallerSet(createdIs.Name)","\ttr.Status.SetVersion(r.resultsVersion)","}","","// TektonResults expects secrets to be created before installing","func (r *Reconciler) validateSecretsAreCreated(ctx context.Context, tr *v1alpha1.TektonResult, secretName string) error {","\tlogger := logging.FromContext(ctx)","\t_, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Get(ctx, secretName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\tlogger.Error(err)","\t\t\ttr.Status.MarkDependencyMissing(fmt.Sprintf(\"%s secret is missing\", secretName))","\t\t\treturn err","\t\t}","\t\tlogger.Error(err)","\t\treturn err","\t}","\treturn nil","}","","// Generate the DB secret","func (r *Reconciler) generateDBSecret(name string, namespace string, tr *v1alpha1.TektonResult) (*corev1.Secret, error) {","\ts := \u0026corev1.Secret{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            name,","\t\t\tNamespace:       namespace,","\t\t\tOwnerReferences: []metav1.OwnerReference{getOwnerRef(tr)},","\t\t},","\t\tType:       corev1.SecretTypeOpaque,","\t\tStringData: map[string]string{},","\t}","\tpassword, err := generateRandomBaseString(20)","\tif err != nil {","\t\treturn nil, err","\t}","\ts.StringData[\"POSTGRES_PASSWORD\"] = password","\ts.StringData[\"POSTGRES_USER\"] = PostgresUser","\treturn s, nil","}","","// Create Result default database secret","func (r *Reconciler) createDBSecret(ctx context.Context, tr *v1alpha1.TektonResult) error {","\tlogger := logging.FromContext(ctx)","","\t// Get the DB secret, if not found then create the DB secret","\t_, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Get(ctx, DefaultDbSecretName, metav1.GetOptions{})","\tif err == nil {","\t\treturn nil","\t}","\tif !apierrors.IsNotFound(err) {","\t\tlogger.Errorf(\"failed to find default TektonResult database secret %s in namespace %s: %v\", DefaultDbSecretName, tr.Spec.TargetNamespace, err)","\t\treturn err","\t}","\tnewDBSecret, err := r.generateDBSecret(DefaultDbSecretName, tr.Spec.TargetNamespace, tr)","\tif err != nil {","\t\tlogger.Errorf(\"failed to generate default TektonResult database secret %s: %s\", DefaultDbSecretName, err)","\t\treturn err","\t}","\t_, err = r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Create(ctx, newDBSecret, metav1.CreateOptions{})","\tif err != nil {","\t\tlogger.Errorf(\"failed to create default TektonResult database secret %s in namespace %s: %v\", DefaultDbSecretName, tr.Spec.TargetNamespace, err)","\t\ttr.Status.MarkDependencyMissing(fmt.Sprintf(\"Default db %s creation is failing\", DefaultDbSecretName))","\t\treturn err","\t}","\treturn nil","}","","// Create default TLS certificates for the database","func (r *Reconciler) createTLSSecret(ctx context.Context, tr *v1alpha1.TektonResult) error {","\tlogger := logging.FromContext(ctx)","","\tif v1alpha1.IsOpenShiftPlatform() {","\t\tlogger.Info(\"Skipping default TLS secret creation: running on OpenShift platform\")","\t\treturn nil","\t}","","\t_, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Get(ctx, TlsSecretName, metav1.GetOptions{})","\tif err == nil {","\t\treturn nil","\t}","\tif !apierrors.IsNotFound(err) {","\t\tlogger.Errorf(\"failed to find default TektonResult TLS secret %s in namespace %s: %v\", TlsSecretName, tr.Spec.TargetNamespace, err)","\t\treturn err","\t}","\tcertPEM, keyPEM, err := generateTLSCertificate(tr.Spec.TargetNamespace)","\tif err != nil {","\t\tlogger.Errorf(\"failed to generate default TektonResult TLS certificate: %v\", err)","\t\treturn err","\t}","\t// Create Kubernetes TLS secret","\terr = r.createKubernetesTLSSecret(ctx, tr.Spec.TargetNamespace, TlsSecretName, certPEM, keyPEM, tr)","\tif err != nil {","\t\tlogger.Errorf(\"failed to create TLS secret %s in namespace %s: %v\", TlsSecretName, tr.Spec.TargetNamespace, err)","","\t}","\treturn nil","}","","// Get an owner reference of Tekton Result","func getOwnerRef(tr *v1alpha1.TektonResult) metav1.OwnerReference {","\treturn *metav1.NewControllerRef(tr, tr.GroupVersionKind())","}","","func generateRandomBaseString(size int) (string, error) {","\tbytes := make([]byte, size)","","\t// Generate random bytes","\t_, err := rand.Read(bytes)","\tif err != nil {","\t\treturn \"\", err","\t}","\t// Encode the random bytes into a Base64 string","\tbase64String := base64.StdEncoding.EncodeToString(bytes)","","\treturn base64String, nil","}","","// generateTLSCertificate generates a self-signed TLS certificate and private key.","func generateTLSCertificate(targetNS string) (certPEM, keyPEM []byte, err error) {","","\t// Define subject and DNS names","\tdnsName := fmt.Sprintf(\"tekton-results-api-service.%s.svc.cluster.local\", targetNS)","","\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)","\tif err != nil {","\t\treturn nil, nil, err","\t}","","\tnotBefore := time.Now()","\tnotAfter := notBefore.Add(365 * 24 * time.Hour)","","\tserialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))","\tif err != nil {","\t\treturn nil, nil, err","\t}","","\ttemplate := x509.Certificate{","\t\tSerialNumber: serialNumber,","\t\tIssuer:       pkix.Name{},","\t\tSubject: pkix.Name{","\t\t\tCommonName: dnsName,","\t\t},","\t\tDNSNames:              []string{dnsName},","\t\tNotBefore:             notBefore,","\t\tNotAfter:              notAfter,","\t\tKeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,","\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},","\t\tBasicConstraintsValid: true,","\t}","","\tcertDER, err := x509.CreateCertificate(rand.Reader, \u0026template, \u0026template, \u0026priv.PublicKey, priv)","\tif err != nil {","\t\treturn nil, nil, err","\t}","","\tcertPEM = pem.EncodeToMemory(\u0026pem.Block{Type: CertificateBlockType, Bytes: certDER})","","\tprivBytes, err := x509.MarshalECPrivateKey(priv)","\tif err != nil {","\t\treturn nil, nil, err","\t}","\tkeyPEM = pem.EncodeToMemory(\u0026pem.Block{Type: ECPrivateKeyBlockType, Bytes: privBytes})","","\treturn certPEM, keyPEM, nil","}","","// createKubernetesSecret creates a Kubernetes TLS secret with the given cert and key.","func (r *Reconciler) createKubernetesTLSSecret(ctx context.Context, namespace, secretName string, certPEM, keyPEM []byte, tr *v1alpha1.TektonResult) error {","","\t// Define the secret","\tlogger := logging.FromContext(ctx)","\tsecret := \u0026corev1.Secret{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:      secretName,","\t\t\tNamespace: namespace,","\t\t},","\t\tType: corev1.SecretTypeTLS,","\t\tData: map[string][]byte{","\t\t\tcorev1.TLSCertKey:       certPEM,","\t\t\tcorev1.TLSPrivateKeyKey: keyPEM,","\t\t},","\t}","","\t_, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Create(ctx, secret, metav1.CreateOptions{})","\tif err != nil {","\t\tlogger.Errorf(\"failed to create TLS secret %s in namespace %s: %v\", secretName, namespace, err)","\t\ttr.Status.MarkDependencyMissing(fmt.Sprintf(\"Default TLS Secret %s creation is failing\", secretName))","\t\treturn err","\t}","","\tlogger.Infof(\"Secret '%s' created successfully in namespace '%s'\\n\", secretName, namespace)","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0]},{"id":128,"path":"pkg/reconciler/kubernetes/tektonresult/transform.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" B]\u003eSIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strconv\"","\t\"strings\"","","\tappsv1 \"k8s.io/api/apps/v1\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\tk8sruntime \"k8s.io/apimachinery/pkg/runtime\"","\t\"knative.dev/pkg/ptr\"",")","","const (","\t// Results ConfigMap","\tconfigAPI                         = \"tekton-results-api-config\"","\tdeploymentAPI                     = \"tekton-results-api\"","\tconfigINFO                        = \"tekton-results-info\"","\tconfigMetrics                     = \"tekton-results-config-observability\"","\tconfigPostgresDB                  = \"tekton-results-postgres\"","\tpvcLoggingVolume                  = \"tekton-logs\"","\tapiContainerName                  = \"api\"","\tretentionPolicyAgentContainerName = \"retention-policy-agent\"","\twatcherContainerName              = \"watcher\"","\tgoogleAPPCredsEnvName             = \"GOOGLE_APPLICATION_CREDENTIALS\"","\tgoogleCredsVolName                = \"google-creds\"","\tgoogleCredsPath                   = \"/creds/google\"","","\tloggingProxyPath              = \"LOGGING_PLUGIN_PROXY_PATH\"","\tloggingAPIURL                 = \"LOGGING_PLUGIN_API_URL\"","\tloggingTokenPath              = \"LOGGING_PLUGIN_TOKEN_PATH\"","\tloggingNamespaceKey           = \"LOGGING_PLUGIN_NAMESPACE_KEY\"","\tloggingStaticLabels           = \"LOGGING_PLUGIN_STATIC_LABELS\"","\tloggingForwarderDelayDuration = \"LOGGING_PLUGIN_FORWARDER_DELAY_DURATION\"","\tlogsAPIKey                    = \"LOGS_API\"","\tlogsTypeKey                   = \"LOGS_TYPE\"","","\tresultAPIDeployment                          = \"tekton-results-api\"","\tresultWatcherDeployment                      = \"tekton-results-watcher\"","\tresultWatcherContainer                       = \"watcher\"","\ttektonResultWatcherName                      = \"tekton-results-watcher\"","\ttektonResultWatcherServiceName               = \"tekton-results-watcher\"","\ttektonResultWatcherStatefulServiceName       = \"STATEFUL_SERVICE_NAME\"","\ttektonResultWatcherStatefulControllerOrdinal = \"STATEFUL_CONTROLLER_ORDINAL\"","\ttektonResultleaderElectionConfig             = \"tekton-results-config-leader-election\"",")","","var (","\tresultDeployementNames = []string{resultAPIDeployment, resultWatcherDeployment}","\t// allowed property secret keys","\tallowedPropertySecretKeys = []string{","\t\t\"S3_BUCKET_NAME\",","\t\t\"S3_ENDPOINT\",","\t\t\"S3_HOSTNAME_IMMUTABLE\",","\t\t\"S3_REGION\",","\t\t\"S3_ACCESS_KEY_ID\",","\t\t\"S3_SECRET_ACCESS_KEY\",","\t\t\"S3_MULTI_PART_SIZE\",","\t}","\tDB_USER     = \"DB_USER\"","\tDB_PASSWORD = \"DB_PASSWORD\"","\t// maps container env key with db secret key","\tContainerEnvKeys = map[string]string{","\t\tDB_USER:     \"POSTGRES_USER\",","\t\tDB_PASSWORD: \"POSTGRES_PASSWORD\",","\t}",")","","// transform mutates the passed manifest to one with common, component","// and platform transformations applied","func (r *Reconciler) transform(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) error {","\tinstance := comp.(*v1alpha1.TektonResult)","\tresultImgs := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ResultsImagePrefix))","","\ttargetNs := comp.GetSpec().GetTargetNamespace()","\tfilterExternalDB(instance, manifest)","\textra := []mf.Transformer{","\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdResults),","\t\tcommon.ApplyProxySettings,","\t\tcommon.ReplaceNamespaceInDeploymentArgs([]string{resultWatcherDeployment}, targetNs),","\t\tcommon.ReplaceNamespaceInDeploymentEnv(resultDeployementNames, targetNs),","\t\tupdateApiConfig(instance.Spec),","\t\tupdateApiEnv(instance.Spec),","\t\tenablePVCLogging(instance.Spec.ResultsAPIProperties),","\t\tupdateEnvWithSecretName(instance.Spec.ResultsAPIProperties),","\t\tupdateEnvWithDBSecretName(instance.Spec.ResultsAPIProperties),","\t\tpopulateGoogleCreds(instance.Spec.ResultsAPIProperties),","\t\tcommon.AddDeploymentRestrictedPSA(),","\t\tcommon.AddConfiguration(instance.Spec.Config),","\t\tcommon.AddStatefulSetRestrictedPSA(),","\t\tcommon.DeploymentImages(resultImgs),","\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\tcommon.StatefulSetImages(resultImgs),","\t\tcommon.AddConfigMapValues(tektonResultleaderElectionConfig, instance.Spec.Performance.PerformanceLeaderElectionConfig),","\t\tcommon.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(\u0026instance.Spec.Performance, tektonResultleaderElectionConfig, resultWatcherDeployment, resultWatcherContainer),","\t\t// Note: PostgreSQL upgrade transformer is NOT needed for Kubernetes","\t}","","\tif instance.Spec.Performance.StatefulsetOrdinals != nil \u0026\u0026 *instance.Spec.Performance.StatefulsetOrdinals {","\t\textra = append(extra,","\t\t\tcommon.ConvertDeploymentToStatefulSet(tektonResultWatcherName, tektonResultWatcherServiceName),","\t\t\tcommon.AddStatefulEnvVars(tektonResultWatcherName, tektonResultWatcherServiceName, tektonResultWatcherStatefulServiceName, tektonResultWatcherStatefulControllerOrdinal),","\t\t)","\t}","","\textra = append(extra, r.extension.Transformers(instance)...)","\terr := common.Transform(ctx, manifest, instance, extra...)","\tif err != nil {","\t\treturn err","\t}","","\t// additional options transformer","\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, instance.Spec.GetTargetNamespace(), instance.Spec.Options); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func enablePVCLogging(p v1alpha1.ResultsAPIProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif p.LogsAPI == nil || !*p.LogsAPI || p.LoggingPVCName == \"\" || p.LogsPath == \"\" || u.GetKind() != \"Deployment\" || u.GetName() != deploymentAPI {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tupdatePVC := true","\t\tfor i := 0; i \u003c len(d.Spec.Template.Spec.Containers[0].VolumeMounts); i++ {","\t\t\tif d.Spec.Template.Spec.Containers[0].VolumeMounts[i].Name == pvcLoggingVolume {","\t\t\t\td.Spec.Template.Spec.Containers[0].VolumeMounts[i] = corev1.VolumeMount{","\t\t\t\t\tName:      pvcLoggingVolume,","\t\t\t\t\tMountPath: p.LogsPath,","\t\t\t\t}","\t\t\t\tupdatePVC = false","\t\t\t}","\t\t}","\t\tif updatePVC {","\t\t\td.Spec.Template.Spec.Containers[0].VolumeMounts = append(","\t\t\t\td.Spec.Template.Spec.Containers[0].VolumeMounts,","\t\t\t\tcorev1.VolumeMount{Name: pvcLoggingVolume,","\t\t\t\t\tMountPath: p.LogsPath,","\t\t\t\t})","\t\t}","","\t\tupdatePVC = true","\t\tvol := corev1.Volume{","\t\t\tName: pvcLoggingVolume,","\t\t\tVolumeSource: corev1.VolumeSource{","\t\t\t\tPersistentVolumeClaim: \u0026corev1.PersistentVolumeClaimVolumeSource{","\t\t\t\t\tClaimName: p.LoggingPVCName,","\t\t\t\t},","\t\t\t},","\t\t}","\t\tfor i := 0; i \u003c len(d.Spec.Template.Spec.Volumes); i++ {","\t\t\tif d.Spec.Template.Spec.Volumes[i].Name == pvcLoggingVolume {","\t\t\t\td.Spec.Template.Spec.Volumes[i] = vol","\t\t\t\tupdatePVC = false","\t\t\t}","\t\t}","\t\tif updatePVC {","\t\t\td.Spec.Template.Spec.Volumes = append(d.Spec.Template.Spec.Volumes, vol)","\t\t}","","\t\tunstrObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","func updateApiConfig(s v1alpha1.TektonResultSpec) mf.Transformer {","\tp := s.ResultsAPIProperties","","\treturn func(u *unstructured.Unstructured) error {","","\t\tkind := strings.ToLower(u.GetKind())","\t\tif kind != \"configmap\" {","\t\t\treturn nil","\t\t}","","\t\tif u.GetName() != configAPI {","\t\t\treturn nil","\t\t}","","\t\tcm := \u0026corev1.ConfigMap{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif cm.Data == nil {","\t\t\tcm.Data = map[string]string{}","\t\t}","","\t\tvalues := reflect.ValueOf(p)","\t\ttypes := values.Type()","\t\tprop := make(map[string]string)","","\t\tapplyLokiStackConfig(prop, s.LokiStackProperties)","","\t\tif !s.IsExternalDB {","\t\t\tprop[\"DB_HOST\"] = \"tekton-results-postgres-service.\" + s.TargetNamespace + \".svc.cluster.local\"","\t\t}","","\t\tfor i := 0; i \u003c values.NumField(); i++ {","\t\t\tkey := strings.Split(types.Field(i).Tag.Get(\"json\"), \",\")[0]","\t\t\tif key == \"\" {","\t\t\t\tcontinue","\t\t\t}","\t\t\tukey := strings.ToUpper(key)","","\t\t\tif values.Field(i).Kind() == reflect.Bool {","\t\t\t\tprop[ukey] = strconv.FormatBool(values.Field(i).Bool())","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif values.Field(i).Kind() == reflect.Int64 {","\t\t\t\tprop[ukey] = strconv.FormatInt(values.Field(i).Int(), 10)","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif values.Field(i).Kind() == reflect.Uint64 {","\t\t\t\tprop[ukey] = strconv.FormatUint(values.Field(i).Uint(), 10)","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif values.Field(i).Kind() == reflect.Ptr {","\t\t\t\tinnerElem := values.Field(i).Elem()","","\t\t\t\tif !innerElem.IsValid() {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tswitch innerElem.Kind() {","\t\t\t\tcase reflect.Bool:","\t\t\t\t\tprop[ukey] = strconv.FormatBool(innerElem.Bool())","\t\t\t\t\tcontinue","","\t\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:","\t\t\t\t\tprop[ukey] = strconv.FormatInt(innerElem.Int(), 10)","\t\t\t\t\tcontinue","","\t\t\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:","\t\t\t\t\tprop[ukey] = strconv.FormatUint(innerElem.Uint(), 10)","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t}","","\t\t\tif value := values.Field(i).String(); value != \"\" {","\t\t\t\tprop[ukey] = value","\t\t\t}","\t\t}","","\t\tconfig := cm.Data[\"config\"]","\t\tcl := strings.Split(config, \"\\n\")","\t\tfor i := range cl {","\t\t\tkey := strings.Split(cl[i], \"=\")","\t\t\tval, ok := prop[key[0]]","\t\t\tif ok {","\t\t\t\tcl[i] = fmt.Sprintf(\"%s=%s\", key[0], val)","\t\t\t}","\t\t}","","\t\tconfig = strings.Join(cl, \"\\n\")","","\t\tcm.Data[\"config\"] = config","\t\tunstrObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","// update the api container envs with result api properties","// as result api server configuration depends on the envs","func updateApiEnv(s v1alpha1.TektonResultSpec) mf.Transformer {","\tp := s.ResultsAPIProperties","\treturn func(u *unstructured.Unstructured) error {","","\t\tif u.GetKind() != \"Deployment\" || u.GetName() != deploymentAPI {","\t\t\treturn nil","\t\t}","","\t\tvalues := reflect.ValueOf(p)","\t\ttypes := reflect.TypeOf(p)","\t\tprop := make(map[string]string)","","\t\tapplyLokiStackConfig(prop, s.LokiStackProperties)","","\t\tif !s.IsExternalDB {","\t\t\tprop[\"DB_HOST\"] = \"tekton-results-postgres-service.\" + s.TargetNamespace + \".svc.cluster.local\"","\t\t}","","\t\tdep := \u0026appsv1.Deployment{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tfor i := 0; i \u003c values.NumField(); i++ {","\t\t\tkey := strings.Split(types.Field(i).Tag.Get(\"json\"), \",\")[0]","\t\t\tif key == \"\" {","\t\t\t\tcontinue","\t\t\t}","\t\t\tukey := strings.ToUpper(key)","","\t\t\tif values.Field(i).Kind() == reflect.Bool {","\t\t\t\tprop[ukey] = strconv.FormatBool(values.Field(i).Bool())","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif values.Field(i).Kind() == reflect.Int64 {","\t\t\t\tprop[ukey] = strconv.FormatInt(values.Field(i).Int(), 10)","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif values.Field(i).Kind() == reflect.Uint64 {","\t\t\t\tprop[ukey] = strconv.FormatUint(values.Field(i).Uint(), 10)","\t\t\t\tcontinue","\t\t\t}","","\t\t\tif values.Field(i).Kind() == reflect.Ptr {","\t\t\t\tinnerElem := values.Field(i).Elem()","","\t\t\t\tif !innerElem.IsValid() {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tswitch innerElem.Kind() {","\t\t\t\tcase reflect.Bool:","\t\t\t\t\tprop[ukey] = strconv.FormatBool(innerElem.Bool())","\t\t\t\t\tcontinue","","\t\t\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:","\t\t\t\t\tprop[ukey] = strconv.FormatInt(innerElem.Int(), 10)","\t\t\t\t\tcontinue","","\t\t\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:","\t\t\t\t\tprop[ukey] = strconv.FormatUint(innerElem.Uint(), 10)","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t}","","\t\t\tif value := values.Field(i).String(); value != \"\" {","\t\t\t\tprop[ukey] = value","\t\t\t}","\t\t}","","\t\t// finds api container and update the matched env and adds other result properties as env","\t\tfor containerIndex, container := range dep.Spec.Template.Spec.Containers {","\t\t\tif container.Name != apiContainerName {","\t\t\t\tcontinue","\t\t\t}","","\t\t\texistingContainerEnv := container.Env","\t\t\tif existingContainerEnv == nil {","\t\t\t\texistingContainerEnv = make([]corev1.EnvVar, 0)","\t\t\t}","","\t\t\treplaceEnv(existingContainerEnv, prop)","\t\t\tfor k, v := range prop {","\t\t\t\tnewEnv := corev1.EnvVar{","\t\t\t\t\tName:  k,","\t\t\t\t\tValue: v,","\t\t\t\t}","\t\t\t\texistingContainerEnv = append(existingContainerEnv, newEnv)","\t\t\t}","\t\t\tdep.Spec.Template.Spec.Containers[containerIndex].Env = existingContainerEnv","\t\t\tbreak","\t\t}","","\t\tunstrObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","func applyLokiStackConfig(prop map[string]string, lokiProp v1alpha1.LokiStackProperties) {","\tif lokiProp.LokiStackName == \"\" || lokiProp.LokiStackNamespace == \"\" {","\t\treturn","\t}","\tlokiURL := \"https://\" + lokiProp.LokiStackName + \"-gateway-http\" + \".\" + lokiProp.LokiStackNamespace + \".svc.cluster.local:8080\"","\tif prop == nil {","\t\tprop = map[string]string{}","\t}","","\tprop[logsAPIKey] = \"true\"","\tprop[logsTypeKey] = \"loki\"","\tprop[loggingProxyPath] = \"/api/logs/v1/application\"","\tprop[loggingAPIURL] = lokiURL","\tprop[loggingTokenPath] = \"/var/run/secrets/kubernetes.io/serviceaccount/token\"","\tprop[loggingNamespaceKey] = \"kubernetes_namespace_name\"","\tprop[loggingStaticLabels] = \"log_type=application\"","\tprop[loggingForwarderDelayDuration] = \"10\"","}","","func populateGoogleCreds(props v1alpha1.ResultsAPIProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif props.LogsType != \"GCS\" || props.GCSCredsSecretName == \"\" ||","\t\t\tprops.GCSCredsSecretKey == \"\" || props.LogsAPI == nil ||","\t\t\t!*props.LogsAPI || u.GetKind() != \"Deployment\" ||","\t\t\tu.GetName() != deploymentAPI {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// find the matching container and add env and secret name object","\t\tfor i, container := range d.Spec.Template.Spec.Containers {","\t\t\tif container.Name != apiContainerName {","\t\t\t\tcontinue","\t\t\t}","\t\t\tadd := true","\t\t\tvol := corev1.Volume{","\t\t\t\tName: googleCredsVolName,","\t\t\t\tVolumeSource: corev1.VolumeSource{","\t\t\t\t\tSecret: \u0026corev1.SecretVolumeSource{","\t\t\t\t\t\tSecretName: props.GCSCredsSecretName,","\t\t\t\t\t\tItems: []corev1.KeyToPath{{","\t\t\t\t\t\t\tKey:  props.GCSCredsSecretKey,","\t\t\t\t\t\t\tPath: props.GCSCredsSecretKey,","\t\t\t\t\t\t}},","\t\t\t\t\t},","\t\t\t\t},","\t\t\t}","\t\t\tfor k := 0; k \u003c len(d.Spec.Template.Spec.Volumes); k++ {","\t\t\t\tif d.Spec.Template.Spec.Volumes[k].Name == googleCredsVolName {","\t\t\t\t\td.Spec.Template.Spec.Volumes[k] = vol","\t\t\t\t\tadd = false","\t\t\t\t}","\t\t\t}","\t\t\tif add {","\t\t\t\td.Spec.Template.Spec.Volumes = append(d.Spec.Template.Spec.Volumes, vol)","\t\t\t}","","\t\t\tvolMount := corev1.VolumeMount{","\t\t\t\tName:      googleCredsVolName,","\t\t\t\tMountPath: googleCredsPath,","\t\t\t}","","\t\t\tadd = true","\t\t\tfor k := 0; k \u003c len(d.Spec.Template.Spec.Containers[i].VolumeMounts); k++ {","\t\t\t\tif d.Spec.Template.Spec.Containers[i].VolumeMounts[k].Name == googleCredsVolName {","\t\t\t\t\td.Spec.Template.Spec.Containers[i].VolumeMounts[k] = volMount","\t\t\t\t\tadd = false","\t\t\t\t}","\t\t\t}","\t\t\tif add {","\t\t\t\td.Spec.Template.Spec.Containers[i].VolumeMounts = append(","\t\t\t\t\td.Spec.Template.Spec.Containers[i].VolumeMounts, volMount)","\t\t\t}","","\t\t\tpath := googleCredsPath + \"/\" + props.GCSCredsSecretKey","\t\t\tnewEnv := corev1.EnvVar{","\t\t\t\tName:  googleAPPCredsEnvName,","\t\t\t\tValue: path,","\t\t\t}","\t\t\tadd = true","\t\t\tfor k, env := range d.Spec.Template.Spec.Containers[i].Env {","\t\t\t\tif env.Name == googleAPPCredsEnvName {","\t\t\t\t\td.Spec.Template.Spec.Containers[i].Env[k] = newEnv","\t\t\t\t\tadd = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\tif add {","\t\t\t\td.Spec.Template.Spec.Containers[i].Env = append(","\t\t\t\t\td.Spec.Template.Spec.Containers[i].Env, newEnv)","\t\t\t}","","\t\t\tbreak","\t\t}","","\t\tuObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","}","","// updates env keys with the secret name into \"tekton-results-api\" deployment in \"api\" container","func updateEnvWithSecretName(props v1alpha1.ResultsAPIProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif props.SecretName == \"\" || u.GetKind() != \"Deployment\" || u.GetName() != deploymentAPI {","\t\t\treturn nil","\t\t}","","\t\tdep := \u0026appsv1.Deployment{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// find the matching container and add env and secret name object","\t\tfor containerIndex, container := range dep.Spec.Template.Spec.Containers {","\t\t\tif container.Name != apiContainerName {","\t\t\t\tcontinue","\t\t\t}","","\t\t\t// get existing env from the container","\t\t\texistingEnv := container.Env","\t\t\tif existingEnv == nil {","\t\t\t\texistingEnv = make([]corev1.EnvVar, 0)","\t\t\t}","","\t\t\t// update only allowed properties","\t\t\tfor _, propertyKey := range allowedPropertySecretKeys {","\t\t\t\tnewEnv := corev1.EnvVar{","\t\t\t\t\tName: propertyKey,","\t\t\t\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\t\t\t\tSecretKeyRef: \u0026corev1.SecretKeySelector{","\t\t\t\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\t\t\t\tName: props.SecretName,","\t\t\t\t\t\t\t},","\t\t\t\t\t\t\tKey:      propertyKey,","\t\t\t\t\t\t\tOptional: ptr.Bool(true),","\t\t\t\t\t\t},","\t\t\t\t\t},","\t\t\t\t}","\t\t\t\t// if existing entry found, replace that","\t\t\t\tappendNewEnv := true","\t\t\t\tfor existingIndex, _env := range existingEnv {","\t\t\t\t\tif _env.Name == propertyKey {","\t\t\t\t\t\texistingEnv[existingIndex] = newEnv","\t\t\t\t\t\tappendNewEnv = false","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif appendNewEnv {","\t\t\t\t\texistingEnv = append(existingEnv, newEnv)","\t\t\t\t}","\t\t\t}","","\t\t\t// update the changes into the actual container","\t\t\tdep.Spec.Template.Spec.Containers[containerIndex].Env = existingEnv","\t\t\tbreak","\t\t}","","\t\tuObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","","}","","func replaceEnv(envs []corev1.EnvVar, prop map[string]string) {","\tfor i, env := range envs {","\t\t_, ok := prop[env.Name]","\t\tif ok {","\t\t\tenvs[i].Name = prop[env.Name]","\t\t\tdelete(prop, env.Name)","\t\t}","\t}","}","","// update api and retention-policy-agent env secret reference with db secret key and name","func updateEnvWithDBSecretName(props v1alpha1.ResultsAPIProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif props.DBSecretName == \"\" || u.GetKind() != \"Deployment\" || u.GetName() == resultWatcherDeployment {","\t\t\treturn nil","\t\t}","","\t\tdep := \u0026appsv1.Deployment{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// find the matching container and add env and secret name object","\t\tfor containerIndex, container := range dep.Spec.Template.Spec.Containers {","","\t\t\t// get existing env from the container","\t\t\texistingEnv := container.Env","\t\t\tif existingEnv == nil {","\t\t\t\texistingEnv = make([]corev1.EnvVar, 0)","\t\t\t}","","\t\t\t// update the value of container keys with provided db secret key","\t\t\tif props.DBSecretUserKey != \"\" {","\t\t\t\tContainerEnvKeys[DB_USER] = props.DBSecretUserKey","\t\t\t}","\t\t\tif props.DBSecretPasswordKey != \"\" {","\t\t\t\tContainerEnvKeys[DB_PASSWORD] = props.DBSecretPasswordKey","\t\t\t}","\t\t\tfor envKey, secretKey := range ContainerEnvKeys {","\t\t\t\tvar newEnv corev1.EnvVar","\t\t\t\tif envKey == DB_USER {","\t\t\t\t\tnewEnv = corev1.EnvVar{","\t\t\t\t\t\tName: envKey,","\t\t\t\t\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\t\t\t\t\tSecretKeyRef: \u0026corev1.SecretKeySelector{","\t\t\t\t\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\t\t\t\t\tName: props.DBSecretName,","\t\t\t\t\t\t\t\t},","\t\t\t\t\t\t\t\tKey: secretKey,","\t\t\t\t\t\t\t},","\t\t\t\t\t\t},","\t\t\t\t\t}","\t\t\t\t} else {","\t\t\t\t\tnewEnv = corev1.EnvVar{","\t\t\t\t\t\tName: envKey,","\t\t\t\t\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\t\t\t\t\tSecretKeyRef: \u0026corev1.SecretKeySelector{","\t\t\t\t\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\t\t\t\t\tName: props.DBSecretName,","\t\t\t\t\t\t\t\t},","\t\t\t\t\t\t\t\tKey: secretKey,","\t\t\t\t\t\t\t},","\t\t\t\t\t\t},","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t// if existing entry found, replace that","\t\t\t\tappendNewEnv := true","\t\t\t\tfor existingIndex, _env := range existingEnv {","\t\t\t\t\tif _env.Name == envKey {","\t\t\t\t\t\texistingEnv[existingIndex] = newEnv","\t\t\t\t\t\tappendNewEnv = false","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif appendNewEnv {","\t\t\t\t\texistingEnv = append(existingEnv, newEnv)","\t\t\t\t}","\t\t\t}","\t\t\t// update the changes into the actual container","\t\t\tdep.Spec.Template.Spec.Containers[containerIndex].Env = existingEnv","\t\t\tbreak","\t\t}","","\t\tuObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(dep)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,1,1,1,1,1,1,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,2,2,2,0,2,2,1,1,2,2,2,0,0,0,2,2,2,2,2,2,2,1,1,0,2,1,1,0,2,2,2,1,1,2,1,1,0,2,2,2,2,2,2,2,2,2,0,2,2,2,1,0,2,2,2,2,2,0,0,2,1,1,0,0,2,1,1,0,0,2,2,2,2,2,0,2,2,2,2,0,2,2,2,0,2,2,2,0,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,1,1,2,2,0,0,0,0,0,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,2,2,2,1,0,2,2,2,2,2,0,0,2,1,1,0,0,2,1,1,0,0,2,2,2,2,2,0,2,2,2,2,0,2,2,2,0,1,1,1,0,0,0,2,2,2,0,0,0,2,2,2,0,0,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,1,2,2,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,2,0,0,2,2,1,1,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,1,0,0,0,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,0,2,2,0,0,2,2,1,1,2,2,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,2,1,1,0,0,2,2,0,0,2,2,1,1,2,2,0,0]},{"id":129,"path":"pkg/reconciler/kubernetes/tektonscheduler/controller.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import (","\t\"context\"","","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonschedulerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonscheduler\"","\ttektonschedulerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonscheduler\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = v1alpha1.TektonSchedulerResourceName + \"-info\"","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","\t\tmanifest, schedulerVer := ctrl.InitController(ctx, common.PayloadOptions{})","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(\"Error while getting operator version\", err)","\t\t}","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","\t\tmetrics, _ := NewRecorder()","\t\tc := \u0026Reconciler{","\t\t\toperatorClientSet:      operatorclient.Get(ctx),","\t\t\tkubeClientSet:          kubeclient.Get(ctx),","\t\t\tpipelineInformer:       tektonPipelineinformer.Get(ctx),","\t\t\tinstallerSetClient:     client.NewInstallerSetClient(tisClient, operatorVer, schedulerVer, v1alpha1.KindTektonScheduler, metrics),","\t\t\textension:              generator(ctx),","\t\t\tmanifest:               manifest,","\t\t\ttektonSchedulerVersion: schedulerVer,","\t\t\toperatorVersion:        operatorVer,","\t\t}","\t\timpl := tektonschedulerreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for TektonScheduler\")","","\t\tif _, err := tektonschedulerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonScheduler informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonScheduler{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":130,"path":"pkg/reconciler/kubernetes/tektonscheduler/finalize.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonscheduler\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","var _ tektonscheduler.Finalizer = (*Reconciler)(nil)","","// FinalizeKind removes all resources after deletion of a TektonScheduler CR.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonScheduler) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\t//Delete CRDs before deleting rest of resources so that any instance","\t//of CRDs which has finalizer set will get deleted before we remove","\t//the controller;s deployment for it","\tif err := r.manifest.Filter(mf.CRDs).Delete(); err != nil {","\t\tlogger.Error(\"Failed to deleted CRDs for TektonScheduler\")","\t\treturn err","\t}","","\tif err := r.installerSetClient.CleanupMainSet(ctx); err != nil {","\t\tlogger.Error(\"failed to cleanup main installerset: \", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0]},{"id":131,"path":"pkg/reconciler/kubernetes/tektonscheduler/installerset.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/logging\"",")","","func (r *Reconciler) ensureInstallerSets(ctx context.Context, tektonScheduler *v1alpha1.TektonScheduler) error {","\tlogger := logging.FromContext(ctx)","","\t// Create Config Installset Before Main Set","\tif err := r.ensureConfigInstallerSet(ctx, tektonScheduler); err != nil {","\t\tmsg := fmt.Sprintf(\"Config InstallerSet Reconcilation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif errors.Is(err, v1alpha1.REQUEUE_EVENT_AFTER) {","\t\t\treturn err","\t\t}","\t\ttektonScheduler.Status.MarkInstallerSetNotReady(msg)","\t\treturn err","\t}","","\t// Main Installerset Should not contain the configMap as it is already created by config installerset","\tfilteredManifest := r.manifest.Filter(mf.Not(mf.All(mf.ByKind(\"ConfigMap\"), mf.ByName(v1alpha1.SchedulerConfigMapName))))","\tif err := r.installerSetClient.MainSet(ctx, tektonScheduler, \u0026filteredManifest, filterAndTransform(r.extension)); err != nil {","\t\tmsg := fmt.Sprintf(\"Main Reconcilation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif errors.Is(err, v1alpha1.REQUEUE_EVENT_AFTER) {","\t\t\treturn err","\t\t}","\t\ttektonScheduler.Status.MarkInstallerSetNotReady(msg)","\t}","\treturn nil","}","","func (r *Reconciler) ensureConfigInstallerSet(ctx context.Context, tektonScheduler *v1alpha1.TektonScheduler) error {","\tlogger := logging.FromContext(ctx)","\tlabelSelector := metav1.LabelSelector{","\t\tMatchLabels: getLabels(),","\t}","\tconfigLabelSector, err := common.LabelSelector(labelSelector)","\tif err != nil {","\t\tlogger.Errorw(\"Invalid Scheduler config label selector\", \"error\", err)","\t\treturn err","\t}","\texistingConfigInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, configLabelSector)","\tif err != nil {","\t\tlogger.Errorw(\"Failed to get config installer set name\", \"error\", err, \"selector\", configLabelSector)","\t\treturn err","\t}","\tif existingConfigInstallerSet == \"\" {","\t\ttektonScheduler.Status.MarkInstallerSetNotAvailable(v1alpha1.SchedulerConfigInstallerSet + \" InstallerSet not available\")","\t\tlogger.Infow(\"Creating new InstallerSet\", v1alpha1.SchedulerConfigInstallerSet, \"targetNamespace\", tektonScheduler.Spec.TargetNamespace)","","\t\t_, err := r.createConfigInstallerSet(ctx, tektonScheduler)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to create Config InstallerSet\", \"error\", err)","\t\t\treturn err","\t\t}","","\t} else {","\t\t// If exists, then fetch the Tekton Scheduler Config InstallerSet","\t\tinstalledConfigTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\tGet(ctx, existingConfigInstallerSet, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to get Config InstallerSet\", err)","\t\t\treturn err","","\t\t}","","\t\tconfigInstallerSetTargetNamespace := installedConfigTIS.Annotations[v1alpha1.TargetNamespaceKey]","\t\tconfigInstallerSetReleaseVersion := installedConfigTIS.Labels[v1alpha1.ReleaseVersionKey]","","\t\tif configInstallerSetTargetNamespace != tektonScheduler.Spec.TargetNamespace || configInstallerSetReleaseVersion != r.operatorVersion {","\t\t\tlogger.Infow(\"Config InstallerSet needs update\",","\t\t\t\t\"name\", existingConfigInstallerSet,","\t\t\t\t\"currentNamespace\", configInstallerSetTargetNamespace,","\t\t\t\t\"expectedNamespace\", tektonScheduler.Spec.TargetNamespace,","\t\t\t\t\"currentVersion\", configInstallerSetReleaseVersion,","\t\t\t\t\"expectedVersion\", r.operatorVersion)","","\t\t\t// Delete the existing Tekton Scheduler InstallerSet","\t\t\terr := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tDelete(ctx, existingConfigInstallerSet, metav1.DeleteOptions{})","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to delete Config InstallerSet\", \"name\", existingConfigInstallerSet, \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// Make sure the Tekton Scheduler Config InstallerSet is deleted","\t\t\t_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\tGet(ctx, existingConfigInstallerSet, metav1.GetOptions{})","\t\t\tif err == nil {","\t\t\t\ttektonScheduler.Status.MarkNotReady(\"Waiting for previous installer set to get deleted\")","\t\t\t\tlogger.Debugw(\"Config InstallerSet deletion pending\", \"name\", existingConfigInstallerSet)","\t\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t\t}","\t\t\tif !apierrors.IsNotFound(err) {","\t\t\t\tlogger.Errorw(\"Failed to confirm Config InstallerSet deletion\", \"name\", existingConfigInstallerSet, \"error\", err)","\t\t\t\treturn err","\t\t\t}","\t\t\treturn nil","","\t\t} else {","\t\t\t// If target namespace and version are not changed then check if Scheduler","\t\t\t// spec is changed by checking hash stored as annotation on","\t\t\t// Tekton Scheduler InstallerSet with computing new hash of TektonScheduler Spec","","\t\t\t// Hash of TektonScheduler Spec","\t\t\texpectedSpecHash, err := hash.Compute(tektonScheduler.Spec)","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to compute spec hash\", \"error\", err)","\t\t\t\treturn err","\t\t\t}","","\t\t\t// spec hash stored on installerSet","\t\t\tlastAppliedHash := installedConfigTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]","\t\t\tif lastAppliedHash != expectedSpecHash {","\t\t\t\tlogger.Infow(\"Config spec changed, updating InstallerSet\",","\t\t\t\t\t\"name\", installedConfigTIS.Name,","\t\t\t\t\t\"oldHash\", lastAppliedHash,","\t\t\t\t\t\"newHash\", expectedSpecHash)","\t\t\t\tif err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\t\t\t\tDelete(ctx, installedConfigTIS.Name, metav1.DeleteOptions{}); err != nil {","\t\t\t\t\tlogger.Errorw(\"Failed to delete outdated Config InstallerSet\", \"name\", installedConfigTIS.Name, \"error\", err)","\t\t\t\t\treturn err","\t\t\t\t}","","\t\t\t\t// after updating installer set enqueue after a duration","\t\t\t\t// to allow changes to get deployed","\t\t\t\tlogger.Infow(\"Config InstallerSet deleted to apply spec changes\", \"name\", installedConfigTIS.Name)","\t\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t\t}","\t\t\tlogger.Debugw(\"Config InstallerSet up to date\", \"name\", installedConfigTIS.Name)","\t\t}","\t}","\treturn nil","}","","func (r *Reconciler) createConfigInstallerSet(ctx context.Context, tektonScheduler *v1alpha1.TektonScheduler) (*v1alpha1.TektonInstallerSet, error) {","\tlogger := logging.FromContext(ctx)","\tmanifest := r.manifest","\tmanifest = manifest.Filter(mf.ByKind(\"ConfigMap\"), mf.ByName(v1alpha1.SchedulerConfigMapName))","","\tlogger.Infow(\"Creating a new SchedulerConfigInstallerSet\", \"manifest\", manifest.Resources())","","\ttransformer := filterAndTransform(r.extension)","\tif _, err := transformer(ctx, \u0026manifest, tektonScheduler); err != nil {","\t\ttektonScheduler.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\treturn nil, err","\t}","","\t// generate installer set","\ttis := r.makeInstallerSet(tektonScheduler, manifest, v1alpha1.SchedulerConfigInstallerSet)","","\t// compute the hash of  spec and store as an annotation","\t// in further reconciliation we compute hash of tektonScheduler spec and check with","\t// annotation, if they are same then we skip updating the object","\t// otherwise we update the manifest","\tspecHash, err := hash.Compute(tektonScheduler.Spec)","\tif err != nil {","\t\treturn nil, err","\t}","\ttis.Annotations[v1alpha1.LastAppliedHashKey] = specHash","","\t// create installer set","\tcreatedIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, tis, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn createdIs, nil","}","","func (r *Reconciler) makeInstallerSet(tc *v1alpha1.TektonScheduler, manifest mf.Manifest, installerSetType string) *v1alpha1.TektonInstallerSet {","\townerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())","\tlabels := getLabels()","","\tlabels[v1alpha1.ReleaseVersionKey] = r.operatorVersion","","\treturn \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: fmt.Sprintf(\"%s-\", installerSetType),","\t\t\tLabels:       labels,","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","}","","func getLabels() map[string]string {","\tlabels := map[string]string{","\t\tv1alpha1.CreatedByKey:     v1alpha1.SchedulerCreatedByValue,","\t\tv1alpha1.InstallerSetType: v1alpha1.SchedulerConfigInstallerSet,","\t}","\treturn labels","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1]},{"id":132,"path":"pkg/reconciler/kubernetes/tektonscheduler/metrics.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import \"go.uber.org/zap\"","","type Recorder struct {","}","","func NewRecorder() (*Recorder, error) {","\treturn \u0026Recorder{}, nil","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\t// TODO","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0]},{"id":133,"path":"pkg/reconciler/kubernetes/tektonscheduler/reconcile.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tpipelineinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\tTektonSchedulerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonscheduler\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// Reconciler implements controller.Reconciler for TektonScheduler resources.","type Reconciler struct {","\t// operator client to interact with operator resources","\toperatorClientSet operatorclient.Interface","\t// kube client to interact with core k8s resources","\tkubeClientSet kubernetes.Interface","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// pipelineInformer to query for TektonPipeline","\tpipelineInformer pipelineinformer.TektonPipelineInformer","\t// manifest has the source manifest of Tekton schedulers for a","\t// particular version","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","\t// version of scheduler which we are installing","\ttektonSchedulerVersion string","\toperatorVersion        string","}","","// Check that our Reconciler implements controller.Reconciler","var _ TektonSchedulerreconciler.Interface = (*Reconciler)(nil)","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, TektonScheduler *v1alpha1.TektonScheduler) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"name\", TektonScheduler.GetName())","\tTektonScheduler.Status.InitializeConditions()","\tTektonScheduler.Status.SetVersion(r.tektonSchedulerVersion)","","\tif TektonScheduler.GetName() != v1alpha1.TektonSchedulerResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.TektonSchedulerResourceName,","\t\t\tTektonScheduler.GetName(),","\t\t)","\t\tlogger.Error(msg)","\t\tTektonScheduler.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// reconcile target namespace","\tif err := common.ReconcileTargetNamespace(ctx, nil, nil, TektonScheduler, r.kubeClientSet); err != nil {","\t\treturn err","\t}","\t// Make sure TektonPipeline is installed before proceeding with","\terr := r.ensureDependenciesInstalled(TektonScheduler)","\tif err != nil {","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\tTektonScheduler.Status.MarkDependenciesInstalled()","","\tif err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {","\t\tlogger.Error(\"failed to remove obsolete installer sets: %v\", err)","\t\treturn err","\t}","","\tif err := r.extension.PreReconcile(ctx, TektonScheduler); err != nil {","\t\tmsg := fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\treturn err","\t\t}","\t\tTektonScheduler.Status.MarkPreReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PreReconcile Complete","\tTektonScheduler.Status.MarkPreReconcilerComplete()","","\t//  Create/Update Required TektonInstallerSets","\tif err := r.ensureInstallerSets(ctx, TektonScheduler); err != nil {","\t\treturn err","\t}","","\tif err := r.extension.PostReconcile(ctx, TektonScheduler); err != nil {","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\treturn err","\t\t}","\t\tTektonScheduler.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PostReconcile Complete","\tTektonScheduler.Status.MarkPostReconcilerComplete()","\treturn nil","}","","func (r *Reconciler) ensureDependenciesInstalled(TektonScheduler *v1alpha1.TektonScheduler) error {","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || errors.Is(err, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR) {","\t\t\tTektonScheduler.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\t// (tektonpipeline.operator.tekton.dev instance not available yet)","\t\tTektonScheduler.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","","\tdiscoveryClient := r.kubeClientSet.Discovery()","\t_, err := discoveryClient.ServerResourcesForGroupVersion(\"kueue.x-k8s.io/v1beta1\")","\tif err != nil {","\t\tTektonScheduler.Status.MarkDependencyMissing(\"API kueue.x-k8s.io/v1beta1 does not exist. Please install kueue.x-k8s.io/v1beta1\")","\t\treturn err","\t}","","\treturn nil","","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,0,0]},{"id":134,"path":"pkg/reconciler/kubernetes/tektonscheduler/transformer.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import (","\t\"context\"","\t\"strings\"","","\tcertv1 \"github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1\"","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","const (","\tcertManagerAnnotation = \"cert-manager.io/inject-ca-from\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tschedulerCR := comp.(*v1alpha1.TektonScheduler)","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.SchedulerImagePrefix))","\t\tschedulerImages := common.ImageRegistryDomainOverride(imagesRaw)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.TektonSchedulerResourceName),","\t\t\tcommon.DeploymentImages(schedulerImages),","\t\t\tcommon.AddDeploymentRestrictedPSA(),","\t\t\tcommon.AddConfigMapValues(v1alpha1.SchedulerConfigMapName, schedulerCR.Spec.SchedulerConfig),","\t\t\tCertificateTransformer(schedulerCR.GetSpec().GetTargetNamespace()),","\t\t\tMutatingWebhookConfigurationTransformer(ctx, schedulerCR.GetSpec().GetTargetNamespace()),","\t\t}","\t\textra = append(extra, extension.Transformers(schedulerCR)...)","\t\terr := common.Transform(ctx, manifest, schedulerCR, extra...)","\t\tif err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, schedulerCR.Spec.GetTargetNamespace(), schedulerCR.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// Now Remove the TargetNamespace from manifest as same is not owned by Scheduler.","\t\tfilteredManifest := manifest.Filter(mf.Not(mf.ByKind(\"Namespace\")), mf.Not(mf.ByName(schedulerCR.GetSpec().GetTargetNamespace())))","","\t\treturn \u0026filteredManifest, nil","\t}","}","","func CertificateTransformer(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Certificate\" {","\t\t\treturn nil","\t\t}","","\t\tcm := \u0026certv1.Certificate{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// Update DNS entries","\t\tdnsNames := cm.Spec.DNSNames","\t\tfor i, v := range dnsNames {","\t\t\tdnsTokens := strings.Split(v, \".\")","\t\t\tif len(dnsTokens) \u003c 2 {","\t\t\t\tcontinue","\t\t\t}","\t\t\tdnsTokens[1] = targetNamespace // ReplaceNameSpace","\t\t\tdnsNames[i] = strings.Join(dnsTokens, \".\")","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","func MutatingWebhookConfigurationTransformer(ctx context.Context, targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() == \"MutatingWebhookConfiguration\" {","\t\t\tannotations := u.GetAnnotations()","\t\t\tann := annotations[certManagerAnnotation]","\t\t\tif ann != \"\" {","\t\t\t\ttokens := strings.Split(ann, \"/\")","\t\t\t\tif len(tokens) \u003e= 2 {","\t\t\t\t\ttokens[0] = targetNamespace","\t\t\t\t\tannotations[certManagerAnnotation] = strings.Join(tokens, \"/\")","","\t\t\t\t}","\t\t\t}","\t\t\tu.SetAnnotations(annotations)","\t\t}","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0]},{"id":135,"path":"pkg/reconciler/kubernetes/tektontrigger/controller.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\t\"context\"","","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonTriggerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektontrigger\"","\ttektonTriggerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektontrigger\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = \"triggers-info\"","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","","\t\tmanifest, triggersVer := ctrl.InitController(ctx, common.PayloadOptions{})","","\t\tmetrics, err := NewRecorder()","\t\tif err != nil {","\t\t\tlogger.Errorf(\"Failed to create trigger metrics recorder %v\", err)","\t\t}","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","","\t\tc := \u0026Reconciler{","\t\t\tkubeClientSet:      kubeclient.Get(ctx),","\t\t\tpipelineInformer:   tektonPipelineinformer.Get(ctx),","\t\t\tinstallerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, triggersVer, v1alpha1.KindTektonTrigger, metrics),","\t\t\textension:          generator(ctx),","\t\t\tmanifest:           manifest,","\t\t\ttriggersVersion:    triggersVer,","\t\t}","\t\timpl := tektonTriggerreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for TektonTrigger\")","","\t\tif _, err := tektonTriggerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonTrigger informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonTrigger{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":136,"path":"pkg/reconciler/kubernetes/tektontrigger/finalize.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\ttektontriggerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektontrigger\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","var _ tektontriggerreconciler.Finalizer = (*Reconciler)(nil)","","// FinalizeKind removes all resources after deletion of a TektonTrigger CR.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonTrigger) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\t//Delete CRDs before deleting rest of resources so that any instance","\t//of CRDs which has finalizer set will get deleted before we remove","\t//the controller;s deployment for it","\tif err := r.manifest.Filter(mf.CRDs).Delete(); err != nil {","\t\tlogger.Error(\"Failed to deleted CRDs for TektonTrigger\")","\t\treturn err","\t}","","\tif err := r.installerSetClient.CleanupMainSet(ctx); err != nil {","\t\tlogger.Error(\"failed to cleanup main installerset: \", err)","\t\treturn err","\t}","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0]},{"id":137,"path":"pkg/reconciler/kubernetes/tektontrigger/metrics.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\t\"context\"","\t\"fmt\"","\t\"time\"","","\t\"go.opencensus.io/stats\"","\t\"go.opencensus.io/stats/view\"","\t\"go.opencensus.io/tag\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/metrics\"",")","","var (","\ttReconcileCount = stats.Float64(\"trigger_reconcile_count\",","\t\t\"number of trigger install\",","\t\tstats.UnitDimensionless)",")","","// Recorder holds keys for Tekton metrics","type Recorder struct {","\tinitialized bool","\tstatus      tag.Key","\tversion     tag.Key","","\tReportingPeriod time.Duration","}","","// NewRecorder creates a new metrics recorder instance","// to log the PipelineRun related metrics","func NewRecorder() (*Recorder, error) {","\tr := \u0026Recorder{","\t\tinitialized: true,","","\t\t// Default to 30s intervals.","\t\tReportingPeriod: 30 * time.Second,","\t}","","\tstatus, err := tag.NewKey(\"status\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.status = status","","\tversion, err := tag.NewKey(\"version\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.version = version","","\terr = view.Register(","\t\t\u0026view.View{","\t\t\tDescription: tReconcileCount.Description(),","\t\t\tMeasure:     tReconcileCount,","\t\t\tAggregation: view.Count(),","\t\t\tTagKeys:     []tag.Key{r.status, r.version},","\t\t},","\t)","","\tif err != nil {","\t\tr.initialized = false","\t\treturn r, err","\t}","","\treturn r, nil","}","","// Count logs number of times a component (pipeline/trigger atm)","// has been installed or failed to install.","func (r *Recorder) Count(status, version string) error {","\tif !r.initialized {","\t\treturn fmt.Errorf(","\t\t\t\"ignoring the metrics recording for trigger , failed to initialize the metrics recorder\")","\t}","","\tctx, err := tag.New(","\t\tcontext.Background(),","\t\ttag.Insert(r.status, status),","\t\ttag.Insert(r.version, version),","\t)","","\tif err != nil {","\t\treturn err","\t}","","\tmetrics.Record(ctx, tReconcileCount.M(1))","\treturn nil","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\terr := m.Count(status, version)","\tif err != nil {","\t\tlogger.Warnf(\"%v: Failed to log the metrics : %v\", resourceKind, err)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0]},{"id":138,"path":"pkg/reconciler/kubernetes/tektontrigger/reconcile.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tpipelineinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\ttektontriggerreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektontrigger\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const resourceKind = v1alpha1.KindTektonTrigger","","// Reconciler implements controller.Reconciler for TektonTrigger resources.","type Reconciler struct {","\t// kube client to interact with core k8s resources","\tkubeClientSet kubernetes.Interface","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// pipelineInformer to query for TektonPipeline","\tpipelineInformer pipelineinformer.TektonPipelineInformer","\t// manifest has the source manifest of Tekton Triggers for a","\t// particular version","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","\t// version of triggers which we are installing","\ttriggersVersion string","}","","// Check that our Reconciler implements controller.Reconciler","var _ tektontriggerreconciler.Interface = (*Reconciler)(nil)","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, tt *v1alpha1.TektonTrigger) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"tektonTrigger\", tt.GetName())","\ttt.Status.InitializeConditions()","\ttt.Status.SetVersion(r.triggersVersion)","","\tlogger.Infow(\"Starting TektonTrigger reconciliation\",","\t\t\"version\", r.triggersVersion,","\t\t\"status\", tt.Status.GetCondition(apis.ConditionReady))","","\tif tt.GetName() != v1alpha1.TriggerResourceName {","\t\tlogger.Errorw(\"Invalid resource name\",","\t\t\t\"expectedName\", v1alpha1.TriggerResourceName,","\t\t\t\"actualName\", tt.GetName())","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.TriggerResourceName,","\t\t\ttt.GetName())","\t\ttt.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\tif err := r.targetNamespaceCheck(ctx, tt); err != nil {","\t\tlogger.Errorw(\"Target namespace check failed\", \"error\", err)","\t\treturn err","\t}","","\t//Make sure TektonPipeline is installed before proceeding with","\t//TektonTrigger","\tlogger.Debug(\"Checking TektonPipeline dependency\")","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\tlogger.Infow(\"Waiting for TektonPipeline installation to complete\")","\t\t\ttt.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\t// (tektonpipeline.operator.tekton.dev instance not available yet)","\t\tlogger.Errorw(\"TektonPipeline dependency not found\", \"error\", err)","\t\ttt.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","\ttt.Status.MarkDependenciesInstalled()","\tlogger.Info(\"All dependencies installed successfully\")","","\t// Pass the object through defaulting","\tlogger.Debug(\"Applying defaults to TektonTrigger\")","\ttt.SetDefaults(ctx)","","\tif err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {","\t\tlogger.Errorw(\"Failed to remove obsolete installer sets\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"Successfully removed obsolete installer sets\")","","\tlogger.Debug(\"Running pre-reconciliation steps\")","\tif err := r.extension.PreReconcile(ctx, tt); err != nil {","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Infow(\"PreReconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmsg := fmt.Sprintf(\"PreReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"PreReconciliation failed\", \"error\", err)","\t\ttt.Status.MarkPreReconcilerFailed(msg)","\t\treturn nil","\t}","","\t//Mark PreReconcile Complete","\ttt.Status.MarkPreReconcilerComplete()","\tlogger.Info(\"PreReconciliation completed successfully\")","","\t// Ensure webhook deadlock prevention before applying the manifest","\tlogger.Debugw(\"Preventing webhook deadlock\")","\tif err := common.PreemptDeadlock(ctx, \u0026r.manifest, r.kubeClientSet, v1alpha1.TriggerResourceName); err != nil {","\t\tlogger.Error(\"Webhook deadlock prevention failed\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debugw(\"Webhook deadlock prevention successful\")","","\tlogger.Debugw(\"Running main reconciliation with installer set\")","\tif err := r.installerSetClient.MainSet(ctx, tt, \u0026r.manifest, filterAndTransform(r.extension)); err != nil {","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Info(\"Main reconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmsg := fmt.Sprintf(\"Main Reconcilation failed: %s\", err.Error())","\t\tlogger.Errorw(\"Main reconciliation failed\", \"error\", err)","\t\ttt.Status.MarkInstallerSetNotReady(msg)","\t\treturn nil","\t}","\tlogger.Info(\"Main reconciliation completed successfully\")","","\tlogger.Debug(\"Running post-reconciliation steps\")","\tif err := r.extension.PostReconcile(ctx, tt); err != nil {","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\tlogger.Infow(\"PostReconciliation requested requeue\")","\t\t\treturn err","\t\t}","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Errorw(\"PostReconciliation failed\", \"error\", err)","\t\ttt.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PostReconcile Complete","\ttt.Status.MarkPostReconcilerComplete()","\tlogger.Infow(\"TektonTrigger reconciliation completed successfully\",","\t\t\"ready\", tt.Status.GetCondition(apis.ConditionReady).IsTrue(),","\t\t\"version\", r.triggersVersion)","","\treturn nil","}","","func (r *Reconciler) targetNamespaceCheck(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tns, err := r.kubeClientSet.CoreV1().Namespaces().Get(ctx, comp.GetSpec().GetTargetNamespace(), metav1.GetOptions{})","\tif err != nil {","\t\t// if namespace is not there then return wait for it","\t\tif apierrors.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the namespace is in deletion state then delete the installerset","\t// and create later otherwise it will keep doing api calls to create resources","\t// and keep failing","\tif ns.DeletionTimestamp != nil {","\t\tif err := r.installerSetClient.CleanupMainSet(ctx); err != nil {","\t\t\treturn err","\t\t}","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","\treturn err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,0,1,0]},{"id":139,"path":"pkg/reconciler/kubernetes/tektontrigger/transform.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","// Triggers ConfigMap","const (","\tConfigDefaults = \"config-defaults-triggers\"","\tFeatureFlag    = \"feature-flags-triggers\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\ttrigger := comp.(*v1alpha1.TektonTrigger)","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.TriggersImagePrefix))","\t\ttriggerImages := common.ImageRegistryDomainOverride(imagesRaw)","","\t\t// adding extension's transformers first to run them before `extra` transformers","\t\ttrns := extension.Transformers(trigger)","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdTriggers),","\t\t\tcommon.AddConfigMapValues(ConfigDefaults, trigger.Spec.OptionalTriggersProperties),","\t\t\tcommon.AddConfigMapValues(FeatureFlag, trigger.Spec.TriggersProperties),","\t\t\tcommon.DeploymentImages(triggerImages),","\t\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\t\tcommon.AddConfiguration(trigger.Spec.Config),","\t\t}","\t\ttrns = append(trns, extra...)","\t\tif err := common.Transform(ctx, manifest, trigger, trns...); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, trigger.Spec.GetTargetNamespace(), trigger.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0]},{"id":140,"path":"pkg/reconciler/openshift/annotation/annotation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package annotation","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/markbates/inflect\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"go.uber.org/zap\"","\t\"gomodules.xyz/jsonpatch/v2\"","\tadmissionv1 \"k8s.io/api/admission/v1\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","\tadmissionlisters \"k8s.io/client-go/listers/admissionregistration/v1\"","\tcorelisters \"k8s.io/client-go/listers/core/v1\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/apis/duck\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/kmp\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"","\tcertresources \"knative.dev/pkg/webhook/certificates/resources\"",")","","// reconciler implements the AdmissionController for resources","type reconciler struct {","\twebhook.StatelessAdmissionImpl","\tpkgreconciler.LeaderAwareFuncs","","\tkey  types.NamespacedName","\tpath string","","\twithContext func(context.Context) context.Context","","\tclient       kubernetes.Interface","\tmwhlister    admissionlisters.MutatingWebhookConfigurationLister","\tsecretlister corelisters.SecretLister","","\tdisallowUnknownFields bool","\tsecretName            string","}","","var _ controller.Reconciler = (*reconciler)(nil)","var _ pkgreconciler.LeaderAware = (*reconciler)(nil)","var _ webhook.AdmissionController = (*reconciler)(nil)","var _ webhook.StatelessAdmissionController = (*reconciler)(nil)","","// Reconcile implements controller.Reconciler","func (ac *reconciler) Reconcile(ctx context.Context, key string) error {","\tlogger := logging.FromContext(ctx)","","\tif !ac.IsLeaderFor(ac.key) {","\t\tlogger.Debugf(\"Skipping key %q, not the leader.\", ac.key)","\t\treturn nil","\t}","","\t// Look up the webhook secret, and fetch the CA cert bundle.","\tsecret, err := ac.secretlister.Secrets(system.Namespace()).Get(ac.secretName)","\tif err != nil {","\t\tlogger.Errorw(\"Error fetching secret\", zap.Error(err))","\t\treturn err","\t}","\tcaCert, ok := secret.Data[certresources.CACert]","\tif !ok {","\t\treturn fmt.Errorf(\"secret %q is missing %q key\", ac.secretName, certresources.CACert)","\t}","","\t// Reconcile the webhook configuration.","\treturn ac.reconcileMutatingWebhook(ctx, caCert)","}","","// Path implements AdmissionController","func (ac *reconciler) Path() string {","\treturn ac.path","}","","// Admit implements AdmissionController","func (ac *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {","\tif ac.withContext != nil {","\t\tctx = ac.withContext(ctx)","\t}","","\tlogger := logging.FromContext(ctx)","\tswitch request.Operation {","\tcase admissionv1.Create:","\tdefault:","\t\tlogger.Info(\"Unhandled webhook operation, letting it through \", request.Operation)","\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t}","","\tpatchBytes, err := ac.mutate(ctx, request)","\tif err != nil {","\t\treturn webhook.MakeErrorStatus(\"mutation failed: %v\", err)","\t}","\tlogger.Infof(\"Kind: %q PatchBytes: %v\", request.Kind, string(patchBytes))","","\treturn \u0026admissionv1.AdmissionResponse{","\t\tPatch:   patchBytes,","\t\tAllowed: true,","\t\tPatchType: func() *admissionv1.PatchType {","\t\t\tpt := admissionv1.PatchTypeJSONPatch","\t\t\treturn \u0026pt","\t\t}(),","\t}","}","","func (ac *reconciler) reconcileMutatingWebhook(ctx context.Context, caCert []byte) error {","\tlogger := logging.FromContext(ctx)","","\tpluralEL := strings.ToLower(inflect.Pluralize(\"EventListener\"))","\trules := []admissionregistrationv1.RuleWithOperations{","\t\t{","\t\t\tOperations: []admissionregistrationv1.OperationType{","\t\t\t\tadmissionregistrationv1.Create,","\t\t\t},","\t\t\tRule: admissionregistrationv1.Rule{","\t\t\t\tAPIGroups:   []string{\"triggers.tekton.dev\"},","\t\t\t\tAPIVersions: []string{\"v1alpha1\", \"v1beta1\"},","\t\t\t\tResources:   []string{pluralEL, pluralEL + \"/status\"},","\t\t\t},","\t\t},","\t}","","\tconfiguredWebhook, err := ac.mwhlister.Get(ac.key.Name)","\tif err != nil {","\t\treturn fmt.Errorf(\"error retrieving webhook: %w\", err)","\t}","","\twebhook := configuredWebhook.DeepCopy()","","\t// Clear out any previous (bad) OwnerReferences.","\t// See: https://github.com/knative/serving/issues/5845","\twebhook.OwnerReferences = nil","","\tfor i, wh := range webhook.Webhooks {","\t\tif wh.Name != webhook.Name {","\t\t\tcontinue","\t\t}","\t\twebhook.Webhooks[i].Rules = rules","\t\twebhook.Webhooks[i].NamespaceSelector = \u0026metav1.LabelSelector{","\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{","\t\t\t\tKey:      \"operator.tekton.dev/enable-annotation\",","\t\t\t\tOperator: metav1.LabelSelectorOpIn,","\t\t\t\tValues:   []string{\"enabled\"},","\t\t\t}, {","\t\t\t\t// \"control-plane\" is added to support Azure's AKS, otherwise the controllers fight.","\t\t\t\t// See knative/pkg#1590 for details.","\t\t\t\tKey:      \"control-plane\",","\t\t\t\tOperator: metav1.LabelSelectorOpDoesNotExist,","\t\t\t}},","\t\t}","\t\twebhook.Webhooks[i].ClientConfig.CABundle = caCert","\t\tif webhook.Webhooks[i].ClientConfig.Service == nil {","\t\t\treturn fmt.Errorf(\"missing service reference for webhook: %s\", wh.Name)","\t\t}","\t\twebhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())","\t}","","\tif ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil {","\t\treturn fmt.Errorf(\"error diffing webhooks: %w\", err)","\t} else if !ok {","\t\tlogger.Info(\"Updating webhook\")","\t\tmwhclient := ac.client.AdmissionregistrationV1().MutatingWebhookConfigurations()","\t\tif _, err := mwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil {","\t\t\treturn fmt.Errorf(\"failed to update webhook: %w\", err)","\t\t}","\t} else {","\t\tlogger.Info(\"Webhook is valid\")","\t}","\treturn nil","}","","func (ac *reconciler) mutate(ctx context.Context, req *admissionv1.AdmissionRequest) ([]byte, error) {","\tkind := req.Kind","\tnewBytes := req.Object.Raw","\toldBytes := req.OldObject.Raw","\t// Why, oh why are these different types...","\tgvk := schema.GroupVersionKind{","\t\tGroup:   kind.Group,","\t\tVersion: kind.Version,","\t\tKind:    kind.Kind,","\t}","","\tlogger := logging.FromContext(ctx)","\tif gvk.Group != \"triggers.tekton.dev\" || !(gvk.Version == \"v1alpha1\" || gvk.Version == \"v1beta1\") || gvk.Kind != \"EventListener\" {","\t\tlogger.Error(\"Unhandled kind: \", gvk)","\t\treturn nil, fmt.Errorf(\"unhandled kind: %v\", gvk)","\t}","","\t// nil values denote absence of `old` (create) or `new` (delete) objects.","\tvar oldObj, newObj v1beta1.EventListener","","\tif len(newBytes) != 0 {","\t\tnewDecoder := json.NewDecoder(bytes.NewBuffer(newBytes))","\t\tif ac.disallowUnknownFields {","\t\t\tnewDecoder.DisallowUnknownFields()","\t\t}","\t\tif err := newDecoder.Decode(\u0026newObj); err != nil {","\t\t\treturn nil, fmt.Errorf(\"cannot decode incoming new object: %w\", err)","\t\t}","\t}","\tif len(oldBytes) != 0 {","\t\toldDecoder := json.NewDecoder(bytes.NewBuffer(oldBytes))","\t\tif ac.disallowUnknownFields {","\t\t\toldDecoder.DisallowUnknownFields()","\t\t}","\t\tif err := oldDecoder.Decode(\u0026oldObj); err != nil {","\t\t\treturn nil, fmt.Errorf(\"cannot decode incoming old object: %w\", err)","\t\t}","\t}","\tvar patches duck.JSONPatch","","\tvar err error","\t// Skip this step if the type we're dealing with is a duck type, since it is inherently","\t// incomplete and this will patch away all of the unspecified fields.","\t// Add these before defaulting fields, otherwise defaulting may cause an illegal patch","\t// because it expects the round tripped through Golang fields to be present already.","\trtp, err := roundTripPatch(newBytes, newObj)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"cannot create patch for round tripped newBytes: %w\", err)","\t}","\tpatches = append(patches, rtp...)","","\tctx = apis.WithinCreate(ctx)","\tctx = apis.WithUserInfo(ctx, \u0026req.UserInfo)","","\t// Default the new object.","\tif patches, err = setDefaults(ctx, patches, newObj); err != nil {","\t\tlogger.Errorw(\"Failed the resource specific defaulter\", zap.Error(err))","\t\t// Return the error message as-is to give the defaulter callback","\t\t// discretion over (our portion of) the message that the user sees.","\t\treturn nil, err","\t}","","\treturn json.Marshal(patches)","}","","// roundTripPatch generates the JSONPatch that corresponds to round tripping the given bytes through","// the Golang type (JSON -\u003e Golang type -\u003e JSON). Because it is not always true that","// bytes == json.Marshal(json.Unmarshal(bytes)).","//","// For example, if bytes did not contain a 'spec' field and the Golang type specifies its 'spec'","// field without omitempty, then by round tripping through the Golang type, we would have added","// `'spec': {}`.","func roundTripPatch(bytes []byte, unmarshalled interface{}) (duck.JSONPatch, error) {","\tif unmarshalled == nil {","\t\treturn duck.JSONPatch{}, nil","\t}","\tmarshaledBytes, err := json.Marshal(unmarshalled)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"cannot marshal interface: %w\", err)","\t}","\treturn jsonpatch.CreatePatch(bytes, marshaledBytes)","}","","// setDefaults simply leverages apis.Defaultable to set defaults.","func setDefaults(ctx context.Context, patches duck.JSONPatch, el v1beta1.EventListener) (duck.JSONPatch, error) {","\tbefore, after := el.DeepCopyObject(), el","","\tsecretName := \"el-\" + el.Name","\tafter.Annotations = map[string]string{","\t\t\"service.beta.openshift.io/serving-cert-secret-name\": secretName,","\t}","\tif after.Spec.Resources.KubernetesResource == nil {","\t\tafter.Spec.Resources.KubernetesResource = \u0026v1beta1.KubernetesResource{}","\t\tafter.Spec.Resources.KubernetesResource = \u0026v1beta1.KubernetesResource{","\t\t\tWithPodSpec: duckv1.WithPodSpec{","\t\t\t\tTemplate: duckv1.PodSpecable{","\t\t\t\t\tSpec: corev1.PodSpec{","\t\t\t\t\t\tContainers: getContainers(secretName),","\t\t\t\t\t},","\t\t\t\t},","\t\t\t},","\t\t}","\t}","\tenvNames := map[string]string{}","\tif after.Spec.Resources.KubernetesResource != nil {","\t\tif len(after.Spec.Resources.KubernetesResource.Template.Spec.Containers) == 0 {","\t\t\tafter.Spec.Resources.KubernetesResource.Template.Spec.Containers = getContainers(secretName)","\t\t} else {","\t\t\tfor i := range after.Spec.Resources.KubernetesResource.Template.Spec.Containers {","\t\t\t\tif len(after.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env) == 0 {","\t\t\t\t\tafter.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env = getEnv(secretName)","\t\t\t\t} else {","\t\t\t\t\tfor _, v := range after.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env {","\t\t\t\t\t\tenvNames[v.Name] = v.Name","\t\t\t\t\t}","\t\t\t\t\tif envNames[\"TLS_CERT\"] != \"TLS_CERT\" \u0026\u0026 envNames[\"TLS_KEY\"] != \"TLS_KEY\" {","\t\t\t\t\t\tafter.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env = getEnv(secretName)","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\tpatch, err := duck.CreatePatch(before, after)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn append(patches, patch...), nil","}","","func getContainers(secretName string) []corev1.Container {","\treturn []corev1.Container{{","\t\tEnv: getEnv(secretName),","\t}}","}","","func getEnv(secretName string) []corev1.EnvVar {","\treturn []corev1.EnvVar{{","\t\tName: \"TLS_CERT\",","\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\tSecretKeyRef: \u0026corev1.SecretKeySelector{","\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\tName: secretName,","\t\t\t\t},","\t\t\t\tKey: \"tls.crt\",","\t\t\t},","\t\t},","\t}, {","\t\tName: \"TLS_KEY\",","\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\tSecretKeyRef: \u0026corev1.SecretKeySelector{","\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\tName: secretName,","\t\t\t\t},","\t\t\t\tKey: \"tls.key\",","\t\t\t},","\t\t},","\t}}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":141,"path":"pkg/reconciler/openshift/annotation/controller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package annotation","","import (","\t\"context\"","\t// Injection stuff","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tmwhinformer \"knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/mutatingwebhookconfiguration\"","\t\"knative.dev/pkg/controller\"","\tsecretinformer \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"",")","","// NewAdmissionController constructs a reconciler","func NewAdmissionController(","\tctx context.Context,","\tname, path string,","\twc func(context.Context) context.Context,","\tdisallowUnknownFields bool,",") *controller.Impl {","","\tclient := kubeclient.Get(ctx)","\tmwhInformer := mwhinformer.Get(ctx)","\tsecretInformer := secretinformer.Get(ctx)","\toptions := webhook.GetOptions(ctx)","","\tkey := types.NamespacedName{Name: name}","","\twh := \u0026reconciler{","\t\tLeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{","\t\t\t// Have this reconciler enqueue our singleton whenever it becomes leader.","\t\t\tPromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error {","\t\t\t\tenq(bkt, key)","\t\t\t\treturn nil","\t\t\t},","\t\t},","","\t\tkey:  key,","\t\tpath: path,","","\t\twithContext:           wc,","\t\tdisallowUnknownFields: disallowUnknownFields,","\t\tsecretName:            options.SecretName,","","\t\tclient:       client,","\t\tmwhlister:    mwhInformer.Lister(),","\t\tsecretlister: secretInformer.Lister(),","\t}","","\tlogger := logging.FromContext(ctx)","\tc := controller.NewContext(ctx, wh, controller.ControllerOptions{WorkQueueName: \"AnnotationDefaultingWebhook\", Logger: logger})","","\t// Reconcile when the named MutatingWebhookConfiguration changes.","\tif _, err := mwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithName(name),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named MWH resource.","\t\tHandler: controller.HandleAll(c.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register MutatingWebhookConfugration informer event handler: %w\", err)","\t}","","\t// Reconcile when the cert bundle changes.","\tif _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), wh.secretName),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named MWH resource.","\t\tHandler: controller.HandleAll(c.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register Secret informer event handler: %w\", err)","\t}","","\treturn c","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0]},{"id":142,"path":"pkg/reconciler/openshift/common/cabundle.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\t\"encoding/json\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/client-go/kubernetes/scheme\"",")","","const (","\tsystemCAVolume = \"config-trusted-system-cabundle-volume\"","\tsystemCAKey    = \"tls-ca-bundle.pem\"","\tsystemCADir    = \"/etc/pki/ca-trust/extracted/pem\"",")","","// ApplyCABundlesToDeployment is a transformer that add the trustedCA volume, mount and","// environment variables so that the deployment uses it.","func ApplyCABundlesToDeployment(u *unstructured.Unstructured) error {","\tif u.GetKind() != \"Deployment\" {","\t\t// Don't do anything on something else than Deployment","\t\treturn nil","\t}","","\tdeployment := \u0026appsv1.Deployment{}","\tif err := scheme.Scheme.Convert(u, deployment, nil); err != nil {","\t\treturn err","\t}","","\t// Let's add the trusted and service CA bundle ConfigMaps as a volume in","\t// the PodSpec which will later be mounted to add certs in the pod.","\tdeployment.Spec.Template.Spec.Volumes = common.AddCABundleConfigMapsToVolumes(deployment.Spec.Template.Spec.Volumes)","\tdeployment.Spec.Template.Spec.Volumes = common.AddOrReplaceInList(","\t\tdeployment.Spec.Template.Spec.Volumes,","\t\tcommon.NewVolumeWithConfigMap(systemCAVolume, common.TrustedCAConfigMapName, common.TrustedCAKey, systemCAKey),","\t\tfunc(v corev1.Volume) string { return v.Name },","\t)","","\t// Now that the injected certificates have been added as a volume, let's","\t// mount them via volumeMounts in the containers","\tfor i := range deployment.Spec.Template.Spec.Containers {","\t\tc := deployment.Spec.Template.Spec.Containers[i] // Create a copy of the container","\t\tcommon.AddCABundlesToContainerVolumes(\u0026c)","\t\taddCABundlesToContainerSystemCAStore(\u0026c)","\t\tdeployment.Spec.Template.Spec.Containers[i] = c","\t}","","\tdeployment.SetGroupVersionKind(schema.GroupVersionKind{","\t\tGroup:   appsv1.SchemeGroupVersion.Group,","\t\tVersion: appsv1.SchemeGroupVersion.Version,","\t\tKind:    \"Deployment\",","\t})","\tm, err := toUnstructured(deployment)","\tif err != nil {","\t\treturn err","\t}","\tu.SetUnstructuredContent(m.Object)","\treturn nil","}","","func toUnstructured(v interface{}) (*unstructured.Unstructured, error) {","\tb, err := json.Marshal(v)","\tif err != nil {","\t\treturn nil, err","\t}","\tud := \u0026unstructured.Unstructured{}","\tif err := json.Unmarshal(b, ud); err != nil {","\t\treturn nil, err","\t}","\treturn ud, nil","}","","// ApplyCABundlesForStatefulSet is a transformer that adds CA bundle configurations to a StatefulSet.","// It configures both trusted CA bundle and service CA bundle by:","// - Adding volumes for the CA bundle ConfigMaps","// - Adding volume mounts to containers","// - Setting up necessary annotations for OpenShift service CA injection","// The function modifies the StatefulSet in place and returns any error encountered.","func ApplyCABundlesForStatefulSet(name string) func(u *unstructured.Unstructured) error {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"StatefulSet\" || u.GetName() != name {","\t\t\t// Don't do anything on something else than the specified StatefulSet","\t\t\treturn nil","\t\t}","","\t\tsts := \u0026appsv1.StatefulSet{}","\t\tif err := scheme.Scheme.Convert(u, sts, nil); err != nil {","\t\t\treturn err","\t\t}","","\t\t// Let's add the trusted and service CA bundle ConfigMaps as a volume in","\t\t// the PodSpec which will later be mounted to add certs in the pod.","\t\tsts.Spec.Template.Spec.Volumes = common.AddCABundleConfigMapsToVolumes(sts.Spec.Template.Spec.Volumes)","\t\tsts.Spec.Template.Spec.Volumes = common.AddOrReplaceInList(","\t\t\tsts.Spec.Template.Spec.Volumes,","\t\t\tcommon.NewVolumeWithConfigMap(systemCAVolume, common.TrustedCAConfigMapName, common.TrustedCAKey, systemCAKey),","\t\t\tfunc(v corev1.Volume) string { return v.Name },","\t\t)","","\t\t// Now that the injected certificates have been added as a volume, let's","\t\t// mount them via volumeMounts in the containers","\t\tfor i := range sts.Spec.Template.Spec.Containers {","\t\t\tc := sts.Spec.Template.Spec.Containers[i] // Create a copy of the container","\t\t\tcommon.AddCABundlesToContainerVolumes(\u0026c)","\t\t\taddCABundlesToContainerSystemCAStore(\u0026c)","\t\t\tsts.Spec.Template.Spec.Containers[i] = c","\t\t}","","\t\tsts.SetGroupVersionKind(schema.GroupVersionKind{","\t\t\tGroup:   appsv1.SchemeGroupVersion.Group,","\t\t\tVersion: appsv1.SchemeGroupVersion.Version,","\t\t\tKind:    \"StatefulSet\",","\t\t})","\t\tm, err := toUnstructured(sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(m.Object)","\t\treturn nil","\t}","}","","// addCABundlesToContainerSystemCAStore mounts the trusted-ca-configmap into the system ca store.","// This is necessary for components shelling out to \"legacy applications\" (e.g. cURL or git) to","// use the CA bundles, as \"legacy applications\"  do not respect SSL_CERT_DIR. In the Openshift","// environment the TrustedCAConfigMap has both the default and custom certificates combined.","// Note that the TrustedCAConfigMap does not contain the Service CA bundle. However that is","// utilized for the internal image registry and its tooling respects SSL_CERT_DIR.","//","// NOTE: This transformer should not be applied to pod templates which could reference","// user-defined images such as a TaskRun or PipelineRun since the transformer both assumes the","// image is a RHEL or a similar environment and because it may override a user's image's custom","// certificate bundle.","//","// See `man(8) update-ca-trust` for documentation on the directory structure and usage","// See openshift documentation for CA mounting details:","//","//\thttps://github.com/openshift/openshift-docs/blob/a8269cf65696fbd08647c8f3b5d065d53a8a1f52/modules/certificate-injection-using-operators.adoc","func addCABundlesToContainerSystemCAStore(container *corev1.Container) {","\tnewMount := corev1.VolumeMount{","\t\tName:      systemCAVolume,","\t\tMountPath: systemCADir,","\t\tReadOnly:  true,","\t}","","\tcontainer.VolumeMounts = common.AddOrReplaceInList(","\t\tcontainer.VolumeMounts,","\t\tnewMount,","\t\tfunc(v corev1.VolumeMount) string { return v.Name },","\t)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,1,0,2,2,1,1,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,1,2,2,0,0,2,2,2,1,1,2,2,1,1,2,0,0,0,0,0,0,0,0,2,2,2,1,1,1,0,2,2,1,1,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0]},{"id":143,"path":"pkg/reconciler/openshift/common/transformer.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package common","","import (","\tmf \"github.com/manifestival/manifestival\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tbatchv1 \"k8s.io/api/batch/v1\"","\tv1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","// RemoveRunAsUser will remove RunAsUser from all container in a deployment","func RemoveRunAsUser() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := d.Spec.Template.Spec.Containers","\t\tremoveRunAsUser(containers)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// RemoveRunAsUserForJob will remove RunAsUser from all container in a job","func RemoveRunAsUserForJob() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Job\" {","\t\t\treturn nil","\t\t}","","\t\tjb := \u0026batchv1.Job{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := jb.Spec.Template.Spec.Containers","\t\tremoveRunAsUser(containers)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","func removeRunAsUser(containers []v1.Container) {","\tfor i := range containers {","\t\tc := \u0026containers[i]","\t\tif c.SecurityContext != nil {","\t\t\t// Remove runAsUser","\t\t\tc.SecurityContext.RunAsUser = nil","\t\t}","\t}","}","","// RemoveRunAsGroup will remove runAsGroup from all container in a deployment","func RemoveRunAsGroup() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tfor i := range d.Spec.Template.Spec.Containers {","\t\t\tc := \u0026d.Spec.Template.Spec.Containers[i]","\t\t\tif c.SecurityContext != nil {","\t\t\t\t// Remove runAsGroup","\t\t\t\tc.SecurityContext.RunAsGroup = nil","\t\t\t}","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// RemoveFsGroupForDeployment will remove FsGroup in a deployment","func RemoveFsGroupForDeployment() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif d.Spec.Template.Spec.SecurityContext.FSGroup != nil {","\t\t\td.Spec.Template.Spec.SecurityContext.FSGroup = nil","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// RemoveFsGroupForJob will remove FsGroup in a job","func RemoveFsGroupForJob() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Job\" {","\t\t\treturn nil","\t\t}","","\t\tjb := \u0026batchv1.Job{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif jb.Spec.Template.Spec.SecurityContext.FSGroup != nil {","\t\t\tjb.Spec.Template.Spec.SecurityContext.FSGroup = nil","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","func UpdateServiceMonitorTargetNamespace(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ServiceMonitor\" {","\t\t\treturn nil","\t\t}","\t\tnsSelector, found, err := unstructured.NestedFieldNoCopy(u.Object, \"spec\", \"namespaceSelector\")","\t\tif !found || err != nil {","\t\t\treturn err","\t\t}","\t\tnsSelector.(map[string]interface{})[\"matchNames\"].([]interface{})[0] = targetNamespace","\t\treturn nil","\t}","}","","// RemoveRunAsUserForStatefulset will remove RunAsUser from all container in a statefulset","func RemoveRunAsUserForStatefulSet(name string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"StatefulSet\" || u.GetName() != name {","\t\t\treturn nil","\t\t}","","\t\tsts := \u0026appsv1.StatefulSet{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := sts.Spec.Template.Spec.Containers","\t\tremoveRunAsUser(containers)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// RemoveFsGroupForStatefulSet will remove FsGroup in a statefulset","func RemoveFsGroupForStatefulSet(name string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"StatefulSet\" || u.GetName() != name {","\t\t\treturn nil","\t\t}","","\t\tsts := \u0026appsv1.StatefulSet{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif sts.Spec.Template.Spec.SecurityContext != nil \u0026\u0026 sts.Spec.Template.Spec.SecurityContext.FSGroup != nil {","\t\t\tsts.Spec.Template.Spec.SecurityContext.FSGroup = nil","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// RemoveRunAsGroupForStatefulSet will remove runAsGroup from all container in a statefulset","func RemoveRunAsGroupForStatefulSet(name string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"StatefulSet\" || u.GetName() != name {","\t\t\treturn nil","\t\t}","","\t\tsts := \u0026appsv1.StatefulSet{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tfor i := range sts.Spec.Template.Spec.Containers {","\t\t\tc := \u0026sts.Spec.Template.Spec.Containers[i]","\t\t\tif c.SecurityContext != nil {","\t\t\t\t// Remove runAsGroup","\t\t\t\tc.SecurityContext.RunAsGroup = nil","\t\t\t}","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,2,0,0,2,2,1,1,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,0,2,2,1,1,2,2,2,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,2,2,2,1,1,2,2,1,1,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,0,2,2,1,1,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,2,0,0,2,2,1,1,2,2,2,0,0]},{"id":144,"path":"pkg/reconciler/openshift/manualapprovalgate/controller.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package manualapprovalgate","","import (","\t\"context\"","","\tk8s_ctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/manualapprovalgate\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":145,"path":"pkg/reconciler/openshift/manualapprovalgate/extension.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package manualapprovalgate","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\text := openshiftExtension{","\t\toperatorClientSet: operatorclient.Get(ctx),","\t}","\treturn ext","}","","type openshiftExtension struct {","\toperatorClientSet versioned.Interface","}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{}","}","","func (oe openshiftExtension) PreReconcile(ctx context.Context, mag v1alpha1.TektonComponent) error {","\treturn nil","}","","func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","","func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1]},{"id":146,"path":"pkg/reconciler/openshift/namespace/controller.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package namespace","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonconfig\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tvwhinformer \"knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/validatingwebhookconfiguration\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\tsecretinformer \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"",")","","func NewNamespaceAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","","\treturn NewAdmissionController(ctx,","","\t\t// Name of the resource webhook.","\t\t\"namespace.operator.tekton.dev\",","","\t\t// The path on which to serve the webhook.","\t\t\"/namespace-validation\",","","\t\t// A function that infuses the context passed to Validate/SetDefaults with custom metadata.","\t\tfunc(ctx context.Context) context.Context {","\t\t\treturn ctx","\t\t},","","\t\t// Whether to disallow unknown fields.","\t\ttrue,","\t)","}","","// NewAdmissionController constructs a reconciler","func NewAdmissionController(","\tctx context.Context,","\tname, path string,","\twc func(context.Context) context.Context,","\tdisallowUnknownFields bool,",") *controller.Impl {","","\tclient := kubeclient.Get(ctx)","\tvwhInformer := vwhinformer.Get(ctx)","\tsecretInformer := secretinformer.Get(ctx)","\toptions := webhook.GetOptions(ctx)","\ttektonConfigInformer := tektonconfig.Get(ctx)","","\tkey := types.NamespacedName{Name: name}","","\twh := \u0026reconciler{","\t\tLeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{","\t\t\t// Have this reconciler enqueue our singleton whenever it becomes leader.","\t\t\tPromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error {","\t\t\t\tenq(bkt, key)","\t\t\t\treturn nil","\t\t\t},","\t\t},","","\t\tkey:  key,","\t\tpath: path,","","\t\twithContext:           wc,","\t\tdisallowUnknownFields: disallowUnknownFields,","\t\tsecretName:            options.SecretName,","","\t\tclient:             client,","\t\tvwhlister:          vwhInformer.Lister(),","\t\tsecretlister:       secretInformer.Lister(),","\t\ttektonConfigLister: tektonConfigInformer.Lister(),","\t}","","\tlogger := logging.FromContext(ctx)","\tc := controller.NewContext(ctx, wh, controller.ControllerOptions{WorkQueueName: \"NamespaceAdmissionWebhook\", Logger: logger})","","\t// Reconcile when the named ValidatingWebhookConfiguration changes.","\tif _, err := vwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithName(name),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named VWH resource.","\t\tHandler: controller.HandleAll(c.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register ValidatingWebhookConfugration informer event handler: %w\", err)","\t}","","\t// Reconcile when the cert bundle changes.","\tif _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), wh.secretName),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named VWH resource.","\t\tHandler: controller.HandleAll(c.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register Secret informer event handler: %w\", err)","\t}","","\treturn c","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0]},{"id":147,"path":"pkg/reconciler/openshift/namespace/namespace.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package namespace","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/markbates/inflect\"","\t\"github.com/tektoncd/operator/pkg/client/listers/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/openshift\"","\t\"go.uber.org/zap\"","","\tadmissionv1 \"k8s.io/api/admission/v1\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","\tadmissionlisters \"k8s.io/client-go/listers/admissionregistration/v1\"","\tcorelisters \"k8s.io/client-go/listers/core/v1\"","","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/kmp\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"","\tcertresources \"knative.dev/pkg/webhook/certificates/resources\"",")","","// reconciler implements the AdmissionController for resources","type reconciler struct {","\twebhook.StatelessAdmissionImpl","\tpkgreconciler.LeaderAwareFuncs","","\tkey  types.NamespacedName","\tpath string","","\twithContext func(context.Context) context.Context","","\tclient             kubernetes.Interface","\tvwhlister          admissionlisters.ValidatingWebhookConfigurationLister","\tsecretlister       corelisters.SecretLister","\ttektonConfigLister v1alpha1.TektonConfigLister","","\tdisallowUnknownFields bool","\tsecretName            string","}","","var _ controller.Reconciler = (*reconciler)(nil)","var _ pkgreconciler.LeaderAware = (*reconciler)(nil)","var _ webhook.AdmissionController = (*reconciler)(nil)","var _ webhook.StatelessAdmissionController = (*reconciler)(nil)","","// Reconcile implements controller.Reconciler","func (ac *reconciler) Reconcile(ctx context.Context, key string) error {","\tlogger := logging.FromContext(ctx)","","\tif !ac.IsLeaderFor(ac.key) {","\t\tlogger.Debugf(\"Skipping key %q, not the leader.\", ac.key)","\t\treturn nil","\t}","","\t// Look up the webhook secret, and fetch the CA cert bundle.","\tsecret, err := ac.secretlister.Secrets(system.Namespace()).Get(ac.secretName)","\tif err != nil {","\t\tlogger.Errorw(\"Error fetching secret\", zap.Error(err))","\t\treturn err","\t}","\tcaCert, ok := secret.Data[certresources.CACert]","\tif !ok {","\t\treturn fmt.Errorf(\"secret %q is missing %q key\", ac.secretName, certresources.CACert)","\t}","","\t// Reconcile the webhook configuration.","\treturn ac.reconcileValidatingWebhook(ctx, caCert)","}","","// Path implements AdmissionController","func (ac *reconciler) Path() string {","\treturn ac.path","}","","// Admit implements AdmissionController","func (ac *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {","\tif ac.withContext != nil {","\t\tctx = ac.withContext(ctx)","\t}","","\tlogger := logging.FromContext(ctx)","","\t// Need to handle both, create and update operations for a namespace","\tswitch request.Operation {","\tcase admissionv1.Create, admissionv1.Update:","\tdefault:","\t\tlogger.Info(\"Unhandled webhook operation, letting it through \", request.Operation)","\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t}","","\tisAllowed, status, err := ac.admissionAllowed(ctx, request)","\tif err != nil {","\t\treturn webhook.MakeErrorStatus(\"admission failed for namespace %v\", err)","\t}","","\t// Something in status means that admission isn't allowed","\tif status != nil {","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\t// isAllowed should be false here always","\t\t\tAllowed: isAllowed,","\t\t\tResult:  status,","\t\t}","\t}","","\treturn \u0026admissionv1.AdmissionResponse{","\t\t// At this point, isAllowed should always be true","\t\tAllowed: isAllowed,","\t}","}","","func (ac *reconciler) admissionAllowed(ctx context.Context, req *admissionv1.AdmissionRequest) (bool, *metav1.Status, error) {","\tkind := req.Kind","\tnamespaceRawBytes := req.Object.Raw","","\t// Why, oh why are these different types...","\tgvk := schema.GroupVersionKind{","\t\tGroup:   kind.Group,","\t\tVersion: kind.Version,","\t\tKind:    kind.Kind,","\t}","","\tlogger := logging.FromContext(ctx)","\tif gvk.Group != \"\" || gvk.Version != \"v1\" || gvk.Kind != \"Namespace\" {","\t\tlogger.Error(\"Unhandled kind: \", gvk)","\t\treturn false, nil, fmt.Errorf(\"unhandled kind: %v\", gvk)","\t}","","\t// nil values denote absence of `old` (create) or `new` (delete) objects.","\tvar namespaceObject corev1.Namespace","","\tif len(namespaceRawBytes) != 0 {","\t\tnewDecoder := json.NewDecoder(bytes.NewBuffer(namespaceRawBytes))","\t\tif ac.disallowUnknownFields {","\t\t\tnewDecoder.DisallowUnknownFields()","\t\t}","\t\tif err := newDecoder.Decode(\u0026namespaceObject); err != nil {","\t\t\treturn false, nil, fmt.Errorf(\"cannot decode incoming new object: %w\", err)","\t\t}","\t}","","\tnsSCC := namespaceObject.Annotations[openshift.NamespaceSCCAnnotation]","\t// If no annotation in namespace, then nothing to do here","\tif nsSCC == \"\" {","\t\treturn true, nil, nil","\t}","","\tlogger.Infof(\"Trying to admit namespace: %s with SCC: %s\", namespaceObject.Name, nsSCC)","","\tsecurityClient := common.GetSecurityClient(ctx)","","\t// verify SCC exists on the cluster","\t_, err := securityClient.SecurityV1().SecurityContextConstraints().Get(ctx, nsSCC, metav1.GetOptions{})","\tif err != nil {","\t\treturn false, nil, err","\t}","","\ttc, err := ac.tektonConfigLister.Get(\"config\")","\tif err != nil {","\t\treturn false, nil, err","\t}","","\t// Check if the SCC requested in namespace is in line with the maxAllowed SCC in TektonConfig","\tmaxAllowedSCC := tc.Spec.Platforms.OpenShift.SCC.MaxAllowed","","\t// If no maxAllowed is set, no problem","\tif maxAllowedSCC == \"\" {","\t\tlogger.Infof(\"Namespace %s validation: no maxAllowed SCC set in TektonConfig\", namespaceObject.Name)","\t\treturn true, nil, nil","\t}","","\tprioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, securityClient)","\tif err != nil {","\t\treturn false, nil, err","\t}","","\tisPriority, err := common.SCCAMoreRestrictiveThanB(prioritizedSCCList, nsSCC, maxAllowedSCC)","\tif err != nil {","\t\treturn false, nil, err","\t}","\tlogger.Infof(\"Is maxAllowed SCC: %s less restrictive than namespace SCC: %s? %t\", maxAllowedSCC, nsSCC, isPriority)","\tif !isPriority {","\t\tprioErr := fmt.Sprintf(\"namespace: %s has requested SCC: %s, but it is less restrictive than 'maxAllowed' SCC: %s\", namespaceObject.Name, nsSCC, maxAllowedSCC)","\t\treturn false, \u0026metav1.Status{","\t\t\tStatus:  \"Failure\",","\t\t\tMessage: prioErr,","\t\t}, nil","\t}","","\treturn true, nil, nil","}","","func (ac *reconciler) reconcileValidatingWebhook(ctx context.Context, caCert []byte) error {","\tlogger := logging.FromContext(ctx)","","\tpluralNS := strings.ToLower(inflect.Pluralize(\"Namespace\"))","\trules := []admissionregistrationv1.RuleWithOperations{","\t\t{","\t\t\tOperations: []admissionregistrationv1.OperationType{","\t\t\t\tadmissionregistrationv1.Create,","\t\t\t\tadmissionregistrationv1.Update,","\t\t\t},","\t\t\tRule: admissionregistrationv1.Rule{","\t\t\t\tAPIGroups:   []string{\"\"},","\t\t\t\tAPIVersions: []string{\"v1\"},","\t\t\t\tResources:   []string{pluralNS, pluralNS + \"/status\"},","\t\t\t},","\t\t},","\t}","","\tconfiguredWebhook, err := ac.vwhlister.Get(ac.key.Name)","\tif err != nil {","\t\treturn fmt.Errorf(\"error retrieving webhook: %w\", err)","\t}","","\twebhook := configuredWebhook.DeepCopy()","","\t// Clear out any previous (bad) OwnerReferences.","\t// See: https://github.com/knative/serving/issues/5845","\twebhook.OwnerReferences = nil","","\tfor i, wh := range webhook.Webhooks {","\t\tif wh.Name != webhook.Name {","\t\t\tcontinue","\t\t}","\t\twebhook.Webhooks[i].Rules = rules","\t\twebhook.Webhooks[i].NamespaceSelector = \u0026metav1.LabelSelector{","\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{","\t\t\t\t{","\t\t\t\t\t// \"control-plane\" is added to support Azure's AKS, otherwise the controllers fight.","\t\t\t\t\t// See knative/pkg#1590 for details.","\t\t\t\t\tKey:      \"control-plane\",","\t\t\t\t\tOperator: metav1.LabelSelectorOpDoesNotExist,","\t\t\t\t},","\t\t\t},","\t\t}","\t\t// Exclude system namespaces","\t\twebhook.Webhooks[i].MatchConditions = []admissionregistrationv1.MatchCondition{","\t\t\t{","\t\t\t\tName:       \"exclude-system-namespaces\",","\t\t\t\tExpression: \"!(object.metadata.name.startsWith('kube-') || object.metadata.name.startsWith('openshift-'))\",","\t\t\t},","\t\t}","","\t\twebhook.Webhooks[i].ClientConfig.CABundle = caCert","\t\tif webhook.Webhooks[i].ClientConfig.Service == nil {","\t\t\treturn fmt.Errorf(\"missing service reference for webhook: %s\", wh.Name)","\t\t}","\t\twebhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())","\t}","","\tif ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil {","\t\treturn fmt.Errorf(\"error diffing webhooks: %w\", err)","\t} else if !ok {","\t\tlogger.Info(\"Updating webhook\")","\t\tvwhclient := ac.client.AdmissionregistrationV1().ValidatingWebhookConfigurations()","\t\tif _, err := vwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil {","\t\t\treturn fmt.Errorf(\"failed to update webhook: %w\", err)","\t\t}","\t} else {","\t\tlogger.Info(\"Webhook is valid\")","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,0,0,2,2,1,1,0,2,2,2,2,0,2,2,2,0,0,2,2,1,1,0,0,2,1,1,1,1,1,1,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,1,1,2,1,1,0,0,2,2,2,2,2,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":148,"path":"pkg/reconciler/openshift/openshiftpipelinesascode/controller.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package openshiftpipelinesascode","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\tpacInformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/openshiftpipelinesascode\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\tpacreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/openshiftpipelinesascode\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/client-go/tools/cache\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const versionConfigMap = \"pipelines-as-code-info\"","","// NewController initializes the controller and is called by the generated code","// Registers event handlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(OpenShiftExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tctrl := common.Controller{","\t\t\tLogger:           logger,","\t\t\tVersionConfigMap: versionConfigMap,","\t\t}","\t\tmanifest, pacVersion := ctrl.InitController(ctx, common.PayloadOptions{})","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","","\t\tmetrics, err := common.NoMetrics()","\t\tif err != nil {","\t\t\tlogger.Errorf(\"Failed to create trigger metrics recorder %v\", err)","\t\t}","","\t\tc := \u0026Reconciler{","\t\t\tpipelineInformer:      tektonPipelineinformer.Get(ctx),","\t\t\tinstallerSetClient:    client.NewInstallerSetClient(tisClient, operatorVer, pacVersion, v1alpha1.KindOpenShiftPipelinesAsCode, metrics),","\t\t\textension:             generator(ctx),","\t\t\tmanifest:              manifest,","\t\t\tadditionalPACManifest: filterAdditionalControllerManifest(manifest),","\t\t\tpacVersion:            pacVersion,","\t\t}","\t\timpl := pacreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for OpenShiftPipelinesAsCode\")","","\t\tif _, err := pacInformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register OpenShiftPipelinesAsCode informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.OpenShiftPipelinesAsCode{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0]},{"id":149,"path":"pkg/reconciler/openshift/openshiftpipelinesascode/extension.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package openshiftpipelinesascode","","import (","\t\"context\"","\t\"os\"","\t\"path/filepath\"","","\tmfc \"github.com/manifestival/client-go-client\"","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const (","\topenshiftNS = \"openshift\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\tlogger := logging.FromContext(ctx)","","\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\tif err != nil {","\t\tlogger.Fatalw(\"Error creating client from injected config\", zap.Error(err))","\t}","\tpacManifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient))","\tif err != nil {","\t\tlogger.Fatalw(\"Error creating initial manifest\", zap.Error(err))","\t}","","\tpacLocation := filepath.Join(os.Getenv(common.KoEnvKey), \"tekton-addon\", \"pipelines-as-code\")","\tif err := common.AppendManifest(\u0026pacManifest, pacLocation); err != nil {","\t\tlogger.Fatalf(\"failed to fetch PAC manifest: %v\", err)","\t}","","\tprTemplates, err := fetchPipelineRunTemplates()","\tif err != nil {","\t\tlogger.Fatalf(\"failed to fetch pipelineRun templates: %v\", err)","\t}","","\toperatorVer, err := common.OperatorVersion(ctx)","\tif err != nil {","\t\tlogger.Fatal(err)","\t}","","\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","\treturn openshiftExtension{","\t\t// component version is used for metrics, passing a dummy","\t\t// value through extension not going to affect execution","\t\tinstallerSetClient:   client.NewInstallerSetClient(tisClient, operatorVer, \"pipelines-as-code-ext\", v1alpha1.KindOpenShiftPipelinesAsCode, nil),","\t\tpacManifest:          \u0026pacManifest,","\t\tpipelineRunTemplates: prTemplates,","\t}","}","","type openshiftExtension struct {","\tinstallerSetClient   *client.InstallerSetClient","\tpacManifest          *mf.Manifest","\tpipelineRunTemplates *mf.Manifest","}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn nil","}","func (oe openshiftExtension) PreReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tlogger := logging.FromContext(ctx)","","\tif err := oe.installerSetClient.PostSet(ctx, comp, oe.pipelineRunTemplates, extFilterAndTransform()); err != nil {","\t\tlogger.Error(\"failed post set creation: \", err)","\t\treturn err","\t}","","\tif err := updateControllerRouteInConfigMap(oe.pacManifest, comp.GetSpec().GetTargetNamespace()); err != nil {","\t\tlogger.Error(\"failed to update controller route: \", err)","\t\treturn err","\t}","\treturn nil","}","func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","","func extFilterAndTransform() client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tprTemplates, err := manifest.Transform(mf.InjectNamespace(openshiftNS))","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn \u0026prTemplates, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0]},{"id":150,"path":"pkg/reconciler/openshift/openshiftpipelinesascode/pipelinerun_templates.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package openshiftpipelinesascode","","import (","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\tv1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"sigs.k8s.io/yaml\"",")","","const (","\tpacRuntimeLabel = \"pipelinesascode.openshift.io/runtime\"",")","","var configmapTemplate = `apiVersion: v1","kind: ConfigMap","metadata:","  name: pipelines-as-code-template","  labels:","    app.kubernetes.io/part-of: pipelines-as-code","data:","  template: \"\"`","","func fetchPipelineRunTemplates() (*mf.Manifest, error) {","\tprManifests := mf.Manifest{}","\tkoDataDir := os.Getenv(common.KoEnvKey)","\ttemplateLocation := filepath.Join(koDataDir, \"tekton-addon\", \"pipelines-as-code-templates\")","\tif err := common.AppendManifest(\u0026prManifests, templateLocation); err != nil {","\t\treturn nil, err","\t}","\tcmManifest, err := pipelineRunToConfigMapConverter(\u0026prManifests)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn cmManifest, nil","}","","func pipelineRunToConfigMapConverter(prManifests *mf.Manifest) (*mf.Manifest, error) {","\tcm := \u0026v1.ConfigMap{}","\terr := yaml.Unmarshal([]byte(configmapTemplate), cm)","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar temp []unstructured.Unstructured","\tfor _, res := range prManifests.Resources() {","\t\tif res.GetKind() != \"PipelineRun\" {","\t\t\ttemp = append(temp, res)","\t\t\tcontinue","\t\t}","","\t\tdata, err := yaml.Marshal(res.Object)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","","\t\t// set pipelineRun","\t\tcm.Data[\"template\"] = string(data)","","\t\t// set metadata","\t\tprname := res.GetName()","\t\tcm.SetName(fmt.Sprintf(\"pipelines-as-code-%s\", prname))","\t\tcm.Labels[pacRuntimeLabel] = strings.TrimPrefix(prname, \"pipelinerun-\")","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","","\t\ttemp = append(temp, unstructured.Unstructured{Object: unstrObj})","\t}","\tmanifest, _ := mf.ManifestFrom(mf.Slice(temp))","\treturn \u0026manifest, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,1,1,0,2,0,2,2,0]},{"id":151,"path":"pkg/reconciler/openshift/openshiftpipelinesascode/reconcile.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    hpacp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package openshiftpipelinesascode","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tpipelineinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\tpacreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/openshiftpipelinesascode\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/selection\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const (","\t// additionalPACController installerset label value","\tadditionalPACControllerComponentLabelValue = \"AdditionalPACController\"",")","","// Reconciler implements controller.Reconciler for OpenShiftPipelinesAsCode resources.","type Reconciler struct {","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// pipelineInformer to query for TektonPipeline","\tpipelineInformer pipelineinformer.TektonPipelineInformer","\t// manifest has the source manifest of Openshift Pipelines As Code for a","\t// particular version","\tmanifest mf.Manifest","\t// Platform-specific behavior to affect the transform","\textension common.Extension","\t// version of PipelinesAsCode which we are installing","\tpacVersion string","\t// additionalPACManifest has the source manifest for the additional Openshift Pipelines As Code Controller","\tadditionalPACManifest mf.Manifest","}","","// Check that our Reconciler implements controller.Reconciler","var _ pacreconciler.Interface = (*Reconciler)(nil)","","// ReconcileKind compares the actual state with the desired, and apacempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, pac *v1alpha1.OpenShiftPipelinesAsCode) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"name\", pac.GetName())","\tpac.Status.InitializeConditions()","\tpac.Status.SetVersion(r.pacVersion)","","\tif pac.GetName() != v1alpha1.OpenShiftPipelinesAsCodeName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.OpenShiftPipelinesAsCodeName,","\t\t\tpac.GetName(),","\t\t)","\t\tlogger.Error(msg)","\t\tpac.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t//Make sure TektonPipeline is installed before proceeding with OpenShiftPipelinesAsCode","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\tpac.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\t// (tektonpipeline.operator.tekton.dev instance not available yet)","\t\tpac.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","\tpac.Status.MarkDependenciesInstalled()","","\tif err := r.extension.PreReconcile(ctx, pac); err != nil {","\t\treturn err","\t}","","\t//Mark PreReconcile Complete","\tpac.Status.MarkPreReconcilerComplete()","","\tif err := r.installerSetClient.MainSet(ctx, pac, \u0026r.manifest, filterAndTransform(r.extension)); err != nil {","\t\tmsg := fmt.Sprintf(\"Main Reconcilation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\treturn err","\t\t}","\t\tpac.Status.MarkInstallerSetNotReady(msg)","\t\treturn nil","\t}","","\t// created additionalPACController for all entries provided","\tfor name, pacInfo := range pac.Spec.PACSettings.AdditionalPACControllers {","\t\t// if it is not enabled then skip creating the additionalPACController","\t\tif !*pacInfo.Enable {","\t\t\tcontinue","\t\t}","","\t\tadditionalPACControllerManifest := r.additionalPACManifest","\t\t// if name of configMap is pipeline-as-code, then not create a new configmap","\t\tif pacInfo.ConfigMapName == pipelinesAsCodeCM {","\t\t\tadditionalPACControllerManifest = additionalPACControllerManifest.Filter(mf.Not(mf.ByKind(\"ConfigMap\")))","\t\t}","","\t\t// create custome set installerset for the additionalPACController","\t\tif err := r.installerSetClient.CustomSet(ctx, pac, name, \u0026additionalPACControllerManifest, additionalControllerTransform(r.extension, name), additionalPacControllerLabels()); err != nil {","\t\t\tmsg := fmt.Sprintf(\"Additional PACController %s Reconciliation failed: %s\", name, err.Error())","\t\t\tlogger.Error(msg)","\t\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\t\treturn err","\t\t\t}","\t\t\tpac.Status.MarkInstallerSetNotReady(msg)","\t\t\treturn nil","\t\t}","\t}","","\t// Handle the deletion of obsolute installersets of additionalController","\tlabelSelector := additionalPacControllerLabelSelector()","\tlogger.Debugf(\"checking custom installer sets with labels: %v\", labelSelector)","\tis, err := r.installerSetClient.ListCustomSet(ctx, labelSelector)","\tif err != nil {","\t\tmsg := fmt.Sprintf(\"Additional PACController Reconciliation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\treturn err","\t\t}","\t}","\t// for all the custom installerset available, iterate and delete which have been removed or disabled","\tfor _, i := range is.Items {","\t\t// get the value of setType label which will be custom-\u003cname\u003e","\t\tsetTypeValue := i.GetLabels()[v1alpha1.InstallerSetType]","\t\t// remove the prefix custom- to get the name","\t\tname := strings.TrimPrefix(setTypeValue, fmt.Sprintf(\"%s-\", client.InstallerTypeCustom))","\t\t// check if the name exist in CR spec","\t\tadditionalPACinfo, ok := pac.Spec.PACSettings.AdditionalPACControllers[name]","\t\t// if not exist with same name or marked disable, delete the installerset","\t\tif !ok || !*additionalPACinfo.Enable {","\t\t\tif err := r.installerSetClient.CleanupCustomSet(ctx, name); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t}","","\tpac.Status.MarkAdditionalPACControllerComplete()","","\tif err := r.extension.PostReconcile(ctx, pac); err != nil {","\t\tmsg := fmt.Sprintf(\"PostReconciliation failed: %s\", err.Error())","\t\tlogger.Error(msg)","\t\tif err == v1alpha1.REQUEUE_EVENT_AFTER {","\t\t\treturn err","\t\t}","\t\tpac.Status.MarkPostReconcilerFailed(msg)","\t\treturn nil","\t}","","\t// Mark PostReconcile Complete","\tpac.Status.MarkPostReconcilerComplete()","\treturn nil","}","","// custom labels to added to the additionalPACController installerset","func additionalPacControllerLabels() map[string]string {","\tlabels := map[string]string{}","\tlabels[v1alpha1.ComponentKey] = additionalPACControllerComponentLabelValue","\treturn labels","}","","// labelSelector to filter the customsets of additionalPACController","func additionalPacControllerLabelSelector() string {","\tlabelSelector := labels.NewSelector()","\tcreatedReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{v1alpha1.KindOpenShiftPipelinesAsCode})","\tif createdReq != nil {","\t\tlabelSelector = labelSelector.Add(*createdReq)","\t}","\tcomponentReq, _ := labels.NewRequirement(v1alpha1.ComponentKey, selection.Equals, []string{additionalPACControllerComponentLabelValue})","\tif componentReq != nil {","\t\tlabelSelector = labelSelector.Add(*componentReq)","\t}","\treturn labelSelector.String()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":152,"path":"pkg/reconciler/openshift/openshiftpipelinesascode/transform.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package openshiftpipelinesascode","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\tpacSettings \"github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings\"","\troutev1 \"github.com/openshift/api/route/v1\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/openshift\"","\toccommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"","\t\"go.uber.org/zap\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","const (","\tpipelinesAsCodeCM                 = \"pipelines-as-code\"","\tadditionalPACControllerNameSuffix = \"-pac-controller\"",")","","func filterAndTransform(extension common.Extension) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tpac := comp.(*v1alpha1.OpenShiftPipelinesAsCode)","\t\t// installerSet adds it's owner as namespace's owner","\t\t// so deleting tekton addon deletes target namespace too","\t\t// to skip it we filter out namespace","\t\tpacManifest := manifest.Filter(mf.Not(mf.ByKind(\"Namespace\")))","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PacImagePrefix))","\t\timages := common.ImageRegistryDomainOverride(imagesRaw)","\t\t// Run transformers","\t\ttfs := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(openshift.OperandOpenShiftPipelineAsCode),","\t\t\tcommon.DeploymentImages(images),","\t\t\tcommon.DeploymentEnvVarKubernetesMinVersion(),","\t\t\tcommon.AddConfiguration(pac.Spec.Config),","\t\t\toccommon.ApplyCABundlesToDeployment,","\t\t\tcommon.CopyConfigMap(pipelinesAsCodeCM, pac.Spec.Settings),","\t\t\toccommon.UpdateServiceMonitorTargetNamespace(pac.Spec.TargetNamespace),","\t\t}","","\t\tallTfs := append(tfs, extension.Transformers(pac)...)","\t\tif err := common.Transform(ctx, \u0026pacManifest, pac, allTfs...); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, \u0026pacManifest, pac.Spec.GetTargetNamespace(), pac.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn \u0026pacManifest, nil","\t}","}","","func additionalControllerTransform(extension common.Extension, name string) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tpac := comp.(*v1alpha1.OpenShiftPipelinesAsCode)","\t\tadditionalPACControllerConfig := pac.Spec.PACSettings.AdditionalPACControllers[name]","","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PacImagePrefix))","\t\timages := common.ImageRegistryDomainOverride(imagesRaw)","\t\t// Run transformers","\t\ttfs := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(openshift.OperandOpenShiftPipelineAsCode),","\t\t\tcommon.DeploymentImages(images),","\t\t\tcommon.AddConfiguration(pac.Spec.Config),","\t\t\toccommon.ApplyCABundlesToDeployment,","\t\t\toccommon.UpdateServiceMonitorTargetNamespace(pac.Spec.TargetNamespace),","\t\t\tupdateAdditionControllerDeployment(additionalPACControllerConfig, name),","\t\t\tupdateAdditionControllerService(name),","\t\t\tupdateAdditionControllerConfigMap(additionalPACControllerConfig),","\t\t\tupdateAdditionControllerRoute(name),","\t\t\tupdateAdditionControllerServiceMonitor(name),","\t\t}","","\t\tallTfs := append(tfs, extension.Transformers(pac)...)","\t\tif err := common.Transform(ctx, manifest, pac, allTfs...); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\t// additional options transformer","\t\t// always execute as last transformer, so that the values in options will be final update values on the manifests","\t\tif err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, pac.Spec.GetTargetNamespace(), pac.Spec.Options); err != nil {","\t\t\treturn \u0026mf.Manifest{}, err","\t\t}","","\t\treturn manifest, nil","\t}","}","","// This returns all resources to deploy for the additional PACController","func filterAdditionalControllerManifest(manifest mf.Manifest) mf.Manifest {","\t// filter deployment","\tdeploymentManifest := manifest.Filter(mf.All(mf.ByName(\"pipelines-as-code-controller\"), mf.ByKind(\"Deployment\")))","","\t// filter service","\tserviceManifest := manifest.Filter(mf.All(mf.ByName(\"pipelines-as-code-controller\"), mf.ByKind(\"Service\")))","","\t// filter route","\trouteManifest := manifest.Filter(mf.All(mf.ByName(\"pipelines-as-code-controller\"), mf.ByKind(\"Route\")))","","\t// filter configmap","\tcmManifest := manifest.Filter(mf.All(mf.ByName(\"pipelines-as-code\"), mf.ByKind(\"ConfigMap\")))","","\t// filter serviceMonitor","\tserviceMonitorManifest := manifest.Filter(mf.All(mf.ByName(\"pipelines-as-code-controller-monitor\"), mf.ByKind(\"ServiceMonitor\")))","","\tfilteredManifest := mf.Manifest{}","\tfilteredManifest = filteredManifest.Append(cmManifest, deploymentManifest, serviceManifest, serviceMonitorManifest, routeManifest)","\treturn filteredManifest","}","","// This updates additional PACController deployment","func updateAdditionControllerDeployment(config v1alpha1.AdditionalPACControllerConfig, name string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\tu.SetName(fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix))","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\td.Spec.Selector.MatchLabels[\"app.kubernetes.io/name\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","","\t\td.Spec.Template.Labels[\"app\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\td.Spec.Template.Labels[\"app.kubernetes.io/name\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","","\t\tfor i, container := range d.Spec.Template.Spec.Containers {","\t\t\tcontainer.Name = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\t\tcontainerEnvs := d.Spec.Template.Spec.Containers[i].Env","\t\t\td.Spec.Template.Spec.Containers[i].Env = replaceEnvInDeployment(containerEnvs, config, name)","\t\t\td.Spec.Template.Spec.Containers[i] = container","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// This updates additional PACController Service","func updateAdditionControllerService(name string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Service\" {","\t\t\treturn nil","\t\t}","\t\tu.SetName(fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix))","","\t\tservice := \u0026corev1.Service{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, service)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tlabels := service.Labels","\t\tif labels == nil {","\t\t\tlabels = map[string]string{}","\t\t}","\t\tlabels[\"app\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\tlabels[\"app.kubernetes.io/name\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\tservice.SetLabels(labels)","","\t\tlabelSelector := service.Spec.Selector","\t\tif labelSelector == nil {","\t\t\tlabelSelector = map[string]string{}","\t\t}","\t\tlabelSelector[\"app.kubernetes.io/name\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\tservice.Spec.Selector = labelSelector","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(service)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","// This updates additional PACController configMap and sets settings data to configMap data","func updateAdditionControllerConfigMap(config v1alpha1.AdditionalPACControllerConfig) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\t// set the name","\t\t// set the namespace","\t\t// set the data from settings","\t\tif u.GetKind() != \"ConfigMap\" {","\t\t\treturn nil","\t\t}","","\t\tu.SetName(config.ConfigMapName)","","\t\t// apply the defaults here, we are not adding the defaults in CR","\t\tif config.Settings == nil {","\t\t\tconfig.Settings = map[string]string{}","\t\t}","","\t\tdefaultPacSettings := pacSettings.Settings{}","\t\terr := pacSettings.SyncConfig(zap.NewNop().Sugar(), \u0026defaultPacSettings, config.Settings, pacSettings.DefaultValidators())","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tconfig.Settings = v1alpha1.ConvertPacStructToConfigMap(\u0026defaultPacSettings)","","\t\tcm := \u0026corev1.ConfigMap{}","\t\terr = runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif cm.Data == nil {","\t\t\tcm.Data = map[string]string{}","\t\t}","","\t\tfor key, value := range config.Settings {","\t\t\tcm.Data[key] = value","\t\t}","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","","\t}","}","","// This updates additional PACController route","func updateAdditionControllerRoute(name string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Route\" {","\t\t\treturn nil","\t\t}","\t\tu.SetName(fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix))","","\t\troute := \u0026routev1.Route{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, route)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\troute.Spec.To.Name = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\tlabels := route.Labels","\t\tif labels == nil {","\t\t\tlabels = map[string]string{}","\t\t}","\t\tlabels[\"app\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\tlabels[\"pipelines-as-code/route\"] = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\troute.SetLabels(labels)","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(route)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}","","// This updates additional PACController ServiceMonitor","func updateAdditionControllerServiceMonitor(name string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ServiceMonitor\" {","\t\t\treturn nil","\t\t}","","\t\tu.SetName(fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix))","\t\terr := unstructured.SetNestedMap(u.Object, map[string]interface{}{","\t\t\t\"app\": fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix),","\t\t}, \"spec\", \"selector\", \"matchLabels\")","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\treturn nil","\t}","}","","// This replaces additional PACController deployment's container env","func replaceEnvInDeployment(envs []corev1.EnvVar, envInfo v1alpha1.AdditionalPACControllerConfig, name string) []corev1.EnvVar {","\tfor i, e := range envs {","\t\tif e.Name == \"PAC_CONTROLLER_CONFIGMAP\" {","\t\t\tenvs[i].Value = envInfo.ConfigMapName","\t\t}","\t\tif e.Name == \"PAC_CONTROLLER_SECRET\" {","\t\t\tenvs[i].Value = envInfo.SecretName","\t\t}","\t\tif e.Name == \"PAC_CONTROLLER_LABEL\" {","\t\t\tenvs[i].Value = fmt.Sprintf(\"%s%s\", name, additionalPACControllerNameSuffix)","\t\t}","\t}","\treturn envs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,1,1,0,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,1,1,2,2,2,0,0,0,0,2,2,2,1,1,2,2,2,2,2,1,1,0,2,2,1,1,2,2,2,2,2,2,1,1,2,2,2,2,2,1,1,0,2,2,0,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,0,2,2,2,1,1,2,2,2,2,2,1,1,0,2,1,1,0,2,2,2,2,2,1,1,0,2,2,0,0,0,0,0,2,2,2,1,1,2,2,2,2,2,1,1,0,2,2,2,1,1,2,2,2,2,2,2,1,1,0,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,1,1,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,0]},{"id":153,"path":"pkg/reconciler/openshift/openshiftpipelinesascode/update_route_in_configmap.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package openshiftpipelinesascode","","import (","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\troutev1 \"github.com/openshift/api/route/v1\"","\t\"github.com/openshift/client-go/route/clientset/versioned/scheme\"","\tv1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","const (","\tcontrollerRouteName = \"pipelines-as-code-controller\"","\tinfoConfigMapName   = \"pipelines-as-code-info\"",")","","func updateControllerRouteInConfigMap(pacManifest *mf.Manifest, targetNs string) error {","\tcontrollerRoute, err := getControllerRouteHost(pacManifest, targetNs)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to get controller route: %v\", err)","\t}","\tif controllerRoute == \"\" {","\t\treturn fmt.Errorf(\"failed to get host in route, will try again\")","\t}","\tif err := updateInfoConfigMap(controllerRoute, pacManifest, targetNs); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func getControllerRouteHost(manifest *mf.Manifest, targetNs string) (string, error) {","\tvar hostUrl string","\tfor _, r := range manifest.Filter(mf.ByKind(\"Route\")).Resources() {","\t\tr.SetNamespace(targetNs)","\t\tu, err := manifest.Client.Get(\u0026r)","\t\tif err != nil {","\t\t\treturn \"\", err","\t\t}","\t\tif u.GetName() == controllerRouteName {","\t\t\troute := \u0026routev1.Route{}","\t\t\tif err := scheme.Scheme.Convert(u, route, nil); err != nil {","\t\t\t\treturn \"\", err","\t\t\t}","\t\t\thostUrl = route.Spec.Host","\t\t}","\t}","\treturn hostUrl, nil","}","","func updateInfoConfigMap(route string, pacManifest *mf.Manifest, targetNs string) error {","\tfor _, r := range pacManifest.Filter(mf.ByKind(\"ConfigMap\")).Resources() {","\t\tif r.GetName() != infoConfigMapName {","\t\t\tcontinue","\t\t}","\t\tr.SetNamespace(targetNs)","\t\tu, err := pacManifest.Client.Get(\u0026r)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tcm := \u0026v1.ConfigMap{}","\t\terr = runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\trouteURL := fmt.Sprintf(\"https://%s\", route)","","\t\t// set controller url if not the same","\t\tif cm.Data[\"controller-url\"] == routeURL {","\t\t\treturn nil","\t\t}","\t\tcm.Data[\"controller-url\"] = routeURL","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\terr = pacManifest.Client.Update(u)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,2,1,1,2,1,1,2,0,0,2,2,2,2,2,2,1,1,2,2,2,1,1,2,0,0,2,0,0,2,2,2,1,0,2,2,2,1,1,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,0,2,0]},{"id":154,"path":"pkg/reconciler/openshift/openshiftplatform/openshiftplatform.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package openshiftplatform","","import (","\t\"github.com/tektoncd/operator/pkg/reconciler/platform\"",")","","// OpenShiftPlatform defines basic configuration for a OpenShift platform","type OpenShiftPlatform struct {","\tplatform.PlatformConfig","\tsupportedControllers platform.ControllerMap","}","","// NewOpenShiftPlatform returns an instance of OpenShiftPlatform","func NewOpenShiftPlatform(pc platform.PlatformConfig) *OpenShiftPlatform {","\tplt := OpenShiftPlatform{","\t\tsupportedControllers: openshiftControllers,","\t}","\tplt.PlatformConfig = pc","\tplt.PlatformConfig.Name = PlatformNameOpenShift","\treturn \u0026plt","}","","// AllSupportedControllers returns a platform.ControllerMap of all controllers (reconcilers) of tektoncd/operator","// supported by OpenShift","func (op *OpenShiftPlatform) AllSupportedControllers() platform.ControllerMap {","\treturn op.supportedControllers","}","","// PlatformParams return platform.PlatformConfig of a OpenShiftPlatform","func (op *OpenShiftPlatform) PlatformParams() platform.PlatformConfig {","\treturn op.PlatformConfig","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1]},{"id":155,"path":"pkg/reconciler/openshift/tektonaddon/community_tasks.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","var communityResourceURLs = []string{","\t\"https://raw.githubusercontent.com/tektoncd/catalog/master/task/jib-maven/0.5/jib-maven.yaml\",","\t\"https://raw.githubusercontent.com/tektoncd/catalog/master/task/helm-upgrade-from-source/0.3/helm-upgrade-from-source.yaml\",","\t\"https://raw.githubusercontent.com/tektoncd/catalog/master/task/helm-upgrade-from-repo/0.2/helm-upgrade-from-repo.yaml\",","\t\"https://raw.githubusercontent.com/tektoncd/catalog/master/task/trigger-jenkins-job/0.1/trigger-jenkins-job.yaml\",","\t\"https://raw.githubusercontent.com/tektoncd/catalog/master/task/pull-request/0.1/pull-request.yaml\",","\t\"https://raw.githubusercontent.com/tektoncd/catalog/master/task/kubeconfig-creator/0.1/kubeconfig-creator.yaml\",","\t\"https://raw.githubusercontent.com/tektoncd/catalog/main/task/argocd-task-sync-and-wait/0.2/argocd-task-sync-and-wait.yaml\",","}","","func (r *Reconciler) EnsureCommunityResolverTask(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error {","\tif len(r.communityResolverTaskManifest.Resources()) == 0 {","\t\treturn nil","\t}","\tmanifest := *r.communityResolverTaskManifest","\tif enable == \"true\" {","\t\tif err := r.installerSetClient.CustomSet(ctx, ta, CommunityResolverTaskInstallerSet, \u0026manifest, filterAndTransformCommunityResolverTask(), nil); err != nil {","\t\t\treturn err","\t\t}","\t} else {","\t\tif err := r.installerSetClient.CleanupCustomSet(ctx, CommunityResolverTaskInstallerSet); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func filterAndTransformCommunityResolverTask() client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tinstance := comp.(*v1alpha1.TektonAddon)","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))","\t\taddonImages := common.ImageRegistryDomainOverride(imagesRaw)","","\t\textra := []mf.Transformer{","\t\t\tinjectLabel(labelProviderType, providerTypeCommunity, overwrite, \"Task\"),","\t\t\tcommon.TaskImages(ctx, addonImages),","\t\t}","\t\tif err := common.Transform(ctx, manifest, instance, extra...); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn manifest, nil","\t}","}","","func appendCommunityResolverTasks(manifest *mf.Manifest) error {","\turls := strings.Join(communityResourceURLs, \",\")","\tm, err := mf.ManifestFrom(mf.Path(urls))","\tif err != nil {","\t\treturn err","\t}","\t*manifest = manifest.Append(m)","\treturn nil","}","","func fetchCommunityResolverTasks(manifest *mf.Manifest) error {","\tif err := appendCommunityResolverTasks(manifest); err != nil {","\t\treturn err","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0]},{"id":156,"path":"pkg/reconciler/openshift/tektonaddon/consolecli.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\troutev1 \"github.com/openshift/api/route/v1\"","\t\"github.com/openshift/client-go/route/clientset/versioned/scheme\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"knative.dev/pkg/logging\"",")","","func (r *Reconciler) EnsureConsoleCLI(ctx context.Context, ta *v1alpha1.TektonAddon) error {","\ttknservecliManifest := r.openShiftConsoleManifest","\tif err := common.Transform(ctx, tknservecliManifest, ta); err != nil {","\t\treturn err","\t}","\trouteHost, err := getRouteHost(tknservecliManifest)","\tif err != nil {","\t\treturn err","\t}","\tmanifest := *r.consoleCLIManifest","\tif err := consoleCLITransform(ctx, \u0026manifest, routeHost); err != nil {","\t\treturn err","\t}","\tif err := r.installerSetClient.CustomSet(ctx, ta, ConsoleCLIInstallerSet, \u0026manifest, filterAndTransformOCPResources(), nil); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func getRouteHost(manifest *mf.Manifest) (string, error) {","\tvar hostUrl string","\tfor _, r := range manifest.Filter(mf.ByKind(\"Route\")).Resources() {","\t\tu, err := manifest.Client.Get(\u0026r)","\t\tif err != nil {","\t\t\treturn \"\", err","\t\t}","\t\tif u.GetName() == \"tkn-cli-serve\" {","\t\t\troute := \u0026routev1.Route{}","\t\t\tif err := scheme.Scheme.Convert(u, route, nil); err != nil {","\t\t\t\treturn \"\", err","\t\t\t}","\t\t\thostUrl = route.Spec.Host","\t\t}","\t}","\treturn hostUrl, nil","}","","func consoleCLITransform(ctx context.Context, manifest *mf.Manifest, baseURL string) error {","\tif baseURL == \"\" {","\t\treturn fmt.Errorf(\"route url should not be empty\")","\t}","\tlogger := logging.FromContext(ctx)","\tlogger.Debug(\"Transforming manifest\")","","\ttransformers := []mf.Transformer{","\t\treplaceURLCCD(baseURL),","\t}","","\ttransformManifest, err := manifest.Transform(transformers...)","\tif err != nil {","\t\treturn err","\t}","","\t*manifest = transformManifest","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0]},{"id":157,"path":"pkg/reconciler/openshift/tektonaddon/controller.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","\t\"os\"","","\t\"github.com/go-logr/zapr\"","\tmfc \"github.com/manifestival/client-go-client\"","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonAddoninformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonaddon\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\ttektonTriggerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektontrigger\"","\ttektonAddonreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonaddon\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"go.uber.org/zap\"","\tapiextensionsclient \"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset\"","\t\"k8s.io/client-go/tools/cache\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tversionKey = \"VERSION\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn NewExtendedController(common.NoExtension)(ctx, cmw)","}","","// NewExtendedController returns a controller extended to a specific platform","func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating client from injected config\", zap.Error(err))","\t\t}","\t\tcrdClient, err := apiextensionsclient.NewForConfig(injection.GetConfig(ctx))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating client from injected config\", zap.Error(err))","\t\t}","\t\tmflogger := zapr.NewLogger(logger.Named(\"manifestival\").Desugar())","\t\tmanifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating initial manifest\", zap.Error(err))","\t\t}","","\t\tversion := os.Getenv(versionKey)","\t\tif version == \"\" {","\t\t\tlogger.Fatal(\"Failed to find version from env\")","\t\t}","","\t\ttisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","\t\tmetrics, _ := NewRecorder()","","\t\tresolverTaskManifest := \u0026mf.Manifest{}","\t\tif err := applyAddons(resolverTaskManifest, \"06-ecosystem/tasks\"); err != nil {","\t\t\tlogger.Fatalf(\"failed to read namespaced tasks from kodata: %v\", err)","\t\t}","","\t\tresolverStepActionManifest := \u0026mf.Manifest{}","\t\tif err := applyAddons(resolverStepActionManifest, \"06-ecosystem/stepactions\"); err != nil {","\t\t\tlogger.Fatalf(\"failed to read namespaced stepactions from kodata: %v\", err)","\t\t}","","\t\ttriggersResourcesManifest := \u0026mf.Manifest{}","\t\tif err := applyAddons(triggersResourcesManifest, \"01-clustertriggerbindings\"); err != nil {","\t\t\tlogger.Fatalf(\"failed to read trigger Resources from kodata: %v\", err)","\t\t}","","\t\tpipelineTemplateManifest := \u0026mf.Manifest{}","\t\tif err := applyAddons(pipelineTemplateManifest, \"02-pipelines\"); err != nil {","\t\t\tlogger.Fatalf(\"failed to read pipeline template from kodata: %v\", err)","\t\t}","\t\tif err := addPipelineTemplates(pipelineTemplateManifest); err != nil {","\t\t\tlogger.Fatalf(\"failed to add pipeline templates: %v\", err)","\t\t}","","\t\topenShiftConsoleManifest := \u0026mf.Manifest{Client: mfclient}","\t\tif err := applyAddons(openShiftConsoleManifest, \"04-tkncliserve\"); err != nil {","\t\t\tlogger.Fatalf(\"failed to read openshift console resources from kodata: %v\", err)","\t\t}","\t\tif err := getOptionalAddons(openShiftConsoleManifest); err != nil {","\t\t\tlogger.Fatalf(\"failed to read optional addon resources from kodata: %v\", err)","\t\t}","","\t\tconsoleCLIManifest := \u0026mf.Manifest{}","\t\tif err := applyAddons(consoleCLIManifest, \"03-consolecli\"); err != nil {","\t\t\tlogger.Fatalf(\"failed to read console cli from kodata: %v\", err)","\t\t}","","\t\tcommunityResolverTaskManifest := \u0026mf.Manifest{}","\t\tif err := fetchCommunityResolverTasks(communityResolverTaskManifest); err != nil {","\t\t\t// if unable to fetch community task, don't fail","\t\t\tlogger.Errorf(\"failed to read community resolver task: %v\", err)","\t\t}","","\t\tc := \u0026Reconciler{","\t\t\tcrdClientSet:                  crdClient,","\t\t\tinstallerSetClient:            client.NewInstallerSetClient(tisClient, version, \"addon\", v1alpha1.KindTektonAddon, metrics),","\t\t\toperatorClientSet:             operatorclient.Get(ctx),","\t\t\textension:                     generator(ctx),","\t\t\tpipelineInformer:              tektonPipelineinformer.Get(ctx),","\t\t\ttriggerInformer:               tektonTriggerinformer.Get(ctx),","\t\t\tmanifest:                      manifest,","\t\t\toperatorVersion:               version,","\t\t\tresolverTaskManifest:          resolverTaskManifest,","\t\t\tresolverStepActionManifest:    resolverStepActionManifest,","\t\t\ttriggersResourcesManifest:     triggersResourcesManifest,","\t\t\tpipelineTemplateManifest:      pipelineTemplateManifest,","\t\t\topenShiftConsoleManifest:      openShiftConsoleManifest,","\t\t\tconsoleCLIManifest:            consoleCLIManifest,","\t\t\tcommunityResolverTaskManifest: communityResolverTaskManifest,","\t\t}","\t\timpl := tektonAddonreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for TektonAddon\")","","\t\tif _, err := tektonAddoninformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonAddon informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonAddon{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0]},{"id":158,"path":"pkg/reconciler/openshift/tektonaddon/metrics.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import \"go.uber.org/zap\"","","type Recorder struct {","}","","func NewRecorder() (*Recorder, error) {","\treturn \u0026Recorder{}, nil","}","","func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {","\t// TODO","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0]},{"id":159,"path":"pkg/reconciler/openshift/tektonaddon/openshift_console.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","\t\"os\"","\t\"path/filepath\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","func (r *Reconciler) EnsureOpenShiftConsoleResources(ctx context.Context, ta *v1alpha1.TektonAddon) (error, bool) {","\tfilteredManifest := *r.openShiftConsoleManifest","\tconsoleYamlSampleExist, err := r.checkCRDExist(ctx, \"consoleyamlsamples.console.openshift.io\")","\tif err != nil {","\t\treturn err, true","\t}","\tif !consoleYamlSampleExist {","\t\tfilteredManifest = filteredManifest.Filter(mf.Not(mf.ByKind(\"ConsoleYAMLSample\")))","\t}","","\tconsoleQuickStartExist, err := r.checkCRDExist(ctx, \"consolequickstarts.console.openshift.io\")","\tif err != nil {","\t\treturn err, true","\t}","\tif !consoleQuickStartExist {","\t\tfilteredManifest = filteredManifest.Filter(mf.Not(mf.ByKind(\"ConsoleQuickStart\")))","\t}","","\tconsoleCLIDownloadExist, err := r.checkCRDExist(ctx, \"consoleclidownloads.console.openshift.io\")","\tif err != nil {","\t\treturn err, true","\t}","\tif !consoleCLIDownloadExist {","\t\tfilteredManifest = filteredManifest.Filter(mf.Not(mf.Any(mf.ByKind(\"Deployment\"), mf.ByKind(\"Service\"), mf.ByKind(\"Route\"))))","\t}","","\tif len(filteredManifest.Resources()) == 0 {","\t\treturn nil, consoleCLIDownloadExist","\t}","\tif err := r.installerSetClient.CustomSet(ctx, ta, OpenShiftConsoleInstallerSet, \u0026filteredManifest, filterAndTransformOCPResources(), nil); err != nil {","\t\treturn err, consoleCLIDownloadExist","\t}","\treturn nil, consoleCLIDownloadExist","}","","func (r *Reconciler) checkCRDExist(ctx context.Context, crdName string) (bool, error) {","\t_, err := r.crdClientSet.ApiextensionsV1().CustomResourceDefinitions().Get(ctx, crdName, v1.GetOptions{})","\tif err != nil {","\t\tif errors.IsNotFound(err) {","\t\t\treturn false, nil","\t\t}","\t\treturn true, err","\t}","\treturn true, nil","}","","func filterAndTransformOCPResources() client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\taddon := comp.(*v1alpha1.TektonAddon)","\t\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))","\t\timages := common.ImageRegistryDomainOverride(imagesRaw)","\t\ttfs := []mf.Transformer{","\t\t\tcommon.DeploymentImages(images),","\t\t\tcommon.AddConfiguration(addon.Spec.Config),","\t\t}","\t\tif err := transformers(ctx, manifest, addon, tfs...); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn manifest, nil","\t}","}","","func getOptionalAddons(manifest *mf.Manifest) error {","\tkoDataDir := os.Getenv(common.KoEnvKey)","","\toptionalLocation := filepath.Join(koDataDir, \"tekton-addon\", \"optional\", \"samples\")","\tif err := common.AppendManifest(manifest, optionalLocation); err != nil {","\t\treturn err","\t}","","\toptionalLocation = filepath.Join(koDataDir, \"tekton-addon\", \"optional\", \"quickstarts\")","\treturn common.AppendManifest(manifest, optionalLocation)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,0]},{"id":160,"path":"pkg/reconciler/openshift/tektonaddon/pipelinetemplate.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","\t\"os\"","\t\"path/filepath\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\ttektonaddon \"github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/pipelinetemplates\"",")","","func (r *Reconciler) EnsurePipelineTemplates(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error {","\tmanifest := *r.pipelineTemplateManifest","\tif enable == \"true\" {","\t\tif err := r.installerSetClient.CustomSet(ctx, ta, PipelinesTemplateInstallerSet, \u0026manifest, filterAndTransformCommon(), nil); err != nil {","\t\t\treturn err","\t\t}","\t} else {","\t\tif err := r.installerSetClient.CleanupCustomSet(ctx, PipelinesTemplateInstallerSet); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func addPipelineTemplates(manifest *mf.Manifest) error {","\tkoDataDir := os.Getenv(common.KoEnvKey)","\taddonLocation := filepath.Join(koDataDir, \"tekton-addon\", \"tekton-pipeline-template\")","\treturn tektonaddon.GeneratePipelineTemplates(addonLocation, manifest)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1]},{"id":161,"path":"pkg/reconciler/openshift/tektonaddon/pipelinetemplates/pipelinetemplates.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"path\"","\t\"runtime\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"",")","","type generateDeployTask func(map[string]interface{}) map[string]interface{}","type taskGenerator interface {","\tgenerate(pipeline unstructured.Unstructured, usingPipelineResource bool) (unstructured.Unstructured, error)","}","","type pipeline struct {","\tenvironment string","\tnameSuffix  string","\tgenerateDeployTask","}","","type RuntimeSpec struct {","\tRuntime string","\tVersion string","\tDefault string","}","","const (","\tLabelPipelineEnvironmentType = \"pipeline.openshift.io/type\"","\tLabelPipelineStrategy        = \"pipeline.openshift.io/strategy\"","\tLabelPipelineRuntime         = \"pipeline.openshift.io/runtime\"","\tAnnotationPreserveNS         = \"operator.tekton.dev/preserve-namespace\"",")","","var (","\tRuntimes = map[string]RuntimeSpec{","\t\t\"s2i-dotnet\": {Runtime: \"dotnet\", Version: \"$(params.VERSION)\", Default: \"3.1-ubi8\"},","\t\t\"s2i-go\":     {Runtime: \"golang\", Version: \"$(params.VERSION)\", Default: \"1.14.7-ubi8\"},","\t\t\"s2i-java\":   {Runtime: \"java\", Version: \"$(params.VERSION)\", Default: \"openjdk-11-ubi8\"},","\t\t\"s2i-nodejs\": {Runtime: \"nodejs\", Version: \"$(params.VERSION)\", Default: \"14-ubi8\"},","\t\t\"s2i-perl\":   {Runtime: \"perl\", Version: \"$(params.VERSION)\", Default: \"5.30-ubi8\"},","\t\t\"s2i-php\":    {Runtime: \"php\", Version: \"$(params.VERSION)\", Default: \"7.4-ubi8\"},","\t\t\"s2i-python\": {Runtime: \"python\", Version: \"$(params.VERSION)\", Default: \"3.8-ubi8\"},","\t\t\"s2i-ruby\":   {Runtime: \"ruby\", Version: \"$(params.VERSION)\", Default: \"2.7-ubi8\"},","\t\t\"buildah\":    {},","\t}",")","","func GeneratePipelineTemplates(templatePath string, manifest *mf.Manifest) error {","\tvar pipelines []unstructured.Unstructured","\tusingPipelineResource := true","","\tworkspacedTemplate, err := mf.NewManifest(path.Join(templatePath, \"pipeline_using_workspace.yaml\"))","\tif err != nil {","\t\treturn err","\t}","","\tworkspacedTaskGenerators := []taskGenerator{","\t\t\u0026pipeline{environment: \"openshift\", nameSuffix: \"\", generateDeployTask: openshiftDeployTask},","\t\t\u0026pipeline{environment: \"kubernetes\", nameSuffix: \"-deployment\", generateDeployTask: kubernetesDeployTask},","\t}","","\t// install knative tasks only where knative is available","\tswitch runtime.GOARCH {","\tcase \"amd64\", \"ppc64le\", \"s390x\":","\t\tworkspacedTaskGenerators = append(workspacedTaskGenerators,","\t\t\t\u0026pipeline{environment: \"knative\", nameSuffix: \"-knative\", generateDeployTask: knativeDeployTask},","\t\t)","\t}","","\twps, err := generateBasePipeline(workspacedTemplate, workspacedTaskGenerators, !usingPipelineResource)","\tif err != nil {","\t\treturn err","\t}","\tpipelines = append(pipelines, wps...)","","\tgeneratedPipelines, err := mf.ManifestFrom(mf.Slice(pipelines))","\tif err != nil {","\t\treturn err","\t}","","\t*manifest = manifest.Append(generatedPipelines)","\treturn nil","}","","func (p *pipeline) generate(pipeline unstructured.Unstructured, usingPipelineResource bool) (unstructured.Unstructured, error) {","\tnewTempRes := unstructured.Unstructured{}","\tpipeline.DeepCopyInto(\u0026newTempRes)","\tlabels := newTempRes.GetLabels()","\tlabels[LabelPipelineEnvironmentType] = p.environment","\tnewTempRes.SetLabels(labels)","\tupdatedName := newTempRes.GetName()","\tupdatedName += p.nameSuffix","\ttaskDeploy, found, err := unstructured.NestedFieldNoCopy(newTempRes.Object, \"spec\", \"tasks\")","\tif !found || err != nil {","\t\treturn unstructured.Unstructured{}, err","\t}","","\tvar index = 2","\tif usingPipelineResource {","\t\tindex = 1","\t\tupdatedName += \"-pr\"","\t}","\tnewTempRes.SetName(updatedName)","","\tp.generateDeployTask(taskDeploy.([]interface{})[index].(map[string]interface{}))","\treturn newTempRes, nil","}","","func openshiftDeployTask(deployTask map[string]interface{}) map[string]interface{} {","\tdeployTask[\"taskRef\"] = getTaskRef(\"openshift-client\")","\tdeployTask[\"runAfter\"] = []interface{}{\"build\"}","\tdeployTask[\"params\"] = []interface{}{","\t\tmap[string]interface{}{\"name\": \"SCRIPT\", \"value\": \"oc rollout status dc/$(params.APP_NAME)\"},","\t}","\treturn deployTask","}","","func kubernetesDeployTask(deployTask map[string]interface{}) map[string]interface{} {","\tdeployTask[\"taskRef\"] = getTaskRef(\"openshift-client\")","\tdeployTask[\"runAfter\"] = []interface{}{\"build\"}","\tdeployTask[\"params\"] = []interface{}{","\t\tmap[string]interface{}{\"name\": \"SCRIPT\", \"value\": \"oc rollout status deploy/$(params.APP_NAME)\"},","\t}","\treturn deployTask","}","","func knativeDeployTask(deployTask map[string]interface{}) map[string]interface{} {","\tdeployTask[\"name\"] = \"kn-service-apply\"","\tdeployTask[\"taskRef\"] = getTaskRef(\"kn\")","\tdeployTask[\"runAfter\"] = []interface{}{\"build\"}","\tdeployTask[\"params\"] = []interface{}{","\t\tmap[string]interface{}{\"name\": \"ARGS\", \"value\": []interface{}{\"service\", \"apply\", \"$(params.APP_NAME)\", \"--image=$(params.IMAGE_NAME)\"}},","\t}","\treturn deployTask","}","","func generateBasePipeline(template mf.Manifest, taskGenerators []taskGenerator, usingPipelineResource bool) ([]unstructured.Unstructured, error) {","\tvar pipelines []unstructured.Unstructured","","\tfor name, spec := range Runtimes {","\t\tcontextParamName := \"CONTEXT\"","\t\tnewTempRes := unstructured.Unstructured{}","\t\ttemplate.Resources()[0].DeepCopyInto(\u0026newTempRes)","\t\tlabels := map[string]string{}","\t\tannotations := map[string]string{}","\t\tif name == \"buildah\" {","\t\t\tlabels[LabelPipelineStrategy] = \"docker\"","\t\t} else {","\t\t\tlabels[LabelPipelineRuntime] = spec.Runtime","\t\t}","","\t\tannotations[AnnotationPreserveNS] = \"true\"","\t\tnewTempRes.SetAnnotations(annotations)","\t\tnewTempRes.SetLabels(labels)","\t\tnewTempRes.SetName(name)","\t\tpipelineParams, found, err := unstructured.NestedFieldNoCopy(newTempRes.Object, \"spec\", \"params\")","\t\tif !found || err != nil {","\t\t\treturn nil, err","\t\t}","","\t\ttasks, found, err := unstructured.NestedFieldNoCopy(newTempRes.Object, \"spec\", \"tasks\")","\t\tif !found || err != nil {","\t\t\treturn nil, err","\t\t}","","\t\ttaskName := name","\t\tvar index = 1","","\t\ttaskBuild := tasks.([]interface{})[index].(map[string]interface{})","\t\ttaskBuild[\"taskRef\"] = getTaskRef(taskName)","\t\ttaskParams, found, err := unstructured.NestedFieldNoCopy(taskBuild, \"params\")","\t\tif !found || err != nil {","\t\t\treturn nil, err","\t\t}","","\t\ttaskParams = append(taskParams.([]interface{}), map[string]interface{}{\"name\": contextParamName, \"value\": \"$(params.PATH_CONTEXT)\"})","","\t\tif spec.Version != \"\" {","\t\t\ttaskParams = append(taskParams.([]interface{}), map[string]interface{}{\"name\": \"VERSION\", \"value\": spec.Version})","\t\t\tpipelineParams = append(pipelineParams.([]interface{}), map[string]interface{}{\"name\": \"VERSION\", \"type\": \"string\", \"default\": spec.Default})","\t\t}","","\t\tif err := unstructured.SetNestedField(newTempRes.Object, pipelineParams, \"spec\", \"params\"); err != nil {","\t\t\treturn nil, err","\t\t}","","\t\tif err := unstructured.SetNestedField(taskBuild, taskParams, \"params\"); err != nil {","\t\t\treturn nil, nil","\t\t}","","\t\t//adding the deploy task","\t\tfor _, tg := range taskGenerators {","\t\t\tp, err := tg.generate(newTempRes, usingPipelineResource)","\t\t\tif err != nil {","\t\t\t\treturn nil, err","\t\t\t}","\t\t\tpipelines = append(pipelines, p)","\t\t}","\t}","\treturn pipelines, nil","}","","func getTaskRef(taskName string) map[string]interface{} {","\treturn map[string]interface{}{\"params\": []interface{}{","\t\tmap[string]interface{}{\"name\": \"kind\", \"value\": \"task\"},","\t\tmap[string]interface{}{\"name\": \"name\", \"value\": taskName},","\t\tmap[string]interface{}{\"name\": \"namespace\", \"value\": \"openshift-pipelines\"},","\t},","\t\t\"resolver\": \"cluster\",","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,1,1,2,2,2,2,1,1,0,2,2,0,0,2,2,2,2,2,2,2,2,2,2,1,1,0,2,2,1,1,1,2,2,2,2,0,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,1,0,2,2,1,1,0,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,0,2,1,1,0,2,1,1,0,0,2,2,2,1,1,2,0,0,2,0,0,2,2,2,2,2,2,2,2,2]},{"id":162,"path":"pkg/reconciler/openshift/tektonaddon/resolver_task.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","func (r *Reconciler) EnsureResolverTask(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error {","\tmanifest := *r.resolverTaskManifest","\treturn r.ensureCustomSet(ctx, enable, ResolverTaskInstallerSet, ta, manifest, r.getTransformer(ctx, KindTask, false))","}","","func (r *Reconciler) EnsureResolverStepAction(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error {","\tmanifest := *r.resolverStepActionManifest","\treturn r.ensureCustomSet(ctx, enable, ResolverStepActionInstallerSet, ta, manifest, r.getTransformer(ctx, KindStepAction, false))","}","","func (r *Reconciler) getTransformer(ctx context.Context, kind string, isVersioned bool) []mf.Transformer {","\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))","\taddonImages := common.ImageRegistryDomainOverride(imagesRaw)","\tvar (","\t\tmfTransformer, mfVersioned mf.Transformer","\t)","\tswitch kind {","\tcase KindTask:","\t\tmfTransformer = common.TaskImages(ctx, addonImages)","\tcase KindStepAction:","\t\tmfTransformer = common.StepActionImages(ctx, addonImages)","\t}","\tif isVersioned {","\t\tmfVersioned = setVersionedNames(r.operatorVersion)","\t}","\treturn []mf.Transformer{","\t\tinjectLabel(labelProviderType, providerTypeRedHat, overwrite, kind),","\t\tmfTransformer,","\t\tmfVersioned,","\t}","}","","func (r *Reconciler) ensureCustomSet(ctx context.Context, enable, installerSetName string, ta *v1alpha1.TektonAddon,","\tmanifest mf.Manifest, tfs []mf.Transformer) error {","\tif enable == \"true\" {","\t\tif err := r.installerSetClient.CustomSet(ctx, ta, installerSetName, \u0026manifest, filterAndTransformResolverTask(tfs), nil); err != nil {","\t\t\treturn err","\t\t}","\t} else {","\t\tif err := r.installerSetClient.CleanupCustomSet(ctx, installerSetName); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func filterAndTransformResolverTask(tfs []mf.Transformer) client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\taddon := comp.(*v1alpha1.TektonAddon)","\t\tif err := transformers(ctx, manifest, addon, tfs...); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0]},{"id":163,"path":"pkg/reconciler/openshift/tektonaddon/resolver_task_versioned.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"",")","","func (r *Reconciler) EnsureVersionedResolverTask(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error {","\tmanifest := *r.resolverTaskManifest","\treturn r.ensureVersionedCustomSet(ctx, enable, VersionedResolverTaskInstallerSet, installerSetNameForResolverTasks, ta, manifest, r.getTransformer(ctx, KindTask, true))","}","","func (r *Reconciler) EnsureVersionedResolverStepAction(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error {","\tmanifest := *r.resolverStepActionManifest","\treturn r.ensureVersionedCustomSet(ctx, enable, VersionedResolverStepActionInstallerSet, installerSetNameForResolverStepAction, ta, manifest, r.getTransformer(ctx, KindStepAction, true))","}","","func (r *Reconciler) ensureVersionedCustomSet(ctx context.Context, enable, installerSetType, installerSetName string, ta *v1alpha1.TektonAddon,","\tmanifest mf.Manifest, tfs []mf.Transformer) error {","\tif enable == \"true\" {","\t\tif err := r.installerSetClient.VersionedTaskSet(ctx, ta, \u0026manifest, filterAndTransformResolverTask(tfs),","\t\t\tinstallerSetType, installerSetName); err != nil {","\t\t\treturn err","\t\t}","\t} else {","\t\tif err := r.installerSetClient.CleanupCustomSet(ctx, installerSetType); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":164,"path":"pkg/reconciler/openshift/tektonaddon/tektonaddon.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","\t\"runtime\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tinformer \"github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1\"","\ttektonaddonreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonaddon\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\tapiextensionsclient \"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// Reconciler implements controller.Reconciler for TektonAddon resources.","type Reconciler struct {","\t// installer Set client to do CRUD operations for components","\tinstallerSetClient *client.InstallerSetClient","\t// crdClientSet allows us to talk to the k8s for core APIs","\tcrdClientSet                  *apiextensionsclient.Clientset","\tmanifest                      mf.Manifest","\toperatorClientSet             clientset.Interface","\textension                     common.Extension","\tpipelineInformer              informer.TektonPipelineInformer","\ttriggerInformer               informer.TektonTriggerInformer","\toperatorVersion               string","\tresolverTaskManifest          *mf.Manifest","\tresolverStepActionManifest    *mf.Manifest","\ttriggersResourcesManifest     *mf.Manifest","\tpipelineTemplateManifest      *mf.Manifest","\topenShiftConsoleManifest      *mf.Manifest","\tconsoleCLIManifest            *mf.Manifest","\tcommunityResolverTaskManifest *mf.Manifest","}","","const (","\tretain int = iota","\toverwrite","","\tlabelProviderType                     = \"operator.tekton.dev/provider-type\"","\tproviderTypeRedHat                    = \"redhat\"","\tinstallerSetNameForResolverTasks      = \"addon-versioned-resolvertasks\"","\tinstallerSetNameForResolverStepAction = \"addon-versioned-resolverstepactions\"","\tproviderTypeCommunity                 = \"community\"",")","","// Check that our Reconciler implements controller.Reconciler","var _ tektonaddonreconciler.Interface = (*Reconciler)(nil)","var _ tektonaddonreconciler.Finalizer = (*Reconciler)(nil)","","// FinalizeKind removes all resources after deletion of a TektonTriggers.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonAddon) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","\tif err := r.installerSetClient.CleanupAllCustomSet(ctx); err != nil {","\t\tlogger.Errorf(\"failed to cleanup custom set: %v\", err)","\t\treturn err","\t}","\treturn nil","}","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, ta *v1alpha1.TektonAddon) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","\tta.Status.InitializeConditions()","\tta.Status.SetVersion(r.operatorVersion)","","\tif ta.GetName() != v1alpha1.AddonResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.AddonResourceName,","\t\t\tta.GetName(),","\t\t)","\t\tlogger.Error(msg)","\t\tta.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// Pass the object through defaulting","\tta.SetDefaults(ctx)","","\t// Make sure TektonPipeline \u0026 TektonTrigger is installed before proceeding with","\t// TektonAddons","","\tif _, err := common.PipelineReady(r.pipelineInformer); err != nil {","\t\tif err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\tta.Status.MarkDependencyInstalling(\"tekton-pipelines is still installing\")","\t\t\t// wait for pipeline status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\t// (tektonpipeline.operator.tekton.dev instance not available yet)","\t\tta.Status.MarkDependencyMissing(\"tekton-pipelines does not exist\")","\t\treturn err","\t}","","\tif _, err := common.TriggerReady(r.triggerInformer); err != nil {","\t\tif err.Error() == common.TriggerNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR {","\t\t\tta.Status.MarkDependencyInstalling(\"tekton-triggers is still installing\")","\t\t\t// wait for trigger status to change","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\t// (tektontrigger.operator.tekton.dev instance not available yet)","\t\tta.Status.MarkDependencyMissing(\"tekton-triggers does not exist\")","\t\treturn err","\t}","","\tta.Status.MarkDependenciesInstalled()","","\t// validate the params","\tptVal, _ := findValue(ta.Spec.Params, v1alpha1.PipelineTemplatesParam)","\trtVal, _ := findValue(ta.Spec.Params, v1alpha1.ResolverTasks)","\trsaVal, _ := findValue(ta.Spec.Params, v1alpha1.ResolverStepActions)","\tctVal, _ := findValue(ta.Spec.Params, v1alpha1.CommunityResolverTasks)","","\tif ptVal == \"true\" \u0026\u0026 rtVal == \"false\" {","\t\tta.Status.MarkNotReady(\"pipelineTemplates cannot be true if ResolverTask is false\")","\t\treturn nil","\t}","","\tif err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil {","\t\treturn err","\t}","","\tif err := r.extension.PreReconcile(ctx, ta); err != nil {","\t\tta.Status.MarkPreReconcilerFailed(err.Error())","\t\treturn err","\t}","","\tta.Status.MarkPreReconcilerComplete()","","\t// this to check if all sets are in ready set","\tready := true","\tvar errorMsg string","","\tif err := r.EnsureResolverTask(ctx, rtVal, ta); err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"namespaced tasks not yet ready: %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\tif err := r.EnsureVersionedResolverTask(ctx, rtVal, ta); err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"versioned namespaced tasks not yet ready:  %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\tif err := r.EnsureResolverStepAction(ctx, rsaVal, ta); err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"namespaced stepactions not yet ready: %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\tif err := r.EnsureVersionedResolverStepAction(ctx, rsaVal, ta); err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"versioned namespaced stepactions not yet ready:  %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\tif err := r.EnsurePipelineTemplates(ctx, ptVal, ta); err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"pipelines templates not yet ready:  %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\tif err := r.EnsureTriggersResources(ctx, ta); err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"triggers resources not yet ready:  %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\terr, consoleCLIDownloadExist := r.EnsureOpenShiftConsoleResources(ctx, ta)","\tif err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"openshift console resources not yet ready:  %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\tif consoleCLIDownloadExist {","\t\tif err := r.EnsureConsoleCLI(ctx, ta); err != nil {","\t\t\tready = false","\t\t\terrorMsg = fmt.Sprintf(\"console cli not yet ready:  %v\", err)","\t\t\tlogger.Error(errorMsg)","\t\t}","\t}","","\tif err := r.EnsureCommunityResolverTask(ctx, ctVal, ta); err != nil {","\t\tready = false","\t\terrorMsg = fmt.Sprintf(\"community tasks not yet ready:  %v\", err)","\t\tlogger.Error(errorMsg)","\t}","","\tif !ready {","\t\tta.Status.MarkInstallerSetNotReady(errorMsg)","\t\treturn nil","\t}","","\tta.Status.MarkInstallerSetReady()","","\tif err := r.extension.PostReconcile(ctx, ta); err != nil {","\t\tta.Status.MarkPostReconcilerFailed(err.Error())","\t\treturn err","\t}","","\tta.Status.MarkPostReconcilerComplete()","\treturn nil","}","","func applyAddons(manifest *mf.Manifest, subpath string) error {","\tkoDataDir := os.Getenv(common.KoEnvKey)","\taddonLocation := filepath.Join(koDataDir, \"tekton-addon\", \"addons\", subpath)","\taddons, err := mf.ManifestFrom(mf.Recursive(addonLocation))","\tif err != nil {","\t\treturn err","\t}","\t// install knative addons only where knative is available","\tswitch runtime.GOARCH {","\tcase \"amd64\", \"ppc64le\", \"s390x\":","\tdefault:","\t\tversion := common.TargetVersion((*v1alpha1.TektonPipeline)(nil))","\t\tversion_formated := strings.Replace(version, \".\", \"-\", -1)","\t\taddons = addons.Filter(","\t\t\tmf.Not(mf.Any(","\t\t\t\tmf.ByName(\"kn\"),","\t\t\t\tmf.ByName(\"kn-v\"+version_formated),","\t\t\t\tmf.ByName(\"kn-apply\"),","\t\t\t\tmf.ByName(\"kn-apply-v\"+version_formated),","\t\t\t)))","\t}","\t*manifest = manifest.Append(addons)","\treturn nil","}","","func findValue(params []v1alpha1.Param, name string) (string, bool) {","\tfor _, p := range params {","\t\tif p.Name == name {","\t\t\treturn p.Value, true","\t\t}","\t}","\treturn \"\", false","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,0,1,0]},{"id":165,"path":"pkg/reconciler/openshift/tektonaddon/transform.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/openshift\"",")","","func transformers(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent, addnTfs ...mf.Transformer) error {","\tinstance := comp.(*v1alpha1.TektonAddon)","","\timagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))","\taddonImages := common.ImageRegistryDomainOverride(imagesRaw)","","\taddonTfs := []mf.Transformer{","\t\t// using common.InjectOperandNameLabelPreserveExisting instead of common.InjectLabelOverwriteExisting","\t\t// to highlight that TektonAddon is a basket of various operands(components)","\t\t// note: using common.InjectLabelOverwriteExisting here  doesnot affect the ability to","\t\t// use InjectOperandNameLabelPreserveExisting or InjectLabelOverwriteExisting again in the transformer chain","\t\t// However, it is recomended to use InjectOperandNameLabelPreserveExisting here (in Addons) as we cannot be sure","\t\t// about order of future addition of transformers in this reconciler or in sub functions which take care of various addons","\t\tcommon.InjectOperandNameLabelPreserveExisting(openshift.OperandOpenShiftPipelinesAddons),","\t\tcommon.TaskImages(ctx, addonImages),","\t}","\taddonTfs = append(addonTfs, addnTfs...)","\treturn common.Transform(ctx, manifest, instance, addonTfs...)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":166,"path":"pkg/reconciler/openshift/tektonaddon/transformer.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"fmt\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\tconsole \"github.com/openshift/api/console/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","// injectLabel adds label key:value to a resource","// overwritePolicy (Retain/Overwrite) decides whehther to overwrite an already existing label","// []kinds specify the Kinds on which the label should be applied","// if len(kinds) = 0, label will be apllied to all/any resources irrespective of its Kind","func injectLabel(key, value string, overwritePolicy int, kinds ...string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tkind := u.GetKind()","\t\tif len(kinds) != 0 \u0026\u0026 !itemInSlice(kind, kinds) {","\t\t\treturn nil","\t\t}","\t\tlabels, found, err := unstructured.NestedStringMap(u.Object, \"metadata\", \"labels\")","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"could not find labels set, %q\", err)","\t\t}","\t\tif overwritePolicy == retain \u0026\u0026 found {","\t\t\tif _, ok := labels[key]; ok {","\t\t\t\treturn nil","\t\t\t}","\t\t}","\t\tif !found {","\t\t\tlabels = map[string]string{}","\t\t}","\t\tlabels[key] = value","\t\terr = unstructured.SetNestedStringMap(u.Object, labels, \"metadata\", \"labels\")","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"error updating labels for %s:%s, %s\", kind, u.GetName(), err)","\t\t}","\t\treturn nil","\t}","}","","func itemInSlice(item string, items []string) bool {","\tfor _, v := range items {","\t\tif v == item {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","func getlinks(baseURL string) []console.CLIDownloadLink {","\tplatformURLs := []struct {","\t\tplatform string","\t\ttknURL   string","\t}{","\t\t{\"Linux x86_64\", \"tkn/tkn-linux-amd64.tar.gz\"},","\t\t{\"Linux ARM 64\", \"tkn/tkn-linux-arm64.tar.gz\"},","\t\t{\"IBM Power\", \"tkn/tkn-linux-ppc64le.tar.gz\"},","\t\t{\"IBM Z\", \"tkn/tkn-linux-s390x.tar.gz\"},","\t\t{\"Mac x86_64\", \"tkn/tkn-macos-amd64.tar.gz\"},","\t\t{\"Mac ARM 64\", \"tkn/tkn-macos-arm64.tar.gz\"},","\t\t{\"Windows x86_64\", \"tkn/tkn-windows-amd64.zip\"},","\t\t{\"Windows ARM 64\", \"tkn/tkn-windows-arm64.zip\"},","\t}","\tlinks := []console.CLIDownloadLink{}","\tfor _, platformURL := range platformURLs {","\t\tlinks = append(links,","\t\t\t// tkn and tkn-pac, single archive","\t\t\tconsole.CLIDownloadLink{","\t\t\t\tHref: getURL(baseURL, platformURL.tknURL),","\t\t\t\tText: fmt.Sprintf(\"Download tkn and tkn-pac for %s\", platformURL.platform),","\t\t\t},","\t\t)","\t}","\treturn links","}","","func getURL(baseURL string, path string) string {","\treturn fmt.Sprintf(\"https://%s/%s\", baseURL, path)","}","","func replaceURLCCD(baseURL string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ConsoleCLIDownload\" {","\t\t\treturn nil","\t\t}","\t\tccd := \u0026console.ConsoleCLIDownload{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, ccd)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tccd.Spec.Links = getlinks(baseURL)","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(ccd)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","func setVersionedNames(operatorVersion string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Task\" \u0026\u0026 u.GetKind() != \"StepAction\" {","\t\t\treturn nil","\t\t}","\t\tname := u.GetName()","\t\tformattedVersion := formattedVersionMajorMinorX(operatorVersion, versionedClusterTaskPatchChar)","\t\tname = fmt.Sprintf(\"%s-%s\", name, formattedVersion)","\t\tu.SetName(name)","\t\treturn nil","\t}","}","","func formattedVersionMajorMinorX(version, x string) string {","\tver := getPatchVersionTrimmed(version)","\tver = fmt.Sprintf(\"%s.%s\", ver, x)","\treturn formattedVersionSnake(ver)","}","","func formattedVersionSnake(version string) string {","\tver := strings.TrimPrefix(version, \"v\")","\treturn strings.Replace(ver, \".\", \"-\", -1)","}","","// To get the minor major version for label i.e. v1.6","func getPatchVersionTrimmed(version string) string {","\tendIndex := strings.LastIndex(version, \".\")","\tif endIndex != -1 {","\t\tversion = version[:endIndex]","\t}","\treturn version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,1,1,2,2,2,1,1,2,2,2,1,1,2,2,0,0,0,2,2,2,1,1,2,2,2,2,2,0,0,0,2,2,2,2,2,0,2,2,2,2,0,0,2,2,2,2,2,2,0]},{"id":167,"path":"pkg/reconciler/openshift/tektonaddon/triggers.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonaddon","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"",")","","func (r *Reconciler) EnsureTriggersResources(ctx context.Context, ta *v1alpha1.TektonAddon) error {","\tmanifest := *r.triggersResourcesManifest","\tif err := r.installerSetClient.CustomSet(ctx, ta, TriggersResourcesInstallerSet, \u0026manifest, filterAndTransformCommon(), nil); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func filterAndTransformCommon() client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\taddon := comp.(*v1alpha1.TektonAddon)","\t\tif err := transformers(ctx, manifest, addon); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn manifest, nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0]},{"id":168,"path":"pkg/reconciler/openshift/tektonchain/controller.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonchain","","import (","\t\"context\"","","\tk8s_ctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonchain\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":169,"path":"pkg/reconciler/openshift/tektonchain/extension.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonchain","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\toccommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"",")","","const (","\ttektonChainsControllerName = \"tekton-chains-controller\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\text := openshiftExtension{","\t\toperatorClientSet: operatorclient.Get(ctx),","\t}","\treturn ext","}","","type openshiftExtension struct {","\toperatorClientSet versioned.Interface","}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\toccommon.RemoveRunAsUser(),","\t\toccommon.RemoveRunAsGroup(),","\t\toccommon.RemoveRunAsUserForStatefulSet(tektonChainsControllerName),","\t\toccommon.RemoveRunAsGroupForStatefulSet(tektonChainsControllerName),","\t\toccommon.ApplyCABundlesToDeployment,","\t\toccommon.ApplyCABundlesForStatefulSet(tektonChainsControllerName),","\t}","}","func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":170,"path":"pkg/reconciler/openshift/tektonconfig/common.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","func createInstallerSet(ctx context.Context, oc versioned.Interface, tc *v1alpha1.TektonConfig, releaseVersion string) error {","","\t// add pipelines-scc","\tpipelinescc := \u0026mf.Manifest{}","\tpipelinesSCCLocation := filepath.Join(os.Getenv(common.KoEnvKey), \"tekton-pipeline\", \"00-prereconcile\")","\tif err := common.AppendManifest(pipelinescc, pipelinesSCCLocation); err != nil {","\t\treturn err","\t}","","\tis := makeInstallerSet(tc, releaseVersion)","\tis.Spec.Manifests = pipelinescc.Resources()","","\tcreatedIs, err := oc.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, is, metav1.CreateOptions{})","\tif err != nil \u0026\u0026 !errors.IsAlreadyExists(err) {","\t\treturn err","\t}","","\tif len(tc.Status.TektonInstallerSet) == 0 {","\t\ttc.Status.TektonInstallerSet = map[string]string{}","\t}","","\t// Update the status of tektonConfig with created installerSet name","\ttc.Status.TektonInstallerSet[rbacInstallerSetType] = createdIs.Name","\treturn nil","}","","func makeInstallerSet(tc *v1alpha1.TektonConfig, releaseVersion string) *v1alpha1.TektonInstallerSet {","\townerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())","\treturn \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: rbacInstallerSetNamePrefix,","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.CreatedByKey:      createdByValue,","\t\t\t\tv1alpha1.InstallerSetType:  rbacInstallerSetType,","\t\t\t\tv1alpha1.ReleaseVersionKey: releaseVersion,","\t\t\t},","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey:  releaseVersion,","\t\t\t\tv1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t}","}","","func deleteInstallerSet(ctx context.Context, oc versioned.Interface, tc *v1alpha1.TektonConfig, component string) error {","\tlabelSelector, err := common.LabelSelector(rbacInstallerSetSelector)","\tif err != nil {","\t\treturn err","\t}","\terr = oc.OperatorV1alpha1().TektonInstallerSets().DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{","\t\tLabelSelector: labelSelector,","\t})","\tif err != nil {","\t\treturn err","\t}","\t// clear the name of installer set from TektonConfig status","\tdelete(tc.Status.TektonInstallerSet, component)","","\treturn nil","}","","// checkIfInstallerSetExist checks if installer set exists for a component and return true/false based on it","// and if installer set which already exist is of older version then it deletes and return false to create a new","// installer set","func checkIfInstallerSetExist(ctx context.Context, oc versioned.Interface, relVersion string,","\ttc *v1alpha1.TektonConfig) (*v1alpha1.TektonInstallerSet, error) {","","\tlabelSelector, err := common.LabelSelector(rbacInstallerSetSelector)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to retreive labelSelector with selector %v: %w\", rbacInstallerSetSelector, err)","\t}","\texistingInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, oc, labelSelector)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to retreive existing InstallerSet with selector %v: %w\", labelSelector, err)","\t}","\tif existingInstallerSet == \"\" {","\t\treturn nil, nil","\t}","","\t// if already created then check which version it is","\tctIs, err := oc.OperatorV1alpha1().TektonInstallerSets().","\t\tGet(ctx, existingInstallerSet, metav1.GetOptions{})","\tif err != nil {","\t\tif errors.IsNotFound(err) {","\t\t\treturn nil, nil","\t\t}","\t\treturn nil, err","\t}","","\tif version, ok := ctIs.Annotations[v1alpha1.ReleaseVersionKey]; ok \u0026\u0026 version == relVersion {","\t\t// if installer set already exist and release version is same","\t\t// then ignore and move on","\t\treturn ctIs, nil","\t}","","\t// release version doesn't exist or is different from expected","\t// deleted existing InstallerSet and create a new one","","\terr = oc.OperatorV1alpha1().TektonInstallerSets().","\t\tDelete(ctx, existingInstallerSet, metav1.DeleteOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,1,1,0,2,2,2,0,0,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,2,2,2,2,1,1,2,2,1,1,2,2,2,0,0,2,2,2,1,1,1,1,0,0,2,2,2,2,2,0,0,0,0,1,1,1,1,1,1,0]},{"id":171,"path":"pkg/reconciler/openshift/tektonconfig/console_plugin_reconciler.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"strings\"","\t\"sync\"","","\t\"github.com/go-logr/zapr\"","\tmf \"github.com/manifestival/manifestival\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\t\"go.uber.org/zap\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"",")","","const (","\t// manifests console plugin yaml directory location","\tconsolePluginReconcileYamlDirectory = \"static/tekton-config/00-console-plugin\"","\t// installerSet label value","\tconsolePluginReconcileLabelCreatedByValue = \"tekton-config-console-plugin-manifests\"","\t// pipelines console plugin environment variable key","\tPipelinesConsolePluginImageEnvironmentKey = \"IMAGE_PIPELINES_CONSOLE_PLUGIN\"","\t// pipelines console plugin container name, used to replace the image from the environment","\tPipelinesConsolePluginContainerName = \"pipelines-console-plugin\"",")","","var (","\t// label filter to set/get installerSet specific to this reconciler","\tconsolePluginReconcileInstallerSetLabel = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.InstallerSetType: v1alpha1.ConfigResourceName,","\t\t\tv1alpha1.CreatedByKey:     consolePluginReconcileLabelCreatedByValue,","\t\t},","\t}",")","","type consolePluginReconciler struct {","\tlogger                      *zap.SugaredLogger","\toperatorClientSet           versioned.Interface","\tsyncOnce                    sync.Once","\tresourcesYamlDirectory      string","\toperatorVersion             string","\tpipelinesConsolePluginImage string","\tmanifest                    mf.Manifest","}","","// reconcile steps","// 1. get console plugin manifests from kodata","// 2. verify the existing installerSet hash value","// 3. if there is a mismatch or the installerSet not available, (re)create it","func (cpr *consolePluginReconciler) reconcile(ctx context.Context, tektonConfigCR *v1alpha1.TektonConfig) error {","","\tcpr.updateOnce(ctx)","","\t// verify he availability of the installerSet","\tlabelSelector, err := common.LabelSelector(consolePluginReconcileInstallerSetLabel)","\tif err != nil {","\t\treturn err","\t}","","\tinstallerSetList, err := cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().List(ctx, metav1.ListOptions{LabelSelector: labelSelector})","\tif err != nil {","\t\treturn err","\t}","","\tdoCreateInstallerSet := false","\tvar deployedInstallerSet v1alpha1.TektonInstallerSet","","\tif len(installerSetList.Items) \u003e 1 {","\t\tfor _, installerSet := range installerSetList.Items {","\t\t\terr = cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, installerSet.GetName(), metav1.DeleteOptions{})","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t\tdoCreateInstallerSet = true","\t} else if len(installerSetList.Items) == 1 {","\t\tdeployedInstallerSet = installerSetList.Items[0]","\t} else {","\t\tdoCreateInstallerSet = true","\t}","","\t// clone the manifest","\tmanifest := cpr.manifest.Append()","\t// apply transformations","\tif err := cpr.transform(ctx, \u0026manifest, tektonConfigCR); err != nil {","\t\ttektonConfigCR.Status.MarkNotReady(fmt.Sprintf(\"transformation failed: %s\", err.Error()))","\t\treturn err","\t}","","\t// get expected hash value of the manifests","\texpectedHash, err := cpr.getHash(manifest.Resources())","\tif err != nil {","\t\treturn err","\t}","","\tif !doCreateInstallerSet {","\t\t// compute hash from the deployed installerSet","\t\tdeployedHash, err := cpr.getHash(deployedInstallerSet.Spec.Manifests)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\treleaseVersion := deployedInstallerSet.GetLabels()[v1alpha1.ReleaseVersionKey]","\t\t// delete the existing installerSet,","\t\t// if hash mismatch or version mismatch","\t\tif expectedHash != deployedHash || cpr.operatorVersion != releaseVersion {","\t\t\tif err := cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, deployedInstallerSet.GetName(), metav1.DeleteOptions{}); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tdoCreateInstallerSet = true","\t\t}","\t}","","\tif doCreateInstallerSet {","\t\treturn cpr.createInstallerSet(ctx, \u0026manifest, tektonConfigCR)","\t}","","\treturn nil","}","","func (cpr *consolePluginReconciler) updateOnce(ctx context.Context) {","\t// reads all yaml files from the directory, it is an expensive process to access disk on each reconcile call.","\t// hence fetch only once at startup, it helps not to degrade the performance of the reconcile loop","\t// also it not necessary to read the files frequently, as the files are shipped along the container and never change","\tcpr.syncOnce.Do(func() {","\t\t// fetch manifest from disk","\t\tmanifest, err := mf.NewManifest(cpr.resourcesYamlDirectory, mf.UseLogger(zapr.NewLogger(cpr.logger.Desugar())))","\t\tif err != nil {","\t\t\tcpr.logger.Fatal(\"error getting manifests\",","\t\t\t\t\"manifestsLocation\", cpr.resourcesYamlDirectory,","\t\t\t\terr,","\t\t\t)","\t\t}","\t\tcpr.manifest = manifest","","\t\t// update pipelines console image details","\t\tconsoleImage, found := os.LookupEnv(PipelinesConsolePluginImageEnvironmentKey)","\t\tif found {","\t\t\tcpr.pipelinesConsolePluginImage = consoleImage","\t\t\tcpr.logger.Debugw(\"pipelines console plugin image found from environment\",","\t\t\t\t\"image\", consoleImage,","\t\t\t\t\"environmentVariable\", PipelinesConsolePluginImageEnvironmentKey,","\t\t\t)","\t\t} else {","\t\t\tcpr.logger.Warnw(\"pipelines console plugin image not found from environment, continuing with the default image from the manifest\",","\t\t\t\t\"environmentVariable\", PipelinesConsolePluginImageEnvironmentKey,","\t\t\t)","\t\t}","\t})","}","","func (cpr *consolePluginReconciler) createInstallerSet(ctx context.Context, manifest *mf.Manifest, tektonConfigCR *v1alpha1.TektonConfig) error {","\t// setup installerSet","\townerRef := *metav1.NewControllerRef(tektonConfigCR, tektonConfigCR.GetGroupVersionKind())","\tinstallerSet := \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: \"tekton-config-console-plugin-manifests-\",","\t\t\tLabels:       consolePluginReconcileInstallerSetLabel.MatchLabels,","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: tektonConfigCR.Spec.TargetNamespace,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","\t// update operator version","\tinstallerSet.Labels[v1alpha1.ReleaseVersionKey] = cpr.operatorVersion","","\t// creates installerSet in the cluster","\t_, err := cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Create(ctx, installerSet, metav1.CreateOptions{})","\tif err != nil {","\t\tcpr.logger.Error(\"error on creating installerset\", err)","\t}","\treturn err","}","","// apply transformations","func (cpr *consolePluginReconciler) transform(ctx context.Context, manifest *mf.Manifest, tektonConfigCR *v1alpha1.TektonConfig) error {","\t// load required transformers","\ttransformers := []mf.Transformer{","\t\t// updates \"metadata.namespace\" to targetNamespace","\t\tcommon.ReplaceNamespace(tektonConfigCR.Spec.TargetNamespace),","\t\tcpr.transformerConsolePlugin(tektonConfigCR.Spec.TargetNamespace),","\t\tcommon.AddConfiguration(tektonConfigCR.Spec.Config),","\t}","","\tif cpr.pipelinesConsolePluginImage != \"\" {","\t\t// updates deployments container image","\t\ttransformers = append(transformers, common.DeploymentImages(map[string]string{","\t\t\t// on the transformer, in the container name, the '-' replaced with '_'","\t\t\tstrings.ReplaceAll(PipelinesConsolePluginContainerName, \"-\", \"_\"): cpr.pipelinesConsolePluginImage,","\t\t}))","\t}","","\t// perform transformation","\treturn common.Transform(ctx, manifest, tektonConfigCR, transformers...)","}","","func (cpr *consolePluginReconciler) getHash(resources []unstructured.Unstructured) (string, error) {","\treturn hash.Compute(resources)","}","","func (cpr *consolePluginReconciler) transformerConsolePlugin(targetNamespace string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ConsolePlugin\" {","\t\t\treturn nil","\t\t}","","\t\treturn unstructured.SetNestedField(u.Object, targetNamespace, \"spec\", \"backend\", \"service\", \"namespace\")","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,1,0,2,2,1,1,0,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,0,0,2,2,2,1,1,1,0,0,2,2,1,1,0,2,2,2,2,1,1,0,2,2,2,2,2,1,1,2,0,0,0,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0,0,2,2,2,0,2,2,2,2,2,0,2,0,0]},{"id":172,"path":"pkg/reconciler/openshift/tektonconfig/controller.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\topenshiftpipelinesascodeinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/openshiftpipelinesascode\"","\ttektonAddoninformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonaddon\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig\"","\t\"k8s.io/client-go/tools/cache\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\tlogger := logging.FromContext(ctx)","\tctrl := tektonconfig.NewExtensibleController(OpenShiftExtension)(ctx, cmw)","\tif _, err := tektonAddoninformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonConfig{}),","\t\tHandler:    controller.HandleAll(ctrl.EnqueueControllerOf),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register TektonAddon informer event handler: %w\", err)","\t}","\tif _, err := openshiftpipelinesascodeinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonConfig{}),","\t\tHandler:    controller.HandleAll(ctrl.EnqueueControllerOf),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register OpenShiftPipelinesAsCode informer event handler: %w\", err)","\t}","\treturn ctrl","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":173,"path":"pkg/reconciler/openshift/tektonconfig/extension.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","","\tmf \"github.com/manifestival/manifestival\"","\tsecurity \"github.com/openshift/client-go/security/clientset/versioned\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\tpkgCommon \"github.com/tektoncd/operator/pkg/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/extension\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/types\"","\tnsV1 \"k8s.io/client-go/informers/core/v1\"","\trbacV1 \"k8s.io/client-go/informers/rbac/v1\"","\t\"k8s.io/client-go/kubernetes\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tnamespaceinformer \"knative.dev/pkg/client/injection/kube/informers/core/v1/namespace\"","\trbacInformer \"knative.dev/pkg/client/injection/kube/informers/rbac/v1/clusterrolebinding\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tversionKey = \"VERSION\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\tlogger := logging.FromContext(ctx)","\toperatorVer, err := common.OperatorVersion(ctx)","\tif err != nil {","\t\tlogger.Fatal(err)","\t}","","\text := openshiftExtension{","\t\toperatorClientSet: operatorclient.Get(ctx),","\t\tkubeClientSet:     kubeclient.Get(ctx),","\t\trbacInformer:      rbacInformer.Get(ctx),","\t\tnsInformer:        namespaceinformer.Get(ctx),","\t\tsecurityClientSet: pkgCommon.GetSecurityClient(ctx),","\t\toperatorVersion:   operatorVer,","\t}","","\text.consolePluginReconciler = \u0026consolePluginReconciler{","\t\tresourcesYamlDirectory: filepath.Join(common.ComponentBaseDir(), consolePluginReconcileYamlDirectory),","\t\tlogger:                 logger,","\t\toperatorClientSet:      ext.operatorClientSet,","\t\toperatorVersion:        operatorVer,","\t}","","\treturn ext","}","","type openshiftExtension struct {","\toperatorClientSet       versioned.Interface","\tkubeClientSet           kubernetes.Interface","\trbacInformer            rbacV1.ClusterRoleBindingInformer","\tnsInformer              nsV1.NamespaceInformer","\tconsolePluginReconciler *consolePluginReconciler","","\t// OpenShift clientsets are a bit... special, we need to get each","\t// clientset separately","\tsecurityClientSet security.Interface","","\toperatorVersion string","}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\t// update namespace in pruner RBAC","\t\tcommon.ReplaceNamespaceInServiceAccount(comp.GetSpec().GetTargetNamespace()),","\t\tcommon.ReplaceNamespaceInClusterRoleBinding(comp.GetSpec().GetTargetNamespace()),","\t}","}","","func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\tconfig := tc.(*v1alpha1.TektonConfig)","\tr := rbac{","\t\tkubeClientSet:     oe.kubeClientSet,","\t\toperatorClientSet: oe.operatorClientSet,","\t\tsecurityClientSet: oe.securityClientSet,","\t\trbacInformer:      oe.rbacInformer,","\t\tnsInformer:        oe.nsInformer,","\t\tversion:           os.Getenv(versionKey),","\t\ttektonConfig:      config,","\t}","","\t// set openshift specific defaults","\tr.setDefault()","","\t// below code helps to retain state of pre-existing SA at the time of upgrade","\tif existingSAWithOwnerRef(r.tektonConfig) {","\t\tlogger := logging.FromContext(ctx)","\t\tlogger.Infof(\"Found pre-existing ServiceAccount. Changing owner reference during upgrade.\")","","\t\tif err := changeOwnerRefOfPreExistingSA(ctx, r.kubeClientSet, *config); err != nil {","\t\t\tlogger.Errorf(\"Failed to change owner reference for pre-existing SA: %v\", err)","\t\t\treturn err","\t\t}","","\t\t// Get current labels to retain any existing labels","\t\ttcLabels := config.GetLabels()","\t\tif tcLabels == nil {","\t\t\ttcLabels = map[string]string{}","\t\t}","","\t\t// Add or update the serviceAccountCreationLabel without removing other labels","\t\ttcLabels[serviceAccountCreationLabel] = \"true\"","","\t\t// Prepare the patch to update only the labels, keeping the existing ones","\t\tjsonLabels, err := common.SerializeLabelsToJSON(tcLabels)","\t\tif err != nil {","\t\t\tlogger.Error(err)","\t\t\treturn err","\t\t}","\t\tpatchData := []byte(fmt.Sprintf(`{\"metadata\":{\"labels\":%s}}`, jsonLabels))","","\t\t// Apply the patch to the TektonConfig","\t\tif _, err := oe.operatorClientSet.OperatorV1alpha1().TektonConfigs().Patch(ctx, config.Name, types.MergePatchType, patchData, metav1.PatchOptions{}); err != nil {","\t\t\tlogger.Errorf(\"Failed to patch TektonConfig with new label: %v\", err)","\t\t\treturn err","\t\t}","","\t\tlogger.Infof(\"Successfully patched TektonConfig with serviceAccountCreationLabel set to true\")","\t}","","\tfor _, v := range config.Spec.Params {","\t\t// check for param name and if its matches to createRbacResource","\t\t// then disable auto creation of RBAC resources by deleting installerSet","\t\tif v.Name == rbacParamName \u0026\u0026 v.Value == \"false\" {","\t\t\tif err := deleteInstallerSet(ctx, r.operatorClientSet, r.tektonConfig, componentNameRBAC); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\t// remove openshift-pipelines.tekton.dev/namespace-reconcile-version label from namespaces while deleting RBAC resources.","\t\t\tif err := r.cleanUp(ctx); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t}","","\t// TODO: Remove this after v0.55.0 release, by following a depreciation notice","\t// --------------------","\tif err := r.cleanUpRBACNameChange(ctx); err != nil {","\t\treturn err","\t}","\t// --------------------","","\treturn r.createResources(ctx)","}","","func (oe openshiftExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tconfigInstance := comp.(*v1alpha1.TektonConfig)","","\tif configInstance.Spec.Profile == v1alpha1.ProfileAll {","\t\tif _, err := extension.EnsureTektonAddonExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonAddons(), configInstance, oe.operatorVersion); err != nil {","\t\t\tconfigInstance.Status.MarkComponentNotReady(fmt.Sprintf(\"TektonAddon: %s\", err.Error()))","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t}","\tif configInstance.Spec.Profile == v1alpha1.ProfileLite || configInstance.Spec.Profile == v1alpha1.ProfileBasic {","\t\tif err := extension.EnsureTektonAddonCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonAddons()); err != nil {","\t\t\treturn err","\t\t}","\t}","","\tpac := configInstance.Spec.Platforms.OpenShift.PipelinesAsCode","\tif pac != nil \u0026\u0026 *pac.Enable {","\t\tif _, err := extension.EnsureOpenShiftPipelinesAsCodeExists(ctx, oe.operatorClientSet.OperatorV1alpha1().OpenShiftPipelinesAsCodes(), configInstance, oe.operatorVersion); err != nil {","\t\t\tconfigInstance.Status.MarkComponentNotReady(fmt.Sprintf(\"OpenShiftPipelinesAsCode: %s\", err.Error()))","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t} else {","\t\tif err := extension.EnsureOpenShiftPipelinesAsCodeCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().OpenShiftPipelinesAsCodes()); err != nil {","\t\t\treturn err","\t\t}","\t}","","\t// execute console plugin reconciler","\treturn oe.consolePluginReconciler.reconcile(ctx, configInstance)","}","","func (oe openshiftExtension) Finalize(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tconfigInstance := comp.(*v1alpha1.TektonConfig)","\tif configInstance.Spec.Profile == v1alpha1.ProfileAll {","\t\tif err := extension.EnsureTektonAddonCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonAddons()); err != nil {","\t\t\treturn err","\t\t}","\t}","\tif configInstance.Spec.Platforms.OpenShift.PipelinesAsCode != nil \u0026\u0026 *configInstance.Spec.Platforms.OpenShift.PipelinesAsCode.Enable {","\t\tif err := extension.EnsureOpenShiftPipelinesAsCodeCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().OpenShiftPipelinesAsCodes()); err != nil {","\t\t\treturn err","\t\t}","\t}","","\tr := rbac{","\t\tkubeClientSet: oe.kubeClientSet,","\t\tversion:       os.Getenv(versionKey),","\t}","\treturn r.cleanUp(ctx)","}","","// configOwnerRef returns owner reference pointing to passed instance","func configOwnerRef(tc v1alpha1.TektonInstallerSet) metav1.OwnerReference {","\treturn *metav1.NewControllerRef(\u0026tc, tc.GetGroupVersionKind())","}","","// tektonConfigOwnerRef returns owner reference of tektonConfig","func tektonConfigOwnerRef(tc v1alpha1.TektonConfig) metav1.OwnerReference {","\treturn *metav1.NewControllerRef(\u0026tc, tc.GetGroupVersionKind())","}","","func changeOwnerRefOfPreExistingSA(ctx context.Context, kc kubernetes.Interface, tc v1alpha1.TektonConfig) error {","\tallSAs, err := kc.CoreV1().ServiceAccounts(\"\").List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn err","\t}","\tfor _, sa := range allSAs.Items {","\t\tif sa.Name == \"pipeline\" \u0026\u0026 !nsRegex.MatchString(sa.Namespace) {","\t\t\t// set tektonconfig ownerRef","\t\t\ttcOwnerRef := tektonConfigOwnerRef(tc)","\t\t\tsa.SetOwnerReferences([]metav1.OwnerReference{tcOwnerRef})","\t\t\tif _, err := kc.CoreV1().ServiceAccounts(sa.Namespace).Update(ctx, \u0026sa, metav1.UpdateOptions{}); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t}","\treturn nil","}","","// existingSAWithOwnerRef checks if openshift-pipelines.tekton.dev/sa-created label is present on tektonconfig","// we add this label from pipelines 1.8, and do not add tektoninstaller set as owner of serviceaccount created","// if label not present it means SA was created earlier and we need to remove ownerRef before we do the update","// this helps us to keep pre-existing SA as it is.","func existingSAWithOwnerRef(tc *v1alpha1.TektonConfig) bool {","\tlabels := tc.GetLabels()","\tif labels == nil {","\t\treturn false","\t}","\treturn labels[serviceAccountCreationLabel] != \"true\"","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,2,2,2,0,0,2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,0]},{"id":174,"path":"pkg/reconciler/openshift/tektonconfig/extension/addon.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package extension","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","func EnsureTektonAddonExists(ctx context.Context, clients op.TektonAddonInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.TektonAddon, error) {","\ttaCR, err := GetAddon(ctx, clients, v1alpha1.AddonResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif _, err = createAddon(ctx, clients, config, operatorVersion); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\ttaCR, err = updateAddon(ctx, taCR, config, clients, operatorVersion)","\tif err != nil {","\t\treturn nil, err","\t}","","\tok, err := isTektonAddonReady(taCR, err)","\tif err != nil {","\t\treturn nil, err","\t}","\tif !ok {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn taCR, err","}","","func createAddon(ctx context.Context, clients op.TektonAddonInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.TektonAddon, error) {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","","\ttaCR := \u0026v1alpha1.TektonAddon{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.AddonResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.TektonAddonSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tAddon: v1alpha1.Addon{","\t\t\t\tParams: config.Spec.Addon.Params,","\t\t\t},","\t\t\tConfig: config.Spec.Config,","\t\t},","\t}","\tif _, err := clients.Create(ctx, taCR, metav1.CreateOptions{}); err != nil {","\t\treturn nil, err","\t}","\treturn taCR, nil","}","","func GetAddon(ctx context.Context, clients op.TektonAddonInterface, name string) (*v1alpha1.TektonAddon, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func updateAddon(ctx context.Context, taCR *v1alpha1.TektonAddon, config *v1alpha1.TektonConfig,","\tclients op.TektonAddonInterface, operatorVersion string,",") (*v1alpha1.TektonAddon, error) {","\t// if the addon spec is changed then update the instance","\tupdated := false","","\t// initialize labels(map) object","\tif taCR.ObjectMeta.Labels == nil {","\t\ttaCR.ObjectMeta.Labels = map[string]string{}","\t}","","\tif config.Spec.TargetNamespace != taCR.Spec.TargetNamespace {","\t\ttaCR.Spec.TargetNamespace = config.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(config.Spec.Addon, taCR.Spec.Addon) {","\t\ttaCR.Spec.Addon = config.Spec.Addon","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(taCR.Spec.Config, config.Spec.Config) {","\t\ttaCR.Spec.Config = config.Spec.Config","\t\tupdated = true","\t}","","\tif taCR.ObjectMeta.OwnerReferences == nil {","\t\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\t\ttaCR.ObjectMeta.OwnerReferences = []metav1.OwnerReference{ownerRef}","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := taCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (oldLabels != operatorVersion) {","\t\ttaCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = operatorVersion","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, taCR, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn taCR, nil","}","","// isTektonAddonReady will check the status conditions of the TektonAddon and return true if the TektonAddon is ready.","func isTektonAddonReady(s *v1alpha1.TektonAddon, err error) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), nil","}","","func EnsureTektonAddonCRNotExists(ctx context.Context, clients op.TektonAddonInterface) error {","\tif _, err := GetAddon(ctx, clients, v1alpha1.AddonResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonAddon CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.AddonResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonAddon CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonAddon %q failed to delete: %v\", v1alpha1.AddonResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,1,0,2,2,2,2,2,0,2,2,2,1,1,2,0,0,2,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0]},{"id":175,"path":"pkg/reconciler/openshift/tektonconfig/extension/pipelinesascode.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package extension","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","func EnsureOpenShiftPipelinesAsCodeExists(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.OpenShiftPipelinesAsCode, error) {","\topacCR, err := GetPAC(ctx, clients, v1alpha1.OpenShiftPipelinesAsCodeName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif _, err = createOPAC(ctx, clients, config, operatorVersion); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\topacCR, err = updateOPAC(ctx, opacCR, config, clients, operatorVersion)","\tif err != nil {","\t\treturn nil, err","\t}","","\tok, err := isOPACReady(opacCR, err)","\tif err != nil {","\t\treturn nil, err","\t}","\tif !ok {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn opacCR, err","}","","func createOPAC(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.OpenShiftPipelinesAsCode, error) {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","","\topacCR := \u0026v1alpha1.OpenShiftPipelinesAsCode{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.OpenShiftPipelinesAsCodeName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.OpenShiftPipelinesAsCodeSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tConfig: config.Spec.Config,","\t\t\tPACSettings: v1alpha1.PACSettings{","\t\t\t\tSettings:                 config.Spec.Platforms.OpenShift.PipelinesAsCode.Settings,","\t\t\t\tAdditionalPACControllers: config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.AdditionalPACControllers,","\t\t\t},","\t\t},","\t}","\tif _, err := clients.Create(ctx, opacCR, metav1.CreateOptions{}); err != nil {","\t\treturn nil, err","\t}","\treturn opacCR, nil","}","","func GetPAC(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface, name string) (*v1alpha1.OpenShiftPipelinesAsCode, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func updateOPAC(ctx context.Context, opacCR *v1alpha1.OpenShiftPipelinesAsCode, config *v1alpha1.TektonConfig,","\tclients op.OpenShiftPipelinesAsCodeInterface, operatorVersion string,",") (*v1alpha1.OpenShiftPipelinesAsCode, error) {","\t// if the pac spec is changed then update the instance","\tupdated := false","","\t// initialize labels(map) object","\tif opacCR.ObjectMeta.Labels == nil {","\t\topacCR.ObjectMeta.Labels = map[string]string{}","\t}","","\tif config.Spec.TargetNamespace != opacCR.Spec.TargetNamespace {","\t\topacCR.Spec.TargetNamespace = config.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(opacCR.Spec.Config, config.Spec.Config) {","\t\topacCR.Spec.Config = config.Spec.Config","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(opacCR.Spec.Settings, config.Spec.Platforms.OpenShift.PipelinesAsCode.Settings) {","\t\topacCR.Spec.PACSettings.Settings = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Settings","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(opacCR.Spec.PACSettings.Options, config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options) {","\t\topacCR.Spec.PACSettings.Options = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(opacCR.Spec.PACSettings.AdditionalPACControllers, config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.AdditionalPACControllers) {","\t\topacCR.Spec.PACSettings.AdditionalPACControllers = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.AdditionalPACControllers","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(opacCR.Spec.PACSettings.Options, config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options) {","\t\topacCR.Spec.PACSettings.Options = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options","\t\tupdated = true","\t}","","\tif opacCR.ObjectMeta.OwnerReferences == nil {","\t\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\t\topacCR.ObjectMeta.OwnerReferences = []metav1.OwnerReference{ownerRef}","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := opacCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (oldLabels != operatorVersion) {","\t\topacCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = operatorVersion","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, opacCR, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn opacCR, nil","}","","// isOPACReady will check the status conditions of the OpenShiftPipelinesAsCode and return true if the OpenShiftPipelinesAsCode is ready.","func isOPACReady(s *v1alpha1.OpenShiftPipelinesAsCode, err error) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), err","}","","func EnsureOpenShiftPipelinesAsCodeCRNotExists(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface) error {","\tif _, err := GetPAC(ctx, clients, v1alpha1.OpenShiftPipelinesAsCodeName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// OpenShiftPipelinesAsCode CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.OpenShiftPipelinesAsCodeName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// OpenShiftPipelinesAsCode CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"OpenShiftPipelinesAsCode %q failed to delete: %v\", v1alpha1.OpenShiftPipelinesAsCodeName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,1,0,2,2,1,1,1,0,2,2,2,1,1,2,0,0,2,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0]},{"id":176,"path":"pkg/reconciler/openshift/tektonconfig/rbac.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"math\"","\t\"regexp\"","\t\"time\"","","\tsecurity \"github.com/openshift/client-go/security/clientset/versioned\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\t\"github.com/tektoncd/operator/pkg/common\"","\treconcilerCommon \"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/openshift\"","","\tcorev1 \"k8s.io/api/core/v1\"","\trbacv1 \"k8s.io/api/rbac/v1\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/selection\"","\t\"k8s.io/apimachinery/pkg/types\"","\tnsV1 \"k8s.io/client-go/informers/core/v1\"","\trbacV1 \"k8s.io/client-go/informers/rbac/v1\"","\t\"k8s.io/client-go/kubernetes\"","\tv1 \"k8s.io/client-go/kubernetes/typed/core/v1\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tpipelinesSCCRole        = \"pipelines-scc-role\"","\tpipelinesSCCClusterRole = \"pipelines-scc-clusterrole\"","\tpipelinesSCCRoleBinding = \"pipelines-scc-rolebinding\"","\tpipelineSA              = \"pipeline\"","\tPipelineRoleBinding     = \"openshift-pipelines-edit\"","","\t// TODO: Remove this after v0.55.0 release, by following a depreciation notice","\t// --------------------","\tpipelineRoleBindingOld  = \"edit\"","\trbacInstallerSetNameOld = \"rbac-resources\"","\t// --------------------","\tserviceCABundleConfigMap    = \"config-service-cabundle\"","\ttrustedCABundleConfigMap    = \"config-trusted-cabundle\"","\tclusterInterceptors         = \"openshift-pipelines-clusterinterceptors\"","\tnamespaceVersionLabel       = \"openshift-pipelines.tekton.dev/namespace-reconcile-version\"","\tnamespaceTrustedConfigLabel = \"openshift-pipelines.tekton.dev/namespace-trusted-configmaps-version\"","\tcreatedByValue              = \"RBAC\"","\tcomponentNameRBAC           = \"rhosp-rbac\"","\trbacInstallerSetType        = \"rhosp-rbac\"","\trbacInstallerSetNamePrefix  = \"rhosp-rbac-\"","\trbacParamName               = \"createRbacResource\"","\ttrustedCABundleParamName    = \"createCABundleConfigMaps\"","\tlegacyPipelineRbacParamName = \"legacyPipelineRbac\"","\tlegacyPipelineRbac          = \"true\"","\tserviceAccountCreationLabel = \"openshift-pipelines.tekton.dev/sa-created\"",")","","var (","\trbacInstallerSetSelector = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     createdByValue,","\t\t\tv1alpha1.InstallerSetType: componentNameRBAC,","\t\t},","\t}",")","","// Namespace Regex to ignore the namespace for creating rbac resources.","var nsRegex = regexp.MustCompile(reconcilerCommon.NamespaceIgnorePattern)","","type rbac struct {","\tkubeClientSet     kubernetes.Interface","\toperatorClientSet clientset.Interface","\tsecurityClientSet security.Interface","\trbacInformer      rbacV1.ClusterRoleBindingInformer","\tnsInformer        nsV1.NamespaceInformer","\townerRef          metav1.OwnerReference","\tversion           string","\ttektonConfig      *v1alpha1.TektonConfig","}","","type NamespaceServiceAccount struct {","\tServiceAccount *corev1.ServiceAccount","\tNamespace      corev1.Namespace","}","","// NamespacesToReconcile holds the namespaces that need reconciliation for different features","type NamespacesToReconcile struct {","\tRBACNamespaces []corev1.Namespace","\tCANamespaces   []corev1.Namespace","}","","func (r *rbac) cleanUp(ctx context.Context) error {","","\t// fetch the list of all namespaces which have label","\t// `openshift-pipelines.tekton.dev/namespace-reconcile-version: \u003crelease-version\u003e`","\tlabelSelector := fmt.Sprintf(\"%s = %s\", namespaceVersionLabel, r.version)","\tnamespaces, err := r.kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{","\t\tLabelSelector: labelSelector,","\t})","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to retreive namespaces with labelSeleclector %s: %v\", labelSelector, err)","\t}","\t// loop on namespaces and remove label if exist","\tfor _, n := range namespaces.Items {","\t\tlabels := n.GetLabels()","\t\tdelete(labels, namespaceVersionLabel)","\t\tn.SetLabels(labels)","\t\tif _, err := r.kubeClientSet.CoreV1().Namespaces().Update(ctx, \u0026n, metav1.UpdateOptions{}); err != nil {","\t\t\treturn fmt.Errorf(\"failed to update namespace %s: %v\", n.Name, err)","\t\t}","\t}","\treturn nil","}","","func (r *rbac) EnsureRBACInstallerSet(ctx context.Context) (*v1alpha1.TektonInstallerSet, error) {","\tif err := r.removeObsoleteRBACInstallerSet(ctx); err != nil {","\t\treturn nil, err","\t}","","\trbacISet, err := checkIfInstallerSetExist(ctx, r.operatorClientSet, r.version, r.tektonConfig)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif rbacISet != nil {","\t\treturn rbacISet, nil","\t}","\t// A new installer needs to be created","\t// either because of operator version upgrade or installerSet gone missing;","\t// therefore all relevant namespaces need to be reconciled for RBAC resources.","\t// Hence, remove the necessary labels to ensure that the namespaces will be 'not skipped'","\t// RBAC reconcile logic","\terr = r.cleanUp(ctx)","\tif err != nil {","\t\treturn nil, err","\t}","","\terr = createInstallerSet(ctx, r.operatorClientSet, r.tektonConfig, r.version)","\tif err != nil {","\t\treturn nil, err","\t}","\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","}","","func (r *rbac) setDefault() {","\tvar rbacParamFound, legacyParamFound, caBundleParamFound bool","\tvar createRbacResourceValue string","","\tfor i, v := range r.tektonConfig.Spec.Params {","\t\tif v.Name == rbacParamName {","\t\t\trbacParamFound = true","\t\t\tcreateRbacResourceValue = v.Value","\t\t\tif v.Value != \"false\" \u0026\u0026 v.Value != \"true\" {","\t\t\t\tr.tektonConfig.Spec.Params[i].Value = \"true\"","\t\t\t}","\t\t}","\t\tif v.Name == legacyPipelineRbacParamName {","\t\t\tlegacyParamFound = true","\t\t\tif v.Value != \"false\" \u0026\u0026 v.Value != \"true\" {","\t\t\t\tr.tektonConfig.Spec.Params[i].Value = \"true\"","\t\t\t}","\t\t}","\t\tif v.Name == trustedCABundleParamName {","\t\t\tcaBundleParamFound = true","\t\t\tif v.Value != \"false\" \u0026\u0026 v.Value != \"true\" {","\t\t\t\tr.tektonConfig.Spec.Params[i].Value = \"true\"","\t\t\t}","\t\t}","\t}","\tif !rbacParamFound {","\t\tr.tektonConfig.Spec.Params = append(r.tektonConfig.Spec.Params, v1alpha1.Param{","\t\t\tName:  rbacParamName,","\t\t\tValue: \"true\",","\t\t})","\t}","\tif !legacyParamFound {","\t\tr.tektonConfig.Spec.Params = append(r.tektonConfig.Spec.Params, v1alpha1.Param{","\t\t\tName:  legacyPipelineRbacParamName,","\t\t\tValue: \"true\",","\t\t})","\t}","","\t// TODO: Remove this upgrade workaround after version 1.22.","\t// This logic is only needed to preserve backward compatibility for users upgrading to 1.21","\t// who had createRbacResource=false and no createCABundleConfigMaps param set.","\tif !caBundleParamFound {","\t\tdefaultVal := \"true\"","\t\tif rbacParamFound \u0026\u0026 createRbacResourceValue == \"false\" {","\t\t\tdefaultVal = \"false\"","\t\t}","\t\tr.tektonConfig.Spec.Params = append(r.tektonConfig.Spec.Params,","\t\t\tv1alpha1.Param{Name: trustedCABundleParamName, Value: defaultVal},","\t\t)","\t}","}","","// ensurePreRequisites validates the resources before creation","func (r *rbac) ensurePreRequisites(ctx context.Context) error {","\tlogger := logging.FromContext(ctx)","","\trbacISet, err := r.EnsureRBACInstallerSet(ctx)","\tif err != nil {","\t\treturn err","\t}","\tr.ownerRef = configOwnerRef(*rbacISet)","","\t// make sure default SCC is in place","\tdefaultSCC := r.tektonConfig.Spec.Platforms.OpenShift.SCC.Default","\tif defaultSCC == \"\" {","\t\t// Should not really happen due to defaulting, but okay...","\t\treturn fmt.Errorf(\"tektonConfig.Spec.Platforms.OpenShift.SCC.Default cannot be empty\")","\t}","\tlogger.Infof(\"default SCC set to: %s\", defaultSCC)","\tif err := common.VerifySCCExists(ctx, defaultSCC, r.securityClientSet); err != nil {","\t\treturn fmt.Errorf(\"failed to verify scc %s exists, %w\", defaultSCC, err)","\t}","","\tprioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, r.securityClientSet)","\tif err != nil {","\t\treturn err","\t}","","\t// validate maxAllowed SCC","\tmaxAllowedSCC := r.tektonConfig.Spec.Platforms.OpenShift.SCC.MaxAllowed","\tif maxAllowedSCC != \"\" {","\t\tif err := common.VerifySCCExists(ctx, maxAllowedSCC, r.securityClientSet); err != nil {","\t\t\treturn fmt.Errorf(\"failed to verify scc %s exists, %w\", maxAllowedSCC, err)","\t\t}","","\t\tisPriority, err := common.SCCAMoreRestrictiveThanB(prioritizedSCCList, defaultSCC, maxAllowedSCC)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tlogger.Infof(\"Is maxAllowed SCC: %s less restrictive than default SCC: %s? %t\", maxAllowedSCC, defaultSCC, isPriority)","\t\tif !isPriority {","\t\t\treturn fmt.Errorf(\"maxAllowed SCC: %s must be less restrictive than the default SCC: %s\", maxAllowedSCC, defaultSCC)","\t\t}","\t\tlogger.Infof(\"maxAllowed SCC set to: %s\", maxAllowedSCC)","\t} else {","\t\tlogger.Info(\"No maxAllowed SCC set in TektonConfig\")","\t}","","\t// Maintaining a separate cluster role for the scc declaration.","\t// to assist us in managing this the scc association in a","\t// granular way.","\t// We need to make sure the pipelines-scc-clusterrole is up-to-date","\t// irrespective of the fact that we get reconcilable namespaces or not.","\tif err := r.ensurePipelinesSCClusterRole(ctx); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func (r *rbac) getNamespacesToBeReconciled(ctx context.Context) (*NamespacesToReconcile, error) {","\tlogger := logging.FromContext(ctx)","","\t// fetch the list of all namespaces","\tallNamespaces, err := r.kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tresult := \u0026NamespacesToReconcile{","\t\tRBACNamespaces: []corev1.Namespace{},","\t\tCANamespaces:   []corev1.Namespace{},","\t}","","\tfor _, ns := range allNamespaces.Items {","\t\t// ignore namespaces with name passing regex `^(openshift|kube)-`","\t\tif ignore := nsRegex.MatchString(ns.GetName()); ignore {","\t\t\tlogger.Debugf(\"Ignoring system namespace: %s\", ns.GetName())","\t\t\tcontinue","\t\t}","","\t\t// ignore namespaces with DeletionTimestamp set","\t\tif ns.GetObjectMeta().GetDeletionTimestamp() != nil {","\t\t\tlogger.Debugf(\"Ignoring namespace being deleted: %s\", ns.GetName())","\t\t\tcontinue","\t\t}","","\t\t// Check if namespace needs RBAC reconciliation","\t\tneedsRBAC := false","\t\t// We want to monitor namespaces with the SCC annotation set","\t\tif ns.Annotations[openshift.NamespaceSCCAnnotation] != \"\" {","\t\t\tneedsRBAC = true","\t\t}","\t\t// Then we want to accept namespaces that have not been reconciled yet","\t\tif ns.Labels[namespaceVersionLabel] != r.version {","\t\t\tneedsRBAC = true","\t\t} else {","\t\t\t// Now we're left with namespaces that have already been reconciled.","\t\t\t// We must make sure that the default SCC is in force via the ClusterRole.","\t\t\tsccRoleBinding, err := r.kubeClientSet.RbacV1().RoleBindings(ns.Name).Get(ctx, pipelinesSCCRoleBinding, metav1.GetOptions{})","\t\t\tif err != nil {","\t\t\t\t// Reconcile a namespace again with missing RoleBinding","\t\t\t\tif errors.IsNotFound(err) {","\t\t\t\t\tlogger.Debugf(\"could not find roleBinding %s in namespace %s\", pipelinesSCCRoleBinding, ns.Name)","\t\t\t\t\tneedsRBAC = true","\t\t\t\t} else {","\t\t\t\t\treturn nil, fmt.Errorf(\"error fetching rolebinding %s from namespace %s: %w\", pipelinesSCCRoleBinding, ns.Name, err)","\t\t\t\t}","\t\t\t} else if sccRoleBinding.RoleRef.Kind != \"ClusterRole\" {","\t\t\t\tlogger.Infof(\"RoleBinding %s in namespace: %s should have CluterRole with default SCC, will reconcile again...\", pipelinesSCCRoleBinding, ns.Name)","\t\t\t\tneedsRBAC = true","\t\t\t}","\t\t}","","\t\tif needsRBAC {","\t\t\tlogger.Debugf(\"Adding namespace for RBAC reconciliation: %s\", ns.GetName())","\t\t\tresult.RBACNamespaces = append(result.RBACNamespaces, ns)","\t\t}","","\t\t// Check if namespace needs CA bundle reconciliation","\t\tif ns.Labels[namespaceTrustedConfigLabel] != r.version {","\t\t\tlogger.Debugf(\"Adding namespace for CA bundle reconciliation: %s\", ns.GetName())","\t\t\tresult.CANamespaces = append(result.CANamespaces, ns)","\t\t}","\t}","","\treturn result, nil","}","","func (r *rbac) getSCCRoleInNamespace(ns *corev1.Namespace) *rbacv1.RoleRef {","\tnsAnnotations := ns.GetAnnotations()","\tnsSCC := nsAnnotations[openshift.NamespaceSCCAnnotation]","\t// If SCC is requested by namespace annotation, then we need a Role","\tif nsSCC != \"\" {","\t\treturn \u0026rbacv1.RoleRef{","\t\t\tAPIGroup: rbacv1.GroupName,","\t\t\tKind:     \"Role\",","\t\t\tName:     pipelinesSCCRole,","\t\t}","\t}","\t// If no SCC annotation is present in the namespace, we will use the","\t// pipelines-scc-clusterrole","\treturn \u0026rbacv1.RoleRef{","\t\tAPIGroup: rbacv1.GroupName,","\t\tKind:     \"ClusterRole\",","\t\tName:     pipelinesSCCClusterRole,","\t}","}","","func (r *rbac) handleSCCInNamespace(ctx context.Context, ns *corev1.Namespace) error {","\tlogger := logging.FromContext(ctx)","","\tnsName := ns.GetName()","\tnsAnnotations := ns.GetAnnotations()","\tnsSCC := nsAnnotations[openshift.NamespaceSCCAnnotation]","","\t// No SCC is requested in the namespace","\tif nsSCC == \"\" {","\t\t// If we don't have a namespace annotation, then we don't need a","\t\t// Role in this namespace as we will bind to the ClusterRole.","\t\t// This happens in cases when the SCC annotation was removed from","\t\t// the namespace.","\t\t_, err := r.kubeClientSet.RbacV1().Roles(nsName).Get(ctx, pipelinesSCCRole, metav1.GetOptions{})","\t\tif err != nil \u0026\u0026 !errors.IsNotFound(err) {","\t\t\treturn err","\t\t}","","\t\t// If `err == nil` AND role was found, it means that role exists","\t\tif !errors.IsNotFound(err) {","\t\t\tlogger.Infof(\"Found leftover role: %s in namespace: %s, deleting...\", pipelinesSCCRole, nsName)","\t\t\terr := r.kubeClientSet.RbacV1().Roles(nsName).Delete(ctx, pipelinesSCCRole, metav1.DeleteOptions{})","\t\t\tif err != nil \u0026\u0026 !errors.IsNotFound(err) {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t\t// Don't proceed further if no SCC requested by namespace","\t\treturn nil","\t}","","\t// We're here, so the namespace has actually requested an SCC","\tlogger.Infof(\"Namespace: %s has requested SCC: %s\", nsName, nsSCC)","","\t// Make sure that SCC exists on cluster","\tif err := common.VerifySCCExists(ctx, nsSCC, r.securityClientSet); err != nil {","\t\tlogger.Error(err)","","\t\t// Create an event in the namespace if the SCC does not exist","\t\teventErr := r.createSCCFailureEventInNamespace(ctx, nsName, nsSCC)","\t\tif eventErr != nil {","\t\t\tlogger.Errorf(\"Failed to create SCC not found event in namepsace: %s\", nsName)","\t\t\treturn eventErr","\t\t}","\t\treturn err","\t}","","\t// Make sure SCC requested in the namespace has a lower or equal priority","\t// than the SCC mentioned in maxAllowed","\tmaxAllowedSCC := r.tektonConfig.Spec.Platforms.OpenShift.SCC.MaxAllowed","\tif maxAllowedSCC != \"\" {","\t\tprioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, r.securityClientSet)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tisPriority, err := common.SCCAMoreRestrictiveThanB(prioritizedSCCList, nsSCC, maxAllowedSCC)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tlogger.Infof(\"Is maxAllowed SCC: %s less restrictive than namespace SCC: %s? %t\", maxAllowedSCC, nsSCC, isPriority)","\t\tif !isPriority {","\t\t\treturn fmt.Errorf(\"namespace: %s has requested SCC: %s, but it is less restrictive than the 'maxAllowed' SCC: %s\", nsName, nsSCC, maxAllowedSCC)","\t\t}","\t}","","\t// Make sure a Role exists with the SCC attached in the namespace","\tif err := r.ensureSCCRoleInNamespace(ctx, nsName, nsSCC); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","// processRBAC encapsulates the logic for processing RBAC in a single namespace.","func (r *rbac) processRBAC(ctx context.Context, ns corev1.Namespace) (*NamespaceServiceAccount, error) {","\tlogger := logging.FromContext(ctx)","\tlogger.Infof(\"Processing RBAC for namespace %s\", ns.GetName())","","\t// Create or update ServiceAccount","\tsa, err := r.ensureSA(ctx, \u0026ns)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to ensure ServiceAccount in namespace %s: %v\", ns.Name, err)","\t}","","\tif sa == nil {","\t\treturn nil, fmt.Errorf(\"ServiceAccount is nil for namespace %s\", ns.Name)","\t}","","\t// Handle SCC in namespace","\tif err := r.handleSCCInNamespace(ctx, \u0026ns); err != nil {","\t\treturn nil, fmt.Errorf(\"failed to handle SCC in namespace %s: %v\", ns.Name, err)","\t}","","\t// Get and apply role reference","\troleRef := r.getSCCRoleInNamespace(\u0026ns)","\tif roleRef != nil {","\t\tif err := r.ensurePipelinesSCCRoleBinding(ctx, sa, roleRef); err != nil {","\t\t\treturn nil, fmt.Errorf(\"failed to ensure pipelines SCC role binding in namespace %s: %v\", ns.Name, err)","\t\t}","\t}","","\t// Ensure role bindings","\tif err := r.ensureRoleBindings(ctx, sa); err != nil {","\t\treturn nil, fmt.Errorf(\"failed to ensure role bindings in namespace %s: %v\", ns.Name, err)","\t}","","\treturn \u0026NamespaceServiceAccount{","\t\tServiceAccount: sa,","\t\tNamespace:      ns,","\t}, nil","}","","// patch namespace with reconciled label","func (r *rbac) patchNamespaceLabel(ctx context.Context, ns corev1.Namespace) error {","\tlogger := logging.FromContext(ctx)","","\tlogger.Infof(\"add label namespace-reconcile-version to mark namespace '%s' as reconciled\", ns.Name)","","\t// Prepare a patch to add/update just one label without overwriting others","\tpatch := map[string]interface{}{","\t\t\"metadata\": map[string]interface{}{","\t\t\t\"labels\": map[string]interface{}{","\t\t\t\tnamespaceVersionLabel: r.version,","\t\t\t},","\t\t},","\t}","","\tpatchPayload, err := json.Marshal(patch)","\tif err != nil {","\t\tlogger.Errorf(\"failed to marshal patch payload: %v\", err)","\t\treturn fmt.Errorf(\"failed to marshal label patch for namespace %s: %w\", ns.Name, err)","\t}","","\t// Use PATCH to update just the target label","\tif _, err := r.kubeClientSet.CoreV1().Namespaces().Patch(ctx, ns.Name, types.StrategicMergePatchType, patchPayload, metav1.PatchOptions{}); err != nil {","\t\tlogger.Errorf(\"failed to patch namespace %s: %v\", ns.Name, err)","\t\treturn fmt.Errorf(\"failed to patch namespace %s: %w\", ns.Name, err)","\t}","","\tlogger.Infof(\"namespace '%s' successfully reconciled with label %q=%q\", ns.Name, namespaceVersionLabel, r.version)","\treturn nil","}","","// createResources handles the reconciliation of RBAC resources and CA bundle configmaps","// across namespaces. It processes each feature independently based on their respective","// configuration flags and only reconciles namespaces that need updates.","func (r *rbac) createResources(ctx context.Context) error {","\tlogger := logging.FromContext(ctx)","","\t// Step 1: Check feature flags","\tcreateCABundles := true","\tcreateRBACResource := true","","\t// Check feature flags","\tfor _, v := range r.tektonConfig.Spec.Params {","\t\tif v.Name == trustedCABundleParamName \u0026\u0026 v.Value == \"false\" {","\t\t\tcreateCABundles = false","\t\t\tlogger.Info(\"CA bundle creation is disabled\")","\t\t}","\t\tif v.Name == rbacParamName \u0026\u0026 v.Value == \"false\" {","\t\t\tcreateRBACResource = false","\t\t\tlogger.Info(\"RBAC resource creation is disabled\")","\t\t}","\t}","","\t// If both features are disabled, nothing to do","\tif !createCABundles \u0026\u0026 !createRBACResource {","\t\tlogger.Info(\"Both CA bundle and RBAC creation are disabled, nothing to do\")","\t\treturn nil","\t}","","\t// Step 2: Ensure prerequisites (only if RBAC is enabled)","\tif createRBACResource {","\t\tif err := r.ensurePreRequisites(ctx); err != nil {","\t\t\tlogger.Errorf(\"error validating resources: %v\", err)","\t\t\treturn err","\t\t}","\t}","","\t// Step 3: Get namespaces to be reconciled for both RBAC and CA bundles","\tnamespacesToReconcile, err := r.getNamespacesToBeReconciled(ctx)","\tif err != nil {","\t\tlogger.Error(err)","\t\treturn err","\t}","","\t// Early return if no namespaces need reconciliation for either feature","\tif len(namespacesToReconcile.RBACNamespaces) == 0 \u0026\u0026 len(namespacesToReconcile.CANamespaces) == 0 {","\t\tlogger.Info(\"No namespaces need reconciliation for either RBAC or CA bundles\")","\t\treturn nil","\t}","","\t// Step 4: Handle RBAC if enabled","\tif createRBACResource {","\t\tif len(namespacesToReconcile.RBACNamespaces) == 0 {","\t\t\tlogger.Info(\"No namespaces need RBAC reconciliation\")","\t\t} else {","\t\t\tlogger.Debugf(\"Found %d namespaces to be reconciled for RBAC\", len(namespacesToReconcile.RBACNamespaces))","","\t\t\t// Remove and update namespaces from Cluster Interceptors","\t\t\tif err := r.removeAndUpdateNSFromCI(ctx); err != nil {","\t\t\t\tlogger.Error(err)","\t\t\t\treturn err","\t\t\t}","","\t\t\tvar namespacesToUpdate []NamespaceServiceAccount","\t\t\t// Process each namespace for RBAC","\t\t\tfor _, ns := range namespacesToReconcile.RBACNamespaces {","\t\t\t\tlogger.Infof(\"Processing namespace %s for RBAC\", ns.Name)","\t\t\t\tnsSA, err := r.processRBAC(ctx, ns)","\t\t\t\tif err != nil {","\t\t\t\t\tlogger.Errorf(\"failed processing namespace %s: %v\", ns.Name, err)","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tnamespacesToUpdate = append(namespacesToUpdate, *nsSA)","\t\t\t}","","\t\t\t// Bulk update ClusterRoleBinding","\t\t\tif len(namespacesToUpdate) \u003e 0 {","\t\t\t\tif err := r.handleClusterRoleBinding(ctx, namespacesToUpdate); err != nil {","\t\t\t\t\tlogger.Errorf(\"failed to ensure clusterrolebinding update: %v\", err)","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t\tlogger.Info(\"Successfully updated cluster role bindings\")","","\t\t\t\t// Patch namespace labels for RBAC","\t\t\t\tfor _, nsSA := range namespacesToUpdate {","\t\t\t\t\tlogger.Infof(\"Reconciling namespace %s for RBAC\", nsSA.Namespace.Name)","\t\t\t\t\tif err := r.patchNamespaceLabel(ctx, nsSA.Namespace); err != nil {","\t\t\t\t\t\tlogger.Errorf(\"failed reconciling namespace %s: %v\", nsSA.Namespace.Name, err)","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\t// Step 5: Handle CA bundles if enabled","\tif createCABundles {","\t\tif len(namespacesToReconcile.CANamespaces) == 0 {","\t\t\tlogger.Info(\"No namespaces need CA bundle reconciliation\")","\t\t} else {","\t\t\tlogger.Debugf(\"Found %d namespaces to be reconciled for CA bundles\", len(namespacesToReconcile.CANamespaces))","","\t\t\tfor _, ns := range namespacesToReconcile.CANamespaces {","\t\t\t\tlogger.Infof(\"Processing namespace %s for CA bundles\", ns.Name)","\t\t\t\tif err := r.ensureCABundlesInNamespace(ctx, \u0026ns); err != nil {","\t\t\t\t\tlogger.Errorf(\"failed to ensure CA bundles in namespace %s: %v\", ns.Name, err)","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\t// Patch namespace with trusted configmaps label","\t\t\t\tif err := r.patchNamespaceTrustedConfigLabel(ctx, ns); err != nil {","\t\t\t\t\tlogger.Errorf(\"failed to patch trusted config label for namespace %s: %v\", ns.Name, err)","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\treturn nil","}","","func (r *rbac) createSCCFailureEventInNamespace(ctx context.Context, namespace string, scc string) error {","\tlogger := logging.FromContext(ctx)","","\tfailureEvent := corev1.Event{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName:    \"pipelines-scc-failure-\",","\t\t\tNamespace:       namespace,","\t\t\tOwnerReferences: []metav1.OwnerReference{r.ownerRef},","\t\t},","\t\tEventTime:           metav1.NewMicroTime(time.Now()),","\t\tReason:              \"RequestedSCCNotFound\",","\t\tType:                \"Warning\",","\t\tAction:              \"SCCNotUpdated\",","\t\tMessage:             fmt.Sprintf(\"SCC '%s' requested in annotation '%s' not found, SCC not updated in the namespace\", scc, openshift.NamespaceSCCAnnotation),","\t\tReportingController: \"openshift-pipelines-operator\",","\t\tReportingInstance:   r.ownerRef.Name,","\t\tInvolvedObject: corev1.ObjectReference{","\t\t\tKind:       \"Namespace\",","\t\t\tName:       namespace,","\t\t\tAPIVersion: \"v1\",","\t\t\tNamespace:  namespace,","\t\t},","\t}","","\tlogger.Infof(\"Creating SCC failure event in namespace: %s\", namespace)","\t_, err := r.kubeClientSet.CoreV1().Events(namespace).Create(ctx, \u0026failureEvent, metav1.CreateOptions{})","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to create failure event in namespace %s, %w\", namespace, err)","\t}","","\treturn nil","}","","func (r *rbac) ensureCABundles(ctx context.Context, ns *corev1.Namespace) error {","\tlogger := logging.FromContext(ctx)","\tcfgInterface := r.kubeClientSet.CoreV1().ConfigMaps(ns.Name)","","\t// Ensure trusted CA bundle","\tlogger.Infof(\"finding configmap: %s/%s\", ns.Name, trustedCABundleConfigMap)","\tcaBundleCM, getErr := cfgInterface.Get(ctx, trustedCABundleConfigMap, metav1.GetOptions{})","\tif getErr != nil \u0026\u0026 !errors.IsNotFound(getErr) {","\t\treturn getErr","\t}","","\tif getErr != nil \u0026\u0026 errors.IsNotFound(getErr) {","\t\tlogger.Infof(\"creating configmap %s in %s namespace\", trustedCABundleConfigMap, ns.Name)","\t\tvar err error","\t\tif caBundleCM, err = createCABundleConfigMaps(ctx, cfgInterface, trustedCABundleConfigMap, ns.Name); err != nil {","\t\t\treturn err","\t\t}","\t}","","\t// If config map already exist then remove owner ref","\tif getErr == nil {","\t\tcaBundleCM.SetOwnerReferences(nil)","\t\tif _, err := cfgInterface.Update(ctx, caBundleCM, metav1.UpdateOptions{}); err != nil {","\t\t\treturn err","\t\t}","\t}","","\t// Ensure service CA bundle","\tlogger.Infof(\"finding configmap: %s/%s\", ns.Name, serviceCABundleConfigMap)","\tserviceCABundleCM, getErr := cfgInterface.Get(ctx, serviceCABundleConfigMap, metav1.GetOptions{})","\tif getErr != nil \u0026\u0026 !errors.IsNotFound(getErr) {","\t\treturn getErr","\t}","","\tif getErr != nil \u0026\u0026 errors.IsNotFound(getErr) {","\t\tlogger.Infof(\"creating configmap %s in %s namespace\", serviceCABundleConfigMap, ns.Name)","\t\tvar err error","\t\tif serviceCABundleCM, err = createServiceCABundleConfigMap(ctx, cfgInterface, serviceCABundleConfigMap, ns.Name); err != nil {","\t\t\treturn err","\t\t}","\t}","","\t// If config map already exist then remove owner ref","\tif getErr == nil {","\t\tserviceCABundleCM.SetOwnerReferences(nil)","\t\tif _, err := cfgInterface.Update(ctx, serviceCABundleCM, metav1.UpdateOptions{}); err != nil {","\t\t\treturn err","\t\t}","\t}","","\treturn nil","}","","func createCABundleConfigMaps(ctx context.Context, cfgInterface v1.ConfigMapInterface,","\tname, ns string) (*corev1.ConfigMap, error) {","\tc := \u0026corev1.ConfigMap{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:      name,","\t\t\tNamespace: ns,","\t\t\tLabels: map[string]string{","\t\t\t\t\"app.kubernetes.io/part-of\": \"tekton-pipelines\",","\t\t\t\t// user-provided and system CA certificates","\t\t\t\t\"config.openshift.io/inject-trusted-cabundle\": \"true\",","\t\t\t},","\t\t\t// No OwnerReferences","\t\t},","\t}","","\tcm, err := cfgInterface.Create(ctx, c, metav1.CreateOptions{})","\tif err != nil \u0026\u0026 !errors.IsAlreadyExists(err) {","\t\treturn nil, err","\t}","\treturn cm, nil","}","","func createServiceCABundleConfigMap(ctx context.Context, cfgInterface v1.ConfigMapInterface,","\tname, ns string) (*corev1.ConfigMap, error) {","\tc := \u0026corev1.ConfigMap{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:      name,","\t\t\tNamespace: ns,","\t\t\tLabels: map[string]string{","\t\t\t\t\"app.kubernetes.io/part-of\": \"tekton-pipelines\",","\t\t\t},","\t\t\tAnnotations: map[string]string{","\t\t\t\t// service serving certificates (required to talk to the internal registry)","\t\t\t\t\"service.beta.openshift.io/inject-cabundle\": \"true\",","\t\t\t},","\t\t\t// No OwnerReferences","\t\t},","\t}","","\tcm, err := cfgInterface.Create(ctx, c, metav1.CreateOptions{})","\tif err != nil \u0026\u0026 !errors.IsAlreadyExists(err) {","\t\treturn nil, err","\t}","\treturn cm, nil","}","","func (r *rbac) ensureSA(ctx context.Context, ns *corev1.Namespace) (*corev1.ServiceAccount, error) {","\tlogger := logging.FromContext(ctx)","\tlogger.Infof(\"finding sa: %s/%s\", ns.Name, \"pipeline\")","\tsaInterface := r.kubeClientSet.CoreV1().ServiceAccounts(ns.Name)","","\tsa, err := saInterface.Get(ctx, pipelineSA, metav1.GetOptions{})","\tif err != nil \u0026\u0026 !errors.IsNotFound(err) {","\t\treturn nil, err","\t}","\tif err != nil \u0026\u0026 errors.IsNotFound(err) {","\t\tlogger.Info(\"creating sa \", pipelineSA, \" ns\", ns.Name)","\t\treturn createSA(ctx, saInterface, ns.Name, *r.tektonConfig)","\t}","","\t// set tektonConfig ownerRef","\ttcOwnerRef := tektonConfigOwnerRef(*r.tektonConfig)","\tsa.SetOwnerReferences([]metav1.OwnerReference{tcOwnerRef})","","\treturn saInterface.Update(ctx, sa, metav1.UpdateOptions{})","}","","func createSA(ctx context.Context, saInterface v1.ServiceAccountInterface, ns string, tc v1alpha1.TektonConfig) (*corev1.ServiceAccount, error) {","\ttcOwnerRef := tektonConfigOwnerRef(tc)","\tsa := \u0026corev1.ServiceAccount{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            pipelineSA,","\t\t\tNamespace:       ns,","\t\t\tOwnerReferences: []metav1.OwnerReference{tcOwnerRef},","\t\t},","\t}","","\tsa, err := saInterface.Create(ctx, sa, metav1.CreateOptions{})","\tif err != nil \u0026\u0026 !errors.IsAlreadyExists(err) {","\t\treturn nil, err","\t}","","\t// Initialize labels map if it doesn't exist","\tif tc.Labels == nil {","\t\ttc.Labels = make(map[string]string)","\t}","\ttc.Labels[serviceAccountCreationLabel] = \"true\"","\treturn sa, nil","}","","// ensureSCCRoleInNamespace ensures that the SCC role exists in the namespace","func (r *rbac) ensureSCCRoleInNamespace(ctx context.Context, namespace string, scc string) error {","\tlogger := logging.FromContext(ctx)","","\tlogger.Infof(\"finding role: %s in namespace %s\", pipelinesSCCRole, namespace)","","\tsccRole := \u0026rbacv1.Role{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            pipelinesSCCRole,","\t\t\tNamespace:       namespace,","\t\t\tOwnerReferences: []metav1.OwnerReference{r.ownerRef},","\t\t},","\t\tRules: []rbacv1.PolicyRule{","\t\t\t{","\t\t\t\tAPIGroups: []string{","\t\t\t\t\t\"security.openshift.io\",","\t\t\t\t},","\t\t\t\tResourceNames: []string{","\t\t\t\t\tscc,","\t\t\t\t},","\t\t\t\tResources: []string{","\t\t\t\t\t\"securitycontextconstraints\",","\t\t\t\t},","\t\t\t\tVerbs: []string{","\t\t\t\t\t\"use\",","\t\t\t\t},","\t\t\t},","\t\t},","\t}","","\trbacClient := r.kubeClientSet.RbacV1()","\tif _, err := rbacClient.Roles(namespace).Get(ctx, pipelinesSCCRole, metav1.GetOptions{}); err != nil {","\t\t// If the role does not exist, then create it and exit","\t\tif errors.IsNotFound(err) {","\t\t\t_, err = rbacClient.Roles(namespace).Create(ctx, sccRole, metav1.CreateOptions{})","\t\t}","\t\treturn err","\t}","\t// Update the role if it already exists","\t_, err := rbacClient.Roles(namespace).Update(ctx, sccRole, metav1.UpdateOptions{})","\treturn err","}","","// ensurePipelinesSCClusterRole ensures that `pipelines-scc` ClusterRole exists","// in the cluster. The SCC used in the ClusterRole is read from SCC config","// in TektonConfig (`pipelines-scc` by default)","func (r *rbac) ensurePipelinesSCClusterRole(ctx context.Context) error {","\tlogger := logging.FromContext(ctx)","","\tlogger.Info(\"finding cluster role:\", pipelinesSCCClusterRole)","","\tclusterRole := \u0026rbacv1.ClusterRole{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            pipelinesSCCClusterRole,","\t\t\tOwnerReferences: []metav1.OwnerReference{r.ownerRef},","\t\t},","\t\tRules: []rbacv1.PolicyRule{","\t\t\t{","\t\t\t\tAPIGroups: []string{","\t\t\t\t\t\"security.openshift.io\",","\t\t\t\t},","\t\t\t\tResourceNames: []string{","\t\t\t\t\tr.tektonConfig.Spec.Platforms.OpenShift.SCC.Default,","\t\t\t\t},","\t\t\t\tResources: []string{","\t\t\t\t\t\"securitycontextconstraints\",","\t\t\t\t},","\t\t\t\tVerbs: []string{","\t\t\t\t\t\"use\",","\t\t\t\t},","\t\t\t},","\t\t},","\t}","","\trbacClient := r.kubeClientSet.RbacV1()","\tif _, err := rbacClient.ClusterRoles().Get(ctx, pipelinesSCCClusterRole, metav1.GetOptions{}); err != nil {","\t\tif errors.IsNotFound(err) {","\t\t\t_, err = rbacClient.ClusterRoles().Create(ctx, clusterRole, metav1.CreateOptions{})","\t\t}","\t\treturn err","\t}","\t_, err := rbacClient.ClusterRoles().Update(ctx, clusterRole, metav1.UpdateOptions{})","\treturn err","}","","func (r *rbac) ensurePipelinesSCCRoleBinding(ctx context.Context, sa *corev1.ServiceAccount, roleRef *rbacv1.RoleRef) error {","\tlogger := logging.FromContext(ctx)","\trbacClient := r.kubeClientSet.RbacV1()","","\troleKind := roleRef.Kind","\troleName := roleRef.Name","\tif roleRef.Kind == \"Role\" {","\t\tlogger.Infof(\"finding %s: %s\", roleKind, roleName)","\t\tif _, err := rbacClient.Roles(sa.Namespace).Get(ctx, roleName, metav1.GetOptions{}); err != nil {","\t\t\tlogger.Error(err, \"finding %s failed: %s\", roleKind, roleName)","\t\t\treturn err","\t\t}","\t} else if roleKind == \"ClusterRole\" {","\t\tlogger.Infof(\"finding %s: %s\", roleKind, roleName)","\t\tif _, err := rbacClient.ClusterRoles().Get(ctx, roleName, metav1.GetOptions{}); err != nil {","\t\t\tlogger.Error(err, \"finding %s failed: %s\", roleKind, roleName)","\t\t\treturn err","\t\t}","\t} else {","\t\treturn fmt.Errorf(\"incorrect value set for roleKind - %s, needs to be Role or ClusterRole\", roleKind)","\t}","","\tlogger.Info(\"finding role-binding\", pipelinesSCCRoleBinding)","\tpipelineRB, rbErr := rbacClient.RoleBindings(sa.Namespace).Get(ctx, pipelinesSCCRoleBinding, metav1.GetOptions{})","\tif rbErr != nil \u0026\u0026 !errors.IsNotFound(rbErr) {","\t\tlogger.Error(rbErr, \"rbac get error\", pipelinesSCCRoleBinding)","\t\treturn rbErr","\t}","","\tif rbErr != nil \u0026\u0026 errors.IsNotFound(rbErr) {","\t\treturn r.createSCCRoleBinding(ctx, sa, roleRef)","\t}","","\t// We cannot update RoleRef in a RoleBinding, we need to delete and","\t// recreate the binding in that case","\tif pipelineRB.RoleRef.Kind != roleKind || pipelineRB.RoleRef.Name != roleName {","\t\tlogger.Infof(\"Need to update RoleRef in RoleBinding %s in namespace: %s, deleting and recreating...\", pipelinesSCCRoleBinding, sa.Namespace)","\t\terr := rbacClient.RoleBindings(sa.Namespace).Delete(ctx, pipelinesSCCRoleBinding, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\treturn r.createSCCRoleBinding(ctx, sa, roleRef)","\t}","","\tlogger.Info(\"found rbac\", \"subjects\", pipelineRB.Subjects)","\treturn r.updateRoleBinding(ctx, pipelineRB, sa, roleRef)","}","","func (r *rbac) createSCCRoleBinding(ctx context.Context, sa *corev1.ServiceAccount, roleRef *rbacv1.RoleRef) error {","\tlogger := logging.FromContext(ctx)","\trbacClient := r.kubeClientSet.RbacV1()","","\tlogger.Info(\"create new rolebinding:\", pipelinesSCCRoleBinding)","\trb := \u0026rbacv1.RoleBinding{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            pipelinesSCCRoleBinding,","\t\t\tNamespace:       sa.Namespace,","\t\t\tOwnerReferences: []metav1.OwnerReference{r.ownerRef},","\t\t},","\t\tRoleRef:  *roleRef,","\t\tSubjects: []rbacv1.Subject{{Kind: rbacv1.ServiceAccountKind, Name: sa.Name, Namespace: sa.Namespace}},","\t}","","\t_, err := rbacClient.RoleBindings(sa.Namespace).Create(ctx, rb, metav1.CreateOptions{})","\tif err != nil {","\t\tlogger.Error(err, \"creation of rolebinding failed:\", pipelinesSCCRoleBinding)","\t}","\treturn err","}","","func (r *rbac) updateRoleBinding(ctx context.Context, rb *rbacv1.RoleBinding, sa *corev1.ServiceAccount, roleRef *rbacv1.RoleRef) error {","\tlogger := logging.FromContext(ctx)","","\tsubject := rbacv1.Subject{Kind: rbacv1.ServiceAccountKind, Name: sa.Name, Namespace: sa.Namespace}","","\thasSubject := hasSubject(rb.Subjects, subject)","\tif !hasSubject {","\t\trb.Subjects = append(rb.Subjects, subject)","\t}","","\trb.RoleRef = *roleRef","","\trbacClient := r.kubeClientSet.RbacV1()","\thasOwnerRef := hasOwnerRefernce(rb.GetOwnerReferences(), r.ownerRef)","","\townerRef := r.updateOwnerRefs(rb.GetOwnerReferences())","\trb.SetOwnerReferences(ownerRef)","","\t// If owners are different then we need to set from r.ownerRef and update the roleBinding.","\tif !hasOwnerRef {","\t\tif _, err := rbacClient.RoleBindings(sa.Namespace).Update(ctx, rb, metav1.UpdateOptions{}); err != nil {","\t\t\tlogger.Error(err, \"failed to update edit rb\")","\t\t\treturn err","\t\t}","\t}","","\tif hasSubject \u0026\u0026 (len(ownerRef) != 0) {","\t\tlogger.Info(\"rolebinding is up to date \", \"action \", \"none\")","\t\treturn nil","\t}","","\tlogger.Infof(\"update existing rolebinding %s/%s\", rb.Namespace, rb.Name)","","\t_, err := rbacClient.RoleBindings(sa.Namespace).Update(ctx, rb, metav1.UpdateOptions{})","\tif err != nil {","\t\tlogger.Errorf(\"%v: failed to update rolebinding %s/%s\", err, rb.Namespace, rb.Name)","\t\treturn err","\t}","\tlogger.Infof(\"successfully updated rolebinding %s/%s\", rb.Namespace, rb.Name)","\treturn nil","}","","func hasSubject(subjects []rbacv1.Subject, x rbacv1.Subject) bool {","\tfor _, v := range subjects {","\t\tif v.Name == x.Name \u0026\u0026 v.Kind == x.Kind \u0026\u0026 v.Namespace == x.Namespace {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","// CompareLists compares two slices of rbacv1.Subject, ignoring order","func CompareSubjects(list1, list2 []rbacv1.Subject) bool {","\t// Check if lengths are different","\tif len(list1) != len(list2) {","\t\treturn false","\t}","\t// Create sets (maps) for both lists","\tset1 := make(map[string]struct{})","\tset2 := make(map[string]struct{})","","\t// Populate set1 with subjects from list1","\tfor _, subject := range list1 {","\t\tkey := fmt.Sprintf(\"%s/%s/%s\", subject.Kind, subject.Name, subject.Namespace)","\t\tset1[key] = struct{}{}","\t}","\t// Populate set2 with subjects from list2","\tfor _, subject := range list2 {","\t\tkey := fmt.Sprintf(\"%s/%s/%s\", subject.Kind, subject.Name, subject.Namespace)","\t\tset2[key] = struct{}{}","\t}","","\t// Compare the sets","\tif len(set1) != len(set2) {","\t\treturn false","\t}","","\t// Check if all elements in set1 are in set2","\tfor key := range set1 {","\t\tif _, exists := set2[key]; !exists {","\t\t\treturn false","\t\t}","\t}","\treturn true","}","","func mergeSubjects(subjects []rbacv1.Subject, x []rbacv1.Subject) []rbacv1.Subject {","\t// Map to track subjects in the existing list","\texistingSubjects := make(map[string]struct{})","","\t// Iterate over `subjects` and track each unique combination of Kind, Name, and Namespace","\tfor _, subject := range subjects {","\t\tkey := fmt.Sprintf(\"%s/%s/%s\", subject.Kind, subject.Name, subject.Namespace)","\t\texistingSubjects[key] = struct{}{}","\t}","","\t// Final list to store the merged subjects","\tvar finalSubjects []rbacv1.Subject","","\t// Add all subjects from the original list (list1)","\tfinalSubjects = append(finalSubjects, subjects...)","","\t// Append subjects from `x` (list2) that are not in `existingSubjects`","\tfor _, subject := range x {","\t\tkey := fmt.Sprintf(\"%s/%s/%s\", subject.Kind, subject.Name, subject.Namespace)","\t\tif _, found := existingSubjects[key]; !found {","\t\t\tfinalSubjects = append(finalSubjects, subject)","\t\t}","\t}","","\treturn finalSubjects","}","","func hasOwnerRefernce(old []metav1.OwnerReference, new metav1.OwnerReference) bool {","\tfor _, v := range old {","\t\tif v.APIVersion == new.APIVersion \u0026\u0026 v.Kind == new.Kind \u0026\u0026 v.Name == new.Name {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","func (r *rbac) isLegacyRBACEnabled() bool {","\tfor _, v := range r.tektonConfig.Spec.Params {","\t\tif v.Name == legacyPipelineRbacParamName {","\t\t\treturn v.Value != \"false\"","\t\t}","\t}","\treturn true","}","","func (r *rbac) ensureRoleBindings(ctx context.Context, sa *corev1.ServiceAccount) error {","\tlogger := logging.FromContext(ctx)","\trbacClient := r.kubeClientSet.RbacV1()","","\tlegacyEnabled := r.isLegacyRBACEnabled()","","\teditRB, err := rbacClient.RoleBindings(sa.Namespace).Get(ctx, PipelineRoleBinding, metav1.GetOptions{})","","\tif !legacyEnabled \u0026\u0026 err == nil {","\t\tlogger.Infof(\"Legacy Pipeline RBAC is disabled, removing existing role binding %s/%s\",","\t\t\teditRB.Namespace, editRB.Name)","\t\treturn rbacClient.RoleBindings(sa.Namespace).Delete(ctx, PipelineRoleBinding, metav1.DeleteOptions{})","\t}","","\tif !legacyEnabled {","\t\tlogger.Infof(\"Legacy Pipeline RBAC is disabled, skipping role binding creation\")","\t\treturn nil","\t}","","\tlogger.Infof(\"Legacy Pipeline RBAC is enabled\")","","\tif err == nil {","\t\tlogger.Infof(\"Found rolebinding %s/%s, updating if needed\", editRB.Namespace, editRB.Name)","\t\treturn r.updateRoleBinding(ctx, editRB, sa, \u0026rbacv1.RoleRef{","\t\t\tAPIGroup: rbacv1.GroupName,","\t\t\tKind:     \"ClusterRole\",","\t\t\tName:     \"edit\",","\t\t})","\t}","","\tif errors.IsNotFound(err) {","\t\tlogger.Infof(\"Role binding not found, creating new one\")","\t\treturn r.createRoleBinding(ctx, sa)","\t}","","\treturn err","}","","func (r *rbac) createRoleBinding(ctx context.Context, sa *corev1.ServiceAccount) error {","\tlogger := logging.FromContext(ctx)","","\tlogger.Infof(\"create new rolebinding %s/%s\", sa.Namespace, sa.Name)","\trbacClient := r.kubeClientSet.RbacV1()","","\tlogger.Info(\"finding clusterrole edit\")","\tif _, err := rbacClient.ClusterRoles().Get(ctx, \"edit\", metav1.GetOptions{}); err != nil {","\t\tlogger.Error(err, \"getting clusterRole 'edit' failed\")","\t\treturn err","\t}","","\trb := \u0026rbacv1.RoleBinding{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            PipelineRoleBinding,","\t\t\tNamespace:       sa.Namespace,","\t\t\tOwnerReferences: []metav1.OwnerReference{r.ownerRef},","\t\t},","\t\tRoleRef:  rbacv1.RoleRef{APIGroup: rbacv1.GroupName, Kind: \"ClusterRole\", Name: \"edit\"},","\t\tSubjects: []rbacv1.Subject{{Kind: rbacv1.ServiceAccountKind, Name: sa.Name, Namespace: sa.Namespace}},","\t}","","\tif _, err := rbacClient.RoleBindings(sa.Namespace).Create(ctx, rb, metav1.CreateOptions{}); err != nil {","\t\tlogger.Errorf(\"%v: failed creation of rolebinding %s/%s\", err, rb.Namespace, rb.Name)","\t\treturn err","\t}","\treturn nil","}","","func (r *rbac) removeAndUpdateNSFromCI(ctx context.Context) error {","\tlogger := logging.FromContext(ctx)","","\trbacClient := r.kubeClientSet.RbacV1()","\trb, err := r.rbacInformer.Lister().Get(clusterInterceptors)","\tif err != nil \u0026\u0026 !errors.IsNotFound(err) {","\t\tlogger.Error(err, \"failed to get\"+clusterInterceptors)","\t\treturn err","\t}","\tif rb == nil {","\t\treturn nil","\t}","","\treq, err := labels.NewRequirement(namespaceVersionLabel, selection.Equals, []string{r.version})","\tif err != nil {","\t\tlogger.Error(err, \"failed to create requirement: \")","\t\treturn err","\t}","","\tnamespaces, err := r.nsInformer.Lister().List(labels.NewSelector().Add(*req))","\tif err != nil \u0026\u0026 !errors.IsNotFound(err) {","\t\tlogger.Error(err, \"failed to list namespace: \")","\t\treturn err","\t}","","\tnsMap := map[string]string{}","\tfor i := range namespaces {","\t\tnsMap[namespaces[i].Name] = namespaces[i].Name","\t}","","\tvar update bool","\tfor i := 0; i \u003c= len(rb.Subjects)-1; i++ {","\t\tif len(nsMap) != len(rb.Subjects) {","\t\t\tif _, ok := nsMap[rb.Subjects[i].Namespace]; !ok {","\t\t\t\trb.Subjects = removeIndex(rb.Subjects, i)","\t\t\t\tupdate = true","\t\t\t}","\t\t}","\t}","\tif update {","\t\tif _, err := rbacClient.ClusterRoleBindings().Update(ctx, rb, metav1.UpdateOptions{}); err != nil {","\t\t\tlogger.Error(err, \"failed to update \"+clusterInterceptors+\" crb\")","\t\t\treturn err","\t\t}","\t\tlogger.Infof(\"successfully removed namespace and updated %s \", clusterInterceptors)","\t}","\treturn nil","}","","func removeIndex(s []rbacv1.Subject, index int) []rbacv1.Subject {","\treturn append(s[:index], s[index+1:]...)","}","","func (r *rbac) handleClusterRoleBinding(ctx context.Context, namespacesToUpdate []NamespaceServiceAccount) error {","\tlogger := logging.FromContext(ctx)","","\trbacClient := r.kubeClientSet.RbacV1()","\tlogger.Info(\"finding cluster-role \", clusterInterceptors)","\tif _, err := rbacClient.ClusterRoles().Get(ctx, clusterInterceptors, metav1.GetOptions{}); errors.IsNotFound(err) {","\t\tif e := r.createClusterRole(ctx); e != nil {","\t\t\treturn e","\t\t}","\t}","","\t// Prepare a list of Subjects from the namespacesToUpdate","\tvar subjects []rbacv1.Subject","","\tfor _, nsSA := range namespacesToUpdate {","\t\tsa := nsSA.ServiceAccount","\t\tns := nsSA.Namespace","","\t\tlogger.Infof(\"Processing Subject for ServiceAccount %s in Namespace %s\", sa.Name, ns.Name)","","\t\t// Create the Subject for the ClusterRoleBinding","\t\tsubject := rbacv1.Subject{","\t\t\tKind:      rbacv1.ServiceAccountKind,","\t\t\tName:      sa.Name,","\t\t\tNamespace: sa.Namespace,","\t\t}","","\t\t// Append the subject to the list","\t\tsubjects = append(subjects, subject)","\t}","","\tlogger.Info(\"finding cluster-role-binding \", clusterInterceptors)","","\tviewCRB, err := rbacClient.ClusterRoleBindings().Get(ctx, clusterInterceptors, metav1.GetOptions{})","","\tif err == nil {","\t\tlogger.Infof(\"found clusterrolebinding %s\", viewCRB.Name)","\t\treturn r.bulkUpdateClusterRoleBinding(ctx, viewCRB, subjects)","\t}","","\tif errors.IsNotFound(err) {","\t\tlogger.Infof(\"could not find clusterrolebinding %s proceeding to create\", viewCRB.Name)","\t\treturn r.bulkCreateClusterRoleBinding(ctx, subjects)","\t}","","\treturn err","}","","// bulk update Cluster rolebinding with all reconciled namespaces and service accounts","func (r *rbac) bulkUpdateClusterRoleBinding(ctx context.Context, rb *rbacv1.ClusterRoleBinding, subjectlist []rbacv1.Subject) error {","\tlogger := logging.FromContext(ctx)","","\thasSubject := CompareSubjects(rb.Subjects, subjectlist)","\tif !hasSubject {","\t\trb.Subjects = mergeSubjects(rb.Subjects, subjectlist)","\t}","","\trbacClient := r.kubeClientSet.RbacV1()","\thasOwnerRef := hasOwnerRefernce(rb.GetOwnerReferences(), r.ownerRef)","","\townerRef := r.updateOwnerRefs(rb.GetOwnerReferences())","\trb.SetOwnerReferences(ownerRef)","","\t// If owners are different then we need to set from r.ownerRef and update the clusterRolebinding.","\tif !hasOwnerRef {","\t\tif _, err := rbacClient.ClusterRoleBindings().Update(ctx, rb, metav1.UpdateOptions{}); err != nil {","\t\t\tlogger.Error(err, \"failed to update \"+clusterInterceptors+\" crb\")","\t\t\treturn err","\t\t}","\t}","","\tif hasSubject \u0026\u0026 (len(ownerRef) != 0) {","\t\tlogger.Info(\"clusterrolebinding is up to date\", \"action\", \"none\")","\t\treturn nil","\t}","","\tlogger.Info(\"update existing clusterrolebinding \", clusterInterceptors)","","\tif _, err := rbacClient.ClusterRoleBindings().Update(ctx, rb, metav1.UpdateOptions{}); err != nil {","\t\tlogger.Error(err, \"failed to update \"+clusterInterceptors+\" crb\")","\t\treturn err","\t}","\tlogger.Info(\"successfully updated \", clusterInterceptors)","\treturn nil","}","","// create Cluster rolebinding with all reconciled namespaces and service accounts","func (r *rbac) bulkCreateClusterRoleBinding(ctx context.Context, subjectlist []rbacv1.Subject) error {","\tlogger := logging.FromContext(ctx)","","\tlogger.Info(\"create new clusterrolebinding \", clusterInterceptors)","\trbacClient := r.kubeClientSet.RbacV1()","","\tlogger.Info(\"finding clusterrole \", clusterInterceptors)","\tif _, err := rbacClient.ClusterRoles().Get(ctx, clusterInterceptors, metav1.GetOptions{}); err != nil {","\t\tlogger.Error(err, \" getting clusterRole \"+clusterInterceptors+\" failed\")","\t\treturn err","\t}","","\tcrb := \u0026rbacv1.ClusterRoleBinding{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            clusterInterceptors,","\t\t\tOwnerReferences: []metav1.OwnerReference{r.ownerRef},","\t\t},","\t\tRoleRef:  rbacv1.RoleRef{APIGroup: rbacv1.GroupName, Kind: \"ClusterRole\", Name: clusterInterceptors},","\t\tSubjects: subjectlist,","\t}","","\tif _, err := rbacClient.ClusterRoleBindings().Create(ctx, crb, metav1.CreateOptions{}); err != nil {","\t\tlogger.Error(err, \" creation of \"+clusterInterceptors+\" failed\")","\t\treturn err","\t}","\treturn nil","}","","func (r *rbac) createClusterRole(ctx context.Context) error {","\tlogger := logging.FromContext(ctx)","","\tlogger.Info(\"create new clusterrole \", clusterInterceptors)","\trbacClient := r.kubeClientSet.RbacV1()","","\tcr := \u0026rbacv1.ClusterRole{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            clusterInterceptors,","\t\t\tOwnerReferences: []metav1.OwnerReference{r.ownerRef},","\t\t},","\t\tRules: []rbacv1.PolicyRule{{","\t\t\tAPIGroups: []string{\"triggers.tekton.dev\"},","\t\t\tResources: []string{\"clusterinterceptors\"},","\t\t\tVerbs:     []string{\"get\", \"list\", \"watch\"},","\t\t}},","\t}","","\tif _, err := rbacClient.ClusterRoles().Create(ctx, cr, metav1.CreateOptions{}); err != nil {","\t\tlogger.Error(err, \"creation of \"+clusterInterceptors+\" clusterrole failed\")","\t\treturn err","\t}","\treturn nil","}","","func (r *rbac) updateOwnerRefs(ownerRef []metav1.OwnerReference) []metav1.OwnerReference {","\tif len(ownerRef) == 0 {","\t\treturn []metav1.OwnerReference{r.ownerRef}","\t}","","\tfor i, ref := range ownerRef {","\t\tif ref.APIVersion != r.ownerRef.APIVersion || ref.Kind != r.ownerRef.Kind || ref.Name != r.ownerRef.Name {","\t\t\t// if owner reference are different remove the existing oand override with r.ownerRef","\t\t\treturn r.removeAndUpdate(ownerRef, i)","\t\t}","\t}","","\treturn ownerRef","}","","func (r *rbac) removeAndUpdate(slice []metav1.OwnerReference, s int) []metav1.OwnerReference {","\townerRef := append(slice[:s], slice[s+1:]...)","\townerRef = append(ownerRef, r.ownerRef)","\treturn ownerRef","}","","// TODO: Remove this after v0.55.0 release, by following a depreciation notice","// --------------------","// cleanUpRBACNameChange will check remove ownerReference: RBAC installerset from","// 'edit' rolebindings from all relevant namespaces","// it will also remove 'pipeline' sa from subject list as","// the new 'openshift-pipelines-edit' rolebinding","func (r *rbac) cleanUpRBACNameChange(ctx context.Context) error {","\trbacClient := r.kubeClientSet.RbacV1()","","\t// fetch the list of all namespaces","\tnamespaces, err := r.kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn err","\t}","","\tfor _, ns := range namespaces.Items {","\t\tnsName := ns.GetName()","","\t\t// filter namespaces:","\t\t// ignore ns with name passing regex `^(openshift|kube)-`","\t\tif ignore := nsRegex.MatchString(nsName); ignore {","\t\t\tcontinue","\t\t}","","\t\t// check if \"edit\" rolebinding exists in \"ns\" namespace","\t\teditRB, err := rbacClient.RoleBindings(ns.GetName()).","\t\t\tGet(ctx, pipelineRoleBindingOld, metav1.GetOptions{})","\t\tif err != nil {","\t\t\t// if \"edit\" rolebinding does not exists in \"ns\" namesapce, then do nothing","\t\t\tif errors.IsNotFound(err) {","\t\t\t\tcontinue","\t\t\t}","\t\t\treturn err","\t\t}","","\t\t// check if 'pipeline' serviceaccount is listed as a subject in 'edit' rolebinding","\t\tdepSub := rbacv1.Subject{Kind: rbacv1.ServiceAccountKind, Name: pipelineSA, Namespace: nsName}","\t\tsubIdx := math.MinInt16","\t\tfor i, s := range editRB.Subjects {","\t\t\tif s.Name == depSub.Name \u0026\u0026 s.Kind == depSub.Kind \u0026\u0026 s.Namespace == depSub.Namespace {","\t\t\t\tsubIdx = i","\t\t\t\tbreak","\t\t\t}","\t\t}","","\t\t// if 'pipeline' serviceaccount is listed as a subject in 'edit' rolebinding","\t\t// remove 'pipeline' serviceaccount from subject list","\t\tif subIdx \u003e= 0 {","\t\t\teditRB.Subjects = append(editRB.Subjects[:subIdx], editRB.Subjects[subIdx+1:]...)","\t\t}","","\t\t// if 'pipeline' serviceaccount was the only item in the subject list of 'edit' rolebinding,","\t\t// then we can delete 'edit' rolebinding as nobody else is using it","\t\tif len(editRB.Subjects) == 0 {","\t\t\tif err := rbacClient.RoleBindings(nsName).Delete(ctx, editRB.GetName(), metav1.DeleteOptions{}); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tcontinue","\t\t}","","\t\t// remove TektonInstallerSet ownerReferece from \"edit\" rolebinding","\t\townerRefs := editRB.GetOwnerReferences()","\t\townerRefIdx := math.MinInt16","\t\tfor i, ownerRef := range ownerRefs {","\t\t\tif ownerRef.Kind == \"TektonInstallerSet\" {","\t\t\t\townerRefIdx = i","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif ownerRefIdx \u003e= 0 {","\t\t\townerRefs := append(ownerRefs[:ownerRefIdx], ownerRefs[ownerRefIdx+1:]...)","\t\t\teditRB.SetOwnerReferences(ownerRefs)","","\t\t}","","\t\t// if ownerReference or subject was updated, then update editRB resource on cluster","\t\tif ownerRefIdx \u003c 0 \u0026\u0026 subIdx \u003c 0 {","\t\t\tcontinue","\t\t}","\t\tif _, err := rbacClient.RoleBindings(nsName).Update(ctx, editRB, metav1.UpdateOptions{}); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","// TODO: Remove this after v0.55.0 release, by following a depreciation notice","// --------------------","func (r *rbac) removeObsoleteRBACInstallerSet(ctx context.Context) error {","\tisClient := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets()","\terr := isClient.Delete(ctx, rbacInstallerSetNameOld, metav1.DeleteOptions{})","\tif err != nil {","\t\tif !errors.IsNotFound(err) {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func (r *rbac) ensureCABundlesInNamespace(ctx context.Context, ns *corev1.Namespace) error {","\tlogger := logging.FromContext(ctx)","\tlogger.Infow(\"Ensuring CA bundle configmaps in namespace\", \"namespace\", ns.GetName())","\treturn r.ensureCABundles(ctx, ns)","}","","// Add new method for patching namespace with trusted configmaps label","func (r *rbac) patchNamespaceTrustedConfigLabel(ctx context.Context, ns corev1.Namespace) error {","\tlogger := logging.FromContext(ctx)","","\tlogger.Infof(\"add label namespace-trusted-configmaps-version to mark namespace '%s' as reconciled\", ns.Name)","","\t// Prepare a patch to add/update just one label without overwriting others","\tpatch := map[string]interface{}{","\t\t\"metadata\": map[string]interface{}{","\t\t\t\"labels\": map[string]interface{}{","\t\t\t\tnamespaceTrustedConfigLabel: r.version,","\t\t\t},","\t\t},","\t}","","\tpatchPayload, err := json.Marshal(patch)","\tif err != nil {","\t\tlogger.Errorf(\"failed to marshal patch payload: %v\", err)","\t\treturn fmt.Errorf(\"failed to marshal label patch for namespace %s: %w\", ns.Name, err)","\t}","","\t// Use PATCH to update just the target label","\tif _, err := r.kubeClientSet.CoreV1().Namespaces().Patch(ctx, ns.Name, types.StrategicMergePatchType, patchPayload, metav1.PatchOptions{}); err != nil {","\t\tlogger.Errorf(\"failed to patch namespace %s: %v\", ns.Name, err)","\t\treturn fmt.Errorf(\"failed to patch namespace %s: %w\", ns.Name, err)","\t}","","\tlogger.Infof(\"namespace '%s' successfully reconciled with label %q=%q\", ns.Name, namespaceTrustedConfigLabel, r.version)","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,1,0,2,1,1,1,1,1,1,0,2,0,0,2,2,1,1,0,2,2,1,1,0,2,2,2,0,0,0,0,0,2,2,1,1,0,2,2,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,1,1,0,2,2,1,1,0,0,2,2,1,1,1,0,1,1,1,1,1,1,1,1,1,2,2,2,0,0,0,0,0,0,2,1,1,0,2,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,1,1,0,0,0,2,1,1,0,0,0,2,2,2,1,1,0,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,0,0,2,2,2,2,0,0,2,0,0,2,2,2,2,2,1,1,1,1,1,1,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,1,1,1,1,1,0,0,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,2,2,2,2,2,2,2,1,1,0,2,1,1,0,0,2,1,1,0,0,2,2,2,1,1,0,0,0,2,1,1,0,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,1,1,1,0,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,0,0,2,2,2,2,2,0,0,0,2,2,1,1,1,0,0,2,1,1,1,0,0,2,2,1,2,2,2,2,2,1,1,1,0,2,2,2,2,2,2,1,1,0,2,0,0,0,2,2,1,1,1,2,2,2,2,2,2,1,1,0,0,0,0,0,0,2,2,1,2,2,2,2,2,2,1,1,0,0,2,1,1,0,0,0,0,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,1,1,0,0,0,2,1,1,1,1,0,0,0,2,2,2,1,1,0,2,2,2,2,1,1,0,0,0,2,1,1,1,1,0,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,2,2,2,1,1,2,2,2,2,0,0,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,0,0,2,2,2,2,2,2,2,1,1,1,1,1,2,2,2,1,1,1,1,1,1,0,2,2,2,1,1,1,0,2,2,2,0,0,0,1,1,1,1,1,1,1,0,0,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,1,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,1,1,1,1,0,2,1,1,1,0,2,2,2,1,1,1,1,1,1,1,0,2,2,2,2,0,1,0,0,2,2,2,2,2,2,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,0,0,2,2,2,2,2,2,1,1,1,2,2,2,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,0,0,1,1,1,0,2,2,2,2,2,2,2,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,1,1,1,0,2,2,2,2,0,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,2,1,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,0,0,1,1,1,1,0,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,0,1,1,1,0,1,0,0,0,0,2,2,2,2,2,1,1,0,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,1,1,1,0,2,2,0]},{"id":177,"path":"pkg/reconciler/openshift/tektonhub/controller.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonhub","","import (","\t\"context\"","","\tk8s_ctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonhub\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":178,"path":"pkg/reconciler/openshift/tektonhub/extension.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonhub","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","\t\"strings\"","","\t\"github.com/go-logr/zapr\"","\tmfc \"github.com/manifestival/client-go-client\"","\tmf \"github.com/manifestival/manifestival\"","\tconsole \"github.com/openshift/api/console/v1\"","\troutev1 \"github.com/openshift/api/route/v1\"","\t\"github.com/openshift/client-go/route/clientset/versioned/scheme\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\topenshiftCommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"","\t\"go.uber.org/zap\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/client-go/kubernetes\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const (","\thubprefix                    string = \"tekton-hub\"","\ttektonHubAPIResourceKey      string = \"api\"","\ttektonHubUiResourceKey       string = \"ui\"","\tCreatedByValue               string = \"TektonHub\"","\tConsoleHubLinkInstallerSet          = \"ConsoleHubLink\"","\tpostgreSQLConfigMapDirectory        = \"static/tekton-hub/postgresql-cm\"",")","","var replaceVal = map[string]string{","\t\"POSTGRES_DB\":       \"POSTGRESQL_DATABASE\",","\t\"POSTGRES_USER\":     \"POSTGRESQL_USER\",","\t\"POSTGRES_PASSWORD\": \"POSTGRESQL_PASSWORD\",","}","","var (","\tdb  string = fmt.Sprintf(\"%s-%s\", hubprefix, \"db\")","\tapi string = fmt.Sprintf(\"%s-%s\", hubprefix, \"api\")","\tui  string = fmt.Sprintf(\"%s-%s\", hubprefix, \"ui\")",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\tlogger := logging.FromContext(ctx)","\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\tif err != nil {","\t\tlogger.Fatalw(\"error creating client from injected config\", zap.Error(err))","\t}","\tmflogger := zapr.NewLogger(logger.Named(\"manifestival\").Desugar())","\tmanifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))","\tif err != nil {","\t\tlogger.Fatalw(\"error creating initial manifest\", zap.Error(err))","\t}","","\text := openshiftExtension{","\t\toperatorClientSet: operatorclient.Get(ctx),","\t\tkubeClientSet:     kubeclient.Get(ctx),","\t\tmanifest:          manifest,","\t}","\treturn ext","}","","type openshiftExtension struct {","\toperatorClientSet clientset.Interface","\tkubeClientSet     kubernetes.Interface","\tmanifest          mf.Manifest","}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\tUpdateDbDeployment(),","\t\tinjectPostgresUpgradeSupport(),","\t\topenshiftCommon.RemoveRunAsUser(),","\t\topenshiftCommon.RemoveRunAsUserForJob(),","\t\topenshiftCommon.RemoveFsGroupForDeployment(),","\t\topenshiftCommon.RemoveFsGroupForJob(),","\t}","}","","func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\tth := tc.(*v1alpha1.TektonHub)","\tlogger := logging.FromContext(ctx)","\ttargetNs := th.Spec.GetTargetNamespace()","\thubDir := filepath.Join(common.ComponentDir(th), common.TargetVersion(th), tektonHubAPIResourceKey)","\tmanifest := oe.manifest.Append()","","\tif err := common.AppendManifest(\u0026manifest, hubDir); err != nil {","\t\treturn err","\t}","","\t// Fetch and append the postgresql config map which has postgresupgrade wrapper script","\tpostgresqlCMDir := filepath.Join(common.ComponentBaseDir(), postgreSQLConfigMapDirectory)","\tpostgresqlManifest := oe.manifest.Append()","\tif err := common.AppendManifest(\u0026postgresqlManifest, postgresqlCMDir); err != nil {","\t\treturn err","\t}","","\t// Transform and apply the postgresql ConfigMap","\tpostgresqlManifest, err := postgresqlManifest.Transform(","\t\tmf.InjectOwner(th),","\t\tmf.InjectNamespace(targetNs),","\t)","\tif err != nil {","\t\tlogger.Error(\"failed to transform postgresql configmap manifest\")","\t\treturn err","\t}","\tif err := postgresqlManifest.Apply(); err != nil {","\t\tlogger.Error(\"failed to apply postgresql configmap manifest\")","\t\treturn err","\t}","","\tapiRouteManifest := manifest.Filter(mf.ByKind(\"Route\"))","\tapiRouteManifest, err = apiRouteManifest.Transform(","\t\tmf.InjectOwner(th),","\t\tmf.InjectNamespace(targetNs),","\t)","\tif err != nil {","\t\tlogger.Error(\"failed to transform manifest\")","\t\treturn err","\t}","\tif err := apiRouteManifest.Apply(); err != nil {","\t\treturn err","\t}","","\t// Get the host of API route","\tapiRoute, err := getRouteHost(\u0026apiRouteManifest, api)","\tif err != nil {","\t\treturn err","\t}","\tth.Status.SetApiRoute(fmt.Sprintf(\"https://%s\", apiRoute))","","\t// Set Auth Url in Tekton Hub Status","\tif err := oe.SetAuthBaseURL(ctx, th, apiRouteManifest); err != nil {","\t\treturn err","\t}","","\t// Create UI route based on the value of ui i.e. false/true","\tuiHubDir := filepath.Join(common.ComponentDir(th), common.TargetVersion(th), tektonHubUiResourceKey)","\tuiManifest := oe.manifest.Append()","","\tif err := common.AppendManifest(\u0026uiManifest, uiHubDir); err != nil {","\t\treturn err","\t}","","\tuiRouteManifest := uiManifest.Filter(mf.ByKind(\"Route\"))","\tuiRouteManifest, err = uiRouteManifest.Transform(","\t\tmf.InjectOwner(th),","\t\tmf.InjectNamespace(targetNs),","\t)","\tif err != nil {","\t\tlogger.Error(\"failed to transform manifest\")","\t\treturn err","\t}","\tif err := uiRouteManifest.Apply(); err != nil {","\t\treturn err","\t}","","\tuiRoute, err := getRouteHost(\u0026uiRouteManifest, ui)","\tif err != nil {","\t\treturn err","\t}","","\tth.Status.SetUiRoute(fmt.Sprintf(\"https://%s\", uiRoute))","","\treturn nil","}","","func (oe openshiftExtension) PostReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\tth := tc.(*v1alpha1.TektonHub)","\tconsoleCLILS := metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.InstallerSetType: ConsoleHubLinkInstallerSet,","\t\t},","\t}","","\tconsoleHubLinkLabelSelector, err := common.LabelSelector(consoleCLILS)","\tif err != nil {","\t\treturn err","\t}","","\texist, err := checkIfInstallerSetExist(ctx, oe.operatorClientSet, common.TargetVersion(th), consoleHubLinkLabelSelector)","\tif err != nil {","\t\treturn err","\t}","","\tif !exist {","\t\thubConsoleLinkManifest := oe.manifest.Append()","\t\tif err := applyHubConsoleLinkManifest(\u0026hubConsoleLinkManifest); err != nil {","\t\t\treturn err","\t\t}","","\t\tif err := consoleLinkTransform(ctx, \u0026hubConsoleLinkManifest, th.Status.GetUiRoute()); err != nil {","\t\t\treturn err","\t\t}","","\t\tif err := createInstallerSet(ctx, oe.operatorClientSet, th, hubConsoleLinkManifest,","\t\t\tcommon.TargetVersion(th), ConsoleHubLinkInstallerSet, \"console-link-hub\"); err != nil {","\t\t\treturn err","\t\t}","\t}","","\treturn nil","}","","func checkIfInstallerSetExist(ctx context.Context, oc clientset.Interface, relVersion string,","\tlabelSelector string) (bool, error) {","","\tinstallerSets, err := oc.OperatorV1alpha1().TektonInstallerSets().","\t\tList(ctx, metav1.ListOptions{","\t\t\tLabelSelector: labelSelector,","\t\t})","\tif err != nil {","\t\treturn false, err","\t}","","\tif len(installerSets.Items) == 0 {","\t\treturn false, nil","\t}","","\tif len(installerSets.Items) == 1 {","\t\t// if already created then check which version it is","\t\tversion, ok := installerSets.Items[0].Labels[v1alpha1.ReleaseVersionKey]","\t\tif ok \u0026\u0026 version == relVersion {","\t\t\t// if installer set already exist and release version is same","\t\t\t// then ignore and move on","\t\t\treturn true, nil","\t\t}","\t}","","\t// release version doesn't exist or is different from expected","\t// deleted existing InstallerSet and create a new one","\t// or there is more than one installerset (unexpected)","\tif err = oc.OperatorV1alpha1().TektonInstallerSets().","\t\tDeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{","\t\t\tLabelSelector: labelSelector,","\t\t}); err != nil {","\t\treturn false, err","\t}","","\treturn false, v1alpha1.RECONCILE_AGAIN_ERR","}","","func createInstallerSet(ctx context.Context, oc clientset.Interface, ta *v1alpha1.TektonHub,","\tmanifest mf.Manifest, releaseVersion, component, installerSetPrefix string) error {","","\tis := makeInstallerSet(ta, manifest, installerSetPrefix, releaseVersion, component)","","\tif _, err := oc.OperatorV1alpha1().TektonInstallerSets().","\t\tCreate(ctx, is, metav1.CreateOptions{}); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","func makeInstallerSet(ta *v1alpha1.TektonHub, manifest mf.Manifest, prefix, releaseVersion, component string) *v1alpha1.TektonInstallerSet {","\townerRef := *metav1.NewControllerRef(ta, ta.GetGroupVersionKind())","\tlabels := map[string]string{","\t\tv1alpha1.CreatedByKey:      CreatedByValue,","\t\tv1alpha1.InstallerSetType:  component,","\t\tv1alpha1.ReleaseVersionKey: releaseVersion,","\t}","\tnamePrefix := fmt.Sprintf(\"%s-\", prefix)","","\treturn \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: namePrefix,","\t\t\tLabels:       labels,","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: ta.Spec.TargetNamespace,","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","}","","func applyHubConsoleLinkManifest(manifest *mf.Manifest) error {","\tkoDataDir := os.Getenv(common.KoEnvKey)","\tlocation := filepath.Join(koDataDir, \"openshift\", \"tekton-hub\")","\treturn common.AppendManifest(manifest, location)","}","","func consoleLinkTransform(ctx context.Context, manifest *mf.Manifest, baseURL string) error {","\tif baseURL == \"\" {","\t\treturn fmt.Errorf(\"route url should not be empty\")","\t}","\tlogger := logging.FromContext(ctx)","\tlogger.Debug(\"Transforming manifest\")","","\ttransformers := []mf.Transformer{","\t\treplaceURLConsoleLink(baseURL),","\t}","","\ttransformManifest, err := manifest.Transform(transformers...)","\tif err != nil {","\t\treturn err","\t}","","\t*manifest = transformManifest","\treturn nil","}","","func replaceURLConsoleLink(baseURL string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"ConsoleLink\" {","\t\t\treturn nil","\t\t}","\t\tcl := \u0026console.ConsoleLink{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cl)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcl.Spec.Href = baseURL","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cl)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","\t\treturn nil","\t}","}","","func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","","// Get the Host value of the Route created","func getRouteHost(manifest *mf.Manifest, routeName string) (string, error) {","\tvar hostUrl string","\tfor _, r := range manifest.Filter(mf.ByKind(\"Route\")).Resources() {","\t\tu, err := manifest.Client.Get(\u0026r)","\t\tif err != nil {","\t\t\treturn \"\", err","\t\t}","\t\tif u.GetName() == routeName {","\t\t\troute := \u0026routev1.Route{}","\t\t\tif err := scheme.Scheme.Convert(u, route, nil); err != nil {","\t\t\t\treturn \"\", err","\t\t\t}","\t\t\thostUrl = route.Spec.Host","\t\t}","\t}","\treturn hostUrl, nil","}","","func UpdateDbDeployment() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tif d.Name == db {","\t\t\tenv := d.Spec.Template.Spec.Containers[0].Env","","\t\t\treplaceEnv(env)","","\t\t\td.Spec.Template.Spec.Containers[0].Env = env","","\t\t\tmountPath := \"/var/lib/pgsql/data\"","\t\t\td.Spec.Template.Spec.Containers[0].VolumeMounts[0].MountPath = mountPath","","\t\t\treplaceProbeCommand(d.Spec.Template.Spec.Containers[0].ReadinessProbe.Exec.Command)","\t\t\treplaceProbeCommand(d.Spec.Template.Spec.Containers[0].LivenessProbe.Exec.Command)","","\t\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\tu.SetUnstructuredContent(unstrObj)","","\t\t\treturn nil","\t\t}","","\t\treturn nil","\t}","}","","func (oe openshiftExtension) SetAuthBaseURL(ctx context.Context, th *v1alpha1.TektonHub, apiRouteManifest mf.Manifest) error {","\t// Get the api secret","\tsecret, err := oe.kubeClientSet.CoreV1().Secrets(th.Spec.GetTargetNamespace()).Get(ctx, \"tekton-hub-api\", metav1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\tth.Status.SetAuthRoute(\"\")","\t\t} else {","\t\t\treturn err","\t\t}","\t}","","\tif len(secret.Data[\"GH_CLIENT_ID\"]) != 0 || len(secret.Data[\"GL_CLIENT_ID\"]) != 0 || len(secret.Data[\"BB_CLIENT_ID\"]) != 0 {","\t\t// Get the host of Auth route","\t\tauthRoute, err := getRouteHost(\u0026apiRouteManifest, \"tekton-hub-auth\")","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tth.Status.SetAuthRoute(fmt.Sprintf(\"https://%s\", authRoute))","","\t\tif secret.Data == nil || string(secret.Data[\"AUTH_BASE_URL\"]) != th.Status.AuthRouteUrl {","","\t\t\tif secret.StringData == nil {","\t\t\t\tsecret.StringData = make(map[string]string)","\t\t\t}","","\t\t\tsecret.StringData[\"AUTH_BASE_URL\"] = th.Status.AuthRouteUrl","","\t\t\t_, err = oe.kubeClientSet.CoreV1().Secrets(th.Spec.GetTargetNamespace()).Update(ctx, secret, metav1.UpdateOptions{})","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t} else {","\t\tth.Status.SetAuthRoute(\"\")","\t}","","\treturn nil","}","","func replaceProbeCommand(data []string) {","\tif strings.Contains(data[2], \"POSTGRES_USER\") {","\t\tdata[2] = strings.ReplaceAll(data[2], \"POSTGRES_USER\", \"POSTGRESQL_USER\")","\t}","\tif strings.Contains(data[2], \"POSTGRES_DB\") {","\t\tdata[2] = strings.ReplaceAll(data[2], \"POSTGRES_DB\", \"POSTGRESQL_DATABASE\")","\t}","}","","func replaceEnv(envs []corev1.EnvVar) {","\tfor i, e := range envs {","\t\t_, ok := replaceVal[e.Name]","\t\tif ok {","\t\t\tenvs[i].Name = replaceVal[e.Name]","\t\t}","\t\t// Update PGDATA value to match the new mount path","\t\tif e.Name == \"PGDATA\" {","\t\t\tenvs[i].Value = \"/var/lib/pgsql/data\"","\t\t}","\t}","}","","// injectPostgresUpgradeSupport modifies the postgres container to support automatic","// upgrade from PostgreSQL 13 to PostgreSQL 15. The wrapper script checks the PG_VERSION","// file in the data directory and sets POSTGRESQL_UPGRADE=copy if an upgrade is needed,","// triggering the sclorg container's built-in upgrade mechanism.","func injectPostgresUpgradeSupport() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\t// Only apply this transformer to the tekton-hub-db Deployment","\t\tif u.GetKind() != \"Deployment\" || u.GetName() != \"tekton-hub-db\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// Modify the main postgres container","\t\tfor i, container := range d.Spec.Template.Spec.Containers {","\t\t\tif container.Name == \"tekton-hub-db\" {","\t\t\t\t// Add volume mount for upgrade scripts","\t\t\t\tvmFound := false","\t\t\t\tfor _, vm := range container.VolumeMounts {","\t\t\t\t\tif vm.Name == \"upgrade-scripts\" {","\t\t\t\t\t\tvmFound = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif !vmFound {","\t\t\t\t\td.Spec.Template.Spec.Containers[i].VolumeMounts = append(","\t\t\t\t\t\tcontainer.VolumeMounts,","\t\t\t\t\t\tcorev1.VolumeMount{","\t\t\t\t\t\t\tName:      \"upgrade-scripts\",","\t\t\t\t\t\t\tMountPath: \"/upgrade-scripts\",","\t\t\t\t\t\t},","\t\t\t\t\t)","\t\t\t\t}","","\t\t\t\t// Change the command to use the wrapper script","\t\t\t\td.Spec.Template.Spec.Containers[i].Command = []string{","\t\t\t\t\t\"/bin/bash\",","\t\t\t\t\t\"/upgrade-scripts/postgres-wrapper.sh\",","\t\t\t\t}","\t\t\t}","\t\t}","","\t\t// Add volume for upgrade scripts ConfigMap","\t\tscriptsVolume := corev1.Volume{","\t\t\tName: \"upgrade-scripts\",","\t\t\tVolumeSource: corev1.VolumeSource{","\t\t\t\tConfigMap: \u0026corev1.ConfigMapVolumeSource{","\t\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\t\tName: \"tekton-hub-postgres-upgrade-scripts\",","\t\t\t\t\t},","\t\t\t\t\tDefaultMode: func() *int32 {","\t\t\t\t\t\tmode := int32(0755)","\t\t\t\t\t\treturn \u0026mode","\t\t\t\t\t}(),","\t\t\t\t},","\t\t\t},","\t\t}","","\t\tvolumeFound := false","\t\tfor i, vol := range d.Spec.Template.Spec.Volumes {","\t\t\tif vol.Name == \"upgrade-scripts\" {","\t\t\t\td.Spec.Template.Spec.Volumes[i] = scriptsVolume","\t\t\t\tvolumeFound = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !volumeFound {","\t\t\td.Spec.Template.Spec.Volumes = append(","\t\t\t\td.Spec.Template.Spec.Volumes,","\t\t\t\tscriptsVolume,","\t\t\t)","\t\t}","","\t\t// Convert back to unstructured","\t\tuObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,2,2,2,0,0,0,0,0,0,0,2,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,2,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,1,1,1,0,0,2,2,2,2,2,2,0,0,2,2,1,1,2,2,0,0]},{"id":179,"path":"pkg/reconciler/openshift/tektonpipeline/controller.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpipeline","","import (","\t\"context\"","","\tk8s_ctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":180,"path":"pkg/reconciler/openshift/tektonpipeline/extension.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpipeline","","import (","\t\"context\"","\t\"os\"","\t\"path/filepath\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\toccommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"","\t\"k8s.io/client-go/kubernetes\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tmonitoringLabelKey = \"openshift.io/cluster-monitoring\"","\tenableMetricsKey   = \"enableMetrics\"","\tversionKey         = \"VERSION\"","","\ttektonPipelinesControllerName       = \"tekton-pipelines-controller\"","\ttektonRemoteResolversControllerName = \"tekton-pipelines-remote-resolvers\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\tlogger := logging.FromContext(ctx)","\tversion := os.Getenv(versionKey)","\tif version == \"\" {","\t\tlogger.Fatal(\"Failed to find version from env\")","\t}","","\text := openshiftExtension{","\t\t// component version is used for metrics, passing a dummy","\t\t// value through extension not going to affect execution","\t\tinstallerSetClient: client.NewInstallerSetClient(operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets(),","\t\t\tversion, \"pipelines-ext\", v1alpha1.KindTektonPipeline, nil),","\t\tkubeClientSet: kubeclient.Get(ctx),","\t}","\treturn ext","}","","type openshiftExtension struct {","\tinstallerSetClient *client.InstallerSetClient","\tkubeClientSet      kubernetes.Interface","}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\ttrns := []mf.Transformer{","\t\toccommon.ApplyCABundlesToDeployment,","\t\toccommon.RemoveRunAsUser(),","\t\toccommon.RemoveRunAsUserForStatefulSet(tektonPipelinesControllerName),","\t\toccommon.RemoveRunAsUserForStatefulSet(tektonRemoteResolversControllerName),","\t\toccommon.ApplyCABundlesForStatefulSet(tektonPipelinesControllerName),","\t\toccommon.ApplyCABundlesForStatefulSet(tektonRemoteResolversControllerName),","\t}","\treturn trns","}","func (oe openshiftExtension) PreReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tmanifest, err := preManifest()","\tif err != nil {","\t\treturn err","\t}","","\t// Filtering out the namespace because it add TektonPipeline as OwnerRef in targetNamespace","\t*manifest = manifest.Filter(mf.Not(mf.ByKind(\"Namespace\")))","\tif err := oe.installerSetClient.PreSet(ctx, comp, manifest, filterAndTransform()); err != nil {","\t\treturn err","\t}","","\t// update monitoring label based on metric enable status under params","\t// namespace creation/modifications are not handled by manifests, see above, namespace filtered from manifests","\tpipeline := comp.(*v1alpha1.TektonPipeline)","\tvalue := strings.ToLower(findParam(pipeline.Spec.Params, enableMetricsKey))","\tlabels := map[string]string{","\t\tmonitoringLabelKey: \"false\",","\t}","\tif value == \"\" || value == \"true\" {","\t\tlabels[monitoringLabelKey] = \"true\"","\t}","","\t// reconcile namespace with updated labels","\treturn common.ReconcileTargetNamespace(ctx, labels, nil, comp, oe.kubeClientSet)","}","","func (oe openshiftExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tpipeline := comp.(*v1alpha1.TektonPipeline)","","\t// Install monitoring if metrics is enabled","\tvalue := strings.ToLower(findParam(pipeline.Spec.Params, enableMetricsKey))","","\tif value == \"\" || value == \"true\" {","\t\tmanifest, err := postManifest()","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif err := oe.installerSetClient.PostSet(ctx, comp, manifest, filterAndTransform()); err != nil {","\t\t\treturn err","\t\t}","\t} else {","\t\tif err := oe.installerSetClient.CleanupPostSet(ctx); err != nil {","\t\t\treturn err","\t\t}","\t}","","\treturn nil","}","func (oe openshiftExtension) Finalize(ctx context.Context, comp v1alpha1.TektonComponent) error {","\tif err := oe.installerSetClient.CleanupPostSet(ctx); err != nil {","\t\treturn err","\t}","\tif err := oe.installerSetClient.CleanupPreSet(ctx); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func preManifest() (*mf.Manifest, error) {","\tkoDataDir := os.Getenv(common.KoEnvKey)","\tmanifest := \u0026mf.Manifest{}","","\t// make sure that openshift-pipelines namespace exists","\tnamespaceLocation := filepath.Join(koDataDir, \"tekton-namespace\")","\tif err := common.AppendManifest(manifest, namespaceLocation); err != nil {","\t\treturn nil, err","\t}","","\t// add inject CA bundles manifests","\tcabundlesLocation := filepath.Join(koDataDir, \"cabundles\")","\tif err := common.AppendManifest(manifest, cabundlesLocation); err != nil {","\t\treturn nil, err","\t}","","\treturn manifest, nil","}","","func postManifest() (*mf.Manifest, error) {","\tkoDataDir := os.Getenv(common.KoEnvKey)","\tmanifest := \u0026mf.Manifest{}","","\tmonitoringLocation := filepath.Join(koDataDir, \"openshift-monitoring\")","\tif err := common.AppendManifest(manifest, monitoringLocation); err != nil {","\t\treturn nil, err","\t}","\treturn manifest, nil","}","","func filterAndTransform() client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tif err := common.Transform(ctx, manifest, comp); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn manifest, nil","\t}","}","","func findParam(params []v1alpha1.Param, param string) string {","\tfor _, p := range params {","\t\tif p.Name == param {","\t\t\treturn p.Value","\t\t}","\t}","\treturn \"\"","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0]},{"id":181,"path":"pkg/reconciler/openshift/tektonpruner/controller.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import (","\t\"context\"","","\tk8sctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner\"","","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8sctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":182,"path":"pkg/reconciler/openshift/tektonpruner/extension.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonpruner","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\toccommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\treturn openshiftExtension{}","}","","type openshiftExtension struct{}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\toccommon.RemoveRunAsUser(),","\t\toccommon.RemoveRunAsGroup(),","\t}","}","func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":183,"path":"pkg/reconciler/openshift/tektonresult/controller.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\t\"context\"","","\tk8s_ctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":184,"path":"pkg/reconciler/openshift/tektonresult/extension.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonresult","","import (","\t\"context\"","\t\"os\"","\t\"path/filepath\"","\t\"strings\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client\"","\toccommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\tk8sruntime \"k8s.io/apimachinery/pkg/runtime\"","\t\"knative.dev/pkg/logging\"",")","","const (","\t// manifests console plugin yaml directory location","\trouteRBACYamlDirectory     = \"static/tekton-results/route-rbac\"","\tlogsRBACYamlDirectory      = \"static/tekton-results/logs-rbac\"","\tdeploymentAPI              = \"tekton-results-api\"","\tserviceAPI                 = \"tekton-results-api-service\"","\trouteAPI                   = \"tekton-results-api\"","\tsecretAPITLS               = \"tekton-results-tls\"","\tapiContainerName           = \"api\"","\tboundSAVolume              = \"bound-sa-token\"","\tboundSAPath                = \"/var/run/secrets/openshift/serviceaccount\"","\tlokiStackTLSCAEnvVar       = \"LOGGING_PLUGIN_CA_CERT\"","\ttektonResultWatcherName    = \"tekton-results-watcher\"","\tpostgresStatefulSetName    = \"tekton-results-postgres\"","\tpostgresContainerName      = \"postgres\"","\tpostgresUpgradeScriptsName = \"postgres-upgrade-scripts\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\tlogger := logging.FromContext(ctx)","","\tversion := os.Getenv(v1alpha1.VersionEnvKey)","\tif version == \"\" {","\t\tlogger.Fatal(\"Failed to find version from env\")","\t}","","\trouteManifest, err := getRouteManifest()","\tif err != nil {","\t\tlogger.Fatalf(\"Failed to fetch route rbac static manifest: %v\", err)","\t}","","\tlogsRBACManifest, err := getloggingRBACManifest()","\tif err != nil {","\t\tlogger.Fatalf(\"Failed to fetch logs RBAC manifest: %v\", err)","\t}","","\text := \u0026openshiftExtension{","\t\tinstallerSetClient: client.NewInstallerSetClient(operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets(),","\t\t\tversion, \"results-ext\", v1alpha1.KindTektonResult, nil),","\t\trouteManifest:    routeManifest,","\t\tlogsRBACManifest: logsRBACManifest,","\t}","\treturn ext","}","","type openshiftExtension struct {","\tinstallerSetClient *client.InstallerSetClient","\trouteManifest      *mf.Manifest","\tlogsRBACManifest   *mf.Manifest","}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\tinstance := comp.(*v1alpha1.TektonResult)","","\treturn []mf.Transformer{","\t\toccommon.RemoveRunAsUser(),","\t\toccommon.RemoveRunAsGroup(),","\t\toccommon.ApplyCABundlesToDeployment,","\t\toccommon.RemoveRunAsUserForStatefulSet(tektonResultWatcherName),","\t\toccommon.RemoveRunAsGroupForStatefulSet(tektonResultWatcherName),","\t\toccommon.ApplyCABundlesForStatefulSet(tektonResultWatcherName),","\t\tinjectBoundSAToken(instance.Spec.ResultsAPIProperties),","\t\tinjectLokiStackTLSCACert(instance.Spec.LokiStackProperties),","\t\tinjectResultsAPIServiceCACert(instance.Spec.ResultsAPIProperties),","\t\tinjectPostgresUpgradeSupport(),","\t}","}","","func (oe *openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\tresult := tc.(*v1alpha1.TektonResult)","\tmf := mf.Manifest{}","","\tif (result.Spec.LokiStackName != \"\" \u0026\u0026 result.Spec.LokiStackNamespace != \"\") ||","\t\tstrings.EqualFold(result.Spec.LogsType, \"LOKI\") {","\t\tmf = mf.Append(*oe.logsRBACManifest)","\t}","","\treturn oe.installerSetClient.PreSet(ctx, tc, \u0026mf, filterAndTransform())","}","","func (oe openshiftExtension) PostReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\tmanifest := *oe.routeManifest","","\tresult := tc.(*v1alpha1.TektonResult)","\tif !isEnableRoute(result) {","\t\t// If route is disable then delete the postset","\t\tif err := oe.installerSetClient.CleanupPostSet(ctx); err != nil {","\t\t\treturn err","\t\t}","\t\treturn nil","\t}","","\treturn oe.installerSetClient.PostSet(ctx, tc, \u0026manifest, filterAndTransform())","}","","func (oe openshiftExtension) Finalize(ctx context.Context, tc v1alpha1.TektonComponent) error {","\tif err := oe.installerSetClient.CleanupPostSet(ctx); err != nil {","\t\treturn err","\t}","\tif err := oe.installerSetClient.CleanupPreSet(ctx); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func getRouteManifest() (*mf.Manifest, error) {","\tmanifest := \u0026mf.Manifest{}","\tresultsRbac := filepath.Join(common.ComponentBaseDir(), routeRBACYamlDirectory)","\tif err := common.AppendManifest(manifest, resultsRbac); err != nil {","\t\treturn nil, err","\t}","\treturn manifest, nil","}","","// function to add fine grained access control to results api if results config specifies that","// pipeline logs are managed by OpenShift Logging with OpenShift logging and OpenShift loki operators","func getloggingRBACManifest() (*mf.Manifest, error) {","\tmanifest := \u0026mf.Manifest{}","\tlogsRbac := filepath.Join(common.ComponentBaseDir(), logsRBACYamlDirectory)","\tif err := common.AppendManifest(manifest, logsRbac); err != nil {","\t\treturn nil, err","\t}","\treturn manifest, nil","}","","func filterAndTransform() client.FilterAndTransform {","\treturn func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) {","\t\tresultImgs := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ResultsImagePrefix))","\t\tinstance := comp.(*v1alpha1.TektonResult)","","\t\textra := []mf.Transformer{","\t\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdResults),","\t\t\tcommon.ApplyProxySettings,","\t\t\tcommon.AddStatefulSetRestrictedPSA(),","\t\t\tcommon.DeploymentImages(resultImgs),","\t\t\tcommon.StatefulSetImages(resultImgs),","\t\t\tinjectResultsAPIRoute(instance.Spec.ResultsAPIProperties),","\t\t}","","\t\tif err := common.Transform(ctx, manifest, comp, extra...); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn manifest, nil","\t}","}","","func injectResultsAPIServiceCACert(props v1alpha1.ResultsAPIProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Service\" || u.GetName() != serviceAPI {","\t\t\treturn nil","\t\t}","","\t\ts := \u0026corev1.Service{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, s)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tannotations := s.Annotations","\t\tif annotations == nil {","\t\t\tannotations = make(map[string]string)","\t\t}","\t\tannotations[\"service.beta.openshift.io/serving-cert-secret-name\"] = secretAPITLS","\t\ts.SetAnnotations(annotations)","","\t\tuObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(s)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","}","","// injectBoundSAToken adds a sa token projected volume to the Results Deployment","func injectBoundSAToken(props v1alpha1.ResultsAPIProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif props.LogsAPI == nil || !*props.LogsAPI ||","\t\t\tu.GetKind() != \"Deployment\" || u.GetName() != deploymentAPI {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// find the matching container and add env and secret name object","\t\tfor i, container := range d.Spec.Template.Spec.Containers {","\t\t\tif container.Name != apiContainerName {","\t\t\t\tcontinue","\t\t\t}","\t\t\tadd := true","\t\t\tvol := corev1.Volume{","\t\t\t\tName: boundSAVolume,","\t\t\t\tVolumeSource: corev1.VolumeSource{","\t\t\t\t\tProjected: \u0026corev1.ProjectedVolumeSource{","\t\t\t\t\t\tSources: []corev1.VolumeProjection{","\t\t\t\t\t\t\t{","\t\t\t\t\t\t\t\tServiceAccountToken: \u0026corev1.ServiceAccountTokenProjection{","\t\t\t\t\t\t\t\t\tAudience: \"openshift\",","\t\t\t\t\t\t\t\t\tPath:     \"token\",","\t\t\t\t\t\t\t\t},","\t\t\t\t\t\t\t},","\t\t\t\t\t\t},","\t\t\t\t\t},","\t\t\t\t},","\t\t\t}","\t\t\tfor k := 0; k \u003c len(d.Spec.Template.Spec.Volumes); k++ {","\t\t\t\tif d.Spec.Template.Spec.Volumes[k].Name == boundSAVolume {","\t\t\t\t\td.Spec.Template.Spec.Volumes[k] = vol","\t\t\t\t\tadd = false","\t\t\t\t}","\t\t\t}","\t\t\tif add {","\t\t\t\td.Spec.Template.Spec.Volumes = append(d.Spec.Template.Spec.Volumes, vol)","\t\t\t}","","\t\t\tvolMount := corev1.VolumeMount{","\t\t\t\tName:      boundSAVolume,","\t\t\t\tMountPath: boundSAPath,","\t\t\t}","","\t\t\tadd = true","\t\t\tfor k := 0; k \u003c len(d.Spec.Template.Spec.Containers[i].VolumeMounts); k++ {","\t\t\t\tif d.Spec.Template.Spec.Containers[i].VolumeMounts[k].Name == boundSAVolume {","\t\t\t\t\td.Spec.Template.Spec.Containers[i].VolumeMounts[k] = volMount","\t\t\t\t\tadd = false","\t\t\t\t}","\t\t\t}","\t\t\tif add {","\t\t\t\td.Spec.Template.Spec.Containers[i].VolumeMounts = append(","\t\t\t\t\td.Spec.Template.Spec.Containers[i].VolumeMounts, volMount)","\t\t\t}","","\t\t\tbreak","\t\t}","","\t\tuObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","}","","// injectLokiStackTLSCACert adds a tls ca cert environment variable to the Results Deployment","// If the env variable already exists, it will be overwritten","func injectLokiStackTLSCACert(prop v1alpha1.LokiStackProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif prop.LokiStackNamespace == \"\" || prop.LokiStackName == \"\" ||","\t\t\tu.GetKind() != \"Deployment\" || u.GetName() != deploymentAPI {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// find the matching container and add env and secret name object","\t\tfor i, container := range d.Spec.Template.Spec.Containers {","\t\t\tif container.Name != apiContainerName {","\t\t\t\tcontinue","\t\t\t}","\t\t\tadd := true","\t\t\tenv := corev1.EnvVar{","\t\t\t\tName: lokiStackTLSCAEnvVar,","\t\t\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\t\t\tConfigMapKeyRef: \u0026corev1.ConfigMapKeySelector{","\t\t\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\t\t\tName: \"openshift-service-ca.crt\",","\t\t\t\t\t\t},","\t\t\t\t\t\tKey: \"service-ca.crt\",","\t\t\t\t\t},","\t\t\t\t},","\t\t\t}","","\t\t\t// Check if the env variable already exists in the container","\t\t\t// If it does, overwrite it","\t\t\tfor k := 0; k \u003c len(d.Spec.Template.Spec.Containers[i].Env); k++ {","\t\t\t\tif d.Spec.Template.Spec.Containers[i].Env[k].Name == lokiStackTLSCAEnvVar {","\t\t\t\t\td.Spec.Template.Spec.Containers[i].Env[k] = env","\t\t\t\t\tadd = false","\t\t\t\t}","\t\t\t}","","\t\t\t// If it doesn't exist, add it","\t\t\tif add {","\t\t\t\td.Spec.Template.Spec.Containers[i].Env = append(","\t\t\t\t\td.Spec.Template.Spec.Containers[i].Env, env)","\t\t\t}","","\t\t\tbreak","\t\t}","","\t\tuObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","}","","// isEnableRoute determines if route should be enabled for results API","func isEnableRoute(result *v1alpha1.TektonResult) bool {","\t// Default to false if not explicitly set","\tif result.Spec.RouteEnabled == nil {","\t\treturn false","\t}","\treturn *result.Spec.RouteEnabled","}","","// injectResultsAPIRoute adds ResultSpec route properties to Results route","func injectResultsAPIRoute(props v1alpha1.ResultsAPIProperties) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Route\" || u.GetName() != routeAPI {","\t\t\treturn nil","\t\t}","","\t\t// Apply custom host if specified","\t\tif props.RouteHost != \"\" {","\t\t\tif err := unstructured.SetNestedField(u.Object, props.RouteHost, \"spec\", \"host\"); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","","\t\t// Apply custom path if specified","\t\tif props.RoutePath != \"\" {","\t\t\tif err := unstructured.SetNestedField(u.Object, props.RoutePath, \"spec\", \"path\"); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","","\t\t// Apply custom TLS termination if specified","\t\tif props.RouteTLSTermination != \"\" {","\t\t\tif err := unstructured.SetNestedField(u.Object, props.RouteTLSTermination, \"spec\", \"tls\", \"termination\"); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","","\t\treturn nil","\t}","}","","// injectPostgresUpgradeSupport modifies the postgres container to support automatic","// upgrade from PostgreSQL 13 to PostgreSQL 15. The wrapper script checks the PG_VERSION","// file in the data directory and sets POSTGRESQL_UPGRADE=copy if an upgrade is needed,","// triggering the sclorg container's built-in upgrade mechanism.","func injectPostgresUpgradeSupport() mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\t// Only apply to the postgres StatefulSet","\t\tif u.GetKind() != \"StatefulSet\" || u.GetName() != postgresStatefulSetName {","\t\t\treturn nil","\t\t}","","\t\tsts := \u0026appsv1.StatefulSet{}","\t\terr := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\t// Modify the main postgres container","\t\tfor i, container := range sts.Spec.Template.Spec.Containers {","\t\t\tif container.Name == postgresContainerName {","\t\t\t\t// Add volume mount for upgrade scripts","\t\t\t\tvmFound := false","\t\t\t\tfor _, vm := range container.VolumeMounts {","\t\t\t\t\tif vm.Name == \"upgrade-scripts\" {","\t\t\t\t\t\tvmFound = true","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif !vmFound {","\t\t\t\t\tsts.Spec.Template.Spec.Containers[i].VolumeMounts = append(","\t\t\t\t\t\tcontainer.VolumeMounts,","\t\t\t\t\t\tcorev1.VolumeMount{","\t\t\t\t\t\t\tName:      \"upgrade-scripts\",","\t\t\t\t\t\t\tMountPath: \"/upgrade-scripts\",","\t\t\t\t\t\t},","\t\t\t\t\t)","\t\t\t\t}","","\t\t\t\t// Change the command to use the wrapper script","\t\t\t\tsts.Spec.Template.Spec.Containers[i].Command = []string{","\t\t\t\t\t\"/bin/bash\",","\t\t\t\t\t\"/upgrade-scripts/postgres-wrapper.sh\",","\t\t\t\t}","\t\t\t}","\t\t}","","\t\t// Add volume for upgrade scripts ConfigMap","\t\tscriptsVolume := corev1.Volume{","\t\t\tName: \"upgrade-scripts\",","\t\t\tVolumeSource: corev1.VolumeSource{","\t\t\t\tConfigMap: \u0026corev1.ConfigMapVolumeSource{","\t\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{","\t\t\t\t\t\tName: postgresUpgradeScriptsName,","\t\t\t\t\t},","\t\t\t\t\tDefaultMode: func() *int32 {","\t\t\t\t\t\tmode := int32(0755)","\t\t\t\t\t\treturn \u0026mode","\t\t\t\t\t}(),","\t\t\t\t},","\t\t\t},","\t\t}","","\t\tvolumeFound := false","\t\tfor i, vol := range sts.Spec.Template.Spec.Volumes {","\t\t\tif vol.Name == \"upgrade-scripts\" {","\t\t\t\tsts.Spec.Template.Spec.Volumes[i] = scriptsVolume","\t\t\t\tvolumeFound = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !volumeFound {","\t\t\tsts.Spec.Template.Spec.Volumes = append(","\t\t\t\tsts.Spec.Template.Spec.Volumes,","\t\t\t\tscriptsVolume,","\t\t\t)","\t\t}","","\t\t// Convert back to unstructured","\t\tuObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(sts)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(uObj)","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0,0,2,2,2,2,2,2,2,1,1,2,0,0,2,0,0,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,1,1,2,2,0,0,0,0,2,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,2,2,2,0,2,2,2,2,2,2,2,2,1,1,1,0,2,2,2,2,0,2,0,0,2,2,1,1,2,2,0,0,0,0,0,2,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,0,2,2,2,2,0,2,0,0,2,2,1,1,2,2,0,0,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,0,2,2,1,1,0,0,0,2,2,1,1,0,0,0,2,2,1,1,0,0,2,0,0,0,0,0,0,0,2,2,2,2,2,2,0,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,2,2,1,1,2,2,0,0]},{"id":185,"path":"pkg/reconciler/openshift/tektonscheduler/controller.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import (","\t\"context\"","","\tk8sctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonscheduler\"","","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8sctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":186,"path":"pkg/reconciler/openshift/tektonscheduler/extension.go","lines":["/*","Copyright 2026 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonscheduler","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\toccommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"",")","","func OpenShiftExtension(ctx context.Context) common.Extension {","\treturn openshiftExtension{}","}","","type openshiftExtension struct{}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\toccommon.RemoveRunAsUser(),","\t\toccommon.RemoveRunAsGroup(),","\t}","}","func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":187,"path":"pkg/reconciler/openshift/tektontrigger/controller.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\t\"context\"","","\tk8s_ctrl \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"",")","","// NewController initializes the controller and is called by the generated code","// Registers eventhandlers to enqueue events","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]},{"id":188,"path":"pkg/reconciler/openshift/tektontrigger/extension.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger\"","\toccommon \"github.com/tektoncd/operator/pkg/reconciler/openshift/common\"","\t\"knative.dev/pkg/ptr\"",")","","// triggersProperties holds fields for configuring runAsUser and runAsGroup.","type triggersProperties struct {","\tDefaultRunAsUser  *string `json:\"default-run-as-user,omitempty\"`","\tDefaultRunAsGroup *string `json:\"default-run-as-group,omitempty\"`","\tDefaultFSGroup    *string `json:\"default-fs-group,omitempty\"`","}","","// Updating the default values of runAsUser and runAsGroup to an empty string","// to ensure compatibility with OpenShift's requirements for managing these settings","// in Triggers Eventlistener containers SCC.","var triggersData = triggersProperties{","\tDefaultRunAsUser:  ptr.String(\"\"),","\tDefaultRunAsGroup: ptr.String(\"\"),","\tDefaultFSGroup:    ptr.String(\"\"),","}","","func OpenShiftExtension(ctx context.Context) common.Extension {","\treturn openshiftExtension{}","}","","type openshiftExtension struct{}","","func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer {","\treturn []mf.Transformer{","\t\toccommon.RemoveRunAsUser(),","\t\toccommon.RemoveRunAsGroup(),","\t\toccommon.ApplyCABundlesToDeployment,","\t\tcommon.AddConfigMapValues(tektontrigger.ConfigDefaults, triggersData),","\t\treplaceDeploymentArgs(\"-el-events\", \"enable\"),","\t}","}","func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}","func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error {","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":189,"path":"pkg/reconciler/openshift/tektontrigger/transformers.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektontrigger","","import (","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\tappsv1 \"k8s.io/api/apps/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime\"",")","","// replace the value of a deployment arg provided argToReplace and value","func replaceDeploymentArgs(argToReplace, value string) mf.Transformer {","\treturn func(u *unstructured.Unstructured) error {","\t\tif u.GetKind() != \"Deployment\" {","\t\t\treturn nil","\t\t}","","\t\td := \u0026appsv1.Deployment{}","\t\terr := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","","\t\tcontainers := d.Spec.Template.Spec.Containers","\t\tfor _, container := range containers {","\t\t\tif len(container.Args) == 0 {","\t\t\t\tcontinue","\t\t\t}","\t\t\tfor j, arg := range container.Args {","\t\t\t\t// for scenario when key and value are in single arg e.g. \"key=value\"","\t\t\t\tif argVal, hasArg := common.SplitsByEqual(arg); hasArg {","\t\t\t\t\tif argVal[0] == argToReplace {","\t\t\t\t\t\tcontainer.Args[j] = argVal[0] + \"=\" + value","\t\t\t\t\t}","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\t// for scenario, when key and value are in different args, eg. \"key\",\"value\"","\t\t\t\tif arg == argToReplace {","\t\t\t\t\tcontainer.Args[j+1] = value","\t\t\t\t}","\t\t\t}","","\t\t}","","\t\tunstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tu.SetUnstructuredContent(unstrObj)","","\t\treturn nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,1,1,0,2,2,2,1,0,2,2,2,2,1,1,2,0,0,2,2,2,0,0,0,0,2,2,1,1,2,2,2,0,0]},{"id":190,"path":"pkg/reconciler/platform/config.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package platform","","import (","\t\"errors\"","\t\"flag\"","\t\"fmt\"","\t\"log\"","\t\"os\"","\t\"strings\"",")","","func init() {","\tRegisterFlags()","}","","const (","\tFlagControllers       string = \"controllers\"","\tFlagSharedMainName    string = \"unique-process-name\"","\tDefaultSharedMainName string = \"tekton-operator\"",")","","var (","\tErrSharedMainNameEmpty = fmt.Errorf(\"sharedMainName cannot be empty string\")","\tErrControllerNamesNil  = fmt.Errorf(\"ControllerNames slice should be non-nil\")","\tctrlArgs               string","\tprocessName            string",")","","// RegisterFlags adds platform specific command line flags","// this logic is written in a separate function to make it convenient","// to write unit-tests","func RegisterFlags() {","\tflag.StringVar(","\t\t\u0026ctrlArgs,","\t\tFlagControllers,","\t\t\"\",","\t\t\"comma separated list of names of controllers to be enabled (\\\"\\\" enables all controllers)\",","\t)","","\t// The role of this flag to make sure that instances of this process running as different","\t// containers have unique \"sharedMain Name\"","\t// The name has to be unique otherwise knative/pkg will consider the 2 containers as copies (like replicas in a deployment) of","\t// same process as leader election and logging are setup using this \"sharedMain Name\"","\tflag.StringVar(","\t\t\u0026processName,","\t\tFlagSharedMainName,","\t\tDefaultSharedMainName,","\t\t\"name of the sharedMain process used in leader election (unique among containers of same pod)\")","}","","// NewConfigFromFlags returns PlatformConfig created using","// inputs from command line flags","func NewConfigFromFlags() PlatformConfig {","","\tconfig, err := newConfig(flagsConfigReader)","\tif err != nil {","\t\tlog.Fatalf(\"unable to read platform from flags: %v\", err)","\t}","\treturn config","}","","// NewConfigFromEnv returns PlatformConfig created using","// inputs from environment variables","func NewConfigFromEnv() PlatformConfig {","\tconfig, err := newConfig(envConfigReader)","\tif err != nil {","\t\tlog.Fatalf(\"unable to read platform from env: %v\", err)","\t}","\treturn config","}","","// envConfigReader of type 'configReader' is modular implementation of the logic","// to read platform specific inputs from environment variables","func envConfigReader(pc *PlatformConfig) error {","\tctrlArgs := os.Getenv(EnvControllerNames)","\tc := os.Getenv(EnvSharedMainName)","\tpc.SharedMainName = c","\tpc.ControllerNames = stringToControllerNamesSlice(ctrlArgs)","\treturn nil","}","","// flagsConfigReader 'configReader' is modular implementation of the logic","// to read platform specific inputs from command line flags","func flagsConfigReader(pc *PlatformConfig) error {","\tflag.Parse()","\tpc.SharedMainName = processName","\tpc.ControllerNames = stringToControllerNamesSlice(ctrlArgs)","\treturn nil","}","","// newConfig returns PlatformConfig created using inputs read by","// provided implementation of 'configReader'","func newConfig(inFn configReader) (PlatformConfig, error) {","\tconfig := PlatformConfig{}","\terr := inFn(\u0026config)","\tif err != nil {","\t\treturn PlatformConfig{}, err","\t}","\tif err := validateConfig(\u0026config); err != nil {","\t\treturn PlatformConfig{}, err","\t}","\treturn config, nil","}","","// validateConfig does basic validation on platform specific configuration","func validateConfig(pc *PlatformConfig) error {","\tviolations := []string{}","","\tif len(pc.SharedMainName) == 0 {","\t\tviolations = append(violations, ErrSharedMainNameEmpty.Error())","\t}","\t// TODO: set a maximum length for pc.SharedMainName","","\tif pc.ControllerNames == nil {","\t\tviolations = append(violations, ErrControllerNamesNil.Error())","\t}","\tif len(violations) == 0 {","\t\treturn nil","\t}","\treturn errors.New(strings.Join(violations, \",\"))","}","","// stringToControllerNamesSlice returns a []ControllerName","// created from controllerNames in a comma separated string \"ctrl1,ctrl2\"","func stringToControllerNamesSlice(s string) []ControllerName {","\tresult := []ControllerName{}","\tif len(s) == 0 {","\t\treturn result","\t}","\tfor _, val := range strings.Split(s, \",\") {","\t\tresult = append(result, ControllerName(val))","\t}","\treturn result","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,1,1,2,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,0]},{"id":191,"path":"pkg/reconciler/platform/platform.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package platform","","import (","\t\"context\"","\t\"fmt\"","\t\"log\"","\t\"strings\"","","\tinstaller \"github.com/tektoncd/operator/pkg/reconciler/shared/tektoninstallerset\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/injection/sharedmain\"","\t\"knative.dev/pkg/signals\"",")","","// validateControllerNamesOrDie ensures that the list of controller names to be enabled","// are supported by a platform. This function exits on error","func validateControllerNamesOrDie(p Platform) {","\tif err := validateControllerNames(p); err != nil {","\t\tlog.Fatalf(\"error validating provided controller names: %v\", err)","\t}","","}","","// validateControllerNames ensures that the list of controller names to be enabled","// are supported by a platform","func validateControllerNames(p Platform) error {","\tpParams := p.PlatformParams()","\tsupportedCtrls := p.AllSupportedControllers()","\tinvalidNamesStr := invalidNames(supportedCtrls, pParams.ControllerNames)","\tif len(invalidNamesStr) == 0 {","\t\treturn nil","\t}","\treturn ErrorControllerNames(invalidNamesStr, supportedCtrls.ControllerNames())","}","","// invalidNames checks if whether there are any names in []CotrollerNames which are","// not present in (supported by) given ControllerMap","func invalidNames(supportedCtrls ControllerMap, cNames []ControllerName) string {","\tinvalidNames := strings.Builder{}","\tfor _, cName := range cNames {","\t\tif _, ok := supportedCtrls[cName]; !ok {","\t\t\tinvalidNames.WriteString(string(cName))","\t\t\tinvalidNames.WriteString(\",\")","\t\t}","\t}","","\treturn strings.TrimSuffix(invalidNames.String(), \",\")","}","","// ErrorControllerNames is a error message format helper","func ErrorControllerNames(invalidNames string, validNames []string) error {","\treturn fmt.Errorf(\"un-identified controller names: %s, supported names: %v\", invalidNames, validNames)","}","","// activeControllers returns a map of the controllers that should be run","// the returned map is a subset of the platform specific map which stores all-supported-controllers","func activeControllers(p Platform) ControllerMap {","\tpParams := p.PlatformParams()","\tresult := ControllerMap{}","\tfor _, name := range pParams.ControllerNames {","\t\tif namedCtrl, ok := p.AllSupportedControllers()[name]; ok {","\t\t\tresult[name] = namedCtrl","\t\t}","\t}","\treturn result","}","","// disabledControllers returns a map of the controllers that should not be run","// the result of disabledControllers is the set of controllers excluded by activeControllers function","// in other words, disabledControllers returns a map which has controllers \"not\" specified in the controlelrNames input to a platform","// the returned map is a subset of the platform specific map which stores all-supported-controllers","func disabledControllers(p Platform) ControllerMap {","\tpParams := p.PlatformParams()","\tresult := p.AllSupportedControllers()","\tfor _, name := range pParams.ControllerNames {","\t\tdelete(result, name)","\t}","\treturn result","}","","// contextWithPlatformName  adds platform name to a given context","func contextWithPlatformName(ctx context.Context, pName string) context.Context {","\tctx = context.WithValue(ctx, PlatformNameKey{}, pName)","\treturn ctx","}","","// startMain starts a knative/pkg sharedMain with a context that stores platform name","// and a list of controllers which should be enabled for the given platform","func startMain(p Platform, ctrls ControllerMap) {","\tpParams := p.PlatformParams()","\tcfg := injection.ParseAndGetRESTConfigOrDie()","\tcfg.QPS = 50","\tctx, _ := injection.EnableInjectionOrDie(signals.NewContext(), cfg)","\tctx = contextWithPlatformName(ctx, pParams.Name)","\tinstaller.InitTektonInstallerSetClient(ctx)","\tsharedmain.MainWithConfig(ctx,","\t\tpParams.SharedMainName,","\t\tcfg,","\t\tctrls.ControllerConstructors()...,","\t)","}","","// StartMainWithAllControllers calls startMain with all controllers","// supported by a platform","func StartMainWithAllControllers(p Platform) {","\tstartMain(p, p.AllSupportedControllers())","}","","// StartMainWithSelectedControllers starts the main control loop with only the controllers","// that are explicitly specified in the platform configuration.","func StartMainWithSelectedControllers(p Platform) {","\tvalidateControllerNamesOrDie(p)","\tselectedCtrls := activeControllers(p)","\tstartMain(p, selectedCtrls)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,0,0,2,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,0,2,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1]},{"id":192,"path":"pkg/reconciler/platform/platform_fake.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package platform","","type FakePlatform struct {","\tpParams           func() PlatformConfig","\tallSupportedCtrls func() ControllerMap","}","","func (fp *FakePlatform) PlatformParams() PlatformConfig {","\treturn fp.pParams()","}","","func (fp *FakePlatform) AllSupportedControllers() ControllerMap {","\treturn fp.allSupportedCtrls()","}","","func SeededFakePlatform(cn []ControllerName, ctrls ControllerMap) *FakePlatform {","\tf := FakePlatform{}","\tf.pParams = func() PlatformConfig {","\t\treturn PlatformConfig{","\t\t\tControllerNames: cn,","\t\t}","\t}","\tf.allSupportedCtrls = func() ControllerMap {","\t\treturn ctrls","\t}","\treturn \u0026f","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0]},{"id":193,"path":"pkg/reconciler/platform/types.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package platform","","import (","\t\"knative.dev/pkg/injection\"",")","","type configReader func(config *PlatformConfig) error","","// PlatformConfig defines basic configuration that","// all platforms should support","type PlatformConfig struct {","\tName            string","\tControllerNames []ControllerName","\tSharedMainName  string","}","","// PlatformNameKey is defines a 'key' for adding platform name to an instance of context.Context","type PlatformNameKey struct{}","","// ControllerName defines a name given to a controller(reconciler) in a platform","type ControllerName string","","// ControllerMap defines map that maps a name given to a controller(reconciler) to its injection.ControllerConstructor","type ControllerMap map[ControllerName]injection.NamedControllerConstructor","","// ControllerNames returns a []string of names of all controllers (reconciers)","// supported in a given ControlelrMap","func (cm ControllerMap) ControllerNames() []string {","\tresult := []string{}","\tfor _, namedCtrl := range cm {","\t\tresult = append(result, namedCtrl.Name)","\t}","\treturn result","}","","// ControllerConstructor returns a []injection.ControllerConstructor of all controllers (reconciers)","// supported in a given ControlelrMap","// Some versions of sharedMain functions in knative/pkg expect","// a variadic list of supported cotrollers as []injection.ControllerConstructor","func (cm ControllerMap) ControllerConstructors() []injection.ControllerConstructor {","\tresult := []injection.ControllerConstructor{}","\tfor _, namedCtrl := range cm {","\t\tresult = append(result, namedCtrl.ControllerConstructor)","\t}","\treturn result","}","","// ControllerConstructor returns a []injection.NamedControllerConstructor of all controllers (reconciers)","// supported in a given ControlelrMap","// Some versions of sharedMain functions in knative/pkg expect","// a variadic list of supported cotrollers as []injection.NamedControllerConstructor","func (cm ControllerMap) NamedControllerConstructors() []injection.NamedControllerConstructor {","\tresult := []injection.NamedControllerConstructor{}","\tfor _, namedCtrl := range cm {","\t\tresult = append(result, namedCtrl)","\t}","\treturn result","}","","// Platform defines a Kubernetes platform (Vanila Kubernetes, OpenShift...)","type Platform interface {","\tPlatformParams() PlatformConfig","\tAllSupportedControllers() ControllerMap","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0]},{"id":194,"path":"pkg/reconciler/proxy/controller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package proxy","","import (","\t\"context\"","\t\"os\"","","\t\"knative.dev/pkg/configmap\"","","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/signals\"","","\t// Injection stuff","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tmwhinformer \"knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/mutatingwebhookconfiguration\"","\t\"knative.dev/pkg/controller\"","\tsecretinformer \"knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"",")","","// NewAdmissionController constructs a reconciler","func NewAdmissionController(","\tctx context.Context,","\tname, path string,","\twc func(context.Context) context.Context,","\tdisallowUnknownFields bool,",") *controller.Impl {","","\tclient := kubeclient.Get(ctx)","\tmwhInformer := mwhinformer.Get(ctx)","\tsecretInformer := secretinformer.Get(ctx)","\toptions := webhook.GetOptions(ctx)","","\tkey := types.NamespacedName{Name: name}","","\twh := \u0026reconciler{","\t\tLeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{","\t\t\t// Have this reconciler enqueue our singleton whenever it becomes leader.","\t\t\tPromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error {","\t\t\t\tenq(bkt, key)","\t\t\t\treturn nil","\t\t\t},","\t\t},","","\t\tkey:  key,","\t\tpath: path,","","\t\twithContext:           wc,","\t\tdisallowUnknownFields: disallowUnknownFields,","\t\tsecretName:            options.SecretName,","","\t\tclient:       client,","\t\tmwhlister:    mwhInformer.Lister(),","\t\tsecretlister: secretInformer.Lister(),","\t}","","\tlogger := logging.FromContext(ctx)","\tc := controller.NewContext(ctx, wh, controller.ControllerOptions{WorkQueueName: \"DefaultingWebhook\", Logger: logger})","","\t// Reconcile when the named MutatingWebhookConfiguration changes.","\tif _, err := mwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithName(name),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named MWH resource.","\t\tHandler: controller.HandleAll(c.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register MutatingWebhookConfugration informer event handler: %w\", err)","\t}","","\t// Reconcile when the cert bundle changes.","\tif _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), wh.secretName),","\t\t// It doesn't matter what we enqueue because we will always Reconcile","\t\t// the named MWH resource.","\t\tHandler: controller.HandleAll(c.Enqueue),","\t}); err != nil {","\t\tlogger.Panicf(\"Couldn't register Secret informer event handler: %w\", err)","\t}","","\treturn c","}","","func Getctx() context.Context {","\tserviceName := os.Getenv(\"WEBHOOK_SERVICE_NAME\")","\tif serviceName == \"\" {","\t\tserviceName = \"tekton-operator-proxy-webhook\"","\t}","","\tsecretName := os.Getenv(\"WEBHOOK_SECRET_NAME\")","\tif secretName == \"\" {","\t\tsecretName = \"proxy-webhook-certs\"","\t}","\tsystemNamespace := os.Getenv(\"SYSTEM_NAMESPACE\")","","\t// Scope informers to the webhook's namespace instead of cluster-wide","\tctx := injection.WithNamespaceScope(signals.NewContext(), systemNamespace)","","\t// Set up a signal context with our webhook options","\tctx = webhook.WithOptions(ctx, webhook.Options{","\t\tServiceName: serviceName,","\t\tPort:        8443,","\t\tSecretName:  secretName,","\t})","\treturn ctx","}","","func NewProxyDefaultingAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","","\treturn NewAdmissionController(ctx,","","\t\t// Name of the resource webhook.","\t\t\"proxy.operator.tekton.dev\",","","\t\t// The path on which to serve the webhook.","\t\t\"/defaulting\",","","\t\t// A function that infuses the context passed to Validate/SetDefaults with custom metadata.","\t\tfunc(ctx context.Context) context.Context {","\t\t\treturn ctx","\t\t},","","\t\t// Whether to disallow unknown fields.","\t\ttrue,","\t)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0]},{"id":195,"path":"pkg/reconciler/proxy/proxy.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package proxy","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"os\"","\t\"strings\"","","\t\"github.com/markbates/inflect\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"go.uber.org/zap\"","\t\"gomodules.xyz/jsonpatch/v2\"","\tadmissionv1 \"k8s.io/api/admission/v1\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","\tadmissionlisters \"k8s.io/client-go/listers/admissionregistration/v1\"","\tcorelisters \"k8s.io/client-go/listers/core/v1\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/apis/duck\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/kmp\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"","\tcertresources \"knative.dev/pkg/webhook/certificates/resources\"",")","","// reconciler implements the AdmissionController for resources","type reconciler struct {","\twebhook.StatelessAdmissionImpl","\tpkgreconciler.LeaderAwareFuncs","","\tkey  types.NamespacedName","\tpath string","","\twithContext func(context.Context) context.Context","","\tclient       kubernetes.Interface","\tmwhlister    admissionlisters.MutatingWebhookConfigurationLister","\tsecretlister corelisters.SecretLister","","\tdisallowUnknownFields bool","\tsecretName            string","}","","var _ controller.Reconciler = (*reconciler)(nil)","var _ pkgreconciler.LeaderAware = (*reconciler)(nil)","var _ webhook.AdmissionController = (*reconciler)(nil)","var _ webhook.StatelessAdmissionController = (*reconciler)(nil)","","// Reconcile implements controller.Reconciler","func (ac *reconciler) Reconcile(ctx context.Context, key string) error {","\tlogger := logging.FromContext(ctx)","","\tif !ac.IsLeaderFor(ac.key) {","\t\tlogger.Debugf(\"Skipping key %q, not the leader.\", ac.key)","\t\treturn nil","\t}","","\t// Look up the webhook secret, and fetch the CA cert bundle.","\tsecret, err := ac.secretlister.Secrets(system.Namespace()).Get(ac.secretName)","\tif err != nil {","\t\tlogger.Errorw(\"Error fetching secret\", zap.Error(err))","\t\treturn err","\t}","\tcaCert, ok := secret.Data[certresources.CACert]","\tif !ok {","\t\treturn fmt.Errorf(\"secret %q is missing %q key\", ac.secretName, certresources.CACert)","\t}","","\t// Reconcile the webhook configuration.","\treturn ac.reconcileMutatingWebhook(ctx, caCert)","}","","// Path implements AdmissionController","func (ac *reconciler) Path() string {","\treturn ac.path","}","","// Admit implements AdmissionController","func (ac *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {","\tif ac.withContext != nil {","\t\tctx = ac.withContext(ctx)","\t}","","\tlogger := logging.FromContext(ctx)","\tswitch request.Operation {","\tcase admissionv1.Create:","\tdefault:","\t\tlogger.Info(\"Unhandled webhook operation, letting it through \", request.Operation)","\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t}","","\tpatchBytes, err := ac.mutate(ctx, request)","\tif err != nil {","\t\treturn webhook.MakeErrorStatus(\"mutation failed: %v\", err)","\t}","\tlogger.Infof(\"Kind: %q PatchBytes: %v\", request.Kind, string(patchBytes))","","\treturn \u0026admissionv1.AdmissionResponse{","\t\tPatch:   patchBytes,","\t\tAllowed: true,","\t\tPatchType: func() *admissionv1.PatchType {","\t\t\tpt := admissionv1.PatchTypeJSONPatch","\t\t\treturn \u0026pt","\t\t}(),","\t}","}","","func (ac *reconciler) reconcileMutatingWebhook(ctx context.Context, caCert []byte) error {","\tlogger := logging.FromContext(ctx)","","\tplural := strings.ToLower(inflect.Pluralize(\"Pod\"))","\trules := []admissionregistrationv1.RuleWithOperations{","\t\t{","\t\t\tOperations: []admissionregistrationv1.OperationType{","\t\t\t\tadmissionregistrationv1.Create,","\t\t\t},","\t\t\tRule: admissionregistrationv1.Rule{","\t\t\t\tAPIGroups:   []string{\"\"},","\t\t\t\tAPIVersions: []string{\"v1\"},","\t\t\t\tResources:   []string{plural, plural + \"/status\"},","\t\t\t},","\t\t},","\t}","","\tconfiguredWebhook, err := ac.mwhlister.Get(ac.key.Name)","\tif err != nil {","\t\treturn fmt.Errorf(\"error retrieving webhook: %w\", err)","\t}","","\twebhook := configuredWebhook.DeepCopy()","","\t// Clear out any previous (bad) OwnerReferences.","\t// See: https://github.com/knative/serving/issues/5845","\twebhook.OwnerReferences = nil","","\tfor i, wh := range webhook.Webhooks {","\t\tif wh.Name != webhook.Name {","\t\t\tcontinue","\t\t}","\t\twebhook.Webhooks[i].Rules = rules","\t\twebhook.Webhooks[i].NamespaceSelector = \u0026metav1.LabelSelector{","\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{{","\t\t\t\tKey:      \"operator.tekton.dev/disable-proxy\",","\t\t\t\tOperator: metav1.LabelSelectorOpDoesNotExist,","\t\t\t}, {","\t\t\t\t// \"control-plane\" is added to support Azure's AKS, otherwise the controllers fight.","\t\t\t\t// See knative/pkg#1590 for details.","\t\t\t\tKey:      \"control-plane\",","\t\t\t\tOperator: metav1.LabelSelectorOpDoesNotExist,","\t\t\t}},","\t\t}","\t\twebhook.Webhooks[i].ObjectSelector = \u0026metav1.LabelSelector{","\t\t\tMatchExpressions: []metav1.LabelSelectorRequirement{","\t\t\t\t{","\t\t\t\t\tKey:      \"app.kubernetes.io/managed-by\",","\t\t\t\t\tValues:   []string{\"tekton-pipelines\", \"pipelinesascode.tekton.dev\"},","\t\t\t\t\tOperator: metav1.LabelSelectorOpIn,","\t\t\t\t},","\t\t\t},","\t\t}","\t\twebhook.Webhooks[i].ClientConfig.CABundle = caCert","\t\tif webhook.Webhooks[i].ClientConfig.Service == nil {","\t\t\treturn fmt.Errorf(\"missing service reference for webhook: %s\", wh.Name)","\t\t}","\t\twebhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())","\t}","","\tif ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil {","\t\treturn fmt.Errorf(\"error diffing webhooks: %w\", err)","\t} else if !ok {","\t\tlogger.Info(\"Updating webhook\")","\t\tmwhclient := ac.client.AdmissionregistrationV1().MutatingWebhookConfigurations()","\t\tif _, err := mwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil {","\t\t\treturn fmt.Errorf(\"failed to update webhook: %w\", err)","\t\t}","\t} else {","\t\tlogger.Info(\"Webhook is valid\")","\t}","\treturn nil","}","","func (ac *reconciler) mutate(ctx context.Context, req *admissionv1.AdmissionRequest) ([]byte, error) {","\tkind := req.Kind","\tnewBytes := req.Object.Raw","\toldBytes := req.OldObject.Raw","\t// Why, oh why are these different types...","\tgvk := schema.GroupVersionKind{","\t\tGroup:   kind.Group,","\t\tVersion: kind.Version,","\t\tKind:    kind.Kind,","\t}","","\tlogger := logging.FromContext(ctx)","\tif gvk.Group != \"\" || gvk.Version != \"v1\" || gvk.Kind != \"Pod\" {","\t\tlogger.Error(\"Unhandled kind: \", gvk)","\t\treturn nil, fmt.Errorf(\"unhandled kind: %v\", gvk)","\t}","","\t// nil values denote absence of `old` (create) or `new` (delete) objects.","\tvar oldObj, newObj corev1.Pod","","\tif len(newBytes) != 0 {","\t\tnewDecoder := json.NewDecoder(bytes.NewBuffer(newBytes))","\t\tif ac.disallowUnknownFields {","\t\t\tnewDecoder.DisallowUnknownFields()","\t\t}","\t\tif err := newDecoder.Decode(\u0026newObj); err != nil {","\t\t\treturn nil, fmt.Errorf(\"cannot decode incoming new object: %w\", err)","\t\t}","\t}","\tif len(oldBytes) != 0 {","\t\toldDecoder := json.NewDecoder(bytes.NewBuffer(oldBytes))","\t\tif ac.disallowUnknownFields {","\t\t\toldDecoder.DisallowUnknownFields()","\t\t}","\t\tif err := oldDecoder.Decode(\u0026oldObj); err != nil {","\t\t\treturn nil, fmt.Errorf(\"cannot decode incoming old object: %w\", err)","\t\t}","\t}","\tvar patches duck.JSONPatch","","\tvar err error","\t// Skip this step if the type we're dealing with is a duck type, since it is inherently","\t// incomplete and this will patch away all of the unspecified fields.","\t// Add these before defaulting fields, otherwise defaulting may cause an illegal patch","\t// because it expects the round tripped through Golang fields to be present already.","\trtp, err := roundTripPatch(newBytes, newObj)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"cannot create patch for round tripped newBytes: %w\", err)","\t}","\tpatches = append(patches, rtp...)","","\tctx = apis.WithinCreate(ctx)","\tctx = apis.WithUserInfo(ctx, \u0026req.UserInfo)","","\t// Default the new object.","\tif patches, err = setDefaults(ac.client, ctx, patches, newObj); err != nil {","\t\tlogger.Errorw(\"Failed the resource specific defaulter\", zap.Error(err))","\t\t// Return the error message as-is to give the defaulter callback","\t\t// discretion over (our portion of) the message that the user sees.","\t\treturn nil, err","\t}","","\treturn json.Marshal(patches)","}","","// roundTripPatch generates the JSONPatch that corresponds to round tripping the given bytes through","// the Golang type (JSON -\u003e Golang type -\u003e JSON). Because it is not always true that","// bytes == json.Marshal(json.Unmarshal(bytes)).","//","// For example, if bytes did not contain a 'spec' field and the Golang type specifies its 'spec'","// field without omitempty, then by round tripping through the Golang type, we would have added","// `'spec': {}`.","func roundTripPatch(bytes []byte, unmarshalled interface{}) (duck.JSONPatch, error) {","\tif unmarshalled == nil {","\t\treturn duck.JSONPatch{}, nil","\t}","\tmarshaledBytes, err := json.Marshal(unmarshalled)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"cannot marshal interface: %w\", err)","\t}","\treturn jsonpatch.CreatePatch(bytes, marshaledBytes)","}","","// setDefaults simply leverages apis.Defaultable to set defaults.","func setDefaults(client kubernetes.Interface, ctx context.Context, patches duck.JSONPatch, pod corev1.Pod) (duck.JSONPatch, error) {","\tbefore, after := pod.DeepCopyObject(), pod","","\tvar proxyEnv = []corev1.EnvVar{{","\t\tName:  \"HTTPS_PROXY\",","\t\tValue: os.Getenv(\"HTTPS_PROXY\"),","\t}, {","\t\tName:  \"HTTP_PROXY\",","\t\tValue: os.Getenv(\"HTTP_PROXY\"),","\t}, {","\t\tName:  \"NO_PROXY\",","\t\tValue: os.Getenv(\"NO_PROXY\"),","\t}}","","\tif after.Spec.Containers != nil {","\t\tfor i, container := range after.Spec.Containers {","\t\t\tnewEnvs := updateAndMergeEnv(container.Env, proxyEnv)","\t\t\tafter.Spec.Containers[i].Env = newEnvs","\t\t}","\t}","","\tafter = updateVolumeOptional(after)","\tpatch, err := duck.CreatePatch(before, after)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn append(patches, patch...), nil","}","","// updateVolumeOptional adds CA bundle ConfigMaps as optional volumes to avoid API call overhead.","// This function uses optional ConfigMap volumes that allow pods to start even when ConfigMaps don't exist,","// eliminating the need for expensive API calls during webhook processing.","func updateVolumeOptional(pod corev1.Pod) corev1.Pod {","\t// Add the trusted and service CA bundle ConfigMaps as optional volumes","\tpod.Spec.Volumes = common.AddCABundleConfigMapsToVolumesOptional(pod.Spec.Volumes)","","\t// Mount the volumes in all containers","\tfor i, c := range pod.Spec.Containers {","\t\tcommon.AddCABundlesToContainerVolumes(\u0026c)","\t\tpod.Spec.Containers[i] = c","\t}","\treturn pod","}","","// updateAndMergeEnv will merge two slices of env","// precedence will be given to second input if exist with same name key","func updateAndMergeEnv(containerenvs []corev1.EnvVar, proxyEnv []corev1.EnvVar) []corev1.EnvVar {","\tcontainerEnv := map[string]string{}","","\tfor _, env := range containerenvs {","\t\tcontainerEnv[env.Name] = env.Value","\t}","\tfor _, env := range proxyEnv {","\t\tvar updated bool","\t\tif _, ok := containerEnv[env.Name]; ok {","\t\t\t// If proxy set at global level and pipelinerun/taskrun level are same","\t\t\t// then priority will be given to pipelinerun/taskrun.","\t\t\tupdated = true","\t\t} else {","\t\t\tif env.Value != \"\" {","\t\t\t\tupdated = false","\t\t\t} else {","\t\t\t\tupdated = true","\t\t\t}","\t\t}","\t\tif !updated {","\t\t\tcontainerenvs = append(containerenvs, corev1.EnvVar{","\t\t\t\tName:  env.Name,","\t\t\t\tValue: env.Value,","\t\t\t})","\t\t}","\t}","\treturn containerenvs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0]},{"id":196,"path":"pkg/reconciler/shared/hash/hash.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package hash","","import (","\t\"crypto/sha256\"","\t\"encoding/json\"","\t\"fmt\"","","\t\"golang.org/x/mod/sumdb/dirhash\"",")","","// Compute generates an unique hash/string for the object pass to it.","// with sha256","func Compute(obj interface{}) (string, error) {","\td, err := json.Marshal(obj)","\tif err != nil {","\t\treturn \"\", err","\t}","\thashSha256 := sha256.New()","\thashSha256.Write(d)","\treturn fmt.Sprintf(\"%x\", hashSha256.Sum(nil)), nil","}","","// computes has for the given directory, tasks the directory and files recursively","// \"prefix\" used internally to produce constant base path,","// actual location will be replaced with this prefix on hash calculation","func ComputeHashDir(dirLocation, prefix string) (string, error) {","\treturn dirhash.HashDir(dirLocation, prefix, dirhash.DefaultHash)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,1,1,2,2,2,0,0,0,0,0,1,1,1]},{"id":197,"path":"pkg/reconciler/shared/tektonconfig/chain/chain.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package chain","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","func EnsureTektonChainExists(ctx context.Context, clients op.TektonChainInterface, tc *v1alpha1.TektonChain) (*v1alpha1.TektonChain, error) {","\ttcCR, err := GetChain(ctx, clients, v1alpha1.ChainResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif err := CreateChain(ctx, clients, tc); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\ttcCR, err = UpdateChain(ctx, tcCR, tc, clients)","\tif err != nil {","\t\treturn nil, err","\t}","","\tready, err := isTektonChainReady(tcCR)","\tif err != nil {","\t\treturn nil, err","\t}","\tif !ready {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn tcCR, err","}","","func EnsureTektonChainCRNotExists(ctx context.Context, clients op.TektonChainInterface) error {","\tif _, err := GetChain(ctx, clients, v1alpha1.ChainResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonChain CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.ChainResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonChain CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonChain %q failed to delete: %v\", v1alpha1.ChainResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}","","func GetChain(ctx context.Context, clients op.TektonChainInterface, name string) (*v1alpha1.TektonChain, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func CreateChain(ctx context.Context, clients op.TektonChainInterface, tt *v1alpha1.TektonChain) error {","\t_, err := clients.Create(ctx, tt, metav1.CreateOptions{})","\treturn err","}","","func UpdateChain(ctx context.Context, old *v1alpha1.TektonChain, new *v1alpha1.TektonChain, clients op.TektonChainInterface) (*v1alpha1.TektonChain, error) {","\t// if the chain spec is changed then update the instance","\tupdated := false","","\t// initialize labels(map) object","\tif old.ObjectMeta.Labels == nil {","\t\told.ObjectMeta.Labels = map[string]string{}","\t}","","\tif new.Spec.TargetNamespace != old.Spec.TargetNamespace {","\t\told.Spec.TargetNamespace = new.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Chain, new.Spec.Chain) {","\t\told.Spec.Chain = new.Spec.Chain","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) {","\t\told.Spec.Config = new.Spec.Config","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Chain.Options, new.Spec.Chain.Options) {","\t\told.Spec.Chain.Options = new.Spec.Chain.Options","\t\tupdated = true","\t}","","\tif old.ObjectMeta.OwnerReferences == nil {","\t\told.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tnewLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (newHasLabels \u0026\u0026 oldLabels != newLabels) {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, old, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn old, nil","}","","// isTektonChainReady will check the status conditions of the TektonChain and return true if the TektonChain is ready.","func isTektonChainReady(s *v1alpha1.TektonChain) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), nil","}","","func GetTektonChainCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonChain {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\treturn \u0026v1alpha1.TektonChain{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.ChainResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.TektonChainSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tConfig: config.Spec.Config,","\t\t\tChain:  config.Spec.Chain,","\t\t},","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0,0,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,2,2,2,2,2,0,2,2,2,1,1,2,0,2,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]},{"id":198,"path":"pkg/reconciler/shared/tektonconfig/controller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"os\"","\t\"regexp\"","","\t\"github.com/go-logr/zapr\"","\tmfc \"github.com/manifestival/client-go-client\"","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\ttektonChaininformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonchain\"","\ttektonConfiginformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonconfig\"","\ttektonInstallerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset\"","\ttektonPipelineinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline\"","\ttektonResultinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonresult\"","\ttektonTriggerinformer \"github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektontrigger\"","\ttektonConfigreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonconfig\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade\"","\t\"go.uber.org/zap\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tnamespaceinformer \"knative.dev/pkg/client/injection/kube/informers/core/v1/namespace\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/kmeta\"","\t\"knative.dev/pkg/logging\"",")","","// NewExtensibleController returns a controller extended to a specific platform","func NewExtensibleController(generator common.ExtensionGenerator) injection.ControllerConstructor {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","","\t\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating client from injected config\", zap.Error(err))","\t\t}","\t\tmflogger := zapr.NewLogger(logger.Named(\"manifestival\").Desugar())","","\t\tmanifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))","\t\tif err != nil {","\t\t\tlogger.Fatalw(\"Error creating initial manifest\", zap.Error(err))","\t\t}","","\t\toperatorVer, err := common.OperatorVersion(ctx)","\t\tif err != nil {","\t\t\tlogger.Fatal(err)","\t\t}","","\t\tc := \u0026Reconciler{","\t\t\tkubeClientSet:     kubeclient.Get(ctx),","\t\t\toperatorClientSet: operatorclient.Get(ctx),","\t\t\textension:         generator(ctx),","\t\t\tmanifest:          manifest,","\t\t\toperatorVersion:   operatorVer,","\t\t}","\t\tc.upgrade = upgrade.New(operatorVer, c.kubeClientSet, c.operatorClientSet, injection.GetConfig(ctx))","","\t\timpl := tektonConfigreconciler.NewImpl(ctx, c)","","\t\tlogger.Debug(\"Setting up event handlers for TektonConfig\")","","\t\tif _, err := tektonConfiginformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonConfig informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonPipelineinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonConfig{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonPipeline informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonTriggerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonConfig{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonTrigger informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonChaininformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonConfig{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonChain informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonResultinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonConfig{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonResult informer event handler: %w\", err)","\t\t}","","\t\tif _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1alpha1.TektonConfig{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register TektonInstallerSet informer event handler: %w\", err)","\t\t}","","\t\tif _, err := namespaceinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(enqueueCustomName(impl, v1alpha1.ConfigResourceName))); err != nil {","\t\t\tlogger.Panicf(\"Couldn't register Namespace informer event handler: %w\", err)","\t\t}","","\t\tif os.Getenv(\"AUTOINSTALL_COMPONENTS\") == \"true\" {","\t\t\t// try to ensure that there is an instance of tektonConfig","\t\t\tnewTektonConfig(operatorclient.Get(ctx), kubeclient.Get(ctx)).ensureInstance(ctx)","\t\t}","","\t\treturn impl","\t}","}","","// enqueueCustomName adds an event with name `config` in work queue so that","// whenever a namespace event occurs, the TektonConfig reconciler get triggered.","// This is required because we want to get our TektonConfig reconciler triggered","// for already existing and new namespaces, without manual intervention like adding","// a label/annotation on namespace to make it manageable by Tekton controller.","// This will also filter the namespaces by regex `^(openshift|kube)-`","// and enqueue only when namespace doesn't match the regex","func enqueueCustomName(impl *controller.Impl, name string) func(obj interface{}) {","\treturn func(obj interface{}) {","\t\tvar nsRegex = regexp.MustCompile(common.NamespaceIgnorePattern)","\t\tobject, err := kmeta.DeletionHandlingAccessor(obj)","\t\tif err == nil \u0026\u0026 !nsRegex.MatchString(object.GetName()) {","\t\t\timpl.EnqueueKey(types.NamespacedName{Namespace: \"\", Name: name})","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0]},{"id":199,"path":"pkg/reconciler/shared/tektonconfig/installerset_pruner.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","\t\"path/filepath\"","\t\"sync\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/logging\"",")","","const (","\tyamlDirNamePrunerManifest = \"tekton-pruner\"","\tlabelCreatedByValue       = \"TektonConfig\"",")","","var (","\tprunerInstallerSetLabel = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     labelCreatedByValue,","\t\t\tv1alpha1.InstallerSetType: v1alpha1.PrunerResourceName,","\t\t},","\t}","","\tprunerYamlDirHashFunc sync.Once","\tprunerManifestHash    prunerManifestSpec",")","","type prunerManifestSpec struct {","\tYamlLocation    string","\tComputedHash    string // this hash value computed from the pruner resources directory","\tTargetNamespace string","}","","func (pms *prunerManifestSpec) GetHash() string {","\treturn fmt.Sprintf(\"%s-%s\", pms.TargetNamespace, pms.ComputedHash)","}","","// reconciles pruner InstallerSets","// for pruner we manage RBAC and ServiceAccount via installer sets","// RBAC and ServiceAccount details are in yaml file and it is located in \"config/pruner/00-pruner.yaml\"","// in the runtime container the directory will be as \"$KO_DATA_PATH/tekton-pruner/\"","func (r *Reconciler) reconcilePrunerInstallerSet(ctx context.Context, tc *v1alpha1.TektonConfig) error {","\t// we have to calculate hash for the entire pruner yaml directory to confirm the changes.","\t// reads all yaml files from the directory and computes hash, it is expensive process to access disk on each call.","\t// hence calculate only once at startup, it helps not to degrade the performance of the reconcile loop","\t// also it not necessary to read the files frequently, as the files are shipped along the container and never change","\tprunerYamlDirHashFunc.Do(func() {","\t\tyamlDirLocation := filepath.Join(common.ComponentBaseDir(), yamlDirNamePrunerManifest)","\t\tcomputedHash, err := hash.ComputeHashDir(yamlDirLocation, \"/tekton-pruner-\")","\t\tif err != nil {","\t\t\tlogger := logging.FromContext(ctx)","\t\t\tlogger.Errorw(\"error on calculating hash for pruner manifest yaml directory\",","\t\t\t\t\"directory\", yamlDirLocation,","\t\t\t\terr,","\t\t\t)","\t\t}","\t\tprunerManifestHash = prunerManifestSpec{","\t\t\tYamlLocation: yamlDirLocation,","\t\t\tComputedHash: computedHash,","\t\t}","\t})","","\t// update targetNamespace","\tprunerManifestHash.TargetNamespace = tc.Spec.TargetNamespace","","\t// report error if the hash not calculated","\t// actual error will be printer on the log from above func on the first call of this method","\tif prunerManifestHash.ComputedHash == \"\" {","\t\treturn errors.New(\"error on calculation hash for pruner manifest yaml directory\")","\t}","","\t// verify availability of pruner InstallerSet","\tlabelSelector, err := common.LabelSelector(prunerInstallerSetLabel)","\tif err != nil {","\t\treturn err","\t}","\tactualInstallerSetName, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)","\tif err != nil {","\t\treturn err","\t}","","\tcreateInstallerSet := false","\tif actualInstallerSetName == \"\" {","\t\t// set create installerSet flag","\t\tcreateInstallerSet = true","\t}","","\tif !createInstallerSet {","\t\t// get the existing installerSet and compare the hash value","\t\t// if it is mismatch, have to delete the old one and create new one with the supplied yaml file","\t\tactualInstallerSet, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, actualInstallerSetName, metav1.GetOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tappliedHash, found := actualInstallerSet.GetAnnotations()[v1alpha1.LastAppliedHashKey]","\t\tif !found || prunerManifestHash.GetHash() != appliedHash {","\t\t\t// delete the existing installerSet","\t\t\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, actualInstallerSetName, metav1.DeleteOptions{}); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\t// set create installerSet flag","\t\t\tcreateInstallerSet = true","\t\t}","\t}","","\tif createInstallerSet {","\t\t// create installerSet with changes","\t\treturn r.createPrunerInstallerSet(ctx, tc)","\t}","","\treturn nil","}","","func (r *Reconciler) createPrunerInstallerSet(ctx context.Context, tc *v1alpha1.TektonConfig) error {","\t// get new manifest","\tmanifest := r.manifest.Append()","","\t// add resources to manifest from yaml files","\tif err := common.AppendManifest(\u0026manifest, prunerManifestHash.YamlLocation); err != nil {","\t\treturn err","\t}","","\t// apply transformers","\tif err := r.transformPruner(ctx, \u0026manifest, tc); err != nil {","\t\ttc.Status.MarkNotReady(\"transformation failed: \" + err.Error())","\t\treturn err","\t}","","\t// setup installerSet","\townerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())","\tprunerInstallerSet := \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: fmt.Sprintf(\"%s-\", v1alpha1.PrunerResourceName),","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.CreatedByKey:      labelCreatedByValue,","\t\t\t\tv1alpha1.InstallerSetType:  v1alpha1.PrunerResourceName,","\t\t\t\tv1alpha1.ReleaseVersionKey: r.operatorVersion,","\t\t\t},","\t\t\tAnnotations: map[string]string{","\t\t\t\tv1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,","\t\t\t\tv1alpha1.LastAppliedHashKey: prunerManifestHash.GetHash(),","\t\t\t},","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\t// include resources from manifest","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","","\t// creates installerSet in the cluster","\t_, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Create(ctx, prunerInstallerSet, metav1.CreateOptions{})","\treturn err","}","","// mutates the passed manifest with list of transformers","func (r *Reconciler) transformPruner(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) error {","\textra := []mf.Transformer{","\t\tcommon.InjectOperandNameLabelOverwriteExisting(v1alpha1.PrunerResourceName),","\t}","\textra = append(extra, r.extension.Transformers(comp)...)","\treturn common.Transform(ctx, manifest, comp, extra...)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1]},{"id":200,"path":"pkg/reconciler/shared/tektonconfig/instance.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"os\"","\t\"time\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/util/wait\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/logging\"",")","","const (","\t// RetryInterval specifies the time between two polls.","\tRetryInterval = 10 * time.Second","","\t// RetryTimeout specifies the timeout for the function PollImmediate to","\t// reach a certain status.","\tRetryTimeout = 5 * time.Minute","","\t// DefaultCRName specifies the default targetnamespaceto be used","\t// in autocreated TektonConfig instance","\tDefaultCRName = \"config\"",")","","type tektonConfig struct {","\toperatorClientSet versioned.Interface","\tkubeClientSet     kubernetes.Interface","\tnamespace         string","}","","func newTektonConfig(operatorClientSet versioned.Interface, kubeClientSet kubernetes.Interface) tektonConfig {","","\treturn tektonConfig{","\t\toperatorClientSet: operatorClientSet,","\t\tkubeClientSet:     kubeClientSet,","\t\tnamespace:         os.Getenv(\"DEFAULT_TARGET_NAMESPACE\"),","\t}","}","","// try to ensure an instance of TektonConfig exists","// if there is an error log error,and continue (an instance of TektonConfig will","// then need to be created by the user to get Tekton Pipelines components installed","func (tc tektonConfig) ensureInstance(ctx context.Context) {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"Ensuring TektonConfig instance exists\")","","\twaitErr := wait.PollUntilContextTimeout(ctx, RetryInterval, RetryTimeout, true, func(ctx context.Context) (bool, error) {","\t\t//note: the code in this block will be retired until","\t\t// an error is returned, or","\t\t// 'true' is returned, or","\t\t// timeout","\t\tinstance, err := tc.operatorClientSet.","\t\t\tOperatorV1alpha1().","\t\t\tTektonConfigs().Get(ctx, DefaultCRName, metav1.GetOptions{})","\t\tif err == nil {","\t\t\tlogger.Infow(\"Found existing TektonConfig instance\",","\t\t\t\t\"name\", instance.GetName(),","\t\t\t\t\"generation\", instance.GetGeneration(),","\t\t\t\t\"resourceVersion\", instance.GetResourceVersion())","\t\t\treturn true, nil","\t\t}","\t\tif !apierrs.IsNotFound(err) {","\t\t\tlogger.Errorw(\"Error getting TektonConfig\", \"error\", err)","\t\t\treturn false, nil","\t\t}","","\t\tlogger.Debugw(\"TektonConfig instance not found, creating new instance\")","\t\terr = tc.createInstance(ctx)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to create TektonConfig instance\", \"error\", err)","\t\t\treturn false, nil","\t\t}","","\t\tlogger.Infow(\"TektonConfig instance created, verifying on next iteration\")","\t\t// even if there is no error after create,","\t\t// loop again to ensure the create is successful with a 'get; api call","\t\treturn false, nil","\t})","","\tif waitErr != nil {","\t\tlogger.Errorw(\"Failed to ensure TektonConfig instance exists after timeout\",","\t\t\t\"retryInterval\", RetryInterval.String(),","\t\t\t\"timeout\", RetryTimeout.String(),","\t\t\t\"error\", waitErr)","\t\tlogger.Warnw(\"TektonConfig instance must be created manually to install Pipelines components\")","\t} else {","\t\tlogger.Infow(\"Successfully ensured TektonConfig instance exists\")","\t}","}","","func (tc tektonConfig) createInstance(ctx context.Context) error {","\tpruneKeep := v1alpha1.PrunerDefaultKeep","\ttcCR := \u0026v1alpha1.TektonConfig{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName: v1alpha1.ConfigResourceName,","\t\t},","\t\tSpec: v1alpha1.TektonConfigSpec{","\t\t\tProfile: v1alpha1.ProfileAll,","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: tc.namespace,","\t\t\t},","\t\t\tPruner: v1alpha1.Prune{","\t\t\t\tDisabled:  false,","\t\t\t\tResources: v1alpha1.PruningDefaultResources,","\t\t\t\tKeep:      \u0026pruneKeep,","\t\t\t\tKeepSince: nil,","\t\t\t\tSchedule:  v1alpha1.PrunerDefaultSchedule,","\t\t\t},","\t\t},","\t}","\ttcCR.SetDefaults(ctx)","\t_, err := tc.operatorClientSet.OperatorV1alpha1().","\t\tTektonConfigs().Create(ctx, tcCR, metav1.CreateOptions{})","\treturn err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":201,"path":"pkg/reconciler/shared/tektonconfig/pipeline/pipeline.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package pipeline","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"knative.dev/pkg/apis\"","","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","func EnsureTektonPipelineExists(ctx context.Context, clients op.TektonPipelineInterface, tp *v1alpha1.TektonPipeline) (*v1alpha1.TektonPipeline, error) {","\ttpCR, err := GetPipeline(ctx, clients, v1alpha1.PipelineResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif err := CreatePipeline(ctx, clients, tp); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\ttpCR, err = UpdatePipeline(ctx, tpCR, tp, clients)","\tif err != nil {","\t\treturn nil, err","\t}","","\tok, err := isTektonPipelineReady(tpCR, err)","\tif err != nil {","\t\treturn nil, err","\t}","\tif !ok {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn tpCR, err","}","","func GetPipeline(ctx context.Context, clients op.TektonPipelineInterface, name string) (*v1alpha1.TektonPipeline, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func GetTektonPipelineCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonPipeline {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\treturn \u0026v1alpha1.TektonPipeline{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.PipelineResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.TektonPipelineSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tPipeline: config.Spec.Pipeline,","\t\t\tConfig:   config.Spec.Config,","\t\t},","\t}","}","","func CreatePipeline(ctx context.Context, clients op.TektonPipelineInterface, tp *v1alpha1.TektonPipeline) error {","\t_, err := clients.Create(ctx, tp, metav1.CreateOptions{})","\treturn err","}","","func UpdatePipeline(ctx context.Context, old *v1alpha1.TektonPipeline, new *v1alpha1.TektonPipeline, clients op.TektonPipelineInterface) (*v1alpha1.TektonPipeline, error) {","\t// if the pipeline spec is changed then update the instance","\tupdated := false","","\t// initialize labels(map) object","\tif old.ObjectMeta.Labels == nil {","\t\told.ObjectMeta.Labels = map[string]string{}","\t}","","\tif new.Spec.TargetNamespace != old.Spec.TargetNamespace {","\t\told.Spec.TargetNamespace = new.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Pipeline, new.Spec.Pipeline) {","\t\told.Spec.Pipeline = new.Spec.Pipeline","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) {","\t\told.Spec.Config = new.Spec.Config","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Performance, new.Spec.Performance) {","\t\told.Spec.Performance = new.Spec.Performance","\t\tupdated = true","\t}","","\tif old.ObjectMeta.OwnerReferences == nil {","\t\told.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tnewLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (newHasLabels \u0026\u0026 oldLabels != newLabels) {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Options, new.Spec.Options) {","\t\told.Spec.Options = new.Spec.Options","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, old, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn old, nil","}","","// IsTektonPipelineReady will check the status conditions of the TektonPipeline and return true if the TektonPipeline is ready.","func isTektonPipelineReady(s *v1alpha1.TektonPipeline, err error) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), err","}","","func GetTektonConfig() *v1alpha1.TektonConfig {","\treturn \u0026v1alpha1.TektonConfig{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName: v1alpha1.ConfigResourceName,","\t\t},","\t\tSpec: v1alpha1.TektonConfigSpec{","\t\t\tProfile: \"all\",","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: \"tekton-pipelines\",","\t\t\t},","\t\t},","\t}","}","","func EnsureTektonPipelineCRNotExists(ctx context.Context, clients op.TektonPipelineInterface) error {","\tif _, err := GetPipeline(ctx, clients, v1alpha1.PipelineResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonPipeline CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.PipelineResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonPipeline CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonPipeline %q failed to delete: %v\", v1alpha1.PipelineResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,2,2,2,2,2,0,2,1,1,1,0,2,2,2,1,1,2,0,2,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0]},{"id":202,"path":"pkg/reconciler/shared/tektonconfig/pruner/pruner.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package pruner","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","func EnsureTektonPrunerExists(ctx context.Context, clients op.TektonPrunerInterface, tp *v1alpha1.TektonPruner) (*v1alpha1.TektonPruner, error) {","\ttpCR, err := GetPruner(ctx, clients, v1alpha1.TektonPrunerResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif err := CreatePruner(ctx, clients, tp); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\ttpCR, err = UpdatePruner(ctx, tpCR, tp, clients)","\tif err != nil {","\t\treturn nil, err","\t}","","\tok, err := isTektonPrunerReady(tpCR, err)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif !ok {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn tpCR, err","}","","func GetPruner(ctx context.Context, clients op.TektonPrunerInterface, name string) (*v1alpha1.TektonPruner, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func GetTektonPrunerCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonPruner {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\treturn \u0026v1alpha1.TektonPruner{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.TektonPrunerResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.TektonPrunerSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tConfig: config.Spec.Config,","\t\t\tPruner: config.Spec.TektonPruner,","\t\t},","\t}","}","","func CreatePruner(ctx context.Context, clients op.TektonPrunerInterface, tp *v1alpha1.TektonPruner) error {","\t_, err := clients.Create(ctx, tp, metav1.CreateOptions{})","\treturn err","}","","func UpdatePruner(ctx context.Context, old *v1alpha1.TektonPruner, new *v1alpha1.TektonPruner, clients op.TektonPrunerInterface) (*v1alpha1.TektonPruner, error) {","\t// if the pruner spec is changed then update the instance","\tupdated := false","\t// initialize labels(map) object","\tif old.ObjectMeta.Labels == nil {","\t\told.ObjectMeta.Labels = map[string]string{}","\t}","","\tif new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] != old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\t\tupdated = true","\t}","","\tif new.Spec.TargetNamespace != old.Spec.TargetNamespace {","\t\told.Spec.TargetNamespace = new.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Pruner, new.Spec.Pruner) {","\t\told.Spec.Pruner = new.Spec.Pruner","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) {","\t\told.Spec.Config = new.Spec.Config","\t\tupdated = true","\t}","","\tif old.ObjectMeta.OwnerReferences == nil {","\t\told.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tnewLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (newHasLabels \u0026\u0026 oldLabels != newLabels) {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, old, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn old, nil","}","","// isTektonPrunerReady will check the status conditions of the TektonPruner and return true if the TektonPruner is ready.","func isTektonPrunerReady(s *v1alpha1.TektonPruner, err error) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), err","}","","func EnsureTektonPrunerCRNotExists(ctx context.Context, clients op.TektonPrunerInterface) error {","\tif _, err := GetPruner(ctx, clients, v1alpha1.TektonPrunerResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonPruner CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.TektonPrunerResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonPruner CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonPruner %q failed to delete: %v\", v1alpha1.TektonPrunerResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,0,2,2,2,0,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,1,1,0,2,2,2,2,0,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,2,2,1,1,1,0,2,2,2,1,1,2,0,2,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0]},{"id":203,"path":"pkg/reconciler/shared/tektonconfig/result/result.go","lines":["/*","Copyright 2024 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package result","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","// This Ensure TektonResult CR is exist or not","// if it exist then update it otherwise creates a new TektonResult CR","func EnsureTektonResultExists(ctx context.Context, clients op.TektonResultInterface, tr *v1alpha1.TektonResult) (*v1alpha1.TektonResult, error) {","\ttrCR, err := GetResult(ctx, clients, v1alpha1.ResultResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif err := CreateResult(ctx, clients, tr); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\ttrCR, err = UpdateResult(ctx, trCR, tr, clients)","\tif err != nil {","\t\treturn nil, err","\t}","","\tready, err := isTektonResultReady(trCR)","\tif err != nil {","\t\treturn nil, err","\t}","\tif !ready {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn trCR, err","}","","// This Ensure TektonResult CR is deleted successfully","func EnsureTektonResultCRNotExists(ctx context.Context, clients op.TektonResultInterface) error {","\tif _, err := GetResult(ctx, clients, v1alpha1.ResultResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonResult CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.ResultResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonResult CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonResult %q failed to delete: %v\", v1alpha1.ResultResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}","","// Get the TektonResult CR","func GetResult(ctx context.Context, clients op.TektonResultInterface, name string) (*v1alpha1.TektonResult, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","// Create the TektonResult CR","func CreateResult(ctx context.Context, clients op.TektonResultInterface, tr *v1alpha1.TektonResult) error {","\t_, err := clients.Create(ctx, tr, metav1.CreateOptions{})","\treturn err","}","","func isTektonResultReady(s *v1alpha1.TektonResult) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), nil","}","","// This update the existing TektonResult CR with updated TektonResult CR","func UpdateResult(ctx context.Context, old *v1alpha1.TektonResult, new *v1alpha1.TektonResult, clients op.TektonResultInterface) (*v1alpha1.TektonResult, error) {","\t// if the result spec is changed then update the instance","\tupdated := false","","\t// initialize labels(map) object","\tif old.ObjectMeta.Labels == nil {","\t\told.ObjectMeta.Labels = map[string]string{}","\t}","","\tif new.Spec.TargetNamespace != old.Spec.TargetNamespace {","\t\told.Spec.TargetNamespace = new.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.ResultsAPIProperties, new.Spec.ResultsAPIProperties) {","\t\told.Spec.ResultsAPIProperties = new.Spec.ResultsAPIProperties","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.LokiStackProperties, new.Spec.LokiStackProperties) {","\t\told.Spec.LokiStackProperties = new.Spec.LokiStackProperties","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Options, new.Spec.Options) {","\t\told.Spec.Options = new.Spec.Options","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Performance, new.Spec.Performance) {","\t\told.Spec.Performance = new.Spec.Performance","\t\tupdated = true","\t}","","\tif old.ObjectMeta.OwnerReferences == nil {","\t\told.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tnewLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (newHasLabels \u0026\u0026 oldLabels != newLabels) {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, old, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn old, nil","}","","// GetTektonResultCR create a TektonResult CR","func GetTektonResultCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonResult {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\treturn \u0026v1alpha1.TektonResult{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.ResultResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.TektonResultSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tResult: config.Spec.Result,","\t\t},","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,0,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0,0,0,2,2,2,0,0,2,2,2,2,0,2,2,2,1,1,0,2,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,2,2,2,2,2,0,2,2,2,1,1,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]},{"id":204,"path":"pkg/reconciler/shared/tektonconfig/scheduler/scheduler.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package scheduler","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","const (","\tKUEUE_GVK = \"kueue.x-k8s.io/v1beta1\"","\tCERT_GVK  = \"cert-manager.io/v1\"",")","","func EnsureTektonSchedulerExists(ctx context.Context, clients op.TektonSchedulerInterface, newScheduler *v1alpha1.TektonScheduler) (*v1alpha1.TektonScheduler, error) {","","\t// Update MultiKueueOverride","\t// If MultiCluster is enabled and MultiClusterRole=Hub then MultiKueueOverride should be true","\tnewScheduler.Spec.Config.MultiKueueOverride = !newScheduler.Spec.MultiClusterDisabled \u0026\u0026 newScheduler.Spec.MultiClusterRole == v1alpha1.MultiClusterRoleHub","\tTektonScheduler, err := GetTektonScheduler(ctx, clients, v1alpha1.TektonSchedulerResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif err := CreateScheduler(ctx, clients, newScheduler); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\tTektonScheduler, err = UpdateScheduler(ctx, TektonScheduler, newScheduler, clients)","\tif err != nil {","\t\treturn nil, err","\t}","","\tok, err := isTektonSchedulerReady(TektonScheduler, err)","\tif err != nil {","\t\treturn nil, err","\t}","","\tif !ok {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn TektonScheduler, err","}","","func GetTektonScheduler(ctx context.Context, clients op.TektonSchedulerInterface, name string) (*v1alpha1.TektonScheduler, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func GetTektonSchedulerCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonScheduler {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\treturn \u0026v1alpha1.TektonScheduler{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.TektonSchedulerResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.TektonSchedulerSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tScheduler: config.Spec.Scheduler,","\t\t},","\t}","}","","func CreateScheduler(ctx context.Context, clients op.TektonSchedulerInterface, scheduler *v1alpha1.TektonScheduler) error {","\t_, err := clients.Create(ctx, scheduler, metav1.CreateOptions{})","\treturn err","}","","func UpdateScheduler(ctx context.Context, old *v1alpha1.TektonScheduler, new *v1alpha1.TektonScheduler, clients op.TektonSchedulerInterface) (*v1alpha1.TektonScheduler, error) {","\t// if the scheduler spec is changed then update the instance","\tupdated := false","\t// initialize labels(map) object","\tif old.ObjectMeta.Labels == nil {","\t\told.ObjectMeta.Labels = map[string]string{}","\t}","","\tif new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] != old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\t\tupdated = true","\t}","","\tif new.Spec.TargetNamespace != old.Spec.TargetNamespace {","\t\told.Spec.TargetNamespace = new.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Scheduler, new.Spec.Scheduler) {","\t\told.Spec.Scheduler = new.Spec.Scheduler","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.SchedulerConfig, new.Spec.SchedulerConfig) {","\t\told.Spec.SchedulerConfig = new.Spec.SchedulerConfig","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.MultiClusterConfig, new.Spec.MultiClusterConfig) {","\t\told.Spec.MultiClusterConfig = new.Spec.MultiClusterConfig","\t\tupdated = true","\t}","","\tif old.ObjectMeta.OwnerReferences == nil {","\t\told.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tnewLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (newHasLabels \u0026\u0026 oldLabels != newLabels) {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, old, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn old, nil","}","","func isTektonSchedulerReady(s *v1alpha1.TektonScheduler, err error) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), err","}","","func EnsureTektonSchedulerCRNotExists(ctx context.Context, clients op.TektonSchedulerInterface) error {","\tif _, err := GetTektonScheduler(ctx, clients, v1alpha1.TektonSchedulerResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonScheduler CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.TektonSchedulerResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonScheduler CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonScheduler %q failed to delete: %v\", v1alpha1.TektonSchedulerResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}","","// EnsureTektonComponent validates that specific component is  deployed on cluster","func EnsureTektonComponent(ctx context.Context, tc *v1alpha1.TektonConfig, operatorClientSet clientset.Interface, operatorVersion string) error {","\tif tc.Spec.Scheduler.IsDisabled() {","\t\t// If TektonScheduler is disabled then uninstall the components","\t\treturn EnsureTektonSchedulerCRNotExists(ctx, operatorClientSet.OperatorV1alpha1().TektonSchedulers())","\t}","\t// Cert-Manager should also be pre-installed","\t_, err := operatorClientSet.Discovery().ServerResourcesForGroupVersion(CERT_GVK)","\tif err != nil {","\t\ttc.Status.MarkComponentNotReady(fmt.Sprintf(\"Please install cert-manager (%s) First, %s \", CERT_GVK, err.Error()))","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\t// Before Installing Scheduler, Make sure that Upstream Kueue is installed","\t_, err = operatorClientSet.Discovery().ServerResourcesForGroupVersion(KUEUE_GVK)","\tif err != nil {","\t\ttc.Status.MarkComponentNotReady(fmt.Sprintf(\"Please install kueue (%s) First, %s \", KUEUE_GVK, err.Error()))","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","","\t// If Scheduler is installed then create TektonScheduler CR","\tTektonScheduler := GetTektonSchedulerCR(tc, operatorVersion)","\tif _, err := EnsureTektonSchedulerExists(ctx, operatorClientSet.OperatorV1alpha1().TektonSchedulers(), TektonScheduler); err != nil {","\t\ttc.Status.MarkComponentNotReady(fmt.Sprintf(\"TektonScheduler : %s\", err.Error()))","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,0]},{"id":205,"path":"pkg/reconciler/shared/tektonconfig/tektonconfig.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektonconfig","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\ttektonConfigreconciler \"github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonconfig\"","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/chain\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/pipeline\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/pruner\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/result\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/scheduler\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/trigger\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","// Reconciler implements controller.Reconciler for TektonConfig resources.","type Reconciler struct {","\t// kubeClientSet allows us to talk to the k8s for core APIs","\tkubeClientSet kubernetes.Interface","\t// operatorClientSet allows us to configure operator objects","\toperatorClientSet clientset.Interface","\t// Platform-specific behavior to affect the transform","\textension       common.Extension","\tmanifest        mf.Manifest","\toperatorVersion string","\t// performs pre and post upgrade operations","\tupgrade *upgrade.Upgrade","}","","// Check that our Reconciler implements controller.Reconciler","var (","\t_ tektonConfigreconciler.Interface = (*Reconciler)(nil)","\t_ tektonConfigreconciler.Finalizer = (*Reconciler)(nil)",")","","// FinalizeKind removes all resources after deletion of a TektonConfig.","func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonConfig) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","","\tif err := r.extension.Finalize(ctx, original); err != nil {","\t\tlogger.Error(\"Failed to finalize platform resources\", err)","\t}","","\tif original.Spec.Profile == v1alpha1.ProfileLite {","\t\treturn pipeline.EnsureTektonPipelineCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPipelines())","\t} else {","\t\t// TektonPipeline and TektonTrigger is common for profile type basic and all","\t\tif err := trigger.EnsureTektonTriggerCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonTriggers()); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := chain.EnsureTektonChainCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonChains()); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := result.EnsureTektonResultCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonResults()); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := pipeline.EnsureTektonPipelineCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPipelines()); err != nil {","\t\t\treturn err","\t\t}","\t}","","\t// remove pruner tektonInstallerSet","\tlabelSelector, err := common.LabelSelector(prunerInstallerSetLabel)","\tif err != nil {","\t\treturn err","\t}","\tif err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().DeleteCollection(","\t\tctx,","\t\tmetav1.DeleteOptions{},","\t\tmetav1.ListOptions{LabelSelector: labelSelector},","\t); err != nil {","\t\tlogger.Error(\"failed to delete pruner installerSet\", err)","\t\treturn err","\t}","","\treturn nil","}","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, tc *v1alpha1.TektonConfig) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx).With(\"tektonconfig\", tc.Name)","\ttc.Status.InitializeConditions()","\ttc.Status.SetVersion(r.operatorVersion)","","\tlogger.Debugw(\"Starting TektonConfig reconciliation\",","\t\t\"version\", r.operatorVersion,","\t\t\"profile\", tc.Spec.Profile,","\t\t\"status\", tc.Status.GetCondition(apis.ConditionReady))","","\tif tc.GetName() != v1alpha1.ConfigResourceName {","\t\tmsg := fmt.Sprintf(\"Resource ignored, Expected Name: %s, Got Name: %s\",","\t\t\tv1alpha1.ConfigResourceName,","\t\t\ttc.GetName(),","\t\t)","\t\tlogger.Errorw(\"Invalid resource name\", \"expectedName\", v1alpha1.ConfigResourceName, \"actualName\", tc.GetName())","\t\ttc.Status.MarkNotReady(msg)","\t\treturn nil","\t}","","\t// run pre upgrade","\tif err := r.upgrade.RunPreUpgrade(ctx); err != nil {","\t\tlogger.Errorw(\"Pre-upgrade failed\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"Pre-upgrade completed successfully\")","","\t// Mark TektonConfig Instance as Not Ready if an upgrade is needed","\tif err := r.markUpgrade(ctx, tc); err != nil {","\t\tlogger.Errorw(\"Failed to mark upgrade status\", \"error\", err)","\t\treturn err","\t}","","\t// reconcile target namespace","\tnsMetaLabels := map[string]string{}","\tnsMetaAnnotations := map[string]string{}","\tif tc.Spec.TargetNamespaceMetadata != nil {","\t\tnsMetaLabels = tc.Spec.TargetNamespaceMetadata.Labels","\t\tnsMetaAnnotations = tc.Spec.TargetNamespaceMetadata.Annotations","\t}","\tlogger.Debugw(\"Reconciling target namespace\",","\t\t\"labelCount\", len(nsMetaLabels),","\t\t\"annotationCount\", len(nsMetaAnnotations))","","\tif err := common.ReconcileTargetNamespace(ctx, nsMetaLabels, nsMetaAnnotations, tc, r.kubeClientSet); err != nil {","\t\tlogger.Errorw(\"Failed to reconcile target namespace\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"Target namespace reconciled successfully\")","","\t// Pre-reconcile extension hooks","\tif err := r.extension.PreReconcile(ctx, tc); err != nil {","\t\tif err == v1alpha1.RECONCILE_AGAIN_ERR {","\t\t\tlogger.Infow(\"Extensions requested requeue\")","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Errorw(\"Pre-install hook failed\", \"error\", err)","\t\ttc.Status.MarkPreInstallFailed(err.Error())","\t\treturn err","\t}","","\ttc.Status.MarkPreInstallComplete()","\tlogger.Debug(\"Pre-install completed successfully\")","","\t// Ensure Pipeline CR","\ttektonpipeline := pipeline.GetTektonPipelineCR(tc, r.operatorVersion)","\tlogger.Debug(\"Ensuring TektonPipeline CR exists\")","\tif _, err := pipeline.EnsureTektonPipelineExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPipelines(), tektonpipeline); err != nil {","\t\terrMsg := fmt.Sprintf(\"TektonPipeline: %s\", err.Error())","\t\tlogger.Errorw(\"Failed to ensure TektonPipeline exists\", \"error\", err)","\t\ttc.Status.MarkComponentNotReady(errMsg)","\t\tif err == v1alpha1.RECONCILE_AGAIN_ERR {","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\treturn nil","\t}","\tlogger.Debug(\"TektonPipeline CR reconciled successfully\")","","\t// Start Event based Pruner only if old Job based Pruner is Disabled.","\tif tc.Spec.TektonPruner.IsDisabled() {","\t\tlogger.Debugw(\"TektonPruner is disabled. Shutting down event based pruner\")","\t\tif err := pruner.EnsureTektonPrunerCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPruners()); err != nil {","\t\t\ttc.Status.MarkComponentNotReady(fmt.Sprintf(\"TektonPruner: %s\", err.Error()))","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t} else if !tc.Spec.Pruner.Disabled {","\t\tmsg := \"Invalid Pruner Configuration!! Both pruners, tektonpruner(event based) and pruner(job based) cannot be enabled simultaneously. Please disable one of them.\"","\t\tlogger.Error(msg)","\t\ttc.Status.MarkComponentNotReady(msg)","\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t} else {","\t\tlogger.Infof(\"TektonPruner is enabled.Creating TektonPipeline CR\")","\t\ttektonPruner := pruner.GetTektonPrunerCR(tc, r.operatorVersion)","\t\tif _, err := pruner.EnsureTektonPrunerExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPruners(), tektonPruner); err != nil {","\t\t\ttc.Status.MarkComponentNotReady(fmt.Sprintf(\"TektonPruner %s\", err.Error()))","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t}","","\tif err := r.EnsureSchedulerComponent(ctx, tc); err != nil {","\t\treturn err","\t}","","\t// Ensure Pipeline Trigger","\tif !tc.Spec.Trigger.Disabled \u0026\u0026 (tc.Spec.Profile == v1alpha1.ProfileAll || tc.Spec.Profile == v1alpha1.ProfileBasic) {","\t\ttektontrigger := trigger.GetTektonTriggerCR(tc, r.operatorVersion)","\t\tlogger.Debug(\"Ensuring TektonTrigger CR exists\")","\t\tif _, err := trigger.EnsureTektonTriggerExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonTriggers(), tektontrigger); err != nil {","\t\t\terrMsg := fmt.Sprintf(\"TektonTrigger: %s\", err.Error())","\t\t\tlogger.Errorw(\"Failed to ensure TektonTrigger exists\", \"error\", err)","\t\t\ttc.Status.MarkComponentNotReady(errMsg)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debug(\"TektonTrigger CR reconciled successfully\")","\t} else {","\t\tlogger.Debugw(\"Ensuring TektonTrigger CR doesn't exist\", \"profile\", tc.Spec.Profile, \"triggerDisabled\", tc.Spec.Trigger.Disabled)","\t\tif err := trigger.EnsureTektonTriggerCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonTriggers()); err != nil {","\t\t\terrMsg := fmt.Sprintf(\"TektonTrigger: %s\", err.Error())","\t\t\tlogger.Errorw(\"Failed to ensure TektonTrigger has been deleted\", \"error\", err)","\t\t\ttc.Status.MarkComponentNotReady(errMsg)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debug(\"TektonTrigger CR removal reconciled successfully\")","\t}","","\t// Ensure Chain CR","\tif !tc.Spec.Chain.Disabled {","\t\ttektonchain := chain.GetTektonChainCR(tc, r.operatorVersion)","\t\tlogger.Debug(\"Ensuring TektonChain CR exists\")","\t\tif _, err := chain.EnsureTektonChainExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonChains(), tektonchain); err != nil {","\t\t\terrMsg := fmt.Sprintf(\"TektonChain: %s\", err.Error())","\t\t\tlogger.Errorw(\"Failed to ensure TektonChain exists\", \"error\", err)","\t\t\ttc.Status.MarkComponentNotReady(errMsg)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debug(\"TektonChain CR reconciled successfully\")","\t} else {","\t\tlogger.Debugw(\"Ensuring TektonChain CR doesn't exist\", \"chainDisabled\", tc.Spec.Chain.Disabled)","\t\tif err := chain.EnsureTektonChainCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonChains()); err != nil {","\t\t\terrMsg := fmt.Sprintf(\"TektonChain: %s\", err.Error())","\t\t\tlogger.Errorw(\"Failed to ensure TektonChain has been deleted\", \"error\", err)","\t\t\ttc.Status.MarkComponentNotReady(errMsg)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debug(\"TektonChain CR removal reconciled successfully\")","\t}","","\t// Ensure Result CR","\tif !tc.Spec.Result.Disabled {","\t\ttektonresult := result.GetTektonResultCR(tc, r.operatorVersion)","\t\tlogger.Debug(\"Ensuring TektonResult CR exists\")","\t\tif _, err := result.EnsureTektonResultExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonResults(), tektonresult); err != nil {","\t\t\terrMsg := fmt.Sprintf(\"TektonResult %s\", err.Error())","\t\t\tlogger.Errorw(\"Failed to ensure TektonResult exists\", \"error\", err)","\t\t\ttc.Status.MarkComponentNotReady(errMsg)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debug(\"TektonResult CR reconciled successfully\")","\t} else {","\t\tlogger.Debugw(\"Ensuring TektonResult CR doesn't exist\", \"resultDisabled\", tc.Spec.Result.Disabled)","\t\tif err := result.EnsureTektonResultCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonResults()); err != nil {","\t\t\terrMsg := fmt.Sprintf(\"TektonResult: %s\", err.Error())","\t\t\tlogger.Errorw(\"Failed to ensure TektonResult has been deleted\", \"error\", err)","\t\t\ttc.Status.MarkComponentNotReady(errMsg)","\t\t\treturn v1alpha1.REQUEUE_EVENT_AFTER","\t\t}","\t\tlogger.Debug(\"TektonResult CR removal reconciled successfully\")","\t}","","\t// Ensure Pruner","\tif !tc.Spec.Pruner.Disabled {","\t\tlogger.Debugw(\"Reconciling pruner installer set\", \"prunerDisabled\", tc.Spec.Pruner.Disabled)","\t\terr := r.reconcilePrunerInstallerSet(ctx, tc)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to reconcile pruner installer set\", \"error\", err)","\t\t\treturn err","\t\t}","\t\tlogger.Debug(\"Pruner installer set reconciled successfully\")","\t}","","\t// Run resource pruning","\tif err := common.Prune(ctx, r.kubeClientSet, tc); err != nil {","\t\terrMsg := fmt.Sprintf(\"tekton-resource-pruner: %s\", err.Error())","\t\tlogger.Errorw(\"Resource pruning failed\", \"error\", err)","\t\ttc.Status.MarkComponentNotReady(errMsg)","\t} else {","\t\tlogger.Debug(\"Resource pruning completed successfully\")","\t}","","\ttc.Status.MarkComponentsReady()","\tlogger.Debug(\"All components marked ready\")","","\t// Post-reconcile extension hooks","\tif err := r.extension.PostReconcile(ctx, tc); err != nil {","\t\tlogger.Errorw(\"Post-reconcile hook failed\", \"error\", err)","\t\treturn err","\t}","","\ttc.Status.MarkPostInstallComplete()","\tlogger.Debug(\"Post-install completed successfully\")","","\t// Update the object for any spec changes","\tlogger.Debug(\"Updating TektonConfig status\")","\tif _, err := r.operatorClientSet.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, tc, metav1.UpdateOptions{}); err != nil {","\t\tlogger.Errorw(\"Failed to update TektonConfig status\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"TektonConfig status updated successfully\")","","\t// run post upgrade","\tif err := r.upgrade.RunPostUpgrade(ctx); err != nil {","\t\tlogger.Errorw(\"Post-upgrade failed\", \"error\", err)","\t\treturn err","\t}","\tlogger.Debug(\"Post-upgrade completed successfully\")","","\tlogger.Debugw(\"TektonConfig reconciliation completed successfully\",","\t\t\"status\", tc.Status.GetCondition(apis.ConditionReady))","\treturn nil","}","","func (r *Reconciler) markUpgrade(ctx context.Context, tc *v1alpha1.TektonConfig) error {","\tlabels := tc.GetLabels()","\tver, ok := labels[v1alpha1.ReleaseVersionKey]","\tif ok \u0026\u0026 ver == r.operatorVersion {","\t\treturn nil","\t}","\tif ok \u0026\u0026 ver != r.operatorVersion {","\t\ttc.Status.MarkComponentNotReady(\"Upgrade Pending\")","\t\ttc.Status.MarkPreInstallFailed(v1alpha1.UpgradePending)","\t\ttc.Status.MarkPostInstallFailed(v1alpha1.UpgradePending)","\t\ttc.Status.MarkNotReady(\"Upgrade Pending\")","\t}","\tif labels == nil {","\t\tlabels = map[string]string{}","\t}","\tlabels[v1alpha1.ReleaseVersionKey] = r.operatorVersion","\ttc.SetLabels(labels)","","\t// Update the object for any spec changes","\tif _, err := r.operatorClientSet.OperatorV1alpha1().TektonConfigs().Update(ctx, tc, metav1.UpdateOptions{}); err != nil {","\t\treturn err","\t}","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}","","func (r *Reconciler) EnsureSchedulerComponent(ctx context.Context, tc *v1alpha1.TektonConfig) error {","\treturn scheduler.EnsureTektonComponent(ctx, tc, r.operatorClientSet, r.operatorVersion)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1]},{"id":206,"path":"pkg/reconciler/shared/tektonconfig/trigger/trigger.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package trigger","","import (","\t\"context\"","\t\"fmt\"","\t\"reflect\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\top \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","func EnsureTektonTriggerExists(ctx context.Context, clients op.TektonTriggerInterface, tt *v1alpha1.TektonTrigger) (*v1alpha1.TektonTrigger, error) {","\tttCR, err := GetTrigger(ctx, clients, v1alpha1.TriggerResourceName)","\tif err != nil {","\t\tif !apierrs.IsNotFound(err) {","\t\t\treturn nil, err","\t\t}","\t\tif err := CreateTrigger(ctx, clients, tt); err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\tttCR, err = UpdateTrigger(ctx, ttCR, tt, clients)","\tif err != nil {","\t\treturn nil, err","\t}","","\tok, err := isTektonTriggerReady(ttCR, err)","\tif err != nil {","\t\treturn nil, err","\t}","\tif !ok {","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","","\treturn ttCR, err","}","","func GetTrigger(ctx context.Context, clients op.TektonTriggerInterface, name string) (*v1alpha1.TektonTrigger, error) {","\treturn clients.Get(ctx, name, metav1.GetOptions{})","}","","func GetTektonTriggerCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonTrigger {","\townerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())","\treturn \u0026v1alpha1.TektonTrigger{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            v1alpha1.TriggerResourceName,","\t\t\tOwnerReferences: []metav1.OwnerReference{ownerRef},","\t\t\tLabels: map[string]string{","\t\t\t\tv1alpha1.ReleaseVersionKey: operatorVersion,","\t\t\t},","\t\t},","\t\tSpec: v1alpha1.TektonTriggerSpec{","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: config.Spec.TargetNamespace,","\t\t\t},","\t\t\tConfig:  config.Spec.Config,","\t\t\tTrigger: config.Spec.Trigger,","\t\t},","\t}","}","","func CreateTrigger(ctx context.Context, clients op.TektonTriggerInterface, tt *v1alpha1.TektonTrigger) error {","\t_, err := clients.Create(ctx, tt, metav1.CreateOptions{})","\treturn err","}","","func UpdateTrigger(ctx context.Context, old *v1alpha1.TektonTrigger, new *v1alpha1.TektonTrigger, clients op.TektonTriggerInterface) (*v1alpha1.TektonTrigger, error) {","\t// if the trigger spec is changed then update the instance","\tupdated := false","","\t// initialize labels(map) object","\tif old.ObjectMeta.Labels == nil {","\t\told.ObjectMeta.Labels = map[string]string{}","\t}","","\tif new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] != old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\t\tupdated = true","\t}","","\tif new.Spec.TargetNamespace != old.Spec.TargetNamespace {","\t\told.Spec.TargetNamespace = new.Spec.TargetNamespace","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Trigger, new.Spec.Trigger) {","\t\told.Spec.Trigger = new.Spec.Trigger","\t\tupdated = true","\t}","","\tif !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) {","\t\told.Spec.Config = new.Spec.Config","\t\tupdated = true","\t}","","\tif old.ObjectMeta.OwnerReferences == nil {","\t\told.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences","\t\tupdated = true","\t}","","\toldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tnewLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]","\tif !oldHasLabels || (newHasLabels \u0026\u0026 oldLabels != newLabels) {","\t\told.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels","\t\tupdated = true","\t}","","\tif updated {","\t\t_, err := clients.Update(ctx, old, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\treturn nil, err","\t\t}","\t\treturn nil, v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn old, nil","}","","// isTektonTriggerReady will check the status conditions of the TektonTrigger and return true if the TektonTrigger is ready.","func isTektonTriggerReady(s *v1alpha1.TektonTrigger, err error) (bool, error) {","\tif s.GetStatus() != nil \u0026\u0026 s.GetStatus().GetCondition(apis.ConditionReady) != nil {","\t\tif strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) {","\t\t\treturn false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR","\t\t}","\t}","\treturn s.Status.IsReady(), err","}","","func GetTektonConfig() *v1alpha1.TektonConfig {","\treturn \u0026v1alpha1.TektonConfig{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName: v1alpha1.ConfigResourceName,","\t\t},","\t\tSpec: v1alpha1.TektonConfigSpec{","\t\t\tProfile: \"all\",","\t\t\tCommonSpec: v1alpha1.CommonSpec{","\t\t\t\tTargetNamespace: \"tekton-pipelines\",","\t\t\t},","\t\t},","\t}","}","","func EnsureTektonTriggerCRNotExists(ctx context.Context, clients op.TektonTriggerInterface) error {","\tif _, err := GetTrigger(ctx, clients, v1alpha1.TriggerResourceName); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonTrigger CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","\t// if the Get was successful, try deleting the CR","\tif err := clients.Delete(ctx, v1alpha1.TriggerResourceName, metav1.DeleteOptions{}); err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\t// TektonTrigger CR is gone, hence return nil","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"TektonTrigger %q failed to delete: %v\", v1alpha1.TriggerResourceName, err)","\t}","\t// if the Delete API call was success,","\t// then return requeue_event","\t// so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,2,1,1,2,0,0,2,2,2,2,0,2,2,1,1,2,2,2,0,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,2,2,2,0,2,1,1,1,0,2,1,1,1,0,2,1,1,1,0,2,2,2,1,1,1,0,2,2,2,1,1,2,0,2,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,1,0,0,2,1,1,1,1,1,0,0,0,0,2,0]},{"id":207,"path":"pkg/reconciler/shared/tektonconfig/upgrade/helper/migrator.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","// copied from: https://github.com/knative/pkg/blob/2783cd8cfad9ba907e6f31cafeef3eb2943424ee/apiextensions/storageversion/migrator.go","// local changes: continue the execution even though error happens on patching a resource","//---","","package upgrade","","import (","\t\"context\"","\t\"fmt\"","","\t\"go.uber.org/zap\"","\tapix \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"","\tapixclient \"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/dynamic\"","\t\"k8s.io/client-go/tools/pager\"",")","","// Migrator will read custom resource definitions and upgrade","// the associated resources to the latest storage version","type Migrator struct {","\tdynamicClient dynamic.Interface","\tapixClient    apixclient.Interface","\tlogger        *zap.SugaredLogger","}","","// NewMigrator will return a new Migrator","func NewMigrator(d dynamic.Interface, a apixclient.Interface, logger *zap.SugaredLogger) *Migrator {","\treturn \u0026Migrator{","\t\tdynamicClient: d,","\t\tapixClient:    a,","\t\tlogger:        logger,","\t}","}","","// Migrate takes a group resource (ie. resource.some.group.dev) and","// updates instances of the resource to the latest storage version","//","// This is done by listing all the resources and performing an empty patch","// which triggers a migration on the K8s API server","//","// Finally the migrator will update the CRD's status and drop older storage","// versions","func (m *Migrator) Migrate(ctx context.Context, gr schema.GroupResource) error {","\tcrdClient := m.apixClient.ApiextensionsV1().CustomResourceDefinitions()","","\tcrd, err := crdClient.Get(ctx, gr.String(), metav1.GetOptions{})","\tif err != nil {","\t\treturn fmt.Errorf(\"unable to fetch crd %s - %w\", gr, err)","\t}","","\tversion := storageVersion(crd)","","\tif version == \"\" {","\t\treturn fmt.Errorf(\"unable to determine storage version for %s\", gr)","\t}","","\tif err := m.migrateResources(ctx, gr.WithVersion(version)); err != nil {","\t\treturn err","\t}","","\tpatch := `{\"status\":{\"storedVersions\":[\"` + version + `\"]}}`","\t_, err = crdClient.Patch(ctx, crd.Name, types.StrategicMergePatchType, []byte(patch), metav1.PatchOptions{}, \"status\")","\tif err != nil {","\t\treturn fmt.Errorf(\"unable to drop storage version definition %s - %w\", gr, err)","\t}","","\treturn nil","}","","func (m *Migrator) migrateResources(ctx context.Context, gvr schema.GroupVersionResource) error {","\tclient := m.dynamicClient.Resource(gvr)","","\tlistFunc := func(ctx context.Context, opts metav1.ListOptions) (runtime.Object, error) {","\t\treturn client.Namespace(metav1.NamespaceAll).List(ctx, opts)","\t}","","\tonEach := func(obj runtime.Object) error {","\t\titem := obj.(metav1.Object)","","\t\t_, err := client.Namespace(item.GetNamespace()).","\t\t\tPatch(ctx, item.GetName(), types.MergePatchType, []byte(\"{}\"), metav1.PatchOptions{})","","\t\tif err != nil \u0026\u0026 !apierrs.IsNotFound(err) {","\t\t\tm.logger.Errorw(\"unable to patch a resource\",","\t\t\t\t\"resourceName\", item.GetName(),","\t\t\t\t\"namespace\", item.GetNamespace(),","\t\t\t\t\"groupVersionResource\", gvr,","\t\t\t\terr,","\t\t\t)","\t\t}","","\t\treturn nil","\t}","","\tpager := pager.New(listFunc)","\treturn pager.EachListItem(ctx, metav1.ListOptions{}, onEach)","}","","func storageVersion(crd *apix.CustomResourceDefinition) string {","\tvar version string","","\tfor _, v := range crd.Spec.Versions {","\t\tif v.Storage {","\t\t\tversion = v.Name","\t\t\tbreak","\t\t}","\t}","","\treturn version","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,1,1,0,2,2,2,0,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,0,0,2,2,2,2,2,2,2,0,0,0,2,0]},{"id":208,"path":"pkg/reconciler/shared/tektonconfig/upgrade/helper/storage_version_migrator.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package upgrade","","import (","\t\"context\"","","\t\"go.uber.org/zap\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","// performs crd storage version upgrade","// lists all the resources and,","// keeps only one storage version on the crd","// continues the execution, even though exception happens","func MigrateStorageVersion(ctx context.Context, logger *zap.SugaredLogger, migrator *Migrator, crdGroups []string) {","\tlogger.Infof(\"migrating %d group resources\", len(crdGroups))","","\tfor _, crdGroupString := range crdGroups {","\t\tcrdGroup := schema.ParseGroupResource(crdGroupString)","\t\tif crdGroup.Empty() {","\t\t\tlogger.Errorf(\"unable to parse group version: '%s'\", crdGroupString)","\t\t\tcontinue","\t\t}","\t\tlogger.Infow(\"migrating group resource\", \"crdGroup\", crdGroup)","\t\tif err := migrator.Migrate(ctx, crdGroup); err != nil {","\t\t\tif apierrs.IsNotFound(err) {","\t\t\t\tlogger.Infow(\"ignoring resource migration - unable to fetch a crdGroup\",","\t\t\t\t\t\"crdGroup\", crdGroup,","\t\t\t\t\terr,","\t\t\t\t)","\t\t\t\tcontinue","\t\t\t}","\t\t\tlogger.Errorw(\"failed to migrate a crdGroup\",","\t\t\t\t\"crdGroup\", crdGroup,","\t\t\t\terr,","\t\t\t)","\t\t\t// continue the execution, even though failures on the crd migration","\t\t} else {","\t\t\tlogger.Infow(\"migration completed\", \"crdGroup\", crdGroup)","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,0,1,1,1,1,0,2,2,2,0,0]},{"id":209,"path":"pkg/reconciler/shared/tektonconfig/upgrade/post_upgrade.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package upgrade","","import (","\t\"context\"","\t\"fmt\"","\t\"slices\"","\t\"strings\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\tupgrade \"github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade/helper\"","\t\"go.uber.org/zap\"","\tapixclient \"k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/dynamic\"","\t\"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/rest\"",")","","const (","\ttaskVersiondRetentionCount = 2",")","","// performs storage versions upgrade","// lists all the resources and keeps only one storage version","func upgradeStorageVersion(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","\t// resources to be upgraded","\tcrdGroups := []string{","","\t\t// dashboard","\t\t\"extensions.dashboard.tekton.dev\",","","\t\t// pipelines","\t\t\"clustertasks.tekton.dev\",","\t\t\"customruns.tekton.dev\",","\t\t\"pipelineruns.tekton.dev\",","\t\t\"pipelines.tekton.dev\",","\t\t\"taskruns.tekton.dev\",","\t\t\"tasks.tekton.dev\",","\t\t\"verificationpolicies.tekton.dev\",","\t\t\"resolutionrequests.resolution.tekton.dev\",","","\t\t// Pipelines-as-code","\t\t\"repositories.pipelinesascode.tekton.dev\",","","\t\t// triggers","\t\t\"clusterinterceptors.triggers.tekton.dev\",","\t\t\"clustertriggerbindings.triggers.tekton.dev\",","\t\t\"eventlisteners.triggers.tekton.dev\",","\t\t\"interceptors.triggers.tekton.dev\",","\t\t\"triggerbindings.triggers.tekton.dev\",","\t\t\"triggers.triggers.tekton.dev\",","\t\t\"triggertemplates.triggers.tekton.dev\",","\t}","","\tmigrator := upgrade.NewMigrator(","\t\tdynamic.NewForConfigOrDie(restConfig),","\t\tapixclient.NewForConfigOrDie(restConfig),","\t\tlogger,","\t)","","\tupgrade.MigrateStorageVersion(ctx, logger, migrator, crdGroups)","","\treturn nil","}","","// removeClusterTaskInstallerSets removes clusterTask, community clusterTask and all versioned clusterTask from the cluster","// as clusterTask has been removed","func removeClusterTaskInstallerSets(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","","\tif !v1alpha1.IsOpenShiftPlatform() {","\t\treturn nil","\t}","","\tclusterInstallerSetsList := []string{\"ClusterTask\", \"CommunityClusterTask\", \"VersionedClusterTask\"}","\ttisClient := operatorClient.OperatorV1alpha1().TektonInstallerSets()","","\tfor _, clusterIS := range clusterInstallerSetsList {","\t\tinstallerSetsLabelSelector := metav1.LabelSelector{","\t\t\tMatchLabels: map[string]string{","\t\t\t\tv1alpha1.InstallerSetType: fmt.Sprintf(\"%s-%s\", \"custom\", strings.ToLower(clusterIS)),","\t\t\t},","\t\t}","\t\tinstallerSetsLabel, err := common.LabelSelector(installerSetsLabelSelector)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\t// deletes clusterTask installersets","\t\tif err := tisClient.DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{","\t\t\tLabelSelector: installerSetsLabel,","\t\t}); err != nil {","\t\t\tlogger.Errorw(\"failed to delete a installerset\", \"installerSetName\", clusterIS, err)","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","// removeVersionedTaskInstallerSets removes the versioned resolver tasks installersets except latest 2 versions","func removeVersionedTaskInstallerSets(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","","\tif !v1alpha1.IsOpenShiftPlatform() {","\t\treturn nil","\t}","","\ttaskInstallerSetsLabelSelector := metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.InstallerSetType: fmt.Sprintf(\"%s-%s\", \"custom\", \"versionedresolvertask\"),","\t\t},","\t}","\ttaskInstallerSetsLabel, err := common.LabelSelector(taskInstallerSetsLabelSelector)","\tif err != nil {","\t\treturn err","\t}","","\treturn findAndDeleteInstallerSetsByLabelName(ctx, logger, operatorClient, taskInstallerSetsLabel)","}","","// removeVersionedStepActionsInstallerSets removes the versioned resolver step actions installersets except latest 2 versions","func removeVersionedStepActionsInstallerSets(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","","\tif !v1alpha1.IsOpenShiftPlatform() {","\t\treturn nil","\t}","","\tstepActionsInstallerSetsLabelSelector := metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.InstallerSetType: fmt.Sprintf(\"%s-%s\", \"custom\", \"versionedresolverstepaction\"),","\t\t},","\t}","\tstepActionsInstallerSetsLabel, err := common.LabelSelector(stepActionsInstallerSetsLabelSelector)","\tif err != nil {","\t\treturn err","\t}","","\treturn findAndDeleteInstallerSetsByLabelName(ctx, logger, operatorClient, stepActionsInstallerSetsLabel)","}","","func findAndDeleteInstallerSetsByLabelName(ctx context.Context, logger *zap.SugaredLogger, operatorClient versioned.Interface, installerSetsLabel string) error {","\ttsClient := operatorClient.OperatorV1alpha1().TektonInstallerSets()","","\tinstallerSets, err := tsClient.List(ctx, metav1.ListOptions{LabelSelector: installerSetsLabel})","\tif err != nil {","\t\treturn err","\t}","\tif len(installerSets.Items) \u003c taskVersiondRetentionCount {","\t\treturn nil","\t}","","\tinstallerListName := []string{}","\tfor _, taskIS := range installerSets.Items {","\t\tinstallerListName = append(installerListName, taskIS.Name)","\t}","","\tslices.Sort(installerListName)","\tslices.Reverse(installerListName)","","\tfor i := taskVersiondRetentionCount; i \u003c len(installerListName); i++ {","\t\tif err := tsClient.Delete(ctx, installerListName[i], metav1.DeleteOptions{}); err != nil {","\t\t\tlogger.Errorw(\"failed to delete a installerset\", \"installerSetName\", installerListName[i], err)","\t\t\treturn err","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,0]},{"id":210,"path":"pkg/reconciler/shared/tektonconfig/upgrade/pre_upgrade.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package upgrade","","import (","\t\"context\"","\t\"encoding/json\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner\"","\t\"gopkg.in/yaml.v3\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\ttektonresult \"github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult\"","\t\"go.uber.org/zap\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/rest\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/ptr\"",")","","// previous version of tekton operator uses a condition type called \"InstallSucceeded\" in status","// but in the recent version we do not have that field, hence \"InstallSucceeded\" condition never updated.","// for some reason, if it was in failed state, tektonConfig CR always in failed state","// even though all the resources are up and running. as the operator sums all the status conditions","// to avoid this, remove all the existing conditions from the status of the CR.","// conditions will be repopulated","func resetTektonConfigConditions(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","\t// fetch the current tektonConfig CR","\ttcCR, err := operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","","\t// remove all the existing conditions","\ttcCR.Status.Conditions = duckv1.Conditions{}","\t// update the status","\t_, err = operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, tcCR, metav1.UpdateOptions{})","\treturn err","}","","// previous version of the tekton operator uses default value which is false for enable-step-actions.","// In the new version, we are shipping stepAction, allowing users to create tasks using stepAction.","// Therefore, we are changing the enable-step-actions setting from false to true.","func upgradePipelineProperties(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","\t// fetch the current tektonConfig CR","\ttcCR, err := operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","","\t// For historical reasons, if it is upgraded from a historical version, this field may be nil","\tif tcCR.Spec.Pipeline.EnableStepActions == nil || !*tcCR.Spec.Pipeline.EnableStepActions {","\t\t// update enable-step-actions to true from false which is default.","\t\ttcCR.Spec.Pipeline.EnableStepActions = ptr.Bool(true)","\t\t_, err = operatorClient.OperatorV1alpha1().TektonConfigs().Update(ctx, tcCR, metav1.UpdateOptions{})","\t\treturn err","\t}","\treturn nil","}","","// previous version of the Tekton Operator created default tekton-results-tls on Openshift Platform","// causing it Tekton Results api failure","func deleteTektonResultsTLSSecret(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","\tif !v1alpha1.IsOpenShiftPlatform() {","\t\treturn nil","\t}","","\t// get the TekonResult CR","\ttrCR, err := operatorClient.OperatorV1alpha1().TektonResults().Get(ctx, v1alpha1.ResultResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","","\t// get the tekton-results-tls secret","\ttlsSecret, err := k8sClient.CoreV1().Secrets(trCR.Spec.TargetNamespace).Get(ctx, tektonresult.TlsSecretName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","","\t// delete default tekton-results-tls secret which has no OwnerReferences","\tif len(tlsSecret.OwnerReferences) == 0 {","\t\terr = k8sClient.CoreV1().Secrets(trCR.Spec.TargetNamespace).Delete(ctx, tektonresult.TlsSecretName, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\treturn nil","}","","// TODO: Remove the preUpgradeTektonPruner upgrade function in next operator release","func preUpgradeTektonPruner(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","\t// get tektonConfig CR","\tlogger.Infof(\"Performing Preupgrade for TektonPruner\")","\ttc, err := operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tlogger.Errorw(\"error on getting TektonConfig CR\", err)","\t\treturn err","\t}","","\tif tc.Spec.TektonPruner.IsDisabled() {","\t\tlogger.Infof(\"TektonPruner is disabled, skipping pre-upgrade for TektonPruner\")","\t\treturn nil","\t}","","\tvar prunerConfig v1alpha1.TektonPrunerConfig","\tcm, err := k8sClient.CoreV1().ConfigMaps(tc.Spec.TargetNamespace).Get(ctx, tektonpruner.PrunerConfigMapName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\tprunerConfig = v1alpha1.TektonPrunerConfig{}","\t\t}","\t}","\tkey := \"global-config\"","\tif cm != nil \u0026\u0026 cm.Data[key] != \"\" {","\t\tif err := yaml.Unmarshal([]byte(cm.Data[key]), \u0026prunerConfig.GlobalConfig); err != nil {","\t\t\tlogger.Errorf(\"error on Unmarshal TektonPruner ConfigMap data\", err)","\t\t\treturn err","\t\t}","\t}","","\ttc.Spec.TektonPruner.GlobalConfig = prunerConfig.GlobalConfig","","\t_, err = operatorClient.OperatorV1alpha1().TektonConfigs().Update(ctx, tc, metav1.UpdateOptions{})","\treturn err","}","","// preUpgradePipelinesAsCodeArtifacts checks if Pipelines as Code is installed and updates","// the hub catalog settings to use the artifact hub URL. It cleans up hub-catalog-name from:","// 1. TektonConfig CR settings","// 2. OpenShiftPipelinesAsCode CR settings","// 3. pipelines-as-code config map","func preUpgradePipelinesAsCodeArtifacts(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","\t// Only run on OpenShift platform","\tif !v1alpha1.IsOpenShiftPlatform() {","\t\tlogger.Infof(\"Not on OpenShift platform, skipping Pipelines as Code artifact upgrade\")","\t\treturn nil","\t}","","\t// Get TektonConfig CR","\tlogger.Infof(\"Performing preupgrade for Pipelines as Code artifact settings\")","\ttc, err := operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\tlogger.Infof(\"TektonConfig CR not found, skipping Pipelines as Code artifact upgrade\")","\t\t\treturn nil","\t\t}","\t\tlogger.Errorw(\"error on getting TektonConfig CR\", err)","\t\treturn err","\t}","","\t// Check if Pipelines as Code is enabled","\tif tc.Spec.Platforms.OpenShift.PipelinesAsCode == nil ||","\t\ttc.Spec.Platforms.OpenShift.PipelinesAsCode.Enable == nil ||","\t\t!*tc.Spec.Platforms.OpenShift.PipelinesAsCode.Enable {","\t\tlogger.Infof(\"Pipelines as Code is not enabled, skipping artifact upgrade\")","\t\treturn nil","\t}","","\t// Initialize settings if nil","\tif tc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Settings == nil {","\t\ttc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Settings = make(map[string]string)","\t}","","\t// Fetch PAC settings","\tsettings := tc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Settings","","\t// Set hub-catalog-type to artifacthub if not already set or if it's set to tektonhub","\tif catalogType, exists := settings[\"hub-catalog-type\"]; !exists || catalogType == \"tektonhub\" {","\t\tsettings[\"hub-catalog-type\"] = \"artifacthub\"","\t\tlogger.Infof(\"Updated hub-catalog-type to artifacthub\")","\t}","","\t// Set hub-url to https://artifacthub.io if not already set or if it's set to the old API URL","\tif hubURL, exists := settings[\"hub-url\"]; !exists || hubURL == \"https://artifacthub.io/api/v1\" || hubURL == \"https://api.hub.tekton.dev/v1\" {","\t\tsettings[\"hub-url\"] = \"https://artifacthub.io\"","\t\tlogger.Infof(\"Updated hub-url to https://artifacthub.io\")","\t}","","\t// remove hub-catalog-name key from setting if found","\tif _, exists := settings[\"hub-catalog-name\"]; exists {","\t\tdelete(settings, \"hub-catalog-name\")","\t\tlogger.Infof(\"Removed hub-catalog-name field from TektonConfig CR\")","\t}","","\t// Update the TektonConfig CR","\t_, err = operatorClient.OperatorV1alpha1().TektonConfigs().Update(ctx, tc, metav1.UpdateOptions{})","\tif err != nil {","\t\tlogger.Errorw(\"error updating TektonConfig CR with artifact settings\", err)","\t\treturn err","\t}","","\t// Also check and update the OpenShiftPipelinesAsCode CR if it exists","\terr = updateOpenShiftPipelinesAsCodeCR(ctx, logger, operatorClient)","\tif err != nil {","\t\tlogger.Errorw(\"error updating OpenShiftPipelinesAsCode CR\", err)","\t\treturn err","\t}","","\t// Also check and update the deployed pipelines-as-code config map if it exists","\terr = updatePipelinesAsCodeConfigMap(ctx, logger, k8sClient, tc.Spec.TargetNamespace)","\tif err != nil {","\t\tlogger.Errorw(\"error updating pipelines-as-code config map\", err)","\t\treturn err","\t}","","\tlogger.Infof(\"Successfully updated Pipelines as Code artifact settings in TektonConfig CR, OpenShiftPipelinesAsCode CR, and config map\")","\treturn nil","}","","// updatePipelinesAsCodeConfigMap checks and updates the deployed pipelines-as-code config map","// to remove hub-catalog-name if it exists","func updatePipelinesAsCodeConfigMap(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, targetNamespace string) error {","\tconfigMapName := \"pipelines-as-code\"","","\t// First check if the config map exists and has the hub-catalog-name field","\tcm, err := k8sClient.CoreV1().ConfigMaps(targetNamespace).Get(ctx, configMapName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\tlogger.Infof(\"pipelines-as-code config map not found, skipping config map update\")","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","","\t// Check if hub-catalog-name exists in the config map data","\tif cm.Data == nil {","\t\tlogger.Infof(\"pipelines-as-code config map has no data, skipping config map update\")","\t\treturn nil","\t}","","\t// Check if hub-catalog-name key exists","\tif val, exists := cm.Data[\"hub-catalog-name\"]; exists {","\t\t// Create a patch to remove the hub-catalog-name field","\t\t// Setting the field to null in the patch will remove it","\t\tpatch := map[string]interface{}{","\t\t\t\"data\": map[string]interface{}{","\t\t\t\t\"hub-catalog-name\": nil,","\t\t\t},","\t\t}","","\t\tpatchBytes, err := json.Marshal(patch)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"failed to marshal patch payload: %v\", err)","\t\t\treturn err","\t\t}","","\t\t// Apply the patch to remove the hub-catalog-name field","\t\t_, err = k8sClient.CoreV1().ConfigMaps(targetNamespace).Patch(ctx, configMapName, types.StrategicMergePatchType, patchBytes, metav1.PatchOptions{})","\t\tif err != nil {","\t\t\tlogger.Errorf(\"failed to patch pipelines-as-code config map: %v\", err)","\t\t\treturn err","\t\t}","","\t\tif val == \"\" {","\t\t\tlogger.Infof(\"Removed empty hub-catalog-name field from pipelines-as-code config map\")","\t\t} else {","\t\t\tlogger.Infof(\"Removed hub-catalog-name field (value: %s) from pipelines-as-code config map\", val)","\t\t}","\t\tlogger.Infof(\"Successfully updated pipelines-as-code config map\")","\t} else {","\t\tlogger.Infof(\"No catalog name entries found in pipelines-as-code config map, no update needed\")","\t}","","\treturn nil","}","","// updateOpenShiftPipelinesAsCodeCR checks and updates the OpenShiftPipelinesAsCode CR","// to remove hub-catalog-name if it exists","func updateOpenShiftPipelinesAsCodeCR(ctx context.Context, logger *zap.SugaredLogger, operatorClient versioned.Interface) error {","\t// First check if the OpenShiftPipelinesAsCode CR exists and has the hub-catalog-name field","\tpacCR, err := operatorClient.OperatorV1alpha1().OpenShiftPipelinesAsCodes().Get(ctx, v1alpha1.OpenShiftPipelinesAsCodeName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\tlogger.Infof(\"OpenShiftPipelinesAsCode CR not found, skipping PAC CR update\")","\t\t\treturn nil","\t\t}","\t\treturn err","\t}","","\t// Check if PAC settings exist","\tif pacCR.Spec.PACSettings.Settings == nil {","\t\tlogger.Infof(\"OpenShiftPipelinesAsCode CR has no settings, skipping PAC CR update\")","\t\treturn nil","\t}","","\t// Check if hub-catalog-name key exists","\tif val, exists := pacCR.Spec.PACSettings.Settings[\"hub-catalog-name\"]; exists {","\t\t// Create a patch to remove the hub-catalog-name field","\t\t// Setting the field to null in the patch will remove it","\t\tpatch := map[string]interface{}{","\t\t\t\"spec\": map[string]interface{}{","\t\t\t\t\"settings\": map[string]interface{}{","\t\t\t\t\t\"hub-catalog-name\": nil,","\t\t\t\t},","\t\t\t},","\t\t}","","\t\tpatchBytes, err := json.Marshal(patch)","\t\tif err != nil {","\t\t\tlogger.Errorf(\"failed to marshal patch payload: %v\", err)","\t\t\treturn err","\t\t}","","\t\t// Apply the patch to remove the hub-catalog-name field","\t\t_, err = operatorClient.OperatorV1alpha1().OpenShiftPipelinesAsCodes().Patch(ctx, v1alpha1.OpenShiftPipelinesAsCodeName, types.MergePatchType, patchBytes, metav1.PatchOptions{})","\t\tif err != nil {","\t\t\tlogger.Errorf(\"failed to patch OpenShiftPipelinesAsCode CR: %v\", err)","\t\t\treturn err","\t\t}","","\t\tif val == \"\" {","\t\t\tlogger.Infof(\"Removed empty hub-catalog-name field from OpenShiftPipelinesAsCode CR\")","\t\t} else {","\t\t\tlogger.Infof(\"Removed hub-catalog-name field (value: %s) from OpenShiftPipelinesAsCode CR\", val)","\t\t}","\t\tlogger.Infof(\"Successfully updated OpenShiftPipelinesAsCode CR\")","\t} else {","\t\tlogger.Infof(\"No catalog name entries found in OpenShiftPipelinesAsCode CR, no update needed\")","\t}","","\treturn nil","}","","// removeDeprecatedDisableAffinityAssistant removes the deprecated DisableAffinityAssistant field from tektonConfig CR spec during pre upgrade","// TODO: Remove this upgrade function in the release-v0.80.x","func removeDeprecatedDisableAffinityAssistant(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error {","\t// use merge patch to remove the deprecated field from the stored CR","\tpatch := map[string]interface{}{","\t\t\"spec\": map[string]interface{}{","\t\t\t\"pipeline\": map[string]interface{}{","\t\t\t\t\"disable-affinity-assistant\": nil,","\t\t\t},","\t\t},","\t}","","\tpatchBytes, err := json.Marshal(patch)","\tif err != nil {","\t\tlogger.Errorf(\"failed to marshal patch payload: %v\", err)","\t\treturn err","\t}","","\t_, err = operatorClient.OperatorV1alpha1().TektonConfigs().Patch(ctx, v1alpha1.ConfigResourceName, types.MergePatchType, patchBytes, metav1.PatchOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\tlogger.Debugw(\"patch to remove disable-affinity-assistant field returned error (field may not exist)\", \"error\", err)","\t\treturn nil","\t}","","\tlogger.Info(\"Successfully removed deprecated disable-affinity-assistant field from TektonConfig CR\")","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,1,0,0,0,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,1,0,0,0,2,2,2,2,2,2,1,0,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,0,0,0,2,2,2,2,2,2,2,2,0,2,1,1,1,0,2,2,2,2,2,2,0,2,2,2,1,1,1,0,0,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,0,0,0,2,2,2,1,1,1,0,0,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,0,0,2,2,1,1,1,0,0,2,2,1,1,1,0,0,2,2,1,1,1,0,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,2,2,2,2,2,2,2,2,1,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,2,2,1,1,1,1,1,0,0,2,2,0]},{"id":211,"path":"pkg/reconciler/shared/tektonconfig/upgrade/upgrade.go","lines":["/*","Copyright 2023 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package upgrade","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\t\"go.uber.org/zap\"","\tapierrs \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/rest\"","\t\"knative.dev/pkg/logging\"",")","","var (","\t// pre upgrade functions","\tpreUpgradeFunctions = []upgradeFunc{","\t\tresetTektonConfigConditions, // upgrade #1: removes conditions from TektonConfig CR, clears outdated conditions","\t\tupgradePipelineProperties,   // upgrade #2: update default value of enable-step-actions from false to true","\t\t// Todo: Remove the deleteTektonResultsTLSSecret upgrade function in next operator release","\t\tdeleteTektonResultsTLSSecret, // upgrade #5: deletes default tekton results tls certificate","\t\t// TODO: Remove the preUpgradeTektonPruner upgrade function in next operator release","\t\tpreUpgradeTektonPruner,                   // upgrade #5: pre upgrade tekton pruner","\t\tremoveDeprecatedDisableAffinityAssistant, // upgrade #6: remove deprecated DisableAffinityAssistant field from pipeline config","\t}","","\t// post upgrade functions","\tpostUpgradeFunctions = []upgradeFunc{","\t\tupgradeStorageVersion,                   // upgrade #1: performs storage version migration","\t\tremoveClusterTaskInstallerSets,          // upgrade #2: removes the clusterTask installerset","\t\tremoveVersionedTaskInstallerSets,        // upgrade #3: remove the older versioned resolver task installersets","\t\tremoveVersionedStepActionsInstallerSets, // upgrade #4: remove the older versioned step action resolver installersets","\t}",")","","type upgradeFunc = func(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error","","type Upgrade struct {","\tlogger          *zap.SugaredLogger","\toperatorVersion string","\tk8sClient       kubernetes.Interface","\toperatorClient  versioned.Interface","\trestConfig      *rest.Config","}","","func New(operatorVersion string, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) *Upgrade {","\treturn \u0026Upgrade{","\t\tk8sClient:       k8sClient,","\t\toperatorClient:  operatorClient,","\t\toperatorVersion: operatorVersion,","\t\trestConfig:      restConfig,","\t}","}","","func (ug *Upgrade) RunPreUpgrade(ctx context.Context) error {","\treturn ug.executeUpgrade(ctx, preUpgradeFunctions, true)","}","","func (ug *Upgrade) RunPostUpgrade(ctx context.Context) error {","\treturn ug.executeUpgrade(ctx, postUpgradeFunctions, false)","}","","func (ug *Upgrade) executeUpgrade(ctx context.Context, upgradeFunctions []upgradeFunc, isPreUpgrade bool) error {","\t// update logger","\tug.logger = logging.FromContext(ctx).Named(\"upgrade\")","","\t// if upgrade not required return from here","\tisUpgradeRequired, err := ug.isUpgradeRequired(ctx, isPreUpgrade)","\tif err != nil {","\t\treturn err","\t}","\tif !isUpgradeRequired {","\t\treturn ug.markUpgradeComplete(ctx, isPreUpgrade)","\t}","","\tif isPreUpgrade {","\t\tif err := ug.markUpgradeFalse(ctx, isPreUpgrade, \"Performing PreUpgrade\", \"Pre upgrade is in progress\"); err != nil {","\t\t\treturn err","\t\t}","\t\tug.logger.Debugw(\"executing pre upgrade functions\", \"numberOfFunctions\", len(upgradeFunctions))","\t} else {","\t\tif err := ug.markUpgradeFalse(ctx, isPreUpgrade, \"Performing PostUpgrade\", \"Post upgrade is in progress\"); err != nil {","\t\t\treturn err","\t\t}","\t\tug.logger.Debugw(\"executing post upgrade functions\", \"numberOfFunctions\", len(upgradeFunctions))","\t}","","\t// execute upgrade functions","\tfor _, _upgradeFunc := range upgradeFunctions {","\t\tif err := _upgradeFunc(ctx, ug.logger, ug.k8sClient, ug.operatorClient, ug.restConfig); err != nil {","\t\t\tug.logger.Error(\"error on upgrade\", err)","\t\t\treturn err","\t\t}","\t}","\tif isPreUpgrade {","\t\tug.logger.Debug(\"completed pre upgrade execution\")","\t} else {","\t\tug.logger.Debug(\"completed post upgrade execution\")","\t}","","\t// update upgrade version","\treturn ug.updateUpgradeVersion(ctx, isPreUpgrade)","}","","func (ug *Upgrade) isUpgradeRequired(ctx context.Context, isPreUpgrade bool) (bool, error) {","\ttcCR, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrs.IsNotFound(err) {","\t\t\treturn false, nil","\t\t}","\t\tug.logger.Error(\"error on getting TektonConfig CR\", err)","\t\treturn false, err","\t}","","\tappliedUpgradeVersion := tcCR.Status.GetPostUpgradeVersion()","\tif isPreUpgrade {","\t\tappliedUpgradeVersion = tcCR.Status.GetPreUpgradeVersion()","\t}","","\t_isUpgradeRequired := ug.operatorVersion != appliedUpgradeVersion","\treturn _isUpgradeRequired, nil","}","","func (ug *Upgrade) updateUpgradeVersion(ctx context.Context, isPreUpgrade bool) error {","\t_cr, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tug.logger.Error(\"error on getting TektonConfig CR\", err)","\t\treturn err","\t}","","\t// update upgrade version into TektonConfig CR, under status","\tif isPreUpgrade {","\t\t_cr.Status.SetPreUpgradeVersion(ug.operatorVersion)","\t} else {","\t\t_cr.Status.SetPostUpgradeVersion(ug.operatorVersion)","\t}","","\t_, err = ug.operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, _cr, metav1.UpdateOptions{})","\tif err != nil {","\t\tug.logger.Errorw(\"error on updating TektonConfig CR status\", \"version\", ug.operatorVersion, err)","\t\treturn err","\t}","\treturn v1alpha1.RECONCILE_AGAIN_ERR","}","","func (ug *Upgrade) markUpgradeFalse(ctx context.Context, isPreUpgrade bool, reason, message string) error {","\t_cr, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tug.logger.Error(\"error on getting TektonConfig CR\", err)","\t\treturn err","\t}","","\tisStatusChanged := false","\tif isPreUpgrade {","\t\tisStatusChanged = _cr.Status.MarkPreUpgradeFalse(reason, message)","\t} else {","\t\tisStatusChanged = _cr.Status.MarkPostUpgradeFalse(reason, message)","\t}","","\tif isStatusChanged {","\t\t_, err = ug.operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, _cr, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\tug.logger.Errorw(\"error on updating TektonConfig CR status\", \"version\", ug.operatorVersion, err)","\t\t\treturn err","\t\t}","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn nil","}","","func (ug *Upgrade) markUpgradeComplete(ctx context.Context, isPreUpgrade bool) error {","\t_cr, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})","\tif err != nil {","\t\tug.logger.Error(\"error on getting TektonConfig CR\", err)","\t\treturn err","\t}","","\tisStatusChanged := false","\tif isPreUpgrade {","\t\tisStatusChanged = _cr.Status.MarkPreUpgradeComplete()","\t} else {","\t\tisStatusChanged = _cr.Status.MarkPostUpgradeComplete()","\t}","","\tif isStatusChanged {","\t\t_, err = ug.operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, _cr, metav1.UpdateOptions{})","\t\tif err != nil {","\t\t\tug.logger.Errorw(\"error on updating TektonConfig CR status\", \"version\", ug.operatorVersion, err)","\t\t\treturn err","\t\t}","\t\treturn v1alpha1.RECONCILE_AGAIN_ERR","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,1,1,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,2,2,2,2,2,0,0,2,0,0,2,2,2,2,2,2,1,1,0,0,2,2,2,2,0,2,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,1,1,1,2,0,0,2,2,2,1,1,1,0,2,2,2,2,2,2,0,2,2,2,1,1,1,2,0,2,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,1,1,1,2,0,2,0]},{"id":212,"path":"pkg/reconciler/shared/tektoninstallerset/client.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","","\tversionedClients \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"",")","","var (","\ttisClient versionedClients.TektonInstallerSetInterface",")","","func InitTektonInstallerSetClient(ctx context.Context) {","\ttisClient = operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()","}","","func getTektonInstallerSetClient() versionedClients.TektonInstallerSetInterface {","\treturn tisClient","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1]},{"id":213,"path":"pkg/reconciler/shared/tektoninstallerset/install.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tversionedClients \"github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1\"","\t\"github.com/tektoncd/operator/pkg/reconciler/shared/hash\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","// Generates the installerset with name","func GenerateInstallerSetWithName(ctx context.Context, ci ComponentInstaller, name string) (*v1alpha1.TektonInstallerSet, error) {","\tnewISM := newTisMetaWithName(name)","\treturn generateInstallerSet(ctx, ci, newISM)","}","","// Generates the installerset with prefix name","func GenerateInstallerSetWithPrefixName(ctx context.Context, ci ComponentInstaller, namePrefix string) (*v1alpha1.TektonInstallerSet, error) {","\tnewISM := newTisMetaWithGenerateName(namePrefix)","\treturn generateInstallerSet(ctx, ci, newISM)","}","","// Generates the installerset without applying on the cluster","func generateInstallerSet(ctx context.Context, ci ComponentInstaller, tis *tisMeta) (*v1alpha1.TektonInstallerSet, error) {","\ttis.config(ctx, ci)","","\tmanifest, err := ci.GetManifest(ctx)","\tif err != nil {","\t\treturn nil, err","\t}","","\tis, err := makeInstallerSet(manifest, tis)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn is, nil","}","","// Creates the installerset on the cluster","func Create(ctx context.Context, is *v1alpha1.TektonInstallerSet) (*v1alpha1.TektonInstallerSet, error) {","\tclient := getTektonInstallerSetClient()","\treturn createWithClient(ctx, client, is)","}","","func createWithClient(ctx context.Context, client versionedClients.TektonInstallerSetInterface, is *v1alpha1.TektonInstallerSet) (*v1alpha1.TektonInstallerSet, error) {","\tcreatedIs, err := client.Create(ctx, is, metav1.CreateOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn createdIs, nil","}","","func makeInstallerSet(manifest *mf.Manifest, mt *tisMeta) (*v1alpha1.TektonInstallerSet, error) {","","\tis := \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:            mt.Name,","\t\t\tGenerateName:    mt.GenerateName,","\t\t\tLabels:          mt.Labels,","\t\t\tAnnotations:     mt.Annotations,","\t\t\tOwnerReferences: mt.OwnerReferences,","\t\t},","\t\tSpec: installerSpec(manifest),","\t}","","\tspecHash, err := getHash(is.Spec)","\tif err != nil {","\t\treturn nil, err","\t}","\tis.Annotations[v1alpha1.LastAppliedHashKey] = specHash","","\treturn is, nil","}","","// Returns the spec of Installerset","func installerSpec(manifest *mf.Manifest) v1alpha1.TektonInstallerSetSpec {","\treturn v1alpha1.TektonInstallerSetSpec{","\t\tManifests: manifest.Resources(),","\t}","}","","// Computes the hash using spec of TektonInstallerSet","func getHash(spec v1alpha1.TektonInstallerSetSpec) (string, error) {","\tspecHash, err := hash.Compute(spec)","\tif err != nil {","\t\treturn \"\", err","\t}","\treturn specHash, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,2,2,2,2,2,1,1,0,2,2,1,1,0,2,0,0,0,1,1,1,1,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,0,0,0,2,2,2,2,2,0,0,2,2,2,1,1,2,0]},{"id":214,"path":"pkg/reconciler/shared/tektoninstallerset/types.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tektoninstallerset","","import (","\t\"context\"","\t\"fmt\"","","\tmf \"github.com/manifestival/manifestival\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","type ComponentInstaller interface {","\tGetManifest(ctx context.Context) (*mf.Manifest, error)","\tGetLabels(ctx context.Context) map[string]string","\tGetAnnotations(ctx context.Context) map[string]string","\tGetOwnerReferences(ctx context.Context) []metav1.OwnerReference","}","","// TektonInstallerSet Meta","type tisMeta struct {","\tLabels          map[string]string","\tAnnotations     map[string]string","\tOwnerReferences []metav1.OwnerReference","\tName            string","\tGenerateName    string","}","","func newTisMeta() *tisMeta {","\treturn \u0026tisMeta{}","}","","func newTisMetaWithName(name string) *tisMeta {","\ttis := newTisMeta()","\ttis.Name = name","","\treturn tis","}","","func newTisMetaWithGenerateName(namePrefix string) *tisMeta {","\ttis := newTisMeta()","\ttis.GenerateName = fmt.Sprintf(\"%s-\", namePrefix)","","\treturn tis","}","","func (tis *tisMeta) config(ctx context.Context, ci ComponentInstaller) {","\ttis.Labels = ci.GetLabels(ctx)","\ttis.Annotations = ci.GetAnnotations(ctx)","\ttis.OwnerReferences = ci.GetOwnerReferences(ctx)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,0,2,2,2,2,2]},{"id":215,"path":"pkg/webhook/webhook.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package webhook","","import (","\t\"context\"","","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/webhook/configmaps\"","\t\"knative.dev/pkg/webhook/resourcesemantics\"","\t\"knative.dev/pkg/webhook/resourcesemantics/defaulting\"","\t\"knative.dev/pkg/webhook/resourcesemantics/validation\"",")","","var types = map[schema.GroupVersionKind]resourcesemantics.GenericCRD{","\tv1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonConfig):   \u0026v1alpha1.TektonConfig{},","\tv1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonPipeline): \u0026v1alpha1.TektonPipeline{},","\tv1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonTrigger):  \u0026v1alpha1.TektonTrigger{},","\tv1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonHub):      \u0026v1alpha1.TektonHub{},","\tv1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonResult):   \u0026v1alpha1.TektonResult{},","\tv1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonChain):    \u0026v1alpha1.TektonChain{},","\tv1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonPruner):   \u0026v1alpha1.TektonPruner{},","}","","func SetTypes(platform string) {","\tif platform == \"openshift\" {","\t\ttypes[v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonAddon)] = \u0026v1alpha1.TektonAddon{}","\t\ttypes[v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindOpenShiftPipelinesAsCode)] = \u0026v1alpha1.OpenShiftPipelinesAsCode{}","\t} else {","\t\ttypes[v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonDashboard)] = \u0026v1alpha1.TektonDashboard{}","\t}","}","","func NewDefaultingAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn defaulting.NewAdmissionController(ctx,","","\t\t// Name of the resource webhook.","\t\t\"webhook.operator.tekton.dev\",","\t\t// The path on which to serve the webhook.","\t\t\"/defaulting\",","","\t\t// The resources to validate and default.","\t\ttypes,","","\t\t// A function that infuses the context passed to Validate/SetDefaults with custom metadata.","\t\tfunc(ctx context.Context) context.Context {","\t\t\treturn ctx","\t\t},","","\t\t// Whether to disallow unknown fields.","\t\ttrue,","\t)","}","","func NewValidationAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn validation.NewAdmissionController(ctx,","","\t\t// Name of the resource webhook.","\t\t\"validation.webhook.operator.tekton.dev\",","","\t\t// The path on which to serve the webhook.","\t\t\"/resource-validation\",","","\t\t// The resources to validate and default.","\t\ttypes,","","\t\t// A function that infuses the context passed to Validate/SetDefaults with custom metadata.","\t\tfunc(ctx context.Context) context.Context {","\t\t\treturn ctx","\t\t},","","\t\t// Whether to disallow unknown fields.","\t\ttrue,","\t)","}","","func NewConfigValidationController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\treturn configmaps.NewAdmissionController(ctx,","\t\t// Name of the configmap webhook.","\t\t\"config.webhook.operator.tekton.dev\",","","\t\t// The path on which to serve the webhook.","\t\t\"/config-validation\",","","\t\tconfigmap.Constructors{","\t\t\tlogging.ConfigMapName(): logging.NewConfigFromConfigMap,","\t\t},","\t)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1]},{"id":216,"path":"pkg/webhook/webhook_init.go","lines":["package webhook","","import (","\t\"context\"","\t\"fmt\"","\t\"os\"","\t\"path/filepath\"","","\t\"github.com/go-logr/zapr\"","\tmfc \"github.com/manifestival/client-go-client\"","\tmf \"github.com/manifestival/manifestival\"","\t\"github.com/tektoncd/operator/pkg/apis/operator/v1alpha1\"","\tclientset \"github.com/tektoncd/operator/pkg/client/clientset/versioned\"","\toperatorclient \"github.com/tektoncd/operator/pkg/client/injection/client\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","","\t\"github.com/tektoncd/operator/pkg/reconciler/common\"","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","const (","\t// deprecated label, used in old versions","\t// keeps this reference to remove the existing webhook installersets","\tDEPRECATED_WEBHOOK_INSTALLERSET_LABEL = \"validating-defaulting-webhooks.operator.tekton.dev\"","","\t// this label is used to terminate the created webhook installerset on graceful termination","\t// use unique name, to identify the resource created by this pod","\tWEBHOOK_UNIQUE_LABEL = \"operator.tekton.dev/webhook-unique-identifier\"","","\t// primary label values to track webhook installersets","\tlabelCreatedByValue        = \"operator-webhook-init\"","\tlabelInstallerSetTypeValue = \"operatorValidatingDefaultingWebhook\"","","\tPOD_NAMESPACE_ENV_KEY = \"SYSTEM_NAMESPACE\"","\tPOD_NAME_ENV_KEY      = \"WEBHOOK_POD_NAME\"",")","","var (","\tErrNamespaceEnvNotSet = fmt.Errorf(\"namespace environment key %q not set\", POD_NAMESPACE_ENV_KEY)","","\t// primary labelSelector to list available webhooks installersets","\tprimaryLabelSelector = metav1.LabelSelector{","\t\tMatchLabels: map[string]string{","\t\t\tv1alpha1.CreatedByKey:     labelCreatedByValue,","\t\t\tv1alpha1.InstallerSetType: labelInstallerSetTypeValue,","\t\t},","\t}",")","","func CleanupWebhookResources(ctx context.Context) {","\tlogger := logging.FromContext(ctx)","\tclient := operatorclient.Get(ctx)","","\t// cannot use the ctx passed from main as it will be cancelled","\t// by the time we use in kube api calls","\tfreshContext := context.Background()","","\t// delete the webhook installersets created by this pod","\terr := deleteExistingInstallerSets(freshContext, client, true)","\tif err != nil {","\t\tlogger.Error(\"error on deleting webhook installersets\", err)","\t}","}","","func CreateWebhookResources(ctx context.Context) {","\tlogger := logging.FromContext(ctx)","","\tmanifest, err := fetchManifests(ctx)","\tif err != nil {","\t\tlogger.Fatalw(\"error creating initial manifest\", zap.Error(err))","\t}","","\tclient := operatorclient.Get(ctx)","\terr = deleteExistingInstallerSets(ctx, client, false)","\tif err != nil {","\t\tlogger.Fatalw(\"error deleting webhook installerset\", zap.Error(err))","\t}","","\tif err := createInstallerSet(ctx, client, *manifest); err != nil {","\t\tlogger.Fatalw(\"error creating webhook installerset\", zap.Error(err))","\t}","}","","func fetchManifests(ctx context.Context) (*mf.Manifest, error) {","\tlogger := logging.FromContext(ctx)","\tmfclient, err := mfc.NewClient(injection.GetConfig(ctx))","\tif err != nil {","\t\treturn nil, err","\t}","\tmflogger := zapr.NewLogger(logger.Named(\"manifestival\").Desugar())","\tmanifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Read manifests","\tkoDataDir := os.Getenv(common.KoEnvKey)","\tvalidating_defaulting_webhooks := filepath.Join(koDataDir, \"validating-defaulting-webhook\")","\tif err := common.AppendManifest(\u0026manifest, validating_defaulting_webhooks); err != nil {","\t\treturn nil, err","\t}","\treturn manifestTransform(\u0026manifest)","}","","func manifestTransform(m *mf.Manifest) (*mf.Manifest, error) {","\tns, ok := os.LookupEnv(POD_NAMESPACE_ENV_KEY)","\tif !ok || ns == \"\" {","\t\treturn nil, ErrNamespaceEnvNotSet","\t}","\ttfs := []mf.Transformer{","\t\tmf.InjectNamespace(ns),","\t}","\tresult, err := m.Transform(tfs...)","\treturn \u0026result, err","}","","func deleteExistingInstallerSets(ctx context.Context, client clientset.Interface, includeUniqueIdentifier bool) error {","\t// deleting the existing deprecated webhook installersets","\tinstallerSetList, err := client.OperatorV1alpha1().TektonInstallerSets().List(","\t\tctx,","\t\tmetav1.ListOptions{LabelSelector: DEPRECATED_WEBHOOK_INSTALLERSET_LABEL},","\t)","\tif err != nil {","\t\treturn err","\t}","\tfor _, is := range installerSetList.Items {","\t\terr = client.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, is.Name, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\t_primaryLabelSelector := primaryLabelSelector.DeepCopy()","\t// this pod name","\tif includeUniqueIdentifier {","\t\tpodName, ok := os.LookupEnv(POD_NAME_ENV_KEY)","\t\tif !ok {","\t\t\t// if pod env not set return","\t\t\treturn fmt.Errorf(\"pod name environment variable[%s] details are not set\", POD_NAME_ENV_KEY)","\t\t}","\t\t// use pod name as unique reference","\t\t_primaryLabelSelector.MatchLabels[WEBHOOK_UNIQUE_LABEL] = podName","\t}","","\t// delete all the existing webhook installersets","\tlabelSelector, err := common.LabelSelector(*_primaryLabelSelector)","\tif err != nil {","\t\treturn err","\t}","","\tinstallerSetList, err = client.OperatorV1alpha1().TektonInstallerSets().List(","\t\tctx,","\t\tmetav1.ListOptions{LabelSelector: labelSelector},","\t)","\tif err != nil {","\t\treturn err","\t}","\tfor _, is := range installerSetList.Items {","\t\terr = client.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, is.Name, metav1.DeleteOptions{})","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func createInstallerSet(ctx context.Context, oc clientset.Interface, manifest mf.Manifest) error {","\tis, err := makeInstallerSet(manifest)","\tif err != nil {","\t\treturn err","\t}","\titem, err := oc.OperatorV1alpha1().TektonInstallerSets().Create(ctx, is, metav1.CreateOptions{})","\tif err != nil {","\t\treturn err","\t}","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"webhook installerset created\",","\t\t\"name\", item.Name,","\t)","\treturn nil","}","","func makeInstallerSet(manifest mf.Manifest) (*v1alpha1.TektonInstallerSet, error) {","\t// this pod name","\tpodName, ok := os.LookupEnv(POD_NAME_ENV_KEY)","\tif !ok {","\t\t// if pod env not set return","\t\treturn nil, fmt.Errorf(\"pod name environment variable[%s] details are not set\", POD_NAME_ENV_KEY)","\t}","\t// use pod name as unique reference","\t_primaryLabelSelector := primaryLabelSelector.DeepCopy()","\t_primaryLabelSelector.MatchLabels[WEBHOOK_UNIQUE_LABEL] = podName","","\tinstallerSet := \u0026v1alpha1.TektonInstallerSet{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tGenerateName: fmt.Sprintf(\"%s-\", \"validating-mutating-webhook\"),","\t\t\tLabels:       _primaryLabelSelector.MatchLabels,","\t\t},","\t\tSpec: v1alpha1.TektonInstallerSetSpec{","\t\t\tManifests: manifest.Resources(),","\t\t},","\t}","","\treturn installerSet, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,0,2,0,0,0,2,2,1,1,0,2,2,2,2,2,1,1,2,2,2,1,1,0,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]}],"tree":{"name":".","type":"dir","children":[{"name":"pkg","type":"dir","children":[{"name":"apis","type":"dir","children":[{"name":"operator","type":"dir","children":[{"name":"v1alpha1","type":"dir","children":[{"name":"additional_options_validation.go","type":"file","fileId":0},{"name":"common.go","type":"file","fileId":1},{"name":"common_validation.go","type":"file","fileId":2},{"name":"manualapprovalgate_lifecycle.go","type":"file","fileId":3},{"name":"manualapprovalgate_types.go","type":"file","fileId":4},{"name":"openshiftpipelinesascode_defaults.go","type":"file","fileId":5},{"name":"openshiftpipelinesascode_lifecycle.go","type":"file","fileId":6},{"name":"openshiftpipelinesascode_types.go","type":"file","fileId":7},{"name":"openshiftpipelinesascode_validation.go","type":"file","fileId":8},{"name":"performance_validation.go","type":"file","fileId":9},{"name":"register.go","type":"file","fileId":10},{"name":"tektonaddon_defaults.go","type":"file","fileId":11},{"name":"tektonaddon_lifecycle.go","type":"file","fileId":12},{"name":"tektonaddon_types.go","type":"file","fileId":13},{"name":"tektonaddon_validation.go","type":"file","fileId":14},{"name":"tektonchain_defaults.go","type":"file","fileId":15},{"name":"tektonchain_lifecycle.go","type":"file","fileId":16},{"name":"tektonchain_types.go","type":"file","fileId":17},{"name":"tektonchain_validation.go","type":"file","fileId":18},{"name":"tektonconfig_defaults.go","type":"file","fileId":19},{"name":"tektonconfig_lifecycle.go","type":"file","fileId":20},{"name":"tektonconfig_types.go","type":"file","fileId":21},{"name":"tektonconfig_validation.go","type":"file","fileId":22},{"name":"tektondashboard_lifecycle.go","type":"file","fileId":23},{"name":"tektondashboard_types.go","type":"file","fileId":24},{"name":"tektondashboard_validation.go","type":"file","fileId":25},{"name":"tektonhub_defaults.go","type":"file","fileId":26},{"name":"tektonhub_lifecycle.go","type":"file","fileId":27},{"name":"tektonhub_types.go","type":"file","fileId":28},{"name":"tektonhub_validation.go","type":"file","fileId":29},{"name":"tektoninstallerset_lifecycle.go","type":"file","fileId":30},{"name":"tektonpipeline_defaults.go","type":"file","fileId":31},{"name":"tektonpipeline_lifecycle.go","type":"file","fileId":32},{"name":"tektonpipeline_types.go","type":"file","fileId":33},{"name":"tektonpipeline_validation.go","type":"file","fileId":34},{"name":"tektonpruner_defaults.go","type":"file","fileId":35},{"name":"tektonpruner_lifecycle.go","type":"file","fileId":36},{"name":"tektonpruner_types.go","type":"file","fileId":37},{"name":"tektonpruner_validation.go","type":"file","fileId":38},{"name":"tektonresult_defaults.go","type":"file","fileId":39},{"name":"tektonresult_lifecycle.go","type":"file","fileId":40},{"name":"tektonresult_types.go","type":"file","fileId":41},{"name":"tektonresult_validation.go","type":"file","fileId":42},{"name":"tektonscheduler_defaults.go","type":"file","fileId":43},{"name":"tektonscheduler_lifecycle.go","type":"file","fileId":44},{"name":"tektonscheduler_types.go","type":"file","fileId":45},{"name":"tektonscheduler_validation.go","type":"file","fileId":46},{"name":"tektontrigger_defaults.go","type":"file","fileId":47},{"name":"tektontrigger_lifecycle.go","type":"file","fileId":48},{"name":"tektontrigger_types.go","type":"file","fileId":49},{"name":"tektontrigger_validation.go","type":"file","fileId":50}]}]}]},{"name":"common","type":"dir","children":[{"name":"scc.go","type":"file","fileId":51}]},{"name":"reconciler","type":"dir","children":[{"name":"common","type":"dir","children":[{"name":"tektoninstallerset","type":"dir","children":[{"name":"defaultinstallerset.go","type":"file","fileId":65}]},{"name":"testing","type":"dir","children":[{"name":"util.go","type":"file","fileId":66}]},{"name":"certificates.go","type":"file","fileId":52},{"name":"common.go","type":"file","fileId":53},{"name":"deadlockbreaker.go","type":"file","fileId":54},{"name":"extensions.go","type":"file","fileId":55},{"name":"initcontroller.go","type":"file","fileId":56},{"name":"labels.go","type":"file","fileId":57},{"name":"name.go","type":"file","fileId":58},{"name":"nometrics.go","type":"file","fileId":59},{"name":"proxy.go","type":"file","fileId":60},{"name":"prune.go","type":"file","fileId":61},{"name":"releases.go","type":"file","fileId":62},{"name":"stages.go","type":"file","fileId":63},{"name":"targetnamespace.go","type":"file","fileId":64},{"name":"transformer_additional_options.go","type":"file","fileId":67},{"name":"transformer_inject_envvar.go","type":"file","fileId":68},{"name":"transformer_injectlabel.go","type":"file","fileId":69},{"name":"transformers.go","type":"file","fileId":70},{"name":"unstructured.go","type":"file","fileId":71},{"name":"utils.go","type":"file","fileId":72}]},{"name":"kubernetes","type":"dir","children":[{"name":"kubernetesplatform","type":"dir","children":[{"name":"kubernetesplatform.go","type":"file","fileId":73}]},{"name":"manualapprovalgate","type":"dir","children":[{"name":"controller.go","type":"file","fileId":74},{"name":"finalize.go","type":"file","fileId":75},{"name":"metrics.go","type":"file","fileId":76},{"name":"reconcile.go","type":"file","fileId":77},{"name":"transform.go","type":"file","fileId":78}]},{"name":"tektonchain","type":"dir","children":[{"name":"controller.go","type":"file","fileId":79},{"name":"installerset.go","type":"file","fileId":80},{"name":"metrics.go","type":"file","fileId":81},{"name":"tektonchain.go","type":"file","fileId":82},{"name":"transform.go","type":"file","fileId":83}]},{"name":"tektonconfig","type":"dir","children":[{"name":"extension","type":"dir","children":[{"name":"dashboard.go","type":"file","fileId":86}]},{"name":"controller.go","type":"file","fileId":84},{"name":"extension.go","type":"file","fileId":85}]},{"name":"tektondashboard","type":"dir","children":[{"name":"controller.go","type":"file","fileId":87},{"name":"finalize.go","type":"file","fileId":88},{"name":"reconcile.go","type":"file","fileId":89},{"name":"transform.go","type":"file","fileId":90}]},{"name":"tektonhub","type":"dir","children":[{"name":"controller.go","type":"file","fileId":91},{"name":"installerset.go","type":"file","fileId":92},{"name":"tektonhub.go","type":"file","fileId":93},{"name":"transform.go","type":"file","fileId":94}]},{"name":"tektoninstallerset","type":"dir","children":[{"name":"client","type":"dir","children":[{"name":"fake","type":"dir","children":[{"name":"client.go","type":"file","fileId":100}]},{"name":"check.go","type":"file","fileId":95},{"name":"cleanup.go","type":"file","fileId":96},{"name":"client.go","type":"file","fileId":97},{"name":"create.go","type":"file","fileId":98},{"name":"custom_versioned_clustertask.go","type":"file","fileId":99},{"name":"labels.go","type":"file","fileId":101},{"name":"list.go","type":"file","fileId":102},{"name":"main_set.go","type":"file","fileId":103},{"name":"obsolete_sets.go","type":"file","fileId":104},{"name":"pre_post_custom_set.go","type":"file","fileId":105},{"name":"update.go","type":"file","fileId":106}]},{"name":"controller.go","type":"file","fileId":107},{"name":"install.go","type":"file","fileId":108},{"name":"query.go","type":"file","fileId":109},{"name":"tektoninstallerset.go","type":"file","fileId":110},{"name":"transformer.go","type":"file","fileId":111}]},{"name":"tektonpipeline","type":"dir","children":[{"name":"controller.go","type":"file","fileId":112},{"name":"finalize.go","type":"file","fileId":113},{"name":"metrics.go","type":"file","fileId":114},{"name":"reconcile.go","type":"file","fileId":115},{"name":"transform.go","type":"file","fileId":116}]},{"name":"tektonpruner","type":"dir","children":[{"name":"controller.go","type":"file","fileId":117},{"name":"finalize.go","type":"file","fileId":118},{"name":"metrics.go","type":"file","fileId":119},{"name":"pruner_installerset.go","type":"file","fileId":120},{"name":"reconcile.go","type":"file","fileId":121},{"name":"transform.go","type":"file","fileId":122}]},{"name":"tektonresult","type":"dir","children":[{"name":"controller.go","type":"file","fileId":123},{"name":"filter.go","type":"file","fileId":124},{"name":"installerset.go","type":"file","fileId":125},{"name":"metrics.go","type":"file","fileId":126},{"name":"tektonresult.go","type":"file","fileId":127},{"name":"transform.go","type":"file","fileId":128}]},{"name":"tektonscheduler","type":"dir","children":[{"name":"controller.go","type":"file","fileId":129},{"name":"finalize.go","type":"file","fileId":130},{"name":"installerset.go","type":"file","fileId":131},{"name":"metrics.go","type":"file","fileId":132},{"name":"reconcile.go","type":"file","fileId":133},{"name":"transformer.go","type":"file","fileId":134}]},{"name":"tektontrigger","type":"dir","children":[{"name":"controller.go","type":"file","fileId":135},{"name":"finalize.go","type":"file","fileId":136},{"name":"metrics.go","type":"file","fileId":137},{"name":"reconcile.go","type":"file","fileId":138},{"name":"transform.go","type":"file","fileId":139}]}]},{"name":"openshift","type":"dir","children":[{"name":"annotation","type":"dir","children":[{"name":"annotation.go","type":"file","fileId":140},{"name":"controller.go","type":"file","fileId":141}]},{"name":"common","type":"dir","children":[{"name":"cabundle.go","type":"file","fileId":142},{"name":"transformer.go","type":"file","fileId":143}]},{"name":"manualapprovalgate","type":"dir","children":[{"name":"controller.go","type":"file","fileId":144},{"name":"extension.go","type":"file","fileId":145}]},{"name":"namespace","type":"dir","children":[{"name":"controller.go","type":"file","fileId":146},{"name":"namespace.go","type":"file","fileId":147}]},{"name":"openshiftpipelinesascode","type":"dir","children":[{"name":"controller.go","type":"file","fileId":148},{"name":"extension.go","type":"file","fileId":149},{"name":"pipelinerun_templates.go","type":"file","fileId":150},{"name":"reconcile.go","type":"file","fileId":151},{"name":"transform.go","type":"file","fileId":152},{"name":"update_route_in_configmap.go","type":"file","fileId":153}]},{"name":"openshiftplatform","type":"dir","children":[{"name":"openshiftplatform.go","type":"file","fileId":154}]},{"name":"tektonaddon","type":"dir","children":[{"name":"pipelinetemplates","type":"dir","children":[{"name":"pipelinetemplates.go","type":"file","fileId":161}]},{"name":"community_tasks.go","type":"file","fileId":155},{"name":"consolecli.go","type":"file","fileId":156},{"name":"controller.go","type":"file","fileId":157},{"name":"metrics.go","type":"file","fileId":158},{"name":"openshift_console.go","type":"file","fileId":159},{"name":"pipelinetemplate.go","type":"file","fileId":160},{"name":"resolver_task.go","type":"file","fileId":162},{"name":"resolver_task_versioned.go","type":"file","fileId":163},{"name":"tektonaddon.go","type":"file","fileId":164},{"name":"transform.go","type":"file","fileId":165},{"name":"transformer.go","type":"file","fileId":166},{"name":"triggers.go","type":"file","fileId":167}]},{"name":"tektonchain","type":"dir","children":[{"name":"controller.go","type":"file","fileId":168},{"name":"extension.go","type":"file","fileId":169}]},{"name":"tektonconfig","type":"dir","children":[{"name":"extension","type":"dir","children":[{"name":"addon.go","type":"file","fileId":174},{"name":"pipelinesascode.go","type":"file","fileId":175}]},{"name":"common.go","type":"file","fileId":170},{"name":"console_plugin_reconciler.go","type":"file","fileId":171},{"name":"controller.go","type":"file","fileId":172},{"name":"extension.go","type":"file","fileId":173},{"name":"rbac.go","type":"file","fileId":176}]},{"name":"tektonhub","type":"dir","children":[{"name":"controller.go","type":"file","fileId":177},{"name":"extension.go","type":"file","fileId":178}]},{"name":"tektonpipeline","type":"dir","children":[{"name":"controller.go","type":"file","fileId":179},{"name":"extension.go","type":"file","fileId":180}]},{"name":"tektonpruner","type":"dir","children":[{"name":"controller.go","type":"file","fileId":181},{"name":"extension.go","type":"file","fileId":182}]},{"name":"tektonresult","type":"dir","children":[{"name":"controller.go","type":"file","fileId":183},{"name":"extension.go","type":"file","fileId":184}]},{"name":"tektonscheduler","type":"dir","children":[{"name":"controller.go","type":"file","fileId":185},{"name":"extension.go","type":"file","fileId":186}]},{"name":"tektontrigger","type":"dir","children":[{"name":"controller.go","type":"file","fileId":187},{"name":"extension.go","type":"file","fileId":188},{"name":"transformers.go","type":"file","fileId":189}]}]},{"name":"platform","type":"dir","children":[{"name":"config.go","type":"file","fileId":190},{"name":"platform.go","type":"file","fileId":191},{"name":"platform_fake.go","type":"file","fileId":192},{"name":"types.go","type":"file","fileId":193}]},{"name":"proxy","type":"dir","children":[{"name":"controller.go","type":"file","fileId":194},{"name":"proxy.go","type":"file","fileId":195}]},{"name":"shared","type":"dir","children":[{"name":"hash","type":"dir","children":[{"name":"hash.go","type":"file","fileId":196}]},{"name":"tektonconfig","type":"dir","children":[{"name":"chain","type":"dir","children":[{"name":"chain.go","type":"file","fileId":197}]},{"name":"pipeline","type":"dir","children":[{"name":"pipeline.go","type":"file","fileId":201}]},{"name":"pruner","type":"dir","children":[{"name":"pruner.go","type":"file","fileId":202}]},{"name":"result","type":"dir","children":[{"name":"result.go","type":"file","fileId":203}]},{"name":"scheduler","type":"dir","children":[{"name":"scheduler.go","type":"file","fileId":204}]},{"name":"trigger","type":"dir","children":[{"name":"trigger.go","type":"file","fileId":206}]},{"name":"upgrade","type":"dir","children":[{"name":"helper","type":"dir","children":[{"name":"migrator.go","type":"file","fileId":207},{"name":"storage_version_migrator.go","type":"file","fileId":208}]},{"name":"post_upgrade.go","type":"file","fileId":209},{"name":"pre_upgrade.go","type":"file","fileId":210},{"name":"upgrade.go","type":"file","fileId":211}]},{"name":"controller.go","type":"file","fileId":198},{"name":"installerset_pruner.go","type":"file","fileId":199},{"name":"instance.go","type":"file","fileId":200},{"name":"tektonconfig.go","type":"file","fileId":205}]},{"name":"tektoninstallerset","type":"dir","children":[{"name":"client.go","type":"file","fileId":212},{"name":"install.go","type":"file","fileId":213},{"name":"types.go","type":"file","fileId":214}]}]}]},{"name":"webhook","type":"dir","children":[{"name":"webhook.go","type":"file","fileId":215},{"name":"webhook_init.go","type":"file","fileId":216}]}]}]},"summary":{"totalLines":18797,"coveredLines":7741,"percent":41.18210352715859}};
    </script>
    <script>
      window.COVERAGE_CONFIG = {"syntaxEnabled":true};
    </script>
    <script>
      (function() {
  'use strict';

  const data = window.COVERAGE_DATA;
  const config = window.COVERAGE_CONFIG || { syntaxEnabled: true };

  // State
  let currentFileId = null;
  let searchQuery = '';
  let contentSearchQuery = '';
  let matches = [];
  let currentMatchIndex = -1;
  let expandedDirs = new Set();
  let syntaxHighlightEnabled = config.syntaxEnabled;
  let sortMode = 'name'; // 'name' or 'coverage'
  let anchorLine = null;        // First line clicked (anchor for shift-select)
  let selectedRange = null;     // { start: N, end: M } or null

  // DOM elements
  const fileTree = document.getElementById('file-tree');
  const viewport = document.getElementById('viewport');
  const filePath = document.getElementById('file-path');
  const summary = document.getElementById('summary');
  const searchInput = document.getElementById('search-input');
  const contentSearch = document.getElementById('content-search');
  const matchInfo = document.getElementById('match-info');
  const prevMatch = document.getElementById('prev-match');
  const nextMatch = document.getElementById('next-match');
  const themeToggle = document.getElementById('theme-toggle');
  const syntaxToggle = document.getElementById('syntax-toggle');
  const helpModal = document.getElementById('help-modal');
  const closeHelp = document.getElementById('close-help');
  const helpToggle = document.getElementById('help-toggle');

  // Coverage cache: fileId -> percentage
  let coverageCache = new Map();

  function initCoverageCache() {
    data.files.forEach((file, idx) => {
      coverageCache.set(idx, calculateFileCoverage(idx));
    });
  }

  function calculateFileCoverage(fileId) {
    const file = data.files[fileId];
    let totalStatements = 0;
    let coveredStatements = 0;

    file.coverage.forEach(cov => {
      if (cov > 0) totalStatements++;
      if (cov === 2) coveredStatements++;
    });

    return totalStatements === 0 ? 0 : (coveredStatements / totalStatements) * 100;
  }

  function calculateDirectoryCoverage(node) {
    if (node.type === 'file') {
      return coverageCache.get(node.fileId) || 0;
    }

    let totalCoverage = 0;
    let fileCount = 0;

    node.children?.forEach(child => {
      const childCov = calculateDirectoryCoverage(child);
      totalCoverage += childCov;
      fileCount++;
    });

    return fileCount === 0 ? 0 : totalCoverage / fileCount;
  }

  function sortTreeNodes(node, mode) {
    if (!node.children || node.children.length === 0) return node;

    // Deep copy to avoid mutating original
    const sorted = { ...node };
    sorted.children = [...node.children].map(child => sortTreeNodes(child, mode));

    // Sort children
    sorted.children.sort((a, b) => {
      // Directories always first
      if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;

      if (mode === 'coverage') {
        const aCov = calculateDirectoryCoverage(a);
        const bCov = calculateDirectoryCoverage(b);
        console.log('Sorting:', a.name, '('+aCov.toFixed(1)+'%) vs', b.name, '('+bCov.toFixed(1)+'%)', '=', bCov - aCov);
        // Descending: high coverage first
        return aCov !== bCov ? bCov - aCov : a.name.localeCompare(b.name);
      }

      return a.name.localeCompare(b.name);
    });

    return sorted;
  }

  // Initialize
  function init() {
    initCoverageCache();
    loadSortPreference();
    renderSummary();
    renderTree();
    setupEventListeners();
    loadTheme();
    loadSyntaxPreference();

    // Check for deep link hash first, otherwise select first file
    if (!navigateToHash() && data.files.length > 0) {
      selectFile(0);
    }

    // Listen for hash changes (browser back/forward)
    window.addEventListener('hashchange', navigateToHash);
  }

  // Deep linking: parse URL hash
  function parseHash() {
    const hash = window.location.hash.slice(1);
    if (!hash) return null;

    const match = hash.match(/^file-(\d+)(?::line-(\d+)(?:-(\d+))?)?$/);
    if (!match) return null;

    return {
      fileId: parseInt(match[1], 10),
      lineStart: match[2] ? parseInt(match[2], 10) : null,
      lineEnd: match[3] ? parseInt(match[3], 10) : null
    };
  }

  // Deep linking: navigate to hash location
  function navigateToHash() {
    const target = parseHash();
    if (!target) return false;

    if (target.fileId < 0 || target.fileId >= data.files.length) return false;

    selectFile(target.fileId);

    if (target.lineStart) {
      requestAnimationFrame(() => {
        const lineEnd = target.lineEnd || target.lineStart;
        anchorLine = target.lineStart;
        selectedRange = { start: target.lineStart, end: lineEnd };
        selectLineRange(target.lineStart, lineEnd);
        scrollToLine(target.lineStart);
      });
    }

    return true;
  }

  // Deep linking: scroll to and highlight a line
  function scrollToLine(lineNum) {
    const lineEl = document.querySelector('.code-line[data-line="' + lineNum + '"]');
    if (!lineEl) return;

    lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  // Clear all selected lines
  function clearLineSelection() {
    document.querySelectorAll('.code-line.selected-line').forEach(el => {
      el.classList.remove('selected-line');
    });
  }

  // Select a range of lines (inclusive)
  function selectLineRange(start, end) {
    clearLineSelection();
    const minLine = Math.min(start, end);
    const maxLine = Math.max(start, end);
    for (let i = minLine; i <= maxLine; i++) {
      const lineEl = document.querySelector('.code-line[data-line="' + i + '"]');
      if (lineEl) {
        lineEl.classList.add('selected-line');
      }
    }
  }

  // Deep linking: update URL hash
  function updateHash(fileId, lineStart, lineEnd) {
    let hash = 'file-' + fileId;
    if (lineStart) {
      hash += ':line-' + lineStart;
      if (lineEnd && lineEnd !== lineStart) {
        // Normalise so start < end
        const minLine = Math.min(lineStart, lineEnd);
        const maxLine = Math.max(lineStart, lineEnd);
        hash = 'file-' + fileId + ':line-' + minLine + '-' + maxLine;
      }
    }
    history.replaceState(null, '', '#' + hash);
  }

  function renderSummary() {
    // Build summary safely using DOM methods
    summary.textContent = '';
    const span = document.createElement('span');
    span.className = 'percent';
    span.textContent = data.summary.percent.toFixed(1) + '%';
    summary.appendChild(span);
    summary.appendChild(document.createTextNode(
      ' coverage (' + data.summary.coveredLines + '/' + data.summary.totalLines + ' lines)'
    ));
  }

  function renderTree() {
    fileTree.textContent = '';
    // Auto-expand all top-level directories
    if (data.tree.children && data.tree.children.length > 0) {
      data.tree.children.forEach(child => {
        if (child.type === 'dir') {
          expandedDirs.add(getNodePath(child, 0));
        }
      });
    }
    const sortedTree = sortTreeNodes(data.tree, sortMode);
    renderNode(sortedTree, fileTree, 0);
  }

  function renderNode(node, container, depth) {
    if (node.name === '.' && node.type === 'dir') {
      // Root node, render children directly
      node.children.forEach(child => renderNode(child, container, depth));
      return;
    }

    const nodeEl = document.createElement('div');
    nodeEl.className = 'tree-node';
    nodeEl.dataset.name = node.name.toLowerCase();

    const item = document.createElement('div');
    item.className = 'tree-item';
    item.style.setProperty('--depth', depth);

    const icon = document.createElement('span');
    icon.className = 'icon';

    const name = document.createElement('span');
    name.className = 'name';
    name.textContent = node.name;

    if (node.type === 'dir') {
      const dirPath = getNodePath(node, depth);
      icon.textContent = expandedDirs.has(dirPath) ? '\u25BC' : '\u25B6';
      if (expandedDirs.has(dirPath)) {
        nodeEl.classList.add('expanded');
      }

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleDir(nodeEl, dirPath, icon);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to all directories
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);

      if (node.children && node.children.length > 0) {
        const children = document.createElement('div');
        children.className = 'tree-children';
        node.children.forEach(child => renderNode(child, children, depth + 1));
        nodeEl.appendChild(children);
      }
    } else {
      icon.textContent = '\uD83D\uDCC4';
      nodeEl.dataset.fileId = node.fileId;

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        selectFile(node.fileId);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to files
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);
    }

    container.appendChild(nodeEl);
  }

  function getNodePath(node, depth) {
    return node.name + '_' + depth;
  }

  function toggleDir(nodeEl, path, icon) {
    if (nodeEl.classList.contains('expanded')) {
      nodeEl.classList.remove('expanded');
      expandedDirs.delete(path);
      icon.textContent = '\u25B6';
    } else {
      nodeEl.classList.add('expanded');
      expandedDirs.add(path);
      icon.textContent = '\u25BC';
    }
  }

  function selectFile(fileId) {
    currentFileId = fileId;
    matches = [];
    currentMatchIndex = -1;
    matchInfo.textContent = '';
    contentSearch.value = '';
    contentSearchQuery = '';
    anchorLine = null;
    selectedRange = null;

    // Update selection in tree
    document.querySelectorAll('.tree-item.selected').forEach(el => {
      el.classList.remove('selected');
    });
    const selected = document.querySelector('[data-file-id="' + fileId + '"] .tree-item');
    if (selected) {
      selected.classList.add('selected');
    }

    const file = data.files[fileId];
    if (!file) return;

    filePath.textContent = file.path;
    renderCode(file);

    // Update URL hash for deep linking
    updateHash(fileId, null);
  }

  function renderCode(file) {
    viewport.textContent = '';

    if (!file.lines || file.lines.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty-state';
      const iconDiv = document.createElement('div');
      iconDiv.className = 'icon';
      iconDiv.textContent = '\uD83D\uDCED';
      const textDiv = document.createElement('div');
      textDiv.textContent = 'No content';
      empty.appendChild(iconDiv);
      empty.appendChild(textDiv);
      viewport.appendChild(empty);
      return;
    }

    const container = document.createElement('div');
    container.className = 'code-container';

    file.lines.forEach((line, idx) => {
      const lineEl = document.createElement('div');
      lineEl.className = 'code-line';
      lineEl.dataset.line = idx + 1;

      const cov = file.coverage[idx];
      if (cov === 2) {
        lineEl.classList.add('covered');
      } else if (cov === 1) {
        lineEl.classList.add('uncovered');
      }

      const gutter = document.createElement('div');
      gutter.className = 'gutter';

      const lineNum = document.createElement('div');
      lineNum.className = 'line-number';
      lineNum.textContent = idx + 1;
      lineNum.title = 'Click to select line, Shift+Click for range';

      // Add click handler for line number deep linking
      const lineNumber = idx + 1;
      lineNum.addEventListener('click', (e) => {
        e.stopPropagation();

        if (e.shiftKey && anchorLine !== null) {
          // Shift-click: select range from anchor to clicked line
          const start = Math.min(anchorLine, lineNumber);
          const end = Math.max(anchorLine, lineNumber);
          selectedRange = { start: start, end: end };
          selectLineRange(start, end);
          updateHash(currentFileId, start, end);
        } else {
          // Regular click: set anchor and select single line
          anchorLine = lineNumber;
          selectedRange = { start: lineNumber, end: lineNumber };
          selectLineRange(lineNumber, lineNumber);
          updateHash(currentFileId, lineNumber, null);
        }
      });

      const content = document.createElement('div');
      content.className = 'line-content';
      content.textContent = line || ' ';

      lineEl.appendChild(gutter);
      lineEl.appendChild(lineNum);
      lineEl.appendChild(content);
      container.appendChild(lineEl);
    });

    viewport.appendChild(container);

    // Apply syntax highlighting after rendering if enabled
    if (syntaxHighlightEnabled) {
      applySyntaxHighlighting();
    }
  }

  function setupEventListeners() {
    // File search
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchQuery = e.target.value.toLowerCase();
        filterTree();
      }, 300);
    });

    // Content search
    let contentTimeout;
    contentSearch.addEventListener('input', (e) => {
      clearTimeout(contentTimeout);
      contentTimeout = setTimeout(() => {
        contentSearchQuery = e.target.value;
        searchInFile();
      }, 300);
    });

    contentSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (e.shiftKey) {
          goToPrevMatch();
        } else {
          goToNextMatch();
        }
      }
    });

    prevMatch.addEventListener('click', goToPrevMatch);
    nextMatch.addEventListener('click', goToNextMatch);

    // Theme toggle
    themeToggle.addEventListener('click', toggleTheme);

    // Syntax toggle
    syntaxToggle.addEventListener('click', toggleSyntax);

    // Sort controls
    const sortButtons = document.querySelectorAll('.sort-btn');
    console.log('Found', sortButtons.length, 'sort buttons');
    sortButtons.forEach(btn => {
      console.log('Attaching click handler to button:', btn.dataset.sort);
      btn.addEventListener('click', () => {
        console.log('Sort button clicked:', btn.dataset.sort);
        changeSortMode(btn.dataset.sort);
      });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f' && currentFileId !== null) {
        e.preventDefault();
        contentSearch.focus();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        searchInput.focus();
      }
      // Help modal
      if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        showHelp();
      }
      if (e.key === 'Escape') {
        // Exit search if focused
        if (document.activeElement === searchInput) {
          searchInput.value = '';
          searchQuery = '';
          filterTree();
          searchInput.blur();
          viewport.focus();
          return;
        }
        if (document.activeElement === contentSearch) {
          contentSearch.value = '';
          contentSearchQuery = '';
          matchInfo.textContent = '';
          matches = [];
          currentMatchIndex = -1;
          if (currentFileId !== null) {
            renderCode(data.files[currentFileId]);
          }
          contentSearch.blur();
          viewport.focus();
          return;
        }
        hideHelp();
      }
    });

    closeHelp.addEventListener('click', hideHelp);
    helpToggle.addEventListener('click', showHelp);
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) hideHelp();
    });
  }

  function filterTree() {
    const nodes = document.querySelectorAll('.tree-node');

    if (!searchQuery) {
      nodes.forEach(n => n.classList.remove('hidden'));
      return;
    }

    nodes.forEach(node => {
      const name = node.dataset.name || '';
      const fileId = node.dataset.fileId;

      if (fileId !== undefined) {
        const file = data.files[parseInt(fileId)];
        const matchesQuery = file && file.path.toLowerCase().includes(searchQuery);
        node.classList.toggle('hidden', !matchesQuery);
      } else {
        const hasVisibleChild = Array.from(node.querySelectorAll('[data-file-id]')).some(f => {
          const fid = parseInt(f.dataset.fileId);
          const file = data.files[fid];
          return file && file.path.toLowerCase().includes(searchQuery);
        });
        node.classList.toggle('hidden', !hasVisibleChild);
        if (hasVisibleChild && searchQuery) {
          node.classList.add('expanded');
          const icon = node.querySelector('.icon');
          if (icon && icon.textContent === '\u25B6') {
            icon.textContent = '\u25BC';
          }
        }
      }
    });
  }

  function searchInFile() {
    matches = [];
    currentMatchIndex = -1;

    // Re-render code to clear highlights
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }

    if (!contentSearchQuery || currentFileId === null) {
      matchInfo.textContent = '';
      return;
    }

    const file = data.files[currentFileId];
    if (!file) return;

    const query = contentSearchQuery.toLowerCase();

    file.lines.forEach((line, idx) => {
      const text = line || '';
      const lowerText = text.toLowerCase();
      let pos = 0;
      let matchIndex;

      while ((matchIndex = lowerText.indexOf(query, pos)) !== -1) {
        matches.push({ line: idx, start: matchIndex, length: query.length });
        pos = matchIndex + 1;
      }
    });

    if (matches.length > 0) {
      highlightMatches();
      currentMatchIndex = 0;
      scrollToMatch(0);
      updateMatchInfo();
    } else {
      matchInfo.textContent = 'No matches';
    }
  }

  function highlightMatches() {
    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    // Group matches by line
    const matchesByLine = {};
    matches.forEach((m, idx) => {
      if (!matchesByLine[m.line]) matchesByLine[m.line] = [];
      matchesByLine[m.line].push({ ...m, idx });
    });

    Object.keys(matchesByLine).forEach(lineIdx => {
      const lineEl = lineEls[parseInt(lineIdx)];
      if (!lineEl) return;

      const content = lineEl.querySelector('.line-content');
      if (!content) return;

      const text = file.lines[parseInt(lineIdx)] || '';
      const lineMatches = matchesByLine[lineIdx].sort((a, b) => a.start - b.start);

      // Build content using DOM nodes for safety
      content.textContent = '';
      let lastEnd = 0;

      lineMatches.forEach(m => {
        // Text before match
        if (m.start > lastEnd) {
          content.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
        }
        // Match span
        const span = document.createElement('span');
        span.className = 'match-highlight';
        span.dataset.matchIdx = m.idx;
        span.textContent = text.substring(m.start, m.start + m.length);
        content.appendChild(span);
        lastEnd = m.start + m.length;
      });

      // Text after last match
      if (lastEnd < text.length) {
        content.appendChild(document.createTextNode(text.substring(lastEnd)));
      }

      // Handle empty line
      if (content.childNodes.length === 0) {
        content.textContent = ' ';
      }
    });
  }

  function scrollToMatch(idx) {
    document.querySelectorAll('.current-match').forEach(el => {
      el.classList.remove('current-match');
    });

    const matchEl = document.querySelector('[data-match-idx="' + idx + '"]');
    if (matchEl) {
      matchEl.classList.add('current-match');
      matchEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function updateMatchInfo() {
    if (matches.length === 0) {
      matchInfo.textContent = 'No matches';
    } else {
      matchInfo.textContent = (currentMatchIndex + 1) + '/' + matches.length;
    }
  }

  function goToNextMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex + 1) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function goToPrevMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex - 1 + matches.length) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function toggleTheme() {
    const body = document.body;
    const current = body.dataset.theme;
    const next = current === 'dark' ? 'light' : 'dark';
    body.dataset.theme = next;
    localStorage.setItem('coverage-theme', next);
  }

  function loadTheme() {
    const saved = localStorage.getItem('coverage-theme');
    if (saved) {
      document.body.dataset.theme = saved;
    }
  }

  function applySyntaxHighlighting() {
    if (!syntaxHighlightEnabled || currentFileId === null) return;
    if (typeof hljs === 'undefined') return;

    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    lineEls.forEach((lineEl, idx) => {
      const cov = file.coverage[idx];
      // Only highlight lines with no coverage info
      if (cov !== 0) return;

      const content = lineEl.querySelector('.line-content');
      if (!content || !content.textContent.trim()) return;

      const text = content.textContent;

      // Use hljs.highlight() which returns result object
      const result = hljs.highlight(text, { language: 'go' });

      // Parse the highlighted HTML safely using DOMParser
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + result.value + '</div>', 'text/html');
      const wrapper = doc.body.firstChild;

      // Clear and append parsed nodes
      content.textContent = '';
      while (wrapper.firstChild) {
        content.appendChild(wrapper.firstChild);
      }
    });
  }

  function toggleSyntax() {
    syntaxHighlightEnabled = !syntaxHighlightEnabled;
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
    localStorage.setItem('coverage-syntax', syntaxHighlightEnabled ? 'on' : 'off');

    // Re-render current file
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }
  }

  function loadSyntaxPreference() {
    const saved = localStorage.getItem('coverage-syntax');
    if (saved !== null) {
      // User preference overrides default
      syntaxHighlightEnabled = saved === 'on';
    }
    // Update button state
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
  }

  function changeSortMode(mode) {
    if (sortMode === mode) return;

    console.log('Changing sort mode from', sortMode, 'to', mode);
    sortMode = mode;
    localStorage.setItem('coverage-sort-mode', mode);

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === mode);
    });

    // Re-render tree
    renderTree();
  }

  function loadSortPreference() {
    const saved = localStorage.getItem('coverage-sort-mode');
    if (saved && (saved === 'name' || saved === 'coverage')) {
      sortMode = saved;
    }

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === sortMode);
    });
  }

  function showHelp() {
    helpModal.classList.remove('hidden');
  }

  function hideHelp() {
    helpModal.classList.add('hidden');
  }

  // Start the app
  init();
})();

    </script>
  </body>
</html>
