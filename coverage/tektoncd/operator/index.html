
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1alpha1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/additional_options_validation.go (88.9%)</option>
				
				<option value="file1">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/common.go (100.0%)</option>
				
				<option value="file2">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/common_validation.go (100.0%)</option>
				
				<option value="file3">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/manualapprovalgate_lifecycle.go (44.4%)</option>
				
				<option value="file4">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/manualapprovalgate_types.go (0.0%)</option>
				
				<option value="file5">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/openshiftpipelinesascode_defaults.go (81.7%)</option>
				
				<option value="file6">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/openshiftpipelinesascode_lifecycle.go (50.0%)</option>
				
				<option value="file7">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/openshiftpipelinesascode_types.go (0.0%)</option>
				
				<option value="file8">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/openshiftpipelinesascode_validation.go (91.2%)</option>
				
				<option value="file9">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/performance_validation.go (92.3%)</option>
				
				<option value="file10">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/register.go (100.0%)</option>
				
				<option value="file11">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonaddon_defaults.go (100.0%)</option>
				
				<option value="file12">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonaddon_lifecycle.go (50.0%)</option>
				
				<option value="file13">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonaddon_types.go (25.0%)</option>
				
				<option value="file14">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonaddon_validation.go (87.5%)</option>
				
				<option value="file15">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonchain_defaults.go (100.0%)</option>
				
				<option value="file16">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonchain_lifecycle.go (51.9%)</option>
				
				<option value="file17">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonchain_types.go (0.0%)</option>
				
				<option value="file18">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonchain_validation.go (73.2%)</option>
				
				<option value="file19">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonconfig_defaults.go (100.0%)</option>
				
				<option value="file20">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonconfig_lifecycle.go (65.3%)</option>
				
				<option value="file21">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonconfig_types.go (0.0%)</option>
				
				<option value="file22">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonconfig_validation.go (46.2%)</option>
				
				<option value="file23">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektondashboard_lifecycle.go (51.9%)</option>
				
				<option value="file24">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektondashboard_types.go (0.0%)</option>
				
				<option value="file25">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektondashboard_validation.go (71.4%)</option>
				
				<option value="file26">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonhub_defaults.go (83.3%)</option>
				
				<option value="file27">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonhub_lifecycle.go (47.7%)</option>
				
				<option value="file28">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonhub_types.go (16.7%)</option>
				
				<option value="file29">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonhub_validation.go (95.5%)</option>
				
				<option value="file30">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektoninstallerset_lifecycle.go (54.5%)</option>
				
				<option value="file31">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonpipeline_defaults.go (89.9%)</option>
				
				<option value="file32">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonpipeline_lifecycle.go (50.0%)</option>
				
				<option value="file33">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonpipeline_types.go (0.0%)</option>
				
				<option value="file34">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonpipeline_validation.go (81.2%)</option>
				
				<option value="file35">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonpruner_defaults.go (75.0%)</option>
				
				<option value="file36">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonpruner_lifecycle.go (77.8%)</option>
				
				<option value="file37">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonpruner_types.go (0.0%)</option>
				
				<option value="file38">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonresult_defaults.go (100.0%)</option>
				
				<option value="file39">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonresult_lifecycle.go (61.9%)</option>
				
				<option value="file40">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonresult_types.go (0.0%)</option>
				
				<option value="file41">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektonresult_validation.go (56.2%)</option>
				
				<option value="file42">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektontrigger_defaults.go (100.0%)</option>
				
				<option value="file43">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektontrigger_lifecycle.go (46.2%)</option>
				
				<option value="file44">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektontrigger_types.go (0.0%)</option>
				
				<option value="file45">github.com/tektoncd/operator/pkg/apis/operator/v1alpha1/tektontrigger_validation.go (81.8%)</option>
				
				<option value="file46">github.com/tektoncd/operator/pkg/common/scc.go (37.8%)</option>
				
				<option value="file47">github.com/tektoncd/operator/pkg/reconciler/common/certificates.go (100.0%)</option>
				
				<option value="file48">github.com/tektoncd/operator/pkg/reconciler/common/common.go (0.0%)</option>
				
				<option value="file49">github.com/tektoncd/operator/pkg/reconciler/common/deadlockbreaker.go (76.5%)</option>
				
				<option value="file50">github.com/tektoncd/operator/pkg/reconciler/common/extensions.go (100.0%)</option>
				
				<option value="file51">github.com/tektoncd/operator/pkg/reconciler/common/initcontroller.go (0.0%)</option>
				
				<option value="file52">github.com/tektoncd/operator/pkg/reconciler/common/labels.go (85.7%)</option>
				
				<option value="file53">github.com/tektoncd/operator/pkg/reconciler/common/name.go (100.0%)</option>
				
				<option value="file54">github.com/tektoncd/operator/pkg/reconciler/common/nometrics.go (0.0%)</option>
				
				<option value="file55">github.com/tektoncd/operator/pkg/reconciler/common/proxy.go (82.2%)</option>
				
				<option value="file56">github.com/tektoncd/operator/pkg/reconciler/common/prune.go (89.7%)</option>
				
				<option value="file57">github.com/tektoncd/operator/pkg/reconciler/common/releases.go (62.3%)</option>
				
				<option value="file58">github.com/tektoncd/operator/pkg/reconciler/common/stages.go (31.6%)</option>
				
				<option value="file59">github.com/tektoncd/operator/pkg/reconciler/common/targetnamespace.go (89.5%)</option>
				
				<option value="file60">github.com/tektoncd/operator/pkg/reconciler/common/tektoninstallerset/defaultinstallerset.go (81.2%)</option>
				
				<option value="file61">github.com/tektoncd/operator/pkg/reconciler/common/testing/util.go (0.0%)</option>
				
				<option value="file62">github.com/tektoncd/operator/pkg/reconciler/common/transformer_additional_options.go (84.8%)</option>
				
				<option value="file63">github.com/tektoncd/operator/pkg/reconciler/common/transformer_inject_envvar.go (73.3%)</option>
				
				<option value="file64">github.com/tektoncd/operator/pkg/reconciler/common/transformer_injectlabel.go (72.4%)</option>
				
				<option value="file65">github.com/tektoncd/operator/pkg/reconciler/common/transformers.go (72.0%)</option>
				
				<option value="file66">github.com/tektoncd/operator/pkg/reconciler/common/unstructured.go (100.0%)</option>
				
				<option value="file67">github.com/tektoncd/operator/pkg/reconciler/common/utils.go (88.0%)</option>
				
				<option value="file68">github.com/tektoncd/operator/pkg/reconciler/kubernetes/kubernetesplatform/kubernetesplatform.go (0.0%)</option>
				
				<option value="file69">github.com/tektoncd/operator/pkg/reconciler/kubernetes/manualapprovalgate/controller.go (0.0%)</option>
				
				<option value="file70">github.com/tektoncd/operator/pkg/reconciler/kubernetes/manualapprovalgate/finalize.go (0.0%)</option>
				
				<option value="file71">github.com/tektoncd/operator/pkg/reconciler/kubernetes/manualapprovalgate/metrics.go (0.0%)</option>
				
				<option value="file72">github.com/tektoncd/operator/pkg/reconciler/kubernetes/manualapprovalgate/reconcile.go (0.0%)</option>
				
				<option value="file73">github.com/tektoncd/operator/pkg/reconciler/kubernetes/manualapprovalgate/transform.go (0.0%)</option>
				
				<option value="file74">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonchain/controller.go (0.0%)</option>
				
				<option value="file75">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonchain/installerset.go (0.0%)</option>
				
				<option value="file76">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonchain/metrics.go (0.0%)</option>
				
				<option value="file77">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonchain/tektonchain.go (0.8%)</option>
				
				<option value="file78">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonchain/transform.go (81.2%)</option>
				
				<option value="file79">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonconfig/controller.go (0.0%)</option>
				
				<option value="file80">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonconfig/extension.go (0.0%)</option>
				
				<option value="file81">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonconfig/extension/dashboard.go (67.9%)</option>
				
				<option value="file82">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektondashboard/controller.go (0.0%)</option>
				
				<option value="file83">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektondashboard/finalize.go (0.0%)</option>
				
				<option value="file84">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektondashboard/reconcile.go (0.0%)</option>
				
				<option value="file85">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektondashboard/transform.go (87.5%)</option>
				
				<option value="file86">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonhub/controller.go (0.0%)</option>
				
				<option value="file87">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonhub/installerset.go (0.0%)</option>
				
				<option value="file88">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonhub/tektonhub.go (0.0%)</option>
				
				<option value="file89">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonhub/transform.go (0.0%)</option>
				
				<option value="file90">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/check.go (80.0%)</option>
				
				<option value="file91">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/cleanup.go (34.1%)</option>
				
				<option value="file92">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/client.go (100.0%)</option>
				
				<option value="file93">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/create.go (69.0%)</option>
				
				<option value="file94">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/custom_versioned_clustertask.go (0.0%)</option>
				
				<option value="file95">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/fake/client.go (0.0%)</option>
				
				<option value="file96">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/labels.go (42.1%)</option>
				
				<option value="file97">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/list.go (0.0%)</option>
				
				<option value="file98">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/main_set.go (52.8%)</option>
				
				<option value="file99">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/obsolete_sets.go (0.0%)</option>
				
				<option value="file100">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/pre_post_custom_set.go (61.1%)</option>
				
				<option value="file101">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client/update.go (83.7%)</option>
				
				<option value="file102">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/controller.go (0.0%)</option>
				
				<option value="file103">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/install.go (69.6%)</option>
				
				<option value="file104">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/query.go (81.5%)</option>
				
				<option value="file105">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/tektoninstallerset.go (0.0%)</option>
				
				<option value="file106">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/transformer.go (86.7%)</option>
				
				<option value="file107">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline/controller.go (0.0%)</option>
				
				<option value="file108">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline/finalize.go (0.0%)</option>
				
				<option value="file109">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline/metrics.go (0.0%)</option>
				
				<option value="file110">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline/reconcile.go (0.0%)</option>
				
				<option value="file111">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline/transform.go (89.5%)</option>
				
				<option value="file112">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner/controller.go (0.0%)</option>
				
				<option value="file113">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner/finalize.go (0.0%)</option>
				
				<option value="file114">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner/metrics.go (0.0%)</option>
				
				<option value="file115">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner/pruner_installerset.go (0.0%)</option>
				
				<option value="file116">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner/reconcile.go (0.0%)</option>
				
				<option value="file117">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner/transform.go (0.0%)</option>
				
				<option value="file118">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult/controller.go (0.0%)</option>
				
				<option value="file119">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult/filter.go (100.0%)</option>
				
				<option value="file120">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult/installerset.go (0.0%)</option>
				
				<option value="file121">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult/metrics.go (60.7%)</option>
				
				<option value="file122">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult/tektonresult.go (0.0%)</option>
				
				<option value="file123">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult/transform.go (80.3%)</option>
				
				<option value="file124">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger/controller.go (0.0%)</option>
				
				<option value="file125">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger/finalize.go (0.0%)</option>
				
				<option value="file126">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger/metrics.go (0.0%)</option>
				
				<option value="file127">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger/reconcile.go (0.0%)</option>
				
				<option value="file128">github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger/transform.go (0.0%)</option>
				
				<option value="file129">github.com/tektoncd/operator/pkg/reconciler/openshift/annotation/annotation.go (0.0%)</option>
				
				<option value="file130">github.com/tektoncd/operator/pkg/reconciler/openshift/annotation/controller.go (0.0%)</option>
				
				<option value="file131">github.com/tektoncd/operator/pkg/reconciler/openshift/common/cabundle.go (83.7%)</option>
				
				<option value="file132">github.com/tektoncd/operator/pkg/reconciler/openshift/common/transformer.go (62.5%)</option>
				
				<option value="file133">github.com/tektoncd/operator/pkg/reconciler/openshift/manualapprovalgate/controller.go (0.0%)</option>
				
				<option value="file134">github.com/tektoncd/operator/pkg/reconciler/openshift/manualapprovalgate/extension.go (0.0%)</option>
				
				<option value="file135">github.com/tektoncd/operator/pkg/reconciler/openshift/namespace/controller.go (0.0%)</option>
				
				<option value="file136">github.com/tektoncd/operator/pkg/reconciler/openshift/namespace/namespace.go (26.1%)</option>
				
				<option value="file137">github.com/tektoncd/operator/pkg/reconciler/openshift/openshiftpipelinesascode/controller.go (0.0%)</option>
				
				<option value="file138">github.com/tektoncd/operator/pkg/reconciler/openshift/openshiftpipelinesascode/extension.go (0.0%)</option>
				
				<option value="file139">github.com/tektoncd/operator/pkg/reconciler/openshift/openshiftpipelinesascode/pipelinerun_templates.go (54.8%)</option>
				
				<option value="file140">github.com/tektoncd/operator/pkg/reconciler/openshift/openshiftpipelinesascode/reconcile.go (0.0%)</option>
				
				<option value="file141">github.com/tektoncd/operator/pkg/reconciler/openshift/openshiftpipelinesascode/transform.go (68.6%)</option>
				
				<option value="file142">github.com/tektoncd/operator/pkg/reconciler/openshift/openshiftpipelinesascode/update_route_in_configmap.go (74.4%)</option>
				
				<option value="file143">github.com/tektoncd/operator/pkg/reconciler/openshift/openshiftplatform/openshiftplatform.go (0.0%)</option>
				
				<option value="file144">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/community_tasks.go (0.0%)</option>
				
				<option value="file145">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/consolecli.go (0.0%)</option>
				
				<option value="file146">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/controller.go (0.0%)</option>
				
				<option value="file147">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/metrics.go (0.0%)</option>
				
				<option value="file148">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/openshift_console.go (0.0%)</option>
				
				<option value="file149">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/pipelinetemplate.go (0.0%)</option>
				
				<option value="file150">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/pipelinetemplates/pipelinetemplates.go (86.5%)</option>
				
				<option value="file151">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/resolver_task.go (0.0%)</option>
				
				<option value="file152">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/resolver_task_versioned.go (0.0%)</option>
				
				<option value="file153">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/tektonaddon.go (0.0%)</option>
				
				<option value="file154">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/transform.go (0.0%)</option>
				
				<option value="file155">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/transformer.go (56.1%)</option>
				
				<option value="file156">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/triggers.go (0.0%)</option>
				
				<option value="file157">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonchain/controller.go (0.0%)</option>
				
				<option value="file158">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonchain/extension.go (0.0%)</option>
				
				<option value="file159">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/common.go (54.8%)</option>
				
				<option value="file160">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/console_plugin_reconciler.go (84.1%)</option>
				
				<option value="file161">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/controller.go (0.0%)</option>
				
				<option value="file162">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/extension.go (2.5%)</option>
				
				<option value="file163">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/extension/addon.go (70.5%)</option>
				
				<option value="file164">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/extension/pipelinesascode.go (62.9%)</option>
				
				<option value="file165">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/rbac.go (47.7%)</option>
				
				<option value="file166">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonhub/controller.go (0.0%)</option>
				
				<option value="file167">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonhub/extension.go (14.7%)</option>
				
				<option value="file168">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonpipeline/controller.go (0.0%)</option>
				
				<option value="file169">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonpipeline/extension.go (0.0%)</option>
				
				<option value="file170">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonpruner/controller.go (0.0%)</option>
				
				<option value="file171">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonpruner/extension.go (0.0%)</option>
				
				<option value="file172">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonresult/controller.go (0.0%)</option>
				
				<option value="file173">github.com/tektoncd/operator/pkg/reconciler/openshift/tektonresult/extension.go (49.3%)</option>
				
				<option value="file174">github.com/tektoncd/operator/pkg/reconciler/openshift/tektontrigger/controller.go (0.0%)</option>
				
				<option value="file175">github.com/tektoncd/operator/pkg/reconciler/openshift/tektontrigger/extension.go (0.0%)</option>
				
				<option value="file176">github.com/tektoncd/operator/pkg/reconciler/openshift/tektontrigger/transformers.go (82.6%)</option>
				
				<option value="file177">github.com/tektoncd/operator/pkg/reconciler/platform/config.go (75.6%)</option>
				
				<option value="file178">github.com/tektoncd/operator/pkg/reconciler/platform/platform.go (61.5%)</option>
				
				<option value="file179">github.com/tektoncd/operator/pkg/reconciler/platform/platform_fake.go (100.0%)</option>
				
				<option value="file180">github.com/tektoncd/operator/pkg/reconciler/platform/types.go (100.0%)</option>
				
				<option value="file181">github.com/tektoncd/operator/pkg/reconciler/proxy/controller.go (0.0%)</option>
				
				<option value="file182">github.com/tektoncd/operator/pkg/reconciler/proxy/proxy.go (4.1%)</option>
				
				<option value="file183">github.com/tektoncd/operator/pkg/reconciler/shared/hash/hash.go (76.9%)</option>
				
				<option value="file184">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/chain/chain.go (71.4%)</option>
				
				<option value="file185">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/controller.go (0.0%)</option>
				
				<option value="file186">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/installerset_pruner.go (0.0%)</option>
				
				<option value="file187">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/instance.go (0.0%)</option>
				
				<option value="file188">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/pipeline/pipeline.go (70.1%)</option>
				
				<option value="file189">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/pruner/pruner.go (71.4%)</option>
				
				<option value="file190">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/result/result.go (69.7%)</option>
				
				<option value="file191">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/tektonconfig.go (0.0%)</option>
				
				<option value="file192">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/trigger/trigger.go (71.9%)</option>
				
				<option value="file193">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade/helper/migrator.go (96.9%)</option>
				
				<option value="file194">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade/helper/storage_version_migrator.go (76.9%)</option>
				
				<option value="file195">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade/post_upgrade.go (0.0%)</option>
				
				<option value="file196">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade/pre_upgrade.go (57.1%)</option>
				
				<option value="file197">github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade/upgrade.go (84.4%)</option>
				
				<option value="file198">github.com/tektoncd/operator/pkg/reconciler/shared/tektoninstallerset/client.go (0.0%)</option>
				
				<option value="file199">github.com/tektoncd/operator/pkg/reconciler/shared/tektoninstallerset/install.go (62.1%)</option>
				
				<option value="file200">github.com/tektoncd/operator/pkg/reconciler/shared/tektoninstallerset/types.go (70.0%)</option>
				
				<option value="file201">github.com/tektoncd/operator/pkg/webhook/webhook.go (0.0%)</option>
				
				<option value="file202">github.com/tektoncd/operator/pkg/webhook/webhook_init.go (33.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"

        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

var (
        validatePipelineWebhookConfigurationFailurePolicy = sets.NewString("Ignore", "Fail")
        validatePipelineWebhookConfigurationSideEffects   = sets.NewString("NoneOnDryRun", "None", "Unknown", "Some")
)

func (w *WebhookConfigurationOptions) validate(path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if w.FailurePolicy != nil &amp;&amp; !validatePipelineWebhookConfigurationFailurePolicy.Has(string(*w.FailurePolicy)) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(*w.FailurePolicy, fmt.Sprintf("%s.webhookconfigurationoptions.failurePolicy", path)))
        }</span>
        <span class="cov8" title="1">if w.SideEffects != nil &amp;&amp; !validatePipelineWebhookConfigurationSideEffects.Has(string(*w.SideEffects)) </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(*w.SideEffects, fmt.Sprintf("%s.webhookconfigurationoptions.sideEffects", path)))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func (op *AdditionalOptions) validate(path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if op.WebhookConfigurationOptions != nil </span><span class="cov8" title="1">{
                for _, webhookConfig := range op.WebhookConfigurationOptions </span><span class="cov8" title="1">{
                        return webhookConfig.validate(path)
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "os"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

const (
        // InstallSucceeded is a Condition indiciating that the installation of the component
        // itself has been successful.
        InstallSucceeded apis.ConditionType = "InstallSucceeded"
)

// TektonComponent is a common interface for accessing meta, spec and status of all known types.
type TektonComponent interface {
        metav1.Object
        schema.ObjectKind

        // GetSpec returns the common spec for all known types.
        GetSpec() TektonComponentSpec
        // GetStatus returns the common status of all known types.
        GetStatus() TektonComponentStatus
}

// TektonComponentSpec is a common interface for accessing the common spec of all known types.
type TektonComponentSpec interface {
        // GetTargetNamespace gets the version to be installed
        GetTargetNamespace() string
}

// TektonComponentStatus is a common interface for status mutations of all known types.
type TektonComponentStatus interface {
        MarkNotReady(string)
        MarkInstallerSetReady()

        MarkInstallerSetNotReady(string)
        MarkInstallerSetAvailable()

        MarkPreReconcilerFailed(string)
        MarkPostReconcilerFailed(string)

        // GetVersion gets the currently installed version of the component.
        GetVersion() string
        // SetVersion sets the currently installed version of the component.
        SetVersion(version string)
        // IsReady return true if all conditions are satisfied
        IsReady() bool
        // ConditionAccessor Implement to interact with a condition
        apis.ConditionAccessor
}

// CommonSpec unifies common fields and functions on the Spec.
type CommonSpec struct {
        // TargetNamespace is where resources will be installed
        // +optional
        TargetNamespace string `json:"targetNamespace,omitempty"`
}

// GetTargetNamespace implements KComponentSpec.
func (c *CommonSpec) GetTargetNamespace() string <span class="cov8" title="1">{
        return c.TargetNamespace
}</span>

// Param declares an string value to use for the parameter called name.
type Param struct {
        Name  string `json:"name,omitempty"`
        Value string `json:"value,omitempty"`
}

// ParamValue defines a default value and possible values for a param
type ParamValue struct {
        Default  string
        Possible []string
}

// ParseParams returns the params array as map
func ParseParams(params []Param) map[string]string <span class="cov8" title="1">{
        paramsMap := map[string]string{}
        for _, p := range params </span><span class="cov8" title="1">{
                paramsMap[p.Name] = p.Value
        }</span>
        <span class="cov8" title="1">return paramsMap</span>
}

func IsOpenShiftPlatform() bool <span class="cov8" title="1">{
        return os.Getenv("PLATFORM") == "openshift"
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"

        "knative.dev/pkg/apis"
)

func (ta *CommonSpec) validate(path string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        targetNamespacePath := fmt.Sprintf("%s.targetNamespace", path)
        if ta.GetTargetNamespace() == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField(targetNamespacePath))
        }</span> else<span class="cov8" title="1"> if IsOpenShiftPlatform() </span><span class="cov8" title="1">{
                // "openshift-operators" namespace restricted in openshift environment
                if ta.GetTargetNamespace() == "openshift-operators" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(ta.GetTargetNamespace(), targetNamespacePath, "'openshift-operators' namespace is not allowed"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

var (
        _ TektonComponentStatus = (*ManualApprovalGateStatus)(nil)

        magCondSet = apis.NewLivingConditionSet(
                DependenciesInstalled,
                PreReconciler,
                InstallerSetAvailable,
                InstallerSetReady,
                PostReconciler,
        )
)

// GroupVersionKind returns SchemeGroupVersion of a ManualApprovalGate
func (mag *ManualApprovalGate) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindManualApprovalGate)
}</span>

func (mag *ManualApprovalGate) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindManualApprovalGate)
}</span>

// GetCondition returns the current condition of a given condition type
func (mag *ManualApprovalGateStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return magCondSet.Manage(mag).GetCondition(t)
}</span>

// InitializeConditions initializes conditions of an ManualApprovalGateStatus
func (mag *ManualApprovalGateStatus) InitializeConditions() <span class="cov8" title="1">{
        magCondSet.Manage(mag).InitializeConditions()
}</span>

// IsReady looks at the conditions returns true if they are all true.
func (mag *ManualApprovalGateStatus) IsReady() bool <span class="cov8" title="1">{
        return magCondSet.Manage(mag).IsHappy()
}</span>

func (mag *ManualApprovalGateStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        magCondSet.Manage(mag).MarkTrue(PreReconciler)
}</span>

func (mag *ManualApprovalGateStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        magCondSet.Manage(mag).MarkTrue(InstallerSetAvailable)
}</span>

func (mag *ManualApprovalGateStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        magCondSet.Manage(mag).MarkTrue(InstallerSetReady)
}</span>

func (mag *ManualApprovalGateStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        magCondSet.Manage(mag).MarkTrue(PostReconciler)
}</span>

// MarkDependenciesInstalled marks the DependenciesInstalled status as true.
func (mag *ManualApprovalGateStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        magCondSet.Manage(mag).MarkTrue(DependenciesInstalled)
}</span>

func (mag *ManualApprovalGateStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        magCondSet.Manage(mag).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (mag *ManualApprovalGateStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        mag.MarkNotReady("PreReconciliation failed")
        magCondSet.Manage(mag).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (mag *ManualApprovalGateStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov0" title="0">{
        mag.MarkNotReady("TektonInstallerSet not ready")
        magCondSet.Manage(mag).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (mag *ManualApprovalGateStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        mag.MarkNotReady("TektonInstallerSet not ready")
        magCondSet.Manage(mag).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (mag *ManualApprovalGateStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        mag.MarkNotReady("PostReconciliation failed")
        magCondSet.Manage(mag).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

// MarkDependencyInstalling marks the DependenciesInstalled status as false with the
// given message.
func (mag *ManualApprovalGateStatus) MarkDependencyInstalling(msg string) <span class="cov0" title="0">{
        mag.MarkNotReady("Dependencies installing")
        magCondSet.Manage(mag).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency installing: %s", msg)
}</span>

// MarkDependencyMissing marks the DependenciesInstalled status as false with the
// given message.
func (mag *ManualApprovalGateStatus) MarkDependencyMissing(msg string) <span class="cov0" title="0">{
        mag.MarkNotReady("Missing Dependencies for ManualApprovalGate")
        magCondSet.Manage(mag).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency missing: %s", msg)
}</span>

func (mag *ManualApprovalGateStatus) GetTektonInstallerSet() string <span class="cov0" title="0">{
        return mag.TektonInstallerSet
}</span>

func (mag *ManualApprovalGateStatus) SetTektonInstallerSet(installerSet string) <span class="cov0" title="0">{
        mag.TektonInstallerSet = installerSet
}</span>

// GetVersion gets the currently installed version of the component.
func (mag *ManualApprovalGateStatus) GetVersion() string <span class="cov0" title="0">{
        return mag.Version
}</span>

// SetVersion sets the currently installed version of the component.
func (mag *ManualApprovalGateStatus) SetVersion(version string) <span class="cov0" title="0">{
        mag.Version = version
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

var (
        _ TektonComponent     = (*ManualApprovalGate)(nil)
        _ TektonComponentSpec = (*ManualApprovalGateSpec)(nil)
)

// ManualApprovalGate is the Schema for the ManualApprovalGate API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type ManualApprovalGate struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   ManualApprovalGateSpec   `json:"spec,omitempty"`
        Status ManualApprovalGateStatus `json:"status,omitempty"`
}

type ManualApprovalGateSpec struct {
        CommonSpec     `json:",inline"`
        ManualApproval `json:",inline"`
}

type ManualApproval struct {
        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

// ManualApprovalGateList contains a list of ManualApprovalGate
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type ManualApprovalGateList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ManualApprovalGate `json:"items"`
}

// GetSpec implements TektonComponent
func (mag *ManualApprovalGate) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;mag.Spec
}</span>

// GetStatus implements TektonComponent
func (mag *ManualApprovalGate) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;mag.Status
}</span>

// ManualApprovalGateStatus defines the observed state of ManualApprovalGate
type ManualApprovalGateStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name for ManualApprovalGate
        // +optional
        TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "reflect"
        "strconv"
        "strings"
        "sync"

        pacSettings "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "go.uber.org/zap"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

func (pac *OpenShiftPipelinesAsCode) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        if pac.Spec.PACSettings.Settings == nil </span><span class="cov0" title="0">{
                pac.Spec.PACSettings.Settings = map[string]string{}
        }</span>
        <span class="cov0" title="0">if pac.Spec.PACSettings.AdditionalPACControllers == nil </span><span class="cov0" title="0">{
                pac.Spec.PACSettings.AdditionalPACControllers = map[string]AdditionalPACControllerConfig{}
        }</span>
        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        pac.Spec.PACSettings.setPACDefaults(logger)</span>
}

func (set *PACSettings) setPACDefaults(logger *zap.SugaredLogger) <span class="cov8" title="1">{
        if set.Settings == nil </span><span class="cov8" title="1">{
                set.Settings = map[string]string{}
        }</span>
        <span class="cov8" title="1">defaultPacSettings := pacSettings.DefaultSettings()
        err := pacSettings.SyncConfig(logger, &amp;defaultPacSettings, set.Settings, map[string]func(string) error{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error on applying default PAC settings", err)
        }</span>

        // Remove tektonhub catalog to only keep artifacthub
        <span class="cov8" title="1">defaultPacSettings.HubCatalogs.Delete("tektonhub")

        // Override the default ArtifactHub URL to use https://artifacthub.io instead of https://artifacthub.io/api/v1
        if defaultCatalog, ok := defaultPacSettings.HubCatalogs.Load("default"); ok </span><span class="cov8" title="1">{
                catalog := defaultCatalog.(pacSettings.HubCatalog)
                catalog.URL = "https://artifacthub.io"
                defaultPacSettings.HubCatalogs.Store("default", catalog)
        }</span>

        <span class="cov8" title="1">set.Settings = ConvertPacStructToConfigMap(&amp;defaultPacSettings)
        setAdditionalPACControllerDefault(set.AdditionalPACControllers)</span>
}

// Set the default values for additional PAc controller resources
func setAdditionalPACControllerDefault(additionalPACController map[string]AdditionalPACControllerConfig) <span class="cov8" title="1">{
        for name, additionalPACInfo := range additionalPACController </span><span class="cov8" title="1">{
                if additionalPACInfo.Enable == nil </span><span class="cov8" title="1">{
                        additionalPACInfo.Enable = ptr.Bool(true)
                }</span>
                <span class="cov8" title="1">if additionalPACInfo.ConfigMapName == "" </span><span class="cov8" title="1">{
                        additionalPACInfo.ConfigMapName = fmt.Sprintf("%s-pipelines-as-code-configmap", name)
                }</span>
                <span class="cov8" title="1">if additionalPACInfo.SecretName == "" </span><span class="cov8" title="1">{
                        additionalPACInfo.SecretName = fmt.Sprintf("%s-pipelines-as-code-secret", name)
                }</span>
                <span class="cov8" title="1">additionalPACController[name] = additionalPACInfo</span>
        }
}

func ConvertPacStructToConfigMap(settings *pacSettings.Settings) map[string]string <span class="cov8" title="1">{
        config := map[string]string{}
        if settings == nil </span><span class="cov0" title="0">{
                return config
        }</span>
        <span class="cov8" title="1">structValue := reflect.ValueOf(settings).Elem()
        structType := reflect.TypeOf(settings).Elem()

        for i := 0; i &lt; structType.NumField(); i++ </span><span class="cov8" title="1">{
                field := structType.Field(i)
                fieldName := field.Name

                jsonTag := field.Tag.Get("json")
                if jsonTag == "-" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">key := strings.ToLower(jsonTag)
                element := structValue.FieldByName(fieldName)
                if !element.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }

                //nolint
                <span class="cov8" title="1">switch field.Type.Kind() </span>{
                case reflect.String:<span class="cov8" title="1">
                        config[key] = element.String()</span>
                case reflect.Bool:<span class="cov8" title="1">
                        config[key] = strconv.FormatBool(element.Bool())</span>
                case reflect.Int:<span class="cov8" title="1">
                        config[key] = strconv.FormatInt(element.Int(), 10)</span>
                case reflect.Ptr:<span class="cov8" title="1">
                        // for hub catalogs map
                        if key == "" </span><span class="cov8" title="1">{
                                data := element.Interface().(*sync.Map)
                                data.Range(func(key, value any) bool </span><span class="cov8" title="1">{
                                        catalogData := value.(pacSettings.HubCatalog)
                                        if key == "default" </span><span class="cov8" title="1">{
                                                config[pacSettings.HubURLKey] = catalogData.URL
                                                config[pacSettings.HubCatalogTypeKey] = catalogData.Type
                                                return true
                                        }</span>
                                        <span class="cov8" title="1">config[fmt.Sprintf("%s-%s-%s", "catalog", catalogData.Index, "id")] = key.(string)
                                        config[fmt.Sprintf("%s-%s-%s", "catalog", catalogData.Index, "name")] = catalogData.Name
                                        config[fmt.Sprintf("%s-%s-%s", "catalog", catalogData.Index, "url")] = catalogData.URL
                                        return true</span>
                                })
                        }
                default:<span class="cov0" title="0">
                        // Skip unsupported field types
                        continue</span>
                }
        }

        <span class="cov8" title="1">return config</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

var (
        _ TektonComponentStatus = (*OpenShiftPipelinesAsCodeStatus)(nil)

        opacCondSet = apis.NewLivingConditionSet(
                DependenciesInstalled,
                PreReconciler,
                InstallerSetAvailable,
                InstallerSetReady,
                AdditionalPACControllerInstalled,
                PostReconciler,
        )
)

const (
        AdditionalPACControllerInstalled apis.ConditionType = "AdditionalPACControllerInstalled"
)

func (pac *OpenShiftPipelinesAsCode) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindOpenShiftPipelinesAsCode)
}</span>

func (pac *OpenShiftPipelinesAsCode) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindOpenShiftPipelinesAsCode)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return opacCondSet.Manage(pac).GetCondition(t)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) InitializeConditions() <span class="cov8" title="1">{
        opacCondSet.Manage(pac).InitializeConditions()
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) IsReady() bool <span class="cov8" title="1">{
        return opacCondSet.Manage(pac).IsHappy()
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        opacCondSet.Manage(pac).MarkTrue(PreReconciler)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        opacCondSet.Manage(pac).MarkTrue(InstallerSetAvailable)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        opacCondSet.Manage(pac).MarkTrue(InstallerSetReady)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkAdditionalPACControllerComplete() <span class="cov8" title="1">{
        opacCondSet.Manage(pac).MarkTrue(AdditionalPACControllerInstalled)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        opacCondSet.Manage(pac).MarkTrue(PostReconciler)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        opacCondSet.Manage(pac).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        pac.MarkNotReady("PreReconciliation failed")
        opacCondSet.Manage(pac).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov0" title="0">{
        pac.MarkNotReady("TektonInstallerSet not ready")
        opacCondSet.Manage(pac).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        pac.MarkNotReady("TektonInstallerSet not ready")
        opacCondSet.Manage(pac).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        pac.MarkNotReady("PostReconciliation failed")
        opacCondSet.Manage(pac).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        opacCondSet.Manage(pac).MarkTrue(DependenciesInstalled)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkDependencyInstalling(msg string) <span class="cov0" title="0">{
        pac.MarkNotReady("Dependencies installing")
        opacCondSet.Manage(pac).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependencies are installing: %s", msg)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) MarkDependencyMissing(msg string) <span class="cov0" title="0">{
        pac.MarkNotReady("Missing Dependencies for TektonTriggers")
        opacCondSet.Manage(pac).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependencies are missing: %s", msg)
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) GetVersion() string <span class="cov0" title="0">{
        return pac.Version
}</span>

func (pac *OpenShiftPipelinesAsCodeStatus) SetVersion(version string) <span class="cov0" title="0">{
        pac.Version = version
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// OpenShiftPipelinesAsCode is the Schema for the OpenShiftPipelinesAsCode API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type OpenShiftPipelinesAsCode struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   OpenShiftPipelinesAsCodeSpec   `json:"spec,omitempty"`
        Status OpenShiftPipelinesAsCodeStatus `json:"status,omitempty"`
}

// GetSpec implements TektonComponent
func (pac *OpenShiftPipelinesAsCode) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;pac.Spec
}</span>

// GetStatus implements TektonComponent
func (pac *OpenShiftPipelinesAsCode) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;pac.Status
}</span>

// OpenShiftPipelinesAsCodeSpec defines the desired state of OpenShiftPipelinesAsCode
type OpenShiftPipelinesAsCodeSpec struct {
        CommonSpec  `json:",inline"`
        Config      Config `json:"config,omitempty"`
        PACSettings `json:",inline"`
}

// OpenShiftPipelinesAsCodeStatus defines the observed state of OpenShiftPipelinesAsCode
type OpenShiftPipelinesAsCodeStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`
}

// OpenShiftPipelinesAsCodeList contains a list of OpenShiftPipelinesAsCode
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type OpenShiftPipelinesAsCodeList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []OpenShiftPipelinesAsCode `json:"items"`
}

type PACSettings struct {
        Settings map[string]string `json:"settings,omitempty"`
        // AdditionalPACControllers allows to deploy additional PAC controller
        // +optional
        AdditionalPACControllers map[string]AdditionalPACControllerConfig `json:"additionalPACControllers,omitempty"`
        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

// AdditionalPACControllerConfig contains config for additionalPACControllers
type AdditionalPACControllerConfig struct {
        // Enable or disable this additional pipelines as code instance by changing this bool
        // +optional
        Enable *bool `json:"enable,omitempty"`
        // Name of the additional controller configMap
        // +optional
        ConfigMapName string `json:"configMapName,omitempty"`
        // Name of the additional controller Secret
        // +optional
        SecretName string `json:"secretName,omitempty"`
        // Setting will contains the configMap data
        // +optional
        Settings map[string]string `json:"settings,omitempty"`
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "reflect"

        pacSettings "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        "go.uber.org/zap"
        kubernetesValidation "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
)

// limit is 25 because this name goes in the installerset name which already have 38 characters, so additional length we
// can have for name is 25, as the kubernetes have restriction for 63
const additionalPACControllerNameMaxLength = 25

func (pac *OpenShiftPipelinesAsCode) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var errs *apis.FieldError

        logger := logging.FromContext(ctx)

        // execute common spec validations
        errs = errs.Also(pac.Spec.CommonSpec.validate("spec"))

        errs = errs.Also(pac.Spec.PACSettings.validate(logger, "spec"))

        return errs</span>
}

func (ps *PACSettings) validate(logger *zap.SugaredLogger, path string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        defaultPacSettings := pacSettings.DefaultSettings()
        if err := pacSettings.SyncConfig(logger, &amp;defaultPacSettings, ps.Settings, pacSettings.DefaultValidators()); err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf("%s.settings", path)))
        }</span>

        <span class="cov8" title="1">for name, additionalPACControllerConfig := range ps.AdditionalPACControllers </span><span class="cov8" title="1">{
                if err := validateAdditionalPACControllerName(name); err != nil </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf("%s.additionalPACControllers", path)))
                }</span>

                <span class="cov8" title="1">errs = errs.Also(additionalPACControllerConfig.validate(fmt.Sprintf("%s.additionalPACControllers", path)))</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func (aps AdditionalPACControllerConfig) validate(path string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        if err := validateKubernetesName(aps.ConfigMapName); err != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf("%s.configMapName", path)))
        }</span>

        <span class="cov8" title="1">if err := validateKubernetesName(aps.SecretName); err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf("%s.secretName", path)))
        }</span>

        <span class="cov8" title="1">if err := validateAdditionalPACControllerSettings(aps.Settings); err != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf("%s.settings", path)))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// validates the name of the controller resource is valid kubernetes name
func validateAdditionalPACControllerName(name string) *apis.FieldError <span class="cov8" title="1">{
        if err := kubernetesValidation.IsDNS1123Subdomain(name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("invalid resource name %q: must be a valid DNS label", name),
                        Paths:   []string{"name"},
                }
        }</span>

        <span class="cov8" title="1">if len(name) &gt; additionalPACControllerNameMaxLength </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("invalid resource name %q: length must be no more than %d characters", name, additionalPACControllerNameMaxLength),
                        Paths:   []string{"name"},
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validates the name of the resource is valid kubernetes name
func validateKubernetesName(name string) *apis.FieldError <span class="cov8" title="1">{
        if err := kubernetesValidation.IsDNS1123Subdomain(name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("invalid resource name %q: must be a valid DNS label", name),
                        Paths:   []string{"name"},
                }
        }</span>

        <span class="cov8" title="1">if len(name) &gt; kubernetesValidation.DNS1123LabelMaxLength </span><span class="cov0" title="0">{
                return &amp;apis.FieldError{
                        Message: fmt.Sprintf("invalid resource name %q: length must be no more than %d characters", name, kubernetesValidation.DNS1123LabelMaxLength),
                        Paths:   []string{"name"},
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// validates the settings of the additionalPACController
func validateAdditionalPACControllerSettings(settings map[string]string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        validators := pacSettings.DefaultValidators()
        if len(settings) &gt; 0 </span><span class="cov8" title="1">{
                fieldTagMapDetails := getFieldTagMap()
                for key, value := range settings </span><span class="cov8" title="1">{
                        fieldName, ok := fieldTagMapDetails[key]
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if validationFunc, ok := validators[fieldName]; ok &amp;&amp; value != "" </span><span class="cov8" title="1">{
                                if err := validationFunc(value); err != nil </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(err, fmt.Sprintf("validation failed for field %s", key)))
                                        continue</span>
                                }
                        }
                }
                <span class="cov8" title="1">return errs</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// this will return map with all the json tags with value equal to their field names
func getFieldTagMap() map[string]string <span class="cov8" title="1">{
        var fieldTagMapping = make(map[string]string)
        rt := reflect.TypeOf(pacSettings.Settings{})
        for i := 0; i &lt; rt.NumField(); i++ </span><span class="cov8" title="1">{
                f := rt.Field(i)
                v := f.Tag.Get("json")
                if v == "" || v == "-" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">fieldTagMapping[v] = f.Name</span>
        }
        <span class="cov8" title="1">return fieldTagMapping</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"

        "knative.dev/pkg/apis"
)

func (ppp *PerformanceProperties) Validate(path string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        bucketsPath := fmt.Sprintf("%s.buckets", path)
        // minimum and maximum allowed buckets value
        if ppp.Buckets != nil </span><span class="cov8" title="1">{
                if *ppp.Buckets &lt; 1 || *ppp.Buckets &gt; MaxBuckets </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrOutOfBoundsValue(*ppp.Buckets, 1, 10, bucketsPath))
                }</span>
        }

        // check for StatefulsetOrdinals and Replicas
        <span class="cov8" title="1">if ppp.StatefulsetOrdinals != nil &amp;&amp; *ppp.StatefulsetOrdinals </span><span class="cov8" title="1">{
                if ppp.Replicas != nil </span><span class="cov8" title="1">{
                        replicas := uint(*ppp.Replicas)
                        if ppp.Buckets == nil </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrMissingField(bucketsPath, "spec.performance.buckets must be set when statefulset ordinals is enabled"))
                        }</span> else<span class="cov8" title="1"> if *ppp.Buckets != replicas </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(*ppp.Replicas, fmt.Sprintf("%s.replicas", path), "spec.performance.replicas must equal spec.performance.buckets for statefulset ordinals"))
                        }</span>
                }
        }

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

const (
        // GroupName is the group of the API.
        GroupName = "operator.tekton.dev"

        // SchemaVersion is the current version of the API.
        SchemaVersion = "v1alpha1"

        // KindTektonPipeline is the Kind of Tekton Pipeline in a GVK context.
        KindTektonPipeline = "TektonPipeline"

        // KindTektonTrigger is the Kind of Tekton Trigger in a GVK context.
        KindTektonTrigger = "TektonTrigger"

        // KindTektonDashboard is the Kind of Tekton Dashboard in a GVK context.
        KindTektonDashboard = "TektonDashboard"

        // KindTektonAddon is the Kind of Tekton Addon in a GVK context.
        KindTektonAddon = "TektonAddon"

        // KindTektonConfig is the Kind of Tekton Config in a GVK context.
        KindTektonConfig = "TektonConfig"

        // KindTektonResult is the Kind of Tekton Result in a GVK context.
        KindTektonResult = "TektonResult"

        // KindTektonInstallerSet is the Kind of TektonInstallerSet in a GVK context.
        KindTektonInstallerSet = "TektonInstallerSet"

        // KindTektonHub is the Kind of TektonHub in a GVK context.
        KindTektonHub = "TektonHub"

        // KindTektonChain is the Kind of Tekton Chain in a GVK context.
        KindTektonChain = "TektonChain"

        // KindOpenShiftPipelinesAsCode is the Kind of OpenShiftPipelinesAsCode in a GVK context.
        KindOpenShiftPipelinesAsCode = "OpenShiftPipelinesAsCode"

        // KindManualApprovalGate is the Kind of KindManualApprovalGate in a GVK context.
        KindManualApprovalGate = "ManualApprovalGate"

        // KindTektonPruner is the Kind of TektonPruner in a GVK context.
        KindTektonPruner = "TektonPruner"
)

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov8" title="1">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

// addKnownTypes adds the set of types defined in this package to the supplied
// scheme.
func addKnownTypes(s *runtime.Scheme) error <span class="cov8" title="1">{
        s.AddKnownTypes(SchemeGroupVersion,
                &amp;TektonPipeline{},
                &amp;TektonPipelineList{},
                &amp;TektonTrigger{},
                &amp;TektonTriggerList{},
                &amp;TektonDashboard{},
                &amp;TektonDashboardList{},
                &amp;TektonAddon{},
                &amp;TektonAddonList{},
                &amp;TektonConfig{},
                &amp;TektonConfigList{},
                &amp;TektonResult{},
                &amp;TektonResultList{},
                &amp;TektonInstallerSet{},
                &amp;TektonInstallerSetList{},
                &amp;TektonHub{},
                &amp;TektonHubList{},
                &amp;TektonChain{},
                &amp;TektonChainList{},
                &amp;OpenShiftPipelinesAsCode{},
                &amp;OpenShiftPipelinesAsCodeList{},
                &amp;ManualApprovalGate{},
                &amp;ManualApprovalGateList{},
                &amp;TektonPruner{},
                &amp;TektonPrunerList{},
        )
        metav1.AddToGroupVersion(s, SchemeGroupVersion)
        return nil
}</span>

var (
        // SchemeGroupVersion is group version used to register these objects
        SchemeGroupVersion = schema.GroupVersion{Group: GroupName, Version: SchemaVersion}

        // SchemeBuilder is used to add go types to the GroupVersionKind scheme
        SchemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)
        // AddToScheme adds the API's types to the Scheme.
        AddToScheme = SchemeBuilder.AddToScheme
)
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

func (ta *TektonAddon) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        setAddonDefaults(&amp;ta.Spec.Addon)
}</span>

func setAddonDefaults(addon *Addon) <span class="cov8" title="1">{

        paramsMap := ParseParams(addon.Params)
        _, ptOk := paramsMap[PipelineTemplatesParam]
        rt, rtOk := paramsMap[ResolverTasks]

        // If ResolverTask is false and pipelineTemplate is not set, then set it as false
        // as pipelines templates are created using ResolverTask
        if rtOk &amp;&amp; (rt == "false" &amp;&amp; !ptOk) </span><span class="cov8" title="1">{
                addon.Params = append(addon.Params, Param{
                        Name:  PipelineTemplatesParam,
                        Value: "false",
                })
                paramsMap = ParseParams(addon.Params)
        }</span>

        // set the params with default values if not set in cr
        <span class="cov8" title="1">for d := range AddonParams </span><span class="cov8" title="1">{
                _, ok := paramsMap[d]
                if !ok </span><span class="cov8" title="1">{
                        addon.Params = append(addon.Params,
                                Param{
                                        Name:  d,
                                        Value: AddonParams[d].Default,
                                })
                }</span>
        }

        // Deprecated, will be removed in further releases
        // moved to OpenShift platform section
        <span class="cov8" title="1">addon.EnablePAC = nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

var (
        addonsCondSet = apis.NewLivingConditionSet(
                DependenciesInstalled,
                PreReconciler,
                InstallerSetReady,
                PostReconciler,
        )
)

func (tp *TektonAddon) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonAddon)
}</span>

func (tp *TektonAddon) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonAddon)
}</span>

func (tas *TektonAddonStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return addonsCondSet.Manage(tas).GetCondition(t)
}</span>

func (tas *TektonAddonStatus) InitializeConditions() <span class="cov8" title="1">{
        addonsCondSet.Manage(tas).InitializeConditions()
}</span>

func (tas *TektonAddonStatus) IsReady() bool <span class="cov8" title="1">{
        return addonsCondSet.Manage(tas).IsHappy()
}</span>

func (tas *TektonAddonStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        addonsCondSet.Manage(tas).MarkTrue(PreReconciler)
}</span>

func (tas *TektonAddonStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        addonsCondSet.Manage(tas).MarkTrue(InstallerSetReady)
}</span>

func (tas *TektonAddonStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        addonsCondSet.Manage(tas).MarkTrue(PostReconciler)
}</span>

func (tas *TektonAddonStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        addonsCondSet.Manage(tas).MarkTrue(DependenciesInstalled)
}</span>

func (tas *TektonAddonStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        addonsCondSet.Manage(tas).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (tas *TektonAddonStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        tas.MarkNotReady("PreReconciliation failed")
        addonsCondSet.Manage(tas).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (tas *TektonAddonStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        tas.MarkNotReady("TektonInstallerSet not ready")
        addonsCondSet.Manage(tas).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tas *TektonAddonStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        tas.MarkNotReady("PostReconciliation failed")
        addonsCondSet.Manage(tas).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

func (tas *TektonAddonStatus) MarkDependencyInstalling(msg string) <span class="cov0" title="0">{
        tas.MarkNotReady("Dependencies installing")
        addonsCondSet.Manage(tas).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependencies are installing: %s", msg)
}</span>

func (tas *TektonAddonStatus) MarkDependencyMissing(msg string) <span class="cov0" title="0">{
        tas.MarkNotReady("Missing Dependencies for TektonTriggers")
        addonsCondSet.Manage(tas).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependencies are missing: %s", msg)
}</span>

func (tas *TektonAddonStatus) GetVersion() string <span class="cov0" title="0">{
        return tas.Version
}</span>

func (tas *TektonAddonStatus) SetVersion(version string) <span class="cov0" title="0">{
        tas.Version = version
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// TektonAddon is the Schema for the tektonaddons API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonAddon struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonAddonSpec   `json:"spec,omitempty"`
        Status TektonAddonStatus `json:"status,omitempty"`
}

// GetSpec implements TektonComponent
func (tp *TektonAddon) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tp.Spec
}</span>

// GetStatus implements TektonComponent
func (tp *TektonAddon) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tp.Status
}</span>

// TektonAddonSpec defines the desired state of TektonAddon
type TektonAddonSpec struct {
        CommonSpec `json:",inline"`
        Addon      `json:",inline"`
        // Config holds the configuration for resources created by Addon
        // +optional
        Config Config `json:"config,omitempty"`
}

// TektonAddonStatus defines the observed state of TektonAddon
type TektonAddonStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // TektonInstallerSet created to install addons
        // +optional
        AddonsInstallerSet map[string]string `json:"installerSets,omitempty"`
}

func (in *TektonAddonStatus) MarkInstallerSetAvailable() <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// Addon defines the field to customize Addon component
type Addon struct {
        // Params is the list of params passed for Addon customization
        // +optional
        Params []Param `json:"params,omitempty"`
        // Deprecated, will be removed in further release
        // EnablePAC field defines whether to install PAC
        // +optional
        EnablePAC *bool `json:"enablePipelinesAsCode,omitempty"`
}

func (a Addon) IsEmpty() bool <span class="cov8" title="1">{
        return len(a.Params) == 0
}</span>

// TektonAddonsList contains a list of TektonAddon
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonAddonList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonAddon `json:"items"`
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

func (ta *TektonAddon) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{

        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if ta.GetName() != AddonResourceName </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("metadata.name,  Only one instance of TektonAddon is allowed by name, %s", AddonResourceName)
                errs = errs.Also(apis.ErrInvalidValue(ta.GetName(), errMsg))
        }</span>

        // execute common spec validations
        <span class="cov8" title="1">errs = errs.Also(ta.Spec.CommonSpec.validate("spec"))

        if len(ta.Spec.Params) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(validateAddonParams(ta.Spec.Params, "spec.params"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateAddonParams(params []Param, pathToParams string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        for i, p := range params </span><span class="cov8" title="1">{
                // Todo: Remove this in next operator release
                if p.Name == "clusterTasks" || p.Name == "communityClusterTasks" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">paramValue, ok := AddonParams[p.Name]
                if !ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidKeyName(p.Name, pathToParams))
                        continue</span>
                }
                <span class="cov8" title="1">if !isValueInArray(paramValue.Possible, p.Value) </span><span class="cov8" title="1">{
                        path := pathToParams + "." + p.Name
                        errs = errs.Also(apis.ErrInvalidArrayValue(p.Value, path, i))
                }</span>
        }
        <span class="cov8" title="1">paramsMap := ParseParams(params)

        if (paramsMap[ResolverTasks] == "false") &amp;&amp; (paramsMap[PipelineTemplatesParam] == "true") </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrGeneric("pipelineTemplates cannot be true if resolverTask is false", pathToParams))
        }</span>

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/ptr"
)

func (tc *TektonChain) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        tc.Spec.Chain.setDefaults()
}</span>

func (c *Chain) setDefaults() <span class="cov8" title="1">{
        // chains defaults
        if c.ArtifactsTaskRunFormat == "" </span><span class="cov8" title="1">{
                c.ArtifactsTaskRunFormat = "in-toto"
        }</span>
        <span class="cov8" title="1">if c.ArtifactsTaskRunStorage == nil </span><span class="cov8" title="1">{
                c.ArtifactsTaskRunStorage = ptr.String("oci")
        }</span>
        <span class="cov8" title="1">if c.ArtifactsPipelineRunFormat == "" </span><span class="cov8" title="1">{
                c.ArtifactsPipelineRunFormat = "in-toto"
        }</span>
        <span class="cov8" title="1">if c.ArtifactsPipelineRunStorage == nil </span><span class="cov8" title="1">{
                c.ArtifactsPipelineRunStorage = ptr.String("oci")
        }</span>
        <span class="cov8" title="1">if c.ArtifactsOCIFormat == "" </span><span class="cov8" title="1">{
                c.ArtifactsOCIFormat = "simplesigning"
        }</span>
        <span class="cov8" title="1">if c.ArtifactsOCIStorage == nil </span><span class="cov8" title="1">{
                c.ArtifactsOCIStorage = ptr.String("oci")
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

var (
        _ TektonComponentStatus = (*TektonChainStatus)(nil)

        chainCondSet = apis.NewLivingConditionSet(
                DependenciesInstalled,
                PreReconciler,
                InstallerSetAvailable,
                InstallerSetReady,
                PostReconciler,
        )
)

// GroupVersionKind returns SchemeGroupVersion of a TektonChain
func (tc *TektonChain) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonChain)
}</span>

func (tc *TektonChain) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonChain)
}</span>

// GetCondition returns the current condition of a given condition type
func (tcs *TektonChainStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return chainCondSet.Manage(tcs).GetCondition(t)
}</span>

// InitializeConditions initializes conditions of an TektonChainStatus
func (tcs *TektonChainStatus) InitializeConditions() <span class="cov8" title="1">{
        chainCondSet.Manage(tcs).InitializeConditions()
}</span>

// IsReady looks at the conditions returns true if they are all true.
func (tcs *TektonChainStatus) IsReady() bool <span class="cov8" title="1">{
        return chainCondSet.Manage(tcs).IsHappy()
}</span>

func (tcs *TektonChainStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        chainCondSet.Manage(tcs).MarkTrue(PreReconciler)
}</span>

func (tcs *TektonChainStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        chainCondSet.Manage(tcs).MarkTrue(InstallerSetAvailable)
}</span>

func (tcs *TektonChainStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        chainCondSet.Manage(tcs).MarkTrue(InstallerSetReady)
}</span>

func (tcs *TektonChainStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        chainCondSet.Manage(tcs).MarkTrue(PostReconciler)
}</span>

// MarkDependenciesInstalled marks the DependenciesInstalled status as true.
func (tcs *TektonChainStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        chainCondSet.Manage(tcs).MarkTrue(DependenciesInstalled)
}</span>

func (tcs *TektonChainStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        chainCondSet.Manage(tcs).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (tcs *TektonChainStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        tcs.MarkNotReady("PreReconciliation failed")
        chainCondSet.Manage(tcs).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (tcs *TektonChainStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov0" title="0">{
        tcs.MarkNotReady("TektonInstallerSet not ready")
        chainCondSet.Manage(tcs).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tcs *TektonChainStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        tcs.MarkNotReady("TektonInstallerSet not ready")
        chainCondSet.Manage(tcs).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tcs *TektonChainStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        tcs.MarkNotReady("PostReconciliation failed")
        chainCondSet.Manage(tcs).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

// MarkDependencyInstalling marks the DependenciesInstalled status as false with the
// given message.
func (tcs *TektonChainStatus) MarkDependencyInstalling(msg string) <span class="cov0" title="0">{
        tcs.MarkNotReady("Dependencies installing")
        chainCondSet.Manage(tcs).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency installing: %s", msg)
}</span>

// MarkDependencyMissing marks the DependenciesInstalled status as false with the
// given message.
func (tcs *TektonChainStatus) MarkDependencyMissing(msg string) <span class="cov8" title="1">{
        tcs.MarkNotReady("Missing Dependencies for TektonChain")
        chainCondSet.Manage(tcs).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency missing: %s", msg)
}</span>

func (tcs *TektonChainStatus) GetTektonInstallerSet() string <span class="cov0" title="0">{
        return tcs.TektonInstallerSet
}</span>

func (tcs *TektonChainStatus) SetTektonInstallerSet(installerSet string) <span class="cov0" title="0">{
        tcs.TektonInstallerSet = installerSet
}</span>

// GetVersion gets the currently installed version of the component.
func (tcs *TektonChainStatus) GetVersion() string <span class="cov0" title="0">{
        return tcs.Version
}</span>

// SetVersion sets the currently installed version of the component.
func (tcs *TektonChainStatus) SetVersion(version string) <span class="cov0" title="0">{
        tcs.Version = version
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "encoding/json"
        "fmt"
        "strconv"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

var (
        _ TektonComponent     = (*TektonChain)(nil)
        _ TektonComponentSpec = (*TektonChainSpec)(nil)
)

// TektonChain is the Schema for the tektonchain API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonChain struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonChainSpec   `json:"spec,omitempty"`
        Status TektonChainStatus `json:"status,omitempty"`
}

// GetSpec implements TektonComponent
func (tc *TektonChain) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tc.Spec
}</span>

// GetStatus implements TektonComponent
func (tc *TektonChain) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tc.Status
}</span>

// TektonChainSpec defines the desired state of TektonChain
type TektonChainSpec struct {
        CommonSpec `json:",inline"`
        Chain      `json:",inline"`
        // Config holds the configuration for resources created by TektonChain
        // +optional
        Config Config `json:"config,omitempty"`
}

type Chain struct {
        // enable or disable chains feature
        Disabled bool `json:"disabled"`

        // generate signing key
        GenerateSigningSecret bool `json:"generateSigningSecret,omitempty"`

        ChainProperties `json:",inline"`
        ControllerEnvs  []corev1.EnvVar `json:"controllerEnvs,omitempty"`
        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

// ChainProperties defines the field to provide chain configuration
type ChainProperties struct {
        // taskrun artifacts config
        ArtifactsTaskRunFormat  string  `json:"artifacts.taskrun.format,omitempty"`
        ArtifactsTaskRunStorage *string `json:"artifacts.taskrun.storage,omitempty"`
        ArtifactsTaskRunSigner  string  `json:"artifacts.taskrun.signer,omitempty"`

        // pipelinerun artifacts config
        ArtifactsPipelineRunFormat               string    `json:"artifacts.pipelinerun.format,omitempty"`
        ArtifactsPipelineRunStorage              *string   `json:"artifacts.pipelinerun.storage,omitempty"`
        ArtifactsPipelineRunSigner               string    `json:"artifacts.pipelinerun.signer,omitempty"`
        ArtifactsPipelineRunEnableDeepInspection BoolValue `json:"artifacts.pipelinerun.enable-deep-inspection,omitempty"`

        // oci artifacts config
        ArtifactsOCIFormat  string  `json:"artifacts.oci.format,omitempty"`
        ArtifactsOCIStorage *string `json:"artifacts.oci.storage,omitempty"`
        ArtifactsOCISigner  string  `json:"artifacts.oci.signer,omitempty"`

        // storage configs
        StorageGCSBucket              string `json:"storage.gcs.bucket,omitempty"`
        StorageOCIRepository          string `json:"storage.oci.repository,omitempty"`
        StorageOCIRepositoryInsecure  *bool  `json:"storage.oci.repository.insecure,omitempty"`
        StorageDocDBURL               string `json:"storage.docdb.url,omitempty"`
        StorageDocDBMongoServerURL    string `json:"storage.docdb.mongo-server-url,omitempty"`
        StorageDocDBMongoServerURLDir string `json:"storage.docdb.mongo-server-url-dir,omitempty"`
        StorageGrafeasProjectID       string `json:"storage.grafeas.projectid,omitempty"`
        StorageGrafeasNoteID          string `json:"storage.grafeas.noteid,omitempty"`
        StorageGrafeasNoteHint        string `json:"storage.grafeas.notehint,omitempty"`

        // builder config
        BuilderID                string `json:"builder.id,omitempty"`
        BuildDefinitionBuildType string `json:"builddefinition.buildtype,omitempty"`

        // x509 signer config
        X509SignerFulcioEnabled     *bool  `json:"signers.x509.fulcio.enabled,omitempty"`
        X509SignerFulcioAddr        string `json:"signers.x509.fulcio.address,omitempty"`
        X509SignerFulcioOIDCIssuer  string `json:"signers.x509.fulcio.issuer,omitempty"`
        X509SignerFulcioProvider    string `json:"signers.x509.fulcio.provider,omitempty"`
        X509SignerIdentityTokenFile string `json:"signers.x509.identity.token.file,omitempty"`
        X509SignerTUFMirrorURL      string `json:"signers.x509.tuf.mirror.url,omitempty"`

        // kms signer config
        KMSRef               string `json:"signers.kms.kmsref,omitempty"`
        KMSAuthAddress       string `json:"signers.kms.auth.address,omitempty"`
        KMSAuthToken         string `json:"signers.kms.auth.token,omitempty"`
        KMSAuthTokenPath     string `json:"signers.kms.auth.token-path,omitempty"`
        KMSAuthOIDCPath      string `json:"signers.kms.auth.oidc.path,omitempty"`
        KMSAuthOIDCRole      string `json:"signers.kms.auth.oidc.role,omitempty"`
        KMSAuthSpireSock     string `json:"signers.kms.auth.spire.sock,omitempty"`
        KMSAuthSpireAudience string `json:"signers.kms.auth.spire.audience,omitempty"`

        TransparencyConfigEnabled BoolValue `json:"transparency.enabled,omitempty"`
        TransparencyConfigURL     string    `json:"transparency.url,omitempty"`

        // +optional
        Performance PerformanceProperties `json:"performance,omitempty"`
}

type BoolValue string

func (bv *BoolValue) UnmarshalJSON(value []byte) error <span class="cov0" title="0">{
        var a string
        var b bool
        if err := json.Unmarshal(value, &amp;a); err == nil </span><span class="cov0" title="0">{
                // no error, it's a string
                *bv = BoolValue(a)
                return nil
        }</span> else<span class="cov0" title="0"> if err := json.Unmarshal(value, &amp;b); err == nil </span><span class="cov0" title="0">{
                // it is a boolean
                *bv = BoolValue(strconv.FormatBool(b))
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("Invalid value")</span>
}

func (bv BoolValue) MarshalJson() ([]byte, error) <span class="cov0" title="0">{
        return []byte(bv), nil
}</span>

// TektonChainStatus defines the observed state of TektonChain
type TektonChainStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name for TektonChain
        // +optional
        TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`
}

// TektonChainList contains a list of TektonChain
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonChainList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonChain `json:"items"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "strings"

        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

var (
        allowedArtifactsTaskRunFormat                   = sets.NewString("", "in-toto", "slsa/v1", "slsa/v2alpha2", "slsa/v2alpha3")
        allowedArtifactsPipelineRunFormat               = sets.NewString("", "in-toto", "slsa/v1", "slsa/v2alpha2", "slsa/v2alpha3")
        allowedX509SignerFulcioProvider                 = sets.NewString("", "google", "spiffe", "github", "filesystem")
        allowedTransparencyConfigEnabled                = sets.NewString("", "true", "false", "manual")
        allowedArtifactsPipelineRunEnableDeepInspection = sets.NewString("", "true", "false")
        allowedArtifactsStorage                         = sets.NewString("", "tekton", "oci", "gcs", "docdb", "grafeas", "kafka")
        allowedControllerEnvs                           = sets.NewString("MONGO_SERVER_URL")
        allowedBuildDefinitionType                      = sets.NewString("", "https://tekton.dev/chains/v2/slsa", "https://tekton.dev/chains/v2/slsa-tekton")
)

func (tc *TektonChain) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{

        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if tc.GetName() != ChainResourceName </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("metadata.name, Only one instance of TektonChain is allowed by name, %s", ChainResourceName)
                errs = errs.Also(apis.ErrInvalidValue(tc.GetName(), errMsg))
        }</span>

        // execute common spec validations
        <span class="cov8" title="1">errs = errs.Also(tc.Spec.CommonSpec.validate("spec"))

        return errs.Also(tc.Spec.ValidateControllerEnv(), tc.Spec.ValidateChainConfig("spec"))</span>
}

func (tcs *TektonChainSpec) ValidateControllerEnv() (errs *apis.FieldError) <span class="cov8" title="1">{
        if tcs.ControllerEnvs != nil </span><span class="cov8" title="1">{
                for _, v := range tcs.ControllerEnvs </span><span class="cov8" title="1">{
                        if !allowedControllerEnvs.Has(v.Name) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidKeyName(v.Name, fmt.Sprintf("supported keys are %s", strings.Join(allowedControllerEnvs.List(), ","))))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func (tcs *TektonChainSpec) ValidateChainConfig(path string) (errs *apis.FieldError) <span class="cov8" title="1">{

        if !allowedArtifactsTaskRunFormat.Has(tcs.ArtifactsTaskRunFormat) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsTaskRunFormat, path+".artifacts.taskrun.format"))
        }</span>

        <span class="cov8" title="1">if tcs.ArtifactsTaskRunStorage != nil </span><span class="cov8" title="1">{
                input := strings.Split(*tcs.ArtifactsTaskRunStorage, ",")
                for i, v := range input </span><span class="cov8" title="1">{
                        input[i] = strings.TrimSpace(v)
                        if !allowedArtifactsStorage.Has(input[i]) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(input[i], path+".artifacts.taskrun.storage"))
                        }</span>
                }
        }

        <span class="cov8" title="1">if tcs.ArtifactsTaskRunSigner != "" </span><span class="cov0" title="0">{
                if tcs.ArtifactsTaskRunSigner != "x509" &amp;&amp; tcs.ArtifactsTaskRunSigner != "kms" </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsTaskRunSigner, path+".artifacts.taskrun.signer"))
                }</span>
        }

        <span class="cov8" title="1">if !allowedArtifactsPipelineRunFormat.Has(tcs.ArtifactsPipelineRunFormat) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsPipelineRunFormat, path+".artifacts.pipelinerun.format"))
        }</span>

        <span class="cov8" title="1">if tcs.ArtifactsPipelineRunStorage != nil </span><span class="cov8" title="1">{
                input := strings.Split(*tcs.ArtifactsPipelineRunStorage, ",")
                for i, v := range input </span><span class="cov8" title="1">{
                        input[i] = strings.TrimSpace(v)
                        if !allowedArtifactsStorage.Has(input[i]) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(input[i], path+".artifacts.pipelinerun.storage"))
                        }</span>
                }
        }

        <span class="cov8" title="1">if tcs.ArtifactsPipelineRunSigner != "" </span><span class="cov0" title="0">{
                if tcs.ArtifactsPipelineRunSigner != "x509" &amp;&amp; tcs.ArtifactsPipelineRunSigner != "kms" </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsPipelineRunSigner, path+".artifacts.pipelinerun.signer"))
                }</span>
        }

        <span class="cov8" title="1">if tcs.ArtifactsOCIFormat != "" </span><span class="cov0" title="0">{
                if tcs.ArtifactsOCIFormat != "simplesigning" </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsOCIFormat, path+".artifacts.oci.format"))
                }</span>
        }

        <span class="cov8" title="1">if tcs.ArtifactsOCIStorage != nil </span><span class="cov0" title="0">{
                input := strings.Split(*tcs.ArtifactsOCIStorage, ",")
                for i, v := range input </span><span class="cov0" title="0">{
                        input[i] = strings.TrimSpace(v)
                        if !allowedArtifactsStorage.Has(input[i]) </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrInvalidValue(input[i], path+".artifacts.oci.storage"))
                        }</span>
                }
        }

        <span class="cov8" title="1">if tcs.ArtifactsOCISigner != "" </span><span class="cov0" title="0">{
                if tcs.ArtifactsOCISigner != "x509" &amp;&amp; tcs.ArtifactsOCISigner != "kms" </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsOCISigner, path+".artifacts.oci.signer"))
                }</span>
        }

        <span class="cov8" title="1">if !allowedX509SignerFulcioProvider.Has(tcs.X509SignerFulcioProvider) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(tcs.X509SignerFulcioProvider, path+".signers.x509.fulcio.provider"))
        }</span>

        <span class="cov8" title="1">if !allowedTransparencyConfigEnabled.Has(string(tcs.TransparencyConfigEnabled)) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(tcs.TransparencyConfigEnabled, path+".transparency.enabled"))
        }</span>

        <span class="cov8" title="1">if !allowedArtifactsPipelineRunEnableDeepInspection.Has(string(tcs.ArtifactsPipelineRunEnableDeepInspection)) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(tcs.ArtifactsPipelineRunEnableDeepInspection, path+".artifacts.pipelinerun.enable-deep-inspection"))
        }</span>

        <span class="cov8" title="1">if !allowedBuildDefinitionType.Has(tcs.BuildDefinitionBuildType) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(tcs.BuildDefinitionBuildType, path+".builddefinition.buildtype"))
        }</span>

        <span class="cov8" title="1">errs = errs.Also(tcs.Performance.Validate(fmt.Sprintf("%s.performance", path)))

        return errs</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "strings"

        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

func (tc *TektonConfig) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        if tc.Spec.Profile == "" </span><span class="cov8" title="1">{
                tc.Spec.Profile = ProfileBasic
        }</span>
        <span class="cov8" title="1">tc.Spec.Pipeline.setDefaults()
        tc.Spec.Trigger.setDefaults()
        tc.Spec.Chain.setDefaults()
        tc.Spec.Result.setDefaults()
        tc.Spec.TektonPruner.SetDefaults()

        if IsOpenShiftPlatform() </span><span class="cov8" title="1">{
                if tc.Spec.Platforms.OpenShift.PipelinesAsCode == nil </span><span class="cov8" title="1">{
                        tc.Spec.Platforms.OpenShift.PipelinesAsCode = &amp;PipelinesAsCode{
                                Enable: ptr.Bool(true),
                                PACSettings: PACSettings{
                                        Settings: map[string]string{},
                                },
                        }
                }</span> else<span class="cov8" title="1"> {
                        tc.Spec.Addon.EnablePAC = nil
                }</span>

                // check if PAC is disabled through addon before enabling through OpenShiftPipelinesAsCode
                <span class="cov8" title="1">if tc.Spec.Addon.EnablePAC != nil &amp;&amp; !*tc.Spec.Addon.EnablePAC </span><span class="cov8" title="1">{
                        tc.Spec.Platforms.OpenShift.PipelinesAsCode.Enable = ptr.Bool(false)
                        tc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Settings = nil
                }</span>

                // pac defaulting
                <span class="cov8" title="1">if *tc.Spec.Platforms.OpenShift.PipelinesAsCode.Enable </span><span class="cov8" title="1">{
                        logger := logging.FromContext(ctx)
                        tc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.setPACDefaults(logger)
                }</span>

                // SCC defaulting
                <span class="cov8" title="1">if tc.Spec.Platforms.OpenShift.SCC == nil </span><span class="cov8" title="1">{
                        tc.Spec.Platforms.OpenShift.SCC = &amp;SCC{}
                }</span>
                <span class="cov8" title="1">if tc.Spec.Platforms.OpenShift.SCC.Default == "" </span><span class="cov8" title="1">{
                        tc.Spec.Platforms.OpenShift.SCC.Default = PipelinesSCC
                }</span>

                <span class="cov8" title="1">setAddonDefaults(&amp;tc.Spec.Addon)</span>
        } else<span class="cov8" title="1"> {
                tc.Spec.Addon = Addon{}
                tc.Spec.Platforms.OpenShift = OpenShift{}
        }</span>

        // earlier pruner was disabled with empty schedule or empty resources
        // now empty schedule, disables only the global cron job,
        // if a namespace has prune schedule annotation, a cron job will be created for that
        // to disable the pruner feature, "disabled" should be set as "true"
        <span class="cov8" title="1">if !tc.Spec.Pruner.Disabled </span><span class="cov8" title="1">{
                // if keep and keep-since is nil, update default keep value
                if tc.Spec.Pruner.Keep == nil &amp;&amp; tc.Spec.Pruner.KeepSince == nil </span><span class="cov8" title="1">{
                        keep := PrunerDefaultKeep
                        tc.Spec.Pruner.Keep = &amp;keep
                }</span>

                // if empty resources, update default resources
                <span class="cov8" title="1">if len(tc.Spec.Pruner.Resources) == 0 </span><span class="cov8" title="1">{
                        tc.Spec.Pruner.Resources = PruningDefaultResources
                }</span>

                // trim space and to lower case resource names
                <span class="cov8" title="1">for index := range tc.Spec.Pruner.Resources </span><span class="cov8" title="1">{
                        value := tc.Spec.Pruner.Resources[index]
                        value = strings.TrimSpace(value)
                        value = strings.ToLower(value)
                        tc.Spec.Pruner.Resources[index] = value
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

const (
        PreInstall      apis.ConditionType = "PreInstall"
        ComponentsReady apis.ConditionType = "ComponentsReady"
        PostInstall     apis.ConditionType = "PostInstall"
        PreUpgrade      apis.ConditionType = "PreUpgrade"
        PostUpgrade     apis.ConditionType = "PostUpgrade"
)

var (
        configCondSet = apis.NewLivingConditionSet(
                PreInstall,
                ComponentsReady,
                PostInstall,
                PreUpgrade,
                PostUpgrade,
        )
)

func (tc *TektonConfig) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonConfig)
}</span>

func (tc *TektonConfig) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonConfig)
}</span>

func (tcs *TektonConfigStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return configCondSet.Manage(tcs).GetCondition(t)
}</span>

func (tcs *TektonConfigStatus) InitializeConditions() <span class="cov8" title="1">{
        configCondSet.Manage(tcs).InitializeConditions()
}</span>

func (tcs *TektonConfigStatus) IsReady() bool <span class="cov8" title="1">{
        return configCondSet.Manage(tcs).IsHappy()
}</span>

func (tcs *TektonConfigStatus) MarkPreInstallComplete() <span class="cov8" title="1">{
        configCondSet.Manage(tcs).MarkTrue(PreInstall)
}</span>

func (tcs *TektonConfigStatus) MarkComponentsReady() <span class="cov8" title="1">{
        configCondSet.Manage(tcs).MarkTrue(ComponentsReady)
}</span>

func (tcs *TektonConfigStatus) MarkPostInstallComplete() <span class="cov8" title="1">{
        configCondSet.Manage(tcs).MarkTrue(PostInstall)
}</span>

func (tcs *TektonConfigStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        configCondSet.Manage(tcs).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (tcs *TektonConfigStatus) MarkPreInstallFailed(msg string) <span class="cov0" title="0">{
        tcs.MarkNotReady("PreReconciliation failed")
        configCondSet.Manage(tcs).MarkFalse(
                PreInstall,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (tcs *TektonConfigStatus) MarkComponentNotReady(msg string) <span class="cov8" title="1">{
        tcs.MarkNotReady("Components not ready")
        configCondSet.Manage(tcs).MarkFalse(
                ComponentsReady,
                "Error",
                "Components not in ready state: %s", msg)
}</span>

func (tcs *TektonConfigStatus) MarkPostInstallFailed(msg string) <span class="cov0" title="0">{
        tcs.MarkNotReady("PostReconciliation failed")
        configCondSet.Manage(tcs).MarkFalse(
                PostInstall,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

func (tcs *TektonConfigStatus) MarkPreUpgradeComplete() bool <span class="cov8" title="1">{
        condition := configCondSet.Manage(tcs).GetCondition(PreUpgrade)
        if condition != nil &amp;&amp; condition.Status == corev1.ConditionTrue </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">configCondSet.Manage(tcs).MarkTrue(PreUpgrade)
        return true</span>
}

func (tcs *TektonConfigStatus) MarkPostUpgradeComplete() bool <span class="cov8" title="1">{
        condition := configCondSet.Manage(tcs).GetCondition(PostUpgrade)
        if condition != nil &amp;&amp; condition.Status == corev1.ConditionTrue </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">configCondSet.Manage(tcs).MarkTrue(PostUpgrade)
        return true</span>
}

func (tcs *TektonConfigStatus) MarkPreUpgradeFalse(reason, msg string) bool <span class="cov0" title="0">{
        condition := configCondSet.Manage(tcs).GetCondition(PreUpgrade)
        if condition != nil &amp;&amp; condition.Status == corev1.ConditionFalse &amp;&amp; condition.Reason == reason &amp;&amp; condition.Message == msg </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">configCondSet.Manage(tcs).MarkFalse(PreUpgrade, reason, "%s", msg)
        return true</span>
}

func (tcs *TektonConfigStatus) MarkPostUpgradeFalse(reason, msg string) bool <span class="cov0" title="0">{
        condition := configCondSet.Manage(tcs).GetCondition(PostUpgrade)
        if condition != nil &amp;&amp; condition.Status == corev1.ConditionFalse &amp;&amp; condition.Reason == reason &amp;&amp; condition.Message == msg </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">configCondSet.Manage(tcs).MarkFalse(PostUpgrade, reason, "%s", msg)
        return true</span>
}

// GetVersion gets the currently installed version of the component.
func (tcs *TektonConfigStatus) GetVersion() string <span class="cov0" title="0">{
        return tcs.Version
}</span>

// SetVersion sets the currently installed version of the component.
func (tcs *TektonConfigStatus) SetVersion(version string) <span class="cov0" title="0">{
        tcs.Version = version
}</span>

// returns pre upgrade version
func (tcs *TektonConfigStatus) GetPreUpgradeVersion() string <span class="cov8" title="1">{
        if tcs.Annotations == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return tcs.Annotations[PreUpgradeVersionKey]</span>
}

// updates pre upgrade version
func (tcs *TektonConfigStatus) SetPreUpgradeVersion(appliedUpgradeVersion string) <span class="cov8" title="1">{
        if tcs.Annotations == nil </span><span class="cov8" title="1">{
                tcs.Annotations = map[string]string{}
        }</span>
        <span class="cov8" title="1">tcs.Annotations[PreUpgradeVersionKey] = appliedUpgradeVersion</span>
}

// returns post upgrade version
func (tcs *TektonConfigStatus) GetPostUpgradeVersion() string <span class="cov8" title="1">{
        if tcs.Annotations == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return tcs.Annotations[PostUpgradeVersionKey]</span>
}

// updates post upgrade version
func (tcs *TektonConfigStatus) SetPostUpgradeVersion(appliedUpgradeVersion string) <span class="cov8" title="1">{
        if tcs.Annotations == nil </span><span class="cov8" title="1">{
                tcs.Annotations = map[string]string{}
        }</span>
        <span class="cov8" title="1">tcs.Annotations[PostUpgradeVersionKey] = appliedUpgradeVersion</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "reflect"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// TektonConfig is the Schema for the TektonConfigs API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonConfig struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonConfigSpec   `json:"spec,omitempty"`
        Status TektonConfigStatus `json:"status,omitempty"`
}

// GetSpec implements TektonComponent
func (tp *TektonConfig) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tp.Spec
}</span>

// GetStatus implements TektonComponent
func (tp *TektonConfig) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tp.Status
}</span>

// Prune defines the pruner
type Prune struct {
        // enable or disable pruner feature
        Disabled bool `json:"disabled"`
        // apply the prune job to the individual resources
        // +optional
        PrunePerResource bool `json:"prune-per-resource,omitempty"`
        // The resources which need to be pruned
        Resources []string `json:"resources,omitempty"`
        // The number of resource to keep
        // You dont want to delete all the pipelinerun/taskrun's by a cron
        // +optional
        Keep *uint `json:"keep,omitempty"`
        // KeepSince keeps the resources younger than the specified value
        // Its value is taken in minutes
        // +optional
        KeepSince *uint `json:"keep-since,omitempty"`
        // How frequent pruning should happen
        Schedule string `json:"schedule,omitempty"`
        // Optional deadline in seconds for starting the job if it misses scheduled time for any reason.
        // Missed jobs executions will be counted as failed ones.
        StartingDeadlineSeconds *int64 `json:"startingDeadlineSeconds,omitempty"`
}

func (p Prune) IsEmpty() bool <span class="cov0" title="0">{
        return reflect.DeepEqual(p, Prune{})
}</span>

type NamespaceMetadata struct {
        Labels      map[string]string `json:"labels,omitempty"`
        Annotations map[string]string `json:"annotations,omitempty"`
}

// TektonConfigSpec defines the desired state of TektonConfig
type TektonConfigSpec struct {
        Profile string `json:"profile,omitempty"`
        // Config holds the configuration for resources created by TektonConfig
        // +optional
        Config Config `json:"config,omitempty"`
        // Pruner holds the prune config
        // +optional
        Pruner Prune `json:"pruner,omitempty"`
        // New EventBasedPruner which provides more granular control over TaskRun and PipelineRuns
        TektonPruner Pruner `json:"tektonpruner,omitempty"`
        CommonSpec   `json:",inline"`
        // Addon holds the addons config
        // +optional
        Addon Addon `json:"addon,omitempty"`
        // Hub holds the hub config
        // +optional
        Hub Hub `json:"hub,omitempty"`
        // Pipeline holds the customizable option for pipeline component
        // +optional
        Pipeline Pipeline `json:"pipeline,omitempty"`
        // Trigger holds the customizable option for triggers component
        // +optional
        Trigger Trigger `json:"trigger,omitempty"`
        // Chain holds the customizable option for chains component
        // +optional
        Chain Chain `json:"chain,omitempty"`
        // Result holds the customize option for results component
        // +optional
        Result Result `json:"result,omitempty"`
        // Dashboard holds the customizable options for dashboards component
        // +optional
        Dashboard Dashboard `json:"dashboard,omitempty"`
        // Params is the list of params passed for all platforms
        // +optional
        Params []Param `json:"params,omitempty"`
        // Platforms allows configuring platform specific configurations
        // +optional
        Platforms Platforms `json:"platforms,omitempty"`
        // holds target namespace metadata
        // +optional
        TargetNamespaceMetadata *NamespaceMetadata `json:"targetNamespaceMetadata,omitempty"`
}

// TektonConfigStatus defines the observed state of TektonConfig
type TektonConfigStatus struct {
        duckv1.Status `json:",inline"`

        // The profile installed
        // +optional
        Profile string `json:"profile,omitempty"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name
        // +optional
        TektonInstallerSet map[string]string `json:"tektonInstallerSets,omitempty"`
}

func (in *TektonConfigStatus) MarkInstallerSetReady() <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (in *TektonConfigStatus) MarkInstallerSetNotReady(s string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (in *TektonConfigStatus) MarkInstallerSetAvailable() <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (in *TektonConfigStatus) MarkPreReconcilerFailed(s string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (in *TektonConfigStatus) MarkPostReconcilerFailed(s string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// TektonConfigList contains a list of TektonConfig
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonConfigList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonConfig `json:"items"`
}

type Config struct {
        NodeSelector map[string]string   `json:"nodeSelector,omitempty"`
        Tolerations  []corev1.Toleration `json:"tolerations,omitempty"`
        // PriorityClassName holds the priority class to be set to pod template
        // +optional
        PriorityClassName string `json:"priorityClassName,omitempty"`
}

type Platforms struct {
        // OpenShift allows configuring openshift specific components and configurations
        // +optional
        OpenShift OpenShift `json:"openshift,omitempty"`
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"

        "github.com/tektoncd/operator/pkg/common"
        "github.com/tektoncd/operator/pkg/reconciler/openshift"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/logging"
)

func (tc *TektonConfig) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{

        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // disallow to update the targetNamespace
        <span class="cov8" title="1">if apis.IsInUpdate(ctx) </span><span class="cov8" title="1">{
                existingTC := apis.GetBaseline(ctx).(*TektonConfig)
                if existingTC.Spec.GetTargetNamespace() != tc.Spec.GetTargetNamespace() </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric("Doesn't allow to update targetNamespace, delete existing TektonConfig and create the updated TektonConfig", "spec.targetNamespace"))
                }</span>
        }

        <span class="cov8" title="1">if tc.GetName() != ConfigResourceName </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("metadata.name,  Only one instance of TektonConfig is allowed by name, %s", ConfigResourceName)
                errs = errs.Also(apis.ErrInvalidValue(tc.GetName(), errMsg))
        }</span>

        // execute common spec validations
        <span class="cov8" title="1">errs = errs.Also(tc.Spec.CommonSpec.validate("spec"))

        if tc.Spec.Profile != "" </span><span class="cov8" title="1">{
                if isValid := isValueInArray(Profiles, tc.Spec.Profile); !isValid </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(tc.Spec.Profile, "spec.profile"))
                }</span>
        }

        <span class="cov8" title="1">if IsOpenShiftPlatform() &amp;&amp; tc.Spec.Platforms.OpenShift.PipelinesAsCode != nil </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)
                errs = errs.Also(tc.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.validate(logger, "spec.platforms.openshift.pipelinesAsCode"))
        }</span>

        // validate SCC config
        <span class="cov8" title="1">if IsOpenShiftPlatform() &amp;&amp; tc.Spec.Platforms.OpenShift.SCC != nil </span><span class="cov0" title="0">{
                defaultSCC := PipelinesSCC
                if tc.Spec.Platforms.OpenShift.SCC.Default != "" </span><span class="cov0" title="0">{
                        defaultSCC = tc.Spec.Platforms.OpenShift.SCC.Default
                }</span>

                // verify default SCC exists on the cluster

                // we don't want to verify pipelines-scc here as it will be created
                // later when the RBAC reconciler will be run
                <span class="cov0" title="0">if defaultSCC != PipelinesSCC </span><span class="cov0" title="0">{
                        if err := verifySCCExists(ctx, tc.Spec.Platforms.OpenShift.SCC.Default); err != nil </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("error verifying SCC exists: %s - %v", tc.Spec.Platforms.OpenShift.SCC.Default, err), "spec.platforms.openshift.scc.default"))
                        }</span>
                }

                <span class="cov0" title="0">maxAllowedSCC := tc.Spec.Platforms.OpenShift.SCC.MaxAllowed
                if maxAllowedSCC != "" </span><span class="cov0" title="0">{
                        // verify maxAllowed SCC exists on the cluster
                        if err := verifySCCExists(ctx, maxAllowedSCC); err != nil </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("error verifying SCC exists: %s - %v", maxAllowedSCC, err), "spec.platforms.openshift.scc.maxAllowed"))
                        }</span>

                        // Check that maxAllowed SCC and default SCC are compatible wrt priority
                        <span class="cov0" title="0">hasPriority, err := compareSCCAMoreRestrictiveThanB(ctx, defaultSCC, maxAllowedSCC)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("error comparing priority between maxAllowed and default SCC in TektonConfig: %v", err), "spec.platforms.openshift.scc.maxAllowed"))
                        }</span> else<span class="cov0" title="0"> if !hasPriority </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("maxAllowed SCC (%s) must be less restrictive than the default SCC (%s)", maxAllowedSCC, defaultSCC), "spec.platforms.openshift.scc.maxAllowed"))
                        }</span>

                        // Now validate maxAllowed SCC config with namespaces
                        <span class="cov0" title="0">sccErrors, err := compareSCCsWithAllNamespaces(ctx, maxAllowedSCC)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrGeneric(fmt.Sprintf("error comparing priority between maxAllowed and SCCs requested in all namespaces: %v", err), "spec.platforms.openshift.scc.maxAllowed"))
                        }</span>
                        <span class="cov0" title="0">errs = errs.Also(sccErrors)</span>
                }
        }

        // validate pruner specifications
        <span class="cov8" title="1">errs = errs.Also(tc.Spec.Pruner.validate())

        if !tc.Spec.Addon.IsEmpty() </span><span class="cov8" title="1">{
                errs = errs.Also(validateAddonParams(tc.Spec.Addon.Params, "spec.addon.params"))
        }</span>

        <span class="cov8" title="1">if !tc.Spec.Hub.IsEmpty() </span><span class="cov8" title="1">{
                errs = errs.Also(validateHubParams(tc.Spec.Hub.Params, "spec.hub.params"))
        }</span>

        <span class="cov8" title="1">errs = errs.Also(tc.Spec.Pipeline.PipelineProperties.validate("spec.pipeline"))

        errs = errs.Also(tc.Spec.Pipeline.Options.validate("spec.pipeline.options"))
        errs = errs.Also(tc.Spec.Hub.Options.validate("spec.hub.options"))
        errs = errs.Also(tc.Spec.Dashboard.Options.validate("spec.dashboard.options"))
        errs = errs.Also(tc.Spec.Chain.Options.validate("spec.chain.options"))
        errs = errs.Also(tc.Spec.Trigger.Options.validate("spec.trigger.options"))
        errs = errs.Also(tc.Spec.Result.Options.validate("spec.result.options"))

        return errs.Also(tc.Spec.Trigger.TriggersProperties.validate("spec.trigger"))</span>
}

func (p Prune) validate() *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        // if pruner job disable no validation required
        if p.Disabled </span><span class="cov8" title="1">{
                return errs
        }</span>

        <span class="cov8" title="1">if len(p.Resources) != 0 </span><span class="cov8" title="1">{
                for i, r := range p.Resources </span><span class="cov8" title="1">{
                        if !isValueInArray(PruningResource, r) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidArrayValue(r, "spec.pruner.resources", i))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                errs = errs.Also(apis.ErrMissingField("spec.pruner.resources"))
        }</span>

        // tkn cli supports both "keep" and "keep-since", even though there is an issue with the logic
        // when we supply both "keep" and "keep-since", the outcome always equivalent to "keep", "keep-since" ignored
        // hence we strict with a single flag support until the issue is fixed in tkn cli
        // issue: https://github.com/tektoncd/cli/issues/1990
        <span class="cov8" title="1">if p.Keep != nil &amp;&amp; p.KeepSince != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrMultipleOneOf("spec.pruner.keep", "spec.pruner.keep-since"))
        }</span>

        <span class="cov8" title="1">if p.Keep == nil &amp;&amp; p.KeepSince == nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("spec.pruner.keep", "spec.pruner.keep-since"))
        }</span>
        <span class="cov8" title="1">if p.Keep != nil &amp;&amp; *p.Keep == 0 </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(*p.Keep, "spec.pruner.keep"))
        }</span>
        <span class="cov8" title="1">if p.KeepSince != nil &amp;&amp; *p.KeepSince == 0 </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(*p.KeepSince, "spec.pruner.keep-since"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func isValueInArray(arr []string, key string) bool <span class="cov8" title="1">{
        for _, p := range arr </span><span class="cov8" title="1">{
                if p == key </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func verifySCCExists(ctx context.Context, sccName string) error <span class="cov0" title="0">{
        securityClient := common.GetSecurityClient(ctx)
        _, err := securityClient.SecurityV1().SecurityContextConstraints().Get(ctx, sccName, metav1.GetOptions{})
        return err
}</span>

func compareSCCAMoreRestrictiveThanB(ctx context.Context, sccA, sccB string) (bool, error) <span class="cov0" title="0">{
        securityClient := common.GetSecurityClient(ctx)
        prioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, securityClient)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return common.SCCAMoreRestrictiveThanB(prioritizedSCCList, sccA, sccB)</span>
}

func compareSCCsWithAllNamespaces(ctx context.Context, maxAllowedSCC string) (*apis.FieldError, error) <span class="cov0" title="0">{
        kc := kubeclient.Get(ctx)
        allNamespaces, err := kc.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var sccErrors *apis.FieldError
        for _, ns := range allNamespaces.Items </span><span class="cov0" title="0">{
                nsSCC := ns.Annotations[openshift.NamespaceSCCAnnotation]
                if nsSCC == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Compare namespace SCC with maxAllowed
                <span class="cov0" title="0">hasPriority, err := compareSCCAMoreRestrictiveThanB(ctx, nsSCC, maxAllowedSCC)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if !hasPriority </span><span class="cov0" title="0">{
                        sccErrors = sccErrors.Also(apis.ErrGeneric(fmt.Sprintf("SCC requested in namespace %s: %s violates the maxAllowed SCC: %s set in TektonConfig", ns.Name, nsSCC, maxAllowedSCC)))
                }</span>
        }
        <span class="cov0" title="0">return sccErrors, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

var (
        _ TektonComponentStatus = (*TektonDashboardStatus)(nil)

        dashboardCondSet = apis.NewLivingConditionSet(
                DependenciesInstalled,
                PreReconciler,
                InstallerSetAvailable,
                InstallerSetReady,
                PostReconciler,
        )
)

// GroupVersionKind returns SchemeGroupVersion of a TektonDashboard
func (td *TektonDashboard) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonDashboard)
}</span>

func (td *TektonDashboard) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonDashboard)
}</span>

// GetCondition returns the current condition of a given condition type
func (tds *TektonDashboardStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return dashboardCondSet.Manage(tds).GetCondition(t)
}</span>

// InitializeConditions initializes conditions of an TektonDashboardStatus
func (tds *TektonDashboardStatus) InitializeConditions() <span class="cov8" title="1">{
        dashboardCondSet.Manage(tds).InitializeConditions()
}</span>

// IsReady looks at the conditions returns true if they are all true.
func (tds *TektonDashboardStatus) IsReady() bool <span class="cov8" title="1">{
        return dashboardCondSet.Manage(tds).IsHappy()
}</span>

func (tds *TektonDashboardStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        dashboardCondSet.Manage(tds).MarkTrue(PreReconciler)
}</span>

func (tds *TektonDashboardStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        dashboardCondSet.Manage(tds).MarkTrue(InstallerSetAvailable)
}</span>

func (tds *TektonDashboardStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        dashboardCondSet.Manage(tds).MarkTrue(InstallerSetReady)
}</span>

func (tds *TektonDashboardStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        dashboardCondSet.Manage(tds).MarkTrue(PostReconciler)
}</span>

// MarkDependenciesInstalled marks the DependenciesInstalled status as true.
func (tds *TektonDashboardStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        dashboardCondSet.Manage(tds).MarkTrue(DependenciesInstalled)
}</span>

func (tds *TektonDashboardStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        dashboardCondSet.Manage(tds).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (tds *TektonDashboardStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        tds.MarkNotReady("PreReconciliation failed")
        dashboardCondSet.Manage(tds).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (tds *TektonDashboardStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov0" title="0">{
        tds.MarkNotReady("TektonInstallerSet not ready")
        dashboardCondSet.Manage(tds).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tds *TektonDashboardStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        tds.MarkNotReady("TektonInstallerSet not ready")
        dashboardCondSet.Manage(tds).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tds *TektonDashboardStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        tds.MarkNotReady("PostReconciliation failed")
        dashboardCondSet.Manage(tds).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

// MarkDependencyInstalling marks the DependenciesInstalled status as false with the
// given message.
func (tds *TektonDashboardStatus) MarkDependencyInstalling(msg string) <span class="cov0" title="0">{
        tds.MarkNotReady("Dependencies installing")
        dashboardCondSet.Manage(tds).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency installing: %s", msg)
}</span>

// MarkDependencyMissing marks the DependenciesInstalled status as false with the
// given message.
func (tds *TektonDashboardStatus) MarkDependencyMissing(msg string) <span class="cov8" title="1">{
        tds.MarkNotReady("Missing Dependencies for TektonDashboard")
        dashboardCondSet.Manage(tds).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency missing: %s", msg)
}</span>

func (tds *TektonDashboardStatus) GetTektonInstallerSet() string <span class="cov0" title="0">{
        return tds.TektonInstallerSet
}</span>

func (tds *TektonDashboardStatus) SetTektonInstallerSet(installerSet string) <span class="cov0" title="0">{
        tds.TektonInstallerSet = installerSet
}</span>

// GetVersion gets the currently installed version of the component.
func (tds *TektonDashboardStatus) GetVersion() string <span class="cov0" title="0">{
        return tds.Version
}</span>

// SetVersion sets the currently installed version of the component.
func (tds *TektonDashboardStatus) SetVersion(version string) <span class="cov0" title="0">{
        tds.Version = version
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

var (
        _ TektonComponent     = (*TektonDashboard)(nil)
        _ TektonComponentSpec = (*TektonDashboardSpec)(nil)
)

// TektonDashboard is the Schema for the tektondashboards API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonDashboard struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonDashboardSpec   `json:"spec,omitempty"`
        Status TektonDashboardStatus `json:"status,omitempty"`
}

// GetSpec implements TektonComponent
func (tp *TektonDashboard) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tp.Spec
}</span>

// GetStatus implements TektonComponent
func (tp *TektonDashboard) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tp.Status
}</span>

// TektonDashboardSpec defines the desired state of TektonDashboard
type TektonDashboardSpec struct {
        CommonSpec `json:",inline"`
        Dashboard  `json:",inline"`
        // Config holds the configuration for resources created by TektonDashboard
        // +optional
        Config Config `json:"config,omitempty"`
}

// TektonDashboardStatus defines the observed state of TektonDashboard
type TektonDashboardStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name for TektonDashboard
        // +optional
        TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`
}

// TektonDashboardsList contains a list of TektonDashboard
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonDashboardList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonDashboard `json:"items"`
}

// Dashboard degines the fields to customize the Dashboard component
type Dashboard struct {
        DashboardProperties `json:",inline"`
        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

// Dashboard degines the fields to customize the Dashboard component
type DashboardProperties struct {
        // Readonly when set to true configures the Tekton dashboard in read-only mode
        Readonly bool `json:"readonly"`
        // +optional
        ExternalLogs string `json:"external-logs,omitempty"`
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"

        "knative.dev/pkg/apis"
)

func (td *TektonDashboard) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{

        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if td.GetName() != DashboardResourceName </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("metadata.name,  Only one instance of TektonDashboard is allowed by name, %s", DashboardResourceName)
                errs = errs.Also(apis.ErrInvalidValue(td.GetName(), errMsg))
        }</span>

        // execute common spec validations
        <span class="cov8" title="1">errs = errs.Also(td.Spec.CommonSpec.validate("spec"))

        return errs</span>
}

func (td *TektonDashboard) SetDefaults(ctx context.Context) {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "os"
)

func (th *TektonHub) SetDefaults(ctx context.Context) <span class="cov8" title="1">{

        if th.Spec.Api.ApiSecretName == "" </span><span class="cov0" title="0">{
                th.Spec.Api.ApiSecretName = HubApiSecretName
        }</span>

        <span class="cov8" title="1">if th.Spec.CommonSpec.TargetNamespace == "" </span><span class="cov8" title="1">{
                th.Spec.CommonSpec.TargetNamespace = os.Getenv("DEFAULT_TARGET_NAMESPACE")
        }</span>

        <span class="cov8" title="1">if th.Spec.Api.CatalogRefreshInterval == "" </span><span class="cov8" title="1">{
                th.Spec.Api.CatalogRefreshInterval = "30m"
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

const (
        // DB
        DbDependenciesInstalled apis.ConditionType = "DbDependenciesInstalled"
        DbInstallerSetAvailable apis.ConditionType = "DbInstallSetAvailable"
        // DB-migration
        // TODO: fix the typo on the value: "DatabasebMigrationDone"
        DatabaseMigrationDone apis.ConditionType = "DatabasebMigrationDone"
        // API
        ApiDependenciesInstalled apis.ConditionType = "ApiDependenciesInstalled"
        ApiInstallerSetAvailable apis.ConditionType = "ApiInstallSetAvailable"
        // UI
        UiInstallerSetAvailable apis.ConditionType = "UiInstallSetAvailable"
)

var (
        // TODO: Add this back after refactoring all components
        // and updating TektonComponentStatus to have updated
        // conditions
        // _ TektonComponentStatus = (*TektonHubStatus)(nil)

        hubCondSet = apis.NewLivingConditionSet(
                DbDependenciesInstalled,
                DbInstallerSetAvailable,
                DatabaseMigrationDone,
                PreReconciler,
                ApiDependenciesInstalled,
                ApiInstallerSetAvailable,
                UiInstallerSetAvailable,
                PostReconciler,
        )
)

// GroupVersionKind returns SchemeGroupVersion of a TektonHub
func (th *TektonHub) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonHub)
}</span>

// required by new type of FilterController
// might have to keep this and remove previous or vice-versa
func (th *TektonHub) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonHub)
}</span>

// GetCondition returns the current condition of a given condition type
func (ths *TektonHubStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return hubCondSet.Manage(ths).GetCondition(t)
}</span>

// InitializeConditions initializes conditions of an TektonHubStatus
func (ths *TektonHubStatus) InitializeConditions() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).InitializeConditions()
}</span>

func (ths *TektonHubStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

// IsReady looks at the conditions returns true if they are all true.
func (ths *TektonHubStatus) IsReady() bool <span class="cov8" title="1">{
        return hubCondSet.Manage(ths).IsHappy()
}</span>

// Lifecycle for the DB component of Tekton Hub
func (ths *TektonHubStatus) MarkDbDependencyInstalling(msg string) <span class="cov0" title="0">{
        ths.MarkNotReady("Dependencies installing for DB")
        hubCondSet.Manage(ths).MarkFalse(
                DbDependenciesInstalled,
                "Error",
                "Dependencies are installing for DB: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkDbDependencyMissing(msg string) <span class="cov0" title="0">{
        ths.MarkNotReady("Missing Dependencies for DB")
        hubCondSet.Manage(ths).MarkFalse(
                DbDependenciesInstalled,
                "Error",
                "Dependencies are missing for DB: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkDbDependenciesInstalled() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(DbDependenciesInstalled)
}</span>

func (ths *TektonHubStatus) MarkDbInstallerSetNotAvailable(msg string) <span class="cov8" title="1">{
        ths.MarkNotReady("TektonInstallerSet not ready for DB")
        hubCondSet.Manage(ths).MarkFalse(
                DbInstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkDbInstallerSetAvailable() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(DbInstallerSetAvailable)
}</span>

// Lifecycle for the DB migration component of Tekton Hub
func (ths *TektonHubStatus) MarkDatabaseMigrationFailed(msg string) <span class="cov8" title="1">{
        ths.MarkNotReady("Database migration job not ready")
        hubCondSet.Manage(ths).MarkFalse(
                DatabaseMigrationDone,
                "Error",
                "Database migration job not ready: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkDatabaseMigrationDone() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(DatabaseMigrationDone)
}</span>

// Lifecycle for the API component of Tekton Hub
func (ths *TektonHubStatus) MarkApiDependencyInstalling(msg string) <span class="cov0" title="0">{
        ths.MarkNotReady("Dependencies installing for API")
        hubCondSet.Manage(ths).MarkFalse(
                ApiDependenciesInstalled,
                "Error",
                "Dependencies are installing for API: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkApiDependencyMissing(msg string) <span class="cov0" title="0">{
        ths.MarkNotReady("Missing Dependencies for API")
        hubCondSet.Manage(ths).MarkFalse(
                ApiDependenciesInstalled,
                "Error",
                "Dependencies are missing for API: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkApiDependenciesInstalled() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(ApiDependenciesInstalled)
}</span>

func (ths *TektonHubStatus) MarkApiInstallerSetNotAvailable(msg string) <span class="cov8" title="1">{
        ths.MarkNotReady("TektonInstallerSet not ready for API")
        hubCondSet.Manage(ths).MarkFalse(
                ApiInstallerSetAvailable,
                "Error",
                "Installer set not ready for API: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkApiInstallerSetAvailable() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(ApiInstallerSetAvailable)
}</span>

func (ths *TektonHubStatus) MarkUiInstallerSetNotAvailable(msg string) <span class="cov8" title="1">{
        ths.MarkNotReady("TektonInstallerSet not ready for UI")
        hubCondSet.Manage(ths).MarkFalse(
                UiInstallerSetAvailable,
                "Error",
                "Installer set not ready for UI: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkUiInstallerSetAvailable() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(UiInstallerSetAvailable)
}</span>

// GetManifests gets the url links of the manifests.
func (ths *TektonHubStatus) GetUiRoute() string <span class="cov0" title="0">{
        return ths.UiRouteUrl
}</span>

// SetManifests sets the url links of the manifests.
func (ths *TektonHubStatus) SetUiRoute(routeUrl string) <span class="cov0" title="0">{
        ths.UiRouteUrl = routeUrl
}</span>

func (ths *TektonHubStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        ths.MarkNotReady("PreReconciliation failed")
        hubCondSet.Manage(ths).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(PreReconciler)
}</span>

func (ths *TektonHubStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        ths.MarkNotReady("PostReconciliation failed")
        hubCondSet.Manage(ths).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

func (ths *TektonHubStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        hubCondSet.Manage(ths).MarkTrue(PostReconciler)
}</span>

// Get the API route URL
func (ths *TektonHubStatus) GetApiRoute() string <span class="cov0" title="0">{
        return ths.ApiRouteUrl
}</span>

// Set the API route URL
func (ths *TektonHubStatus) SetApiRoute(routeUrl string) <span class="cov0" title="0">{
        ths.ApiRouteUrl = routeUrl
}</span>

// Get the Auth route URL
func (ths *TektonHubStatus) GetAuthRoute() string <span class="cov0" title="0">{
        return ths.AuthRouteUrl
}</span>

// Set the Auth route URL
func (ths *TektonHubStatus) SetAuthRoute(routeUrl string) <span class="cov0" title="0">{
        ths.AuthRouteUrl = routeUrl
}</span>

// GetVersion gets the currently installed version of the component.
func (ths *TektonHubStatus) GetVersion() string <span class="cov0" title="0">{
        return ths.Version
}</span>

// SetVersion sets the currently installed version of the component.
func (ths *TektonHubStatus) SetVersion(version string) <span class="cov0" title="0">{
        ths.Version = version
}</span>

// GetManifests gets the url links of the manifests.
func (ths *TektonHubStatus) GetManifests() []string <span class="cov0" title="0">{
        return ths.Manifests
}</span>

// SetManifests sets the url links of the manifests.
func (ths *TektonHubStatus) SetManifests(manifests []string) <span class="cov0" title="0">{
        ths.Manifests = manifests
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

const (
        HubDbSecretName  = "tekton-hub-db"
        HubApiSecretName = "tekton-hub-api"
)

var (
        _ TektonComponent     = (*TektonHub)(nil)
        _ TektonComponentSpec = (*TektonHubSpec)(nil)
)

// TektonHub is the Schema for the tektonhub API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonHub struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonHubSpec   `json:"spec,omitempty"`
        Status TektonHubStatus `json:"status,omitempty"`
}

type TektonHubSpec struct {
        CommonSpec `json:",inline"`
        Hub        `json:",inline"`
        Categories []string       `json:"categories,omitempty"`
        Catalogs   []Catalog      `json:"catalogs,omitempty"`
        Scopes     []Scope        `json:"scopes,omitempty"`
        Default    Default        `json:"default,omitempty"`
        Db         DbSpec         `json:"db,omitempty"`
        Api        ApiSpec        `json:"api,omitempty"`
        CustomLogo CustomLogoSpec `json:"customLogo,omitempty"`
}

// Hub defines the field to customize Hub component
type Hub struct {
        // Params is the list of params passed for Hub customization
        // +optional
        Params []Param `json:"params,omitempty"`
        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

type DbSpec struct {
        DbSecretName string `json:"secret,omitempty"`
}

type ApiSpec struct {
        // Deprecated, will be removed in further release
        HubConfigUrl           string `json:"hubConfigUrl,omitempty"`
        ApiSecretName          string `json:"secret,omitempty"`
        RouteHostUrl           string `json:"routeHostUrl,omitempty"`
        CatalogRefreshInterval string `json:"catalogRefreshInterval,omitempty"`
}

type Category struct {
        Name string `json:"name,omitempty"`
}

type Catalog struct {
        Name       string `json:"name,omitempty"`
        Org        string `json:"org,omitempty"`
        Type       string `json:"type,omitempty"`
        URL        string `json:"url,omitempty"`
        SshUrl     string `json:"sshUrl,omitempty"`
        ContextDir string `json:"contextDir,omitempty"`
        Revision   string `json:"revision,omitempty"`
        Provider   string `json:"provider,omitempty"`
}

type Scope struct {
        Name  string   `json:"name,omitempty"`
        Users []string `json:"users,omitempty"`
}

type Default struct {
        Scopes []string `json:"scopes,omitempty"`
}

// The Base64 Encode data and mediaType of the Custom Logo
type CustomLogoSpec struct {
        Base64Data string `json:"base64Data,omitempty"`
        MediaType  string `json:"mediaType,omitempty"`
}

// TektonHubStatus defines the observed state of TektonHub
type TektonHubStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The url links of the manifests, separated by comma
        // +optional
        Manifests []string `json:"manifests,omitempty"`

        // The URL route for API which needs to be exposed
        // +optional
        ApiRouteUrl string `json:"apiUrl,omitempty"`

        // The URL route for Auth server
        // +optional
        AuthRouteUrl string `json:"authUrl,omitempty"`

        // The URL route for UI which needs to be exposed
        // +optional
        UiRouteUrl string `json:"uiUrl,omitempty"`

        // The current installer set name
        // +optional
        HubInstallerSet map[string]string `json:"hubInstallerSets,omitempty"`
}

func (in *TektonHubStatus) MarkInstallerSetReady() <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (in *TektonHubStatus) MarkInstallerSetNotReady(s string) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (in *TektonHubStatus) MarkInstallerSetAvailable() <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

// TektonHubList contains a list of TektonHub
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonHubList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonHub `json:"items"`
}

// GetSpec implements TektonComponent
func (th *TektonHub) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;th.Spec
}</span>

// GetStatus implements TektonComponent
func (th *TektonHub) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;th.Status
}</span>

func (h Hub) IsEmpty() bool <span class="cov8" title="1">{
        return len(h.Params) == 0
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/apis"
)

func validateHubParams(params []Param, pathToParams string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        for i, p := range params </span><span class="cov8" title="1">{
                paramValue, ok := HubParams[p.Name]
                if !ok </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidKeyName(p.Name, pathToParams))
                        continue</span>
                }
                <span class="cov8" title="1">if !isValueInArray(paramValue.Possible, p.Value) </span><span class="cov8" title="1">{
                        path := pathToParams + "." + p.Name
                        errs = errs.Also(apis.ErrInvalidArrayValue(p.Value, path, i))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func (th *TektonHub) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // disallow to update the targetNamespace
        <span class="cov8" title="1">if apis.IsInUpdate(ctx) </span><span class="cov8" title="1">{
                existingTC := apis.GetBaseline(ctx).(*TektonHub)
                if existingTC.Spec.GetTargetNamespace() != th.Spec.GetTargetNamespace() </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrGeneric("doesn't allow to update targetNamespace, delete existing TektonHub object and create the updated TektonHub object", "spec.targetNamespace"))
                }</span>
        }

        // execute common spec validations
        <span class="cov8" title="1">errs = errs.Also(th.Spec.CommonSpec.validate("spec"))

        // validate database secret name
        if th.Spec.Db.DbSecretName != "" &amp;&amp; th.Spec.Db.DbSecretName != HubDbSecretName </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(th.Spec.Db.DbSecretName, "spec.db.secret"))
        }</span>

        // validate api secret name
        <span class="cov8" title="1">if th.Spec.Api.ApiSecretName != "" &amp;&amp; th.Spec.Api.ApiSecretName != HubApiSecretName </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(th.Spec.Api.ApiSecretName, "spec.api.secret"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

const (
        CrdInstalled         apis.ConditionType = "CrdsInstalled"
        ClustersScoped       apis.ConditionType = "ClusterScopedResourcesInstalled"
        NamespaceScoped      apis.ConditionType = "NamespaceScopedResourcesInstalled"
        DeploymentsAvailable apis.ConditionType = "DeploymentsAvailable"
        StatefulSetReady     apis.ConditionType = "StatefulSetReady"
        WebhookReady         apis.ConditionType = "WebhooksReady"
        ControllerReady      apis.ConditionType = "ControllersReady"
        AllDeploymentsReady  apis.ConditionType = "AllDeploymentsReady"
        JobsInstalled        apis.ConditionType = "JobsInstalled"
)

var (
        installerSetCondSet = apis.NewLivingConditionSet(
                CrdInstalled,
                ClustersScoped,
                NamespaceScoped,
                DeploymentsAvailable,
                StatefulSetReady,
                WebhookReady,
                ControllerReady,
                AllDeploymentsReady,
                JobsInstalled,
        )
)

func (tis *TektonInstallerSet) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonInstallerSet)
}</span>

func (tis *TektonInstallerSetStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return installerSetCondSet.Manage(tis).GetCondition(t)
}</span>

func (tis *TektonInstallerSetStatus) InitializeConditions() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).InitializeConditions()
}</span>

func (tis *TektonInstallerSetStatus) IsReady() bool <span class="cov8" title="1">{
        return installerSetCondSet.Manage(tis).IsHappy()
}</span>

func (tis *TektonInstallerSetStatus) MarkReady() <span class="cov0" title="0">{
        installerSetCondSet.Manage(tis).MarkTrue(apis.ConditionReady)
}</span>

func (tis *TektonInstallerSetStatus) MarkCRDsInstalled() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(CrdInstalled)
}</span>

func (tis *TektonInstallerSetStatus) MarkClustersScopedResourcesInstalled() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(ClustersScoped)
}</span>

func (tis *TektonInstallerSetStatus) MarkNamespaceScopedResourcesInstalled() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(NamespaceScoped)
}</span>

func (tis *TektonInstallerSetStatus) MarkDeploymentsAvailable() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(DeploymentsAvailable)
}</span>

func (tis *TektonInstallerSetStatus) MarkStatefulSetReady() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(StatefulSetReady)
}</span>

func (tis *TektonInstallerSetStatus) MarkWebhookReady() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(WebhookReady)
}</span>

func (tis *TektonInstallerSetStatus) MarkControllerReady() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(ControllerReady)
}</span>

func (tis *TektonInstallerSetStatus) MarkAllDeploymentsReady() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(AllDeploymentsReady)
}</span>

func (tis *TektonInstallerSetStatus) MarkJobsInstalled() <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkTrue(JobsInstalled)
}</span>

func (tis *TektonInstallerSetStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        installerSetCondSet.Manage(tis).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkCRDsInstallationFailed(msg string) <span class="cov8" title="1">{
        tis.MarkNotReady("CRDs installation failed")
        installerSetCondSet.Manage(tis).MarkFalse(
                CrdInstalled,
                "Error",
                "Install failed with message: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkClustersScopedInstallationFailed(msg string) <span class="cov0" title="0">{
        tis.MarkNotReady("Cluster Scoped resources installation failed")
        installerSetCondSet.Manage(tis).MarkFalse(
                ClustersScoped,
                "Error",
                "Install failed with message: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkNamespaceScopedInstallationFailed(msg string) <span class="cov0" title="0">{
        tis.MarkNotReady("Namespace Scoped resources installation failed")
        installerSetCondSet.Manage(tis).MarkFalse(
                NamespaceScoped,
                "Error",
                "Install failed with message: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkDeploymentsAvailableFailed(msg string) <span class="cov0" title="0">{
        tis.MarkNotReady("Deployment resources installation failed")
        installerSetCondSet.Manage(tis).MarkFalse(
                DeploymentsAvailable,
                "Error",
                "Install failed with message: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkStatefulSetNotReady(msg string) <span class="cov0" title="0">{
        tis.MarkNotReady("StatefulSet resources is not available")
        installerSetCondSet.Manage(tis).MarkFalse(
                StatefulSetReady,
                "Error",
                "Install failed with message: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkWebhookNotReady(msg string) <span class="cov8" title="1">{
        tis.MarkNotReady("Webhooks not available")
        installerSetCondSet.Manage(tis).MarkFalse(
                WebhookReady,
                "Error",
                "Webhook: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkControllerNotReady(msg string) <span class="cov0" title="0">{
        tis.MarkNotReady("Controller Deployment not available")
        installerSetCondSet.Manage(tis).MarkFalse(
                ControllerReady,
                "Error",
                "Controller: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkAllDeploymentsNotReady(msg string) <span class="cov0" title="0">{
        tis.MarkNotReady("All Deployments not available")
        installerSetCondSet.Manage(tis).MarkFalse(
                AllDeploymentsReady,
                "Error",
                "Deployment: %s", msg)
}</span>

func (tis *TektonInstallerSetStatus) MarkJobsInstallationFailed(msg string) <span class="cov0" title="0">{
        tis.MarkNotReady("Job resources installation failed")
        installerSetCondSet.Manage(tis).MarkFalse(
                JobsInstalled,
                "Error",
                "Install failed with message: %s", msg)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "knative.dev/pkg/ptr"
)

const (
        // openshift specific
        enableMetricsKey                         = "enableMetrics"
        enableMetricsDefaultValue                = "true"
        openshiftDefaultDisableAffinityAssistant = true
        ospDefaultSA                             = "pipeline"
)

func (tp *TektonPipeline) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        tp.Spec.setDefaults()
}</span>

func (p *Pipeline) setDefaults() <span class="cov8" title="1">{
        if p.DisableCredsInit == nil </span><span class="cov8" title="1">{
                p.DisableCredsInit = ptr.Bool(config.DefaultDisableCredsInit)
        }</span>
        <span class="cov8" title="1">if p.AwaitSidecarReadiness == nil </span><span class="cov8" title="1">{
                p.AwaitSidecarReadiness = ptr.Bool(config.DefaultAwaitSidecarReadiness)
        }</span>
        <span class="cov8" title="1">if p.RunningInEnvironmentWithInjectedSidecars == nil </span><span class="cov8" title="1">{
                p.RunningInEnvironmentWithInjectedSidecars = ptr.Bool(config.DefaultRunningInEnvWithInjectedSidecars)
        }</span>
        <span class="cov8" title="1">if p.RequireGitSshSecretKnownHosts == nil </span><span class="cov8" title="1">{
                p.RequireGitSshSecretKnownHosts = ptr.Bool(config.DefaultRequireGitSSHSecretKnownHosts)
        }</span>

        // not in use, see: https://github.com/tektoncd/pipeline/pull/7789
        // this field is removed from pipeline component
        // keeping here to maintain the API compatibility
        <span class="cov8" title="1">p.EnableTektonOciBundles = nil

        if p.EnableCustomTasks == nil </span><span class="cov8" title="1">{
                // EnableCustomTask is always enable
                p.EnableCustomTasks = ptr.Bool(true)
        }</span>
        <span class="cov8" title="1">if p.SendCloudEventsForRuns == nil </span><span class="cov8" title="1">{
                p.SendCloudEventsForRuns = ptr.Bool(config.DefaultSendCloudEventsForRuns)
        }</span>
        <span class="cov8" title="1">if p.EnableApiFields == "" </span><span class="cov8" title="1">{
                p.EnableApiFields = config.DefaultEnableAPIFields
        }</span>

        // "verification-mode" is deprecated and never used.
        // this field will be removed, see https://github.com/tektoncd/operator/issues/1497
        <span class="cov8" title="1">p.VerificationMode = ""

        if p.VerificationNoMatchPolicy == "" </span><span class="cov8" title="1">{
                p.VerificationNoMatchPolicy = config.DefaultNoMatchPolicyConfig
        }</span>

        <span class="cov8" title="1">if p.EnableProvenanceInStatus == nil </span><span class="cov8" title="1">{
                p.EnableProvenanceInStatus = ptr.Bool(config.DefaultEnableProvenanceInStatus)
        }</span>

        // Deprecated: set to nil, remove in further release
        <span class="cov8" title="1">p.ScopeWhenExpressionsToTask = nil

        if p.EnforceNonfalsifiability == "" </span><span class="cov8" title="1">{
                p.EnforceNonfalsifiability = config.DefaultEnforceNonfalsifiability
        }</span>

        <span class="cov8" title="1">if p.EnableKeepPodOnCancel == nil </span><span class="cov8" title="1">{
                p.EnableKeepPodOnCancel = ptr.Bool(config.DefaultEnableKeepPodOnCancel.Enabled)
        }</span>

        <span class="cov8" title="1">if p.ResultExtractionMethod == "" </span><span class="cov8" title="1">{
                p.ResultExtractionMethod = config.DefaultResultExtractionMethod
        }</span>

        <span class="cov8" title="1">if p.MaxResultSize == nil </span><span class="cov8" title="1">{
                p.MaxResultSize = ptr.Int32(config.DefaultMaxResultSize)
        }</span>

        <span class="cov8" title="1">if p.SetSecurityContext == nil </span><span class="cov8" title="1">{
                p.SetSecurityContext = ptr.Bool(config.DefaultSetSecurityContext)
        }</span>

        <span class="cov8" title="1">if p.Coschedule == "" </span><span class="cov8" title="1">{
                p.Coschedule = config.DefaultCoschedule
        }</span>

        <span class="cov8" title="1">if p.EnableCELInWhenExpression == nil </span><span class="cov8" title="1">{
                p.EnableCELInWhenExpression = ptr.Bool(config.DefaultEnableCELInWhenExpression.Enabled)
        }</span>

        <span class="cov8" title="1">if p.EnableStepActions == nil </span><span class="cov8" title="1">{
                p.EnableStepActions = ptr.Bool(config.DefaultFeatureFlags.EnableStepActions)
        }</span>

        <span class="cov8" title="1">if p.EnableParamEnum == nil </span><span class="cov8" title="1">{
                p.EnableParamEnum = ptr.Bool(config.DefaultEnableParamEnum.Enabled)
        }</span>

        <span class="cov8" title="1">if p.DisableInlineSpec == "" </span><span class="cov8" title="1">{
                p.DisableInlineSpec = config.DefaultDisableInlineSpec
        }</span>

        <span class="cov8" title="1">if p.MetricsPipelinerunDurationType == "" </span><span class="cov8" title="1">{
                p.MetricsPipelinerunDurationType = config.DefaultDurationPipelinerunType
        }</span>
        <span class="cov8" title="1">if p.MetricsPipelinerunLevel == "" </span><span class="cov8" title="1">{
                p.MetricsPipelinerunLevel = config.DefaultPipelinerunLevel
        }</span>
        <span class="cov8" title="1">if p.MetricsTaskrunDurationType == "" </span><span class="cov8" title="1">{
                p.MetricsTaskrunDurationType = config.DefaultDurationTaskrunType
        }</span>
        <span class="cov8" title="1">if p.MetricsTaskrunLevel == "" </span><span class="cov8" title="1">{
                p.MetricsTaskrunLevel = config.DefaultTaskrunLevel
        }</span>
        <span class="cov8" title="1">if p.CountWithReason == nil </span><span class="cov8" title="1">{
                p.CountWithReason = ptr.Bool(false)
        }</span>

        // Resolvers
        <span class="cov8" title="1">if p.EnableBundlesResolver == nil </span><span class="cov8" title="1">{
                p.EnableBundlesResolver = ptr.Bool(true)
        }</span>
        <span class="cov8" title="1">if p.EnableClusterResolver == nil </span><span class="cov8" title="1">{
                p.EnableClusterResolver = ptr.Bool(true)
        }</span>
        <span class="cov8" title="1">if p.EnableHubResolver == nil </span><span class="cov8" title="1">{
                p.EnableHubResolver = ptr.Bool(true)
        }</span>
        <span class="cov8" title="1">if p.EnableGitResolver == nil </span><span class="cov8" title="1">{
                p.EnableGitResolver = ptr.Bool(true)
        }</span>

        // Statefulset Ordinals
        // if StatefulSet Ordinals mode, buckets should be equal to replicas
        <span class="cov8" title="1">if p.Performance.StatefulsetOrdinals != nil &amp;&amp; *p.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                if p.Performance.Replicas != nil &amp;&amp; *p.Performance.Replicas &gt; 1 </span><span class="cov0" title="0">{
                        replicas := uint(*p.Performance.Replicas)
                        p.Performance.Buckets = &amp;replicas
                }</span>
        }

        // run platform specific defaulting
        <span class="cov8" title="1">if IsOpenShiftPlatform() </span><span class="cov8" title="1">{
                p.openshiftDefaulting()
        }</span>
}

func (p *Pipeline) openshiftDefaulting() <span class="cov8" title="1">{
        if p.DefaultServiceAccount == "" </span><span class="cov8" title="1">{
                p.DefaultServiceAccount = ospDefaultSA
        }</span>

        <span class="cov8" title="1">if p.DisableAffinityAssistant == nil </span><span class="cov8" title="1">{
                p.DisableAffinityAssistant = ptr.Bool(openshiftDefaultDisableAffinityAssistant)
        }</span>

        // Add params with default values if not defined by user
        <span class="cov8" title="1">var found = false
        for i, param := range p.Params </span><span class="cov0" title="0">{
                if param.Name == enableMetricsKey </span><span class="cov0" title="0">{
                        found = true
                        // If the value set is invalid then set key to default value
                        if param.Value != "false" &amp;&amp; param.Value != "true" </span><span class="cov0" title="0">{
                                p.Params[i].Value = enableMetricsDefaultValue
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                p.Params = append(p.Params, Param{
                        Name:  enableMetricsKey,
                        Value: enableMetricsDefaultValue,
                })
        }</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

const (
        PreReconciler         apis.ConditionType = "PreReconciler"
        InstallerSetAvailable apis.ConditionType = "InstallerSetAvailable"
        InstallerSetReady     apis.ConditionType = "InstallerSetReady"
        PostReconciler        apis.ConditionType = "PostReconciler"
)

var (
        // TODO: Add this back after refactoring all components
        // and updating TektonComponentStatus to have updated
        // conditions
        //_ TektonComponentStatus = (*TektonPipelineStatus)(nil)

        pipelineCondSet = apis.NewLivingConditionSet(
                PreReconciler,
                InstallerSetAvailable,
                InstallerSetReady,
                PostReconciler,
        )
)

func (tp *TektonPipeline) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonPipeline)
}</span>

func (tp *TektonPipeline) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonPipeline)
}</span>

func (tps *TektonPipelineStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return pipelineCondSet.Manage(tps).GetCondition(t)
}</span>

func (tps *TektonPipelineStatus) InitializeConditions() <span class="cov8" title="1">{
        pipelineCondSet.Manage(tps).InitializeConditions()
}</span>

func (tps *TektonPipelineStatus) IsReady() bool <span class="cov8" title="1">{
        return pipelineCondSet.Manage(tps).IsHappy()
}</span>

func (tps *TektonPipelineStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        pipelineCondSet.Manage(tps).MarkTrue(PreReconciler)
}</span>

func (tps *TektonPipelineStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        pipelineCondSet.Manage(tps).MarkTrue(InstallerSetAvailable)
}</span>

func (tps *TektonPipelineStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        pipelineCondSet.Manage(tps).MarkTrue(InstallerSetReady)
}</span>

func (tps *TektonPipelineStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        pipelineCondSet.Manage(tps).MarkTrue(PostReconciler)
}</span>

func (tps *TektonPipelineStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        pipelineCondSet.Manage(tps).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (tps *TektonPipelineStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        tps.MarkNotReady("PreReconciliation failed")
        pipelineCondSet.Manage(tps).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (tps *TektonPipelineStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov0" title="0">{
        tps.MarkNotReady("TektonInstallerSet not ready")
        pipelineCondSet.Manage(tps).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tps *TektonPipelineStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        tps.MarkNotReady("TektonInstallerSet not ready")
        pipelineCondSet.Manage(tps).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tps *TektonPipelineStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        tps.MarkNotReady("PostReconciliation failed")
        pipelineCondSet.Manage(tps).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

// TODO: below methods are not required for TektonPipeline
// but as extension implements TektonComponent we need to defined them
// this will be removed

func (tps *TektonPipelineStatus) GetTektonInstallerSet() string <span class="cov0" title="0">{
        return tps.TektonInstallerSet
}</span>

func (tps *TektonPipelineStatus) SetTektonInstallerSet(installerSet string) <span class="cov0" title="0">{
        tps.TektonInstallerSet = installerSet
}</span>

func (tps *TektonPipelineStatus) GetVersion() string <span class="cov0" title="0">{
        return tps.Version
}</span>

func (tps *TektonPipelineStatus) SetVersion(version string) <span class="cov0" title="0">{
        tps.Version = version
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// TektonPipeline is the Schema for the tektonpipelines API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonPipeline struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonPipelineSpec   `json:"spec,omitempty"`
        Status TektonPipelineStatus `json:"status,omitempty"`
}

func (tp *TektonPipeline) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tp.Spec
}</span>

func (tp *TektonPipeline) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tp.Status
}</span>

// TektonPipelineSpec defines the desired state of TektonPipeline
type TektonPipelineSpec struct {
        CommonSpec `json:",inline"`
        Pipeline   `json:",inline"`
        // Config holds the configuration for resources created by TektonPipeline
        // +optional
        Config Config `json:"config,omitempty"`
}

// TektonPipelineStatus defines the observed state of TektonPipeline
type TektonPipelineStatus struct {
        duckv1.Status `json:",inline"`
        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name for TektonPipeline
        // +optional
        TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`

        // The installer sets created for extension components
        // +optional
        ExtentionInstallerSets map[string]string `json:"extTektonInstallerSets,omitempty"`
}

// TektonPipelineList contains a list of TektonPipeline
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonPipelineList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonPipeline `json:"items"`
}

// Pipeline defines the field to customize Pipeline component
type Pipeline struct {
        PipelineProperties `json:",inline"`
        // The params to customize different components of Pipelines
        // +optional
        Params []Param `json:"params,omitempty"`
        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

// PipelineProperties defines customizable flags for Pipeline Component.
type PipelineProperties struct {
        DisableAffinityAssistant                 *bool  `json:"disable-affinity-assistant,omitempty"`
        DisableCredsInit                         *bool  `json:"disable-creds-init,omitempty"`
        AwaitSidecarReadiness                    *bool  `json:"await-sidecar-readiness,omitempty"`
        RunningInEnvironmentWithInjectedSidecars *bool  `json:"running-in-environment-with-injected-sidecars,omitempty"`
        RequireGitSshSecretKnownHosts            *bool  `json:"require-git-ssh-secret-known-hosts,omitempty"`
        EnableCustomTasks                        *bool  `json:"enable-custom-tasks,omitempty"`
        EnableApiFields                          string `json:"enable-api-fields,omitempty"`
        EmbeddedStatus                           string `json:"embedded-status,omitempty"`
        SendCloudEventsForRuns                   *bool  `json:"send-cloudevents-for-runs,omitempty"`
        // "verification-mode" is deprecated and never used.
        // This field will be removed, see https://github.com/tektoncd/operator/issues/1497
        // originally this field was removed in https://github.com/tektoncd/operator/pull/1481
        // there is no use with this field, just adding back to unblock the upgrade

        // not in use, see: https://github.com/tektoncd/pipeline/pull/7789
        // this field is removed from pipeline component
        // keeping here to maintain the API compatibility
        EnableTektonOciBundles *bool `json:"enable-tekton-oci-bundles,omitempty"`

        VerificationMode          string `json:"verification-mode,omitempty"`
        VerificationNoMatchPolicy string `json:"trusted-resources-verification-no-match-policy,omitempty"`
        EnableProvenanceInStatus  *bool  `json:"enable-provenance-in-status,omitempty"`

        // ScopeWhenExpressionsToTask is deprecated and never used.
        ScopeWhenExpressionsToTask *bool `json:"scope-when-expressions-to-task,omitempty"`

        EnforceNonfalsifiability  string `json:"enforce-nonfalsifiability,omitempty"`
        EnableKeepPodOnCancel     *bool  `json:"keep-pod-on-cancel,omitempty"`
        ResultExtractionMethod    string `json:"results-from,omitempty"`
        MaxResultSize             *int32 `json:"max-result-size,omitempty"`
        SetSecurityContext        *bool  `json:"set-security-context,omitempty"`
        Coschedule                string `json:"coschedule,omitempty"`
        EnableCELInWhenExpression *bool  `json:"enable-cel-in-whenexpression,omitempty"`
        EnableStepActions         *bool  `json:"enable-step-actions,omitempty"`
        EnableParamEnum           *bool  `json:"enable-param-enum,omitempty"`
        DisableInlineSpec         string `json:"disable-inline-spec,omitempty"`

        PipelineMetricsProperties `json:",inline"`
        // +optional
        OptionalPipelineProperties `json:",inline"`
        // +optional
        Resolvers `json:",inline"`
        // +optional
        Performance PerformanceProperties `json:"performance,omitempty"`
}

// OptionalPipelineProperties defines the fields which are to be
// defined for pipelines only if user pass them
type OptionalPipelineProperties struct {
        DefaultTimeoutMinutes               *uint  `json:"default-timeout-minutes,omitempty"`
        DefaultServiceAccount               string `json:"default-service-account,omitempty"`
        DefaultManagedByLabelValue          string `json:"default-managed-by-label-value,omitempty"`
        DefaultPodTemplate                  string `json:"default-pod-template,omitempty"`
        DefaultCloudEventsSink              string `json:"default-cloud-events-sink,omitempty"`
        DefaultAffinityAssistantPodTemplate string `json:"default-affinity-assistant-pod-template,omitempty"`
        DefaultTaskRunWorkspaceBinding      string `json:"default-task-run-workspace-binding,omitempty"`
        DefaultMaxMatrixCombinationsCount   string `json:"default-max-matrix-combinations-count,omitempty"`
        DefaultForbiddenEnv                 string `json:"default-forbidden-env,omitempty"`
        DefaultResolverType                 string `json:"default-resolver-type,omitempty"`
}

// WebhookOptions defines options for webhooks
type WebhookConfigurationOptions struct {
        FailurePolicy  *admissionregistrationv1.FailurePolicyType `json:"failurePolicy,omitempty"`
        TimeoutSeconds *int32                                     `json:"timeoutSeconds,omitempty"`
        SideEffects    *admissionregistrationv1.SideEffectClass   `json:"sideEffects,omitempty"`
}

// PipelineMetricsProperties defines the fields which are configurable for
// metrics
type PipelineMetricsProperties struct {
        MetricsTaskrunLevel            string `json:"metrics.taskrun.level,omitempty"`
        MetricsTaskrunDurationType     string `json:"metrics.taskrun.duration-type,omitempty"`
        MetricsPipelinerunLevel        string `json:"metrics.pipelinerun.level,omitempty"`
        MetricsPipelinerunDurationType string `json:"metrics.pipelinerun.duration-type,omitempty"`
        CountWithReason                *bool  `json:"metrics.count.enable-reason,omitempty"`
}

// Resolvers defines the fields to configure resolvers
type Resolvers struct {
        EnableBundlesResolver *bool `json:"enable-bundles-resolver,omitempty"`
        EnableHubResolver     *bool `json:"enable-hub-resolver,omitempty"`
        EnableGitResolver     *bool `json:"enable-git-resolver,omitempty"`
        EnableClusterResolver *bool `json:"enable-cluster-resolver,omitempty"`
        ResolversConfig       `json:",inline"`
}

// ResolversConfig defines the fields to configure each of the resolver
type ResolversConfig struct {
        BundlesResolverConfig map[string]string `json:"bundles-resolver-config,omitempty"`
        HubResolverConfig     map[string]string `json:"hub-resolver-config,omitempty"`
        GitResolverConfig     map[string]string `json:"git-resolver-config,omitempty"`
        ClusterResolverConfig map[string]string `json:"cluster-resolver-config,omitempty"`
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/config"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

var (
        validatePipelineAllowedApiFields          = sets.NewString("", config.AlphaAPIFields, config.BetaAPIFields, config.StableAPIFields)
        validatePipelineVerificationNoMatchPolicy = sets.NewString("", config.FailNoMatchPolicy, config.WarnNoMatchPolicy, config.IgnoreNoMatchPolicy)
        validatePipelineResultExtractionMethod    = sets.NewString("", config.ResultExtractionMethodTerminationMessage, config.ResultExtractionMethodSidecarLogs)
        validatePipelineEnforceNonFalsifiability  = sets.NewString("", config.EnforceNonfalsifiabilityNone, config.EnforceNonfalsifiabilityWithSpire)
        validatePipelineCoschedule                = sets.NewString("", config.CoscheduleDisabled, config.CoscheduleWorkspaces, config.CoschedulePipelineRuns, config.CoscheduleIsolatePipelineRun)
        validatePipelineInlineSpecDisable         = sets.NewString("", "pipeline", "pipelinerun", "taskrun")
)

func (tp *TektonPipeline) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{

        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if tp.GetName() != PipelineResourceName </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("metadata.name, Only one instance of TektonPipeline is allowed by name, %s", PipelineResourceName)
                errs = errs.Also(apis.ErrInvalidValue(tp.GetName(), errMsg))
        }</span>

        // execute common spec validations
        <span class="cov8" title="1">errs = errs.Also(tp.Spec.CommonSpec.validate("spec"))

        errs = errs.Also(tp.Spec.PipelineProperties.validate("spec"))

        errs = errs.Also(tp.Spec.Options.validate("spec"))

        return errs</span>
}

func (p *PipelineProperties) validate(path string) (errs *apis.FieldError) <span class="cov8" title="1">{

        if !validatePipelineAllowedApiFields.Has(p.EnableApiFields) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(p.EnableApiFields, fmt.Sprintf("%s.enable-api-fields", path)))
        }</span>

        <span class="cov8" title="1">if p.DisableInlineSpec != "" </span><span class="cov8" title="1">{
                val := strings.Split(p.DisableInlineSpec, ",")
                for _, v := range val </span><span class="cov8" title="1">{
                        if !validatePipelineInlineSpecDisable.Has(v) </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(p.DisableInlineSpec, fmt.Sprintf("%s.disable-inline-spec", path)))
                        }</span>
                }
        }

        <span class="cov8" title="1">if p.DefaultTimeoutMinutes != nil </span><span class="cov0" title="0">{
                if *p.DefaultTimeoutMinutes == 0 </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(p.DefaultTimeoutMinutes, path+".default-timeout-minutes"))
                }</span>
        }
        <span class="cov8" title="1">if p.MaxResultSize != nil </span><span class="cov0" title="0">{
                if *p.MaxResultSize &gt;= 1572864 </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(p.MaxResultSize, path+".max-result-size"))
                }</span>
        }

        // validate trusted-resources-verification-no-match-policy
        <span class="cov8" title="1">if !validatePipelineVerificationNoMatchPolicy.Has(p.VerificationNoMatchPolicy) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(p.VerificationNoMatchPolicy, fmt.Sprintf("%s.trusted-resources-verification-no-match-policy", path)))
        }</span>

        <span class="cov8" title="1">if !validatePipelineResultExtractionMethod.Has(p.ResultExtractionMethod) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(p.ResultExtractionMethod, fmt.Sprintf("%s.results-from", path)))
        }</span>

        <span class="cov8" title="1">if !validatePipelineEnforceNonFalsifiability.Has(p.EnforceNonfalsifiability) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(p.EnforceNonfalsifiability, fmt.Sprintf("%s.enforce-nonfalsifiability", path)))
        }</span>

        <span class="cov8" title="1">if !validatePipelineCoschedule.Has(p.Coschedule) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(p.Coschedule, fmt.Sprintf("%s.coschedule", path)))
        }</span>

        // validate performance properties
        <span class="cov8" title="1">errs = errs.Also(p.Performance.Validate(fmt.Sprintf("%s.performance", path)))

        return errs</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

var DefaultPrunerDisabled = true

func (tp *TektonPruner) SetDefaults(_ context.Context) <span class="cov0" title="0">{
        tp.Spec.Pruner.SetDefaults()
}</span>

func (p *Pruner) SetDefaults() <span class="cov8" title="1">{
        if p.Disabled == nil </span><span class="cov8" title="1">{
                p.Disabled = &amp;DefaultPrunerDisabled
        }</span>
        <span class="cov8" title="1">p.GlobalConfig.SetDefaults()</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

var (
        _ TektonComponentStatus = (*TektonPrunerStatus)(nil)

        condSet = apis.NewLivingConditionSet(
                DependenciesInstalled,
                PreReconciler,
                InstallerSetAvailable,
                InstallerSetReady,
                PostReconciler,
        )
)

// GroupVersionKind returns SchemeGroupVersion of a TektonPruner
func (pruner *TektonPruner) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonPruner)
}</span>

func (pruner *TektonPruner) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonPruner)
}</span>

// GetCondition returns the current condition of a given condition type
func (pruner *TektonPrunerStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return condSet.Manage(pruner).GetCondition(t)
}</span>

// InitializeConditions initializes conditions of an TektonPrunerStatus
func (pruner *TektonPrunerStatus) InitializeConditions() <span class="cov8" title="1">{
        condSet.Manage(pruner).InitializeConditions()
}</span>

// IsReady looks at the conditions returns true if they are all true.
func (pruner *TektonPrunerStatus) IsReady() bool <span class="cov8" title="1">{
        return condSet.Manage(pruner).IsHappy()
}</span>

func (pruner *TektonPrunerStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        condSet.Manage(pruner).MarkTrue(PreReconciler)
}</span>

func (pruner *TektonPrunerStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        condSet.Manage(pruner).MarkTrue(InstallerSetAvailable)
}</span>

func (pruner *TektonPrunerStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        condSet.Manage(pruner).MarkTrue(InstallerSetReady)
}</span>

func (pruner *TektonPrunerStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        condSet.Manage(pruner).MarkTrue(PostReconciler)
}</span>

// MarkDependenciesInstalled marks the DependenciesInstalled status as true.
func (pruner *TektonPrunerStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        condSet.Manage(pruner).MarkTrue(DependenciesInstalled)
}</span>

func (pruner *TektonPrunerStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        condSet.Manage(pruner).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (pruner *TektonPrunerStatus) MarkPreReconcilerFailed(msg string) <span class="cov8" title="1">{
        pruner.MarkNotReady("PreReconciliation failed")
        condSet.Manage(pruner).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (pruner *TektonPrunerStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov8" title="1">{
        pruner.MarkNotReady("TektonInstallerSet not ready")
        condSet.Manage(pruner).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (pruner *TektonPrunerStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        pruner.MarkNotReady("TektonInstallerSet not ready")
        condSet.Manage(pruner).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (pruner *TektonPrunerStatus) MarkPostReconcilerFailed(msg string) <span class="cov8" title="1">{
        pruner.MarkNotReady("PostReconciliation failed")
        condSet.Manage(pruner).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

// MarkDependencyInstalling marks the DependenciesInstalled status as false with the
// given message.
func (pruner *TektonPrunerStatus) MarkDependencyInstalling(msg string) <span class="cov8" title="1">{
        pruner.MarkNotReady("Dependencies installing")
        condSet.Manage(pruner).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency installing: %s", msg)
}</span>

// MarkDependencyMissing marks the DependenciesInstalled status as false with the
// given message.
func (pruner *TektonPrunerStatus) MarkDependencyMissing(msg string) <span class="cov8" title="1">{
        pruner.MarkNotReady("Missing Dependencies for TektonPruner")
        condSet.Manage(pruner).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency missing: %s", msg)
}</span>

func (pruner *TektonPrunerStatus) GetTektonInstallerSet() string <span class="cov0" title="0">{
        return pruner.TektonInstallerSet
}</span>

func (pruner *TektonPrunerStatus) SetTektonInstallerSet(installerSet string) <span class="cov0" title="0">{
        pruner.TektonInstallerSet = installerSet
}</span>

// GetVersion gets the currently installed version of the component.
func (pruner *TektonPrunerStatus) GetVersion() string <span class="cov0" title="0">{
        return pruner.Version
}</span>

// SetVersion sets the currently installed version of the component.
func (pruner *TektonPrunerStatus) SetVersion(version string) <span class="cov0" title="0">{
        pruner.Version = version
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/openshift-pipelines/tektoncd-pruner/pkg/config"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

var (
        _ TektonComponent     = (*TektonPruner)(nil)
        _ TektonComponentSpec = (*TektonPrunerSpec)(nil)
)

// TektonPruner is the Schema for the TektonPruner API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
// +kubebuilder:resource:scope=Cluster

type TektonPruner struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`
        Spec              TektonPrunerSpec   `json:"spec,omitempty"`
        Status            TektonPrunerStatus `json:"status,omitempty"`
}

type TektonPrunerConfig struct {
        GlobalConfig config.GlobalConfig `json:"global-config"`
}

type Pruner struct {
        // enable or disable TektonPruner Component
        Disabled           *bool `json:"disabled"`
        TektonPrunerConfig `json:",inline"`

        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

// TektonPrunerList contains a list of TektonPruner
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonPrunerList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonPruner `json:"items"`
}

type TektonPrunerSpec struct {
        CommonSpec `json:",inline"`
        Pruner     `json:",inline"`
        // Config holds the configuration for resources created by TektonPruner
        // +optional
        Config Config `json:"config,omitempty"`
}

// TektonPrunerStatus defines the observed state of TektonPruner
type TektonPrunerStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name for TektonPruner
        // +optional
        TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`
}

// GetSpec implements TektonComponent
func (tp *TektonPruner) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tp.Spec
}</span>

func (tp *TektonPruner) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tp.Status
}</span>

// IsDisabled returns true if the TektonPruner is disabled
func (p *Pruner) IsDisabled() bool <span class="cov0" title="0">{
        if p == nil || p.Disabled == nil </span><span class="cov0" title="0">{
                // When the Pruner is nil or Disabled is nil, we assume it is the default state.
                return DefaultPrunerDisabled
        }</span>
        <span class="cov0" title="0">return *p.Disabled</span>
}

func (in *TektonPrunerConfig) DeepCopyInto(out *TektonPrunerConfig) <span class="cov0" title="0">{
        *out = *in
        return
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

func (tp *TektonResult) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        // Deprecate TLSHostnameOverride
        if tp.Spec.TLSHostnameOverride != "" </span><span class="cov8" title="1">{
                tp.Spec.TLSHostnameOverride = ""
        }</span>
}

// Sets default values of Result
func (c *Result) setDefaults() <span class="cov8" title="1">{
        // Set default values for route configuration
        if c.RouteEnabled == nil </span><span class="cov8" title="1">{
                // Default to true for OpenShift platforms to automatically create routes
                enabled := IsOpenShiftPlatform()
                c.RouteEnabled = &amp;enabled
        }</span>

        <span class="cov8" title="1">if c.RouteTLSTermination == "" </span><span class="cov8" title="1">{
                c.RouteTLSTermination = "edge"
        }</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    httr://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

var (
        _              TektonComponentStatus = (*TektonResultStatus)(nil)
        resultsCondSet                       = apis.NewLivingConditionSet(
                PreReconciler,
                DependenciesInstalled,
                InstallerSetAvailable,
                InstallerSetReady,
                PostReconciler,
        )
)

// GroupVersionKind returns SchemeGroupVersion of a TektonResult
func (tr *TektonResult) GroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonResult)
}</span>

func (tr *TektonResult) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonResult)
}</span>

// GetCondition returns the current condition of a given condition type
func (trs *TektonResultStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return resultsCondSet.Manage(trs).GetCondition(t)
}</span>

// InitializeConditions initializes conditions of an TektonResultStatus
func (trs *TektonResultStatus) InitializeConditions() <span class="cov8" title="1">{
        resultsCondSet.Manage(trs).InitializeConditions()
}</span>

// IsReady looks at the conditions returns true if they are all true.
func (trs *TektonResultStatus) IsReady() bool <span class="cov8" title="1">{
        return resultsCondSet.Manage(trs).IsHappy()
}</span>

func (trs *TektonResultStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        resultsCondSet.Manage(trs).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (trs *TektonResultStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        addonsCondSet.Manage(trs).MarkTrue(PreReconciler)
}</span>

func (trs *TektonResultStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        resultsCondSet.Manage(trs).MarkTrue(InstallerSetAvailable)
}</span>

func (trs *TektonResultStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        resultsCondSet.Manage(trs).MarkTrue(InstallerSetReady)
}</span>

func (trs *TektonResultStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov0" title="0">{
        trs.MarkNotReady("TektonInstallerSet not ready")
        resultsCondSet.Manage(trs).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (trs *TektonResultStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        trs.MarkNotReady("TektonInstallerSet not ready")
        resultsCondSet.Manage(trs).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (trs *TektonResultStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        resultsCondSet.Manage(trs).MarkTrue(PostReconciler)
}</span>

// MarkDependenciesInstalled marks the DependenciesInstalled status as true.
func (trs *TektonResultStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        resultsCondSet.Manage(trs).MarkTrue(DependenciesInstalled)
}</span>

// MarkDependencyInstalling marks the DependenciesInstalled status as false with the
// given message.
func (trs *TektonResultStatus) MarkDependencyInstalling(msg string) <span class="cov0" title="0">{
        resultsCondSet.Manage(trs).MarkFalse(
                DependenciesInstalled,
                "Installing",
                "Dependency installing: %s", msg)
}</span>

// MarkDependencyMissing marks the DependenciesInstalled status as false with the
// given message.
func (trs *TektonResultStatus) MarkDependencyMissing(msg string) <span class="cov8" title="1">{
        resultsCondSet.Manage(trs).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependency missing: %s", msg)
}</span>

func (trs *TektonResultStatus) GetTektonInstallerSet() string <span class="cov0" title="0">{
        return trs.TektonInstallerSet
}</span>

func (trs *TektonResultStatus) SetTektonInstallerSet(installerSet string) <span class="cov0" title="0">{
        trs.TektonInstallerSet = installerSet
}</span>

// GetVersion gets the currently installed version of the component.
func (trs *TektonResultStatus) GetVersion() string <span class="cov0" title="0">{
        return trs.Version
}</span>

// SetVersion sets the currently installed version of the component.
func (trs *TektonResultStatus) SetVersion(version string) <span class="cov0" title="0">{
        trs.Version = version
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

var (
        _ TektonComponent     = (*TektonResult)(nil)
        _ TektonComponentSpec = (*TektonResultSpec)(nil)
)

// TektonResult is the Schema for the tektonresults API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonResult struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonResultSpec   `json:"spec,omitempty"`
        Status TektonResultStatus `json:"status,omitempty"`
}

// GetSpec implements TektonComponent
func (tp *TektonResult) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tp.Spec
}</span>

// GetStatus implements TektonComponent
func (tp *TektonResult) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tp.Status
}</span>

// TektonResultSpec defines the desired state of TektonResult
type TektonResultSpec struct {
        CommonSpec `json:",inline"`
        Result     `json:",inline"`
        // Config holds the configuration for resources created by TektonResult
        // +optional
        Config Config `json:"config,omitempty"`
}

type LokiStackProperties struct {
        LokiStackName      string `json:"loki_stack_name,omitempty"`
        LokiStackNamespace string `json:"loki_stack_namespace,omitempty"`
}

// Result defines the field to customize Result component
type Result struct {
        // enable or disable Result Component
        Disabled bool `json:"disabled"`
        // ResultsAPIProperties holds configuration properties for Result API
        ResultsAPIProperties `json:",inline"`
        // LokiStackProperties holds configuration for LokiStack
        LokiStackProperties `json:",inline"`
        // Options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
        // +optional
        Performance PerformanceProperties `json:"performance,omitempty"`
}

// ResultsAPIProperties defines the fields which are configurable for
// Results API server config
type ResultsAPIProperties struct {
        DBHost                string `json:"db_host,omitempty"`
        DBPort                *int64 `json:"db_port,omitempty"`
        DBName                string `json:"db_name,omitempty"`
        DBSSLMode             string `json:"db_sslmode,omitempty"`
        DBSSLRootCert         string `json:"db_sslrootcert,omitempty"`
        DBEnableAutoMigration *bool  `json:"db_enable_auto_migration,omitempty"`
        DBSecretName          string `json:"db_secret_name,omitempty"`
        DBSecretUserKey       string `json:"db_secret_user_key,omitempty"`
        DBSecretPasswordKey   string `json:"db_secret_password_key,omitempty"`
        ServerPort            *int64 `json:"server_port,omitempty"`
        PrometheusPort        *int64 `json:"prometheus_port,omitempty"`
        PrometheusHistogram   *bool  `json:"prometheus_histogram,omitempty"`
        LogLevel              string `json:"log_level,omitempty"`
        LogsAPI               *bool  `json:"logs_api,omitempty"`
        LogsType              string `json:"logs_type,omitempty"`
        LogsBufferSize        *int64 `json:"logs_buffer_size,omitempty"`
        LogsPath              string `json:"logs_path,omitempty"`
        TLSHostnameOverride   string `json:"tls_hostname_override,omitempty"`
        AuthDisable           *bool  `json:"auth_disable,omitempty"`
        AuthImpersonate       *bool  `json:"auth_impersonate,omitempty"`
        LoggingPVCName        string `json:"logging_pvc_name,omitempty"`
        GcsBucketName         string `json:"gcs_bucket_name,omitempty"`
        StorageEmulatorHost   string `json:"storage_emulator_host,omitempty"`
        // name of the secret used to get S3 credentials and
        // pass it as environment variables to the "tekton-results-api" deployment under "api" container
        SecretName         string `json:"secret_name,omitempty"`
        GCSCredsSecretName string `json:"gcs_creds_secret_name,omitempty"`
        GCSCredsSecretKey  string `json:"gcs_creds_secret_key,omitempty"`
        IsExternalDB       bool   `json:"is_external_db"`

        LoggingPluginTLSVerificationDisable bool   `json:"logging_plugin_tls_verification_disable,omitempty"`
        LoggingPluginProxyPath              string `json:"logging_plugin_proxy_path,omitempty"`
        LoggingPluginAPIURL                 string `json:"logging_plugin_api_url,omitempty"`
        LoggingPluginTokenPath              string `json:"logging_plugin_token_path,omitempty"`
        LoggingPluginNamespaceKey           string `json:"logging_plugin_namespace_key,omitempty"`
        LoggingPluginStaticLabels           string `json:"logging_plugin_static_labels,omitempty"`
        LoggingPluginCACert                 string `json:"logging_plugin_ca_cert,omitempty"`
        LoggingPluginForwarderDelayDuration *uint  `json:"logging_plugin_forwarder_delay_duration,omitempty"`
        LoggingPluginQueryLimit             *uint  `json:"logging_plugin_query_limit,omitempty"`
        LoggingPluginQueryParams            string `json:"logging_plugin_query_params,omitempty"`
        LoggingPluginMultipartRegex         string `json:"logging_plugin_multipart_regex,omitempty"`

        // Route configuration for Results API service exposure
        RouteEnabled *bool  `json:"route_enabled,omitempty"`
        RouteHost    string `json:"route_host,omitempty"`
        RoutePath    string `json:"route_path,omitempty"`
        // +optional
        RouteTLSTermination string `json:"route_tls_termination,omitempty"`
}

// TektonResultStatus defines the observed state of TektonResult
type TektonResultStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name for TektonResult
        // +optional
        TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`
}

func (trs *TektonResultStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        trs.MarkNotReady("PreReconciliation failed")
        resultsCondSet.Manage(trs).MarkFalse(
                PreReconciler,
                "Error",
                msg)
}</span>

func (trs *TektonResultStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        trs.MarkNotReady("PostReconciliation failed")
        resultsCondSet.Manage(trs).MarkFalse(
                PostReconciler,
                "Error",
                msg)
}</span>

// TektonResultsList contains a list of TektonResult
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonResultList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonResult `json:"items"`
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "strings"

        "knative.dev/pkg/apis"
)

const (
        LogsTypeLoki = "loki"
)

func (tp *TektonResult) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{

        if apis.IsInDelete(ctx) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if tp.GetName() != ResultResourceName </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("metadata.name, Only one instance of TektonResult is allowed by name, %s", ResultResourceName)
                return errs.Also(apis.ErrInvalidValue(tp.GetName(), errMsg))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(tp.Spec.validate("spec"))
        return errs</span>
}

func (trs *TektonResultSpec) validate(path string) (errs *apis.FieldError) <span class="cov8" title="1">{
        if trs.LokiStackName != "" </span><span class="cov0" title="0">{
                if strings.ToLower(trs.LogsType) != LogsTypeLoki &amp;&amp; trs.LogsType != "" </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("Loki stack is only supported when logs_type is loki or empty, got logs_type: %s", trs.LogsType)
                        errs = errs.Also(apis.ErrInvalidValue(trs.LogsType, fmt.Sprintf("%s.logs_type", path), errMsg))
                }</span>
                <span class="cov0" title="0">if trs.LokiStackNamespace == "" </span><span class="cov0" title="0">{
                        errMsg := "Loki stack namespace is required when loki_stack_name is provided"
                        errs = errs.Also(apis.ErrInvalidValue(trs.LokiStackNamespace, fmt.Sprintf("%s.loki_stack_namespace", path), errMsg))
                }</span>
        }

        // validate performance properties
        <span class="cov8" title="1">errs = errs.Also(trs.Performance.Validate(fmt.Sprintf("%s.performance", path)))

        return errs</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/config"
)

var (
        // DefaultOpenshiftSA is the default service account for openshift
        DefaultOpenshiftSA = "pipeline"
)

func (tt *TektonTrigger) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        tt.Spec.Trigger.setDefaults()
}</span>

func (t *Trigger) setDefaults() <span class="cov8" title="1">{
        if t.EnableApiFields == "" </span><span class="cov8" title="1">{
                t.EnableApiFields = config.DefaultEnableAPIFields
        }</span>

        // run platform specific defaulting
        <span class="cov8" title="1">if IsOpenShiftPlatform() </span><span class="cov8" title="1">{
                t.openshiftDefaulting()
        }</span>
}

func (t *Trigger) openshiftDefaulting() <span class="cov8" title="1">{
        if t.DefaultServiceAccount == "" </span><span class="cov8" title="1">{
                t.DefaultServiceAccount = DefaultOpenshiftSA
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

const (
        DependenciesInstalled apis.ConditionType = "DependenciesInstalled"
)

var (
        // TODO: Add this back after refactoring all components
        // and updating TektonComponentStatus to have updated
        // conditions
        //_ TektonComponentStatus = (*TektonTriggerStatus)(nil)

        triggersCondSet = apis.NewLivingConditionSet(
                DependenciesInstalled,
                PreReconciler,
                InstallerSetAvailable,
                InstallerSetReady,
                PostReconciler,
        )
)

func (tr *TektonTrigger) GroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(KindTektonTrigger)
}</span>

func (tr *TektonTrigger) GetGroupVersionKind() schema.GroupVersionKind <span class="cov8" title="1">{
        return SchemeGroupVersion.WithKind(KindTektonTrigger)
}</span>

func (tts *TektonTriggerStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return triggersCondSet.Manage(tts).GetCondition(t)
}</span>

func (tts *TektonTriggerStatus) InitializeConditions() <span class="cov8" title="1">{
        triggersCondSet.Manage(tts).InitializeConditions()
}</span>

func (tts *TektonTriggerStatus) IsReady() bool <span class="cov8" title="1">{
        return triggersCondSet.Manage(tts).IsHappy()
}</span>

func (tts *TektonTriggerStatus) IsNewInstallation() bool <span class="cov0" title="0">{
        return tts.Status.GetCondition(apis.ConditionReady).IsUnknown()
}</span>

func (tts *TektonTriggerStatus) MarkPreReconcilerComplete() <span class="cov8" title="1">{
        triggersCondSet.Manage(tts).MarkTrue(PreReconciler)
}</span>

func (tts *TektonTriggerStatus) MarkInstallerSetAvailable() <span class="cov8" title="1">{
        triggersCondSet.Manage(tts).MarkTrue(InstallerSetAvailable)
}</span>

func (tts *TektonTriggerStatus) MarkInstallerSetReady() <span class="cov8" title="1">{
        triggersCondSet.Manage(tts).MarkTrue(InstallerSetReady)
}</span>

func (tts *TektonTriggerStatus) MarkPostReconcilerComplete() <span class="cov8" title="1">{
        triggersCondSet.Manage(tts).MarkTrue(PostReconciler)
}</span>

func (tts *TektonTriggerStatus) MarkDependenciesInstalled() <span class="cov8" title="1">{
        triggersCondSet.Manage(tts).MarkTrue(DependenciesInstalled)
}</span>

func (tts *TektonTriggerStatus) MarkNotReady(msg string) <span class="cov8" title="1">{
        triggersCondSet.Manage(tts).MarkFalse(
                apis.ConditionReady,
                "Error",
                "Ready: %s", msg)
}</span>

func (tts *TektonTriggerStatus) MarkPreReconcilerFailed(msg string) <span class="cov0" title="0">{
        tts.MarkNotReady("PreReconciliation failed")
        triggersCondSet.Manage(tts).MarkFalse(
                PreReconciler,
                "Error",
                "PreReconciliation failed with message: %s", msg)
}</span>

func (tts *TektonTriggerStatus) MarkInstallerSetNotAvailable(msg string) <span class="cov0" title="0">{
        tts.MarkNotReady("TektonInstallerSet not ready")
        triggersCondSet.Manage(tts).MarkFalse(
                InstallerSetAvailable,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tts *TektonTriggerStatus) MarkInstallerSetNotReady(msg string) <span class="cov8" title="1">{
        tts.MarkNotReady("TektonInstallerSet not ready")
        triggersCondSet.Manage(tts).MarkFalse(
                InstallerSetReady,
                "Error",
                "Installer set not ready: %s", msg)
}</span>

func (tts *TektonTriggerStatus) MarkPostReconcilerFailed(msg string) <span class="cov0" title="0">{
        tts.MarkNotReady("PostReconciliation failed")
        triggersCondSet.Manage(tts).MarkFalse(
                PostReconciler,
                "Error",
                "PostReconciliation failed with message: %s", msg)
}</span>

func (tts *TektonTriggerStatus) MarkDependencyInstalling(msg string) <span class="cov0" title="0">{
        tts.MarkNotReady("Dependencies installing")
        triggersCondSet.Manage(tts).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependencies are installing: %s", msg)
}</span>

func (tts *TektonTriggerStatus) MarkDependencyMissing(msg string) <span class="cov0" title="0">{
        tts.MarkNotReady("Missing Dependencies for TektonTriggers")
        triggersCondSet.Manage(tts).MarkFalse(
                DependenciesInstalled,
                "Error",
                "Dependencies are missing: %s", msg)
}</span>

func (tts *TektonTriggerStatus) GetVersion() string <span class="cov0" title="0">{
        return tts.Version
}</span>

func (tts *TektonTriggerStatus) SetVersion(version string) <span class="cov0" title="0">{
        tts.Version = version
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// TektonTrigger is the Schema for the tektontriggers API
// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient:nonNamespaced
type TektonTrigger struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   TektonTriggerSpec   `json:"spec,omitempty"`
        Status TektonTriggerStatus `json:"status,omitempty"`
}

// GetSpec implements TektonComponent
func (tp *TektonTrigger) GetSpec() TektonComponentSpec <span class="cov0" title="0">{
        return &amp;tp.Spec
}</span>

// GetStatus implements TektonComponent
func (tp *TektonTrigger) GetStatus() TektonComponentStatus <span class="cov0" title="0">{
        return &amp;tp.Status
}</span>

// TektonTriggerSpec defines the desired state of TektonTrigger
type TektonTriggerSpec struct {
        CommonSpec `json:",inline"`
        Trigger    `json:",inline"`
        // Config holds the configuration for resources created by TektonTrigger
        // +optional
        Config Config `json:"config,omitempty"`
}

// TektonTriggerStatus defines the observed state of TektonTrigger
type TektonTriggerStatus struct {
        duckv1.Status `json:",inline"`

        // The version of the installed release
        // +optional
        Version string `json:"version,omitempty"`

        // The current installer set name
        // +optional
        TektonInstallerSet string `json:"tektonInstallerSet,omitempty"`
}

// TektonTriggersList contains a list of TektonTrigger
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type TektonTriggerList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TektonTrigger `json:"items"`
}

// Trigger defines the field to customize Trigger component
type Trigger struct {
        // enable or disable Trigger Component
        Disabled           bool `json:"disabled"`
        TriggersProperties `json:",inline"`
        // options holds additions fields and these fields will be updated on the manifests
        Options AdditionalOptions `json:"options"`
}

// TriggersProperties defines the fields which are to be
// defined for triggers only if user pass them
type TriggersProperties struct {
        EnableApiFields string `json:"enable-api-fields,omitempty"`
        // +optional
        OptionalTriggersProperties `json:",inline"`
}

// OptionalTriggersProperties defines the fields which are to be
// defined for triggers only if user pass them
type OptionalTriggersProperties struct {
        DefaultServiceAccount string `json:"default-service-account,omitempty"`
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "knative.dev/pkg/apis"
)

func (tr *TektonTrigger) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{

        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if tr.GetName() != TriggerResourceName </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("metadata.name,  Only one instance of TektonTrigger is allowed by name, %s", TriggerResourceName)
                errs = errs.Also(apis.ErrInvalidValue(tr.GetName(), errMsg))
        }</span>

        // execute common spec validations
        <span class="cov8" title="1">errs = errs.Also(tr.Spec.CommonSpec.validate("spec"))

        return errs.Also(tr.Spec.TriggersProperties.validate("spec"))</span>
}

func (tr *TriggersProperties) validate(path string) (errs *apis.FieldError) <span class="cov8" title="1">{

        if tr.EnableApiFields != "" </span><span class="cov8" title="1">{
                if tr.EnableApiFields != config.StableAPIFieldValue &amp;&amp; tr.EnableApiFields != config.AlphaAPIFieldValue </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(tr.EnableApiFields, path+".enable-api-fields"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "fmt"
        "sort"

        securityv1 "github.com/openshift/api/security/v1"
        sccSort "github.com/openshift/apiserver-library-go/pkg/securitycontextconstraints/util/sort"
        security "github.com/openshift/client-go/security/clientset/versioned"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/logging"
)

func GetSecurityClient(ctx context.Context) security.Interface <span class="cov0" title="0">{
        restConfig, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(err)
        }</span>
        <span class="cov0" title="0">securityClient, err := security.NewForConfig(restConfig)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(err)
        }</span>
        <span class="cov0" title="0">return securityClient</span>
}

func VerifySCCExists(ctx context.Context, sccName string, securityClient security.Interface) error <span class="cov0" title="0">{
        _, err := securityClient.SecurityV1().SecurityContextConstraints().Get(ctx, sccName, metav1.GetOptions{})
        return err
}</span>

func GetSCCRestrictiveList(ctx context.Context, securityClient security.Interface) ([]*securityv1.SecurityContextConstraints, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        sccList, err := securityClient.SecurityV1().SecurityContextConstraints().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error listing SCCs")
                return nil, err
        }</span>
        <span class="cov0" title="0">var sccPointerList []*securityv1.SecurityContextConstraints
        for i := range sccList.Items </span><span class="cov0" title="0">{
                sccPointerList = append(sccPointerList, &amp;sccList.Items[i])
        }</span>

        // This will sort the sccPointerList from most restrictive to least restrictive.
        // ByRestrictions implements the sort interface so sort.Sort() can be run on it.
        <span class="cov0" title="0">sort.Sort(sccSort.ByRestrictions(sccPointerList))

        sccLog := "SCCs sorted from most restrictive to least restrictive:"
        for _, sortedSCC := range sccPointerList </span><span class="cov0" title="0">{
                sccLog = fmt.Sprintf("%s %s", sccLog, sortedSCC.Name)
        }</span>
        <span class="cov0" title="0">logger.Info(sccLog)
        return sccPointerList, nil</span>
}

func SCCAMoreRestrictiveThanB(prioritizedSCCList []*securityv1.SecurityContextConstraints, sccA string, sccB string) (bool, error) <span class="cov8" title="1">{
        var sccAIndex, sccBIndex int
        var sccAFound, sccBFound bool
        for i, scc := range prioritizedSCCList </span><span class="cov8" title="1">{
                if scc.Name == sccA </span><span class="cov8" title="1">{
                        sccAFound = true
                        sccAIndex = i
                }</span>
                <span class="cov8" title="1">if scc.Name == sccB </span><span class="cov8" title="1">{
                        sccBFound = true
                        sccBIndex = i
                }</span>
                <span class="cov8" title="1">if sccAFound &amp;&amp; sccBFound </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if !sccAFound || !sccBFound </span><span class="cov8" title="1">{
                return false, fmt.Errorf("SCCs not found while looking up priorities, found SCC %s: %t, found SCC %s: %t", sccA, sccAFound, sccB, sccBFound)
        }</span>

        <span class="cov8" title="1">return sccAIndex &lt;= sccBIndex, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "path/filepath"
        "strings"

        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/ptr"
)

const (
        // user-provided and system CA certificates
        TrustedCAConfigMapName   = "config-trusted-cabundle"
        TrustedCAConfigMapVolume = "config-trusted-cabundle-volume"
        TrustedCAKey             = "ca-bundle.crt"

        // service serving certificates (required to talk to the internal registry)
        ServiceCAConfigMapName   = "config-service-cabundle"
        ServiceCAConfigMapVolume = "config-service-cabundle-volume"
        ServiceCAKey             = "service-ca.crt"
)

// NewVolumeWithConfigMap creates a new volume with the given ConfigMap
func NewVolumeWithConfigMap(volumeName, configMapName, configMapKey, configMapPath string) corev1.Volume <span class="cov8" title="1">{
        return corev1.Volume{
                Name: volumeName,
                VolumeSource: corev1.VolumeSource{
                        ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                LocalObjectReference: corev1.LocalObjectReference{Name: configMapName},
                                Items: []corev1.KeyToPath{
                                        {
                                                Key:  configMapKey,
                                                Path: configMapPath,
                                        },
                                },
                        },
                },
        }
}</span>

// NewVolumeWithConfigMapOptional creates a new volume with the given ConfigMap marked as optional
// This allows the pod to start even if the ConfigMap doesn't exist
func NewVolumeWithConfigMapOptional(volumeName, configMapName, configMapKey, configMapPath string) corev1.Volume <span class="cov8" title="1">{
        return corev1.Volume{
                Name: volumeName,
                VolumeSource: corev1.VolumeSource{
                        ConfigMap: &amp;corev1.ConfigMapVolumeSource{
                                LocalObjectReference: corev1.LocalObjectReference{Name: configMapName},
                                Items: []corev1.KeyToPath{
                                        {
                                                Key:  configMapKey,
                                                Path: configMapPath,
                                        },
                                },
                                Optional: ptr.Bool(true),
                        },
                },
        }
}</span>

// AddCABundleConfigMapsToVolumes adds the config-trusted-cabundle and config-service-cabundle
// ConfigMaps to the given list of volumes and removes duplicates, if any
func AddCABundleConfigMapsToVolumes(volumes []corev1.Volume) []corev1.Volume <span class="cov8" title="1">{
        // If CA bundle volumes already exists in the pod's volumes, then remove it
        for _, newVolume := range []corev1.Volume{
                NewVolumeWithConfigMap(TrustedCAConfigMapVolume, TrustedCAConfigMapName, TrustedCAKey, TrustedCAKey),
                NewVolumeWithConfigMap(ServiceCAConfigMapVolume, ServiceCAConfigMapName, ServiceCAKey, ServiceCAKey),
        } </span><span class="cov8" title="1">{
                volumes = AddOrReplaceInList(
                        volumes,
                        newVolume,
                        func(v corev1.Volume) string </span><span class="cov8" title="1">{ return v.Name }</span>,
                )
        }

        <span class="cov8" title="1">return volumes</span>
}

// AddCABundleConfigMapsToVolumesOptional adds the config-trusted-cabundle and config-service-cabundle
// ConfigMaps to the given list of volumes as optional volumes and removes duplicates, if any.
// Using optional volumes allows pods to start even when ConfigMaps don't exist, eliminating the need
// for API calls to check ConfigMap existence.
func AddCABundleConfigMapsToVolumesOptional(volumes []corev1.Volume) []corev1.Volume <span class="cov8" title="1">{
        // If CA bundle volumes already exists in the pod's volumes, then remove it
        for _, volumeName := range []string{TrustedCAConfigMapVolume, ServiceCAConfigMapVolume} </span><span class="cov8" title="1">{
                for i, v := range volumes </span><span class="cov8" title="1">{
                        if v.Name == volumeName </span><span class="cov8" title="1">{
                                volumes = append(volumes[:i], volumes[i+1:]...)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return append(
                volumes,
                NewVolumeWithConfigMapOptional(TrustedCAConfigMapVolume, TrustedCAConfigMapName, TrustedCAKey, TrustedCAKey),
                NewVolumeWithConfigMapOptional(ServiceCAConfigMapVolume, ServiceCAConfigMapName, ServiceCAKey, ServiceCAKey),
        )</span>
}

// AddCABundlesToContainerVolumes adds the CA bundles to the container via VolumeMounts.
// SSL_CERT_DIR environment variable is also set if it does not exist already.
func AddCABundlesToContainerVolumes(c *corev1.Container) <span class="cov8" title="1">{
        // We will mount the certs at /tekton-custom-certs so we don't override the existing certs
        sslCertDir := "/tekton-custom-certs"
        certEnvAvailable := false

        for _, env := range c.Env </span><span class="cov8" title="1">{
                // If SSL_CERT_DIR env var already exists, then we don't mess with
                // it and simply carry it forward as it is
                if env.Name == "SSL_CERT_DIR" </span><span class="cov8" title="1">{
                        sslCertDir = env.Value
                        certEnvAvailable = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !certEnvAvailable </span><span class="cov8" title="1">{
                // Here, we need to set the default value for SSL_CERT_DIR.
                // Keep in mind that if SSL_CERT_DIR is set, then it overrides the
                // system default, i.e. the system default directories will "NOT"
                // be scanned for certificates. This is risky and we don't want to
                // do this because users mount certificates at these locations or
                // build images with certificates "in" them and expect certificates
                // to get picked up, and rightfully so since this is the documented
                // way of achieving this.
                // So, let's keep the system wide default locations in place and
                // "append" our custom location to those.
                //
                // certDirectories copied from
                // https://golang.org/src/crypto/x509/root_linux.go
                var certDirectories = []string{
                        // Ordering is important here - we will be using the "first"
                        // element in SSL_CERT_DIR to do the volume mounts.
                        sslCertDir,           // /tekton-custom-certs
                        "/etc/ssl/certs",     // SLES10/SLES11, https://golang.org/issue/12139
                        "/etc/pki/tls/certs", // Fedora/RHEL
                }

                // SSL_CERT_DIR accepts a colon separated list of directories
                sslCertDir = strings.Join(certDirectories, ":")
                c.Env = append(c.Env, corev1.EnvVar{
                        Name:  "SSL_CERT_DIR",
                        Value: sslCertDir,
                })
        }</span>

        // We only want the first entry in SSL_CERT_DIR for the mount
        <span class="cov8" title="1">mountDir := strings.Split(sslCertDir, ":")[0]
        for _, newVolumeMount := range []corev1.VolumeMount{
                {
                        Name:      TrustedCAConfigMapVolume,
                        MountPath: filepath.Join(mountDir, TrustedCAKey),
                        SubPath:   TrustedCAKey,
                        ReadOnly:  true,
                },
                {
                        Name:      ServiceCAConfigMapVolume,
                        MountPath: filepath.Join(mountDir, ServiceCAKey),
                        SubPath:   ServiceCAKey,
                        ReadOnly:  true,
                },
        } </span><span class="cov8" title="1">{
                c.VolumeMounts = AddOrReplaceInList(
                        c.VolumeMounts,
                        newVolumeMount,
                        func(v corev1.VolumeMount) string </span><span class="cov8" title="1">{ return v.Name }</span>,
                )
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "errors"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        informer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "knative.dev/pkg/apis"
)

const (
        PipelineNotReady       = "tekton-pipelines not ready"
        PipelineNotFound       = "tekton-pipelines not installed"
        TriggerNotReady        = "tekton-triggers not ready"
        TriggerNotFound        = "tekton-triggers not installed"
        NamespaceIgnorePattern = "^(openshift|kube)-|^open-cluster-management-agent-addon$|^open-cluster-management-agent$|^dedicated-admin$|^kube-node-lease$|^kube-public$|^kube-system$"
)

func PipelineReady(informer informer.TektonPipelineInformer) (*v1alpha1.TektonPipeline, error) <span class="cov0" title="0">{
        ppln, err := getPipelineRes(informer)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, errors.New(PipelineNotFound)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if isUpgradePending(ppln.GetStatus()) </span><span class="cov0" title="0">{
                return nil, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
        }</span>
        <span class="cov0" title="0">if !ppln.Status.IsReady() </span><span class="cov0" title="0">{
                return nil, errors.New(PipelineNotReady)
        }</span>
        <span class="cov0" title="0">return ppln, nil</span>
}

// isUpgradePending checks if the component status indicates an upgrade is pending
func isUpgradePending(status v1alpha1.TektonComponentStatus) bool <span class="cov0" title="0">{
        if status == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">readyCondition := status.GetCondition(apis.ConditionReady)
        if readyCondition == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return strings.Contains(readyCondition.Message, v1alpha1.UpgradePending)</span>
}

func PipelineTargetNamspace(informer informer.TektonPipelineInformer) (string, error) <span class="cov0" title="0">{
        ppln, err := getPipelineRes(informer)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov0" title="0">return ppln.Spec.TargetNamespace, nil</span>
}

func getPipelineRes(informer informer.TektonPipelineInformer) (*v1alpha1.TektonPipeline, error) <span class="cov0" title="0">{
        res, err := informer.Lister().Get(v1alpha1.PipelineResourceName)
        return res, err
}</span>

func TriggerReady(informer informer.TektonTriggerInformer) (*v1alpha1.TektonTrigger, error) <span class="cov0" title="0">{
        trigger, err := getTriggerRes(informer)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, errors.New(TriggerNotFound)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if trigger.GetStatus() != nil &amp;&amp; strings.Contains(trigger.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                return nil, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
        }</span>
        <span class="cov0" title="0">if !trigger.Status.IsReady() </span><span class="cov0" title="0">{
                return nil, errors.New(TriggerNotReady)
        }</span>
        <span class="cov0" title="0">return trigger, nil</span>
}

func getTriggerRes(informer informer.TektonTriggerInformer) (*v1alpha1.TektonTrigger, error) <span class="cov0" title="0">{
        res, err := informer.Lister().Get(v1alpha1.TriggerResourceName)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "fmt"

        "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/client-go/kubernetes"
)

var webhookNames = map[string]string{
        v1alpha1.PipelineResourceName: "config.webhook.pipeline.tekton.dev",
        v1alpha1.TriggerResourceName:  "config.webhook.triggers.tekton.dev",
}

var webhookServiceNames = map[string]string{
        v1alpha1.PipelineResourceName: "tekton-pipelines-webhook",
        v1alpha1.TriggerResourceName:  "tekton-triggers-webhook",
}

func PreemptDeadlock(ctx context.Context, m *manifestival.Manifest, kc kubernetes.Interface, component string) error <span class="cov8" title="1">{

        // check if there are pod endpoints populated for webhhook service
        webhookServiceName, ok := webhookServiceNames[component]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no webhook service name found for component %s", component)
        }</span>
        <span class="cov8" title="1">ok, err := isWebhookEndpointsActive(ctx, m, kc, webhookServiceName)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to check webhook endpoints: %w", err)
        }</span>
        // If endpoints are active, no deadlock prevention needed
        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                return nil
        }</span>

        // If endpoints are empty, set webhook definition rules
        // to the initial state where the webhook pod can refill the rules when it comes up
        <span class="cov8" title="1">webhookName, ok := webhookNames[component]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("no webhook name found for component %s", component)
        }</span>

        <span class="cov8" title="1">err = removeValidatingWebhookRules(m, kc, webhookName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// isWebhookEndpointsActive checks if the there are valid Endpoint resources associated with a webhook service
func isWebhookEndpointsActive(ctx context.Context, m *manifestival.Manifest, kc kubernetes.Interface, svcName string) (bool, error) <span class="cov8" title="1">{
        svcResource := m.Filter(manifestival.ByKind("Service"), manifestival.ByName(svcName))
        if len(svcResource.Resources()) == 0 </span><span class="cov8" title="1">{
                return false, fmt.Errorf("service %s not found in manifest", svcName)
        }</span>
        <span class="cov8" title="1">targetNamespace := svcResource.Resources()[0].GetNamespace()
        endPoint, err := kc.CoreV1().Endpoints(targetNamespace).Get(ctx, svcName, v1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("failed to get endpoint %s in namespace %s: %w", svcName, targetNamespace, err)</span>
        }

        <span class="cov8" title="1">return len(endPoint.Subsets) &gt; 0, nil</span>
}

// removeValidatingWebhookRules remove "rules" from config.webhook.** webhook definiton(s)
func removeValidatingWebhookRules(m *manifestival.Manifest, kc kubernetes.Interface, webhookName string) error <span class="cov8" title="1">{
        cmValidationWebHookManifest := m.Filter(manifestival.ByName(webhookName))
        transformed, err := cmValidationWebHookManifest.Transform(removeWebhooks)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to transform manifest for config webhook %s: %w", webhookName, err)
        }</span>
        <span class="cov8" title="1">if err := transformed.Apply(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove webhook rules on config webhook %s: %w", webhookName, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// removeWebhooks is a Transformer function which clears our webhooks[...].rules
func removeWebhooks(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        unstructured.RemoveNestedField(u.Object, "webhooks")
        return nil
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
)

// Extension enables platform-specific features
type Extension interface {
        Transformers(v1alpha1.TektonComponent) []mf.Transformer
        PreReconcile(context.Context, v1alpha1.TektonComponent) error
        PostReconcile(context.Context, v1alpha1.TektonComponent) error
        Finalize(context.Context, v1alpha1.TektonComponent) error
}

// ExtensionGenerator creates an Extension from a Context
type ExtensionGenerator func(context.Context) Extension

// NoPlatform "generates" a NilExtension
func NoExtension(context.Context) Extension <span class="cov8" title="1">{
        return nilExtension{}
}</span>

type nilExtension struct{}

func (nilExtension) Transformers(v1alpha1.TektonComponent) []mf.Transformer <span class="cov8" title="1">{
        return nil
}</span>
func (nilExtension) PreReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov8" title="1">{
        return nil
}</span>
func (nilExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov8" title="1">{
        return nil
}</span>
func (nilExtension) Finalize(context.Context, v1alpha1.TektonComponent) error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        mfc "github.com/manifestival/client-go-client"
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "go.uber.org/zap"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const ReleaseVersionUnknown = "Unknown"

type Controller struct {
        Manifest         *mf.Manifest
        Logger           *zap.SugaredLogger
        VersionConfigMap string
}

type PayloadOptions struct {
        ReadOnly bool
}

func OperatorVersion(ctx context.Context) (string, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        operatorVersion, ok := os.LookupEnv(v1alpha1.VersionEnvKey)
        if !ok || operatorVersion == "" </span><span class="cov0" title="0">{
                logger.Errorf(v1alpha1.VERSION_ENV_NOT_SET_ERR.Error())
                return "", v1alpha1.VERSION_ENV_NOT_SET_ERR
        }</span>
        <span class="cov0" title="0">return operatorVersion, nil</span>
}

func (ctrl Controller) InitController(ctx context.Context, opts PayloadOptions) (mf.Manifest, string) <span class="cov0" title="0">{

        mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Logger.Fatalw("Error creating client from injected config", zap.Error(err))
        }</span>

        <span class="cov0" title="0">manifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient))
        if err != nil </span><span class="cov0" title="0">{
                ctrl.Logger.Fatalw("Error creating initial manifest", zap.Error(err))
        }</span>

        <span class="cov0" title="0">ctrl.Manifest = &amp;manifest
        if err := ctrl.fetchSourceManifests(ctx, opts); err != nil </span><span class="cov0" title="0">{
                ctrl.Logger.Fatalw("failed to read manifest", err)
        }</span>

        <span class="cov0" title="0">var releaseVersion string
        // Read the release version of component
        releaseVersion, err = FetchVersionFromConfigMap(manifest, ctrl.VersionConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                if IsFetchVersionError(err) </span><span class="cov0" title="0">{
                        ctrl.Logger.Warnf("failed to read version information from ConfigMap %s: %v", ctrl.VersionConfigMap, err)
                        releaseVersion = ReleaseVersionUnknown
                }</span> else<span class="cov0" title="0"> {
                        ctrl.Logger.Fatalw("Error while reading ConfigMap", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return manifest, releaseVersion</span>
}

// fetchSourceManifests mutates the passed manifest by appending one
// appropriate for the passed TektonComponent
func (ctrl Controller) fetchSourceManifests(ctx context.Context, opts PayloadOptions) error <span class="cov0" title="0">{
        component := strings.TrimSuffix(ctrl.VersionConfigMap, "-info")
        switch component </span>{
        case "pipelines":<span class="cov0" title="0">
                var pipeline *v1alpha1.TektonPipeline
                if err := AppendTarget(ctx, ctrl.Manifest, pipeline); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if strings.EqualFold(os.Getenv("DISABLE_PROXY_WEBHOOK"), "true") </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return addProxy(ctrl.Manifest)</span>
        case "triggers":<span class="cov0" title="0">
                var trigger *v1alpha1.TektonTrigger
                return AppendTarget(ctx, ctrl.Manifest, trigger)</span>
        case "dashboard":<span class="cov0" title="0">
                if opts.ReadOnly </span><span class="cov0" title="0">{
                        var dashboard v1alpha1.TektonDashboard
                        dashboard.Spec.Readonly = true
                        return AppendTarget(ctx, ctrl.Manifest, &amp;dashboard)
                }</span> else<span class="cov0" title="0"> {
                        var dashboard v1alpha1.TektonDashboard
                        dashboard.Spec.Readonly = false
                        return AppendTarget(ctx, ctrl.Manifest, &amp;dashboard)
                }</span>
        case "chains":<span class="cov0" title="0">
                var chain v1alpha1.TektonChain
                return AppendTarget(ctx, ctrl.Manifest, &amp;chain)</span>
        case "tekton-results":<span class="cov0" title="0">
                var results v1alpha1.TektonResult
                return AppendTarget(ctx, ctrl.Manifest, &amp;results)</span>
        case "pipelines-as-code":<span class="cov0" title="0">
                pacLocation := filepath.Join(os.Getenv(KoEnvKey), "tekton-addon", "pipelines-as-code")
                return AppendManifest(ctrl.Manifest, pacLocation)</span>
        case "manual-approval-gate":<span class="cov0" title="0">
                var mag v1alpha1.ManualApprovalGate
                return AppendTarget(ctx, ctrl.Manifest, &amp;mag)</span>
        case v1alpha1.TektonPrunerResourceName:<span class="cov0" title="0">
                var pruner v1alpha1.TektonPruner
                return AppendTarget(ctx, ctrl.Manifest, &amp;pruner)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func addProxy(manifest *mf.Manifest) error <span class="cov0" title="0">{
        koDataDir := os.Getenv(KoEnvKey)
        proxyLocation := filepath.Join(koDataDir, "webhook")
        return AppendManifest(manifest, proxyLocation)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "fmt"
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
)

func LabelSelector(ls metav1.LabelSelector) (string, error) <span class="cov8" title="1">{
        var (
                err error
                req *labels.Requirement
                s   []string
        )
        for k, v := range ls.MatchLabels </span><span class="cov8" title="1">{
                req, err = labels.NewRequirement(k, selection.Equals, []string{v})
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to create requirement: %w", err)
                }</span>
                <span class="cov8" title="1">s = append(s, labels.NewSelector().Add(*req).String())</span>
        }
        <span class="cov8" title="1">return strings.Join(s, ","), err</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "fmt"
        "regexp"

        utilrand "k8s.io/apimachinery/pkg/util/rand"
)

// NameGenerator generates names for objects. Some backends may have more information
// available to guide selection of new names and this interface hides those details.
type NameGenerator interface {
        // RestrictLengthWithRandomSuffix generates a valid name from the base name, adding a random suffix to the
        // base. If base is valid, the returned name must also be valid. The generator is
        // responsible for knowing the maximum valid name length.
        RestrictLengthWithRandomSuffix(base string) string

        // RestrictLength generates a valid name from the name of a step specified in a Task,
        // shortening it to the maximum valid name length if needed.
        RestrictLength(base string) string
}

// simpleNameGenerator generates random names.
type simpleNameGenerator struct{}

// SimpleNameGenerator is a generator that returns the name plus a random suffix of five alphanumerics
// when a name is requested. The string is guaranteed to not exceed the length of a standard Kubernetes
// name (63 characters)
var SimpleNameGenerator NameGenerator = simpleNameGenerator{}

const (
        // TODO: make this flexible for non-core resources with alternate naming rules.
        maxNameLength          = 63
        randomLength           = 5
        maxGeneratedNameLength = maxNameLength - randomLength - 1
)

func (simpleNameGenerator) RestrictLengthWithRandomSuffix(base string) string <span class="cov8" title="1">{
        if len(base) &gt; maxGeneratedNameLength </span><span class="cov8" title="1">{
                base = base[:maxGeneratedNameLength]
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s-%s", base, utilrand.String(randomLength))</span>
}

var alphaNumericRE = regexp.MustCompile(`^[a-zA-Z0-9]+$`)

func (simpleNameGenerator) RestrictLength(base string) string <span class="cov8" title="1">{
        if len(base) &gt; maxNameLength </span><span class="cov8" title="1">{
                base = base[:maxNameLength]
        }</span>

        <span class="cov8" title="1">for !alphaNumericRE.MatchString(base[len(base)-1:]) </span><span class="cov8" title="1">{
                base = base[:len(base)-1]
        }</span>
        <span class="cov8" title="1">return base</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import "go.uber.org/zap"

type Recorder struct {
}

func NoMetrics() (*Recorder, error) <span class="cov0" title="0">{
        return &amp;Recorder{}, nil
}</span>

func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {<span class="cov0" title="0">
        // TODO
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package common

import (
        "os"
        "sort"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// ApplyProxySettings is a transformer that propagate any proxy environment variables
// set on the operator deployment to the underlying deployment.
func ApplyProxySettings(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                // Don't do anything on something else than Deployment
                return nil
        }</span>

        <span class="cov8" title="1">var proxyEnv = []corev1.EnvVar{{
                Name:  "HTTPS_PROXY",
                Value: os.Getenv("HTTPS_PROXY"),
        }, {
                Name:  "HTTP_PROXY",
                Value: os.Getenv("HTTP_PROXY"),
        }, {
                Name:  "NO_PROXY",
                Value: os.Getenv("NO_PROXY"),
        }}

        m := u.Object
        containers, found, err := unstructured.NestedSlice(m, "spec", "template", "spec", "containers")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                // No containers in the deployment, it is weird but let's not fail
                return nil
        }</span>
        <span class="cov8" title="1">for _, c := range containers </span><span class="cov8" title="1">{
                envs, err := extractEnvs(c.(map[string]interface{}))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, e := range proxyEnv </span><span class="cov8" title="1">{
                        if e.Value == "" </span><span class="cov8" title="1">{
                                // Remove existing envvar if they are not set.
                                // This probably means the proxy configuration has been removed
                                delete(envs, e.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">envs[e.Name] = e.Value</span>
                }
                <span class="cov8" title="1">if len(envs) == 0 </span><span class="cov8" title="1">{
                        unstructured.RemoveNestedField(c.(map[string]interface{}), "env")
                }</span> else<span class="cov8" title="1"> if err := unstructured.SetNestedSlice(c.(map[string]interface{}), toUnstructured(envs), "env"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if err := unstructured.SetNestedField(m, containers, "spec", "template", "spec", "containers"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">u.SetUnstructuredContent(m)
        return nil</span>
}

func extractEnvs(uc map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        currentEnv, found, err := unstructured.NestedSlice(uc, "env")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return map[string]interface{}{}, nil
        }</span>
        <span class="cov8" title="1">envs := make(map[string]interface{}, len(currentEnv))
        for _, e := range currentEnv </span><span class="cov8" title="1">{
                em := e.(map[string]interface{})
                envs[em["name"].(string)] = em

        }</span>
        <span class="cov8" title="1">return envs, nil</span>
}

func toUnstructured(envs map[string]interface{}) []interface{} <span class="cov8" title="1">{
        newEnv := []interface{}{}
        for n, v := range envs </span><span class="cov8" title="1">{
                switch va := v.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        newEnv = append(newEnv, va)</span>
                case map[string]string:<span class="cov0" title="0">
                        newEnv = append(newEnv, va)</span>
                default:<span class="cov8" title="1">
                        newEnv = append(newEnv, map[string]interface{}{
                                "name":  n,
                                "value": va,
                        })</span>
                }
        }
        <span class="cov8" title="1">sort.Slice(newEnv, func(i, j int) bool </span><span class="cov8" title="1">{
                return newEnv[i].(map[string]interface{})["name"].(string) &lt; newEnv[j].(map[string]interface{})["name"].(string)
        }</span>)
        <span class="cov8" title="1">return newEnv</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "fmt"
        "os"
        "regexp"
        "sort"
        "strconv"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        "go.uber.org/zap"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

const (
        // cron job and service account name
        prunerCronJobName        = "tekton-resource-pruner"
        prunerServiceAccountName = "tekton-resource-pruner"

        // tkn container image via environment key
        prunerContainerImageEnvKey = "IMAGE_JOB_PRUNER_TKN"

        // namespace annotations
        pruneAnnotationSkip             = "operator.tekton.dev/prune.skip"
        pruneAnnotationSchedule         = "operator.tekton.dev/prune.schedule"
        pruneAnnotationKeep             = "operator.tekton.dev/prune.keep"
        pruneAnnotationKeepSince        = "operator.tekton.dev/prune.keep-since"
        pruneAnnotationPrunePerResource = "operator.tekton.dev/prune.prune-per-resource"
        pruneAnnotationResources        = "operator.tekton.dev/prune.resources"
        pruneAnnotationStrategy         = "operator.tekton.dev/prune.strategy"

        // labels used in resources managed by pruner
        pruneCronLabel = "tektonconfig.operator.tekton.dev/pruner"

        // prune strategy used in namespace annotation
        pruneStrategyKeep      = "keep"
        pruneStrategyKeepSince = "keep-since"

        // script to be executed inside container
        //nolint:dupword
        prunerCommand = `
        function prune() {
                namespace=$1
                flags=$2
                resources=$3
                prune_per_resource=$4
                updated_flags=$(echo $flags | tr ',' ' ')
                for resource in ${resources//,/ }; do
                        echo ""        
                        if [[ "$prune_per_resource" == "true" ]]; then
                                parent_resource=$(echo $resource | sed "s/run$//")
                                resource_names=$(tkn $parent_resource list --namespace=$namespace --no-headers --output=jsonpath={.items[*].metadata.name})
                                if [ $? -ne 0 ]; then
                                        echo "error on getting list of '$parent_resource'"
                                        error_status=1
                                        continue
                                fi
                                if [[ "$resource_names" == "" ]]; then
                                        echo "there is no '$parent_resource' available in '$namespace'"
                                        continue
                                fi
                                for resource_name in $resource_names; do
                                        echo ""
                                        target_cmd="tkn $resource delete --$parent_resource=\"$resource_name\" $updated_flags --namespace=$namespace --force"
                                        echo "\$ ${target_cmd}"
                                        eval $target_cmd
                                        if [ $? -ne 0 ]; then
                                                error_status=1
                                        fi
                                done
                        else
                                target_cmd="tkn $resource delete $updated_flags --namespace=$namespace --force"
                                echo "\$ ${target_cmd}"
                                eval $target_cmd
                                if [ $? -ne 0 ]; then
                                        error_status=1
                                fi
                        fi
                done
        }
        
        error_status=0
        for c in $*; do
                namespace=$(echo $c | cut -d ';' -f 1)
                flags=$(echo $c | cut -d ';' -f 2)
                resources=$(echo $c | cut -d ';' -f 3)
                prune_per_resource=$(echo $c | cut -d ';' -f 4)
                prune $namespace $flags $resources $prune_per_resource
        done
        exit $error_status
        `
)

var (
        // normalize resources
        pruneResourceNameMap = map[string]string{
                "pipelineruns": "pipelinerun",
                "pipelinerun":  "pipelinerun",
                "pr":           "pipelinerun",
                "taskruns":     "taskrun",
                "taskrun":      "taskrun",
                "tr":           "taskrun",
        }
)

type Pruner struct {
        tektonConfig    *v1alpha1.TektonConfig
        kubeClientset   kubernetes.Interface
        tknImage        string
        targetNamespace string
        ownerRef        metav1.OwnerReference
        logger          *zap.SugaredLogger
}

type pruneConfig struct {
        Schedule         string
        Namespace        string
        Keep             *uint
        KeepSince        *uint
        Resources        []string
        PrunePerResource bool
        TknImage         string
}

func Prune(ctx context.Context, k kubernetes.Interface, tektonConfig *v1alpha1.TektonConfig) error <span class="cov0" title="0">{
        pruner, err := getPruner(ctx, k, tektonConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return pruner.reconcile(ctx)</span>
}

func getPruner(ctx context.Context, k kubernetes.Interface, tektonConfig *v1alpha1.TektonConfig) (*Pruner, error) <span class="cov8" title="1">{
        pruner := &amp;Pruner{
                tektonConfig:    tektonConfig,
                kubeClientset:   k,
                targetNamespace: tektonConfig.Spec.TargetNamespace,
                ownerRef:        *metav1.NewControllerRef(tektonConfig, tektonConfig.GetGroupVersionKind()),
                logger:          logging.FromContext(ctx),
        }
        return pruner, nil
}</span>

func (pr *Pruner) reconcile(ctx context.Context) error <span class="cov8" title="1">{
        // get tkn cli container image name from environment
        tknImageFromEnv := os.Getenv(prunerContainerImageEnvKey)
        if tknImageFromEnv == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("tkn image '%s' environment variable is not set", prunerContainerImageEnvKey)
        }</span>
        <span class="cov8" title="1">pr.tknImage = tknImageFromEnv

        // reconcile cron jobs
        err := pr.reconcileCronJobs(ctx)
        return err</span>
}

func (pr *Pruner) getOwnerReferences() []metav1.OwnerReference <span class="cov8" title="1">{
        return []metav1.OwnerReference{pr.ownerRef}
}</span>

func (pr *Pruner) reconcileCronJobs(ctx context.Context) error <span class="cov8" title="1">{
        // group prune config by schedule cron expression
        // use schedule cron expression as map key
        // grouping by this way we can limit number of cron jobs
        // example: {"* * * * *": []{}, "*/2 * * * *": []{}}
        pruneConfigsMap := make(map[string][]pruneConfig)

        // verify prune job enabled in TektonConfig CR
        if !pr.tektonConfig.Spec.Pruner.Disabled </span><span class="cov8" title="1">{
                // collect namespace details
                namespaceList, err := pr.kubeClientset.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // ignore namespace where pipeline never configured
                <span class="cov8" title="1">ignorePattern := regexp.MustCompile(NamespaceIgnorePattern)
                for _, namespace := range namespaceList.Items </span><span class="cov8" title="1">{
                        if ignorePattern.MatchString(namespace.GetName()) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">prunerCfg := pr.getPruneConfig(&amp;namespace)
                        if prunerCfg == nil </span><span class="cov8" title="1">{
                                // prune job skipped for this namespace
                                // may be annotation skip enabled or some error on the config
                                // error details will be printed, if any
                                continue</span>
                        }

                        // add prune config into the map
                        <span class="cov8" title="1">if _, found := pruneConfigsMap[prunerCfg.Schedule]; !found </span><span class="cov8" title="1">{
                                pruneConfigsMap[prunerCfg.Schedule] = make([]pruneConfig, 0)
                        }</span>
                        <span class="cov8" title="1">configSlice := pruneConfigsMap[prunerCfg.Schedule]
                        configSlice = append(configSlice, *prunerCfg)
                        pruneConfigsMap[prunerCfg.Schedule] = configSlice</span>
                }
        }

        // compute hash for the grouped prune configurations
        <span class="cov8" title="1">computedHashMap := make(map[string]string)
        for schedule := range pruneConfigsMap </span><span class="cov8" title="1">{
                pruneConfigs := pruneConfigsMap[schedule]
                // order pruneConfigs by namespace to keep a constant hash value
                sort.SliceStable(pruneConfigs, func(i, j int) bool </span><span class="cov8" title="1">{
                        return pruneConfigs[i].Namespace &lt; pruneConfigs[j].Namespace
                }</span>)

                <span class="cov8" title="1">computedHash, err := pr.computeHash(pruneConfigs)
                if err != nil </span><span class="cov0" title="0">{
                        pr.logger.Errorw("error on computing hash value, skipping this schedule",
                                "schedule", schedule,
                                "pruneConfigs", pruneConfigs,
                                err,
                        )
                        continue</span>
                }
                <span class="cov8" title="1">computedHashMap[schedule] = computedHash</span>
        }

        // remove the existing outdated cron jobs
        <span class="cov8" title="1">cronJobsToBeCreated, err := pr.deleteOutdatedCronJobs(ctx, computedHashMap)
        if err != nil </span><span class="cov0" title="0">{
                pr.logger.Errorw("error on deleting outdated cron jobs", err)
                return err
        }</span>

        // create cron jobs that is modified [or] not exists
        <span class="cov8" title="1">pr.createCronJobs(ctx, cronJobsToBeCreated, pruneConfigsMap)

        return nil</span>
}

// to compute hash include, pruneConfigs, startingDeadlineSeconds, nodeSelector, toleration, priorityClass
func (pr *Pruner) computeHash(pruneConfigs []pruneConfig) (string, error) <span class="cov8" title="1">{
        // to compute hash additionally include, nodeSelector, tolerations, priorityClassName
        // to update cronjobs if there is a change on those fields
        targetObject := struct {
                PruneConfigs            []pruneConfig
                StartingDeadlineSeconds *int64
                NodeSelector            map[string]string
                Tolerations             []corev1.Toleration
                PriorityClassName       string
                Script                  string
        }{
                PruneConfigs:      pruneConfigs,
                NodeSelector:      pr.tektonConfig.Spec.Config.NodeSelector,
                Tolerations:       pr.tektonConfig.Spec.Config.Tolerations,
                PriorityClassName: pr.tektonConfig.Spec.Config.PriorityClassName,
                Script:            prunerCommand,
        }
        // update StartingDeadlineSeconds
        if pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds != nil </span><span class="cov8" title="1">{
                targetObject.StartingDeadlineSeconds = ptr.Int64(*pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds)
        }</span>
        <span class="cov8" title="1">return hash.Compute(targetObject)</span>
}

// update prune config from namespace annotations and global pruner config
func (pr *Pruner) getPruneConfig(namespace *corev1.Namespace) *pruneConfig <span class="cov8" title="1">{
        // create prune config and update some values from global config
        // note these values may be replaced with namespace annotations value
        defaultPruneConfig := pr.tektonConfig.Spec.Pruner
        pruneCfg := pruneConfig{
                Namespace:        namespace.GetName(),
                TknImage:         pr.tknImage,
                Schedule:         defaultPruneConfig.Schedule,
                PrunePerResource: defaultPruneConfig.PrunePerResource,
        }

        annotations := namespace.GetAnnotations()

        // asked to skip for this namespace?
        if pr.getMapString(annotations, pruneAnnotationSkip, "") == "true" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // if the global schedule is disabled and there is no prune schedule annotation present in a namespace
        // skip that namespace
        <span class="cov8" title="1">if defaultPruneConfig.Schedule == "" &amp;&amp; pr.getMapString(annotations, pruneAnnotationSchedule, "") == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // update missing values from defaults
        <span class="cov8" title="1">if defaultPruneConfig.Keep == nil &amp;&amp; defaultPruneConfig.KeepSince == nil </span><span class="cov8" title="1">{
                keep := v1alpha1.PrunerDefaultKeep
                defaultPruneConfig.Keep = &amp;keep
        }</span>
        <span class="cov8" title="1">if len(defaultPruneConfig.Resources) == 0 </span><span class="cov8" title="1">{
                defaultPruneConfig.Resources = v1alpha1.PruningDefaultResources
        }</span>

        // update keep and keep-since based on the strategy
        <span class="cov8" title="1">pruneStrategy := pr.getMapString(annotations, pruneAnnotationStrategy, "")
        // update keep value
        if pruneStrategy == pruneStrategyKeep || pruneStrategy == "" </span><span class="cov8" title="1">{
                // if value a not found on the namespace annotation, take it from global configuration
                _keep, err := pr.getMapUint(annotations, pruneAnnotationKeep, defaultPruneConfig.Keep)
                if err != nil </span><span class="cov8" title="1">{
                        pr.logger.Errorw("invalid keep value received",
                                "keepValue", pr.getMapString(annotations, pruneAnnotationKeep, ""),
                                "namespace", namespace.GetName(),
                        )
                        return nil
                }</span>
                <span class="cov8" title="1">pruneCfg.Keep = _keep</span>
        }
        // update keepSince value
        <span class="cov8" title="1">if pruneStrategy == pruneStrategyKeepSince || pruneStrategy == "" </span><span class="cov8" title="1">{
                // if value a not found on the namespace annotation, take it from global configuration
                _keepSince, err := pr.getMapUint(annotations, pruneAnnotationKeepSince, defaultPruneConfig.KeepSince)
                if err != nil </span><span class="cov8" title="1">{
                        pr.logger.Errorw("invalid keep-since value received",
                                "keepSinceValue", pr.getMapString(annotations, pruneAnnotationKeepSince, ""),
                                "namespace", namespace.GetName(),
                        )
                        return nil
                }</span>
                <span class="cov8" title="1">pruneCfg.KeepSince = _keepSince</span>
        }

        // update schedule
        <span class="cov8" title="1">pruneCfg.Schedule = pr.getMapString(annotations, pruneAnnotationSchedule, defaultPruneConfig.Schedule)

        // update resources
        resourcesString := pr.getMapString(annotations, pruneAnnotationResources, "")
        if resourcesString == "" </span><span class="cov8" title="1">{
                pruneCfg.Resources = defaultPruneConfig.Resources
        }</span> else<span class="cov8" title="1"> {
                resources := strings.Split(resourcesString, ",")
                pruneCfg.Resources = resources
        }</span>

        // update prune-per-resource, if annotation set on this namespace
        <span class="cov8" title="1">prunePerResourceString := pr.getMapString(annotations, pruneAnnotationPrunePerResource, "")
        if prunePerResourceString != "" </span><span class="cov8" title="1">{
                pruneCfg.PrunePerResource = prunePerResourceString == "true"
        }</span>

        // normalize resource values
        <span class="cov8" title="1">normalizedResources := []string{}
        for _, resource := range pruneCfg.Resources </span><span class="cov8" title="1">{
                // trim and lowercase the resource
                resource = strings.ToLower(strings.TrimSpace(resource))
                normalizedResource, found := pruneResourceNameMap[resource]
                if !found </span><span class="cov8" title="1">{
                        pr.logger.Errorw("invalid resource value received",
                                "resourceValue", resource,
                                "namespace", namespace.GetName(),
                        )
                        continue</span>
                }
                <span class="cov8" title="1">normalizedResources = append(normalizedResources, normalizedResource)</span>
        }
        <span class="cov8" title="1">pruneCfg.Resources = normalizedResources

        // if there is no resource provided, there is no meaning to proceed further
        // return nil, will not be created a cron job for this namespace
        if len(pruneCfg.Resources) == 0 </span><span class="cov8" title="1">{
                pr.logger.Warnw("there is no resource defined",
                        "namespace", namespace.GetName(),
                )
                return nil
        }</span>

        // if keep and keep-since is nil or either one is zero, skip that namespace
        <span class="cov8" title="1">if pruneCfg.Keep == nil &amp;&amp; pruneCfg.KeepSince == nil </span><span class="cov0" title="0">{
                pr.logger.Warnw("flags keep and keep-since can not be nil",
                        "namespace", namespace.GetName(),
                )
                return nil
        }</span> else<span class="cov8" title="1"> if pruneCfg.Keep != nil &amp;&amp; *pruneCfg.Keep == 0 </span><span class="cov8" title="1">{
                pr.logger.Warnw("flag keep can not be 0",
                        "namespace", namespace.GetName(),
                )
                return nil
        }</span> else<span class="cov8" title="1"> if pruneCfg.KeepSince != nil &amp;&amp; *pruneCfg.KeepSince == 0 </span><span class="cov8" title="1">{
                pr.logger.Warnw("flag keep-since can not be 0",
                        "namespace", namespace.GetName(),
                )
                return nil
        }</span>

        // sort resources to keep a constant hash value
        <span class="cov8" title="1">sort.Strings(pruneCfg.Resources)

        return &amp;pruneCfg</span>
}

func (pr *Pruner) getMapString(data map[string]string, key, defaultValue string) string <span class="cov8" title="1">{
        value, found := data[key]
        if !found </span><span class="cov8" title="1">{
                return defaultValue
        }</span>
        <span class="cov8" title="1">return strings.ToLower(strings.TrimSpace(value))</span>
}

func (pr *Pruner) getMapUint(data map[string]string, key string, defaultValue *uint) (*uint, error) <span class="cov8" title="1">{
        // break the defaultValue pointer reference
        var defaultValueCloned *uint
        if defaultValue != nil </span><span class="cov8" title="1">{
                dValue := *defaultValue
                defaultValueCloned = &amp;dValue
        }</span>

        <span class="cov8" title="1">value, found := data[key]
        if !found </span><span class="cov8" title="1">{
                return defaultValueCloned, nil
        }</span>
        <span class="cov8" title="1">uintValue, err := strconv.ParseUint(value, 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                return defaultValueCloned, err
        }</span>

        <span class="cov8" title="1">newValue := uint(uintValue)
        return &amp;newValue, nil</span>
}

// deletes absolute cron jobs and returns cron schedule to be (re)created
func (pr *Pruner) deleteOutdatedCronJobs(ctx context.Context, computedHashMap map[string]string) (map[string]string, error) <span class="cov8" title="1">{
        // filter only the jobs owned by this operator
        labelsFilter := fmt.Sprintf("%s=true", pruneCronLabel)
        cronJobs, err := pr.kubeClientset.BatchV1().CronJobs(pr.targetNamespace).List(ctx, metav1.ListOptions{LabelSelector: labelsFilter})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, cronJob := range cronJobs.Items </span><span class="cov8" title="1">{
                markedForDeletion := false
                annotations := cronJob.GetAnnotations()
                existingHash, found := annotations[v1alpha1.LastAppliedHashKey]
                if !found </span><span class="cov8" title="1">{
                        markedForDeletion = true
                }</span>

                // check existing hash availability in comptedHashMap
                <span class="cov8" title="1">if !markedForDeletion </span><span class="cov8" title="1">{
                        hasValidHash := false
                        for schedule, computedHash := range computedHashMap </span><span class="cov8" title="1">{
                                // if hash value found. cron job up to date, no action needed
                                // and remove it from the computedHashMap
                                if computedHash == existingHash </span><span class="cov8" title="1">{
                                        delete(computedHashMap, schedule)
                                        hasValidHash = true
                                        break</span>
                                }
                        }
                        // hash value not found, mark it for deletion
                        <span class="cov8" title="1">if !hasValidHash </span><span class="cov8" title="1">{
                                markedForDeletion = true
                        }</span>
                }

                <span class="cov8" title="1">if markedForDeletion </span><span class="cov8" title="1">{
                        pr.logger.Debugw("deleting an outdated cron job",
                                "name", cronJob.GetName(),
                                "schedule", cronJob.Spec.Schedule,
                        )
                        err = pr.kubeClientset.BatchV1().CronJobs(pr.targetNamespace).Delete(ctx, cronJob.GetName(), metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                pr.logger.Errorw("error on deleting an outdated cron job",
                                        "name", cronJob.GetName(),
                                        "namespace", cronJob.GetNamespace(),
                                        err,
                                )
                                continue</span>
                        }
                }
        }

        <span class="cov8" title="1">return computedHashMap, nil</span>
}

func (pr *Pruner) createCronJobs(ctx context.Context, cronJobsToBeCreated map[string]string, pruneConfigMap map[string][]pruneConfig) <span class="cov8" title="1">{
        for schedule, computedHash := range cronJobsToBeCreated </span><span class="cov8" title="1">{
                pruneConfigs, found := pruneConfigMap[schedule]
                if !found </span><span class="cov0" title="0">{
                        pr.logger.Errorw("prune schedule not found",
                                "schedule", schedule,
                        )
                        continue</span>
                }

                <span class="cov8" title="1">prunerCommandArgs := pr.generatePrunerCommandArgs(pruneConfigs)

                // create cron job
                backOffLimit := int32(1)
                failedJobsHistoryLimit := int32(2)
                successfulJobsHistoryLimit := int32(2)
                ttlSecondsAfterFinished := int32(3600)
                runAsNonRoot := true
                allowPrivilegedEscalation := false
                runAsUser := ptr.Int64(65532)
                fsGroup := ptr.Int64(65532)
                var startingDeadlineSeconds *int64

                // update startingDeadlineSeconds
                if pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds != nil </span><span class="cov8" title="1">{
                        startingDeadlineSeconds = ptr.Int64(*pr.tektonConfig.Spec.Pruner.StartingDeadlineSeconds)
                }</span>

                // if it is a openshift platform remove the user and fsGroup ids
                // those ids will be allocated dynamically
                <span class="cov8" title="1">if v1alpha1.IsOpenShiftPlatform() </span><span class="cov0" title="0">{
                        runAsUser = nil
                        fsGroup = nil
                }</span>

                <span class="cov8" title="1">cronJob := &amp;batchv1.CronJob{
                        ObjectMeta: metav1.ObjectMeta{
                                GenerateName:    fmt.Sprintf("%s-", prunerCronJobName),
                                Namespace:       pr.targetNamespace,
                                OwnerReferences: pr.getOwnerReferences(),
                                Labels:          map[string]string{v1alpha1.CreatedByKey: v1alpha1.PrunerResourceName, pruneCronLabel: "true"},
                                Annotations:     map[string]string{v1alpha1.LastAppliedHashKey: computedHash},
                        },
                        Spec: batchv1.CronJobSpec{
                                Schedule:                   schedule,
                                ConcurrencyPolicy:          batchv1.ForbidConcurrent,
                                FailedJobsHistoryLimit:     &amp;failedJobsHistoryLimit,
                                SuccessfulJobsHistoryLimit: &amp;successfulJobsHistoryLimit,
                                StartingDeadlineSeconds:    startingDeadlineSeconds,
                                JobTemplate: batchv1.JobTemplateSpec{
                                        Spec: batchv1.JobSpec{
                                                TTLSecondsAfterFinished: &amp;ttlSecondsAfterFinished,
                                                BackoffLimit:            &amp;backOffLimit,
                                                Template: corev1.PodTemplateSpec{
                                                        Spec: corev1.PodSpec{
                                                                Containers: []corev1.Container{{
                                                                        Name:                     "tkn-pruner",
                                                                        Image:                    pr.tknImage,
                                                                        Command:                  []string{"/bin/sh", "-c", prunerCommand},
                                                                        Args:                     []string{"-s", prunerCommandArgs},
                                                                        TerminationMessagePolicy: corev1.TerminationMessageFallbackToLogsOnError,
                                                                        SecurityContext: &amp;corev1.SecurityContext{
                                                                                AllowPrivilegeEscalation: &amp;allowPrivilegedEscalation,
                                                                                Capabilities: &amp;corev1.Capabilities{
                                                                                        Drop: []corev1.Capability{"ALL"},
                                                                                },
                                                                        },
                                                                }},
                                                                RestartPolicy:      corev1.RestartPolicyNever,
                                                                ServiceAccountName: prunerServiceAccountName,
                                                                NodeSelector:       pr.tektonConfig.Spec.Config.NodeSelector,
                                                                Tolerations:        pr.tektonConfig.Spec.Config.Tolerations,
                                                                PriorityClassName:  pr.tektonConfig.Spec.Config.PriorityClassName,
                                                                SecurityContext: &amp;corev1.PodSecurityContext{
                                                                        RunAsNonRoot: &amp;runAsNonRoot,
                                                                        SeccompProfile: &amp;corev1.SeccompProfile{
                                                                                Type: corev1.SeccompProfileTypeRuntimeDefault,
                                                                        },
                                                                        RunAsUser: runAsUser,
                                                                        FSGroup:   fsGroup,
                                                                },
                                                        },
                                                },
                                        },
                                },
                        },
                }

                // create a cron job
                _, err := pr.kubeClientset.BatchV1().CronJobs(pr.targetNamespace).Create(ctx, cronJob, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        pr.logger.Errorw("error on creating a cron job",
                                "name", cronJob.GetName(),
                                "namespace", cronJob.GetNamespace(),
                                err,
                        )
                }</span>
        }
}

// Generates command arguments for passing to the tkn container.
// Refer to the "prunerCommand" constant (at the top of this file) for the actual execution command.
// The command args format (multiple space-separated instances): namespace;tkn_flag_1,tkn_flag_n;resources;prunePerResource.
// NOTE: A space separates each namespace configuration, so spaces are not allowed in the namespace configuration.
//
// examples:
// ns-one;--keep=5;pipelinerun;false
//   - $ tkn pipelinerun delete --keep=5 --namespace=ns-one --force
//
// ns-two;--keep=2;taskrun;false
//   - $ tkn taskrun delete --keep=2 --namespace=ns-two --force
//
// ns-three;--keep=4,--keep-since=300;pipelinerun,taskrun;false
//   - $ tkn pipelinerun delete --keep=4 --keep-since=300 --namespace=ns-three --force
//   - $ tkn taskrun delete --keep=4 --keep-since=300 --namespace=ns-three --force
//
// ns-four;--keep=4;pipelinerun,taskrun;true  &lt;= note the "true" - prunePerResource
// resource names will be taken dynamically on the script
//   - $ tkn pipelinerun delete --pipeline="pipeline-one" --keep=5 --namespace=ns-four --force
//   - $ tkn taskrun delete --task="task-one" --keep=5 --namespace=ns-four --force
func (pr *Pruner) generatePrunerCommandArgs(pruneConfigs []pruneConfig) string <span class="cov8" title="1">{
        commands := []string{}
        for _, pruneCfg := range pruneConfigs </span><span class="cov8" title="1">{
                tknFlagsSlice := []string{}
                if pruneCfg.Keep != nil &amp;&amp; *pruneCfg.Keep != 0 </span><span class="cov8" title="1">{
                        tknFlagsSlice = append(tknFlagsSlice, fmt.Sprintf("--keep=%d", *pruneCfg.Keep))
                }</span>
                <span class="cov8" title="1">if pruneCfg.KeepSince != nil &amp;&amp; *pruneCfg.KeepSince != 0 </span><span class="cov8" title="1">{
                        tknFlagsSlice = append(tknFlagsSlice, fmt.Sprintf("--keep-since=%d", *pruneCfg.KeepSince))
                }</span>

                <span class="cov8" title="1">tnkFlags := strings.Join(tknFlagsSlice, ",")
                resources := strings.Join(pruneCfg.Resources, ",")

                commands = append(commands,
                        fmt.Sprintf(
                                "%s;%s;%s;%t",
                                pruneCfg.Namespace, tnkFlags, resources, pruneCfg.PrunePerResource,
                        ),
                )</span>
        }

        // create space separated group of commands
        <span class="cov8" title="1">return strings.Join(commands, " ")</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "fmt"
        "os"
        "path"
        "path/filepath"
        "sort"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "golang.org/x/mod/semver"
)

const (
        // KoEnvKey is the key of the environment variable to specify the path to the ko data directory
        KoEnvKey = "KO_DATA_PATH"
        // COMMA is the character comma
        COMMA = ","
)

var cache = map[string]mf.Manifest{}
var cacheRecursive = map[string]mf.Manifest{}

// TargetVersion returns the version of the manifest to be installed
// per the spec in the component. If spec.version is empty, the latest
// version known to the operator is returned.
func TargetVersion(instance v1alpha1.TektonComponent) string <span class="cov8" title="1">{
        return latestRelease(instance)
}</span>

// TargetManifest returns the manifest for the TargetVersion
func TargetManifest(instance v1alpha1.TektonComponent) (mf.Manifest, error) <span class="cov0" title="0">{
        return FetchRecursive(manifestPath(TargetVersion(instance), instance))
}</span>

// fetchWithCache is a generic function to fetch manifest with caching
func fetchWithCache(path string, cache map[string]mf.Manifest, fetchFn func(string) (mf.Manifest, error)) (mf.Manifest, error) <span class="cov8" title="1">{
        if m, ok := cache[path]; ok </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov8" title="1">result, err := fetchFn(path)
        if err == nil </span><span class="cov8" title="1">{
                cache[path] = result
        }</span>
        <span class="cov8" title="1">return result, err</span>
}

// Fetch returns a manifest from the given path only, not recursively
func Fetch(path string) (mf.Manifest, error) <span class="cov8" title="1">{
        return fetchWithCache(path, cache, func(p string) (mf.Manifest, error) </span><span class="cov8" title="1">{
                return mf.NewManifest(p)
        }</span>)
}

// FetchRecursive returns a manifest from the given path recursively
func FetchRecursive(path string) (mf.Manifest, error) <span class="cov8" title="1">{
        return fetchWithCache(path, cacheRecursive, func(p string) (mf.Manifest, error) </span><span class="cov8" title="1">{
                return mf.ManifestFrom(mf.Recursive(p))
        }</span>)
}

func ComponentDir(instance v1alpha1.TektonComponent) string <span class="cov8" title="1">{
        koDataDir := ComponentBaseDir()
        switch ins := instance.(type) </span>{
        case *v1alpha1.TektonPipeline:<span class="cov0" title="0">
                return filepath.Join(koDataDir, "tekton-pipeline")</span>
        case *v1alpha1.TektonTrigger:<span class="cov8" title="1">
                return filepath.Join(koDataDir, "tekton-trigger")</span>
        case *v1alpha1.TektonDashboard:<span class="cov0" title="0">
                if ins.Spec.Readonly </span><span class="cov0" title="0">{
                        return filepath.Join(koDataDir, "tekton-dashboard/tekton-dashboard-readonly")
                }</span>
                <span class="cov0" title="0">return filepath.Join(koDataDir, "tekton-dashboard/tekton-dashboard-fullaccess")</span>
        case *v1alpha1.TektonAddon:<span class="cov0" title="0">
                return filepath.Join(koDataDir, "tekton-addon")</span>
        case *v1alpha1.TektonConfig:<span class="cov0" title="0">
                return filepath.Join(koDataDir, "tekton-config")</span>
        case *v1alpha1.TektonResult:<span class="cov0" title="0">
                return filepath.Join(koDataDir, "tekton-results")</span>
        case *v1alpha1.TektonHub:<span class="cov0" title="0">
                return filepath.Join(koDataDir, "tekton-hub")</span>
        case *v1alpha1.TektonChain:<span class="cov0" title="0">
                return filepath.Join(koDataDir, "tekton-chains")</span>
        case *v1alpha1.ManualApprovalGate:<span class="cov0" title="0">
                return filepath.Join(koDataDir, "manual-approval-gate")</span>
        case *v1alpha1.TektonPruner:<span class="cov8" title="1">
                return filepath.Join(koDataDir, v1alpha1.TektonPrunerResourceName)</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func ComponentBaseDir() string <span class="cov8" title="1">{
        return os.Getenv(KoEnvKey)
}</span>

func manifestPath(version string, instance v1alpha1.TektonComponent) string <span class="cov0" title="0">{
        if !semver.IsValid(sanitizeSemver(version)) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">localPath := filepath.Join(ComponentDir(instance), version)
        if _, err := os.Stat(localPath); !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return localPath
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// sanitizeSemver always adds `v` in front of the version.
// x.y.z is the standard format we use as the semantic version for Knative. The letter `v` is added for
// comparison purpose.
func sanitizeSemver(version string) string <span class="cov8" title="1">{
        return fmt.Sprintf("v%s", version)
}</span>

// allReleases returns the all the available release versions
// available under kodata directory for Knative component.
func allReleases(instance v1alpha1.TektonComponent) ([]string, error) <span class="cov8" title="1">{
        // List all the directories available under kodata
        pathname := ComponentDir(instance)
        fileList, err := os.ReadDir(pathname)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">releaseTags := make([]string, 0, len(fileList))
        for _, file := range fileList </span><span class="cov8" title="1">{
                name := path.Join(pathname, file.Name())
                pathDirOrFile, err := os.Stat(name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if pathDirOrFile.IsDir() </span><span class="cov8" title="1">{
                        releaseTags = append(releaseTags, file.Name())
                }</span>
        }
        <span class="cov8" title="1">if len(releaseTags) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to find any version number for %v", instance)
        }</span>

        // This function makes sure the versions are sorted in a descending order.
        <span class="cov8" title="1">sort.Slice(releaseTags, func(i, j int) bool </span><span class="cov8" title="1">{
                // The index i is the one after the index j. If i is more recent than j, return true to swap.
                return semver.Compare(sanitizeSemver(releaseTags[i]), sanitizeSemver(releaseTags[j])) == 1
        }</span>)

        <span class="cov8" title="1">return releaseTags, nil</span>
}

// latestRelease returns the latest release tag available under kodata directory for Knative component.
func latestRelease(instance v1alpha1.TektonComponent) string <span class="cov8" title="1">{
        vers, err := allReleases(instance)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // The versions are in a descending order, so the first one will be the latest version.
        <span class="cov8" title="1">return vers[0]</span>
}

func AppendManifest(manifest *mf.Manifest, yamlLocation string) error <span class="cov8" title="1">{
        m, err := mf.ManifestFrom(mf.Recursive(yamlLocation))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*manifest = manifest.Append(m)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "knative.dev/pkg/logging"
)

// Stage represents a step in the reconcile process
type Stage func(context.Context, *mf.Manifest, v1alpha1.TektonComponent) error

// Stages are a list of steps
type Stages []Stage

// Execute each stage in sequence until one returns an error
func (stages Stages) Execute(ctx context.Context, manifest *mf.Manifest, instance v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        for _, stage := range stages </span><span class="cov0" title="0">{
                if err := stage(ctx, manifest, instance); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// NoOp does nothing
func NoOp(context.Context, *mf.Manifest, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>

// AppendTarget mutates the passed manifest by appending one
// appropriate for the passed TektonComponent
func AppendTarget(ctx context.Context, manifest *mf.Manifest, instance v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        m, err := TargetManifest(instance)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*manifest = manifest.Append(m)
        return nil</span>
}

// ManifestFetcher returns a manifest appropriate for the instance
type ManifestFetcher func(ctx context.Context, instance v1alpha1.TektonComponent) (*mf.Manifest, error)

// DeleteObsoleteResources returns a Stage after calculating the
// installed manifest from the instance. This is meant to be called
// *before* executing the reconciliation stages so that the proper
// manifest is captured in a closure before any stage might mutate the
// instance status, e.g. Install.
func DeleteObsoleteResources(ctx context.Context, instance v1alpha1.TektonComponent, fetch ManifestFetcher) Stage <span class="cov8" title="1">{
        if TargetVersion(instance) == instance.GetStatus().GetVersion() </span><span class="cov0" title="0">{
                return NoOp
        }</span>
        <span class="cov8" title="1">logger := logging.FromContext(ctx)
        installed, err := fetch(ctx, instance)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Unable to obtain the installed manifest; obsolete resources may linger", err)
                return NoOp
        }</span>
        <span class="cov8" title="1">return func(_ context.Context, manifest *mf.Manifest, _ v1alpha1.TektonComponent) error </span><span class="cov8" title="1">{
                return installed.Filter(mf.NoCRDs, mf.Not(mf.In(*manifest))).Delete()
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "fmt"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/logging"
)

const (
        labelKeyTargetNamespace = "operator.tekton.dev/targetNamespace"
)

func ReconcileTargetNamespace(ctx context.Context, labels map[string]string, annotations map[string]string, tektonComponent v1alpha1.TektonComponent, kubeClientSet kubernetes.Interface) error <span class="cov8" title="1">{
        // get logger
        logger := logging.FromContext(ctx)

        logger.Debugw("reconciling target namespace",
                "targetNamespace", tektonComponent.GetSpec().GetTargetNamespace(),
        )

        // ensure only one namespace with the specified targetNamespace label
        nsList, err := kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{LabelSelector: fmt.Sprintf("%s=true", labelKeyTargetNamespace)})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("error on listing namespaces",
                        "targetNamespace", tektonComponent.GetSpec().GetTargetNamespace(),
                        err,
                )
                return err
        }</span>

        <span class="cov8" title="1">var targetNamespace *corev1.Namespace
        namespaceDeletionInProgress := false
        for _, namespace := range nsList.Items </span><span class="cov8" title="1">{
                if namespace.Name == tektonComponent.GetSpec().GetTargetNamespace() &amp;&amp; namespace.DeletionTimestamp == nil </span><span class="cov8" title="1">{
                        _targetNamespace := namespace.DeepCopy()
                        targetNamespace = _targetNamespace
                }</span> else<span class="cov8" title="1"> if len(namespace.GetOwnerReferences()) &gt; 0 </span><span class="cov8" title="1">{
                        // delete irrelevant namespaces if the owner is the same component
                        // if deletionTimestamp is not nil, that indicates, the namespace is in deletion state
                        ownerReferenceName := namespace.GetOwnerReferences()[0].Name
                        if namespace.DeletionTimestamp == nil &amp;&amp; ownerReferenceName == tektonComponent.GetName() </span><span class="cov8" title="1">{
                                if err := kubeClientSet.CoreV1().Namespaces().Delete(ctx, namespace.Name, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorw("error on deleting a namespace",
                                                "namespace", namespace.Name,
                                                err,
                                        )
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">if namespace.DeletionTimestamp != nil </span><span class="cov8" title="1">{
                                logger.Debugf("'%v' namespace is in deletion state", namespace.Name)
                                namespaceDeletionInProgress = true
                        }</span>
                } else<span class="cov8" title="1"> {
                        logger.Infof("'%v' namespace is not owned by any component", namespace.Name)
                }</span>
        }

        // if some of the namespaces are in deletion state, requeue and try again on next reconcile cycle
        <span class="cov8" title="1">if namespaceDeletionInProgress </span><span class="cov8" title="1">{
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>

        // verify the target namespace exists, now get with targetNamespace name
        <span class="cov8" title="1">if targetNamespace == nil </span><span class="cov8" title="1">{
                _targetNamespace, err := kubeClientSet.CoreV1().Namespaces().Get(ctx, tektonComponent.GetSpec().GetTargetNamespace(), metav1.GetOptions{})
                if err == nil </span><span class="cov8" title="1">{
                        if _targetNamespace.DeletionTimestamp != nil </span><span class="cov8" title="1">{
                                logger.Infof("'%v' namespace is in deletion state", tektonComponent.GetSpec().GetTargetNamespace())
                                return v1alpha1.REQUEUE_EVENT_AFTER
                        }</span>
                        <span class="cov8" title="1">targetNamespace = _targetNamespace</span>
                } else<span class="cov8" title="1"> if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // owner reference used for target namespace
        <span class="cov8" title="1">ownerRef := *metav1.NewControllerRef(tektonComponent, tektonComponent.GroupVersionKind())

        // update required labels
        if labels == nil </span><span class="cov8" title="1">{
                labels = map[string]string{}
        }</span>

        // update required annotations
        <span class="cov8" title="1">if annotations == nil </span><span class="cov8" title="1">{
                annotations = map[string]string{}
        }</span>

        <span class="cov8" title="1">labels[labelKeyTargetNamespace] = "true" // include target namespace label

        // if a namespace found, update the required fields
        if targetNamespace != nil </span><span class="cov8" title="1">{
                // initialize labels and annotations
                if targetNamespace.Labels == nil </span><span class="cov8" title="1">{
                        targetNamespace.Labels = map[string]string{}
                }</span>
                <span class="cov8" title="1">if targetNamespace.Annotations == nil </span><span class="cov8" title="1">{
                        targetNamespace.Annotations = map[string]string{}
                }</span>

                // verify the existing namespace has the required fields, if not update
                <span class="cov8" title="1">updateRequired := false

                // update owner reference, if no one is owned
                if len(targetNamespace.GetOwnerReferences()) == 0 </span><span class="cov8" title="1">{
                        targetNamespace.OwnerReferences = []metav1.OwnerReference{ownerRef}
                        updateRequired = true
                }</span>

                // update labels
                <span class="cov8" title="1">for expectedKey, expectedValue := range labels </span><span class="cov8" title="1">{
                        found := false
                        for actualKey, actualValue := range targetNamespace.GetLabels() </span><span class="cov8" title="1">{
                                if expectedKey == actualKey &amp;&amp; expectedValue == actualValue </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        // update label if not found
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                targetNamespace.Labels[expectedKey] = expectedValue
                                updateRequired = true
                        }</span>
                }

                // include annotations from targetNamespaceMetadata
                <span class="cov8" title="1">for expectedKey, expectedValue := range annotations </span><span class="cov8" title="1">{
                        found := false
                        for actualKey, actualValue := range targetNamespace.GetAnnotations() </span><span class="cov8" title="1">{
                                if expectedKey == actualKey &amp;&amp; expectedValue == actualValue </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        // update annotation if not found
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                targetNamespace.Annotations[expectedKey] = expectedValue
                                updateRequired = true
                        }</span>
                }

                // update the namespace, if required
                <span class="cov8" title="1">if updateRequired </span><span class="cov8" title="1">{
                        _, err = kubeClientSet.CoreV1().Namespaces().Update(ctx, targetNamespace, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("error on updating target namespace",
                                        "targetNamespace", tektonComponent.GetSpec().GetTargetNamespace(),
                                        err,
                                )
                        }</span>
                        <span class="cov8" title="1">return err</span>
                }

        } else<span class="cov8" title="1"> {
                // create target namespace
                namespace := &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:            tektonComponent.GetSpec().GetTargetNamespace(),
                                Labels:          labels,
                                Annotations:     annotations,
                                OwnerReferences: []metav1.OwnerReference{ownerRef},
                        },
                }

                if _, err := kubeClientSet.CoreV1().Namespaces().Create(ctx, namespace, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("error on creating target namespace",
                                "targetNamespace", tektonComponent.GetSpec().GetTargetNamespace(),
                                err,
                        )
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type DefaultInstaller struct {
        Labels          map[string]string
        Annotations     map[string]string
        OwnerReferences []metav1.OwnerReference
        Manifest        mf.Manifest
}

// GetLabels :- Get all the labels
func (di *DefaultInstaller) GetLabels(ctx context.Context) map[string]string <span class="cov8" title="1">{
        return di.Labels
}</span>

// GetAnnotations :- Get all the annotations
func (di *DefaultInstaller) GetAnnotations(ctx context.Context) map[string]string <span class="cov8" title="1">{
        return di.Annotations
}</span>

// GetOwnerReferences :- Get the owner references
func (di *DefaultInstaller) GetOwnerReferences(ctx context.Context) []metav1.OwnerReference <span class="cov8" title="1">{
        return di.OwnerReferences
}</span>

// GetManifest :- Get the manifest
func (di *DefaultInstaller) GetManifest(ctx context.Context) (*mf.Manifest, error) <span class="cov8" title="1">{
        return &amp;di.Manifest, nil
}</span>

func (di *DefaultInstaller) AddLabelKeyVal(key, val string) <span class="cov8" title="1">{
        di.Labels[key] = val
}</span>

func (di *DefaultInstaller) AddLabelsFromMap(labels map[string]string) <span class="cov8" title="1">{
        for k, v := range labels </span><span class="cov8" title="1">{
                di.AddLabelKeyVal(k, v)
        }</span>
}

func (di *DefaultInstaller) AddAnnotationsKeyVal(key, val string) <span class="cov8" title="1">{
        di.Annotations[key] = val
}</span>

func (di *DefaultInstaller) AddAnnotationsFromMap(annotations map[string]string) <span class="cov8" title="1">{
        for k, v := range annotations </span><span class="cov8" title="1">{
                di.AddAnnotationsKeyVal(k, v)
        }</span>
}

func (di *DefaultInstaller) AddOwnerReferences(ownerRef metav1.OwnerReference) <span class="cov8" title="1">{
        di.OwnerReferences = append(di.OwnerReferences, ownerRef)
}</span>

func (di *DefaultInstaller) AddManifest(manifest mf.Manifest) <span class="cov8" title="1">{
        di.Manifest = di.Manifest.Append(manifest)
}</span>

func (di *DefaultInstaller) AddTypeLabel(val string) <span class="cov0" title="0">{
        di.AddLabelKeyVal(v1alpha1.InstallerSetType, val)
}</span>

func (di *DefaultInstaller) AddCreatedByLabel(val string) <span class="cov0" title="0">{
        di.AddLabelKeyVal(v1alpha1.CreatedByKey, val)
}</span>

func (di *DefaultInstaller) AddReleaseVersionLabel(val string) <span class="cov0" title="0">{
        di.AddLabelKeyVal(v1alpha1.ReleaseVersionKey, val)
}</span>

func NewDefaultInstaller() *DefaultInstaller <span class="cov8" title="1">{
        return &amp;DefaultInstaller{
                Labels:          map[string]string{},
                Annotations:     map[string]string{},
                OwnerReferences: []metav1.OwnerReference{},
                Manifest:        mf.Manifest{},
        }
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package testing

import (
        "fmt"
        "reflect"
        "testing"

        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes/scheme"

        appsv1 "k8s.io/api/apps/v1"
)

func MakeDeployment(name string, podSpec corev1.PodSpec) *appsv1.Deployment <span class="cov0" title="0">{
        return &amp;appsv1.Deployment{
                TypeMeta: metav1.TypeMeta{
                        Kind: "Deployment",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: appsv1.DeploymentSpec{
                        Template: corev1.PodTemplateSpec{
                                Spec: podSpec,
                        },
                },
        }
}</span>

func MakeDaemonSet(name string, podSpec corev1.PodSpec) *appsv1.DaemonSet <span class="cov0" title="0">{
        return &amp;appsv1.DaemonSet{
                TypeMeta: metav1.TypeMeta{
                        Kind: "DaemonSet",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name: name,
                },
                Spec: appsv1.DaemonSetSpec{
                        Template: corev1.PodTemplateSpec{
                                Spec: podSpec,
                        },
                },
        }
}</span>

func MakeUnstructured(t *testing.T, obj interface{}) unstructured.Unstructured <span class="cov0" title="0">{
        t.Helper()
        var result = unstructured.Unstructured{}
        err := scheme.Scheme.Convert(obj, &amp;result, nil)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Could not create unstructured object: %v, err: %v", result, err)
        }</span>
        <span class="cov0" title="0">return result</span>
}

func AssertEqual(t *testing.T, actual, expected interface{}) <span class="cov0" title="0">{
        t.Helper()
        if actual == expected </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.Fatalf("expected does not equal actual. \nExpected: %v\nActual: %v", expected, actual)</span>
}

func AssertNotEqual(t *testing.T, actual, expected interface{}) <span class="cov0" title="0">{
        t.Helper()
        if actual != expected </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.Fatalf("expected equal actual. \nExpected: %v\nActual: %v", expected, actual)</span>
}

func AssertDeepEqual(t *testing.T, actual, expected interface{}) <span class="cov0" title="0">{
        t.Helper()
        if reflect.DeepEqual(actual, expected) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">t.Fatalf("expected does not deep equal actual. \nExpected: %T %+v\nActual:   %T %+v", expected, expected, actual, actual)</span>
}

func AssertNoError(t *testing.T, err error) <span class="cov0" title="0">{
        t.Helper()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("expected no error, error: %q", err)
        }</span>
}

// PrintWantGot takes a diff string generated by cmp.Diff and returns it
// in a consistent format for reuse across all of our tests. This
// func assumes that the order of arguments passed to cmp.Diff was
// (want, got) or, in other words, the expectedResult then the actualResult.
func PrintWantGot(diff string) string <span class="cov0" title="0">{
        return fmt.Sprintf("(-want, +got): %s", diff)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        "go.uber.org/zap"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        apimachineryRuntime "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

const (
        KindConfigMap                      = "ConfigMap"
        KindDeployment                     = "Deployment"
        KindStatefulSet                    = "StatefulSet"
        KindHorizontalPodAutoscaler        = "HorizontalPodAutoscaler"
        KindValidatingWebhookConfiguration = "ValidatingWebhookConfiguration"
        KindMutatingWebhookConfiguration   = "MutatingWebhookConfiguration"
)

type OptionsTransformer struct {
        options v1alpha1.AdditionalOptions
        logger  *zap.SugaredLogger
}

func ExecuteAdditionalOptionsTransformer(ctx context.Context, manifest *mf.Manifest, targetNamespace string, additionalOptions v1alpha1.AdditionalOptions) error <span class="cov8" title="1">{
        ot := &amp;OptionsTransformer{
                options: additionalOptions,
                logger:  logging.FromContext(ctx),
        }

        if additionalOptions.Disabled != nil &amp;&amp; *additionalOptions.Disabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        // execute transformer
        <span class="cov8" title="1">finalManifest, err := manifest.Transform(ot.transform)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*manifest = finalManifest

        // create config map, if not found in the existing manifest
        extraConfigMaps, err := ot.createConfigMaps(manifest, targetNamespace, additionalOptions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // update into the manifests
        <span class="cov8" title="1">if err = ot.addInToManifest(manifest, extraConfigMaps); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // create HorizontalPodAutoscaler, if not found in the existing manifest
        <span class="cov8" title="1">extraHPAs, err := ot.createHorizontalPodAutoscalers(manifest, targetNamespace, additionalOptions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // update into the manifests
        <span class="cov8" title="1">if err = ot.addInToManifest(manifest, extraHPAs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (ot *OptionsTransformer) addInToManifest(manifest *mf.Manifest, additionalResources []unstructured.Unstructured) error <span class="cov8" title="1">{
        if len(additionalResources) &gt; 0 </span><span class="cov8" title="1">{
                additionalManifest, err := mf.ManifestFrom(mf.Slice(additionalResources))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*manifest = manifest.Append(additionalManifest)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ot *OptionsTransformer) transform(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        switch u.GetKind() </span>{
        case KindConfigMap:<span class="cov8" title="1">
                return ot.updateConfigMaps(u)</span>

        case KindDeployment:<span class="cov8" title="1">
                err := ot.updateDeployments(u)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // update deployment hash value in to template labels
                // this will recreate the pods, if there is a change detected in deployment.spec
                <span class="cov8" title="1">return ot.updateDeploymentHashValue(u)</span>

        case KindStatefulSet:<span class="cov8" title="1">
                return ot.updateStatefulSets(u)</span>

        case KindHorizontalPodAutoscaler:<span class="cov8" title="1">
                return ot.updateHorizontalPodAutoscalers(u)</span>

        case KindValidatingWebhookConfiguration, KindMutatingWebhookConfiguration:<span class="cov8" title="1">
                return ot.updateWebhookConfiguration(u)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (ot *OptionsTransformer) updateLabels(u *unstructured.Unstructured, labels map[string]string) error <span class="cov8" title="1">{
        return ot.updateMapField(u, labels, "metadata", "labels")
}</span>

func (ot *OptionsTransformer) updateAnnotations(u *unstructured.Unstructured, annotations map[string]string) error <span class="cov8" title="1">{
        return ot.updateMapField(u, annotations, "metadata", "annotations")
}</span>

func (ot *OptionsTransformer) updateMapField(u *unstructured.Unstructured, extraData map[string]string, locationKey ...string) error <span class="cov8" title="1">{
        if len(extraData) == 0 || len(locationKey) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // get source map data
        <span class="cov8" title="1">sourceData, _, err := unstructured.NestedMap(u.Object, locationKey...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if sourceData == nil </span><span class="cov8" title="1">{
                sourceData = make(map[string]interface{})
        }</span>

        // update source map data
        <span class="cov8" title="1">for key, value := range extraData </span><span class="cov8" title="1">{
                sourceData[key] = value
        }</span>

        // update source map data into the target object
        <span class="cov8" title="1">unstructured.RemoveNestedField(u.Object, locationKey...)
        return unstructured.SetNestedMap(u.Object, sourceData, locationKey...)</span>
}

func (ot *OptionsTransformer) updateConfigMaps(u *unstructured.Unstructured) error <span class="cov8" title="1">{

        optionsConfigMap, found := ot.options.ConfigMaps[u.GetName()]
        if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        // update labels
        <span class="cov8" title="1">err := ot.updateLabels(u, optionsConfigMap.Labels)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update annotations
        <span class="cov8" title="1">err = ot.updateAnnotations(u, optionsConfigMap.Annotations)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // convert unstructured object to configMap
        <span class="cov8" title="1">targetConfigMap := &amp;corev1.ConfigMap{}
        err = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update data part of the target config map
        <span class="cov8" title="1">for dataKey, newValue := range optionsConfigMap.Data </span><span class="cov8" title="1">{
                targetConfigMap.Data[dataKey] = newValue
        }</span>

        // convert configMap to unstructured object
        <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetConfigMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.SetUnstructuredContent(obj)

        return nil</span>
}

func (ot *OptionsTransformer) createConfigMaps(manifest *mf.Manifest, targetNamespace string, additionalOptions v1alpha1.AdditionalOptions) ([]unstructured.Unstructured, error) <span class="cov8" title="1">{
        extraConfigMaps := []unstructured.Unstructured{}
        existingConfigMaps := manifest.Filter(mf.Any(mf.ByKind(KindConfigMap)))
        for configMapName, providedConfigMap := range additionalOptions.ConfigMaps </span><span class="cov8" title="1">{
                found := false
                for _, resource := range existingConfigMaps.Resources() </span><span class="cov8" title="1">{
                        if resource.GetName() == configMapName </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                        continue</span>
                }

                // update name
                <span class="cov8" title="1">providedConfigMap.SetName(configMapName)

                // always update namespace to targetNamespace
                providedConfigMap.SetNamespace(targetNamespace)

                // update kind
                if providedConfigMap.TypeMeta.Kind == "" </span><span class="cov8" title="1">{
                        providedConfigMap.TypeMeta.Kind = KindConfigMap
                }</span>

                // update api version
                <span class="cov8" title="1">if providedConfigMap.TypeMeta.APIVersion == "" </span><span class="cov8" title="1">{
                        providedConfigMap.TypeMeta.APIVersion = corev1.SchemeGroupVersion.Version
                }</span>

                // convert configMap to unstructured object
                <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(&amp;providedConfigMap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">u := unstructured.Unstructured{}
                u.SetUnstructuredContent(obj)
                extraConfigMaps = append(extraConfigMaps, u)</span>
        }

        <span class="cov8" title="1">return extraConfigMaps, nil</span>
}

func (ot *OptionsTransformer) updateDeployments(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        // verify the deployment has changes
        deploymentOptions, found := ot.options.Deployments[u.GetName()]
        if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        // update labels
        <span class="cov8" title="1">err := ot.updateLabels(u, deploymentOptions.Labels)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update annotations
        <span class="cov8" title="1">err = ot.updateAnnotations(u, deploymentOptions.Annotations)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update pod template labels
        <span class="cov8" title="1">err = ot.updateMapField(u, deploymentOptions.Spec.Template.Labels, "spec", "template", "metadata", "labels")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update pod template annotations
        <span class="cov8" title="1">err = ot.updateMapField(u, deploymentOptions.Spec.Template.Annotations, "spec", "template", "metadata", "annotations")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // convert unstructured object to deployment
        <span class="cov8" title="1">targetDeployment := &amp;appsv1.Deployment{}
        err = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetDeployment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update replicas
        <span class="cov8" title="1">if deploymentOptions.Spec.Replicas != nil </span><span class="cov8" title="1">{
                targetDeployment.Spec.Replicas = ptr.Int32(*deploymentOptions.Spec.Replicas)
        }</span>

        // update affinity
        <span class="cov8" title="1">if deploymentOptions.Spec.Template.Spec.Affinity != nil </span><span class="cov8" title="1">{
                targetDeployment.Spec.Template.Spec.Affinity = deploymentOptions.Spec.Template.Spec.Affinity
        }</span>

        // update PriorityClassName
        <span class="cov8" title="1">if deploymentOptions.Spec.Template.Spec.PriorityClassName != "" </span><span class="cov8" title="1">{
                targetDeployment.Spec.Template.Spec.PriorityClassName = deploymentOptions.Spec.Template.Spec.PriorityClassName
        }</span>

        // update node selectors
        <span class="cov8" title="1">if len(deploymentOptions.Spec.Template.Spec.NodeSelector) &gt; 0 </span><span class="cov8" title="1">{
                targetDeployment.Spec.Template.Spec.NodeSelector = deploymentOptions.Spec.Template.Spec.NodeSelector
        }</span>

        // update tolerations
        <span class="cov8" title="1">if len(deploymentOptions.Spec.Template.Spec.Tolerations) &gt; 0 </span><span class="cov8" title="1">{
                targetDeployment.Spec.Template.Spec.Tolerations = deploymentOptions.Spec.Template.Spec.Tolerations
        }</span>

        // update Topology Spread Constraints
        <span class="cov8" title="1">if len(deploymentOptions.Spec.Template.Spec.TopologySpreadConstraints) &gt; 0 </span><span class="cov8" title="1">{
                targetDeployment.Spec.Template.Spec.TopologySpreadConstraints = deploymentOptions.Spec.Template.Spec.TopologySpreadConstraints
        }</span>

        // update runTimeClassName
        <span class="cov8" title="1">if deploymentOptions.Spec.Template.Spec.RuntimeClassName != nil </span><span class="cov8" title="1">{
                targetDeployment.Spec.Template.Spec.RuntimeClassName = deploymentOptions.Spec.Template.Spec.RuntimeClassName
        }</span>

        // update volumes
        <span class="cov8" title="1">targetDeployment.Spec.Template.Spec.Volumes = ot.updateVolumes(targetDeployment.Spec.Template.Spec.Volumes, deploymentOptions.Spec.Template.Spec.Volumes)

        // update init containers
        targetDeployment.Spec.Template.Spec.InitContainers = ot.updateContainers(targetDeployment.Spec.Template.Spec.InitContainers, deploymentOptions.Spec.Template.Spec.InitContainers)

        // update containers
        targetDeployment.Spec.Template.Spec.Containers = ot.updateContainers(targetDeployment.Spec.Template.Spec.Containers, deploymentOptions.Spec.Template.Spec.Containers)

        // convert deployment to unstructured object
        obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetDeployment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.SetUnstructuredContent(obj)

        return nil</span>
}

func (ot *OptionsTransformer) updateVolumes(sourceVolumes, additionalVolumes []corev1.Volume) []corev1.Volume <span class="cov8" title="1">{
        for _, newVolume := range additionalVolumes </span><span class="cov8" title="1">{
                itemFound := false
                for volumeIndex, oldVolume := range sourceVolumes </span><span class="cov8" title="1">{
                        if oldVolume.Name == newVolume.Name </span><span class="cov8" title="1">{
                                sourceVolumes[volumeIndex] = newVolume
                                itemFound = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !itemFound </span><span class="cov8" title="1">{
                        sourceVolumes = append(sourceVolumes, newVolume)
                }</span>
        }
        <span class="cov8" title="1">return sourceVolumes</span>
}

func (ot *OptionsTransformer) updateContainers(targetContainers, containersOptions []corev1.Container) []corev1.Container <span class="cov8" title="1">{
        containersToAdd := []corev1.Container{}
        for _, containerOptions := range containersOptions </span><span class="cov8" title="1">{
                containerFound := false
                for containerIndex := range targetContainers </span><span class="cov8" title="1">{
                        targetContainer := targetContainers[containerIndex]
                        if containerOptions.Name != targetContainer.Name </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">containerFound = true

                        // update resource requirements
                        if containerOptions.Resources.Size() != 0 </span><span class="cov8" title="1">{
                                targetContainers[containerIndex].Resources = containerOptions.Resources
                        }</span>

                        // update environments
                        <span class="cov8" title="1">{
                                envVariables := targetContainer.Env
                                for _, newEnv := range containerOptions.Env </span><span class="cov8" title="1">{
                                        itemFound := false
                                        for envIndex, oldEnv := range envVariables </span><span class="cov8" title="1">{
                                                if oldEnv.Name == newEnv.Name </span><span class="cov8" title="1">{
                                                        envVariables[envIndex] = newEnv
                                                        itemFound = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if !itemFound </span><span class="cov8" title="1">{
                                                envVariables = append(envVariables, newEnv)
                                        }</span>
                                }
                                <span class="cov8" title="1">targetContainers[containerIndex].Env = envVariables</span>
                        }

                        // update volume mounts
                        <span class="cov8" title="1">{
                                volumeMounts := targetContainer.VolumeMounts
                                for _, newVolumeMount := range containerOptions.VolumeMounts </span><span class="cov8" title="1">{
                                        itemFound := false
                                        for volumeMountIndex, oldVolumeMount := range volumeMounts </span><span class="cov8" title="1">{
                                                if oldVolumeMount.Name == newVolumeMount.Name </span><span class="cov8" title="1">{
                                                        volumeMounts[volumeMountIndex] = newVolumeMount
                                                        itemFound = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">if !itemFound </span><span class="cov8" title="1">{
                                                volumeMounts = append(volumeMounts, newVolumeMount)
                                        }</span>
                                }
                                <span class="cov8" title="1">targetContainers[containerIndex].VolumeMounts = volumeMounts</span>
                        }

                        // update arguments: replace by key, support pair-form, preserve existing style, avoid duplicates
                        <span class="cov8" title="1">if len(containerOptions.Args) &gt; 0 </span><span class="cov8" title="1">{
                                existing := targetContainers[containerIndex].Args
                                keyIndex := make(map[string]int)
                                seenExact := make(map[string]bool)
                                // index existing args by key; track pair-style positions
                                for i := 0; i &lt; len(existing); i++ </span><span class="cov8" title="1">{
                                        a := existing[i]
                                        seenExact[a] = true
                                        if !strings.HasPrefix(a, "-") </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if eq := strings.Index(a, "="); eq &gt; 0 </span><span class="cov0" title="0">{
                                                keyIndex[a[:eq]] = i
                                                continue</span>
                                        }
                                        // pair-style key then value
                                        <span class="cov8" title="1">if i+1 &lt; len(existing) &amp;&amp; !strings.HasPrefix(existing[i+1], "-") </span><span class="cov8" title="1">{
                                                keyIndex[a] = i
                                        }</span>
                                }
                                // merge options
                                <span class="cov8" title="1">for i := 0; i &lt; len(containerOptions.Args); </span><span class="cov8" title="1">{
                                        a := containerOptions.Args[i]
                                        if strings.HasPrefix(a, "-") </span><span class="cov8" title="1">{
                                                // key=value from options
                                                if strings.Contains(a, "=") </span><span class="cov8" title="1">{
                                                        k := a[:strings.Index(a, "=")]
                                                        if pos, ok := keyIndex[k]; ok </span><span class="cov0" title="0">{
                                                                // preserve existing style
                                                                if existing[pos] == k </span><span class="cov0" title="0">{
                                                                        val := a[strings.Index(a, "=")+1:]
                                                                        if pos+1 &lt; len(existing) &amp;&amp; !strings.HasPrefix(existing[pos+1], "-") </span><span class="cov0" title="0">{
                                                                                existing[pos+1] = val
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                existing = append(existing[:pos+1], append([]string{val}, existing[pos+1:]...)...)
                                                                        }</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        existing[pos] = a
                                                                }</span>
                                                        } else<span class="cov8" title="1"> {
                                                                keyIndex[k] = len(existing)
                                                                existing = append(existing, a)
                                                        }</span>
                                                        <span class="cov8" title="1">i++
                                                        continue</span>
                                                }
                                                // pair-style from options: key then value
                                                <span class="cov8" title="1">if i+1 &lt; len(containerOptions.Args) &amp;&amp; !strings.HasPrefix(containerOptions.Args[i+1], "-") </span><span class="cov8" title="1">{
                                                        k, val := a, containerOptions.Args[i+1]
                                                        if pos, ok := keyIndex[k]; ok </span><span class="cov0" title="0">{
                                                                if existing[pos] == k </span><span class="cov0" title="0">{
                                                                        if pos+1 &lt; len(existing) &amp;&amp; !strings.HasPrefix(existing[pos+1], "-") </span><span class="cov0" title="0">{
                                                                                existing[pos+1] = val
                                                                        }</span> else<span class="cov0" title="0"> {
                                                                                existing = append(existing[:pos+1], append([]string{val}, existing[pos+1:]...)...)
                                                                        }</span>
                                                                } else<span class="cov0" title="0"> {
                                                                        existing[pos] = k + "=" + val
                                                                }</span>
                                                        } else<span class="cov8" title="1"> {
                                                                keyIndex[k] = len(existing)
                                                                existing = append(existing, k, val)
                                                        }</span>
                                                        <span class="cov8" title="1">i += 2
                                                        continue</span>
                                                }
                                                // standalone flag: exact dedupe
                                                <span class="cov8" title="1">if !seenExact[a] </span><span class="cov8" title="1">{
                                                        seenExact[a] = true
                                                        existing = append(existing, a)
                                                }</span>
                                                <span class="cov8" title="1">i++
                                                continue</span>
                                        }
                                        // non-flag token: exact-string dedupe
                                        <span class="cov0" title="0">if !seenExact[a] </span><span class="cov0" title="0">{
                                                seenExact[a] = true
                                                existing = append(existing, a)
                                        }</span>
                                        <span class="cov0" title="0">i++</span>
                                }
                                <span class="cov8" title="1">targetContainers[containerIndex].Args = existing</span>
                        }
                }
                // add the new container from the options list
                <span class="cov8" title="1">if !containerFound </span><span class="cov8" title="1">{
                        containersToAdd = append(containersToAdd, containerOptions)
                }</span>
        }
        <span class="cov8" title="1">targetContainers = append(targetContainers, containersToAdd...)
        return targetContainers</span>
}

// calculate deployment spec hash value and update it under pods label(under template).
// If there is change detected in deployment spec, all pods will be recreated, as we the pods label(hash value label) is updated
func (ot *OptionsTransformer) updateDeploymentHashValue(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        // convert unstructured object to deployment
        deployment := &amp;appsv1.Deployment{}
        err := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, deployment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // remove some of the fields, that we do not want to calculate hash value
        <span class="cov8" title="1">deployment.Spec.Selector = nil
        deployment.Spec.Strategy = appsv1.DeploymentStrategy{}
        // remove existing hash value from template
        if len(deployment.Spec.Template.Labels) == 0 </span><span class="cov0" title="0">{
                deployment.Spec.Template.Labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">deployment.Spec.Template.Labels[v1alpha1.DeploymentSpecHashValueLabelKey] = ""

        // label value max limit is 63 chars, sha256 hash produces 64 chars
        // use md5 hash which is 16 chars
        hashValue, err := hash.ComputeMd5(deployment.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update hash value
        <span class="cov8" title="1">obj := u.Object
        if err := unstructured.SetNestedField(obj, hashValue, "spec", "template", "metadata", "labels", v1alpha1.DeploymentSpecHashValueLabelKey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">u.SetUnstructuredContent(obj)
        return nil</span>
}

func (ot *OptionsTransformer) updateStatefulSets(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        // verify the statefulSet has changes
        statefulSetOptions, found := ot.options.StatefulSets[u.GetName()]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>

        // update labels
        <span class="cov8" title="1">err := ot.updateLabels(u, statefulSetOptions.Labels)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update annotations
        <span class="cov8" title="1">err = ot.updateAnnotations(u, statefulSetOptions.Annotations)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update pod template labels
        <span class="cov8" title="1">err = ot.updateMapField(u, statefulSetOptions.Spec.Template.Labels, "spec", "template", "metadata", "labels")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update pod template annotations
        <span class="cov8" title="1">err = ot.updateMapField(u, statefulSetOptions.Spec.Template.Annotations, "spec", "template", "metadata", "annotations")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // convert unstructured object to statefulSet
        <span class="cov8" title="1">targetStatefulSet := &amp;appsv1.StatefulSet{}
        err = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetStatefulSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update replicas
        <span class="cov8" title="1">if statefulSetOptions.Spec.Replicas != nil </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.Replicas = ptr.Int32(*statefulSetOptions.Spec.Replicas)
        }</span>

        // update affinity
        <span class="cov8" title="1">if statefulSetOptions.Spec.Template.Spec.Affinity != nil </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.Template.Spec.Affinity = statefulSetOptions.Spec.Template.Spec.Affinity
        }</span>

        // update priorityClassName
        <span class="cov8" title="1">if statefulSetOptions.Spec.Template.Spec.PriorityClassName != "" </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.Template.Spec.PriorityClassName = statefulSetOptions.Spec.Template.Spec.PriorityClassName

        }</span>

        // update node selectors
        <span class="cov8" title="1">if len(statefulSetOptions.Spec.Template.Spec.NodeSelector) &gt; 0 </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.Template.Spec.NodeSelector = statefulSetOptions.Spec.Template.Spec.NodeSelector
        }</span>

        // update tolerations
        <span class="cov8" title="1">if len(statefulSetOptions.Spec.Template.Spec.Tolerations) &gt; 0 </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.Template.Spec.Tolerations = statefulSetOptions.Spec.Template.Spec.Tolerations
        }</span>

        // update Topology Spread Constraints
        <span class="cov8" title="1">if len(statefulSetOptions.Spec.Template.Spec.TopologySpreadConstraints) &gt; 0 </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.Template.Spec.TopologySpreadConstraints = statefulSetOptions.Spec.Template.Spec.TopologySpreadConstraints
        }</span>

        // update pod management policy
        <span class="cov8" title="1">if statefulSetOptions.Spec.PodManagementPolicy != "" </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.PodManagementPolicy = statefulSetOptions.Spec.PodManagementPolicy
        }</span>

        // update service name
        <span class="cov8" title="1">if statefulSetOptions.Spec.ServiceName != "" </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.ServiceName = statefulSetOptions.Spec.ServiceName
        }</span>

        // update volume claim templates
        <span class="cov8" title="1">if len(statefulSetOptions.Spec.VolumeClaimTemplates) &gt; 0 </span><span class="cov8" title="1">{
                for _, newVolumeClaimTpl := range statefulSetOptions.Spec.VolumeClaimTemplates </span><span class="cov8" title="1">{
                        itemFound := false
                        for volumeClaimTplIndex, oldVolumeClaimTpl := range targetStatefulSet.Spec.VolumeClaimTemplates </span><span class="cov8" title="1">{
                                if oldVolumeClaimTpl.Name == newVolumeClaimTpl.Name </span><span class="cov8" title="1">{
                                        targetStatefulSet.Spec.VolumeClaimTemplates[volumeClaimTplIndex] = newVolumeClaimTpl
                                        itemFound = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !itemFound </span><span class="cov8" title="1">{
                                targetStatefulSet.Spec.VolumeClaimTemplates = append(targetStatefulSet.Spec.VolumeClaimTemplates, newVolumeClaimTpl)
                        }</span>
                }
        }

        // update runTimeClassName
        <span class="cov8" title="1">if statefulSetOptions.Spec.Template.Spec.RuntimeClassName != nil </span><span class="cov8" title="1">{
                targetStatefulSet.Spec.Template.Spec.RuntimeClassName = statefulSetOptions.Spec.Template.Spec.RuntimeClassName
        }</span>

        // update volumes
        <span class="cov8" title="1">targetStatefulSet.Spec.Template.Spec.Volumes = ot.updateVolumes(targetStatefulSet.Spec.Template.Spec.Volumes, statefulSetOptions.Spec.Template.Spec.Volumes)

        // update init containers
        targetStatefulSet.Spec.Template.Spec.InitContainers = ot.updateContainers(targetStatefulSet.Spec.Template.Spec.InitContainers, statefulSetOptions.Spec.Template.Spec.InitContainers)

        // update containers
        targetStatefulSet.Spec.Template.Spec.Containers = ot.updateContainers(targetStatefulSet.Spec.Template.Spec.Containers, statefulSetOptions.Spec.Template.Spec.Containers)

        // convert statefulSet to unstructured object
        obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetStatefulSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.SetUnstructuredContent(obj)

        return nil</span>
}

func (ot *OptionsTransformer) updateHorizontalPodAutoscalers(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        hpaOptions, found := ot.options.HorizontalPodAutoscalers[u.GetName()]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>

        // update labels
        <span class="cov8" title="1">err := ot.updateLabels(u, hpaOptions.Labels)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update annotations
        <span class="cov8" title="1">err = ot.updateAnnotations(u, hpaOptions.Annotations)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // convert unstructured object to statefulSet
        <span class="cov8" title="1">targetHpa := autoscalingv2.HorizontalPodAutoscaler{}
        err = apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, &amp;targetHpa)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update scaling target reference
        <span class="cov8" title="1">if hpaOptions.Spec.ScaleTargetRef.Kind != "" &amp;&amp; hpaOptions.Spec.ScaleTargetRef.Name != "" </span><span class="cov8" title="1">{
                targetHpa.Spec.ScaleTargetRef = hpaOptions.Spec.ScaleTargetRef
        }</span>

        // updates min replicas
        <span class="cov8" title="1">if hpaOptions.Spec.MinReplicas != nil </span><span class="cov8" title="1">{
                targetHpa.Spec.MinReplicas = ptr.Int32(*hpaOptions.Spec.MinReplicas)
        }</span>

        // updates max replicas
        <span class="cov8" title="1">if hpaOptions.Spec.MaxReplicas &gt; 0 </span><span class="cov8" title="1">{
                targetHpa.Spec.MaxReplicas = hpaOptions.Spec.MaxReplicas
        }</span>

        // update metrics
        <span class="cov8" title="1">if len(hpaOptions.Spec.Metrics) &gt; 0 </span><span class="cov8" title="1">{
                targetHpa.Spec.Metrics = hpaOptions.Spec.Metrics
        }</span>

        // update behavior
        <span class="cov8" title="1">if hpaOptions.Spec.Behavior != nil </span><span class="cov8" title="1">{
                // update behavior, if empty
                if targetHpa.Spec.Behavior == nil </span><span class="cov8" title="1">{
                        targetHpa.Spec.Behavior = &amp;autoscalingv2.HorizontalPodAutoscalerBehavior{}
                }</span>

                // update scaling down
                <span class="cov8" title="1">if hpaOptions.Spec.Behavior.ScaleDown != nil </span><span class="cov8" title="1">{
                        targetHpa.Spec.Behavior.ScaleDown = hpaOptions.Spec.Behavior.ScaleDown.DeepCopy()
                }</span>

                // update scaling up
                <span class="cov8" title="1">if hpaOptions.Spec.Behavior.ScaleUp != nil </span><span class="cov8" title="1">{
                        targetHpa.Spec.Behavior.ScaleUp = hpaOptions.Spec.Behavior.ScaleUp.DeepCopy()
                }</span>
        }

        // convert HorizontalPodAutoscaler to unstructured object
        <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(&amp;targetHpa)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.SetUnstructuredContent(obj)

        return nil</span>
}

func (ot *OptionsTransformer) createHorizontalPodAutoscalers(manifest *mf.Manifest, targetNamespace string, additionalOptions v1alpha1.AdditionalOptions) ([]unstructured.Unstructured, error) <span class="cov8" title="1">{
        newHPAs := []unstructured.Unstructured{}
        existingHPAs := manifest.Filter(mf.Any(mf.ByKind(KindHorizontalPodAutoscaler)))
        for hpaName, newHPA := range additionalOptions.HorizontalPodAutoscalers </span><span class="cov8" title="1">{
                found := false
                for _, resource := range existingHPAs.Resources() </span><span class="cov8" title="1">{
                        if resource.GetName() == hpaName </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                        continue</span>
                }

                // update name
                <span class="cov8" title="1">newHPA.SetName(hpaName)

                // update the namespace to targetNamespace
                newHPA.SetNamespace(targetNamespace)

                // update kind
                if newHPA.TypeMeta.Kind == "" </span><span class="cov8" title="1">{
                        newHPA.TypeMeta.Kind = KindHorizontalPodAutoscaler
                }</span>

                // update api version
                <span class="cov8" title="1">if newHPA.TypeMeta.APIVersion == "" </span><span class="cov8" title="1">{
                        newHPA.TypeMeta.APIVersion = autoscalingv2.SchemeGroupVersion.String()
                }</span>

                // convert hpa to unstructured object
                <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(&amp;newHPA)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">u := unstructured.Unstructured{}
                u.SetUnstructuredContent(obj)
                newHPAs = append(newHPAs, u)</span>
        }

        <span class="cov8" title="1">return newHPAs, nil</span>
}

func (ot *OptionsTransformer) updateWebhookConfiguration(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        webhookOptions, found := ot.options.WebhookConfigurationOptions[u.GetName()]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">switch u.GetKind() </span>{
        case KindValidatingWebhookConfiguration:<span class="cov8" title="1">
                targetWebhookConfiguration := &amp;admissionregistrationv1.ValidatingWebhookConfiguration{}
                err := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetWebhookConfiguration)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for i, w := range targetWebhookConfiguration.Webhooks </span><span class="cov8" title="1">{
                        if u.GetName() == w.Name </span><span class="cov8" title="1">{
                                if webhookOptions.FailurePolicy != nil </span><span class="cov8" title="1">{
                                        targetWebhookConfiguration.Webhooks[i].FailurePolicy = webhookOptions.FailurePolicy
                                }</span>
                                <span class="cov8" title="1">if webhookOptions.TimeoutSeconds != nil </span><span class="cov8" title="1">{
                                        targetWebhookConfiguration.Webhooks[i].TimeoutSeconds = webhookOptions.TimeoutSeconds
                                }</span>
                                <span class="cov8" title="1">if webhookOptions.SideEffects != nil </span><span class="cov8" title="1">{
                                        targetWebhookConfiguration.Webhooks[i].SideEffects = webhookOptions.SideEffects
                                }</span>
                        }
                }
                // convert webhookconfigurtion to unstructured object
                <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetWebhookConfiguration)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(obj)</span>

        case KindMutatingWebhookConfiguration:<span class="cov8" title="1">
                targetWebhookConfiguration := &amp;admissionregistrationv1.MutatingWebhookConfiguration{}
                err := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, targetWebhookConfiguration)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for i, w := range targetWebhookConfiguration.Webhooks </span><span class="cov8" title="1">{
                        if u.GetName() == w.Name </span><span class="cov8" title="1">{
                                if webhookOptions.FailurePolicy != nil </span><span class="cov8" title="1">{
                                        targetWebhookConfiguration.Webhooks[i].FailurePolicy = webhookOptions.FailurePolicy
                                }</span>
                                <span class="cov8" title="1">if webhookOptions.TimeoutSeconds != nil </span><span class="cov8" title="1">{
                                        targetWebhookConfiguration.Webhooks[i].TimeoutSeconds = webhookOptions.TimeoutSeconds
                                }</span>
                                <span class="cov8" title="1">if webhookOptions.SideEffects != nil </span><span class="cov0" title="0">{
                                        targetWebhookConfiguration.Webhooks[i].SideEffects = webhookOptions.SideEffects
                                }</span>
                        }
                }
                // convert webhookconfigurtion to unstructured object
                <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(targetWebhookConfiguration)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(obj)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "os"

        mf "github.com/manifestival/manifestival"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/version"
)

func DeploymentEnvVarKubernetesMinVersion() mf.Transformer <span class="cov0" title="0">{
        var envVars []corev1.EnvVar
        if minVersion, exists := os.LookupEnv(version.KubernetesMinVersionKey); exists </span><span class="cov0" title="0">{
                envVars = append(envVars, corev1.EnvVar{
                        Name:  version.KubernetesMinVersionKey,
                        Value: minVersion,
                })
        }</span>
        <span class="cov0" title="0">return deploymentEnvVars(envVars)</span>
}

func deploymentEnvVars(envVars []corev1.EnvVar) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">if len(envVars) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">containers := d.Spec.Template.Spec.Containers
                for i := range containers </span><span class="cov8" title="1">{
                        for _, newEnv := range envVars </span><span class="cov8" title="1">{
                                envVarExists := false

                                for j := range containers[i].Env </span><span class="cov8" title="1">{
                                        if containers[i].Env[j].Name == newEnv.Name </span><span class="cov8" title="1">{
                                                containers[i].Env[j].Value = newEnv.Value
                                                containers[i].Env[j].ValueFrom = newEnv.ValueFrom
                                                envVarExists = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !envVarExists </span><span class="cov8" title="1">{
                                        containers[i].Env = append(containers[i].Env, newEnv)
                                }</span>
                        }
                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file64" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/labels"
)

func InjectOperandNameLabelPreserveExisting(operandName string) mf.Transformer <span class="cov0" title="0">{
        preserveExisting := true
        return injectOperandNameLabel(operandName, preserveExisting)
}</span>

func InjectOperandNameLabelOverwriteExisting(operandName string) mf.Transformer <span class="cov0" title="0">{
        preserveExisting := false
        return injectOperandNameLabel(operandName, preserveExisting)
}</span>

func injectOperandNameLabel(operandName string, preserveExisting bool) mf.Transformer <span class="cov8" title="1">{
        l := labels.Set{
                v1alpha1.LabelOperandName: operandName,
        }

        if preserveExisting </span><span class="cov0" title="0">{
                return InjectLabelPreserveExisting(l)
        }</span>
        <span class="cov8" title="1">return InjectLabelOverwriteExisting(l)</span>
}

func InjectLabelPreserveExisting(newLabels labels.Set, skipChecks ...mf.Predicate) mf.Transformer <span class="cov0" title="0">{
        preserverExisting := true
        return injectLabel(newLabels, preserverExisting, skipChecks...)
}</span>

func InjectLabelOverwriteExisting(newLabels labels.Set, skipChecks ...mf.Predicate) mf.Transformer <span class="cov8" title="1">{
        preserverExisting := false
        return injectLabel(newLabels, preserverExisting, skipChecks...)
}</span>

func injectLabel(newLabels labels.Set, preserverExisting bool, skipChecks ...mf.Predicate) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                for _, skipCheck := range skipChecks </span><span class="cov8" title="1">{
                        if skipCheck(u) </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                }
                <span class="cov8" title="1">resourceLabels := u.GetLabels()
                if resourceLabels == nil </span><span class="cov0" title="0">{
                        resourceLabels = map[string]string{}
                }</span>
                <span class="cov8" title="1">for key, val := range newLabels </span><span class="cov8" title="1">{
                        if !replaceAllowed(preserverExisting, resourceLabels, key) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">resourceLabels[key] = val</span>
                }
                <span class="cov8" title="1">u.SetLabels(resourceLabels)
                return nil</span>
        }
}

func replaceAllowed(preserveExisting bool, existingLabels map[string]string, key string) bool <span class="cov8" title="1">{
        if !preserveExisting </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">_, ok := existingLabels[key]

        // if key exists (ok = true) then donot allow replace, hence return false
        // else if key not exists (ok = false) the allow replace, hence return true
        // ie, return !ok
        return !ok</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "context"
        "fmt"
        "os"
        "reflect"
        "sort"
        "strconv"
        "strings"

        "gopkg.in/yaml.v3"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "go.uber.org/zap"
        "golang.org/x/exp/slices"
        appsv1 "k8s.io/api/apps/v1"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        apimachineryRuntime "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

const (
        AnnotationPreserveNS          = "operator.tekton.dev/preserve-namespace"
        AnnotationPreserveRBSubjectNS = "operator.tekton.dev/preserve-rb-subject-namespace"
        ImageRegistryOverride         = "TEKTON_REGISTRY_OVERRIDE"
        PipelinesImagePrefix          = "IMAGE_PIPELINES_"
        TriggersImagePrefix           = "IMAGE_TRIGGERS_"
        AddonsImagePrefix             = "IMAGE_ADDONS_"
        PacImagePrefix                = "IMAGE_PAC_"
        ChainsImagePrefix             = "IMAGE_CHAINS_"
        ManualApprovalGatePrefix      = "IMAGE_MAG_"
        PrunerImagePrefix             = "IMAGE_PRUNER_"
        ResultsImagePrefix            = "IMAGE_RESULTS_"
        HubImagePrefix                = "IMAGE_HUB_"
        DashboardImagePrefix          = "IMAGE_DASHBOARD_"

        DefaultTargetNamespace = "tekton-pipelines"

        ArgPrefix   = "arg_"
        ParamPrefix = "param_"

        runAsNonRootValue              = true
        allowPrivilegedEscalationValue = false
        pipelinesControllerDeployment  = "tekton-pipelines-controller"
)

// transformers that are common to all components.
func transformers(ctx context.Context, obj v1alpha1.TektonComponent) []mf.Transformer <span class="cov8" title="1">{
        return []mf.Transformer{
                mf.InjectOwner(obj),
                injectNamespaceConditional(AnnotationPreserveNS, obj.GetSpec().GetTargetNamespace()),
                injectNamespaceCRDWebhookClientConfig(obj.GetSpec().GetTargetNamespace()),
                injectNamespaceCRClusterInterceptorClientConfig(obj.GetSpec().GetTargetNamespace()),
                injectNamespaceClusterRole(obj.GetSpec().GetTargetNamespace()),
                AddDeploymentRestrictedPSA(),
        }
}</span>

// TODO for now added here but planning to refactor so that we can avoid openshift specific changes as part of common
func roleBindingTransformers(ctx context.Context, obj v1alpha1.TektonComponent) []mf.Transformer <span class="cov8" title="1">{
        return []mf.Transformer{
                mf.InjectOwner(obj),
                injectNamespaceRoleBindingConditional(AnnotationPreserveNS,
                        AnnotationPreserveRBSubjectNS, obj.GetSpec().GetTargetNamespace()),
        }
}</span>

// Transform will mutate the passed-by-reference manifest with one
// transformed by platform, common, and any extra passed in
func Transform(ctx context.Context, manifest *mf.Manifest, instance v1alpha1.TektonComponent, extra ...mf.Transformer) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Debug("Transforming manifest")

        roleBindingManifest := manifest.Filter(mf.Any(mf.ByKind("RoleBinding")))
        remainingManifest := manifest.Filter(mf.Not(mf.Any(mf.ByKind("RoleBinding"))))

        transformers := transformers(ctx, instance)
        transformers = append(transformers, extra...)

        t1 := roleBindingTransformers(ctx, instance)

        remainingManifest, err := remainingManifest.Transform(transformers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">roleBindingManifest, err = roleBindingManifest.Transform(t1...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*manifest = remainingManifest.Append(roleBindingManifest)
        return nil</span>
}

func injectNamespaceConditional(preserveNamespace, targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        tf := mf.InjectNamespace(targetNamespace)
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                annotations := u.GetAnnotations()
                val, ok := annotations[preserveNamespace]
                if ok &amp;&amp; val == "true" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return tf(u)</span>
        }
}

func injectNamespaceCRDWebhookClientConfig(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                kind := strings.ToLower(u.GetKind())
                if kind != "customresourcedefinition" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">service, found, err := unstructured.NestedFieldNoCopy(u.Object, "spec", "conversion", "webhookClientConfig", "service")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">m := service.(map[string]interface{})
                if _, ok := m["namespace"]; ok </span><span class="cov0" title="0">{
                        m["namespace"] = targetNamespace
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func injectNamespaceCRClusterInterceptorClientConfig(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                kind := strings.ToLower(u.GetKind())
                if kind != "clusterinterceptor" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">service, found, err := unstructured.NestedFieldNoCopy(u.Object, "spec", "clientConfig", "service")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">m := service.(map[string]interface{})
                if _, ok := m["namespace"]; ok </span><span class="cov8" title="1">{
                        m["namespace"] = targetNamespace
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// ImagesFromEnv will provide map of key value.
func ImagesFromEnv(prefix string) map[string]string <span class="cov8" title="1">{
        images := map[string]string{}
        for _, env := range os.Environ() </span><span class="cov8" title="1">{
                if !strings.HasPrefix(env, prefix) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">keyValue := strings.Split(env, "=")
                name := strings.TrimPrefix(keyValue[0], prefix)
                url := keyValue[1]
                images[name] = url</span>
        }

        <span class="cov8" title="1">return images</span>
}

// ImageRegistryDomainOverride will add or override the registry used in the image list
func ImageRegistryDomainOverride(images map[string]string) map[string]string <span class="cov8" title="1">{
        registry := os.Getenv(ImageRegistryOverride)
        if registry == "" </span><span class="cov8" title="1">{
                return images
        }</span> else<span class="cov8" title="1"> {
                for key, imageName := range images </span><span class="cov8" title="1">{
                        parts := strings.Split(imageName, "/")
                        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                                // if image has registry part, replace it
                                images[key] = registry + "/" + strings.Join(parts[1:], "/")
                        }</span> else<span class="cov0" title="0"> {
                                // if image does not have registry part, add it
                                images[key] = registry + "/" + imageName
                        }</span>
                }
                <span class="cov8" title="1">return images</span>
        }
}

// ToLowerCaseKeys converts key value to lower cases.
func ToLowerCaseKeys(keyValues map[string]string) map[string]string <span class="cov8" title="1">{
        newMap := map[string]string{}

        for k, v := range keyValues </span><span class="cov8" title="1">{
                key := strings.ToLower(k)
                newMap[key] = v
        }</span>

        <span class="cov8" title="1">return newMap</span>
}

// DeploymentImages replaces container and args images.
func DeploymentImages(images map[string]string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">containers := d.Spec.Template.Spec.Containers
                replaceContainerImages(containers, images)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// StatefulSetImages replaces container and args images.
func StatefulSetImages(images map[string]string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "StatefulSet" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">s := &amp;appsv1.StatefulSet{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">containers := s.Spec.Template.Spec.Containers
                replaceContainerImages(containers, images)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// JobImages replaces container and args images.
func JobImages(images map[string]string) mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                if u.GetKind() != "Job" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">jb := &amp;batchv1.Job{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">containers := jb.Spec.Template.Spec.Containers
                replaceContainerImages(containers, images)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

func replaceContainerImages(containers []corev1.Container, images map[string]string) <span class="cov8" title="1">{
        for i, container := range containers </span><span class="cov8" title="1">{
                name := formKey("", container.Name)
                if url, exist := images[name]; exist </span><span class="cov8" title="1">{
                        containers[i].Image = url
                }</span>

                <span class="cov8" title="1">replaceContainersArgsImage(&amp;container, images)</span>
        }
}

func replaceContainersArgsImage(container *corev1.Container, images map[string]string) <span class="cov8" title="1">{
        for a, arg := range container.Args </span><span class="cov8" title="1">{
                if argVal, hasArg := SplitsByEqual(arg); hasArg </span><span class="cov8" title="1">{
                        argument := formKey(ArgPrefix, argVal[0])
                        if url, exist := images[argument]; exist </span><span class="cov0" title="0">{
                                container.Args[a] = argVal[0] + "=" + url
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">argument := formKey(ArgPrefix, arg)
                if url, exist := images[argument]; exist </span><span class="cov0" title="0">{
                        container.Args[a+1] = url
                }</span>
        }
}

func formKey(prefix, arg string) string <span class="cov8" title="1">{
        argument := strings.ToLower(arg)
        if prefix != "" </span><span class="cov8" title="1">{
                argument = prefix + argument
        }</span>
        <span class="cov8" title="1">return strings.ReplaceAll(argument, "-", "_")</span>
}

func SplitsByEqual(arg string) ([]string, bool) <span class="cov8" title="1">{
        values := strings.Split(arg, "=")
        if len(values) == 2 </span><span class="cov8" title="1">{
                return values, true
        }</span>

        <span class="cov8" title="1">return values, false</span>
}

// TaskImages replaces step and params images.
func TaskImages(ctx context.Context, images map[string]string) mf.Transformer <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ClusterTask" &amp;&amp; u.GetKind() != "Task" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">steps, found, err := unstructured.NestedSlice(u.Object, "spec", "steps")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">replaceStepsImages(steps, images, logger)
                err = unstructured.SetNestedField(u.Object, steps, "spec", "steps")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">params, found, err := unstructured.NestedSlice(u.Object, "spec", "params")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">replaceParamsImage(params, images, logger)
                return unstructured.SetNestedField(u.Object, params, "spec", "params")</span>
        }
}

// StepActionImages replaces spec images.
func StepActionImages(ctx context.Context, images map[string]string) mf.Transformer <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                stepActionSpec, found, err := unstructured.NestedMap(u.Object, "spec")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">replaceStepActionImages(stepActionSpec, images, u.GetName(), logger)
                return unstructured.SetNestedMap(u.Object, stepActionSpec, "spec")</span>
        }
}

func replaceStepActionImages(stepActionSpec map[string]interface{}, override map[string]string, name string, logger *zap.SugaredLogger) <span class="cov8" title="1">{
        name = formKey("", name)
        image, found := override[name]
        if !found || image == "" </span><span class="cov0" title="0">{
                logger.Debugf("Image not found in stepaction %s action skip", name)
                return
        }</span>
        // Replace the image in the stepActionSpec if the key exists.
        <span class="cov8" title="1">if _, ok := stepActionSpec["image"]; ok </span><span class="cov8" title="1">{
                logger.Debugf("replacing image with %s", image)
                stepActionSpec["image"] = image
        }</span>
}

func replaceStepsImages(steps []interface{}, override map[string]string, logger *zap.SugaredLogger) <span class="cov8" title="1">{
        for _, s := range steps </span><span class="cov8" title="1">{
                step := s.(map[string]interface{})
                name, ok := step["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        logger.Debugf("Unable to get the step %v step", s)
                        continue</span>
                }

                <span class="cov8" title="1">name = formKey("", name)
                image, found := override[name]
                if !found || image == "" </span><span class="cov8" title="1">{
                        logger.Debugf("Image not found step %s action skip", name)
                        continue</span>
                }
                <span class="cov8" title="1">step["image"] = image</span>
        }
}

func replaceParamsImage(params []interface{}, override map[string]string, logger *zap.SugaredLogger) <span class="cov8" title="1">{
        for _, p := range params </span><span class="cov8" title="1">{
                param := p.(map[string]interface{})
                name, ok := param["name"].(string)
                if !ok </span><span class="cov0" title="0">{
                        logger.Debugf("Unable to get the pram %v param", p)
                        continue</span>
                }

                <span class="cov8" title="1">name = formKey(ParamPrefix, name)
                image, found := override[name]
                if !found || image == "" </span><span class="cov8" title="1">{
                        logger.Debugf("Image not found step %s action skip", name)
                        continue</span>
                }
                <span class="cov8" title="1">param["default"] = image</span>
        }
}

func injectNamespaceRoleBindingConditional(preserveNS, preserveRBSubjectNS, targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        tf := injectNamespaceRoleBindingSubjects(targetNamespace)

        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                annotations := u.GetAnnotations()
                val, ok := annotations[preserveNS]
                if !(ok &amp;&amp; val == "true") </span><span class="cov0" title="0">{
                        u.SetNamespace(targetNamespace)
                }</span>
                <span class="cov0" title="0">val, ok = annotations[preserveRBSubjectNS]
                if ok &amp;&amp; val == "true" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return tf(u)</span>
        }
}

func injectNamespaceRoleBindingSubjects(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                kind := strings.ToLower(u.GetKind())
                if kind != "rolebinding" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">subjects, found, err := unstructured.NestedFieldNoCopy(u.Object, "subjects")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, subject := range subjects.([]interface{}) </span><span class="cov0" title="0">{
                        m := subject.(map[string]interface{})
                        if _, ok := m["namespace"]; ok </span><span class="cov0" title="0">{
                                m["namespace"] = targetNamespace
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
}

func injectNamespaceClusterRole(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if strings.ToLower(u.GetKind()) != "clusterrole" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">rules, found, err := unstructured.NestedFieldNoCopy(u.Object, "rules")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, rule := range rules.([]interface{}) </span><span class="cov8" title="1">{
                        m := rule.(map[string]interface{})
                        resources, ok := m["resources"]
                        if !ok || len(resources.([]interface{})) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">containsNamespaceResource := false
                        for _, resource := range resources.([]interface{}) </span><span class="cov8" title="1">{
                                if strings.HasPrefix(resource.(string), "namespaces") </span><span class="cov8" title="1">{
                                        containsNamespaceResource = true
                                }</span>
                        }
                        <span class="cov8" title="1">resourceNames, ok := m["resourceNames"]
                        if containsNamespaceResource &amp;&amp; ok </span><span class="cov8" title="1">{
                                nm := []interface{}{}
                                for _, rn := range resourceNames.([]interface{}) </span><span class="cov8" title="1">{
                                        if rn.(string) == DefaultTargetNamespace </span><span class="cov8" title="1">{
                                                nm = append(nm, targetNamespace)
                                        }</span> else<span class="cov0" title="0"> {
                                                nm = append(nm, rn)
                                        }</span>
                                }
                                <span class="cov8" title="1">m["resourceNames"] = nm</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }
}

// ReplaceNamespaceInDeploymentEnv replaces any instance of the default namespace string in the given deployments' env var
func ReplaceNamespaceInDeploymentEnv(deploymentNames []string, targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" || !slices.Contains(deploymentNames, u.GetName()) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">container := d.Spec.Template.Spec.Containers[0]
                d.Spec.Template.Spec.Containers[0].Env = replaceNamespaceInDBAddress(container.Env, targetNamespace)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

func replaceNamespaceInDBAddress(envs []corev1.EnvVar, targetNamespace string) []corev1.EnvVar <span class="cov8" title="1">{
        req := []string{"DB_ADDR", "TEKTON_RESULTS_API_SERVICE"}

        for i, e := range envs </span><span class="cov8" title="1">{
                if slices.Contains(req, e.Name) </span><span class="cov8" title="1">{
                        envs[i].Value = strings.ReplaceAll(e.Value, DefaultTargetNamespace, targetNamespace)
                }</span>
        }
        <span class="cov8" title="1">return envs</span>
}

// ReplaceNamespaceInDeploymentArgs replaces any instance of the default namespace in the given deployments' args
func ReplaceNamespaceInDeploymentArgs(deploymentNames []string, targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" || !slices.Contains(deploymentNames, u.GetName()) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">container := d.Spec.Template.Spec.Containers[0]
                replaceNamespaceInContainerArg(&amp;container, targetNamespace)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

func replaceNamespaceInContainerArg(container *corev1.Container, targetNamespace string) <span class="cov8" title="1">{
        for i, a := range container.Args </span><span class="cov8" title="1">{
                if strings.Contains(a, DefaultTargetNamespace) </span><span class="cov8" title="1">{
                        container.Args[i] = strings.ReplaceAll(a, DefaultTargetNamespace, targetNamespace)
                }</span>
        }
}

// AddConfigMapValues will loop on the interface (should be a struct) and add the fields in to configMap
// the key will be the json tag of the struct field
func AddConfigMapValues(configMapName string, prop interface{}) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ConfigMap" || u.GetName() != configMapName || prop == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">cm := &amp;corev1.ConfigMap{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if cm.Data == nil </span><span class="cov8" title="1">{
                        cm.Data = map[string]string{}
                }</span>

                <span class="cov8" title="1">values := reflect.ValueOf(prop)
                // if the given properties is not struct type, do not proceed
                if values.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">for index := 0; index &lt; values.NumField(); index++ </span><span class="cov8" title="1">{
                        key := values.Type().Field(index).Tag.Get("json")
                        if strings.Contains(key, ",") </span><span class="cov8" title="1">{
                                key = strings.Split(key, ",")[0]
                        }</span>

                        <span class="cov8" title="1">if key == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">element := values.Field(index)
                        if element.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                if element.IsNil() </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                // empty string value will not be included in the following switch statement
                                // however, *string pointer can have empty("") string
                                // so copying the actual string value to the configMap, it can be a empty string too
                                <span class="cov8" title="1">if value, ok := element.Interface().(*string); ok </span><span class="cov8" title="1">{
                                        if value != nil </span><span class="cov8" title="1">{
                                                cm.Data[key] = *value
                                        }</span>
                                }
                                // extract the actual element from the pointer
                                <span class="cov8" title="1">element = values.Field(index).Elem()</span>
                        }

                        <span class="cov8" title="1">if !element.IsValid() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">_value := ""
                        switch element.Kind() </span>{
                        case reflect.Bool:<span class="cov8" title="1">
                                _value = strconv.FormatBool(element.Bool())</span>

                        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                                _value = strconv.FormatInt(element.Int(), 10)</span>

                        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                                _value = strconv.FormatUint(element.Uint(), 10)</span>

                        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                                _value = strconv.FormatFloat(element.Float(), 'f', 6, 64)</span>

                        case reflect.String:<span class="cov8" title="1">
                                _value = element.String()</span>

                        case reflect.Struct:<span class="cov8" title="1">
                                out, err := yaml.Marshal(element.Interface())
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to marshal struct field %s: %v", key, err)
                                }</span>
                                <span class="cov8" title="1">_value = string(out)</span>
                        }

                        <span class="cov8" title="1">if _value != "" </span><span class="cov8" title="1">{
                                cm.Data[key] = _value
                        }</span>
                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// InjectLabelOnNamespace will add a label on tekton-pipelines and
// openshift-pipelines namespace
func InjectLabelOnNamespace(label string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                kind := strings.ToLower(u.GetKind())
                if kind != "namespace" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">labels := u.GetLabels()
                arr := strings.Split(label, "=")
                labels[arr[0]] = arr[1]
                u.SetLabels(labels)

                return nil</span>
        }
}

func AddConfiguration(config v1alpha1.Config) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">d.Spec.Template.Spec.NodeSelector = config.NodeSelector
                d.Spec.Template.Spec.Tolerations = config.Tolerations
                d.Spec.Template.Spec.PriorityClassName = config.PriorityClassName

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// AddDeploymentRestrictedPSA will add the default restricted spec on Deployment to remove errors/warning
func AddDeploymentRestrictedPSA() mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if d.Spec.Template.Spec.SecurityContext == nil </span><span class="cov8" title="1">{
                        d.Spec.Template.Spec.SecurityContext = &amp;corev1.PodSecurityContext{}
                }</span>

                <span class="cov8" title="1">if d.Spec.Template.Spec.SecurityContext.RunAsNonRoot == nil </span><span class="cov8" title="1">{
                        d.Spec.Template.Spec.SecurityContext.RunAsNonRoot = ptr.Bool(runAsNonRootValue)
                }</span>

                <span class="cov8" title="1">if d.Spec.Template.Spec.SecurityContext.SeccompProfile == nil </span><span class="cov8" title="1">{
                        d.Spec.Template.Spec.SecurityContext.SeccompProfile = &amp;corev1.SeccompProfile{
                                Type: corev1.SeccompProfileTypeRuntimeDefault,
                        }
                }</span>

                <span class="cov8" title="1">for i := range d.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        c := &amp;d.Spec.Template.Spec.Containers[i]
                        if c.SecurityContext == nil </span><span class="cov8" title="1">{
                                c.SecurityContext = &amp;corev1.SecurityContext{}
                        }</span>
                        <span class="cov8" title="1">c.SecurityContext.AllowPrivilegeEscalation = ptr.Bool(allowPrivilegedEscalationValue)
                        c.SecurityContext.Capabilities = &amp;corev1.Capabilities{Drop: []corev1.Capability{"ALL"}}</span>
                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

// AddStatefulSetRestrictedPSA will add the default restricted spec on StatefulSet to remove errors/warning
func AddStatefulSetRestrictedPSA() mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if strings.ToLower(u.GetKind()) != "statefulset" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">s := &amp;appsv1.StatefulSet{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if s.Spec.Template.Spec.SecurityContext == nil </span><span class="cov8" title="1">{
                        s.Spec.Template.Spec.SecurityContext = &amp;corev1.PodSecurityContext{}
                }</span>

                <span class="cov8" title="1">if s.Spec.Template.Spec.SecurityContext.RunAsNonRoot == nil </span><span class="cov8" title="1">{
                        s.Spec.Template.Spec.SecurityContext.RunAsNonRoot = ptr.Bool(runAsNonRootValue)
                }</span>

                <span class="cov8" title="1">if s.Spec.Template.Spec.SecurityContext.SeccompProfile == nil </span><span class="cov8" title="1">{
                        s.Spec.Template.Spec.SecurityContext.SeccompProfile = &amp;corev1.SeccompProfile{
                                Type: corev1.SeccompProfileTypeRuntimeDefault,
                        }
                }</span>

                <span class="cov8" title="1">for i := range s.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        c := &amp;s.Spec.Template.Spec.Containers[i]
                        if c.SecurityContext == nil </span><span class="cov8" title="1">{
                                c.SecurityContext = &amp;corev1.SecurityContext{}
                        }</span>
                        <span class="cov8" title="1">c.SecurityContext.AllowPrivilegeEscalation = ptr.Bool(allowPrivilegedEscalationValue)
                        c.SecurityContext.Capabilities = &amp;corev1.Capabilities{Drop: []corev1.Capability{"ALL"}}</span>
                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

// AddJobRestrictedPSA will add the default restricted spec on Job to remove errors/warning
func AddJobRestrictedPSA() mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                if u.GetKind() != "Job" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">jb := &amp;batchv1.Job{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if jb.Spec.Template.Spec.SecurityContext == nil </span><span class="cov0" title="0">{
                        jb.Spec.Template.Spec.SecurityContext = &amp;corev1.PodSecurityContext{}
                }</span>

                <span class="cov0" title="0">if jb.Spec.Template.Spec.SecurityContext.RunAsNonRoot == nil </span><span class="cov0" title="0">{
                        jb.Spec.Template.Spec.SecurityContext.RunAsNonRoot = ptr.Bool(runAsNonRootValue)
                }</span>

                <span class="cov0" title="0">if jb.Spec.Template.Spec.SecurityContext.SeccompProfile == nil </span><span class="cov0" title="0">{
                        jb.Spec.Template.Spec.SecurityContext.SeccompProfile = &amp;corev1.SeccompProfile{
                                Type: corev1.SeccompProfileTypeRuntimeDefault,
                        }
                }</span>

                <span class="cov0" title="0">for i := range jb.Spec.Template.Spec.Containers </span><span class="cov0" title="0">{
                        c := &amp;jb.Spec.Template.Spec.Containers[i]
                        if c.SecurityContext == nil </span><span class="cov0" title="0">{
                                c.SecurityContext = &amp;corev1.SecurityContext{}
                        }</span>
                        <span class="cov0" title="0">if c.SecurityContext.AllowPrivilegeEscalation == nil </span><span class="cov0" title="0">{
                                c.SecurityContext.AllowPrivilegeEscalation = ptr.Bool(allowPrivilegedEscalationValue)
                        }</span>
                        <span class="cov0" title="0">if c.SecurityContext.Capabilities == nil </span><span class="cov0" title="0">{
                                c.SecurityContext.Capabilities = &amp;corev1.Capabilities{Drop: []corev1.Capability{"ALL"}}
                        }</span>
                }
                <span class="cov0" title="0">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

// CopyConfigMap will copy all the values from the passed configmap to the configmap
// in the manifest and any extra fields will be added in the manifest
func CopyConfigMap(configMapName string, expectedValues map[string]string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                kind := strings.ToLower(u.GetKind())
                if kind != "configmap" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if u.GetName() != configMapName || len(expectedValues) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">cm := &amp;corev1.ConfigMap{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if cm.Data == nil </span><span class="cov0" title="0">{
                        cm.Data = map[string]string{}
                }</span>

                <span class="cov8" title="1">for key, value := range expectedValues </span><span class="cov8" title="1">{
                        // updates values , if the key is found,
                        // adds key and value, if the key is not found
                        cm.Data[key] = value
                }</span>
                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

func ReplaceDeploymentArg(deploymentName, existingArg, newArg string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if u.GetName() != deploymentName </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for i, arg := range d.Spec.Template.Spec.Containers[0].Args </span><span class="cov8" title="1">{
                        if arg == existingArg </span><span class="cov8" title="1">{
                                d.Spec.Template.Spec.Containers[0].Args[i] = newArg
                        }</span>
                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

// replaces the namespace in serviceAccount
func ReplaceNamespaceInServiceAccount(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ServiceAccount" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // update namespace
                <span class="cov8" title="1">u.SetNamespace(targetNamespace)

                return nil</span>
        }
}

// replaces the namespace in clusterRoleBinding
func ReplaceNamespaceInClusterRoleBinding(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ClusterRoleBinding" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">crb := &amp;rbacv1.ClusterRoleBinding{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, crb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // update namespace
                <span class="cov8" title="1">for index := range crb.Subjects </span><span class="cov8" title="1">{
                        crb.Subjects[index].Namespace = targetNamespace
                }</span>

                <span class="cov8" title="1">obj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(crb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(obj)
                return nil</span>
        }
}

// updates "metadata.namespace" and under "spec"
// TODO: we have different transformer for each kind
// TODO: replaces all the existing transformers(used to update namespace) with this.
func ReplaceNamespace(newNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                // update metadata.namespace for all the resources
                // this change will be updated in cluster wide resource too
                // there is no effect on updating namespace on cluster wide resource
                u.SetNamespace(newNamespace)

                switch u.GetKind() </span>{
                case "ClusterRoleBinding":<span class="cov8" title="1">
                        crb := &amp;rbacv1.ClusterRoleBinding{}
                        err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, crb)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // update namespace
                        <span class="cov8" title="1">for index := range crb.Subjects </span><span class="cov8" title="1">{
                                crb.Subjects[index].Namespace = newNamespace
                        }</span>

                        <span class="cov8" title="1">obj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(crb)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">u.SetUnstructuredContent(obj)</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}

// AddSecretData adds the given data and annotations to the Secret object.
func AddSecretData(data map[string][]byte, annotations map[string]string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                // If input data is empty, do not transform
                if len(data) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Check if the resource is a Secret
                <span class="cov8" title="1">if u.GetKind() != "Secret" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Convert unstructured to Secret
                <span class="cov8" title="1">secret := &amp;corev1.Secret{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, secret)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update the Secret's data only if it is nil or empty
                <span class="cov8" title="1">if len(secret.Data) == 0 </span><span class="cov8" title="1">{
                        secret.Data = data
                }</span>

                // Update the Secret's annotations
                <span class="cov8" title="1">if secret.Annotations == nil </span><span class="cov8" title="1">{
                        secret.Annotations = make(map[string]string)
                }</span>
                <span class="cov8" title="1">for key, value := range annotations </span><span class="cov8" title="1">{
                        secret.Annotations[key] = value
                }</span>

                // Convert back to unstructured
                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(secret)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Update the original unstructured object
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// ConvertDeploymentToStatefulSet converts a Deployment to a StatefulSet with given parameters
func ConvertDeploymentToStatefulSet(controllerName, serviceName string) mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                if u.GetKind() != "Deployment" || u.GetName() != controllerName </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">ss := &amp;appsv1.StatefulSet{
                        TypeMeta: metav1.TypeMeta{
                                Kind:       "StatefulSet",
                                APIVersion: appsv1.SchemeGroupVersion.Group + "/" + appsv1.SchemeGroupVersion.Version,
                        },
                        ObjectMeta: d.ObjectMeta,
                        Spec: appsv1.StatefulSetSpec{
                                Selector:    d.Spec.Selector,
                                ServiceName: serviceName,
                                Template:    d.Spec.Template,
                                Replicas:    d.Spec.Replicas,
                                UpdateStrategy: appsv1.StatefulSetUpdateStrategy{
                                        Type: appsv1.RollingUpdateStatefulSetStrategyType,
                                },
                        },
                }

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(ss)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// AddStatefulEnvVars adds environment variables to the statefulset based on given parameters
func AddStatefulEnvVars(controllerName, serviceName, statefulServiceEnvVar, controllerOrdinalEnvVar string) mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                if u.GetKind() != "StatefulSet" || u.GetName() != controllerName </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">ss := &amp;appsv1.StatefulSet{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, ss)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">newEnvVars := []corev1.EnvVar{
                        {
                                Name:  statefulServiceEnvVar,
                                Value: serviceName,
                        },
                        {
                                Name: controllerOrdinalEnvVar,
                                ValueFrom: &amp;corev1.EnvVarSource{
                                        FieldRef: &amp;corev1.ObjectFieldSelector{
                                                FieldPath: "metadata.name",
                                        },
                                },
                        },
                }

                if len(ss.Spec.Template.Spec.Containers) &gt; 0 </span><span class="cov0" title="0">{
                        ss.Spec.Template.Spec.Containers[0].Env = append(ss.Spec.Template.Spec.Containers[0].Env, newEnvVars...)
                }</span>

                <span class="cov0" title="0">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(ss)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// updates performance flags/args into deployment and container given as args
// and leader election config as pod labels into a Deployment, ensuring that any changes trigger a rollout.
// It also updates the replica count if specified in the performanceSpec.
func UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(performanceSpec *v1alpha1.PerformanceProperties, leaderConfig, deploymentName, containerName string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" || u.GetName() != deploymentName </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // holds the flags needs to be added in the container args section
                <span class="cov8" title="1">flags := map[string]interface{}{}

                // convert struct to map with json tag
                // so that, we can map the arguments as is
                if err := StructToMap(&amp;performanceSpec.DeploymentPerformanceArgs, &amp;flags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // if there is no flags to update, return from here
                <span class="cov8" title="1">if len(flags) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // convert unstructured object to deployment
                <span class="cov8" title="1">dep := &amp;appsv1.Deployment{}
                err := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // include config-leader-election data into deployment pod label
                // so that pods will be recreated, if there is a change in "buckets"
                <span class="cov8" title="1">leaderElectionConfigMapData := map[string]interface{}{}
                if err = StructToMap(&amp;performanceSpec.PerformanceLeaderElectionConfig, &amp;leaderElectionConfigMapData); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">podLabels := dep.Spec.Template.Labels
                if podLabels == nil </span><span class="cov0" title="0">{
                        podLabels = map[string]string{}
                }</span>
                // sort data keys in an order, to get the consistent hash value in installerset
                <span class="cov8" title="1">labelKeys := getSortedKeys(leaderElectionConfigMapData)
                for _, key := range labelKeys </span><span class="cov8" title="1">{
                        value := leaderElectionConfigMapData[key]
                        labelKey := fmt.Sprintf("%s.data.%s", leaderConfig, key)
                        podLabels[labelKey] = fmt.Sprintf("%v", value)
                }</span>
                <span class="cov8" title="1">dep.Spec.Template.Labels = podLabels

                // update replicas, if available
                if performanceSpec.Replicas != nil </span><span class="cov0" title="0">{
                        dep.Spec.Replicas = ptr.Int32(*performanceSpec.Replicas)
                }</span>

                // include it in the pods label, that will recreate all the pods, if there is a change in replica count
                <span class="cov8" title="1">if dep.Spec.Replicas != nil </span><span class="cov8" title="1">{
                        dep.Spec.Template.Labels["deployment.spec.replicas"] = fmt.Sprintf("%d", *dep.Spec.Replicas)
                }</span>

                // sort flag keys in an order, to get the consistent hash value in installerset
                <span class="cov8" title="1">flagKeys := getSortedKeys(flags)
                // update performance arguments into target container
                for containerIndex, container := range dep.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if container.Name != containerName </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, flagKey := range flagKeys </span><span class="cov8" title="1">{
                                // update the arg name with "-" prefix
                                expectedArg := fmt.Sprintf("-%s", flagKey)
                                argStringValue := fmt.Sprintf("%v", flags[flagKey])

                                // skip deprecated disable-ha flag if not pipelinesControllerDeployment
                                // should be removed when the flag is removed from pipelines controller
                                // we can use this logic incase we need to skip it for other controllers as well here
                                if deploymentName != pipelinesControllerDeployment &amp;&amp; flagKey == "disable-ha" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">argUpdated := false
                                for argIndex, existingArg := range container.Args </span><span class="cov8" title="1">{
                                        if strings.HasPrefix(existingArg, expectedArg) </span><span class="cov8" title="1">{
                                                container.Args[argIndex] = fmt.Sprintf("%s=%s", expectedArg, argStringValue)
                                                argUpdated = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !argUpdated </span><span class="cov8" title="1">{
                                        container.Args = append(container.Args, fmt.Sprintf("%s=%s", expectedArg, argStringValue))
                                }</span>
                        }
                        <span class="cov8" title="1">dep.Spec.Template.Spec.Containers[containerIndex] = container</span>
                }

                // convert deployment to unstructured object
                <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(obj)

                return nil</span>
        }
}

// sort keys in an order, to get the consistent hash value in installerset
func getSortedKeys(input map[string]interface{}) []string <span class="cov8" title="1">{
        keys := []string{}
        for key := range input </span><span class="cov8" title="1">{
                keys = append(keys, key)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        return keys</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

// namespacedResource is an unstructured resource with the given apiVersion, kind, ns and name.
func namespacedResource(apiVersion, kind, ns, name string) unstructured.Unstructured <span class="cov8" title="1">{
        resource := unstructured.Unstructured{}
        resource.SetAPIVersion(apiVersion)
        resource.SetKind(kind)
        resource.SetNamespace(ns)
        resource.SetName(name)
        return resource
}</span>

// clusterScopedResource is an unstructured resource with the given apiVersion, kind and name.
func clusterScopedResource(apiVersion, kind, name string) unstructured.Unstructured <span class="cov8" title="1">{
        return namespacedResource(apiVersion, kind, "", name)
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "encoding/json"
        "fmt"
        "slices"

        mf "github.com/manifestival/manifestival"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

type VersionError error

var (
        errConfigMap VersionError = fmt.Errorf("version information could not be determined from ConfigMap")
)

func IsFetchVersionError(err error) bool <span class="cov0" title="0">{
        return err == errConfigMap
}</span>

// FetchVersionFromConfigMap finds the component version from the ConfigMap data field. It looks
// for the version key in the ConfigMap and if the ConfigMap or version key is not found
// then return the error.
func FetchVersionFromConfigMap(manifest mf.Manifest, configMapName string) (string, error) <span class="cov8" title="1">{
        configMaps := manifest.Filter(mf.ByKind("ConfigMap"), mf.ByName(configMapName))

        if len(configMaps.Resources()) == 0 </span><span class="cov8" title="1">{
                return "", errConfigMap
        }</span>

        <span class="cov8" title="1">versionConfigMap := configMaps.Resources()[0]
        dataObj, _, _ := unstructured.NestedStringMap(versionConfigMap.Object, "data")
        version := dataObj["version"]

        if version != "" </span><span class="cov8" title="1">{
                return version, nil
        }</span>

        <span class="cov8" title="1">return "", errConfigMap</span>
}

// converts struct to map with json encoding
func StructToMap(in, out interface{}) error <span class="cov8" title="1">{
        data, err := json.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(data, out)</span>
}

// Helper function to serialize labels map to JSON string
func SerializeLabelsToJSON(labels map[string]string) (string, error) <span class="cov8" title="1">{
        bytes, err := json.Marshal(labels)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to serialize labels to JSON: %v", err)
        }</span>
        <span class="cov8" title="1">return string(bytes), nil</span>
}

// AddOrReplaceInList appends newItem to the provided list. If the new item exists in the list then the original
// copy of the item is removed from the list before the new copy is appended. The identityFunc parameter is used
// to uniquely identify an item during comparison.
func AddOrReplaceInList[T any, V comparable](items []T, newItem T, identityFunc func(T) V) []T <span class="cov8" title="1">{
        newItemIdentity := identityFunc(newItem)
        for i, item := range items </span><span class="cov8" title="1">{
                itemIdentity := identityFunc(item)
                if itemIdentity == newItemIdentity </span><span class="cov8" title="1">{
                        items = slices.Delete(items, i, i+1)
                        break</span>
                }
        }
        <span class="cov8" title="1">return append(items, newItem)</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package kubernetesplatform

import (
        "github.com/tektoncd/operator/pkg/reconciler/platform"
)

// KubernetesPlatform defines basic configuration for a Vanila Kubernetes platform
type KubernetesPlatform struct {
        platform.PlatformConfig
        supportedControllers platform.ControllerMap
}

// NewKubernetesPlatform returns an instance of KubernetesPlatform
func NewKubernetesPlatform(pc platform.PlatformConfig) *KubernetesPlatform <span class="cov0" title="0">{
        plt := KubernetesPlatform{
                supportedControllers: kubernetesControllers,
        }
        plt.PlatformConfig = pc
        plt.PlatformConfig.Name = PlatformNameKubernetes
        return &amp;plt
}</span>

// AllSupportedControllers returns a platform.ControllerMap of all controllers (reconcilers) of tektoncd/operator
// supported by Vanila Kubernetes
func (kp *KubernetesPlatform) AllSupportedControllers() platform.ControllerMap <span class="cov0" title="0">{
        return kp.supportedControllers
}</span>

// PlatformParams return platform.PlatformConfig of a KubernetesPlatform
func (kp *KubernetesPlatform) PlatformParams() platform.PlatformConfig <span class="cov0" title="0">{
        return kp.PlatformConfig
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manualapprovalgate

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        manualapprovalgateinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/manualapprovalgate"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        manualapprovalgatereconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/manualapprovalgate"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const versionConfigMap = "manual-approval-gate-info"

func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, w configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }

                manifest, ver := ctrl.InitController(ctx, common.PayloadOptions{})
                if ver == common.ReleaseVersionUnknown </span><span class="cov0" title="0">{
                        ver = "devel"
                }</span>

                <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">metrics, _ := NewRecorder()

                tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()

                c := &amp;Reconciler{
                        operatorClientSet:         operatorclient.Get(ctx),
                        kubeClientSet:             kubeclient.Get(ctx),
                        extension:                 generator(ctx),
                        manifest:                  manifest,
                        installerSetClient:        client.NewInstallerSetClient(tisClient, operatorVer, ver, v1alpha1.KindManualApprovalGate, metrics),
                        pipelineInformer:          tektonPipelineinformer.Get(ctx),
                        operatorVersion:           operatorVer,
                        manualApprovalGateVersion: ver,
                }
                impl := manualapprovalgatereconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for ManualApprovalGate")

                if _, err := manualapprovalgateinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register ManualApprovalGate informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.ManualApprovalGate{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manualapprovalgate

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        manualapprovalgatereconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/manualapprovalgate"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

var _ manualapprovalgatereconciler.Finalizer = (*Reconciler)(nil)

// FinalizeKind removes all resources after deletion of a ManualApprovalGate CR.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.ManualApprovalGate) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        //Delete CRDs before deleting rest of resources so that any instance
        //of CRDs which has finalizer set will get deleted before we remove
        //the controller;s deployment for it
        if err := r.manifest.Filter(mf.CRDs).Delete(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to deleted CRDs for ManualApprovalGate")
                return err
        }</span>

        <span class="cov0" title="0">if err := r.installerSetClient.CleanupMainSet(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to cleanup main installerset: ", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manualapprovalgate

import "go.uber.org/zap"

type Recorder struct {
}

func NewRecorder() (*Recorder, error) <span class="cov0" title="0">{
        return &amp;Recorder{}, nil
}</span>

func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {<span class="cov0" title="0">
        // TODO
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manualapprovalgate

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        pipelineinformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        manualapprovalgatereconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/manualapprovalgate"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

type Reconciler struct {
        // kube client to interact with core k8s resources
        kubeClientSet kubernetes.Interface
        // operatorClientSet allows us to configure operator objects
        operatorClientSet clientset.Interface
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // manifest has the source manifest of ManualApprovalGate for a
        // particular version
        manifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension common.Extension
        // manualApprovalGateVersion describes the current manualapprovalgate version
        manualApprovalGateVersion string
        operatorVersion           string
        // pipelineInformer provides access to a shared informer and lister for
        // TektonPipelines
        pipelineInformer pipelineinformer.TektonPipelineInformer
}

// Check that our Reconciler implements controller.Reconciler
var _ manualapprovalgatereconciler.Interface = (*Reconciler)(nil)

func (r *Reconciler) ReconcileKind(ctx context.Context, mag *v1alpha1.ManualApprovalGate) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("manualapprovalgate", mag.GetName())

        logger.Debugw("Starting ManualApprovalGate reconciliation",
                "version", r.manualApprovalGateVersion,
                "status", mag.Status.GetCondition(apis.ConditionReady))

        mag.Status.InitializeConditions()
        mag.Status.SetVersion(r.manualApprovalGateVersion)

        if mag.GetName() != v1alpha1.ManualApprovalGates </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.ManualApprovalGates,
                        mag.GetName(),
                )
                logger.Errorw("Invalid resource name", "expectedName", v1alpha1.ManualApprovalGates, "actualName", mag.GetName())
                mag.Status.MarkNotReady(msg)
                return nil
        }</span>

        // reconcile target namespace
        <span class="cov0" title="0">logger.Debug("Reconciling target namespace")
        if err := common.ReconcileTargetNamespace(ctx, nil, nil, mag, r.kubeClientSet); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to reconcile target namespace", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Info("Target namespace reconciled successfully")

        //Make sure TektonPipeline is installed before proceeding with
        //ManualApprovalGate
        logger.Debug("Checking Tekton Pipeline dependency")
        if _, err := common.PipelineReady(r.pipelineInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        logger.Infow("Tekton Pipeline dependency not ready yet", "error", err)
                        mag.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
                        // wait for pipeline status to change
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                // (tektonpipeline.operator.tekton.dev instance not available yet)
                <span class="cov0" title="0">logger.Errorw("Tekton Pipeline dependency missing", "error", err)
                mag.Status.MarkDependencyMissing("tekton-pipelines does not exist")
                return err</span>
        }
        <span class="cov0" title="0">logger.Info("All dependencies installed successfully")
        mag.Status.MarkDependenciesInstalled()

        logger.Debug("Removing obsolete installer sets")
        if err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to remove obsolete installer sets", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Obsolete installer sets removed")

        logger.Debug("Executing pre-reconciliation")
        if err := r.extension.PreReconcile(ctx, mag); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PreReconciliation failed: %s", err.Error())
                logger.Errorw("Pre-reconciliation failed", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Info("Pre-reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">mag.Status.MarkPreReconcilerFailed(msg)
                return nil</span>
        }

        <span class="cov0" title="0">logger.Info("Pre-reconciliation completed successfully")
        mag.Status.MarkPreReconcilerComplete()

        if err := r.installerSetClient.MainSet(ctx, mag, &amp;r.manifest, filterAndTransform(r.extension)); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Main Reconcilation failed: %s", err.Error())
                logger.Errorw("Failed to apply main installer set", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Info("Main reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">mag.Status.MarkInstallerSetNotReady(msg)
                return nil</span>
        }
        <span class="cov0" title="0">logger.Info("Main manifest applied successfully")

        logger.Debug("Executing post-reconciliation")
        if err := r.extension.PostReconcile(ctx, mag); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                logger.Errorw("Post-reconciliation failed", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Info("Post-reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">mag.Status.MarkPostReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PostReconcile Complete
        <span class="cov0" title="0">logger.Info("Post-reconciliation completed successfully")
        mag.Status.MarkPostReconcilerComplete()

        logger.Info("ManualApprovalGate reconciliation completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manualapprovalgate

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                magCR := comp.(*v1alpha1.ManualApprovalGate)
                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ManualApprovalGatePrefix))
                magImages := common.ImageRegistryDomainOverride(imagesRaw)
                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.ManualApprovalGates),
                        common.DeploymentImages(magImages),
                        common.DeploymentEnvVarKubernetesMinVersion(),
                        common.AddDeploymentRestrictedPSA(),
                }
                extra = append(extra, extension.Transformers(magCR)...)
                err := common.Transform(ctx, manifest, magCR, extra...)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov0" title="0">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, magCR.Spec.GetTargetNamespace(), magCR.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov0" title="0">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonchain

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonChaininformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonchain"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        tektonChainreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonchain"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

// chains-info stores the version of Chains installed in the cluster
const versionConfigMap = "chains-info"

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }

                manifest, chainVer := ctrl.InitController(ctx, common.PayloadOptions{})
                if chainVer == common.ReleaseVersionUnknown </span><span class="cov0" title="0">{
                        chainVer = "devel"
                }</span>

                <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>
                <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()

                metrics, err := NewRecorder()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">c := &amp;Reconciler{
                        operatorClientSet:  operatorclient.Get(ctx),
                        installerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, chainVer, v1alpha1.KindTektonChain, metrics),
                        extension:          generator(ctx),
                        manifest:           manifest,
                        pipelineInformer:   tektonPipelineinformer.Get(ctx),
                        operatorVersion:    operatorVer,
                        chainVersion:       chainVer,
                        recorder:           metrics,
                }
                impl := tektonChainreconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for Tekton Chain")

                if _, err := tektonChaininformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonChain informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonChain{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonchain

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (r *Reconciler) createSecretInstallerSet(ctx context.Context, tc *v1alpha1.TektonChain) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{

        manifest := r.manifest
        // filter only secret for this installerset as this needs
        // to be restored over upgrade
        manifest = manifest.Filter(mf.ByKind("Secret"))
        transformer := filterAndTransform(r.extension)
        if _, err := transformer(ctx, &amp;manifest, tc); err != nil </span><span class="cov0" title="0">{
                tc.Status.MarkNotReady("transformation failed: " + err.Error())
                return nil, err
        }</span>

        // generate installer set
        <span class="cov0" title="0">tis := makeInstallerSet(tc, manifest, secretChainInstallerset, "", r.operatorVersion)

        // Add annoation to secret installer set in case the generate secret signing is set to true
        if tc.Spec.GenerateSigningSecret </span><span class="cov0" title="0">{
                tis.Annotations[secretTISSigningAnnotation] = "true"
        }</span>

        // create installer set
        <span class="cov0" title="0">createdIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, tis, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return createdIs, nil</span>
}

func (r *Reconciler) createConfigInstallerSet(ctx context.Context, tc *v1alpha1.TektonChain) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        manifest := r.manifest

        // remove secret from this installerset as this installerset will be deleted on upgrade
        manifest = manifest.Filter(mf.ByKind("ConfigMap"), mf.ByName("chains-config"))
        transformer := filterAndTransform(r.extension)
        if _, err := transformer(ctx, &amp;manifest, tc); err != nil </span><span class="cov0" title="0">{
                tc.Status.MarkNotReady("transformation failed: " + err.Error())
                return nil, err
        }</span>

        // generate installer set
        <span class="cov0" title="0">tis := makeInstallerSet(tc, manifest, configChainInstallerset, "", r.operatorVersion)

        // compute the hash of tektonchain spec and store as an annotation
        // in further reconciliation we compute hash of tc spec and check with
        // annotation, if they are same then we skip updating the object
        // otherwise we update the manifest
        specHash, err := hash.Compute(tc.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tis.Annotations[v1alpha1.LastAppliedHashKey] = specHash

        // create installer set
        createdIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, tis, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return createdIs, nil</span>

}

func (r *Reconciler) createInstallerSet(ctx context.Context, tc *v1alpha1.TektonChain) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{

        manifest := r.manifest
        // installerSet adds it's owner as namespace's owner
        // so deleting tekton chain deletes target namespace too
        // to skip it we filter out namespace if pipeline have same namespace
        pipelineNamespace, err := common.PipelineTargetNamspace(r.pipelineInformer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if tc.Spec.GetTargetNamespace() == pipelineNamespace </span><span class="cov0" title="0">{
                manifest = manifest.Filter(mf.Not(mf.ByKind("Namespace")))
        }</span>

        // remove secret and `chains-config` configMap from this installerset as this installerset will be deleted on upgrade
        <span class="cov0" title="0">manifest = manifest.Filter(mf.Not(mf.ByKind("Secret")),
                mf.Not(mf.All(mf.ByName("chains-config"), mf.ByKind("ConfigMap"))))

        transformer := filterAndTransform(r.extension)
        if _, err = transformer(ctx, &amp;manifest, tc); err != nil </span><span class="cov0" title="0">{
                tc.Status.MarkNotReady("transformation failed: " + err.Error())
                return nil, err
        }</span>

        // set installerSet installType: deployment or statefulset
        <span class="cov0" title="0">installerSetInstallType := client.InstallerSubTypeDeployment
        if tc.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *tc.Spec.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                installerSetInstallType = client.InstallerSubTypeStatefulset
        }</span>
        // generate installer set
        <span class="cov0" title="0">tis := makeInstallerSet(tc, manifest, v1alpha1.ChainResourceName, installerSetInstallType, r.operatorVersion)

        // compute the hash of tektonchain spec and store as an annotation
        // in further reconciliation we compute hash of tc spec and check with
        // annotation, if they are same then we skip updating the object
        // otherwise we update the manifest
        specHash, err := hash.Compute(tc.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tis.Annotations[v1alpha1.LastAppliedHashKey] = specHash

        // create installer set
        createdIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, tis, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return createdIs, nil</span>
}

func makeInstallerSet(tc *v1alpha1.TektonChain, manifest mf.Manifest, installerSetType, installerSetInstallType, releaseVersion string) *v1alpha1.TektonInstallerSet <span class="cov0" title="0">{
        ownerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())
        labels := map[string]string{
                v1alpha1.CreatedByKey:      createdByValue,
                v1alpha1.ReleaseVersionKey: releaseVersion,
                v1alpha1.InstallerSetType:  installerSetType,
        }

        if installerSetInstallType != "" </span><span class="cov0" title="0">{
                labels[v1alpha1.InstallerSetInstallType] = installerSetInstallType
        }</span>
        <span class="cov0" title="0">return &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-", installerSetType),
                        Labels:       labels,
                        Annotations: map[string]string{
                                v1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonchain

import (
        "context"
        "fmt"
        "time"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        "knative.dev/pkg/metrics"
)

var (
        rReconcileCount = stats.Float64("chains_reconciled",
                "metrics of chains reconciled with labels",
                stats.UnitDimensionless)
)

// Recorder holds keys for Tekton metrics
type Recorder struct {
        initialized        bool
        version            tag.Key
        taskrunFormat      tag.Key
        taskrunStorage     tag.Key
        taskrunSigner      tag.Key
        pipelinerunFormat  tag.Key
        pipelinerunStorage tag.Key
        pipelinerunSigner  tag.Key
        ociFormat          tag.Key
        ociStorage         tag.Key
        ociSigner          tag.Key

        ReportingPeriod time.Duration
}

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder() (*Recorder, error) <span class="cov0" title="0">{
        r := &amp;Recorder{
                initialized: true,

                // Default to 30s intervals.
                ReportingPeriod: 30 * time.Second,
        }

        version, err := tag.NewKey("version")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.version = version

        taskrunFormat, err := tag.NewKey("taskrun_format")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.taskrunFormat = taskrunFormat

        taskrunStorage, err := tag.NewKey("taskrun_storage")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.taskrunStorage = taskrunStorage

        taskrunSigner, err := tag.NewKey("taskrun_signer")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.taskrunSigner = taskrunSigner

        pipelinerunFormat, err := tag.NewKey("pipelinerun_format")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.pipelinerunFormat = pipelinerunFormat

        pipelinerunStorage, err := tag.NewKey("pipelinerun_storage")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.pipelinerunStorage = pipelinerunStorage

        pipelinerunSigner, err := tag.NewKey("pipelinerun_signer")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.pipelinerunSigner = pipelinerunSigner

        ociFormat, err := tag.NewKey("oci_format")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.ociFormat = ociFormat

        ociStorage, err := tag.NewKey("oci_storage")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.ociStorage = ociStorage

        ociSigner, err := tag.NewKey("oci_signer")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.ociSigner = ociSigner

        err = view.Register(
                &amp;view.View{
                        Description: rReconcileCount.Description(),
                        Measure:     rReconcileCount,
                        Aggregation: view.Count(),
                        TagKeys: []tag.Key{r.version,
                                r.taskrunFormat, r.taskrunStorage, r.taskrunSigner,
                                r.pipelinerunFormat, r.pipelinerunStorage, r.pipelinerunSigner,
                                r.ociFormat, r.ociStorage, r.ociSigner},
                },
        )

        if err != nil </span><span class="cov0" title="0">{
                r.initialized = false
                return r, err
        }</span>

        <span class="cov0" title="0">return r, nil</span>
}

// Logs when chains is reconciled with version and
// config labels.
func (r *Recorder) Count(version string, spec v1alpha1.TektonChainSpec) error <span class="cov0" title="0">{
        if !r.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "ignoring the metrics recording for pipelinee failed to initialize the metrics recorder")
        }</span>

        <span class="cov0" title="0">var taskrunStorage, pipelinerunStorage, ociStorage string
        if spec.ArtifactsTaskRunStorage != nil </span><span class="cov0" title="0">{
                taskrunStorage = *spec.ArtifactsTaskRunStorage
        }</span>
        <span class="cov0" title="0">if spec.ArtifactsPipelineRunStorage != nil </span><span class="cov0" title="0">{
                pipelinerunStorage = *spec.ArtifactsPipelineRunStorage
        }</span>
        <span class="cov0" title="0">if spec.ArtifactsOCIStorage != nil </span><span class="cov0" title="0">{
                ociStorage = *spec.ArtifactsOCIStorage
        }</span>

        <span class="cov0" title="0">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.version, version),
                tag.Insert(r.taskrunFormat, spec.ArtifactsTaskRunFormat),
                tag.Insert(r.taskrunStorage, taskrunStorage),
                tag.Insert(r.taskrunSigner, spec.ArtifactsTaskRunSigner),
                tag.Insert(r.pipelinerunFormat, spec.ArtifactsPipelineRunFormat),
                tag.Insert(r.pipelinerunStorage, pipelinerunStorage),
                tag.Insert(r.pipelinerunSigner, spec.ArtifactsPipelineRunSigner),
                tag.Insert(r.ociFormat, spec.ArtifactsOCIFormat),
                tag.Insert(r.ociStorage, ociStorage),
                tag.Insert(r.ociSigner, spec.ArtifactsOCISigner),
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metrics.Record(ctx, rReconcileCount.M(1))
        return nil</span>
}

func (m *Recorder) LogMetricsWithSpec(version string, spec v1alpha1.TektonChainSpec, logger *zap.SugaredLogger) <span class="cov0" title="0">{
        err := m.Count(version, spec)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("%v: Failed to log the metrics : %v", v1alpha1.KindTektonResult, err)
        }</span>
}

func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) <span class="cov0" title="0">{
        var newSpec v1alpha1.TektonChainSpec
        err := m.Count(status, newSpec)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("%v: Failed to log the metrics : %v", resourceKind, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonchain

import (
        "context"
        "crypto/rand"
        "encoding/base64"
        "fmt"
        "strconv"

        "github.com/sigstore/cosign/v2/pkg/cosign"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        pipelineinformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        tektonchainreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonchain"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        resourceKind = v1alpha1.KindTektonChain

        // Chains ConfigMap
        ChainsConfig = "chains-config"
        // Chains Container Name
        chainsContainerName = "tekton-chains-controller"
        // Deployment Name
        chainsDeploymentName = "tekton-chains-controller"

        // secret installer set additional Annotation
        secretTISSigningAnnotation = "operator.tekton.dev/generated-signing-secret"

        // The number of random bytes we'll generate (before encoding) for the Cosign passphrase.
        defaultCosignPasswordLength = 16
)

// Reconciler implements controller.Reconciler for TektonChain resources.
type Reconciler struct {
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient

        // operatorClientSet allows us to configure operator objects
        operatorClientSet clientset.Interface
        // manifest has the source manifest of Tekton Triggers for a
        // particular version
        manifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension common.Extension
        // chainVersion describes the current chain version
        chainVersion    string
        operatorVersion string
        // pipelineInformer provides access to a shared informer and lister for
        // TektonPipelines
        pipelineInformer pipelineinformer.TektonPipelineInformer
        // Metrics Recorder
        recorder *Recorder
}

// Check that our Reconciler implements controller.Reconciler
var _ tektonchainreconciler.Interface = (*Reconciler)(nil)
var _ tektonchainreconciler.Finalizer = (*Reconciler)(nil)

const (
        createdByValue          = "TektonChain"
        secretChainInstallerset = "chain-secret"
        configChainInstallerset = "chain-config"
)

var (
        ls = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     createdByValue,
                        v1alpha1.InstallerSetType: v1alpha1.ChainResourceName,
                },
        }
        secretLs = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     createdByValue,
                        v1alpha1.InstallerSetType: secretChainInstallerset,
                },
        }
        configLs = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     createdByValue,
                        v1alpha1.InstallerSetType: configChainInstallerset,
                },
        }
)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, tc *v1alpha1.TektonChain) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With(
                "name", tc.GetName(),
                "generation", tc.Generation,
                "namespace", tc.GetNamespace(),
        )
        defer r.recorder.LogMetricsWithSpec(r.chainVersion, tc.Spec, logger)

        tc.Status.InitializeConditions()
        tc.Status.ObservedGeneration = tc.Generation

        logger.Debugw("Starting TektonChain reconciliation", "status", tc.Status.GetCondition(apis.ConditionReady))

        if tc.GetName() != v1alpha1.ChainResourceName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.ChainResourceName,
                        tc.GetName(),
                )
                logger.Errorw("Invalid resource name", "expectedName", v1alpha1.ConfigResourceName, "actualName", tc.GetName())
                tc.Status.MarkNotReady(msg)
                return nil
        }</span>

        // find a valid TektonPipeline installation
        <span class="cov0" title="0">if _, err := common.PipelineReady(r.pipelineInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        tc.Status.MarkDependencyInstalling("TektonPipeline is still installing")
                        logger.Debug("Waiting for TektonPipeline installation")
                        return fmt.Errorf(common.PipelineNotReady)
                }</span>
                // tektonpipeline.operator.tekton.dev instance not available yet
                <span class="cov0" title="0">tc.Status.MarkDependencyMissing("TektonPipeline does not exist")
                logger.Errorw("TektonPipeline dependency check failed", "error", err)
                return err</span>
        }
        <span class="cov0" title="0">tc.Status.MarkDependenciesInstalled()
        logger.Debug("TektonPipeline dependency check completed successfully")

        // Pass the object through defaulting
        tc.SetDefaults(ctx)

        // Mark TektonChain Instance as Not Ready if an upgrade is needed
        if err := r.markUpgrade(ctx, tc); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Upgrade check failed", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.PreReconcile(ctx, tc); err != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("PreReconciliation failed: %s", err.Error())
                logger.Errorw("PreReconcile failed", "error", err)
                tc.Status.MarkPreReconcilerFailed(errMsg)
                return err
        }</span>

        // Mark PreReconcile Complete
        <span class="cov0" title="0">tc.Status.MarkPreReconcilerComplete()
        logger.Debug("PreReconcile completed successfully")

        // Fetching and deleting the chains tektoninstallerset to delete `chains-config` configMap
        // to handle the scenario when user upgrades i.e. in previous version `chains-config` configMap
        // installerset was not there and with latest version we create separate installerset for
        // `chains-config` configMap
        chainlabelSelector, err := common.LabelSelector(ls)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid chain label selector", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">existingChainInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, chainlabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to retrieve current chain installer set", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">if existingChainInstallerSet != "" </span><span class="cov0" title="0">{
                // If exists, then fetch the Tekton Chain InstallerSet
                installedTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, existingChainInstallerSet, metav1.GetOptions{})
                if err != nil &amp;&amp; apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Errorw("Chain InstallerSet not found", "name", existingChainInstallerSet)
                        return err
                }</span>

                <span class="cov0" title="0">if rv := installedTIS.Labels[v1alpha1.ReleaseVersionKey]; rv != r.operatorVersion </span><span class="cov0" title="0">{
                        logger.Infow("Deleting outdated InstallerSet", "name", existingChainInstallerSet, "currentVersion", rv, "expectedVersion", r.operatorVersion)
                        err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                Delete(ctx, existingChainInstallerSet, metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to delete outdated InstallerSet", "error", err)
                                return err
                        }</span>

                        <span class="cov0" title="0">if _, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, existingChainInstallerSet, metav1.GetOptions{}); err == nil </span><span class="cov0" title="0">{
                                tc.Status.MarkNotReady("Waiting for previous installer set to get deleted")
                                logger.Debugw("InstallerSet deletion pending", "name", existingChainInstallerSet)
                                return v1alpha1.REQUEUE_EVENT_AFTER
                        }</span> else<span class="cov0" title="0"> if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                logger.Errorw("Error confirming InstallerSet deletion", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Infow("Outdated InstallerSet successfully deleted")
                        return nil</span>
                }
        }

        // Check if a Tekton Chain Config InstallerSet already exists, if not then create one
        <span class="cov0" title="0">configLabelSector, err := common.LabelSelector(configLs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid chain config label selector", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">existingConfigInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, configLabelSector)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get config installer set name", "error", err, "selector", configLabelSector)
                return err
        }</span>
        <span class="cov0" title="0">if existingConfigInstallerSet == "" </span><span class="cov0" title="0">{
                tc.Status.MarkInstallerSetNotAvailable("Chain Config InstallerSet not available")
                logger.Infow("Creating new Chain Config InstallerSet", "targetNamespace", tc.Spec.TargetNamespace)

                createdIs, err := r.createConfigInstallerSet(ctx, tc)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create Config InstallerSet", "error", err)
                        return err
                }</span>

                <span class="cov0" title="0">return r.updateTektonChainStatus(tc, createdIs)</span>
        }

        // If exists, then fetch the Tekton Chain Config InstallerSet
        <span class="cov0" title="0">installedConfigTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Get(ctx, existingConfigInstallerSet, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Infow("Config InstallerSet not found, creating new one", "name", existingConfigInstallerSet)
                        createdIs, err := r.createConfigInstallerSet(ctx, tc)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to create Config InstallerSet", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Infow("Chain Config InstallerSet created successfully", "name", createdIs.GetName())
                        return r.updateTektonChainStatus(tc, createdIs)</span>
                }
                <span class="cov0" title="0">logger.Errorw("Failed to get Config InstallerSet", "name", existingConfigInstallerSet, "error", err)
                return err</span>
        }

        <span class="cov0" title="0">configInstallerSetTargetNamespace := installedConfigTIS.Annotations[v1alpha1.TargetNamespaceKey]
        configInstallerSetReleaseVersion := installedConfigTIS.Labels[v1alpha1.ReleaseVersionKey]

        // Check if TargetNamespace of existing Tekton Chain Config InstallerSet is same as expected
        // Check if Release Version in Tekton Chain Config InstallerSet is same as expected
        // If any of the above things is not same then delete the existing Tekton Chain InstallerSet
        // and create a new with expected properties

        if configInstallerSetTargetNamespace != tc.Spec.TargetNamespace || configInstallerSetReleaseVersion != r.operatorVersion </span><span class="cov0" title="0">{
                logger.Infow("Config InstallerSet needs update",
                        "name", existingConfigInstallerSet,
                        "currentNamespace", configInstallerSetTargetNamespace,
                        "expectedNamespace", tc.Spec.TargetNamespace,
                        "currentVersion", configInstallerSetReleaseVersion,
                        "expectedVersion", r.operatorVersion)
                // Delete the existing Tekton Chain InstallerSet
                err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Delete(ctx, existingConfigInstallerSet, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to delete Chains Config InstallerSet", "name", existingConfigInstallerSet, "error", err)
                        return err
                }</span>

                // Make sure the Tekton Chain Config InstallerSet is deleted
                <span class="cov0" title="0">_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, existingConfigInstallerSet, metav1.GetOptions{})
                if err == nil </span><span class="cov0" title="0">{
                        tc.Status.MarkNotReady("Waiting for previous installer set to get deleted")
                        logger.Debugw("Config InstallerSet deletion pending", "name", existingConfigInstallerSet)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to confirm Config InstallerSet deletion", "name", existingConfigInstallerSet, "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>

        } else<span class="cov0" title="0"> {
                // If target namespace and version are not changed then check if Chain
                // spec is changed by checking hash stored as annotation on
                // Tekton Chain InstallerSet with computing new hash of TektonChain Spec

                // Hash of TektonChain Spec
                expectedSpecHash, err := hash.Compute(tc.Spec)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to compute spec hash", "error", err)
                        return err
                }</span>

                // spec hash stored on installerSet
                <span class="cov0" title="0">lastAppliedHash := installedConfigTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]

                if lastAppliedHash != expectedSpecHash </span><span class="cov0" title="0">{
                        logger.Infow("Config spec changed, updating InstallerSet",
                                "name", installedConfigTIS.Name,
                                "oldHash", lastAppliedHash,
                                "newHash", expectedSpecHash)
                        if err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                Delete(ctx, installedConfigTIS.Name, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to delete outdated Config InstallerSet", "name", installedConfigTIS.Name, "error", err)
                                return err
                        }</span>

                        // after updating installer set enqueue after a duration
                        // to allow changes to get deployed
                        <span class="cov0" title="0">logger.Infow("Config InstallerSet deleted to apply spec changes", "name", installedConfigTIS.Name)
                        return v1alpha1.REQUEUE_EVENT_AFTER</span>
                }
                <span class="cov0" title="0">logger.Debugw("Config InstallerSet up to date", "name", installedConfigTIS.Name)</span>
        }

        // Chain controller is deployed as statefulset, ensure deployment installerset is deleted
        <span class="cov0" title="0">if tc.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *tc.Spec.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                if err := r.installerSetClient.CleanupWithLabelInstallTypeDeployment(ctx, v1alpha1.ChainResourceName); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to delete chain deployment installer set", "error", err, "resource", v1alpha1.ChainResourceName)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debugw("Using statefulset deployment type", "resource", v1alpha1.ChainResourceName)</span>
        } else<span class="cov0" title="0"> {
                // Chain controller is deployed as deployment, ensure statefulset installerset is deleted
                if err := r.installerSetClient.CleanupWithLabelInstallTypeStatefulset(ctx, v1alpha1.ChainResourceName); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to delete chain statefulset installer set", "error", err, "resource", v1alpha1.ChainResourceName)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debugw("Using standard deployment type", "resource", v1alpha1.ChainResourceName)</span>
        }

        // Check if a Tekton Chain InstallerSet already exists, if not then create one
        <span class="cov0" title="0">labelSelector, err := common.LabelSelector(ls)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid label selector", "error", err, "selector", ls)
                return err
        }</span>
        <span class="cov0" title="0">existingInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get current installer set name", "error", err, "selector", labelSelector)
                return err
        }</span>

        <span class="cov0" title="0">if existingInstallerSet == "" </span><span class="cov0" title="0">{
                tc.Status.MarkInstallerSetNotAvailable("Chain InstallerSet not available")
                logger.Infow("Creating new Chain InstallerSet", "targetNamespace", tc.Spec.TargetNamespace)

                createdIs, err := r.createInstallerSet(ctx, tc)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create InstallerSet", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Chain InstallerSet created successfully", "name", createdIs.GetName())
                return r.updateTektonChainStatus(tc, createdIs)</span>
        }

        // If exists, then fetch the Tekton Chain InstallerSet
        <span class="cov0" title="0">installedTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Get(ctx, existingInstallerSet, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Infow("InstallerSet not found, creating new one", "name", existingInstallerSet)
                        createdIs, err := r.createInstallerSet(ctx, tc)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to create InstallerSet", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Infow("Chain InstallerSet created successfully", "name", createdIs.GetName())
                        return r.updateTektonChainStatus(tc, createdIs)</span>
                }
                <span class="cov0" title="0">logger.Errorw("Failed to get InstallerSet", "name", existingInstallerSet, "error", err)
                return err</span>
        }

        <span class="cov0" title="0">installerSetTargetNamespace := installedTIS.Annotations[v1alpha1.TargetNamespaceKey]
        installerSetReleaseVersion := installedTIS.Labels[v1alpha1.ReleaseVersionKey]

        // Check if TargetNamespace of existing Tekton Chain InstallerSet is same as expected
        // Check if Release Version in Tekton Chain InstallerSet is same as expected
        // If any of the above things is not same then delete the existing Tekton Chain InstallerSet
        // and create a new with expected properties

        if installerSetTargetNamespace != tc.Spec.TargetNamespace || installerSetReleaseVersion != r.operatorVersion </span><span class="cov0" title="0">{
                logger.Infow("InstallerSet needs update",
                        "name", existingInstallerSet,
                        "currentNamespace", installerSetTargetNamespace,
                        "expectedNamespace", tc.Spec.TargetNamespace,
                        "currentVersion", installerSetReleaseVersion,
                        "expectedVersion", r.operatorVersion)
                // Delete the existing Tekton Chain InstallerSet
                err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Delete(ctx, existingInstallerSet, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to delete InstallerSet", "name", existingInstallerSet, "error", err)
                        return err
                }</span>

                // Make sure the Tekton Chain InstallerSet is deleted
                <span class="cov0" title="0">_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, existingInstallerSet, metav1.GetOptions{})
                if err == nil </span><span class="cov0" title="0">{
                        tc.Status.MarkNotReady("Waiting for previous installer set to get deleted")
                        logger.Debugw("InstallerSet deletion pending", "name", existingInstallerSet)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to confirm InstallerSet deletion", "name", existingInstallerSet, "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("InstallerSet successfully deleted", "name", existingInstallerSet)
                return nil</span>

        } else<span class="cov0" title="0"> {
                // If target namespace and version are not changed then check if Chain
                // spec is changed by checking hash stored as annotation on
                // Tekton Chain InstallerSet with computing new hash of TektonChain Spec

                // Hash of TektonChain Spec
                expectedSpecHash, err := hash.Compute(tc.Spec)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to compute spec hash", "error", err)
                        return err
                }</span>

                // spec hash stored on installerSet
                <span class="cov0" title="0">lastAppliedHash := installedTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]

                if lastAppliedHash != expectedSpecHash </span><span class="cov0" title="0">{
                        logger.Infow("Spec changed, updating InstallerSet",
                                "name", installedTIS.Name,
                                "oldHash", lastAppliedHash,
                                "newHash", expectedSpecHash)
                        manifest := r.manifest
                        // installerSet adds it's owner as namespace's owner
                        // so deleting tekton chain deletes target namespace too
                        // to skip it we filter out namespace if pipeline have same namespace
                        pipelineNamespace, err := common.PipelineTargetNamspace(r.pipelineInformer)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to fetch pipeline namespace", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">if tc.Spec.GetTargetNamespace() == pipelineNamespace </span><span class="cov0" title="0">{
                                logger.Debugw("Filtering out namespace resource as it's shared with pipeline",
                                        "namespace", pipelineNamespace)
                                manifest = manifest.Filter(mf.Not(mf.ByKind("Namespace")))
                        }</span>
                        // remove secret and `chains-config` configMap from this installerset as this installerset will be deleted on upgrade
                        <span class="cov0" title="0">manifest = manifest.Filter(mf.Not(mf.ByKind("Secret")),
                                mf.Not(mf.All(mf.ByName("chains-config"), mf.ByKind("ConfigMap"))))

                        transformer := filterAndTransform(r.extension)
                        if _, err := transformer(ctx, &amp;manifest, tc); err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Manifest transformation failed", "error", err)
                                return err
                        }</span>

                        // Update the spec hash
                        <span class="cov0" title="0">current := installedTIS.GetAnnotations()
                        current[v1alpha1.LastAppliedHashKey] = expectedSpecHash
                        installedTIS.SetAnnotations(current)

                        // Update the manifests
                        installedTIS.Spec.Manifests = manifest.Resources()

                        if _, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                Update(ctx, installedTIS, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to update InstallerSet", "name", installedTIS.Name, "error", err)
                                return err
                        }</span>

                        // after updating installer set enqueue after a duration
                        // to allow changes to get deployed
                        <span class="cov0" title="0">logger.Infow("InstallerSet successfully updated", "name", installedTIS.Name)
                        return v1alpha1.REQUEUE_EVENT_AFTER</span>
                }
                <span class="cov0" title="0">logger.Debugw("InstallerSet up to date", "name", installedTIS.Name)</span>
        }

        // Check if a Tekton Chain Secret InstallerSet already exists, if not then create one
        <span class="cov0" title="0">secretLabelSelector, err := common.LabelSelector(secretLs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid secret label selector", "error", err, "selector", secretLs)
                return err
        }</span>
        <span class="cov0" title="0">existingSecretInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, secretLabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get secret installer set name", "error", err, "selector", secretLabelSelector)
                return err
        }</span>
        <span class="cov0" title="0">if existingSecretInstallerSet == "" </span><span class="cov0" title="0">{
                tc.Status.MarkInstallerSetNotAvailable("Chain Secret InstallerSet not available")
                logger.Infow("Creating new Chain Secret InstallerSet", "targetNamespace", tc.Spec.TargetNamespace)
                createdIs, err := r.createSecretInstallerSet(ctx, tc)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create Secret InstallerSet", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Chain Secret InstallerSet created successfully", "name", createdIs.GetName())
                return v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        // If exists, then fetch the Tekton Chain Secret InstallerSet
        <span class="cov0" title="0">installedSecretTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Get(ctx, existingSecretInstallerSet, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Infow("Secret InstallerSet not found, creating new one", "name", existingSecretInstallerSet)
                        createdIs, err := r.createSecretInstallerSet(ctx, tc)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to create Secret InstallerSet", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Infow("Chain Secret InstallerSet created successfully", "name", createdIs.GetName())
                        return v1alpha1.RECONCILE_AGAIN_ERR</span>
                }
                <span class="cov0" title="0">logger.Errorw("Failed to get Secret InstallerSet", "name", existingSecretInstallerSet, "error", err)
                return err</span>
        }

        // if the namespace or generatedSigningSecret has been changed for chainsCR, then delete the Tekton Chain Secret Installerset
        <span class="cov0" title="0">secretInstallerSetTargetNamespace := installedSecretTIS.Annotations[v1alpha1.TargetNamespaceKey]
        if secretInstallerSetTargetNamespace != tc.Spec.TargetNamespace </span><span class="cov0" title="0">{
                logger.Infow("Secret InstallerSet namespace changed, recreating",
                        "name", existingSecretInstallerSet,
                        "currentNamespace", secretInstallerSetTargetNamespace,
                        "expectedNamespace", tc.Spec.TargetNamespace)
                // Delete the existing Tekton Chain Secret InstallerSet
                err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Delete(ctx, existingSecretInstallerSet, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to delete Secret InstallerSet", "name", existingSecretInstallerSet, "error", err)
                        return err
                }</span>

                // Make sure the Tekton Chain Secret InstallerSet is deleted
                <span class="cov0" title="0">_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, existingSecretInstallerSet, metav1.GetOptions{})
                if err == nil </span><span class="cov0" title="0">{
                        tc.Status.MarkNotReady("Waiting for previous installer set to get deleted")
                        logger.Debugw("Secret InstallerSet deletion pending", "name", existingSecretInstallerSet)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to confirm Secret InstallerSet deletion", "name", existingSecretInstallerSet, "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Secret InstallerSet successfully deleted", "name", existingSecretInstallerSet)
                return nil</span>
        }

        // if generatedSigningSecret has been changed for chainsCR, then update the Tekton Chain Secret InstallerSet
        <span class="cov0" title="0">secretInstallerSetSigningKey, err := strconv.ParseBool(installedSecretTIS.Annotations[secretTISSigningAnnotation])
        if err != nil </span><span class="cov0" title="0">{
                secretInstallerSetSigningKey = false
                logger.Debugw("Failed to parse signing key annotation, defaulting to false",
                        "annotation", secretTISSigningAnnotation,
                        "error", err)
        }</span>
        <span class="cov0" title="0">if secretInstallerSetSigningKey != tc.Spec.GenerateSigningSecret </span><span class="cov0" title="0">{
                logger.Infow("Signing key configuration changed, updating Secret InstallerSet",
                        "name", existingSecretInstallerSet,
                        "currentValue", secretInstallerSetSigningKey,
                        "newValue", tc.Spec.GenerateSigningSecret)
                manifest := r.manifest.Filter(mf.ByKind("Secret"))
                transformer := filterAndTransform(r.extension)
                if _, err := transformer(ctx, &amp;manifest, tc); err != nil </span><span class="cov0" title="0">{
                        tc.Status.MarkNotReady("transformation failed: " + err.Error())
                        logger.Errorw("Secret manifest transformation failed", "error", err)
                        return err
                }</span>
                // update the installer set annotation
                <span class="cov0" title="0">installedSecretTIS.Annotations[secretTISSigningAnnotation] = strconv.FormatBool(tc.Spec.GenerateSigningSecret)

                // Update the manifests
                installedSecretTIS.Spec.Manifests = manifest.Resources()

                if _, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Update(ctx, installedSecretTIS, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to update Secret InstallerSet", "name", installedSecretTIS.Name, "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Secret InstallerSet successfully updated", "name", installedSecretTIS.Name)</span>
        }

        // Mark InstallerSetAvailable
        <span class="cov0" title="0">tc.Status.MarkInstallerSetAvailable()

        ready := installedTIS.Status.GetCondition(apis.ConditionReady)
        if ready == nil </span><span class="cov0" title="0">{
                tc.Status.MarkInstallerSetNotReady("Waiting for installation")
                logger.Debugw("InstallerSet status is Unknown", "name", installedTIS.Name)
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>

        <span class="cov0" title="0">if ready.Status == corev1.ConditionUnknown </span><span class="cov0" title="0">{
                tc.Status.MarkInstallerSetNotReady("Waiting for installation")
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span> else<span class="cov0" title="0"> if ready.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                tc.Status.MarkInstallerSetNotReady(ready.Message)
                logger.Infow("InstallerSet not ready", "name", installedTIS.Name, "message", ready.Message)
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>

        // Mark InstallerSet Ready
        <span class="cov0" title="0">tc.Status.MarkInstallerSetReady()
        logger.Infow("InstallerSet not ready", "name", installedTIS.Name, "message", ready.Message)

        if err := r.extension.PostReconcile(ctx, tc); err != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                tc.Status.MarkPostReconcilerFailed(errMsg)
                logger.Errorw("PostReconcile failed", "error", err, "component", "extension")
                return err
        }</span>

        // Mark PostReconcile Complete
        <span class="cov0" title="0">tc.Status.MarkPostReconcilerComplete()
        logger.Debug("PostReconcile completed successfully")

        // Update the object for any spec changes
        if _, err := r.operatorClientSet.OperatorV1alpha1().TektonChains().Update(ctx, tc, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to update TektonChain status", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FinalizeKind removes all resources after deletion of a TektonChain.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonChain) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Delete CRDs before deleting rest of resources so that any instance
        // of CRDs which has finalizer set will get deleted before we remove
        // the controller's deployment for it
        if err := r.manifest.Filter(mf.CRDs).Delete(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to deleted CRDs for TektonChain")
                return err
        }</span>

        <span class="cov0" title="0">labelSelector, err := common.LabelSelector(ls)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{
                        LabelSelector: labelSelector,
                }); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete installer set created by TektonChain", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) updateTektonChainStatus(tc *v1alpha1.TektonChain, createdIs *v1alpha1.TektonInstallerSet) error <span class="cov0" title="0">{
        // update the tc with TektonInstallerSet and releaseVersion
        tc.Status.SetTektonInstallerSet(createdIs.Name)
        tc.Status.SetVersion(r.chainVersion)

        return v1alpha1.RECONCILE_AGAIN_ERR
}</span>

func (r *Reconciler) markUpgrade(ctx context.Context, tc *v1alpha1.TektonChain) error <span class="cov0" title="0">{
        labels := tc.GetLabels()
        ver, ok := labels[v1alpha1.ReleaseVersionKey]
        if ok &amp;&amp; ver == r.operatorVersion </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if ok &amp;&amp; ver != r.operatorVersion </span><span class="cov0" title="0">{
                tc.Status.MarkInstallerSetNotReady(v1alpha1.UpgradePending)
                tc.Status.MarkPreReconcilerFailed(v1alpha1.UpgradePending)
                tc.Status.MarkPostReconcilerFailed(v1alpha1.UpgradePending)
                tc.Status.MarkNotReady(v1alpha1.UpgradePending)
        }</span>
        <span class="cov0" title="0">if labels == nil </span><span class="cov0" title="0">{
                labels = map[string]string{}
        }</span>
        <span class="cov0" title="0">labels[v1alpha1.ReleaseVersionKey] = r.operatorVersion
        tc.SetLabels(labels)

        if _, err := r.operatorClientSet.OperatorV1alpha1().TektonChains().Update(ctx,
                tc, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}

func AddControllerEnv(controllerEnvs []corev1.EnvVar) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" || len(controllerEnvs) == 0 || u.GetName() != chainsDeploymentName </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov0" title="0">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for i, c := range d.Spec.Template.Spec.Containers </span><span class="cov0" title="0">{
                        if c.Name != chainsContainerName </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">existingEnv := c.Env
                        for _, v := range controllerEnvs </span><span class="cov0" title="0">{
                                newEnv := corev1.EnvVar{
                                        Name:      v.Name,
                                        Value:     v.Value,
                                        ValueFrom: v.ValueFrom,
                                }
                                appendNewEnv := true
                                for existingEnvIndex, env := range existingEnv </span><span class="cov0" title="0">{
                                        // Check for the key, if found replace it
                                        if env.Name == newEnv.Name </span><span class="cov0" title="0">{
                                                existingEnv[existingEnvIndex] = newEnv
                                                appendNewEnv = false
                                                break</span>
                                        }
                                }
                                // If not found append the new env
                                <span class="cov0" title="0">if appendNewEnv </span><span class="cov0" title="0">{
                                        existingEnv = append(existingEnv, newEnv)
                                }</span>
                        }

                        // update the changes into the actual container
                        <span class="cov0" title="0">d.Spec.Template.Spec.Containers[i].Env = existingEnv
                        break</span>
                }

                <span class="cov0" title="0">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

// Creates a cryptographically secure random password
// of length defaultCosignPasswordLength, then encodes it using base64
func generateRandomPassword(ctx context.Context) (string, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        raw := make([]byte, defaultCosignPasswordLength)
        if _, err := rand.Read(raw); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to generate random bytes: %v", err)
                return "", err
        }</span>

        // Base64 encode it
        <span class="cov0" title="0">pass := base64.StdEncoding.EncodeToString(raw)
        return pass, nil</span>
}

func generateSigningSecrets(ctx context.Context) map[string][]byte <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        randomPassword, err := generateRandomPassword(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error generating random password %w:", err)
                return nil
        }</span>

        // Define a PassFunc that supplies the generated password to cosign
        <span class="cov0" title="0">passFunc := func(confirm bool) ([]byte, error) </span><span class="cov0" title="0">{
                return []byte(randomPassword), nil
        }</span>

        <span class="cov0" title="0">keys, err := cosign.GenerateKeyPair(passFunc)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error generating cosign key pair:", err)
                return nil
        }</span>

        // Return the cosign keys and password
        <span class="cov0" title="0">return map[string][]byte{
                "cosign.key":      keys.PrivateBytes,
                "cosign.pub":      keys.PublicBytes,
                "cosign.password": []byte(randomPassword),
        }</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonchain

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

const (
        leaderElectionChainConfig                       = "tekton-chains-config-leader-election"
        chainControllerDeployment                       = "tekton-chains-controller"
        chainControllerContainer                        = "tekton-chains-controller"
        tektonChainsControllerName                      = "tekton-chains-controller"
        tektonChainsServiceName                         = "tekton-chains-controller"
        tektonChainsControllerStatefulServiceName       = "STATEFUL_SERVICE_NAME"
        tektonChainsControllerStatefulControllerOrdinal = "STATEFUL_CONTROLLER_ORDINAL"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov8" title="1">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov8" title="1">{
                chainCR := comp.(*v1alpha1.TektonChain)
                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ChainsImagePrefix))
                chainImages := common.ImageRegistryDomainOverride(imagesRaw)
                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdChains),
                        common.DeploymentImages(chainImages),
                        common.DeploymentEnvVarKubernetesMinVersion(),
                        common.AddConfiguration(chainCR.Spec.Config),
                        common.AddConfigMapValues(ChainsConfig, chainCR.Spec.Chain.ChainProperties),
                        common.AddDeploymentRestrictedPSA(),
                        AddControllerEnv(chainCR.Spec.Chain.ControllerEnvs),
                        common.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(&amp;chainCR.Spec.Performance, leaderElectionChainConfig, chainControllerDeployment, chainControllerContainer),
                }
                if chainCR.Spec.GenerateSigningSecret </span><span class="cov0" title="0">{
                        extra = append(extra, common.AddSecretData(generateSigningSecrets(ctx), map[string]string{
                                secretTISSigningAnnotation: "true",
                        }))
                }</span>

                <span class="cov8" title="1">if chainCR.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *chainCR.Spec.Performance.StatefulsetOrdinals </span><span class="cov8" title="1">{
                        extra = append(extra,
                                common.ConvertDeploymentToStatefulSet(tektonChainsControllerName, tektonChainsServiceName),
                                common.AddStatefulEnvVars(
                                        tektonChainsControllerName, tektonChainsServiceName, tektonChainsControllerStatefulServiceName, tektonChainsControllerStatefulControllerOrdinal))
                }</span>

                <span class="cov8" title="1">extra = append(extra, extension.Transformers(chainCR)...)
                err := common.Transform(ctx, manifest, chainCR, extra...)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>
                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov8" title="1">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, chainCR.Spec.GetTargetNamespace(), chainCR.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov8" title="1">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        tektonDashboardinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektondashboard"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        ctrl := tektonconfig.NewExtensibleController(KubernetesExtension)(ctx, cmw)
        if _, err := tektonDashboardinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterControllerGVK(v1alpha1.SchemeGroupVersion.WithKind("TektonConfig")),
                Handler:    controller.HandleAll(ctrl.EnqueueControllerOf),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register TektonDashboard informer event handler: %w", err)
        }</span>
        <span class="cov0" title="0">return ctrl</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonconfig/extension"
)

func KubernetesExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        return kubernetesExtension{
                operatorClientSet: operatorclient.Get(ctx),
        }
}</span>

type kubernetesExtension struct {
        operatorClientSet versioned.Interface
}

func (oe kubernetesExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return []mf.Transformer{}
}</span>
func (oe kubernetesExtension) PreReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe kubernetesExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        configInstance := comp.(*v1alpha1.TektonConfig)

        if configInstance.Spec.Profile == v1alpha1.ProfileAll </span><span class="cov0" title="0">{
                if _, err := extension.EnsureTektonDashboardExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonDashboards(), configInstance); err != nil </span><span class="cov0" title="0">{
                        configInstance.Status.MarkPostInstallFailed(fmt.Sprintf("TektonDashboard: %s", err.Error()))
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
        }

        <span class="cov0" title="0">if configInstance.Spec.Profile == v1alpha1.ProfileLite || configInstance.Spec.Profile == v1alpha1.ProfileBasic </span><span class="cov0" title="0">{
                return extension.EnsureTektonDashboardCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonDashboards())
        }</span>

        <span class="cov0" title="0">return nil</span>
}
func (oe kubernetesExtension) Finalize(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        configInstance := comp.(*v1alpha1.TektonConfig)
        if configInstance.Spec.Profile == v1alpha1.ProfileAll </span><span class="cov0" title="0">{
                return extension.EnsureTektonDashboardCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonDashboards())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package extension

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

func EnsureTektonDashboardExists(ctx context.Context, clients op.TektonDashboardInterface, config *v1alpha1.TektonConfig) (*v1alpha1.TektonDashboard, error) <span class="cov8" title="1">{
        tdCR, err := GetDashboard(ctx, clients, v1alpha1.DashboardResourceName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if _, err = createDashboard(ctx, clients, config); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">tdCR, err = updateDashboard(ctx, tdCR, config, clients)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ok, err := isTektonDashboardReady(tdCR, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return tdCR, err</span>
}

func GetDashboard(ctx context.Context, clients op.TektonDashboardInterface, name string) (*v1alpha1.TektonDashboard, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

func createDashboard(ctx context.Context, clients op.TektonDashboardInterface, config *v1alpha1.TektonConfig) (*v1alpha1.TektonDashboard, error) <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())

        tdCR := &amp;v1alpha1.TektonDashboard{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.DashboardResourceName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonDashboardSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Config:    config.Spec.Config,
                        Dashboard: config.Spec.Dashboard,
                },
        }
        return clients.Create(ctx, tdCR, metav1.CreateOptions{})
}</span>

func updateDashboard(ctx context.Context, tdCR *v1alpha1.TektonDashboard, config *v1alpha1.TektonConfig,
        clients op.TektonDashboardInterface) (*v1alpha1.TektonDashboard, error) <span class="cov8" title="1">{
        // if the dashboard spec is changed then update the instance
        updated := false

        if config.Spec.TargetNamespace != tdCR.Spec.TargetNamespace </span><span class="cov8" title="1">{
                tdCR.Spec.TargetNamespace = config.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(tdCR.Spec.DashboardProperties, config.Spec.Dashboard.DashboardProperties) </span><span class="cov0" title="0">{
                tdCR.Spec.DashboardProperties = config.Spec.Dashboard.DashboardProperties
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(tdCR.Spec.Config, config.Spec.Config) </span><span class="cov0" title="0">{
                tdCR.Spec.Config = config.Spec.Config
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(tdCR.Spec.Dashboard.Options, config.Spec.Dashboard.Options) </span><span class="cov0" title="0">{
                tdCR.Spec.Dashboard.Options = config.Spec.Dashboard.Options
                updated = true
        }</span>

        <span class="cov8" title="1">if tdCR.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
                tdCR.ObjectMeta.OwnerReferences = []metav1.OwnerReference{ownerRef}
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, tdCR, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">return tdCR, nil</span>
}

// isTektonDashboardReady will check the status conditions of the TektonDashboard and return true if the TektonDashboard is ready.
func isTektonDashboardReady(s *v1alpha1.TektonDashboard, err error) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), err</span>
}

// EnsureTektonDashboardCRNotExists deletes the singleton instance of TektonDashboard
// and ensures the instance is removed checking whether in exists in a subsequent invocation
func EnsureTektonDashboardCRNotExists(ctx context.Context, clients op.TektonDashboardInterface) error <span class="cov8" title="1">{
        if _, err := GetDashboard(ctx, clients, v1alpha1.DashboardResourceName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // TektonDashBoard CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.DashboardResourceName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // TektonDashBoard CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TektonDashboard %q failed to delete: %v", v1alpha1.DashboardResourceName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektondashboard

import (
        "context"

        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonDashboardinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektondashboard"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        tektonDashboardreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektondashboard"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const versionConfigMap = "dashboard-info"

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                tektonPipelineInformer := tektonPipelineinformer.Get(ctx)
                tektonDashboardInformer := tektonDashboardinformer.Get(ctx)

                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }

                readonlyManifest, dashboardVer := ctrl.InitController(ctx, common.PayloadOptions{ReadOnly: true})

                fullaccessManifest, _ := ctrl.InitController(ctx, common.PayloadOptions{ReadOnly: false})

                operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">metrics, err := common.NoMetrics()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to create dashboard metrics recorder %v", err)
                }</span>

                <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()
                c := &amp;Reconciler{
                        pipelineInformer:   tektonPipelineInformer,
                        installerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, dashboardVer, v1alpha1.KindTektonDashboard, metrics),
                        operatorClientSet:  operatorclient.Get(ctx),
                        extension:          generator(ctx),
                        readonlyManifest:   readonlyManifest,
                        fullaccessManifest: fullaccessManifest,
                        dashboardVersion:   dashboardVer,
                        operatorVersion:    operatorVer,
                }
                impl := tektonDashboardreconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for tekton-dashboard")

                if _, err := tektonDashboardInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonDashboard informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonDashboard{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektondashboard

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// FinalizeKind removes all resources after deletion of a TektonDashboards.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonDashboard) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Delete CRDs before deleting rest of resources so that any instance
        // of CRDs which has finalizer set will get deleted before we remove
        // the controller;s deployment for it

        var manifest mf.Manifest
        if original.Spec.Readonly </span><span class="cov0" title="0">{
                manifest = r.readonlyManifest
        }</span> else<span class="cov0" title="0"> {
                manifest = r.fullaccessManifest
        }</span>

        <span class="cov0" title="0">if err := manifest.Filter(mf.CRDs).Delete(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to deleted CRDs for TektonDashboard")
                return err
        }</span>

        <span class="cov0" title="0">if err := r.installerSetClient.CleanupMainSet(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to cleanup main installerset: ", err)
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektondashboard

import (
        "context"
        "fmt"

        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        pipelineinformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        tektondashboardreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektondashboard"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Reconciler implements controller.Reconciler for TektonDashboard resources.
type Reconciler struct {
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // operatorClientSet allows us to configure operator objects
        operatorClientSet clientset.Interface
        // readOnlyManifest has the source manifest of Tekton Dashboard for
        // a particular version with readonly value as true
        readonlyManifest mf.Manifest
        // fullaccessManifest has the source manifest of Tekton Dashboard for
        // a particular version with readonly value as false
        fullaccessManifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension        common.Extension
        pipelineInformer pipelineinformer.TektonPipelineInformer
        operatorVersion  string
        dashboardVersion string
}

// Check that our Reconciler implements controller.Reconciler
var _ tektondashboardreconciler.Interface = (*Reconciler)(nil)
var _ tektondashboardreconciler.Finalizer = (*Reconciler)(nil)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, td *v1alpha1.TektonDashboard) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("tektondashboard", td.GetName())
        td.Status.InitializeConditions()
        td.Status.ObservedGeneration = td.Generation
        td.Status.SetVersion(r.dashboardVersion)

        logger.Debugw("Starting TektonDashboard reconciliation",
                "version", r.dashboardVersion,
                "generation", td.Generation,
                "status", td.Status.GetCondition(apis.ConditionReady))

        if td.GetName() != v1alpha1.DashboardResourceName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.DashboardResourceName,
                        td.GetName(),
                )
                logger.Errorw("Invalid resource name", "expectedName", v1alpha1.DashboardResourceName, "actualName", td.GetName())
                td.Status.MarkNotReady(msg)
                return nil
        }</span>

        // find the valid tekton-pipeline installation
        <span class="cov0" title="0">logger.Debug("Checking Tekton Pipeline dependency")
        if _, err := common.PipelineReady(r.pipelineInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        logger.Infow("Tekton Pipeline dependency not ready yet", "error", err)
                        td.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
                        // wait for pipeline status to change
                        return v1alpha1.REQUEUE_EVENT_AFTER

                }</span>
                // (tektonpipeline.opeator.tekton.dev instance not available yet)
                <span class="cov0" title="0">logger.Errorw("Tekton Pipeline dependency missing", "error", err)
                td.Status.MarkDependencyMissing("tekton-pipelines does not exist")
                return err</span>
        }
        <span class="cov0" title="0">logger.Info("All dependencies installed successfully")
        td.Status.MarkDependenciesInstalled()

        logger.Debug("Removing obsolete installer sets")
        if err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to remove obsolete installer sets", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Obsolete installer sets removed")

        logger.Debug("Executing pre-reconciliation")
        if err := r.extension.PreReconcile(ctx, td); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Pre-reconciliation failed", "error", err)
                td.Status.MarkPreReconcilerFailed(fmt.Sprintf("PreReconciliation failed: %s", err.Error()))
                return err
        }</span>

        // Mark PreReconcile Complete
        <span class="cov0" title="0">logger.Info("Pre-reconciliation completed successfully")
        td.Status.MarkPreReconcilerComplete()

        var manifest mf.Manifest
        if td.Spec.Readonly </span><span class="cov0" title="0">{
                logger.Debugw("Using readonly manifest", "readonly", true)
                manifest = r.readonlyManifest
        }</span> else<span class="cov0" title="0"> {
                logger.Debugw("Using full access manifest", "readonly", false)
                manifest = r.fullaccessManifest
        }</span>

        // When Tekton Dashboard is insalled targetNamespace is getting updated with the OwnerRef as TektonDashboard
        // and hence deleting the component in the integration tests, targetNamespace was getting deleted. Hence
        // filtering out the namespace here
        <span class="cov0" title="0">logger.Debug("Filtering out namespace from manifest")
        manifest = manifest.Filter(mf.Not(mf.ByKind("Namespace")))

        logger.Debug("Applying main manifest")
        if err := r.installerSetClient.MainSet(ctx, td, &amp;manifest, filterAndTransform(r.extension)); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Main Reconcilation failed: %s", err.Error())
                logger.Errorw("Failed to apply main installer set", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Infow("Main reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">td.Status.MarkInstallerSetNotReady(msg)
                return nil</span>
        }
        <span class="cov0" title="0">logger.Info("Main manifest applied successfully")

        logger.Debug("Executing post-reconciliation")
        if err := r.extension.PostReconcile(ctx, td); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                logger.Errorw("Post-reconciliation failed", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Infow("Post-reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Post-reconciliation completed successfully")
                td.Status.MarkPostReconcilerFailed(msg)
                return nil</span>
        }

        <span class="cov0" title="0">logger.Info("Post-reconciliation completed successfully")
        td.Status.MarkPostReconcilerComplete()

        logger.Info("TektonDashboard reconciliation completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektondashboard

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

const (
        externalLogsArg         = "--external-logs="
        dashboardDeploymentName = "tekton-dashboard"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov8" title="1">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov8" title="1">{
                dashboard := comp.(*v1alpha1.TektonDashboard)
                targetNamespace := dashboard.Spec.GetTargetNamespace()

                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.DashboardImagePrefix))
                images := common.ImageRegistryDomainOverride(imagesRaw)

                trns := extension.Transformers(dashboard)
                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdDashboard),
                        common.AddConfiguration(dashboard.Spec.Config),
                        common.AddDeploymentRestrictedPSA(),
                        common.DeploymentImages(images),
                        common.DeploymentEnvVarKubernetesMinVersion(),
                        common.ReplaceNamespaceInDeploymentArgs([]string{dashboardDeploymentName}, targetNamespace),
                }
                trns = append(trns, extra...)
                if dashboard.Spec.ExternalLogs != "" </span><span class="cov8" title="1">{
                        updatedExternalLogsArg := externalLogsArg + dashboard.Spec.ExternalLogs
                        trns = append(trns, common.ReplaceDeploymentArg(dashboardDeploymentName, externalLogsArg, updatedExternalLogsArg))
                }</span>
                <span class="cov8" title="1">if err := common.Transform(ctx, manifest, dashboard, trns...); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov8" title="1">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, targetNamespace, dashboard.Spec.Dashboard.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov8" title="1">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonhub

import (
        "context"

        "github.com/go-logr/zapr"
        mfc "github.com/manifestival/client-go-client"
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonHubinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonhub"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonHubReconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonhub"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "go.uber.org/zap"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                tektonHubInformer := tektonHubinformer.Get(ctx)
                kubeClient := kubeclient.Get(ctx)
                logger := logging.FromContext(ctx)

                mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating client from injected config", zap.Error(err))
                }</span>
                <span class="cov0" title="0">mflogger := zapr.NewLogger(logger.Named("manifestival").Desugar())
                manifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating initial manifest", zap.Error(err))
                }</span>

                <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">c := &amp;Reconciler{
                        kubeClientSet:     kubeClient,
                        operatorClientSet: operatorclient.Get(ctx),
                        extension:         generator(ctx),
                        manifest:          manifest,
                        operatorVersion:   operatorVer,
                }
                impl := tektonHubReconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers")

                if _, err := tektonHubInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonHub informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonHub{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>
                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package tektonhub

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// checkIfInstallerSetExist checks if installer set exists for a component and return true/false based on it
// and if installer set which already exist is of older version then it deletes and return false to create a new
// installer set
func (r *Reconciler) checkIfInstallerSetExist(ctx context.Context, oc clientset.Interface, relVersion string, installerSetType string) (bool, error) <span class="cov0" title="0">{

        labels := r.getLabels(installerSetType)
        labelSelector, err := common.LabelSelector(labels)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">compInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if compInstallerSet != "" </span><span class="cov0" title="0">{
                // if already created then check which version it is
                ctIs, err := oc.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, compInstallerSet, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }

                <span class="cov0" title="0">version, ok := ctIs.Annotations[v1alpha1.ReleaseVersionKey]
                if ok &amp;&amp; version == relVersion </span><span class="cov0" title="0">{
                        // if installer set already exist and release version is same
                        // then ignore and move on
                        return true, nil
                }</span>

                // release version doesn't exist or is different from expected
                // deleted existing InstallerSet and create a new one

                <span class="cov0" title="0">err = oc.OperatorV1alpha1().TektonInstallerSets().
                        Delete(ctx, compInstallerSet, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

func createInstallerSet(ctx context.Context, oc clientset.Interface, th *v1alpha1.TektonHub,
        manifest mf.Manifest, releaseVersion, component, installerSetPrefix, namespace string, labels map[string]string, specHash string) error <span class="cov0" title="0">{

        is := makeInstallerSet(th, manifest, installerSetPrefix, releaseVersion, namespace, labels, specHash)
        if is == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to create installerset")
        }</span>

        <span class="cov0" title="0">createdIs, err := oc.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, is, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(th.Status.HubInstallerSet) == 0 </span><span class="cov0" title="0">{
                th.Status.HubInstallerSet = map[string]string{}
        }</span>

        // Update the status of addon with created installerSet name
        <span class="cov0" title="0">th.Status.HubInstallerSet[component] = createdIs.Name
        th.Status.SetVersion(releaseVersion)
        return nil</span>
}

func makeInstallerSet(th *v1alpha1.TektonHub, manifest mf.Manifest, prefix, releaseVersion, namespace string, labels map[string]string, specHash string) *v1alpha1.TektonInstallerSet <span class="cov0" title="0">{
        ownerRef := *metav1.NewControllerRef(th, th.GetGroupVersionKind())

        tektonHubCRSpecHash, err := hash.Compute(th.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">is := &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-", prefix),
                        Labels:       labels,
                        Annotations: map[string]string{
                                v1alpha1.ReleaseVersionKey:  releaseVersion,
                                v1alpha1.TargetNamespaceKey: namespace,
                                v1alpha1.LastAppliedHashKey: tektonHubCRSpecHash,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }

        if specHash != "" </span><span class="cov0" title="0">{
                is.Annotations[v1alpha1.DbSecretHash] = specHash
        }</span>

        <span class="cov0" title="0">return is</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.

You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonhub

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "path/filepath"
        "reflect"
        "strings"

        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"

        mf "github.com/manifestival/manifestival"
        "github.com/spf13/viper"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        tektonhubconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonhub"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Reconciler implements controller.Reconciler for TektonHub resources.
type Reconciler struct {
        // kubeClientSet allows us to talk to the k8s for core APIs
        kubeClientSet kubernetes.Interface
        // operatorClientSet allows us to configure operator objects
        operatorClientSet clientset.Interface
        // manifest is empty, but with a valid client and logger. all
        // manifests are immutable, and any created during reconcile are
        // expected to be appended to this one, obviating the passing of
        // client &amp; logger
        manifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension       common.Extension
        operatorVersion string
}

const (
        // installerSet labels
        installerSetLabelCreatedByValue = "TektonHub"

        // installerSet names
        installerSetNameDatabase      = "DbInstallerSet"
        installerSetDatabaseMigration = "DbMigrationInstallerSet"
        installerSetNameAPI           = "ApiInstallerSet"
        installerSetNameUI            = "UiInstallerSet"

        // installerSet types
        installerSetTypeDatabase          = "tekton-hub-db"
        installerSetTypeDatabaseMigration = "tekton-hub-db-migration"
        installerSetTypeAPI               = "tekton-hub-api"
        installerSetTypeUI                = "tekton-hub-ui"

        // manifests directory names
        manifestDirDatabase          = "db"
        manifestDirDatabaseMigration = "db-migration"
        manifestDirAPI               = "api"
        manifestDirUI                = "ui"
        manifestDirInfo              = "hub-info"

        // resource names
        databaseSecretName = "tekton-hub-db"
        apiConfigMapName   = "tekton-hub-api"
        uiConfigMapName    = "tekton-hub-ui"

        // database secret keys
        secretKeyPostgresHost     = "POSTGRES_HOST"
        secretKeyPostgresDB       = "POSTGRES_DB"
        secretKeyPostgresUser     = "POSTGRES_USER"
        secretKeyPostgresPassword = "POSTGRES_PASSWORD"
        secretKeyPostgresPort     = "POSTGRES_PORT"

        // default postgres database values
        defaultPostgresHost     = "tekton-hub-db"
        defaultPostgresDB       = "hub"
        defaultPostgresUser     = "hub"
        defaultPostgresPassword = "hub"
        defaultPostgresPort     = "5432"
)

var (
        errKeyMissing error = fmt.Errorf("secret doesn't contains all the keys")

        // Check that our Reconciler implements controller.Reconciler
        _ tektonhubconciler.Interface = (*Reconciler)(nil)
        _ tektonhubconciler.Finalizer = (*Reconciler)(nil)

        ls = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     installerSetLabelCreatedByValue,
                        v1alpha1.InstallerSetType: v1alpha1.HubResourceName,
                },
        }

        dbKeys = []string{secretKeyPostgresHost, secretKeyPostgresDB, secretKeyPostgresUser, secretKeyPostgresPassword, secretKeyPostgresPort}
)

type Data struct {
        Catalogs   []v1alpha1.Catalog
        Categories []v1alpha1.Category
        Scopes     []v1alpha1.Scope
        Default    v1alpha1.Default
}

// FinalizeKind removes all resources after deletion of a TektonHub.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonHub) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        labelSelector, err := common.LabelSelector(ls)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{
                        LabelSelector: labelSelector,
                }); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete installer set created by TektonHub", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, th *v1alpha1.TektonHub) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        th.Status.InitializeConditions()
        th.Status.ObservedGeneration = th.Generation

        logger.Infow("Reconciling TektonHub", "status", th.Status)

        // we have to maintain only one hub across the cluster and the accepted resource name is "hub"
        if th.GetName() != v1alpha1.HubResourceName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.HubResourceName,
                        th.GetName(),
                )
                logger.Error(msg)
                th.Status.MarkNotReady(msg)
                return nil
        }</span>

        <span class="cov0" title="0">th.SetDefaults(ctx)

        // reconcile target namespace
        if err := common.ReconcileTargetNamespace(ctx, nil, nil, th, r.kubeClientSet); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("error on reconciling targetNamespace",
                        "targetNamespace", th.Spec.GetTargetNamespace(),
                        err,
                )
                return err
        }</span>

        // execute pre-reconcile, used in extension
        <span class="cov0" title="0">if err := r.extension.PreReconcile(ctx, th); err != nil </span><span class="cov0" title="0">{
                return r.handleError(err, th)
        }</span>
        <span class="cov0" title="0">th.Status.MarkPreReconcilerComplete()

        // get TektonHub version and yaml manifests directory
        version := common.TargetVersion(th)
        hubManifestDir := filepath.Join(common.ComponentDir(th), version)

        // if user has not supplied external database credentials setup a database
        if err := r.reconcileDatabaseInstallerSet(ctx, th, hubManifestDir, version); err != nil </span><span class="cov0" title="0">{
                return r.handleError(err, th)
        }</span>

        <span class="cov0" title="0">if err := r.setupDatabaseMigrationInstallerSet(ctx, th, hubManifestDir, version); err != nil </span><span class="cov0" title="0">{
                return r.handleError(err, th)
        }</span>
        <span class="cov0" title="0">th.Status.MarkDatabaseMigrationDone()

        if err := r.reconcileApiInstallerSet(ctx, th, hubManifestDir, version); err != nil </span><span class="cov0" title="0">{
                return r.handleError(err, th)
        }</span>
        <span class="cov0" title="0">th.Status.MarkApiInstallerSetAvailable()

        if err := r.reconcileUiInstallerSet(ctx, th, hubManifestDir, version); err != nil </span><span class="cov0" title="0">{
                return r.handleError(err, th)
        }</span>
        <span class="cov0" title="0">th.Status.MarkUiInstallerSetAvailable()

        // execute post-reconcile, used in extension
        if err := r.extension.PostReconcile(ctx, th); err != nil </span><span class="cov0" title="0">{
                return r.handleError(err, th)
        }</span>
        <span class="cov0" title="0">th.Status.MarkPostReconcilerComplete()

        return nil</span>
}

func (r *Reconciler) handleError(err error, th *v1alpha1.TektonHub) error <span class="cov0" title="0">{
        if err == v1alpha1.RECONCILE_AGAIN_ERR </span><span class="cov0" title="0">{
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (r *Reconciler) reconcileUiInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error <span class="cov0" title="0">{
        exist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeUI)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                th.Status.MarkUiInstallerSetNotAvailable("UI installer set not available")
                uiLocation := filepath.Join(hubDir, manifestDirUI)

                manifest, err := r.getManifest(ctx, th, uiLocation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetNameUI, version, installerSetTypeUI)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                // Get the installerset, check for the hash of spec
                // if not same delete the installerset.
                labels := r.getLabels(installerSetTypeUI)
                labelSelector, err := common.LabelSelector(labels)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">compInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if compInstallerSet != "" </span><span class="cov0" title="0">{
                        ctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, compInstallerSet, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">lastAppliedTektonHubCRSpecHash := ctIs.Annotations[v1alpha1.LastAppliedHashKey]
                        tektonHubCRSpecHash, err := hash.Compute(th.Spec)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if tektonHubCRSpecHash != lastAppliedTektonHubCRSpecHash </span><span class="cov0" title="0">{
                                if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, ctIs.Name, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return v1alpha1.RECONCILE_AGAIN_ERR</span>
                        }
                }
        }

        <span class="cov0" title="0">err = r.checkComponentStatus(ctx, th, installerSetTypeUI)
        if err != nil </span><span class="cov0" title="0">{
                th.Status.MarkUiInstallerSetNotAvailable(err.Error())
                return v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) reconcileApiInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error <span class="cov0" title="0">{

        // Validate whether the secrets and configmap are created for API
        if err := r.validateApiDependencies(ctx, th, hubDir, manifestDirAPI); err != nil </span><span class="cov0" title="0">{
                th.Status.MarkApiDependencyMissing("api secrets not present")
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>

        <span class="cov0" title="0">th.Status.MarkApiDependenciesInstalled()

        exist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeAPI)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                th.Status.MarkApiInstallerSetNotAvailable("API installer set not available")
                apiLocation := filepath.Join(hubDir, manifestDirAPI)

                manifest, err := r.getManifest(ctx, th, apiLocation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">infoLocation := filepath.Join(hubDir, manifestDirInfo)

                infoManifest, err := r.getManifest(ctx, th, infoLocation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">*manifest = manifest.Append(*infoManifest)

                err = applyPVC(ctx, manifest, th)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetNameAPI, version, installerSetTypeAPI)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                // Get the installerset, check for the hash of db secret
                // if not same delete the installerset.
                labels := r.getLabels(installerSetTypeAPI)
                labelSelector, err := common.LabelSelector(labels)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">compInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if compInstallerSet != "" </span><span class="cov0" title="0">{
                        ctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                Get(ctx, compInstallerSet, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">lastAppliedDbSecretHash := ctIs.Annotations[v1alpha1.DbSecretHash]
                        lastAppliedTektonHubCRSpecHash := ctIs.Annotations[v1alpha1.LastAppliedHashKey]

                        secret, err := r.getSecret(ctx, databaseSecretName, th.Spec.GetTargetNamespace(), dbKeys)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">expectedDbSecretHash, err := hash.Compute(secret.Data)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">tektonHubCRSpecHash, err := hash.Compute(th.Spec)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if lastAppliedDbSecretHash != expectedDbSecretHash || tektonHubCRSpecHash != lastAppliedTektonHubCRSpecHash </span><span class="cov0" title="0">{

                                if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, ctIs.Name, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">return v1alpha1.RECONCILE_AGAIN_ERR</span>
                        }
                }
        }

        <span class="cov0" title="0">err = r.checkComponentStatus(ctx, th, installerSetTypeAPI)
        if err != nil </span><span class="cov0" title="0">{
                th.Status.MarkApiInstallerSetNotAvailable(err.Error())
                return v1alpha1.RECONCILE_AGAIN_ERR
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) setupDatabaseMigrationInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error <span class="cov0" title="0">{
        // Check if the InstallerSet is available for DB-migration
        exist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeDatabaseMigration)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                dbMigrationManifestsDir := filepath.Join(hubDir, manifestDirDatabaseMigration)
                th.Status.MarkDatabaseMigrationFailed("DB migration installerset not available")

                manifest, err := r.getManifest(ctx, th, dbMigrationManifestsDir)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetDatabaseMigration, version, installerSetTypeDatabaseMigration)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if exist </span><span class="cov0" title="0">{
                // Get the installerset, check for the hash of db secret
                // if not same delete the installerset

                labels := r.getLabels(installerSetTypeDatabaseMigration)
                labelSelector, err := common.LabelSelector(labels)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">compInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if compInstallerSet != "" </span><span class="cov0" title="0">{
                        ctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, compInstallerSet, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">lastAppliedDbSecretHash := ctIs.Annotations[v1alpha1.DbSecretHash]

                        secret, err := r.getSecret(ctx, databaseSecretName, th.Spec.GetTargetNamespace(), dbKeys)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">expectedDbSecretHash, err := hash.Compute(secret.Data)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">if lastAppliedDbSecretHash != expectedDbSecretHash </span><span class="cov0" title="0">{
                                if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, ctIs.Name, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">err = r.checkComponentStatus(ctx, th, installerSetTypeDatabaseMigration)
        if err != nil </span><span class="cov0" title="0">{
                th.Status.MarkDatabaseMigrationFailed(err.Error())
                return v1alpha1.RECONCILE_AGAIN_ERR
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) setupDatabase(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error <span class="cov0" title="0">{
        // Check if the DB secrets are created
        if err := r.validateOrCreateDBSecrets(ctx, th); err != nil </span><span class="cov0" title="0">{
                th.Status.MarkDbDependencyMissing("db secrets are either invalid or not present")
                return err
        }</span>
        <span class="cov0" title="0">th.Status.MarkDbDependenciesInstalled()

        exist, err := r.checkIfInstallerSetExist(ctx, r.operatorClientSet, version, installerSetTypeDatabase)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                th.Status.MarkDbInstallerSetNotAvailable("DB installer set not available")
                dbLocation := filepath.Join(hubDir, manifestDirDatabase)
                manifest, err := r.getManifest(ctx, th, dbLocation)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = applyPVC(ctx, manifest, th)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = r.setUpAndCreateInstallerSet(ctx, *manifest, th, installerSetNameDatabase, version, installerSetTypeDatabase)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">err = r.checkComponentStatus(ctx, th, installerSetTypeDatabase)
        if err != nil </span><span class="cov0" title="0">{
                th.Status.MarkDbInstallerSetNotAvailable(err.Error())
                return v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate DB are present on the cluster. If DB secrets are present and all the keys don't
// have values then update the remaining values with default values. If the DB secret
// is not present then create a new secret with default values.
func (r *Reconciler) validateOrCreateDBSecrets(ctx context.Context, th *v1alpha1.TektonHub) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        targetNamespace := th.Spec.GetTargetNamespace()

        // th.Status.MarkDbDependencyInstalling("db secrets are being added into the namespace")

        dbSecret, err := r.getSecret(ctx, databaseSecretName, targetNamespace, dbKeys)
        if err != nil </span><span class="cov0" title="0">{
                newDbSecret := createDbSecret(databaseSecretName, targetNamespace, dbSecret, th)
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        _, err = r.kubeClientSet.CoreV1().Secrets(targetNamespace).Create(ctx, newDbSecret, metav1.CreateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err)
                                th.Status.MarkDbDependencyMissing(fmt.Sprintf("%s secret is missing", databaseSecretName))
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
                <span class="cov0" title="0">if err == errKeyMissing </span><span class="cov0" title="0">{
                        _, err = r.kubeClientSet.CoreV1().Secrets(targetNamespace).Update(ctx, newDbSecret, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err)
                                th.Status.MarkDbDependencyMissing(fmt.Sprintf("%s secret is missing", databaseSecretName))
                                return err
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Error(err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// TektonHub expects API secrets to be created before installing Tekton Hub API
func (r *Reconciler) validateApiDependencies(ctx context.Context, th *v1alpha1.TektonHub, hubDir, comp string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        apiSecretKeys := []string{"GH_CLIENT_ID", "GH_CLIENT_SECRET", "JWT_SIGNING_KEY", "ACCESS_JWT_EXPIRES_IN", "REFRESH_JWT_EXPIRES_IN", "GHE_URL"}

        th.Status.MarkApiDependencyInstalling("checking for api secrets in the namespace and creating the ConfigMap")

        _, err := r.getSecret(ctx, th.Spec.Api.ApiSecretName, th.Spec.GetTargetNamespace(), apiSecretKeys)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        if err := r.createApiSecret(ctx, th, hubDir, comp); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">if err == errKeyMissing </span><span class="cov0" title="0">{
                        th.Status.MarkApiDependencyMissing(fmt.Sprintf("%s secret is missing the keys", th.Spec.Api.ApiSecretName))
                        return err
                }</span> else<span class="cov0" title="0"> {
                        logger.Error(err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) getManifest(ctx context.Context, th *v1alpha1.TektonHub, manifestLocation string) (*mf.Manifest, error) <span class="cov0" title="0">{
        manifest := r.manifest.Append()

        if err := common.AppendManifest(&amp;manifest, manifestLocation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">transformer := filterAndTransform(r.extension)
        transformedManifest, err := transformer(ctx, &amp;manifest, th)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return transformedManifest, nil</span>
}

func (r *Reconciler) getLabels(componentInstallerSetType string) metav1.LabelSelector <span class="cov0" title="0">{
        return metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     installerSetLabelCreatedByValue,
                        v1alpha1.InstallerSetType: componentInstallerSetType,
                },
        }
}</span>

func applyPVC(ctx context.Context, manifest *mf.Manifest, th *v1alpha1.TektonHub) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        pvc := manifest.Filter(mf.ByKind("PersistentVolumeClaim"))
        pvcManifest, err := pvc.Transform(
                mf.InjectOwner(th),
                mf.InjectNamespace(th.Spec.GetTargetNamespace()),
        )

        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to transform manifest")
                return err
        }</span>

        <span class="cov0" title="0">if err := pvcManifest.Apply(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) reconcileDatabaseInstallerSet(ctx context.Context, th *v1alpha1.TektonHub, hubDir, version string) error <span class="cov0" title="0">{
        // Get the db secret, if not found or if any key is missing,
        // then manage the db installerset. If the value of db host
        // is different then user already has the db, hence delete
        // existing db installerset
        secret, err := r.getSecret(ctx, databaseSecretName, th.Spec.GetTargetNamespace(), dbKeys)
        if err != nil </span><span class="cov0" title="0">{
                // If not found create db with default db
                if apierrors.IsNotFound(err) || err == errKeyMissing </span><span class="cov0" title="0">{
                        if err := r.setupDatabase(ctx, th, hubDir, version); err != nil </span><span class="cov0" title="0">{
                                return r.handleError(err, th)
                        }</span>
                        <span class="cov0" title="0">th.Status.MarkDbInstallerSetAvailable()
                        return nil</span>
                }
                <span class="cov0" title="0">return err</span>
        } else<span class="cov0" title="0"> if string(secret.Data[secretKeyPostgresHost]) != defaultPostgresHost </span><span class="cov0" title="0">{
                // Mark the database as ready state as the
                // database is already installed by the user
                th.Status.MarkDbDependenciesInstalled()
                th.Status.MarkDbInstallerSetAvailable()

                // Get and delete the default db installerset
                if err := r.getAndDeleteInstallerSet(ctx, installerSetTypeDatabase); err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        } else<span class="cov0" title="0"> {
                // If secret found, with no error, then make sure db is up and running
                if err := r.setupDatabase(ctx, th, hubDir, version); err != nil </span><span class="cov0" title="0">{
                        return r.handleError(err, th)
                }</span>
                <span class="cov0" title="0">th.Status.MarkDbInstallerSetAvailable()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) setUpAndCreateInstallerSet(ctx context.Context, manifest mf.Manifest, th *v1alpha1.TektonHub, installerSetName, version, prefixName string) error <span class="cov0" title="0">{

        manifest = manifest.Filter(mf.Not(mf.Any(mf.ByKind("Secret"), mf.ByKind("PersistentVolumeClaim"), mf.ByKind("Namespace"))))

        specHash := ""
        if prefixName == installerSetTypeDatabaseMigration || prefixName == installerSetTypeAPI </span><span class="cov0" title="0">{
                secret, err := r.kubeClientSet.CoreV1().Secrets(th.Spec.GetTargetNamespace()).Get(ctx, databaseSecretName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">specHash, err = hash.Compute(secret.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">labels := r.getLabels(prefixName).MatchLabels
        if err := createInstallerSet(ctx, r.operatorClientSet, th, manifest,
                version, installerSetName, prefixName, th.Spec.GetTargetNamespace(), labels, specHash); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) getAndDeleteInstallerSet(ctx context.Context, installerSetType string) error <span class="cov0" title="0">{
        labels := r.getLabels(installerSetType)
        labelSelector, err := common.LabelSelector(labels)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if compInstallerSet != "" </span><span class="cov0" title="0">{
                _, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, compInstallerSet, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Delete(ctx, compInstallerSet, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) checkComponentStatus(ctx context.Context, th *v1alpha1.TektonHub, installerSetType string) error <span class="cov0" title="0">{

        labels := r.getLabels(installerSetType)
        labelSelector, err := common.LabelSelector(labels)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">compInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if compInstallerSet != "" </span><span class="cov0" title="0">{

                ctIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, compInstallerSet, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov0" title="0">ready := ctIs.Status.GetCondition(apis.ConditionReady)
                if ready == nil || ready.Status == corev1.ConditionUnknown </span><span class="cov0" title="0">{
                        return fmt.Errorf("InstallerSet %s: waiting for installation", ctIs.Name)
                }</span> else<span class="cov0" title="0"> if ready.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                        return fmt.Errorf("InstallerSet %s: ", ready.Message)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) getSecret(ctx context.Context, name, targetNs string, verifyKeys []string) (*corev1.Secret, error) <span class="cov0" title="0">{
        secret, err := r.kubeClientSet.CoreV1().Secrets(targetNs).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, key := range verifyKeys </span><span class="cov0" title="0">{
                if _, ok := secret.Data[key]; !ok </span><span class="cov0" title="0">{
                        return nil, errKeyMissing
                }</span>
        }

        <span class="cov0" title="0">return secret, nil</span>
}

func (r *Reconciler) createApiSecret(ctx context.Context, th *v1alpha1.TektonHub, hubDir, comp string) error <span class="cov0" title="0">{

        manifest, err := r.getHubManifest(ctx, th, hubDir, comp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">secret := manifest.Filter(mf.ByKind("Secret"))
        secretManifest, err := secret.Transform(
                mf.InjectNamespace(th.Spec.GetTargetNamespace()),
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := secretManifest.Apply(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) getHubManifest(ctx context.Context, th *v1alpha1.TektonHub, hubDir, comp string) (*mf.Manifest, error) <span class="cov0" title="0">{
        manifestLocation := filepath.Join(hubDir, comp)

        manifest, err := r.getManifest(ctx, th, manifestLocation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return manifest, nil</span>
}

func createDbSecret(name, namespace string, existingSecret *corev1.Secret, th *v1alpha1.TektonHub) *corev1.Secret <span class="cov0" title="0">{
        s := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "app": "db",
                        },
                        OwnerReferences: []metav1.OwnerReference{getOwnerRef(th)},
                },
                Type: corev1.SecretTypeOpaque,
        }

        if existingSecret != nil &amp;&amp; existingSecret.Data != nil </span><span class="cov0" title="0">{
                s.Data = existingSecret.Data
        }</span>

        <span class="cov0" title="0">s.StringData = make(map[string]string)

        defaultValues := map[string]string{
                secretKeyPostgresHost:     defaultPostgresHost,
                secretKeyPostgresDB:       defaultPostgresDB,
                secretKeyPostgresUser:     defaultPostgresUser,
                secretKeyPostgresPassword: defaultPostgresPassword,
                secretKeyPostgresPort:     defaultPostgresPort,
        }

        // fill default value for absents
        for secretKey, defaultValue := range defaultValues </span><span class="cov0" title="0">{
                if s.Data[secretKey] == nil || len(s.Data[secretKey]) == 0 </span><span class="cov0" title="0">{
                        s.StringData[secretKey] = defaultValue
                }</span>
        }

        <span class="cov0" title="0">return s</span>
}

// Get an ownerRef of TektonHub
func getOwnerRef(th *v1alpha1.TektonHub) metav1.OwnerReference <span class="cov0" title="0">{
        return *metav1.NewControllerRef(th, th.GroupVersionKind())
}</span>

// add key value pair to the given configmap name
func addConfigMapKeyValue(configMapName, key, value string) mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                kind := strings.ToLower(u.GetKind())
                if kind != "configmap" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if u.GetName() != configMapName </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">cm := &amp;corev1.ConfigMap{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cm.Data == nil </span><span class="cov0" title="0">{
                        cm.Data = map[string]string{}
                }</span>

                <span class="cov0" title="0">cm.Data[key] = value

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

func updateApiConfigMap(th *v1alpha1.TektonHub, configMapName string) mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{

                kind := strings.ToLower(u.GetKind())
                if kind != "configmap" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if u.GetName() != configMapName </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">cm := &amp;corev1.ConfigMap{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // TODO: Remove this condition in the next release
                <span class="cov0" title="0">if th.Spec.Api.HubConfigUrl != "" </span><span class="cov0" title="0">{

                        hubUrlConfigdata, err := getConfigDataFromHubURL(th)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">cm = updateConfigMapDataFromHubConfigURL(th, cm, hubUrlConfigdata)</span>

                } else<span class="cov0" title="0"> {

                        if len(th.Spec.Categories) &gt; 0 </span><span class="cov0" title="0">{
                                categories := ""
                                for _, c := range th.Spec.Categories </span><span class="cov0" title="0">{
                                        categories += fmt.Sprintf("- %s\n", c)
                                }</span>
                                <span class="cov0" title="0">cm.Data["CATEGORIES"] = categories</span>
                        }

                        <span class="cov0" title="0">if len(th.Spec.Catalogs) &gt; 0 </span><span class="cov0" title="0">{
                                catalogs := ""
                                for _, c := range th.Spec.Catalogs </span><span class="cov0" title="0">{
                                        catalogs = catalogs + getCatalogData(c, th)
                                }</span>
                                <span class="cov0" title="0">cm.Data["CATALOGS"] = catalogs</span>
                        }

                        <span class="cov0" title="0">if len(th.Spec.Scopes) &gt; 0 </span><span class="cov0" title="0">{
                                userScopes := ""
                                for _, s := range th.Spec.Scopes </span><span class="cov0" title="0">{
                                        scope := ""
                                        scope += fmt.Sprintf("- name: %s\n", s.Name)
                                        scope += fmt.Sprintf("  users: [%s]\n", strings.Join(s.Users, ", "))
                                        userScopes = userScopes + scope
                                }</span>
                                <span class="cov0" title="0">cm.Data["SCOPES"] = userScopes</span>
                        } else<span class="cov0" title="0"> {
                                cm.Data["SCOPES"] = ""
                        }</span>

                        <span class="cov0" title="0">if len(th.Spec.Default.Scopes) &gt; 0 </span><span class="cov0" title="0">{
                                defaultScopes := ""
                                scopes := fmt.Sprintf("%s\n", defaultScopes)
                                for _, d := range th.Spec.Default.Scopes </span><span class="cov0" title="0">{
                                        scopes += fmt.Sprintf("  - %s\n", d)
                                }</span>
                                <span class="cov0" title="0">defaultScopes = fmt.Sprintf(" scopes: \n%s", scopes)
                                cm.Data["DEFAULT"] = defaultScopes</span>
                        }
                }

                <span class="cov0" title="0">if th.Spec.Api.CatalogRefreshInterval != "" </span><span class="cov0" title="0">{
                        cm.Data["CATALOG_REFRESH_INTERVAL"] = th.Spec.Api.CatalogRefreshInterval
                }</span>

                <span class="cov0" title="0">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// TODO: Remove this function in the next release
// Adds Config Data from HubConfigUrl to API Config Map
func updateConfigMapDataFromHubConfigURL(th *v1alpha1.TektonHub, cm *corev1.ConfigMap, hubUrlConfigdata *Data) *corev1.ConfigMap <span class="cov0" title="0">{
        categories := ""
        for _, c := range hubUrlConfigdata.Categories </span><span class="cov0" title="0">{
                categories += fmt.Sprintf("- %s\n", c.Name)
        }</span>
        <span class="cov0" title="0">cm.Data["CATEGORIES"] = categories

        catalogs := ""
        for _, c := range hubUrlConfigdata.Catalogs </span><span class="cov0" title="0">{
                catalogs = catalogs + getCatalogData(c, th)
        }</span>
        <span class="cov0" title="0">cm.Data["CATALOGS"] = catalogs

        userScopes := ""
        for _, s := range hubUrlConfigdata.Scopes </span><span class="cov0" title="0">{
                scope := ""
                scope += fmt.Sprintf("- name: %s\n", s.Name)
                scope += fmt.Sprintf("  users: [%s]\n", strings.Join(s.Users, ", "))
                userScopes = userScopes + scope
        }</span>
        <span class="cov0" title="0">cm.Data["SCOPES"] = userScopes

        defaultScopes := ""
        scopes := fmt.Sprintf("%s\n", defaultScopes)
        for _, d := range hubUrlConfigdata.Default.Scopes </span><span class="cov0" title="0">{
                scopes += fmt.Sprintf("  - %s\n", d)
        }</span>
        <span class="cov0" title="0">defaultScopes = fmt.Sprintf(" scopes: \n%s", scopes)
        cm.Data["DEFAULT"] = defaultScopes

        return cm</span>
}

func getCatalogData(c v1alpha1.Catalog, th *v1alpha1.TektonHub) string <span class="cov0" title="0">{
        catalogs := ""
        v := reflect.ValueOf(c)

        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov0" title="0">{
                cat := ""
                key := strings.ToLower(v.Type().Field(i).Name)

                if v.Field(i).Interface() != "" </span><span class="cov0" title="0">{
                        if key == "name" </span><span class="cov0" title="0">{
                                key = "- " + key
                                cat += fmt.Sprintf("%s: %s\n", key, v.Field(i).Interface())
                        }</span> else<span class="cov0" title="0"> {
                                cat += fmt.Sprintf("  %s: %s\n", key, v.Field(i).Interface())
                        }</span>
                        <span class="cov0" title="0">catalogs = catalogs + cat</span>
                }
        }
        <span class="cov0" title="0">return catalogs</span>
}

// TODO: Remove this function in the next release
func getConfigDataFromHubURL(th *v1alpha1.TektonHub) (*Data, error) <span class="cov0" title="0">{
        var data = &amp;Data{}
        if th.Spec.Api.HubConfigUrl != "" </span><span class="cov0" title="0">{
                resp, err := http.Get(th.Spec.Api.HubConfigUrl)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                body, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">viper.SetConfigType("yaml")
                if err := viper.ReadConfig(bytes.NewBuffer(body)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err := viper.Unmarshal(&amp;data); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonhub

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "knative.dev/pkg/logging"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)
                hubCR := comp.(*v1alpha1.TektonHub)

                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.HubImagePrefix))
                images := common.ImageRegistryDomainOverride(imagesRaw)

                trans := extension.Transformers(hubCR)
                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdHub),
                        mf.InjectOwner(hubCR),
                        mf.InjectNamespace(hubCR.Spec.GetTargetNamespace()),
                        common.DeploymentImages(images),
                        common.DeploymentEnvVarKubernetesMinVersion(),
                        common.JobImages(images),
                        updateApiConfigMap(hubCR, apiConfigMapName),
                        addConfigMapKeyValue(uiConfigMapName, "API_URL", hubCR.Status.ApiRouteUrl),
                        addConfigMapKeyValue(uiConfigMapName, "AUTH_BASE_URL", hubCR.Status.AuthRouteUrl),
                        addConfigMapKeyValue(uiConfigMapName, "API_VERSION", "v1"),
                        addConfigMapKeyValue(uiConfigMapName, "REDIRECT_URI", hubCR.Status.UiRouteUrl),
                        addConfigMapKeyValue(uiConfigMapName, "CUSTOM_LOGO_BASE64_DATA", hubCR.Spec.CustomLogo.Base64Data),
                        addConfigMapKeyValue(uiConfigMapName, "CUSTOM_LOGO_MEDIA_TYPE", hubCR.Spec.CustomLogo.MediaType),
                        common.AddDeploymentRestrictedPSA(),
                        common.AddJobRestrictedPSA(),
                }

                trans = append(trans, extra...)

                err := common.Transform(ctx, manifest, hubCR, trans...)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to transform manifest")
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov0" title="0">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, hubCR.Spec.GetTargetNamespace(), hubCR.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov0" title="0">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        "go.uber.org/zap"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
)

func (i *InstallerSetClient) checkSet(ctx context.Context, comp v1alpha1.TektonComponent, isType string) ([]v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        labelSelector := i.getSetLabels(isType)
        logger.Debugf("%v/%v: checking installer sets with labels: %v", i.resourceKind, isType, labelSelector)

        is, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: labelSelector})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">logger.Debugf("%v/%v: found %v installer sets", i.resourceKind, isType, len(is.Items))

        iSets := is.Items

        if len(iSets) == 0 </span><span class="cov8" title="1">{
                logger.Debugf("%v/%v: installer sets not found", i.resourceKind, isType)
                return nil, ErrNotFound
        }</span>

        <span class="cov8" title="1">if len(iSets) == 1 </span><span class="cov8" title="1">{
                if iSets[0].DeletionTimestamp != nil </span><span class="cov0" title="0">{
                        return iSets, ErrSetsInDeletionState
                }</span>
        } else<span class="cov8" title="1"> {
                if iSets[0].DeletionTimestamp != nil || iSets[1].DeletionTimestamp != nil </span><span class="cov0" title="0">{
                        return iSets, ErrSetsInDeletionState
                }</span>
        }

        <span class="cov8" title="1">switch isType </span>{
        case InstallerTypeMain:<span class="cov8" title="1">
                if err := verifyMainInstallerSets(iSets); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("%v/%v: failed to verify main sets: %v", i.resourceKind, isType, err)
                        return iSets, err
                }</span>
        case InstallerTypePre, InstallerTypePost:<span class="cov8" title="1">
                if len(iSets) != 1 </span><span class="cov8" title="1">{
                        logger.Errorf("%v/%v: found multiple sets, expected one", i.resourceKind, isType)
                        return iSets, ErrInvalidState
                }</span>
        default:<span class="cov0" title="0">
                if !strings.HasPrefix(isType, InstallerTypeCustom) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid installerSet type")
                }</span>
                <span class="cov0" title="0">if len(iSets) != 1 </span><span class="cov0" title="0">{
                        logger.Errorf("%v/%v: found multiple sets, expected one", i.resourceKind, isType)
                        return iSets, ErrInvalidState
                }</span>
        }

        <span class="cov8" title="1">if err := verifyMeta(i.resourceKind, isType, logger, iSets[0], comp, i.releaseVersion); err != nil </span><span class="cov8" title="1">{
                logger.Errorf("%v/%v: meta check failed for installer type: %v", i.resourceKind, isType, err)
                return iSets, err
        }</span>
        <span class="cov8" title="1">logger.Debugf("%v/%v: meta check passed", i.resourceKind, isType)

        return iSets, nil</span>
}

func verifyMainInstallerSets(iSets []v1alpha1.TektonInstallerSet) error <span class="cov8" title="1">{
        if len(iSets) != 2 </span><span class="cov0" title="0">{
                return ErrInvalidState
        }</span>
        <span class="cov8" title="1">var static, deployment bool
        if strings.Contains(iSets[0].GetName(), InstallerSubTypeStatic) ||
                strings.Contains(iSets[1].GetName(), InstallerSubTypeStatic) </span><span class="cov8" title="1">{
                static = true
        }</span>
        <span class="cov8" title="1">if strings.Contains(iSets[0].GetName(), InstallerSubTypeDeployment) ||
                strings.Contains(iSets[1].GetName(), InstallerSubTypeDeployment) ||
                strings.Contains(iSets[0].GetName(), InstallerSubTypeStatefulset) ||
                strings.Contains(iSets[1].GetName(), InstallerSubTypeStatefulset) </span><span class="cov8" title="1">{
                deployment = true
        }</span>
        <span class="cov8" title="1">if !(static &amp;&amp; deployment) </span><span class="cov8" title="1">{
                return ErrInvalidState
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func verifyMeta(resourceKind, isType string, logger *zap.SugaredLogger, set v1alpha1.TektonInstallerSet, comp v1alpha1.TektonComponent, releaseVersion string) error <span class="cov8" title="1">{
        // Release Version Check
        logger.Debugf("%v/%v: release version check", resourceKind, isType)

        rVel, ok := set.GetLabels()[v1alpha1.ReleaseVersionKey]
        if !ok </span><span class="cov0" title="0">{
                return ErrInvalidState
        }</span>
        <span class="cov8" title="1">if rVel != releaseVersion </span><span class="cov8" title="1">{
                return ErrVersionDifferent
        }</span>

        // Target namespace check
        <span class="cov8" title="1">logger.Debugf("%v/%v: target namespace check", resourceKind, isType)

        targetNamespace, ok := set.GetAnnotations()[v1alpha1.TargetNamespaceKey]
        if !ok </span><span class="cov0" title="0">{
                return ErrInvalidState
        }</span>
        <span class="cov8" title="1">if targetNamespace != comp.GetSpec().GetTargetNamespace() </span><span class="cov8" title="1">{
                return ErrNsDifferent
        }</span>

        // Spec Hash Check
        <span class="cov8" title="1">logger.Debugf("%v/%v: spec hash check", resourceKind, isType)

        expectedHash, err := hash.Compute(comp.GetSpec())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">onClusterHash, ok := set.GetAnnotations()[v1alpha1.LastAppliedHashKey]
        if !ok </span><span class="cov0" title="0">{
                return ErrInvalidState
        }</span>
        <span class="cov8" title="1">if onClusterHash != expectedHash </span><span class="cov8" title="1">{
                return ErrUpdateRequired
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
        "knative.dev/pkg/logging"
)

var deletePropagationPolicy = metav1.DeletePropagationForeground

func (i *InstallerSetClient) CleanupMainSet(ctx context.Context) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx).With("kind", i.resourceKind, "type", InstallerTypeMain)

        list, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabels(InstallerTypeMain)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(list.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugf("no installerSets found for %s, nothing to clean up", InstallerTypeMain)
                return nil
        }</span>

        <span class="cov8" title="1">if len(list.Items) != 2 </span><span class="cov0" title="0">{
                logger.Warnf("found %d installerSets for %s when expecting 2, proceeding with cleanup",
                        len(list.Items), InstallerTypeMain)
        }</span>

        // delete all static installerSet first and then deployment one
        <span class="cov8" title="1">for _, is := range list.Items </span><span class="cov8" title="1">{
                if strings.Contains(is.GetName(), InstallerSubTypeStatic) </span><span class="cov8" title="1">{
                        logger.Debugf("deleting main-static installer set: %s", is.GetName())
                        err = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{
                                PropagationPolicy: &amp;deletePropagationPolicy,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete main-static installer set for %s", is.GetName())
                        }</span>
                }
        }

        // now delete all deployment installerSet
        <span class="cov8" title="1">for _, is := range list.Items </span><span class="cov8" title="1">{
                if strings.Contains(is.GetName(), InstallerSubTypeDeployment) ||
                        strings.Contains(is.GetName(), InstallerSubTypeStatefulset) </span><span class="cov8" title="1">{
                        logger.Debugf("deleting main-deployment installer set: %s", is.GetName())
                        err = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{
                                PropagationPolicy: &amp;deletePropagationPolicy,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete main-deployment installer set for %s", is.GetName())
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *InstallerSetClient) CleanupSet(ctx context.Context, setType string) error <span class="cov8" title="1">{
        return i.cleanup(ctx, setType)
}</span>

func (i *InstallerSetClient) CleanupPreSet(ctx context.Context) error <span class="cov8" title="1">{
        return i.cleanup(ctx, InstallerTypePre)
}</span>

func (i *InstallerSetClient) CleanupPostSet(ctx context.Context) error <span class="cov8" title="1">{
        return i.cleanup(ctx, InstallerTypePost)
}</span>

func (i *InstallerSetClient) CleanupCustomSet(ctx context.Context, customName string) error <span class="cov0" title="0">{
        setType := InstallerTypeCustom + "-" + strings.ToLower(customName)
        return i.cleanup(ctx, setType)
}</span>

func (i *InstallerSetClient) CleanupAllCustomSet(ctx context.Context) error <span class="cov0" title="0">{
        labelSelector := labels.NewSelector()
        createdReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})
        if createdReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*createdReq)
        }</span>
        <span class="cov0" title="0">err := i.clientSet.DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{
                LabelSelector: labelSelector.String(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete %s custom sets: %v", i.resourceKind, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (i *InstallerSetClient) cleanup(ctx context.Context, isType string) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx).With("kind", i.resourceKind, "type", isType)

        list, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabels(isType)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(list.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugf("no installerSets found for %s, nothing to clean up", isType)
                return nil
        }</span>

        <span class="cov8" title="1">if len(list.Items) &gt; 1 </span><span class="cov0" title="0">{
                logger.Warnf("found %d installerSets for %s when expecting at most 1, cleaning up all matching %s",
                        len(list.Items), isType, isType)
        }</span>

        <span class="cov8" title="1">for _, is := range list.Items </span><span class="cov8" title="1">{
                logger.Debugf("deleting %s installer set: %s", isType, is.GetName())
                err = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{
                        PropagationPolicy: &amp;deletePropagationPolicy,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete %s set: %s", isType, is.GetName())
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *InstallerSetClient) CleanupSubTypeDeployment(ctx context.Context) error <span class="cov0" title="0">{
        return i.cleanupSubType(ctx, InstallerTypeMain, InstallerSubTypeDeployment)
}</span>

func (i *InstallerSetClient) CleanupSubTypeStatefulset(ctx context.Context) error <span class="cov0" title="0">{
        return i.cleanupSubType(ctx, InstallerTypeMain, InstallerSubTypeStatefulset)
}</span>

func (i *InstallerSetClient) cleanupSubType(ctx context.Context, isType string, isSubType string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("kind", i.resourceKind, "type", isType)

        list, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabels(isType)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(list.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugf("no installerSets found for %s, nothing to clean up", isType)
                return nil
        }</span>

        <span class="cov0" title="0">if len(list.Items) &gt; 1 </span><span class="cov0" title="0">{
                logger.Warnf("found %d installerSets for %s when expecting at most 1, cleaning up all matching %s",
                        len(list.Items), isType, isSubType)
        }</span>

        <span class="cov0" title="0">for _, is := range list.Items </span><span class="cov0" title="0">{
                if strings.Contains(is.GetName(), isSubType) </span><span class="cov0" title="0">{
                        logger.Debugf("deleting %s installer set: %s", isType, is.GetName())
                        err = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{
                                PropagationPolicy: &amp;deletePropagationPolicy,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to delete %s set: %s", isType, is.GetName())
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (i *InstallerSetClient) CleanupWithLabelInstallTypeDeployment(ctx context.Context, isType string) error <span class="cov0" title="0">{
        return i.cleanupWithLabel(ctx, isType, InstallerSubTypeDeployment)
}</span>

func (i *InstallerSetClient) CleanupWithLabelInstallTypeStatefulset(ctx context.Context, isType string) error <span class="cov0" title="0">{
        return i.cleanupWithLabel(ctx, isType, InstallerSubTypeStatefulset)
}</span>

// cleanupWithLabel cleans installersets using isType as label selector example
// v1alpha1.InstallerSetType: chain and v1alpha1.InstallerSetInstallType: deployment
func (i *InstallerSetClient) cleanupWithLabel(ctx context.Context, isType string, isInstallType string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("kind", i.resourceKind, "type", isType)

        list, err := i.clientSet.List(ctx, metav1.ListOptions{LabelSelector: i.getSetLabelsWithTypeAndInstallType(isType, isInstallType)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(list.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugf("no installerSets found for %s, nothing to clean up", isType)
                return nil
        }</span>

        <span class="cov0" title="0">if len(list.Items) &gt; 1 </span><span class="cov0" title="0">{
                logger.Warnf("found %d installerSets for %s when expecting at most 1, cleaning up all matching %s",
                        len(list.Items), isType, isInstallType)
        }</span>

        <span class="cov0" title="0">for _, is := range list.Items </span><span class="cov0" title="0">{
                logger.Debugf("deleting %s installer set: %s, of installType: %s", isType, is.GetName(), isInstallType)
                err = i.clientSet.Delete(ctx, is.GetName(), metav1.DeleteOptions{
                        PropagationPolicy: &amp;deletePropagationPolicy,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to delete %s set: %s", isType, is.GetName())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientSet "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
)

const (
        InstallerSubTypeStatic      = "static"
        InstallerSubTypeDeployment  = "deployment"
        InstallerSubTypeStatefulset = "statefulset"

        InstallerTypeMain   = "main"
        InstallerTypePre    = "pre"
        InstallerTypePost   = "post"
        InstallerTypeCustom = "custom"
)

var (
        ErrInvalidState        = fmt.Errorf("installer sets in invalid state")
        ErrNotFound            = fmt.Errorf("installer sets not found")
        ErrVersionDifferent    = fmt.Errorf("installer sets release version doesn't match")
        ErrNsDifferent         = fmt.Errorf("installer sets target namespace doesn't match")
        ErrUpdateRequired      = fmt.Errorf("installer sets needs to be updated")
        ErrSetsInDeletionState = fmt.Errorf("installer sets are in deletion state, will come back")
)

type FilterAndTransform func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error)

type InstallerSetClient struct {
        clientSet        clientSet.TektonInstallerSetInterface
        releaseVersion   string
        componentVersion string
        resourceKind     string
        metrics          Metrics
}

func NewInstallerSetClient(clientSet clientSet.TektonInstallerSetInterface, releaseVersion, componentVersion string, resourceKind string, metrics Metrics) *InstallerSetClient <span class="cov8" title="1">{
        return &amp;InstallerSetClient{
                clientSet:        clientSet,
                releaseVersion:   releaseVersion,
                resourceKind:     resourceKind,
                metrics:          metrics,
                componentVersion: componentVersion,
        }
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "fmt"
        "strings"
        "time"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
)

func (i *InstallerSetClient) create(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, isType string, customLabels map[string]string) ([]v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx).With("kind", i.resourceKind, "type", isType)

        if isType == InstallerTypeMain </span><span class="cov8" title="1">{
                sets, err := i.makeMainSets(ctx, comp, manifest)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("installer set creation failed for main type: %v", err)
                        return sets, err
                }</span>
                <span class="cov8" title="1">return sets, nil</span>
        }

        <span class="cov8" title="1">kind := strings.ToLower(strings.TrimPrefix(i.resourceKind, "Tekton"))
        isName := fmt.Sprintf("%s-%s-", kind, isType)

        iS, err := i.makeInstallerSet(ctx, comp, manifest, isName, isType, customLabels)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">iS, err = i.clientSet.Create(ctx, iS, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return []v1alpha1.TektonInstallerSet{*iS}, nil</span>
}

func (i *InstallerSetClient) makeMainSets(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest) ([]v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        staticManifest := manifest.Filter(mf.Not(mf.ByKind("Deployment")), mf.Not(mf.ByKind("Service")))
        deploymentManifest := manifest.Filter(mf.Any(mf.ByKind("Deployment"), mf.ByKind("Service")))
        statefulSetManifest := manifest.Filter(mf.Any(mf.ByKind("StatefulSet"), mf.Any(mf.ByKind("Deployment")), mf.ByKind("Service")))

        kind := strings.ToLower(strings.TrimPrefix(i.resourceKind, "Tekton"))
        staticName := fmt.Sprintf("%s-%s-%s-", kind, InstallerTypeMain, InstallerSubTypeStatic)

        staticIS, err := i.makeInstallerSet(ctx, comp, &amp;staticManifest, staticName, InstallerTypeMain, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">staticIS, err = i.clientSet.Create(ctx, staticIS, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := i.waitForStatus(ctx, staticIS); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">deployName := fmt.Sprintf("%s-%s-%s-", kind, InstallerTypeMain, InstallerSubTypeDeployment)

        deploymentIS, err := i.makeInstallerSet(ctx, comp, &amp;deploymentManifest, deployName, InstallerTypeMain, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">deploymentIS, err = i.clientSet.Create(ctx, deploymentIS, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">statefulSet := false
        if pipeline, ok := comp.(*v1alpha1.TektonPipeline); ok </span><span class="cov0" title="0">{
                statefulSet = pipeline.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *pipeline.Spec.Performance.StatefulsetOrdinals
        }</span>
        <span class="cov8" title="1">if statefulSet </span><span class="cov0" title="0">{
                stsName := fmt.Sprintf("%s-%s-%s-", kind, InstallerTypeMain, InstallerSubTypeStatefulset)
                stsIS, err := i.makeInstallerSet(ctx, comp, &amp;statefulSetManifest, stsName, InstallerTypeMain, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">stsIS, err = i.clientSet.Create(ctx, stsIS, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return []v1alpha1.TektonInstallerSet{*staticIS, *deploymentIS, *stsIS}, nil</span>
        }

        <span class="cov8" title="1">return []v1alpha1.TektonInstallerSet{*staticIS, *deploymentIS}, nil</span>
}

func (i *InstallerSetClient) waitForStatus(ctx context.Context, set *v1alpha1.TektonInstallerSet) error <span class="cov8" title="1">{
        for cnt := 0; cnt &lt; 3; cnt++ </span><span class="cov8" title="1">{
                onClusterSet, err := i.clientSet.Get(ctx, set.GetName(), metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // once status is initialised for static set we can create deployment set
                <span class="cov8" title="1">ready := onClusterSet.Status.GetCondition(apis.ConditionReady)
                if ready != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // if status is not initialised then wait
                <span class="cov8" title="1">time.Sleep(3 * time.Second)</span>
        }
        // if still the status is not initialised then create the next set and let it fail
        // there may be something else wrong
        <span class="cov8" title="1">return nil</span>
}

func (i *InstallerSetClient) makeInstallerSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, isName, isType string, customLabels map[string]string) (*v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        specHash, err := hash.Compute(comp.GetSpec())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // get default labels of installerset
        <span class="cov8" title="1">labels := i.getDefaultLabels(isType)
        // append custom labels
        for key, value := range customLabels </span><span class="cov0" title="0">{
                labels[key] = value
        }</span>

        <span class="cov8" title="1">ownerRef := *metav1.NewControllerRef(comp, v1alpha1.SchemeGroupVersion.WithKind(i.resourceKind))
        return &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: isName,
                        Labels:       labels,
                        Annotations: map[string]string{
                                v1alpha1.TargetNamespaceKey: comp.GetSpec().GetTargetNamespace(),
                                v1alpha1.LastAppliedHashKey: specHash,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }, nil</span>
}

func (i *InstallerSetClient) getDefaultLabels(isType string) map[string]string <span class="cov8" title="1">{
        labels := map[string]string{}
        labels[v1alpha1.CreatedByKey] = i.resourceKind
        labels[v1alpha1.ReleaseVersionKey] = i.releaseVersion
        labels[v1alpha1.InstallerSetType] = isType
        return labels
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    hcompp://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "fmt"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
)

// VersionedTaskSet this is an exception case where we create one installer set for one minor version
// not for patch version, and we don't remove older installer sets on upgrade, hence keeping it different
// from custom set otherwise code becomes unnecessarily complex to handle this case
func (i *InstallerSetClient) VersionedTaskSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest,
        filterAndTransform FilterAndTransform, insType, insName string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // perform transformation
        manifestUpdated, err := filterAndTransform(ctx, manifest, comp)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("error on transforming a manifest",
                        "component", comp.GroupVersionKind().String(),
                        "componentName", comp.GetName(),
                )
                return err
        }</span>

        <span class="cov0" title="0">setType := fmt.Sprintf("%s-%s", InstallerTypeCustom, strings.ToLower(insType))
        versionedTaskLS := v1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.InstallerSetType:       setType,
                        v1alpha1.ReleaseMinorVersionKey: getPatchVersionTrimmed(i.releaseVersion),
                },
        }
        versionedTaskLabelSelector, err := common.LabelSelector(versionedTaskLS)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">is, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: versionedTaskLabelSelector})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(is.Items) == 0 </span><span class="cov0" title="0">{
                vctSet, err := i.makeInstallerSet(ctx, comp, manifestUpdated, insName, setType, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">vctSet.Labels[v1alpha1.ReleaseMinorVersionKey] = getPatchVersionTrimmed(i.releaseVersion)
                vctSet.GenerateName = fmt.Sprintf("%s-%s-", insName, getPatchVersionTrimmed(i.releaseVersion))

                _, err = i.clientSet.Create(ctx, vctSet, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return v1alpha1.REQUEUE_EVENT_AFTER</span>
        }

        <span class="cov0" title="0">if err := i.statusCheck(logger, setType, is.Items); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getPatchVersionTrimmed(version string) string <span class="cov0" title="0">{
        endIndex := strings.LastIndex(version, ".")
        if endIndex != -1 </span><span class="cov0" title="0">{
                version = version[:endIndex]
        }</span>
        <span class="cov0" title="0">return version</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package fake

import (
        "context"
        "fmt"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        v1alpha12 "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/watch"
)

type fakeClient struct {
        resource map[string]*v1alpha1.TektonInstallerSet
}

func NewFakeISClient(is ...*v1alpha1.TektonInstallerSet) v1alpha12.TektonInstallerSetInterface <span class="cov0" title="0">{
        client := &amp;fakeClient{
                resource: map[string]*v1alpha1.TektonInstallerSet{},
        }
        for _, r := range is </span><span class="cov0" title="0">{
                inst := r
                client.resource[inst.GetName()] = inst
        }</span>
        <span class="cov0" title="0">return client</span>
}

func (f fakeClient) Create(ctx context.Context, tektonInstallerSet *v1alpha1.TektonInstallerSet, opts metav1.CreateOptions) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        tektonInstallerSet.SetName(tektonInstallerSet.GenerateName + "test")
        if _, ok := f.resource[tektonInstallerSet.GetName()]; ok </span><span class="cov0" title="0">{
                return nil, errors.NewAlreadyExists(schema.GroupResource{
                        Group:    v1alpha1.GroupName,
                        Resource: v1alpha1.KindTektonInstallerSet,
                }, tektonInstallerSet.GetName())
        }</span>
        <span class="cov0" title="0">f.resource[tektonInstallerSet.GetName()] = tektonInstallerSet
        return tektonInstallerSet, nil</span>
}

func (f fakeClient) Update(ctx context.Context, tektonInstallerSet *v1alpha1.TektonInstallerSet, opts metav1.UpdateOptions) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        f.resource[tektonInstallerSet.GetName()] = tektonInstallerSet
        return f.resource[tektonInstallerSet.GetName()], nil
}</span>

func (f fakeClient) UpdateStatus(ctx context.Context, tektonInstallerSet *v1alpha1.TektonInstallerSet, opts metav1.UpdateOptions) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        f.resource[tektonInstallerSet.GetName()] = tektonInstallerSet
        return f.resource[tektonInstallerSet.GetName()], nil
}</span>

func (f fakeClient) Delete(ctx context.Context, name string, opts metav1.DeleteOptions) error <span class="cov0" title="0">{
        delete(f.resource, name)
        return nil
}</span>

func (f fakeClient) DeleteCollection(ctx context.Context, opts metav1.DeleteOptions, listOpts metav1.ListOptions) error <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (f fakeClient) Get(ctx context.Context, name string, opts metav1.GetOptions) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        if res, ok := f.resource[name]; ok </span><span class="cov0" title="0">{
                return res, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("resource not found")</span>
}

func (f fakeClient) List(ctx context.Context, opts metav1.ListOptions) (*v1alpha1.TektonInstallerSetList, error) <span class="cov0" title="0">{
        list := []v1alpha1.TektonInstallerSet{}
        for i := range f.resource </span><span class="cov0" title="0">{
                list = append(list, *f.resource[i])
        }</span>
        <span class="cov0" title="0">return &amp;v1alpha1.TektonInstallerSetList{Items: list}, nil</span>
}

func (f fakeClient) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}

func (f fakeClient) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts metav1.PatchOptions, subresources ...string) (result *v1alpha1.TektonInstallerSet, err error) <span class="cov0" title="0">{
        //TODO implement me
        panic("implement me")</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
)

func (i *InstallerSetClient) getSetLabels(setType string) string <span class="cov8" title="1">{
        labelSelector := labels.NewSelector()
        createdReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})
        if createdReq != nil </span><span class="cov8" title="1">{
                labelSelector = labelSelector.Add(*createdReq)
        }</span>
        <span class="cov8" title="1">typeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetType, selection.Equals, []string{setType})
        if typeReq != nil </span><span class="cov8" title="1">{
                labelSelector = labelSelector.Add(*typeReq)
        }</span>
        <span class="cov8" title="1">return labelSelector.String()</span>
}

func (i *InstallerSetClient) getSetLabelsWithTypeAndInstallType(setType, setInstallType string) string <span class="cov0" title="0">{
        labelSelector := labels.NewSelector()
        createdReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})
        if createdReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*createdReq)
        }</span>
        <span class="cov0" title="0">typeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetType, selection.Equals, []string{setType})
        if typeReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*typeReq)
        }</span>
        <span class="cov0" title="0">installtypeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetInstallType, selection.Equals, []string{setInstallType})
        if installtypeReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*installtypeReq)
        }</span>
        <span class="cov0" title="0">return labelSelector.String()</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
)

// ListCustomSet return the lists of custom sets with the provided labelSelector
func (i *InstallerSetClient) ListCustomSet(ctx context.Context, labelSelector string) (*v1alpha1.TektonInstallerSetList, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        logger.Debugf("%v: checking installer sets with labels: %v", i.resourceKind, labelSelector)

        is, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: labelSelector})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(is.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugf("%v: no installer sets found with labels: %v", i.resourceKind, labelSelector)
        }</span>
        <span class="cov0" title="0">return is, nil</span>
}

// ListPreSet return the lists of Pre sets with the provided labelSelector
func (i *InstallerSetClient) ListPreSet(ctx context.Context, labelSelector string) (*v1alpha1.TektonInstallerSetList, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        logger.Debugf("%v: checking installer sets with labels: %v", i.resourceKind, labelSelector)

        is, err := i.clientSet.List(ctx, v1.ListOptions{LabelSelector: labelSelector})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(is.Items) == 0 </span><span class="cov0" title="0">{
                logger.Debugf("%v: no installer sets found with labels: %v", i.resourceKind, labelSelector)
        }</span>
        <span class="cov0" title="0">return is, nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "errors"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "go.uber.org/zap"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
)

const (
        metricsNew     = "NewInstall"
        metricsUpgrade = "Upgrade"
)

func (i *InstallerSetClient) MainSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, filterAndTransform FilterAndTransform) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        setType := InstallerTypeMain

        // perform transformation
        manifestUpdated, err := filterAndTransform(ctx, manifest, comp)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("error on transforming a manifest",
                        "component", comp.GroupVersionKind().String(),
                        "componentName", comp.GetName(),
                )
                return err
        }</span>

        <span class="cov8" title="1">sets, err := i.checkSet(ctx, comp, setType)
        if err == nil </span><span class="cov8" title="1">{
                logger.Debugf("%v/%v: found %v installer sets", i.resourceKind, setType, len(sets))
        }</span>

        <span class="cov8" title="1">switch err </span>{
        case ErrNotFound:<span class="cov8" title="1">
                logger.Debugf("%v/%v: installer set not found, creating", i.resourceKind, setType)
                sets, err = i.create(ctx, comp, manifestUpdated, setType, nil)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("%v/%v: failed to create main installer set: %v", i.resourceKind, setType, err)
                        return err
                }</span>
                <span class="cov8" title="1">if comp.GetStatus().GetCondition(v1alpha1.InstallerSetAvailable).IsUnknown() </span><span class="cov8" title="1">{
                        i.metrics.LogMetrics(metricsNew, i.componentVersion, logger)
                }</span>

        case ErrInvalidState, ErrNsDifferent, ErrVersionDifferent:<span class="cov0" title="0">
                logger.Debugf("%v/%v: installer set not in valid state : %v, cleaning up!", i.resourceKind, setType, err)
                if err := i.CleanupMainSet(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("%v/%v: failed to cleanup main installer set: %v", i.resourceKind, setType, err)
                        return err
                }</span>
                <span class="cov0" title="0">if err == ErrVersionDifferent </span><span class="cov0" title="0">{
                        i.metrics.LogMetrics(metricsUpgrade, i.componentVersion, logger)
                        markComponentStatus(comp, v1alpha1.UpgradePending)
                }</span> else<span class="cov0" title="0"> {
                        markComponentStatus(comp, v1alpha1.Reinstalling)
                }</span>
                <span class="cov0" title="0">logger.Debugf("%v/%v: returning, will create main installer sets in further reconcile", i.resourceKind, setType)
                return v1alpha1.REQUEUE_EVENT_AFTER</span>

        case ErrUpdateRequired:<span class="cov0" title="0">
                logger.Debugf("%v/%v: updating installer set", i.resourceKind, setType)
                sets, err = i.update(ctx, comp, sets, manifestUpdated, setType)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("%v/%v: update failed : %v", i.resourceKind, setType, err)
                        return err
                }</span>
        case ErrSetsInDeletionState:<span class="cov0" title="0">
                logger.Debugf("%v/%v: %v", i.resourceKind, setType, err)
                return v1alpha1.REQUEUE_EVENT_AFTER</span>
        }

        //Mark InstallerSet Available
        <span class="cov8" title="1">comp.GetStatus().MarkInstallerSetAvailable()

        if err := i.statusCheck(logger, setType, sets); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        //Mark InstallerSet Ready
        <span class="cov8" title="1">comp.GetStatus().MarkInstallerSetReady()

        return nil</span>
}

func (i *InstallerSetClient) statusCheck(logger *zap.SugaredLogger, setType string, sets []v1alpha1.TektonInstallerSet) error <span class="cov8" title="1">{
        for _, set := range sets </span><span class="cov8" title="1">{
                ready := set.Status.GetCondition(apis.ConditionReady)
                if ready.IsUnknown() </span><span class="cov8" title="1">{
                        logger.Debugf("%v/%v: installer set %v status not set, wait !", i.resourceKind, setType, set.GetName())
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov8" title="1">if !ready.IsTrue() </span><span class="cov8" title="1">{
                        msg := fmt.Sprintf("%v/%v: installer set not ready, will retry: %v", i.resourceKind, setType, ready.Message)
                        logger.Debugf(msg)
                        return errors.New(msg)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func markComponentStatus(comp v1alpha1.TektonComponent, status string) <span class="cov0" title="0">{
        comp.GetStatus().MarkInstallerSetNotReady(status)
        comp.GetStatus().MarkInstallerSetNotReady(status)
        comp.GetStatus().MarkPostReconcilerFailed(status)
        comp.GetStatus().MarkNotReady(status)
}</span>
</pre>
		
		<pre class="file" id="file99" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
)

func (i *InstallerSetClient) RemoveObsoleteSets(ctx context.Context) error <span class="cov0" title="0">{
        var sets []string

        switch i.resourceKind </span>{
        case v1alpha1.KindTektonPipeline:<span class="cov0" title="0">
                sets = []string{"pipeline", "PrePipeline", "PostPipeline"}</span>
        case v1alpha1.KindTektonTrigger:<span class="cov0" title="0">
                sets = []string{"trigger"}</span>
        case v1alpha1.KindTektonChain:<span class="cov0" title="0">
                sets = []string{"chain"}</span>
        case v1alpha1.KindTektonAddon:<span class="cov0" title="0">
                // not adding VersionedClusterTask here, as we keep versioned clustertasks on upgrade
                sets = []string{"ClusterTask", "CommunityClusterTask", "PipelinesTemplate", "TriggersResources", "ConsoleCLI", "MiscellaneousResources", "PipelinesAsCode"}</span>
        case v1alpha1.KindTektonDashboard:<span class="cov0" title="0">
                sets = []string{"dashboard"}</span>
        case v1alpha1.ManualApprovalGates:<span class="cov0" title="0">
                sets = []string{"manualapprovalgate"}</span>
        }

        <span class="cov0" title="0">labelSelector := labels.NewSelector()
        createdReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{i.resourceKind})
        if createdReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*createdReq)
        }</span>
        <span class="cov0" title="0">typeReq, _ := labels.NewRequirement(v1alpha1.InstallerSetType, selection.In, sets)
        if typeReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*typeReq)
        }</span>
        <span class="cov0" title="0">err := i.clientSet.DeleteCollection(ctx, metav1.DeleteOptions{},
                metav1.ListOptions{LabelSelector: labelSelector.String()})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "knative.dev/pkg/logging"
)

func (i *InstallerSetClient) PostSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, filterAndTransform FilterAndTransform) error <span class="cov0" title="0">{
        return i.applyTransformationAndCreateSet(ctx, comp, InstallerTypePost, manifest, filterAndTransform, nil)
}</span>

func (i *InstallerSetClient) PreSet(ctx context.Context, comp v1alpha1.TektonComponent, manifest *mf.Manifest, filterAndTransform FilterAndTransform) error <span class="cov8" title="1">{
        return i.applyTransformationAndCreateSet(ctx, comp, InstallerTypePre, manifest, filterAndTransform, nil)
}</span>

func (i *InstallerSetClient) CustomSet(ctx context.Context, comp v1alpha1.TektonComponent, customName string, manifest *mf.Manifest, filterAndTransform FilterAndTransform, customLabels map[string]string) error <span class="cov0" title="0">{
        setType := InstallerTypeCustom + "-" + strings.ToLower(customName)
        return i.applyTransformationAndCreateSet(ctx, comp, setType, manifest, filterAndTransform, customLabels)
}</span>

func (i *InstallerSetClient) applyTransformationAndCreateSet(ctx context.Context, comp v1alpha1.TektonComponent, setType string, manifest *mf.Manifest, filterAndTransform FilterAndTransform, customLabels map[string]string) error <span class="cov8" title="1">{
        // perform transformation
        manifestUpdated, err := filterAndTransform(ctx, manifest, comp)
        if err != nil </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)
                logger.Errorw("error on transforming a manifest",
                        "component", comp.GroupVersionKind().String(),
                        "componentName", comp.GetName(),
                )
                return err
        }</span>
        <span class="cov8" title="1">return i.createSet(ctx, comp, setType, manifestUpdated, customLabels)</span>
}

func (i *InstallerSetClient) createSet(ctx context.Context, comp v1alpha1.TektonComponent, setType string, manifest *mf.Manifest, customLabels map[string]string) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        sets, err := i.checkSet(ctx, comp, setType)
        if err == nil </span><span class="cov8" title="1">{
                logger.Debugf("%v/%v: found %v installer sets", i.resourceKind, setType, len(sets))
        }</span>

        <span class="cov8" title="1">switch err </span>{
        case ErrNotFound:<span class="cov8" title="1">
                logger.Debugf("%v/%v: installer set not found, creating", i.resourceKind, setType)
                sets, err = i.create(ctx, comp, manifest, setType, customLabels)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("%v/%v: failed to create installer set: %v", i.resourceKind, setType, err)
                        return err
                }</span>

        case ErrInvalidState, ErrNsDifferent, ErrVersionDifferent:<span class="cov8" title="1">
                logger.Debugf("%v/%v: installer set not in valid state : %v, cleaning up!", i.resourceKind, setType, err)
                if err := i.CleanupSet(ctx, setType); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("%v/%v: failed to cleanup installer set: %v", i.resourceKind, setType, err)
                        return nil
                }</span>
                <span class="cov8" title="1">logger.Debugf("%v/%v: returning, will create installer sets in further reconcile", i.resourceKind, setType)
                return v1alpha1.REQUEUE_EVENT_AFTER</span>

        case ErrUpdateRequired:<span class="cov8" title="1">
                logger.Debugf("%v/%v: updating installer set", i.resourceKind, setType)
                sets, err = i.update(ctx, comp, sets, manifest, setType)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("%v/%v: update failed : %v", i.resourceKind, setType, err)
                        return err
                }</span>
        case ErrSetsInDeletionState:<span class="cov0" title="0">
                logger.Debugf("%v/%v: %v", i.resourceKind, setType, err)
                return v1alpha1.REQUEUE_EVENT_AFTER</span>
        }

        <span class="cov8" title="1">if err := i.statusCheck(logger, setType, sets); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package client

import (
        "context"
        "fmt"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/util/retry"
        "knative.dev/pkg/logging"
)

func (i *InstallerSetClient) update(ctx context.Context, comp v1alpha1.TektonComponent, toBeUpdatedIS []v1alpha1.TektonInstallerSet, manifest *mf.Manifest, isType string) ([]v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx).With("kind", i.resourceKind, "type", isType)

        if isType == InstallerTypeMain </span><span class="cov8" title="1">{
                sets, err := i.updateMainSets(ctx, comp, toBeUpdatedIS, manifest)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("installer set update failed for main type: %v", err)
                        return sets, err
                }</span>
                <span class="cov8" title="1">return sets, nil</span>
        }

        <span class="cov8" title="1">logger.Debugf("updating installer set: %v", toBeUpdatedIS[0].GetName())
        updatedSet, err := i.updateSet(ctx, comp, toBeUpdatedIS[0], manifest)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update installerset : %v", err)
        }</span>
        <span class="cov8" title="1">logger.Debugf("updated installer set: %v", toBeUpdatedIS[0].GetName())
        return []v1alpha1.TektonInstallerSet{*updatedSet}, nil</span>
}

func (i *InstallerSetClient) updateMainSets(ctx context.Context, comp v1alpha1.TektonComponent, toBeUpdatedIS []v1alpha1.TektonInstallerSet, manifest *mf.Manifest) ([]v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Debugf("updating main installersets for %v", i.resourceKind)

        staticManifest := manifest.Filter(mf.Not(mf.ByKind("Deployment")))
        deploymentManifest := manifest.Filter(mf.ByKind("Deployment"))

        var updatedSets []v1alpha1.TektonInstallerSet

        for _, is := range toBeUpdatedIS </span><span class="cov8" title="1">{
                logger.Debugf("updating installer set: %v", is.GetName())

                var manifest *mf.Manifest
                if strings.Contains(is.GetName(), InstallerSubTypeStatic) </span><span class="cov8" title="1">{
                        manifest = &amp;staticManifest
                }</span> else<span class="cov8" title="1"> {
                        manifest = &amp;deploymentManifest
                }</span>

                <span class="cov8" title="1">updatedSet, err := i.updateSet(ctx, comp, is, manifest)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to update installerset : %v", err)
                }</span>

                <span class="cov8" title="1">logger.Debugf("updated installer set: %v", is.GetName())
                updatedSets = append(updatedSets, *updatedSet)</span>
        }
        <span class="cov8" title="1">return updatedSets, nil</span>
}

func (i *InstallerSetClient) updateSet(ctx context.Context, comp v1alpha1.TektonComponent, set v1alpha1.TektonInstallerSet, manifest *mf.Manifest) (*v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        var updatedSet *v1alpha1.TektonInstallerSet
        retryErr := retry.RetryOnConflict(retry.DefaultRetry, func() error </span><span class="cov8" title="1">{
                onCluster, err := i.clientSet.Get(ctx, set.GetName(), metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">specHash, err := hash.Compute(comp.GetSpec())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">current := onCluster.GetAnnotations()
                current[v1alpha1.LastAppliedHashKey] = specHash
                onCluster.SetAnnotations(current)

                onCluster.Spec.Manifests = manifest.Resources()

                updatedSet, err = i.clientSet.Update(ctx, onCluster, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if retryErr != nil </span><span class="cov0" title="0">{
                return nil, retryErr
        }</span>
        <span class="cov8" title="1">return updatedSet, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"

        mfc "github.com/manifestival/client-go-client"
        "go.uber.org/zap"
        "k8s.io/client-go/tools/cache"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonInstallerReconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektoninstallerset"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        deploymentinformer "knative.dev/pkg/client/injection/kube/informers/apps/v1/deployment"
        statefulsetinformer "knative.dev/pkg/client/injection/kube/informers/apps/v1/statefulset"
        serviceAccountInformer "knative.dev/pkg/client/injection/kube/informers/core/v1/serviceaccount"
        clusterRoleInformer "knative.dev/pkg/client/injection/kube/informers/rbac/v1/clusterrole"
        clusterRoleBindingInformer "knative.dev/pkg/client/injection/kube/informers/rbac/v1/clusterrolebinding"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController()(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController() injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating client from injected config", zap.Error(err))
                }</span>

                <span class="cov0" title="0">c := &amp;Reconciler{
                        operatorClientSet: operatorclient.Get(ctx),
                        mfClient:          mfclient,
                        kubeClientSet:     kubeclient.Get(ctx),
                }
                impl := tektonInstallerReconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for TektonInstallerSet")

                if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := deploymentinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonInstallerSet{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register Deployment informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := statefulsetinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonInstallerSet{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register StatefulSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := clusterRoleBindingInformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonInstallerSet{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register ClusterRoleBinding informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := clusterRoleInformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonInstallerSet{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register ClusterRole informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := serviceAccountInformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonInstallerSet{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register ServiceAccount informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file103" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"
        "fmt"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        "go.uber.org/zap"
        appsv1 "k8s.io/api/apps/v1"
        autoscalingv2 "k8s.io/api/autoscaling/v2"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/kubernetes/scheme"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

const (
        annotationsPath = "metadata.annotations"
        labelsPath      = "metadata.labels"
)

type installer struct {
        manifest        *mf.Manifest
        mfClient        mf.Client
        kubeClientSet   kubernetes.Interface
        logger          *zap.SugaredLogger
        crds            []unstructured.Unstructured
        clusterScoped   []unstructured.Unstructured
        namespaceScoped []unstructured.Unstructured
        deployment      []unstructured.Unstructured
        statefulset     []unstructured.Unstructured
        job             []unstructured.Unstructured
}

func NewInstaller(manifest *mf.Manifest, mfClient mf.Client, kubeClientSet kubernetes.Interface, logger *zap.SugaredLogger) *installer <span class="cov8" title="1">{
        installer := &amp;installer{
                manifest:        manifest,
                mfClient:        mfClient,
                kubeClientSet:   kubeClientSet,
                logger:          logger,
                crds:            []unstructured.Unstructured{},
                clusterScoped:   []unstructured.Unstructured{},
                namespaceScoped: []unstructured.Unstructured{},
                deployment:      []unstructured.Unstructured{},
                statefulset:     []unstructured.Unstructured{},
                job:             []unstructured.Unstructured{},
        }

        // we filter out resource as some resources are dependent on others
        // for eg. namespace should be created before configmap
        // non k8s core resources like openshift resources will be classified as
        // namespace scoped
        for _, res := range manifest.Resources() </span><span class="cov8" title="1">{
                if strings.ToLower(res.GetKind()) == "customresourcedefinition" </span><span class="cov0" title="0">{
                        installer.crds = append(installer.crds, res)
                        continue</span>
                } else<span class="cov8" title="1"> if res.GetKind() == "Deployment" </span><span class="cov8" title="1">{
                        installer.deployment = append(installer.deployment, res)
                        continue</span>
                } else<span class="cov8" title="1"> if res.GetKind() == "StatefulSet" </span><span class="cov8" title="1">{
                        installer.statefulset = append(installer.statefulset, res)
                        continue</span>
                } else<span class="cov8" title="1"> if res.GetKind() == "Job" </span><span class="cov8" title="1">{
                        installer.job = append(installer.job, res)
                        continue</span>
                }
                <span class="cov8" title="1">if isClusterScoped(res.GetKind()) &amp;&amp; strings.ToLower(res.GetKind()) != "clusterrolebinding" </span><span class="cov0" title="0">{
                        installer.clusterScoped = append(installer.clusterScoped, res)
                        continue</span>
                }
                <span class="cov8" title="1">installer.namespaceScoped = append(installer.namespaceScoped, res)</span>
        }
        <span class="cov8" title="1">return installer</span>
}

// https://github.com/manifestival/manifestival/blob/af1baacf01ec54390c3cbd46ee561d52b2b4ab14/transform.go#L107
func isClusterScoped(kind string) bool <span class="cov8" title="1">{
        switch strings.ToLower(kind) </span>{
        case "componentstatus",
                "namespace",
                "node",
                "persistentvolume",
                "mutatingwebhookconfiguration",
                "validatingwebhookconfiguration",
                "customresourcedefinition",
                "apiservice",
                "meshpolicy",
                "tokenreview",
                "selfsubjectaccessreview",
                "selfsubjectrulesreview",
                "subjectaccessreview",
                "certificatesigningrequest",
                "clusterrolebinding",
                "clusterrole",
                "priorityclass",
                "storageclass",
                "volumeattachment":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (i *installer) ensureResources(resources []unstructured.Unstructured) error <span class="cov8" title="1">{
        for _, r := range resources </span><span class="cov8" title="1">{
                ressourceLogger := i.logger.With(
                        "kind", r.GetKind(),
                        "namespace", r.GetNamespace(),
                        "name", r.GetName(),
                )
                expectedHash, err := hash.Compute(r.Object)
                if err != nil </span><span class="cov0" title="0">{
                        ressourceLogger.Error("failed to compute resource hash", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">ressourceLogger.Debug("fetching resource")

                res, err := i.mfClient.Get(&amp;r)
                if err != nil </span><span class="cov8" title="1">{
                        if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                                ressourceLogger.Debug("creating new resource")
                                // add hash on the resource of expected manifest and create
                                anno := r.GetAnnotations()
                                if anno == nil </span><span class="cov8" title="1">{
                                        anno = map[string]string{}
                                }</span>
                                <span class="cov8" title="1">anno[v1alpha1.LastAppliedHashKey] = expectedHash
                                r.SetAnnotations(anno)
                                err = i.mfClient.Create(&amp;r)
                                if err != nil </span><span class="cov0" title="0">{
                                        ressourceLogger.Error("failed to create resource", "error", err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">ressourceLogger.Debug("resource created successfully")
                                continue</span>
                        }
                        <span class="cov0" title="0">ressourceLogger.Error("failed to get resource", "error", err)
                        return err</span>
                }

                <span class="cov8" title="1">if res.GetDeletionTimestamp() != nil </span><span class="cov8" title="1">{
                        ressourceLogger.Debug("resource is being deleted, will reconcile again")
                        return v1alpha1.RECONCILE_AGAIN_ERR
                }</span>

                <span class="cov8" title="1">ressourceLogger.Debug("resource exists, checking for updates")

                // if resource exist then check if expected hash is different from the one
                // on the resource
                hashOnResource := res.GetAnnotations()[v1alpha1.LastAppliedHashKey]

                if expectedHash == hashOnResource </span><span class="cov0" title="0">{
                        ressourceLogger.Debug("resource is up-to-date, no changes needed")
                        continue</span>
                }

                <span class="cov8" title="1">ressourceLogger.Debug("resource needs update",
                        "currentHash", hashOnResource,
                        "expectedHash", expectedHash)

                anno := r.GetAnnotations()
                if anno == nil </span><span class="cov0" title="0">{
                        anno = map[string]string{}
                }</span>
                <span class="cov8" title="1">anno[v1alpha1.LastAppliedHashKey] = expectedHash
                r.SetAnnotations(anno)

                installManifests, err := mf.ManifestFrom(mf.Slice([]unstructured.Unstructured{r}), mf.UseClient(i.mfClient))
                if err != nil </span><span class="cov0" title="0">{
                        ressourceLogger.Error("failed to create manifest", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">if err := installManifests.Apply(); err != nil </span><span class="cov0" title="0">{
                        ressourceLogger.Error("failed to apply manifest", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">ressourceLogger.Debug("resource updated successfully")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *installer) EnsureCRDs() error <span class="cov0" title="0">{
        return i.ensureResources(i.crds)
}</span>

func (i *installer) EnsureClusterScopedResources() error <span class="cov0" title="0">{
        return i.ensureResources(i.clusterScoped)
}</span>

func (i *installer) EnsureNamespaceScopedResources() error <span class="cov8" title="1">{
        return i.ensureResources(i.namespaceScoped)
}</span>

func (i *installer) EnsureStatefulSetResources(ctx context.Context) error <span class="cov8" title="1">{
        for _, s := range i.statefulset </span><span class="cov8" title="1">{
                if err := i.ensureResource(ctx, &amp;s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := i.isStatefulSetAvailable(&amp;s); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *installer) EnsureDeploymentResources(ctx context.Context) error <span class="cov0" title="0">{
        for _, d := range i.deployment </span><span class="cov0" title="0">{
                if err := i.ensureResource(ctx, &amp;d); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (i *installer) EnsureJobResources() error <span class="cov0" title="0">{
        return i.ensureResources(i.job)
}</span>

// list of fields should be reconciled
func (i *installer) resourceReconcileFields(u *unstructured.Unstructured) []string <span class="cov8" title="1">{
        switch u.GetKind() </span>{
        case "Deployment", "StatefulSet":<span class="cov8" title="1">
                return []string{
                        annotationsPath,
                        labelsPath,
                        "spec",
                }</span>

        default:<span class="cov0" title="0">
                return []string{}</span>
        }
}

// this method is written as generic to all the resources
// currently tested with deployments and StatefulSet
// TODO: (jkandasa) needs to be tested with other resources too
func (i *installer) ensureResource(ctx context.Context, expected *unstructured.Unstructured) error <span class="cov8" title="1">{
        loggerWithContext := i.logger.With(
                "name", expected.GetName(),
                "namespace", expected.GetNamespace(),
                "kind", expected.GetKind(),
        )
        loggerWithContext.Debug("verifying a resource")

        // update specific things to deployments and statefulSets
        if expected.GetKind() == "Deployment" || expected.GetKind() == "StatefulSet" </span><span class="cov8" title="1">{

                // update proxy settings
                err := common.ApplyProxySettings(expected)
                if err != nil </span><span class="cov0" title="0">{
                        loggerWithContext.Errorw("failed to apply proxy settings", "error", err)
                        return err
                }</span>

                // if a deployment or statefulSets managed by HPA, ignore replicas from user input(TektonConfig CR)
                // and take replicas from HPA status(DesiredReplicas)

                // lists the available HPAs
                <span class="cov8" title="1">hpaList, err := i.kubeClientSet.AutoscalingV2().HorizontalPodAutoscalers(expected.GetNamespace()).List(ctx, metav1.ListOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        loggerWithContext.Errorw("failed to list HPAs", "error", err)
                        return err
                }</span>

                // check the expected resource configured with HPA
                <span class="cov8" title="1">var hpa *autoscalingv2.HorizontalPodAutoscaler
                for _, _hpa := range hpaList.Items </span><span class="cov8" title="1">{
                        target := _hpa.Spec.ScaleTargetRef
                        if target.Kind == expected.GetKind() &amp;&amp; target.Name == expected.GetName() </span><span class="cov8" title="1">{
                                hpa = _hpa.DeepCopy()
                                break</span>
                        }
                }

                // if a hpa found to this resource, update replicas value from the hpa
                <span class="cov8" title="1">if hpa != nil </span><span class="cov8" title="1">{
                        hpaLogger := loggerWithContext.With(
                                "hpaName", hpa.GetName(),
                                "hpaNamespace", hpa.GetNamespace(),
                        )
                        hpaLogger.Debug("HPA found for resource, verifying replicas")

                        hpaScalingDisabled := true
                        // verify HPA status from ScalingActive condition
                        for _, condition := range hpa.Status.Conditions </span><span class="cov8" title="1">{
                                if condition.Type == autoscalingv2.ScalingActive &amp;&amp; condition.Status != corev1.ConditionFalse </span><span class="cov8" title="1">{
                                        hpaScalingDisabled = false
                                        break</span>
                                }
                        }

                        // working description:
                        //---------------------
                        // variables description:
                        // - desiredReplicas - taken from hpa status.desiredReplicas
                        // - minReplicas - taken from hpa spec.minReplicas. this can be nil or zero. we set it as 1, if the value is nil or zero.
                        // - maxReplicas - taken from hpa spec.maxReplicas
                        // - manifestReplicas - taken from expected resource(manifest), can be a deployment or statefulSet the value is from spec.replicas
                        // The desiredReplicas calculated as follows,
                        // - if scaling is enabled compares minReplicas and desiredReplicas from hpa, take the higher one
                        // - if scaling is disabled, take manifestReplicas and compare with scaling range from hpa
                        // -- if the manifestReplicas value is lesser than the minReplicas, takes minReplicas as desiredReplicas
                        // -- if the manifestReplicas value is higher than the maxReplicas, takes the maxReplicas as desiredReplicas
                        // -- if the manifestReplicas value is in range. that is "minReplicas &gt;= manifestReplicas &lt;= maxReplicas", takes manifestReplicas as desiredReplicas

                        <span class="cov8" title="1">desiredReplicas := hpa.Status.DesiredReplicas
                        maxReplicas := hpa.Spec.MaxReplicas
                        minReplicas := hpa.Spec.MinReplicas
                        // minReplicas can be nil or zero. in that case, we keep it as 1
                        if minReplicas == nil || *minReplicas == 0 </span><span class="cov8" title="1">{
                                minReplicas = ptr.Int32(1)
                        }</span>

                        <span class="cov8" title="1">if hpaScalingDisabled </span><span class="cov8" title="1">{
                                hpaLogger.Info("HPA scaling disabled, adjusting replicas to scaling range")

                                manifestReplicas, manifestReplicasFound, err := unstructured.NestedInt64(expected.Object, "spec", "replicas")
                                if err != nil </span><span class="cov0" title="0">{
                                        hpaLogger.Errorw("failed to get manifest replicas", "error", err)
                                }</span> else<span class="cov8" title="1"> if !manifestReplicasFound </span><span class="cov8" title="1">{
                                        hpaLogger.Debug("manifest replicas not found, defaulting to 1")
                                        // set default value as 1
                                        manifestReplicas = 1
                                }</span>

                                // adjust the manifest replicas value to hpa's scaling range
                                <span class="cov8" title="1">if manifestReplicas &lt; int64(*minReplicas) </span><span class="cov8" title="1">{
                                        originalReplicas := manifestReplicas
                                        manifestReplicas = int64(*minReplicas)
                                        hpaLogger.Infow("adjusted replicas to minReplicas",
                                                "originalReplicas", originalReplicas,
                                                "newReplicas", manifestReplicas,
                                                "minReplicas", *minReplicas,
                                        )
                                }</span> else<span class="cov8" title="1"> if manifestReplicas &gt; int64(maxReplicas) </span><span class="cov8" title="1">{
                                        originalReplicas := manifestReplicas
                                        manifestReplicas = int64(maxReplicas)
                                        hpaLogger.Infow("adjusted replicas to maxReplicas",
                                                "originalReplicas", originalReplicas,
                                                "newReplicas", manifestReplicas,
                                                "maxReplicas", maxReplicas,
                                        )
                                }</span>

                                // updates the desiredReplicas
                                <span class="cov8" title="1">desiredReplicas = int32(manifestReplicas)</span>

                        } else<span class="cov8" title="1"> { // hpa scaling is enabled
                                hpaLogger.Debugw("HPA scaling enabled",
                                        "desiredReplicas", desiredReplicas,
                                        "minReplicas", *minReplicas,
                                        "maxReplicas", maxReplicas,
                                        "scaleTargetKind", hpa.Spec.ScaleTargetRef.Kind,
                                        "scaleTargetName", hpa.Spec.ScaleTargetRef.Name,
                                )

                                // if there is no metrics data available in the cluster the HPA desiredReplicas will be zero
                                // compare minReplicas and desiredReplicas and take the higher one
                                if desiredReplicas &lt; *minReplicas </span><span class="cov8" title="1">{
                                        hpaLogger.Debugw("HPA desiredReplicas less than minReplicas, adjusting desiredReplicas to minReplicas",
                                                "OriginalDesiredReplicas", desiredReplicas,
                                                "minReplicas", *minReplicas,
                                                "scaleTargetKind", hpa.Spec.ScaleTargetRef.Kind,
                                                "scaleTargetName", hpa.Spec.ScaleTargetRef.Name,
                                        )
                                        desiredReplicas = *minReplicas
                                }</span>
                        }

                        <span class="cov8" title="1">hpaLogger.Infow("calculated final desired replicas", "desiredReplicas", desiredReplicas, "hpaScalingEnabled", !hpaScalingDisabled)

                        // update the replicas value from HPA in expected object
                        // note: converting the replicas value to int64, "DeepCopyJSONValue" not accepts int32, it is available inside "SetNestedField"
                        err = unstructured.SetNestedField(expected.Object, int64(desiredReplicas), "spec", "replicas")
                        if err != nil </span><span class="cov0" title="0">{
                                hpaLogger.Errorw("failed to set replicas value", "error", err)
                                return err
                        }</span>

                }
        }

        // check if the resource already exists
        <span class="cov8" title="1">existing, err := i.mfClient.Get(expected)
        if err != nil </span><span class="cov8" title="1">{
                // If the resource doesn't exist, then create new
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        loggerWithContext.Debug("resource not found, creating")
                        err = i.mfClient.Create(expected)
                        if err != nil </span><span class="cov0" title="0">{
                                loggerWithContext.Errorw("failed to create resource", "error", err)
                                return err
                        }</span>
                        <span class="cov8" title="1">loggerWithContext.Debug("resource created successfully")</span>
                }
                <span class="cov8" title="1">loggerWithContext.Errorw("failed to get resource", "error", err)
                return err</span>
        }

        <span class="cov8" title="1">loggerWithContext.Debug("resource found in cluster, checking for changes")

        if existing.GetDeletionTimestamp() != nil </span><span class="cov8" title="1">{
                loggerWithContext.Debug("resource is being deleted, waiting for completion")
                return v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        // get list of reconcile fields
        <span class="cov8" title="1">reconcileFields := i.resourceReconcileFields(expected)

        // compute hash value for the expected deployment or statefulset
        expectedHashValue, err := i.computeResourceHash(expected, reconcileFields...)
        if err != nil </span><span class="cov0" title="0">{
                loggerWithContext.Errorw("failed to compute hash for expected resource", "error", err)
                return fmt.Errorf("failed to compute hash value for expected resource, name:%s, error: %v", expected.GetName(), err)
        }</span>

        // compute hash value for the existing resource
        // remove extra annotations and labels to keep the consistence hash
        <span class="cov8" title="1">existingCloned := existing.DeepCopy()
        existingCloned.SetAnnotations(i.removeExtraKeyInMap(existingCloned.GetAnnotations(), expected.GetAnnotations()))
        existingCloned.SetLabels(i.removeExtraKeyInMap(existingCloned.GetLabels(), expected.GetLabels()))
        // compute hash
        existingHashValue, err := i.computeResourceHash(existingCloned, reconcileFields...)
        if err != nil </span><span class="cov0" title="0">{
                loggerWithContext.Errorw("failed to compute hash for existing resource", "error", err)
                return fmt.Errorf("failed to compute hash value for existing resource, name:%s, namespace:%s, kind:%s error: %v",
                        existingCloned.GetName(), existingCloned.GetNamespace(), existingCloned.GetKind(), err,
                )
        }</span>

        // if change detected in hash value, update the resource with changes
        <span class="cov8" title="1">if existingHashValue != expectedHashValue </span><span class="cov8" title="1">{
                loggerWithContext.Debugw("change detected, updating resource",
                        "existingHash", existingHashValue,
                        "expectedHash", expectedHashValue,
                )

                err = i.copyResourceFields(expected, existing, reconcileFields...)
                if err != nil </span><span class="cov0" title="0">{
                        loggerWithContext.Errorw("failed to copy resource fields", "error", err)
                        return err
                }</span>

                <span class="cov8" title="1">err = i.mfClient.Update(existing)
                if err != nil </span><span class="cov0" title="0">{
                        loggerWithContext.Errorw("failed to update resource", "error", err)
                        return v1alpha1.RECONCILE_AGAIN_ERR
                }</span>

                <span class="cov8" title="1">loggerWithContext.Debug("resource updated successfully")
                return nil</span>
        }
        <span class="cov8" title="1">loggerWithContext.Debug("no changes detected, resource is up-to-date")
        return nil</span>
}

func (i *installer) removeExtraKeyInMap(src, dst map[string]string) map[string]string <span class="cov8" title="1">{
        newMap := map[string]string{}
        if len(src) == 0 </span><span class="cov8" title="1">{
                return newMap
        }</span>
        <span class="cov8" title="1">for dstKey, dstValue := range dst </span><span class="cov8" title="1">{
                for srcKey := range src </span><span class="cov8" title="1">{
                        if dstKey == srcKey </span><span class="cov8" title="1">{
                                newMap[dstKey] = dstValue
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return newMap</span>
}

func (i *installer) computeResourceHash(u *unstructured.Unstructured, reconcileFieldKeys ...string) (string, error) <span class="cov8" title="1">{
        // always keep the empty annotations and labels as empty, NOT nil
        if u.GetAnnotations() == nil </span><span class="cov8" title="1">{
                u.SetAnnotations(map[string]string{})
        }</span>
        <span class="cov8" title="1">if u.GetLabels() == nil </span><span class="cov8" title="1">{
                u.SetLabels(map[string]string{})
        }</span>

        // if there is no reconcile key specified, compute the hash to the entire object
        <span class="cov8" title="1">if len(reconcileFieldKeys) == 0 </span><span class="cov0" title="0">{
                return hash.Compute(u.Object)
        }</span>

        // holds the required fieldsMap
        <span class="cov8" title="1">fieldsMap := map[string]interface{}{}

        // collect all the required fields to compute hash value
        for _, fieldKey := range reconcileFieldKeys </span><span class="cov8" title="1">{
                // split the fields with comma
                nestedKeys := strings.Split(fieldKey, ".")
                fieldValue, _, err := unstructured.NestedFieldCopy(u.Object, nestedKeys...)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">fieldsMap[fieldKey] = fieldValue</span>
        }

        // compute hash to the collected fieldMaps
        <span class="cov8" title="1">return hash.Compute(fieldsMap)</span>
}

func (i *installer) mergeMaps(src, dst map[string]string) map[string]string <span class="cov8" title="1">{
        if len(dst) == 0 </span><span class="cov0" title="0">{
                return src
        }</span>
        <span class="cov8" title="1">for key, value := range src </span><span class="cov8" title="1">{
                dst[key] = value
        }</span>
        <span class="cov8" title="1">return dst</span>
}

func (i *installer) copyResourceFields(src, dst *unstructured.Unstructured, reconcileFieldKeys ...string) error <span class="cov8" title="1">{
        // if there is no reconcile key specified, compute the hash to the entire object
        if len(reconcileFieldKeys) == 0 </span><span class="cov0" title="0">{
                srcCloned := src.DeepCopy()
                // merge annotations
                srcCloned.SetAnnotations(i.mergeMaps(srcCloned.GetAnnotations(), dst.GetAnnotations()))
                // merge labels
                srcCloned.SetLabels(i.mergeMaps(srcCloned.GetLabels(), dst.GetLabels()))

                dst.Object = srcCloned.Object
                return nil
        }</span>

        <span class="cov8" title="1">for _, fieldKey := range reconcileFieldKeys </span><span class="cov8" title="1">{
                switch fieldKey </span>{
                case annotationsPath:<span class="cov8" title="1"> // merge annotations
                        dst.SetAnnotations(i.mergeMaps(src.GetAnnotations(), dst.GetAnnotations()))</span>

                case labelsPath:<span class="cov8" title="1"> // merge labels
                        dst.SetLabels(i.mergeMaps(src.GetLabels(), dst.GetLabels()))</span>

                default:<span class="cov8" title="1">
                        // split the fields with comma
                        nestedKeys := strings.Split(fieldKey, ".")
                        fieldValue, found, err := unstructured.NestedFieldCopy(src.Object, nestedKeys...)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                                err = unstructured.SetNestedField(dst.Object, fieldValue, nestedKeys...)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                unstructured.RemoveNestedField(dst.Object, nestedKeys...)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (i *installer) IsWebhookReady() error <span class="cov8" title="1">{
        for _, u := range i.deployment </span><span class="cov8" title="1">{
                if !strings.Contains(u.GetName(), "webhook") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">err := i.isDeploymentReady(&amp;u)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *installer) IsControllerReady() error <span class="cov8" title="1">{
        for _, u := range i.deployment </span><span class="cov8" title="1">{
                if !strings.Contains(u.GetName(), "controller") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">err := i.isDeploymentReady(&amp;u)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *installer) AllDeploymentsReady() error <span class="cov8" title="1">{
        for _, u := range i.deployment </span><span class="cov8" title="1">{
                if strings.Contains(u.GetName(), "controller") ||
                        strings.Contains(u.GetName(), "webhook") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">err := i.isDeploymentReady(&amp;u)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (i *installer) IsJobCompleted(ctx context.Context, labels map[string]string, installSetName string) error <span class="cov8" title="1">{
        for _, u := range i.manifest.Filter(mf.ByKind("Job")).Resources() </span><span class="cov8" title="1">{
                resource, err := i.mfClient.Get(&amp;u)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">job := &amp;batchv1.Job{}
                if err := scheme.Scheme.Convert(resource, job, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">logger := logging.FromContext(ctx)
                if !isJobCompleted(job) </span><span class="cov8" title="1">{
                        logger.Info("job not ready in installerset, name: %s, created-by: %s, in namespace: %s", installSetName, labels[v1alpha1.CreatedByKey], job.GetNamespace())
                        return fmt.Errorf("Job not successful")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (i *installer) isStatefulSetAvailable(sfs *unstructured.Unstructured) error <span class="cov8" title="1">{
        resource, err := i.mfClient.Get(sfs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">statefulSet := &amp;appsv1.StatefulSet{}
        err = runtime.DefaultUnstructuredConverter.FromUnstructured(resource.Object, statefulSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !isStatefulSetReady(statefulSet) </span><span class="cov8" title="1">{
                i.logger.Infof("statefulset %v not ready, returning will retry!", statefulSet.GetName())
                return fmt.Errorf("%s statefulset is not ready", statefulSet.GetName())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (i *installer) isDeploymentReady(d *unstructured.Unstructured) error <span class="cov8" title="1">{
        resource, err := i.mfClient.Get(d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">deployment := &amp;appsv1.Deployment{}
        err = runtime.DefaultUnstructuredConverter.FromUnstructured(resource.Object, deployment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if msg := isFailedToCreateState(deployment); msg != "" </span><span class="cov0" title="0">{
                i.logger.Infof("deployment %v is in failed state, deleting! reason: ", msg)
                err := i.mfClient.Delete(resource)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return v1alpha1.REQUEUE_EVENT_AFTER</span>
        }

        <span class="cov8" title="1">if !isDeploymentAvailable(deployment) </span><span class="cov8" title="1">{
                i.logger.Infof("deployment %v not ready, returning will retry!", deployment.GetName())
                return fmt.Errorf("%s deployment not ready", deployment.GetName())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func isFailedToCreateState(d *appsv1.Deployment) string <span class="cov8" title="1">{
        for _, c := range d.Status.Conditions </span><span class="cov8" title="1">{
                if string(c.Type) == string(appsv1.ReplicaSetReplicaFailure) &amp;&amp; c.Status == corev1.ConditionTrue &amp;&amp; c.Reason == "FailedCreate" </span><span class="cov0" title="0">{
                        return c.Message
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func isDeploymentAvailable(d *appsv1.Deployment) bool <span class="cov8" title="1">{
        for _, c := range d.Status.Conditions </span><span class="cov8" title="1">{
                if c.Type == appsv1.DeploymentAvailable &amp;&amp; c.Status == corev1.ConditionTrue </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isStatefulSetReady(sfs *appsv1.StatefulSet) bool <span class="cov8" title="1">{
        if sfs.Spec.Replicas != nil </span><span class="cov8" title="1">{
                if sfs.Status.ReadyReplicas == *sfs.Spec.Replicas </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isJobCompleted(d *batchv1.Job) bool <span class="cov8" title="1">{
        for _, c := range d.Status.Conditions </span><span class="cov8" title="1">{
                if c.Type == batchv1.JobComplete &amp;&amp; c.Status == corev1.ConditionTrue </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// DeleteResources Deletes all resources except CRDs, PVCs and Namespace as they
// are own by owner of TektonInstallerSet.
// They will be deleted when the component CR is deleted
func (i *installer) DeleteResources() error <span class="cov0" title="0">{
        // delete clusterScope resources first
        if err := i.delete(i.clusterScoped); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := i.delete(i.namespaceScoped); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := i.deleteWithPolicy(i.job, metav1.DeletePropagationForeground); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := i.delete(i.deployment); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (i *installer) delete(resources []unstructured.Unstructured) error <span class="cov0" title="0">{
        for _, r := range resources </span><span class="cov0" title="0">{
                if skipDeletion(r.GetKind()) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">resource, err := i.mfClient.Get(&amp;r)
                if err != nil </span><span class="cov0" title="0">{
                        // if error occurs log and move on, as we have owner reference set for resources, those
                        // will be removed eventually and manifestival breaks the pod during uninstallation,
                        // when CRD is deleted, CRs are removed but when we delete installer set, manifestival
                        // breaks during deleting those CRs
                        i.logger.Errorf("failed to get resource, skipping deletion: %v/%v: %v ", r.GetKind(), r.GetName(), err)
                        continue</span>
                }
                <span class="cov0" title="0">err = i.mfClient.Delete(resource)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func (i *installer) deleteWithPolicy(resources []unstructured.Unstructured, policy metav1.DeletionPropagation) error <span class="cov0" title="0">{
        for _, r := range resources </span><span class="cov0" title="0">{
                if skipDeletion(r.GetKind()) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">resource, err := i.mfClient.Get(&amp;r)
                if err != nil </span><span class="cov0" title="0">{
                        // if error occurs log and move on, as we have owner reference set for resources, those
                        // will be removed eventually and manifestival breaks the pod during uninstallation,
                        // when CRD is deleted, CRs are removed but when we delete installer set, manifestival
                        // breaks during deleting those CRs
                        i.logger.Errorf("failed to get resource, skipping deletion: %v/%v: %v ", r.GetKind(), r.GetName(), err)
                        continue</span>
                }

                <span class="cov0" title="0">err = i.mfClient.Delete(resource, mf.DeleteOption(mf.PropagationPolicy(policy)))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func skipDeletion(kind string) bool <span class="cov0" title="0">{
        if kind == "Namespace" ||
                kind == "PersistentVolumeClaim" ||
                kind == "CustomResourceDefinition" </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
)

func CurrentInstallerSetName(ctx context.Context, client clientset.Interface, labelSelector string) (string, error) <span class="cov8" title="1">{
        iSets, err := client.OperatorV1alpha1().TektonInstallerSets().List(ctx, v1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(iSets.Items) == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if len(iSets.Items) == 1 </span><span class="cov8" title="1">{
                iSetName := iSets.Items[0].GetName()
                return iSetName, nil
        }</span>

        // len(iSets.Items) &gt; 1
        // delete all installerSets as it cannot be decided which one is the desired one
        <span class="cov8" title="1">err = client.OperatorV1alpha1().TektonInstallerSets().DeleteCollection(ctx,
                v1.DeleteOptions{},
                v1.ListOptions{
                        LabelSelector: labelSelector,
                })
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return "", v1alpha1.RECONCILE_AGAIN_ERR</span>
}

// CleanUpObsoleteResources cleans up obsolete resources
// this is required because after TektonInstallerSet were introduced
// it was observed that during upgrade multiple installerSets were
// getting created
// now that we have label based query and we have new labels
// this cleanup is just to make sure we delete all older installerSets
// from the cluster
func CleanUpObsoleteResources(ctx context.Context, client clientset.Interface, createdBy string) error <span class="cov8" title="1">{

        labelSelector := labels.NewSelector()
        createdReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{createdBy})
        if createdReq != nil </span><span class="cov8" title="1">{
                labelSelector = labelSelector.Add(*createdReq)
        }</span>

        <span class="cov8" title="1">list, err := client.OperatorV1alpha1().TektonInstallerSets().List(ctx, v1.ListOptions{LabelSelector: labelSelector.String()})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(list.Items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, i := range list.Items </span><span class="cov8" title="1">{
                // check if installerSet has InstallerSetType label
                // if it doesn't exist then delete it
                if _, ok := i.Labels[v1alpha1.InstallerSetType]; !ok </span><span class="cov8" title="1">{
                        err := client.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, i.Name, v1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        tektonInstallerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektoninstallerset"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Reconciler implements controller.Reconciler for TektonInstallerSet resources.
type Reconciler struct {
        operatorClientSet clientset.Interface
        mfClient          mf.Client
        kubeClientSet     kubernetes.Interface
}

// Reconciler implements controller.Reconciler
var _ tektonInstallerreconciler.Interface = (*Reconciler)(nil)
var _ tektonInstallerreconciler.Finalizer = (*Reconciler)(nil)

// FinalizeKind removes all resources after deletion of a TektonInstallerSet.
func (r *Reconciler) FinalizeKind(ctx context.Context, installerSet *v1alpha1.TektonInstallerSet) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        deleteManifests, err := mf.ManifestFrom(installerSet.Spec.Manifests, mf.UseClient(r.mfClient))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error creating initial manifest: ", err)
                installerSet.Status.MarkNotReady(fmt.Sprintf("Internal Error: failed to create manifest: %s", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">installer := NewInstaller(&amp;deleteManifests, r.mfClient, r.kubeClientSet, logger)
        err = installer.DeleteResources()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete resources: ", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Returns ownerReference to add in resource while installing
func getReference(tis *v1alpha1.TektonInstallerSet) []v1.OwnerReference <span class="cov0" title="0">{
        return []v1.OwnerReference{*v1.NewControllerRef(tis, tis.GetGroupVersionKind())}
}</span>

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, installerSet *v1alpha1.TektonInstallerSet) pkgreconciler.Event <span class="cov0" title="0">{
        installerSet.Status.InitializeConditions()
        logger := logging.FromContext(ctx).With("installerSet", fmt.Sprintf("%s/%s", installerSet.Namespace, installerSet.Name))

        logger.Debugw("Starting TektonInstallerSet reconciliation",
                "resourceVersion", installerSet.ResourceVersion,
                "status", installerSet.Status.GetCondition(apis.ConditionReady))

        installManifests, err := mf.ManifestFrom(installerSet.Spec.Manifests, mf.UseClient(r.mfClient))
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Internal Error: failed to create manifest: %s", err.Error())
                logger.Errorw("Failed to create initial manifest", "error", err)
                installerSet.Status.MarkNotReady(msg)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Successfully created initial manifest")

        // Set owner of InstallerSet as owner of CRDs so that
        // deleting the installer will not delete the CRDs and Namespace
        // If installerSet has not set any owner then CRDs will
        // not have any owner
        installerSetOwner := installerSet.GetOwnerReferences()
        logger.Debug("Transforming manifest with ownership information")
        installManifests, err = installManifests.Transform(
                injectOwner(getReference(installerSet)),
                injectOwnerForCRDsAndNamespace(installerSetOwner),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to transform manifest with ownership information", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">installer := NewInstaller(&amp;installManifests, r.mfClient, r.kubeClientSet, logger)

        // Install CRDs
        logger.Debug("Installing CRDs")
        err = installer.EnsureCRDs()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("CRD installation failed", "error", err)
                installerSet.Status.MarkCRDsInstallationFailed(err.Error())
                return r.handleError(err, installerSet)
        }</span>

        // Update Status for CRD condition
        <span class="cov0" title="0">installerSet.Status.MarkCRDsInstalled()
        logger.Debug("CRDs installed successfully")

        // Install ClusterScoped Resources
        logger.Debug("Installing cluster-scoped resources")
        err = installer.EnsureClusterScopedResources()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Cluster-scoped resources installation failed", "error", err)
                installerSet.Status.MarkClustersScopedInstallationFailed(err.Error())
                return r.handleError(err, installerSet)
        }</span>

        // Update Status for ClustersScope Condition
        <span class="cov0" title="0">installerSet.Status.MarkClustersScopedResourcesInstalled()
        logger.Debug("Cluster-scoped resources installed successfully")

        // Install NamespaceScoped Resources
        logger.Debug("Installing namespace-scoped resources")
        err = installer.EnsureNamespaceScopedResources()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Namespace-scoped resources installation failed", "error", err)
                installerSet.Status.MarkNamespaceScopedInstallationFailed(err.Error())
                return r.handleError(err, installerSet)
        }</span>

        // Update Status for NamespaceScope Condition
        <span class="cov0" title="0">installerSet.Status.MarkNamespaceScopedResourcesInstalled()
        logger.Debug("Namespace-scoped resources installed successfully")

        // Install Job Resources
        logger.Debug("Installing job resources")
        err = installer.EnsureJobResources()
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Job resources installation failed", "error", err)
                installerSet.Status.MarkJobsInstallationFailed(err.Error())
                return r.handleError(err, installerSet)
        }</span>

        // Update Status for Job Resources
        <span class="cov0" title="0">installerSet.Status.MarkJobsInstalled()
        logger.Debug("Job resources installed successfully")

        // Install Deployment Resources
        logger.Debug("Installing deployment resources")
        err = installer.EnsureDeploymentResources(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Deployment resources installation failed", "error", err)
                installerSet.Status.MarkDeploymentsAvailableFailed(err.Error())
                return r.handleError(err, installerSet)
        }</span>

        // Update Status for Deployment Resources
        <span class="cov0" title="0">installerSet.Status.MarkDeploymentsAvailable()
        logger.Debug("Deployment resources installed successfully")

        // Install StatefulSet Resources
        logger.Debug("Installing statefulset resources")
        err = installer.EnsureStatefulSetResources(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("StatefulSet resources installation failed", "error", err)
                installerSet.Status.MarkStatefulSetNotReady(err.Error())
                return r.handleError(err, installerSet)
        }</span>

        // Update Status for StatefulSet Resources
        <span class="cov0" title="0">installerSet.Status.MarkStatefulSetReady()
        logger.Debug("StatefulSet resources installed successfully")

        // Check if webhook is ready
        logger.Debugw("Checking webhook readiness")
        err = installer.IsWebhookReady()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnw("Webhook not ready", "error", err)
                installerSet.Status.MarkWebhookNotReady(err.Error())
                return nil
        }</span>

        // Update Status for Webhook
        <span class="cov0" title="0">installerSet.Status.MarkWebhookReady()
        logger.Debug("Webhook is ready")

        // Check if controller is ready
        logger.Debug("Checking controller readiness")
        err = installer.IsControllerReady()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnw("Controller not ready", "error", err)
                installerSet.Status.MarkControllerNotReady(err.Error())
                return nil
        }</span>

        // Update Ready status of Controller
        <span class="cov0" title="0">installerSet.Status.MarkControllerReady()
        logger.Debug("Controller is ready")

        // job
        labels := installerSet.GetLabels()
        installSetname := installerSet.GetName()
        logger.Debug("Checking job completion status")
        err = installer.IsJobCompleted(ctx, labels, installSetname)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnw("Jobs not completed", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("All jobs completed successfully")

        // Check if any other deployment exists other than controller
        // and webhook and is ready
        logger.Debug("Checking all deployments readiness")
        err = installer.AllDeploymentsReady()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnw("Not all deployments are ready", "error", err)
                installerSet.Status.MarkAllDeploymentsNotReady(err.Error())
                return nil
        }</span>

        // Mark all deployments ready
        <span class="cov0" title="0">installerSet.Status.MarkAllDeploymentsReady()
        logger.Debug("All deployments are ready")

        logger.Debugw("TektonInstallerSet reconciliation completed successfully",
                "ready", installerSet.Status.GetCondition(apis.ConditionReady))

        return nil</span>
}

func (r *Reconciler) handleError(err error, installerSet *v1alpha1.TektonInstallerSet) error <span class="cov0" title="0">{
        if err == v1alpha1.RECONCILE_AGAIN_ERR </span><span class="cov0" title="0">{
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        mf "github.com/manifestival/manifestival"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

func injectOwner(owner []v1.OwnerReference) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                kind := u.GetKind()
                if kind == "CustomResourceDefinition" ||
                        kind == "ValidatingWebhookConfiguration" ||
                        kind == "MutatingWebhookConfiguration" ||
                        kind == "Namespace" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">u.SetOwnerReferences(owner)
                return nil</span>
        }
}

func injectOwnerForCRDsAndNamespace(owner []v1.OwnerReference) mf.Transformer <span class="cov8" title="1">{
        if len(owner) == 0 </span><span class="cov0" title="0">{
                return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{ return nil }</span>
        }
        <span class="cov8" title="1">return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                kind := u.GetKind()
                if kind != "CustomResourceDefinition" &amp;&amp;
                        kind != "Namespace" </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">u.SetOwnerReferences(owner)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file107" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpipeline

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineInformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        tektonPipelineReconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpipeline"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const versionConfigMap = "pipelines-info"

// NewController initializes the controller and is called by the generated code
// Registers event handlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }

                manifest, pipelineVer := ctrl.InitController(ctx, common.PayloadOptions{})

                metrics, err := NewRecorder()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to create pipeline metrics recorder %v", err)
                }</span>

                <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>
                <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()

                c := &amp;Reconciler{
                        kubeClientSet:      kubeclient.Get(ctx),
                        extension:          generator(ctx),
                        manifest:           manifest,
                        pipelineVersion:    pipelineVer,
                        installerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, pipelineVer, v1alpha1.KindTektonPipeline, metrics),
                }
                impl := tektonPipelineReconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for TektonPipeline")

                if _, err := tektonPipelineInformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonPipeline informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonPipeline{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file108" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpipeline

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        tektonpipelinereconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpipeline"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

var _ tektonpipelinereconciler.Finalizer = (*Reconciler)(nil)

// FinalizeKind removes all resources after deletion of a TektonPipeline.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonPipeline) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Delete CRDs before deleting rest of resources so that any instance
        // of CRDs which has finalizer set will get deleted before we remove
        // the controller;s deployment for it
        if err := r.manifest.Filter(mf.CRDs).Delete(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete CRDs for TektonPipeline")
                return err
        }</span>

        <span class="cov0" title="0">if err := r.installerSetClient.CleanupMainSet(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to cleanup main installerset: ", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources: ", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpipeline

import (
        "context"
        "fmt"
        "time"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        "knative.dev/pkg/metrics"
)

var (
        pReconcileCount = stats.Float64("pipeline_reconcile_count",
                "number of pipeline install",
                stats.UnitDimensionless)
)

// Recorder holds keys for Tekton metrics
type Recorder struct {
        initialized bool
        status      tag.Key
        version     tag.Key

        ReportingPeriod time.Duration
}

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder() (*Recorder, error) <span class="cov0" title="0">{
        r := &amp;Recorder{
                initialized: true,

                // Default to 30s intervals.
                ReportingPeriod: 30 * time.Second,
        }

        status, err := tag.NewKey("status")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.status = status

        version, err := tag.NewKey("version")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.version = version

        err = view.Register(
                &amp;view.View{
                        Description: pReconcileCount.Description(),
                        Measure:     pReconcileCount,
                        Aggregation: view.Count(),
                        TagKeys:     []tag.Key{r.status, r.version},
                },
        )

        if err != nil </span><span class="cov0" title="0">{
                r.initialized = false
                return r, err
        }</span>

        <span class="cov0" title="0">return r, nil</span>
}

// Count logs number of times a component (pipeline/trigger atm)
// has been installed or failed to install.
func (r *Recorder) Count(status, version string) error <span class="cov0" title="0">{
        if !r.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "ignoring the metrics recording for pipelinee failed to initialize the metrics recorder")
        }</span>

        <span class="cov0" title="0">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.status, status),
                tag.Insert(r.version, version),
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metrics.Record(ctx, pReconcileCount.M(1))
        return nil</span>
}

func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) <span class="cov0" title="0">{
        err := m.Count(status, version)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("%v: Failed to log the metrics : %v", resourceKind, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpipeline

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        tektonpipelinereconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpipeline"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        resourceKind = v1alpha1.KindTektonPipeline

        proxyLabel = "operator.tekton.dev/disable-proxy=true"
)

// Reconciler implements controller.Reconciler for TektonPipeline resources.
type Reconciler struct {
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // manifest has the source manifest of Tekton Pipeline for a
        // particular version
        manifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension common.Extension
        // kube client to interact with core k8s resources
        kubeClientSet kubernetes.Interface
        // version of pipelines which we are installing
        pipelineVersion string
}

// Check that our Reconciler implements controller.Reconciler
var _ tektonpipelinereconciler.Interface = (*Reconciler)(nil)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, tp *v1alpha1.TektonPipeline) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With(
                "name", tp.GetName(),
                "namespace", tp.GetNamespace(),
                "resourceVersion", tp.GetResourceVersion(),
        )
        logger.Debugw("Starting TektonPipeline reconciliation",
                "version", r.pipelineVersion,
                "status", tp.Status.GetCondition(apis.ConditionReady))

        tp.Status.InitializeConditions()
        tp.Status.SetVersion(r.pipelineVersion)

        if tp.GetName() != v1alpha1.PipelineResourceName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored: expected name '%s', got '%s'",
                        v1alpha1.PipelineResourceName, tp.GetName())
                logger.Errorw("Invalid resource name", "expectedName", v1alpha1.PipelineResourceName, "actualName", tp.GetName())
                tp.Status.MarkNotReady(msg)
                return nil
        }</span>

        // Pass the object through defaulting
        <span class="cov0" title="0">tp.SetDefaults(ctx)

        // reconcile target namespace
        logger.Debug("Reconciling target namespace")
        if err := common.ReconcileTargetNamespace(ctx, nil, nil, tp, r.kubeClientSet); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to reconcile target namespace", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to remove obsolete installer sets", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Obsolete installer sets removed")

        // Pipeline controller is deployed as statefulset, ensure deployment installerset is deleted
        if tp.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *tp.Spec.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                logger.Debugw("Cleaning up deployment installer set", "usingStatefulset", true)
                if err := r.installerSetClient.CleanupSubTypeDeployment(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to delete main deployment installer set", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debug("Deployment installer set deleted")</span>
        } else<span class="cov0" title="0"> {
                // Pipeline controller is deployed as deployment, ensure statefulset installerset is deleted
                if err := r.installerSetClient.CleanupSubTypeStatefulset(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Debugw("Cleaning up statefulset installer set", "usingDeployment", true)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debug("Statefulset installer set deleted")</span>
        }

        <span class="cov0" title="0">logger.Debug("Executing pre-reconciliation")
        if err := r.extension.PreReconcile(ctx, tp); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PreReconciliation failed: %s", err.Error())
                logger.Errorw("Pre-reconciliation failed", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Infow("Pre-reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">tp.Status.MarkPreReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PreReconcile Complete
        <span class="cov0" title="0">logger.Debug("Pre-reconciliation completed successfully")
        tp.Status.MarkPreReconcilerComplete()

        // When TektonPipeline component is deleted targetNamespace was getting deleted,
        // because in pipeline reconciler targetNamespace was updated by adding few labels which
        // in turn also updated the ownerRef of targetNamespace from TektonConfig to TektonPipeline.
        // Since namespace is created in TektonConfig reconciler hence deleting TektonPipeline
        // component should not delete the targetNamespace hence filtering out the namespace here
        logger.Debug("Filtering out namespace from manifest")
        manifest := r.manifest.Filter(mf.Not(mf.ByKind("Namespace")))

        // Ensure webhook deadlock prevention before applying the manifest
        logger.Debug("Preempting webhook deadlock")
        if err := common.PreemptDeadlock(ctx, &amp;manifest, r.kubeClientSet, v1alpha1.PipelineResourceName); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to preempt webhook deadlock", "error", err)
                return err
        }</span>

        //Apply manifest
        <span class="cov0" title="0">logger.Debug("Applying main manifest")
        if err := r.installerSetClient.MainSet(ctx, tp, &amp;manifest, filterAndTransform(r.extension)); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Main Reconcilation failed: %s", err.Error())
                logger.Errorw("Failed to apply main installer set", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Debugw("Main reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">tp.Status.MarkInstallerSetNotReady(msg)
                return nil</span>
        }
        <span class="cov0" title="0">logger.Debug("Main manifest applied successfully")

        logger.Debug("Executing post-reconciliation")
        if err := r.extension.PostReconcile(ctx, tp); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                logger.Errorw("Post-reconciliation failed", "error", err)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Debug("Post-reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">tp.Status.MarkPostReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PostReconcile Complete
        <span class="cov0" title="0">logger.Debug("Post-reconciliation completed successfully")
        tp.Status.MarkPostReconcilerComplete()

        logger.Debug("TektonPipeline reconciliation completed successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpipeline

import (
        "context"
        "sort"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        apimachineryRuntime "k8s.io/apimachinery/pkg/runtime"
)

const (
        // Pipelines ConfigMap
        FeatureFlag                                  = "feature-flags"
        ConfigDefaults                               = "config-defaults"
        ConfigMetrics                                = "config-observability"
        ResolverFeatureFlag                          = "resolvers-feature-flags"
        bundleResolverConfig                         = "bundleresolver-config"
        clusterResolverConfig                        = "cluster-resolver-config"
        hubResolverConfig                            = "hubresolver-config"
        gitResolverConfig                            = "git-resolver-config"
        leaderElectionPipelineConfig                 = "config-leader-election-controller"
        leaderElectionResolversConfig                = "config-leader-election-resolvers"
        pipelinesControllerDeployment                = "tekton-pipelines-controller"
        pipelinesControllerContainer                 = "tekton-pipelines-controller"
        pipelinesRemoteResolversControllerDeployment = "tekton-pipelines-remote-resolvers"
        pipelinesRemoteResolverControllerContainer   = "controller"
        resolverEnvKeyTektonHubApi                   = "tekton-hub-api"
        resolverEnvKeyArtifactHubApi                 = "artifact-hub-api"

        tektonPipelinesControllerName                      = "tekton-pipelines-controller"
        tektonPipelinesServiceName                         = "tekton-pipelines-controller"
        tektonRemoteResolversControllerName                = "tekton-pipelines-remote-resolvers"
        tektonRemoteResolversServiceName                   = "tekton-pipelines-remote-resolvers"
        tektonPipelinesControllerStatefulServiceName       = "STATEFUL_SERVICE_NAME"
        tektonPipelinesControllerStatefulControllerOrdinal = "STATEFUL_CONTROLLER_ORDINAL"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov8" title="1">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov8" title="1">{
                pipeline := comp.(*v1alpha1.TektonPipeline)

                // not in use, see: https://github.com/tektoncd/pipeline/pull/7789
                // this field is removed from pipeline component
                // still keeping types to maintain the API compatibility
                pipeline.Spec.Pipeline.EnableTektonOciBundles = nil

                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PipelinesImagePrefix))
                images := common.ImageRegistryDomainOverride(imagesRaw)
                instance := comp.(*v1alpha1.TektonPipeline)
                // adding extension's transformers first to run them before `extra` transformers
                trns := extension.Transformers(instance)
                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdPipeline),
                        common.AddConfigMapValues(FeatureFlag, pipeline.Spec.PipelineProperties),
                        common.AddConfigMapValues(ConfigDefaults, pipeline.Spec.OptionalPipelineProperties),
                        common.AddConfigMapValues(ConfigMetrics, pipeline.Spec.PipelineMetricsProperties),
                        common.AddConfigMapValues(ResolverFeatureFlag, pipeline.Spec.Resolvers),
                        common.DeploymentImages(images),
                        common.StatefulSetImages(images),
                        common.DeploymentEnvVarKubernetesMinVersion(),
                        common.InjectLabelOnNamespace(proxyLabel),
                        common.AddConfiguration(pipeline.Spec.Config),
                        common.CopyConfigMap(bundleResolverConfig, pipeline.Spec.BundlesResolverConfig),
                        common.CopyConfigMap(hubResolverConfig, pipeline.Spec.HubResolverConfig),
                        common.CopyConfigMap(clusterResolverConfig, pipeline.Spec.ClusterResolverConfig),
                        common.CopyConfigMap(gitResolverConfig, pipeline.Spec.GitResolverConfig),
                        common.AddConfigMapValues(leaderElectionPipelineConfig, pipeline.Spec.Performance.PerformanceLeaderElectionConfig),
                        common.AddConfigMapValues(leaderElectionResolversConfig, pipeline.Spec.Performance.PerformanceLeaderElectionConfig),
                        common.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(&amp;pipeline.Spec.Performance, leaderElectionPipelineConfig, pipelinesControllerDeployment, pipelinesControllerContainer),
                        common.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(&amp;pipeline.Spec.Performance, leaderElectionResolversConfig, pipelinesRemoteResolversControllerDeployment, pipelinesRemoteResolverControllerContainer),
                        updateResolverConfigEnvironmentsInDeployment(pipeline),
                }
                if pipeline.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *pipeline.Spec.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                        extra = append(extra, common.ConvertDeploymentToStatefulSet(tektonPipelinesControllerName, tektonPipelinesServiceName), common.AddStatefulEnvVars(
                                tektonPipelinesControllerName, tektonPipelinesServiceName, tektonPipelinesControllerStatefulServiceName, tektonPipelinesControllerStatefulControllerOrdinal))
                        extra = append(extra, common.ConvertDeploymentToStatefulSet(tektonRemoteResolversControllerName, tektonRemoteResolversServiceName), common.AddStatefulEnvVars(
                                tektonRemoteResolversControllerName, tektonRemoteResolversServiceName, tektonPipelinesControllerStatefulServiceName, tektonPipelinesControllerStatefulControllerOrdinal))
                }</span>

                <span class="cov8" title="1">trns = append(trns, extra...)

                if err := common.Transform(ctx, manifest, instance, trns...); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov8" title="1">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, pipeline.Spec.GetTargetNamespace(), pipeline.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov8" title="1">return manifest, nil</span>
        }
}

// updates resolver config environment variables
func updateResolverConfigEnvironmentsInDeployment(pipelineCR *v1alpha1.TektonPipeline) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" || u.GetName() != pipelinesRemoteResolversControllerDeployment </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // holds the variables needs to be added in the container environment section
                <span class="cov8" title="1">envVariables := map[string]string{}

                // collect all the required environment keys
                rawEnvKeys := []string{resolverEnvKeyTektonHubApi, resolverEnvKeyArtifactHubApi}
                // get values from resolver config
                for _, rawEnvKey := range rawEnvKeys </span><span class="cov8" title="1">{
                        if value, found := pipelineCR.Spec.ResolversConfig.HubResolverConfig[rawEnvKey]; found &amp;&amp; value != "" </span><span class="cov8" title="1">{
                                envVariables[rawEnvKey] = value
                        }</span>
                }

                // if there is no variables available to update, return from here
                <span class="cov8" title="1">if len(envVariables) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // update environment key to actual format
                // example: tekton-hub-api =&gt; TEKTON_HUB_API
                <span class="cov8" title="1">envKeys := []string{}
                for key, value := range envVariables </span><span class="cov8" title="1">{
                        newKey := strings.ToUpper(strings.ReplaceAll(key, "-", "_"))
                        delete(envVariables, key)
                        envVariables[newKey] = value
                        envKeys = append(envKeys, newKey)
                }</span>
                // sort the keys
                <span class="cov8" title="1">sort.Strings(envKeys)

                // convert unstructured object to deployment
                dep := &amp;appsv1.Deployment{}
                err := apimachineryRuntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // update environment keys into the target container
                <span class="cov8" title="1">for containerIndex, container := range dep.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if container.Name != pipelinesRemoteResolverControllerContainer </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, envKey := range envKeys </span><span class="cov8" title="1">{
                                envUpdated := false
                                envVar := corev1.EnvVar{
                                        Name:  envKey,
                                        Value: envVariables[envKey],
                                }
                                for envIndex, existingEnv := range container.Env </span><span class="cov8" title="1">{
                                        if existingEnv.Name == envKey </span><span class="cov8" title="1">{
                                                container.Env[envIndex] = envVar
                                                envUpdated = true
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if !envUpdated </span><span class="cov8" title="1">{
                                        container.Env = append(container.Env, envVar)
                                }</span>
                        }
                        <span class="cov8" title="1">dep.Spec.Template.Spec.Containers[containerIndex] = container</span>
                }

                // convert deployment to unstructured object
                <span class="cov8" title="1">obj, err := apimachineryRuntime.DefaultUnstructuredConverter.ToUnstructured(dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(obj)

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file112" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import (
        "context"

        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonPrunerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpruner"
        tektonPrunerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const versionConfigMap = v1alpha1.TektonPrunerResourceName + "-info"

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }

                manifest, prunerVer := ctrl.InitController(ctx, common.PayloadOptions{})
                operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()
                metrics, _ := NewRecorder()
                c := &amp;Reconciler{
                        operatorClientSet:  operatorclient.Get(ctx),
                        kubeClientSet:      kubeclient.Get(ctx),
                        pipelineInformer:   tektonPipelineinformer.Get(ctx),
                        installerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, prunerVer, v1alpha1.KindTektonPruner, metrics),
                        extension:          generator(ctx),
                        manifest:           manifest,
                        prunerVersion:      prunerVer,
                        operatorVersion:    operatorVer,
                }
                impl := tektonPrunerreconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for TektonPruner")

                if _, err := tektonPrunerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonPruner informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonPruner{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file113" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

var _ tektonpruner.Finalizer = (*Reconciler)(nil)

// FinalizeKind removes all resources after deletion of a TektonPruner CR.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonPruner) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        //Delete CRDs before deleting rest of resources so that any instance
        //of CRDs which has finalizer set will get deleted before we remove
        //the controller;s deployment for it
        if err := r.manifest.Filter(mf.CRDs).Delete(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to deleted CRDs for TektonPruner")
                return err
        }</span>

        <span class="cov0" title="0">if err := r.installerSetClient.CleanupMainSet(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to cleanup main installerset: ", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import "go.uber.org/zap"

type Recorder struct {
}

func NewRecorder() (*Recorder, error) <span class="cov0" title="0">{
        return &amp;Recorder{}, nil
}</span>

func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {<span class="cov0" title="0">
        // TODO
}</span>
</pre>
		
		<pre class="file" id="file115" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import (
        "context"
        "errors"
        "fmt"

        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        apierrors "k8s.io/apimachinery/pkg/api/errors"

        mf "github.com/manifestival/manifestival"
        "github.com/openshift-pipelines/tektoncd-pruner/pkg/config"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
)

const (
        PrunerConfigInstallerSet = "pruner-config"
        CreatedByValue           = "TektonConfig"
        PrunerConfigMapName      = config.PrunerConfigMapName
)

func (r *Reconciler) ensureInstallerSets(ctx context.Context, tp *v1alpha1.TektonPruner) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        if err := r.installerSetClient.MainSet(ctx, tp, &amp;r.manifest, filterAndTransform(r.extension)); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Main Reconcilation failed: %s", err.Error())
                logger.Error(msg)
                if errors.Is(err, v1alpha1.REQUEUE_EVENT_AFTER) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tp.Status.MarkInstallerSetNotReady(msg)</span>
        }

        <span class="cov0" title="0">if err := r.ensureConfigInstallerSet(ctx, tp); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Config InstallerSet Reconcilation failed: %s", err.Error())
                logger.Error(msg)
                if errors.Is(err, v1alpha1.REQUEUE_EVENT_AFTER) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tp.Status.MarkInstallerSetNotReady(msg)</span>

        }
        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) ensureConfigInstallerSet(ctx context.Context, tp *v1alpha1.TektonPruner) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        labelSelector := metav1.LabelSelector{
                MatchLabels: getLabels(),
        }
        configLabelSector, err := common.LabelSelector(labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid Pruner config label selector", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">existingConfigInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, configLabelSector)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get config installer set name", "error", err, "selector", configLabelSector)
                return err
        }</span>
        <span class="cov0" title="0">if existingConfigInstallerSet == "" </span><span class="cov0" title="0">{
                tp.Status.MarkInstallerSetNotAvailable(PrunerConfigInstallerSet + " InstallerSet not available")
                logger.Infow("Creating new InstallerSet", PrunerConfigInstallerSet, "targetNamespace", tp.Spec.TargetNamespace)

                _, err := r.createConfigInstallerSet(ctx, tp)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create Config InstallerSet", "error", err)
                        return err
                }</span>

        } else<span class="cov0" title="0"> {
                // If exists, then fetch the Tekton Pruner Config InstallerSet
                installedConfigTIS, _ := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, existingConfigInstallerSet, metav1.GetOptions{})

                configInstallerSetTargetNamespace := installedConfigTIS.Annotations[v1alpha1.TargetNamespaceKey]
                configInstallerSetReleaseVersion := installedConfigTIS.Labels[v1alpha1.ReleaseVersionKey]

                if configInstallerSetTargetNamespace != tp.Spec.TargetNamespace || configInstallerSetReleaseVersion != r.operatorVersion </span><span class="cov0" title="0">{
                        logger.Infow("Config InstallerSet needs update",
                                "name", existingConfigInstallerSet,
                                "currentNamespace", configInstallerSetTargetNamespace,
                                "expectedNamespace", tp.Spec.TargetNamespace,
                                "currentVersion", configInstallerSetReleaseVersion,
                                "expectedVersion", r.operatorVersion)

                        // Delete the existing Tekton Pruner InstallerSet
                        err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                Delete(ctx, existingConfigInstallerSet, metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to delete Config InstallerSet", "name", existingConfigInstallerSet, "error", err)
                                return err
                        }</span>

                        // Make sure the Tekton Pruner Config InstallerSet is deleted
                        <span class="cov0" title="0">_, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                Get(ctx, existingConfigInstallerSet, metav1.GetOptions{})
                        if err == nil </span><span class="cov0" title="0">{
                                tp.Status.MarkNotReady("Waiting for previous installer set to get deleted")
                                logger.Debugw("Config InstallerSet deletion pending", "name", existingConfigInstallerSet)
                                return v1alpha1.REQUEUE_EVENT_AFTER
                        }</span>
                        <span class="cov0" title="0">if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to confirm Config InstallerSet deletion", "name", existingConfigInstallerSet, "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">return nil</span>

                } else<span class="cov0" title="0"> {
                        // If target namespace and version are not changed then check if Pruner
                        // spec is changed by checking hash stored as annotation on
                        // Tekton Pruner InstallerSet with computing new hash of TektonPruner Spec

                        // Hash of TektonPruner Spec
                        expectedSpecHash, err := hash.Compute(tp.Spec)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to compute spec hash", "error", err)
                                return err
                        }</span>

                        // spec hash stored on installerSet
                        <span class="cov0" title="0">lastAppliedHash := installedConfigTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]
                        if lastAppliedHash != expectedSpecHash </span><span class="cov0" title="0">{
                                logger.Infow("Config spec changed, updating InstallerSet",
                                        "name", installedConfigTIS.Name,
                                        "oldHash", lastAppliedHash,
                                        "newHash", expectedSpecHash)
                                if err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                        Delete(ctx, installedConfigTIS.Name, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorw("Failed to delete outdated Config InstallerSet", "name", installedConfigTIS.Name, "error", err)
                                        return err
                                }</span>

                                // after updating installer set enqueue after a duration
                                // to allow changes to get deployed
                                <span class="cov0" title="0">logger.Infow("Config InstallerSet deleted to apply spec changes", "name", installedConfigTIS.Name)
                                return v1alpha1.REQUEUE_EVENT_AFTER</span>
                        }
                        <span class="cov0" title="0">logger.Debugw("Config InstallerSet up to date", "name", installedConfigTIS.Name)</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) createConfigInstallerSet(ctx context.Context, tektonPruner *v1alpha1.TektonPruner) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        manifest := r.manifest
        manifest = manifest.Filter(mf.ByKind("ConfigMap"), mf.ByName(config.PrunerConfigMapName))

        logger.Infow("Creating a new ConfigInstallerSet", "manifest", manifest.Resources())

        transformer := filterAndTransform(r.extension)
        if _, err := transformer(ctx, &amp;manifest, tektonPruner); err != nil </span><span class="cov0" title="0">{
                tektonPruner.Status.MarkNotReady("transformation failed: " + err.Error())
                return nil, err
        }</span>

        // generate installer set
        <span class="cov0" title="0">tis := r.makeInstallerSet(tektonPruner, manifest, PrunerConfigInstallerSet)

        // compute the hash of  spec and store as an annotation
        // in further reconciliation we compute hash of tektonPruner spec and check with
        // annotation, if they are same then we skip updating the object
        // otherwise we update the manifest
        specHash, err := hash.Compute(tektonPruner.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tis.Annotations[v1alpha1.LastAppliedHashKey] = specHash

        // create installer set
        createdIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, tis, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return createdIs, nil</span>
}

func (r *Reconciler) makeInstallerSet(tc *v1alpha1.TektonPruner, manifest mf.Manifest, installerSetType string) *v1alpha1.TektonInstallerSet <span class="cov0" title="0">{
        ownerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())
        labels := getLabels()

        labels[v1alpha1.ReleaseVersionKey] = r.operatorVersion

        return &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-", installerSetType),
                        Labels:       labels,
                        Annotations: map[string]string{
                                v1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }
}</span>

func getLabels() map[string]string <span class="cov0" title="0">{
        labels := map[string]string{
                v1alpha1.CreatedByKey:     CreatedByValue,
                v1alpha1.InstallerSetType: PrunerConfigInstallerSet,
        }
        return labels
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        pipelineinformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        tektonprunerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonpruner"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Reconciler implements controller.Reconciler for TektonPruner resources.
type Reconciler struct {
        // operator client to interact with operator resources
        operatorClientSet operatorclient.Interface
        // kube client to interact with core k8s resources
        kubeClientSet kubernetes.Interface
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // pipelineInformer to query for TektonPipeline
        pipelineInformer pipelineinformer.TektonPipelineInformer
        // manifest has the source manifest of Tekton Pruners for a
        // particular version
        manifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension common.Extension
        // version of pruner which we are installing
        prunerVersion   string
        operatorVersion string
}

// Check that our Reconciler implements controller.Reconciler
var _ tektonprunerreconciler.Interface = (*Reconciler)(nil)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, tp *v1alpha1.TektonPruner) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("name", tp.GetName())
        tp.Status.InitializeConditions()
        tp.Status.SetVersion(r.prunerVersion)

        if tp.GetName() != v1alpha1.TektonPrunerResourceName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.TektonPrunerResourceName,
                        tp.GetName(),
                )
                logger.Error(msg)
                tp.Status.MarkNotReady(msg)
                return nil
        }</span>

        // reconcile target namespace
        <span class="cov0" title="0">if err := common.ReconcileTargetNamespace(ctx, nil, nil, tp, r.kubeClientSet); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Make sure TektonPipeline is installed before proceeding with
        // TektonPruner
        <span class="cov0" title="0">if _, err := common.PipelineReady(r.pipelineInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        tp.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
                        // wait for pipeline status to change
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                // (tektonpipeline.operator.tekton.dev instance not available yet)
                <span class="cov0" title="0">tp.Status.MarkDependencyMissing("tekton-pipelines does not exist")
                return err</span>
        }
        <span class="cov0" title="0">tp.Status.MarkDependenciesInstalled()

        if err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to remove obsolete installer sets: %v", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.PreReconcile(ctx, tp); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PreReconciliation failed: %s", err.Error())
                logger.Error(msg)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tp.Status.MarkPreReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PreReconcile Complete
        <span class="cov0" title="0">tp.Status.MarkPreReconcilerComplete()

        //  Create/Update Required TektonInstallerSets
        if err := r.ensureInstallerSets(ctx, tp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.PostReconcile(ctx, tp); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                logger.Error(msg)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">tp.Status.MarkPostReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PostReconcile Complete
        <span class="cov0" title="0">tp.Status.MarkPostReconcilerComplete()
        return nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                prunerCR := comp.(*v1alpha1.TektonPruner)

                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PrunerImagePrefix))
                prunerImages := common.ImageRegistryDomainOverride(imagesRaw)
                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.TektonPrunerResourceName),
                        common.DeploymentImages(prunerImages),
                        common.AddDeploymentRestrictedPSA(),
                        common.AddConfigMapValues(PrunerConfigMapName, prunerCR.Spec.TektonPrunerConfig),
                }
                extra = append(extra, extension.Transformers(prunerCR)...)
                err := common.Transform(ctx, manifest, prunerCR, extra...)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov0" title="0">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, prunerCR.Spec.GetTargetNamespace(), prunerCR.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov0" title="0">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file118" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        "context"

        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineInformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        tektonResultInformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonresult"
        tektonResultReconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonresult"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const versionConfigMap = "tekton-results-info"

// NewController initializes the controller and is called by the generated code
// Registers event handlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }

                manifest, resultsVer := ctrl.InitController(ctx, common.PayloadOptions{})
                if resultsVer == common.ReleaseVersionUnknown </span><span class="cov0" title="0">{
                        resultsVer = "devel"
                }</span>

                <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">recorder, err := NewRecorder()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error starting Results metrics")
                }</span>

                <span class="cov0" title="0">metricsWrapper := NewRecorderWrapper(recorder)

                tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()

                c := &amp;Reconciler{
                        installerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, resultsVer, v1alpha1.KindTektonResult, metricsWrapper),
                        kubeClientSet:      kubeclient.Get(ctx),
                        operatorClientSet:  operatorclient.Get(ctx),
                        extension:          generator(ctx),
                        manifest:           &amp;manifest,
                        pipelineInformer:   tektonPipelineInformer.Get(ctx),
                        operatorVersion:    operatorVer,
                        resultsVersion:     resultsVer,
                        recorder:           recorder,
                }
                impl := tektonResultReconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for tekton-results")

                if _, err := tektonResultInformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonResult informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonResult{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file119" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" B]&gt;SIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
)

const (
        statefulSetDB     = "tekton-results-postgres"
        servicePostgresDB = "tekton-results-postgres-service"
)

func filterExternalDB(tr *v1alpha1.TektonResult, manifest *mf.Manifest) <span class="cov8" title="1">{
        if tr.Spec.IsExternalDB </span><span class="cov8" title="1">{
                *manifest = manifest.Filter(mf.Not(mf.All(mf.ByKind("StatefulSet"), mf.ByName(statefulSetDB))))
                *manifest = manifest.Filter(mf.Not(mf.All(mf.ByKind("ConfigMap"), mf.ByName(configPostgresDB))))
                *manifest = manifest.Filter(mf.Not(mf.All(mf.ByKind("Service"), mf.ByName(servicePostgresDB))))
        }</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (r *Reconciler) createInstallerSet(ctx context.Context, tr *v1alpha1.TektonResult, manifest mf.Manifest) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{

        if err := r.transform(ctx, &amp;manifest, tr); err != nil </span><span class="cov0" title="0">{
                tr.Status.MarkNotReady("transformation failed: " + err.Error())
                return nil, err
        }</span>

        // compute the hash of tektonresult spec and store as an annotation
        // in further reconciliation we compute hash of td spec and check with
        // annotation, if they are same then we skip updating the object
        // otherwise we update the manifest
        <span class="cov0" title="0">specHash, err := hash.Compute(tr.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // create installer set
        <span class="cov0" title="0">tis := r.makeInstallerSet(tr, manifest, specHash)
        createdIs, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, tis, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return createdIs, nil</span>
}

func (r *Reconciler) makeInstallerSet(tr *v1alpha1.TektonResult, manifest mf.Manifest, trSpecHash string) *v1alpha1.TektonInstallerSet <span class="cov0" title="0">{
        ownerRef := *metav1.NewControllerRef(tr, tr.GetGroupVersionKind())
        // Determine the subtype based on statefulset mode.
        mode := "deployment"
        if tr.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *tr.Spec.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                mode = "statefulset"
        }</span>

        <span class="cov0" title="0">return &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-", v1alpha1.ResultResourceName),
                        Labels: map[string]string{
                                v1alpha1.CreatedByKey:            createdByValue,
                                v1alpha1.InstallerSetType:        v1alpha1.ResultResourceName,
                                v1alpha1.ReleaseVersionKey:       r.operatorVersion,
                                v1alpha1.InstallerSetInstallType: mode,
                        },
                        Annotations: map[string]string{
                                v1alpha1.TargetNamespaceKey: tr.Spec.TargetNamespace,
                                v1alpha1.LastAppliedHashKey: trSpecHash,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        "context"
        "fmt"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        "knative.dev/pkg/metrics"
)

var (
        rReconcileCount = stats.Float64("results_reconciled",
                "results reconciled with their log type",
                stats.UnitDimensionless)
        rReconcilerCountView *view.View

        errUninitializedRecorder = fmt.Errorf("ignoring the metrics recording for result failed to initialize the metrics recorder")
)

// Recorder holds keys for Tekton metrics
type Recorder struct {
        initialized bool
        version     tag.Key
        logType     tag.Key
}

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder() (*Recorder, error) <span class="cov8" title="1">{
        r := &amp;Recorder{
                initialized: true,
        }

        version, err := tag.NewKey("version")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r.version = version

        logType, err := tag.NewKey("log_type")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r.logType = logType

        rReconcilerCountView = &amp;view.View{
                Description: rReconcileCount.Description(),
                Measure:     rReconcileCount,
                Aggregation: view.LastValue(),
                TagKeys:     []tag.Key{r.version, r.logType},
        }

        err = view.Register(rReconcilerCountView)

        if err != nil </span><span class="cov0" title="0">{
                r.initialized = false
                return r, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// Record the Results reconciled with their log type
func (r *Recorder) Count(version, logType string) error <span class="cov8" title="1">{
        if !r.initialized </span><span class="cov8" title="1">{
                return errUninitializedRecorder
        }</span>

        <span class="cov8" title="1">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.version, version),
                tag.Insert(r.logType, logType),
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">metrics.Record(ctx, rReconcileCount.M(float64(1)))
        return nil</span>
}

func (m *Recorder) LogMetrics(version string, spec v1alpha1.TektonResultSpec, logger *zap.SugaredLogger) <span class="cov0" title="0">{
        err := m.Count(version, spec.Result.ResultsAPIProperties.LogsType)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("%v: Failed to log the metrics : %v", v1alpha1.KindTektonResult, err)
        }</span>
}

// RecorderWrapper wraps the existing Recorder to implement this interface.
type RecorderWrapper struct {
        recorder *Recorder
}

// NewRecorderWrapper creates a new RecorderWrapper instance.
func NewRecorderWrapper(recorder *Recorder) *RecorderWrapper <span class="cov0" title="0">{
        return &amp;RecorderWrapper{recorder: recorder}
}</span>

// LogMetrics implements the Metrics interface by converting the provided logType string
// into a TektonResultSpec before calling the underlying Recorder's LogMetrics method.
func (rw *RecorderWrapper) LogMetrics(logType string, version string, logger *zap.SugaredLogger) <span class="cov0" title="0">{
        spec := v1alpha1.TektonResultSpec{
                Result: v1alpha1.Result{
                        ResultsAPIProperties: v1alpha1.ResultsAPIProperties{
                                LogsType: logType,
                        },
                },
        }
        rw.recorder.LogMetrics(version, spec, logger)
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        "context"
        "crypto/ecdsa"
        "crypto/elliptic"
        "crypto/rand"
        "crypto/x509"
        "crypto/x509/pkix"
        "encoding/base64"
        "encoding/pem"
        "errors"
        "fmt"
        "math/big"
        "time"

        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        pipelineInformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        tektonresultconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonresult"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        DefaultDbSecretName          = "tekton-results-postgres"
        TlsSecretName                = "tekton-results-tls"
        CertificateBlockType         = "CERTIFICATE"
        PostgresUser                 = "result"
        ECPrivateKeyBlockType        = "EC PRIVATE KEY"
        tektonResultStatefulSetLabel = "statefulset"
        tektonResultDeploymentLabel  = "deployment"
)

// Reconciler implements controller.Reconciler for TektonResult resources.
type Reconciler struct {
        // kubeClientSet allows us to talk to the k8s for core APIs
        kubeClientSet kubernetes.Interface
        // operatorClientSet allows us to configure operator objects
        operatorClientSet clientset.Interface
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // manifest is empty, but with a valid client and logger. all
        // manifests are immutable, and any created during reconcile are
        // expected to be appended to this one, obviating the passing of
        // client &amp; logger
        manifest *mf.Manifest
        // Platform-specific behavior to affect the transform
        extension common.Extension

        pipelineInformer pipelineInformer.TektonPipelineInformer

        operatorVersion string
        resultsVersion  string
        recorder        *Recorder
}

// Check that our Reconciler implements controller.Reconciler
var _ tektonresultconciler.Interface = (*Reconciler)(nil)
var _ tektonresultconciler.Finalizer = (*Reconciler)(nil)

var (
        ls = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     createdByValue,
                        v1alpha1.InstallerSetType: v1alpha1.ResultResourceName,
                },
        }
)

const createdByValue = "TektonResult"

// FinalizeKind removes all resources after deletion of a TektonResult.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonResult) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        labelSelector, err := common.LabelSelector(ls)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{
                        LabelSelector: labelSelector,
                }); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to delete installer set created by TektonResult", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, tr *v1alpha1.TektonResult) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("tektonresult", tr.Name)
        defer r.recorder.LogMetrics(r.resultsVersion, tr.Spec, logger)

        tr.Status.InitializeConditions()
        tr.Status.ObservedGeneration = tr.Generation

        logger.Infow("Starting TektonResults reconciliation",
                "version", r.resultsVersion,
                "generation", tr.Generation,
                "status", tr.Status.GetCondition(apis.ConditionReady))

        manifest := *r.manifest

        if tr.GetName() != v1alpha1.ResultResourceName </span><span class="cov0" title="0">{
                logger.Errorw("Invalid resource name",
                        "expectedName", v1alpha1.ResultResourceName,
                        "actualName", tr.GetName())
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.ResultResourceName, tr.GetName())
                tr.Status.MarkNotReady(msg)
                return nil
        }</span>

        // find the valid tekton-pipeline installation
        <span class="cov0" title="0">tp, err := common.PipelineReady(r.pipelineInformer)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        logger.Infow("Waiting for tekton-pipelines installation to complete")
                        tr.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
                        // wait for pipeline status to change
                        return fmt.Errorf(common.PipelineNotReady)
                }</span>
                // tektonpipeline.operator.tekton.dev instance not available yet
                <span class="cov0" title="0">logger.Errorw("Pipeline dependency not found", "error", err)
                tr.Status.MarkDependencyMissing("tekton-pipelines does not exist")
                return err</span>
        }

        <span class="cov0" title="0">if tp.GetSpec().GetTargetNamespace() != tr.GetSpec().GetTargetNamespace() </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("tekton-pipelines is missing in %s namespace", tr.GetSpec().GetTargetNamespace())
                logger.Errorw("Namespace mismatch for pipeline dependency",
                        "resultNamespace", tr.GetSpec().GetTargetNamespace(),
                        "pipelineNamespace", tp.GetSpec().GetTargetNamespace())
                tr.Status.MarkDependencyMissing(errMsg)
                return errors.New(errMsg)
        }</span>

        // If the external database is disabled, create a default database and a TLS secret.
        // Otherwise, verify if the default database secret is already created, and ensure the TLS secret is also created.
        <span class="cov0" title="0">if !tr.Spec.IsExternalDB &amp;&amp; tr.Spec.DBSecretName == "" </span><span class="cov0" title="0">{
                logger.Debugw("Creating database secret for internal database")
                if err := r.createDBSecret(ctx, tr); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create database secret", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debugw("Creating TLS secret for internal database")
                if err := r.createTLSSecret(ctx, tr); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create TLS secret", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Successfully created database and TLS secrets")</span>
        } else<span class="cov0" title="0"> {
                customDbSecretName := DefaultDbSecretName
                if tr.Spec.DBSecretName != "" </span><span class="cov0" title="0">{
                        customDbSecretName = tr.Spec.DBSecretName
                }</span>
                <span class="cov0" title="0">logger.Debugw("Validating external database secrets")
                if err := r.validateSecretsAreCreated(ctx, tr, customDbSecretName); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to validate database secrets", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debugw("Creating TLS secret for external database")
                if err := r.createTLSSecret(ctx, tr); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create TLS secret", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Info("Successfully validated database secrets and created TLS secret")</span>
        }

        <span class="cov0" title="0">tr.Status.MarkDependenciesInstalled()
        logger.Info("All dependencies installed successfully")

        //Result watcher is deployed as statefulset, ensure deployment installerset is deleted
        if tr.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *tr.Spec.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                if err := r.installerSetClient.CleanupWithLabelInstallTypeDeployment(ctx, v1alpha1.ResultResourceName); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to delete main deployment installer set: %v", err)
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                // Result watcher is deployed as deployment, ensure statefulset installerset is deleted
                if err := r.installerSetClient.CleanupWithLabelInstallTypeStatefulset(ctx, v1alpha1.ResultResourceName); err != nil </span><span class="cov0" title="0">{
                        logger.Error("failed to delete main statefulset installer set: %v", err)
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := r.extension.PreReconcile(ctx, tr); err != nil </span><span class="cov0" title="0">{
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Info("PreReconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">msg := fmt.Sprintf("PreReconciliation failed: %s", err.Error())
                logger.Errorw("PreReconciliation failed", "error", err)
                tr.Status.MarkPreReconcilerFailed(msg)
                return nil</span>
        }

        <span class="cov0" title="0">tr.Status.MarkPreReconcilerComplete()
        logger.Info("PreReconciliation completed successfully")

        // Check if an tektoninstallerset already exists, if not then create
        labelSelector, err := common.LabelSelector(ls)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to create label selector", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">logger.Debugw("Checking for existing installer set")
        existingInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get current installer set name", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">if existingInstallerSet == "" </span><span class="cov0" title="0">{
                logger.Info("No existing installer set found, creating new one")
                createdIs, err := r.createInstallerSet(ctx, tr, manifest)

                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create installer set", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Successfully created installer set", "name", createdIs.Name)
                r.updateTektonResultsStatus(ctx, tr, createdIs)
                return v1alpha1.REQUEUE_EVENT_AFTER</span>
        }
        // If exists, then fetch the TektonInstallerSet
        <span class="cov0" title="0">logger.Debugw("Fetching existing installer set", "name", existingInstallerSet)
        installedTIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                Get(ctx, existingInstallerSet, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Infow("Existing installer set not found, creating new one", "missingSet", existingInstallerSet)
                        createdIs, err := r.createInstallerSet(ctx, tr, manifest)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to create installer set", "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Infow("Successfully created installer set", "name", createdIs.Name)
                        r.updateTektonResultsStatus(ctx, tr, createdIs)
                        return v1alpha1.REQUEUE_EVENT_AFTER</span>
                }
                <span class="cov0" title="0">logger.Errorw("Failed to get existing installer set", "name", existingInstallerSet, "error", err)
                return err</span>
        }

        <span class="cov0" title="0">installerSetTargetNamespace := installedTIS.Annotations[v1alpha1.TargetNamespaceKey]
        installerSetReleaseVersion := installedTIS.Labels[v1alpha1.ReleaseVersionKey]

        // Check if TargetNamespace of existing TektonInstallerSet is same as expected
        // Check if Release Version in TektonInstallerSet is same as expected
        // If any of the thing above is not same then delete the existing TektonInstallerSet
        // and create a new with expected properties
        if installerSetTargetNamespace != tr.Spec.TargetNamespace || installerSetReleaseVersion != r.operatorVersion </span><span class="cov0" title="0">{
                logger.Infow("Configuration changed, deleting existing installer set",
                        "existingNamespace", installerSetTargetNamespace,
                        "newNamespace", tr.Spec.TargetNamespace,
                        "existingVersion", installerSetReleaseVersion,
                        "newVersion", r.operatorVersion)
                // Delete the existing TektonInstallerSet
                err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Delete(ctx, existingInstallerSet, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to delete installer set", "name", existingInstallerSet, "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Successfully deleted installer set", "name", existingInstallerSet)

                // Make sure the TektonInstallerSet is deleted
                _, err = r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                        Get(ctx, existingInstallerSet, metav1.GetOptions{})
                if err == nil </span><span class="cov0" title="0">{
                        logger.Infow("Waiting for previous installer set to be deleted", "name", existingInstallerSet)
                        tr.Status.MarkNotReady("Waiting for previous installer set to get deleted")
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to verify installer set deletion", "name", existingInstallerSet, "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infow("Confirmed installer set deletion", "name", existingInstallerSet)
                return nil</span>

        } else<span class="cov0" title="0"> {
                // If target namespace and version are not changed then check if spec
                // of TektonResult is changed by checking hash stored as annotation on
                // TektonInstallerSet with computing new hash of TektonResult Spec
                logger.Debug("Checking for spec changes in TektonResult")
                // Hash of TektonResult Spec
                expectedSpecHash, err := hash.Compute(tr.Spec)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to compute spec hash", "error", err)
                        return err
                }</span>

                // spec hash stored on installerSet
                <span class="cov0" title="0">lastAppliedHash := installedTIS.GetAnnotations()[v1alpha1.LastAppliedHashKey]

                if lastAppliedHash != expectedSpecHash </span><span class="cov0" title="0">{
                        logger.Infow("TektonResult spec changed, updating installer set",
                                "previousHash", lastAppliedHash,
                                "newHash", expectedSpecHash)

                        if err := r.transform(ctx, &amp;manifest, tr); err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Manifest transformation failed", "error", err)
                                return err
                        }</span>

                        // Update the spec hash
                        <span class="cov0" title="0">current := installedTIS.GetAnnotations()
                        current[v1alpha1.LastAppliedHashKey] = expectedSpecHash
                        installedTIS.SetAnnotations(current)

                        // Update the manifests
                        installedTIS.Spec.Manifests = manifest.Resources()
                        updatedIS, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().
                                Update(ctx, installedTIS, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to update installer set", "name", installedTIS.Name, "error", err)
                                return err
                        }</span>
                        <span class="cov0" title="0">logger.Infow("Successfully updated installer set with new spec",
                                "name", updatedIS.Name,
                                "newHash", expectedSpecHash)
                        // after updating installer set enqueue after a duration
                        // to allow changes to get deployed
                        return v1alpha1.REQUEUE_EVENT_AFTER</span>
                } else<span class="cov0" title="0"> {
                        logger.Debugw("No changes detected in TektonResult spec", "hash", expectedSpecHash)
                }</span>
        }

        <span class="cov0" title="0">r.updateTektonResultsStatus(ctx, tr, installedTIS)

        // Mark InstallerSet Available
        tr.Status.MarkInstallerSetAvailable()
        logger.Infow("Marked installer set as available", "name", installedTIS.Name)

        ready := installedTIS.Status.GetCondition(apis.ConditionReady)
        if ready == nil </span><span class="cov0" title="0">{
                logger.Infow("Installer set not yet reporting status", "name", installedTIS.Name)
                tr.Status.MarkInstallerSetNotReady("Waiting for installation")
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>

        <span class="cov0" title="0">if ready.Status == corev1.ConditionUnknown </span><span class="cov0" title="0">{
                logger.Infow("Installer set status is unknown, waiting", "name", installedTIS.Name)
                tr.Status.MarkInstallerSetNotReady("Waiting for installation")
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span> else<span class="cov0" title="0"> if ready.Status == corev1.ConditionFalse </span><span class="cov0" title="0">{
                logger.Warnw("Installer set not ready", "name", installedTIS.Name, "message", ready.Message)
                tr.Status.MarkInstallerSetNotReady(ready.Message)
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span>

        // MarkInstallerSetReady
        <span class="cov0" title="0">tr.Status.MarkInstallerSetReady()
        logger.Infow("Installer set is ready", "name", installedTIS.Name)

        if err := r.extension.PostReconcile(ctx, tr); err != nil </span><span class="cov0" title="0">{
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Infow("PostReconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                logger.Errorw("PostReconciliation failed", "error", err)
                tr.Status.MarkPostReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PostReconcile Complete
        <span class="cov0" title="0">logger.Infow("PostReconciliation completed successfully")
        tr.Status.MarkPostReconcilerComplete()
        r.updateTektonResultsStatus(ctx, tr, installedTIS)

        logger.Infow("TektonResults reconciliation completed successfully",
                "ready", tr.Status.GetCondition(apis.ConditionReady).IsTrue(),
                "generation", tr.Status.ObservedGeneration)

        return nil</span>
}

func (r *Reconciler) updateTektonResultsStatus(ctx context.Context, tr *v1alpha1.TektonResult, createdIs *v1alpha1.TektonInstallerSet) <span class="cov0" title="0">{
        // update the tr with TektonInstallerSet
        tr.Status.SetTektonInstallerSet(createdIs.Name)
        tr.Status.SetVersion(r.resultsVersion)
}</span>

// TektonResults expects secrets to be created before installing
func (r *Reconciler) validateSecretsAreCreated(ctx context.Context, tr *v1alpha1.TektonResult, secretName string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        _, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Get(ctx, secretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Error(err)
                        tr.Status.MarkDependencyMissing(fmt.Sprintf("%s secret is missing", secretName))
                        return err
                }</span>
                <span class="cov0" title="0">logger.Error(err)
                return err</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Generate the DB secret
func (r *Reconciler) generateDBSecret(name string, namespace string, tr *v1alpha1.TektonResult) (*corev1.Secret, error) <span class="cov0" title="0">{
        s := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            name,
                        Namespace:       namespace,
                        OwnerReferences: []metav1.OwnerReference{getOwnerRef(tr)},
                },
                Type:       corev1.SecretTypeOpaque,
                StringData: map[string]string{},
        }
        password, err := generateRandomBaseString(20)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.StringData["POSTGRES_PASSWORD"] = password
        s.StringData["POSTGRES_USER"] = PostgresUser
        return s, nil</span>
}

// Create Result default database secret
func (r *Reconciler) createDBSecret(ctx context.Context, tr *v1alpha1.TektonResult) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Get the DB secret, if not found then create the DB secret
        _, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Get(ctx, DefaultDbSecretName, metav1.GetOptions{})
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                logger.Errorf("failed to find default TektonResult database secret %s in namespace %s: %v", DefaultDbSecretName, tr.Spec.TargetNamespace, err)
                return err
        }</span>
        <span class="cov0" title="0">newDBSecret, err := r.generateDBSecret(DefaultDbSecretName, tr.Spec.TargetNamespace, tr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to generate default TektonResult database secret %s: %s", DefaultDbSecretName, err)
                return err
        }</span>
        <span class="cov0" title="0">_, err = r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Create(ctx, newDBSecret, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to create default TektonResult database secret %s in namespace %s: %v", DefaultDbSecretName, tr.Spec.TargetNamespace, err)
                tr.Status.MarkDependencyMissing(fmt.Sprintf("Default db %s creation is failing", DefaultDbSecretName))
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Create default TLS certificates for the database
func (r *Reconciler) createTLSSecret(ctx context.Context, tr *v1alpha1.TektonResult) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        if v1alpha1.IsOpenShiftPlatform() </span><span class="cov0" title="0">{
                logger.Info("Skipping default TLS secret creation: running on OpenShift platform")
                return nil
        }</span>

        <span class="cov0" title="0">_, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Get(ctx, TlsSecretName, metav1.GetOptions{})
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if !apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                logger.Errorf("failed to find default TektonResult TLS secret %s in namespace %s: %v", TlsSecretName, tr.Spec.TargetNamespace, err)
                return err
        }</span>
        <span class="cov0" title="0">certPEM, keyPEM, err := generateTLSCertificate(tr.Spec.TargetNamespace)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to generate default TektonResult TLS certificate: %v", err)
                return err
        }</span>
        // Create Kubernetes TLS secret
        <span class="cov0" title="0">err = r.createKubernetesTLSSecret(ctx, tr.Spec.TargetNamespace, TlsSecretName, certPEM, keyPEM, tr)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to create TLS secret %s in namespace %s: %v", TlsSecretName, tr.Spec.TargetNamespace, err)

        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Get an owner reference of Tekton Result
func getOwnerRef(tr *v1alpha1.TektonResult) metav1.OwnerReference <span class="cov0" title="0">{
        return *metav1.NewControllerRef(tr, tr.GroupVersionKind())
}</span>

func generateRandomBaseString(size int) (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, size)

        // Generate random bytes
        _, err := rand.Read(bytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // Encode the random bytes into a Base64 string
        <span class="cov0" title="0">base64String := base64.StdEncoding.EncodeToString(bytes)

        return base64String, nil</span>
}

// generateTLSCertificate generates a self-signed TLS certificate and private key.
func generateTLSCertificate(targetNS string) (certPEM, keyPEM []byte, err error) <span class="cov0" title="0">{

        // Define subject and DNS names
        dnsName := fmt.Sprintf("tekton-results-api-service.%s.svc.cluster.local", targetNS)

        priv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">notBefore := time.Now()
        notAfter := notBefore.Add(365 * 24 * time.Hour)

        serialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">template := x509.Certificate{
                SerialNumber: serialNumber,
                Issuer:       pkix.Name{},
                Subject: pkix.Name{
                        CommonName: dnsName,
                },
                DNSNames:              []string{dnsName},
                NotBefore:             notBefore,
                NotAfter:              notAfter,
                KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
                ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
                BasicConstraintsValid: true,
        }

        certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;priv.PublicKey, priv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">certPEM = pem.EncodeToMemory(&amp;pem.Block{Type: CertificateBlockType, Bytes: certDER})

        privBytes, err := x509.MarshalECPrivateKey(priv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">keyPEM = pem.EncodeToMemory(&amp;pem.Block{Type: ECPrivateKeyBlockType, Bytes: privBytes})

        return certPEM, keyPEM, nil</span>
}

// createKubernetesSecret creates a Kubernetes TLS secret with the given cert and key.
func (r *Reconciler) createKubernetesTLSSecret(ctx context.Context, namespace, secretName string, certPEM, keyPEM []byte, tr *v1alpha1.TektonResult) error <span class="cov0" title="0">{

        // Define the secret
        logger := logging.FromContext(ctx)
        secret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      secretName,
                        Namespace: namespace,
                },
                Type: corev1.SecretTypeTLS,
                Data: map[string][]byte{
                        corev1.TLSCertKey:       certPEM,
                        corev1.TLSPrivateKeyKey: keyPEM,
                },
        }

        _, err := r.kubeClientSet.CoreV1().Secrets(tr.Spec.TargetNamespace).Create(ctx, secret, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to create TLS secret %s in namespace %s: %v", secretName, namespace, err)
                tr.Status.MarkDependencyMissing(fmt.Sprintf("Default TLS Secret %s creation is failing", secretName))
                return err
        }</span>

        <span class="cov0" title="0">logger.Infof("Secret '%s' created successfully in namespace '%s'\n", secretName, namespace)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" B]&gt;SIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        "context"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        appsv1 "k8s.io/api/apps/v1"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        k8sruntime "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/ptr"
)

const (
        // Results ConfigMap
        configAPI                         = "tekton-results-api-config"
        deploymentAPI                     = "tekton-results-api"
        configINFO                        = "tekton-results-info"
        configMetrics                     = "tekton-results-config-observability"
        configPostgresDB                  = "tekton-results-postgres"
        pvcLoggingVolume                  = "tekton-logs"
        apiContainerName                  = "api"
        retentionPolicyAgentContainerName = "retention-policy-agent"
        watcherContainerName              = "watcher"
        googleAPPCredsEnvName             = "GOOGLE_APPLICATION_CREDENTIALS"
        googleCredsVolName                = "google-creds"
        googleCredsPath                   = "/creds/google"

        loggingProxyPath              = "LOGGING_PLUGIN_PROXY_PATH"
        loggingAPIURL                 = "LOGGING_PLUGIN_API_URL"
        loggingTokenPath              = "LOGGING_PLUGIN_TOKEN_PATH"
        loggingNamespaceKey           = "LOGGING_PLUGIN_NAMESPACE_KEY"
        loggingStaticLabels           = "LOGGING_PLUGIN_STATIC_LABELS"
        loggingForwarderDelayDuration = "LOGGING_PLUGIN_FORWARDER_DELAY_DURATION"
        logsAPIKey                    = "LOGS_API"
        logsTypeKey                   = "LOGS_TYPE"

        resultAPIDeployment                          = "tekton-results-api"
        resultWatcherDeployment                      = "tekton-results-watcher"
        resultWatcherContainer                       = "watcher"
        tektonResultWatcherName                      = "tekton-results-watcher"
        tektonResultWatcherServiceName               = "tekton-results-watcher"
        tektonResultWatcherStatefulServiceName       = "STATEFUL_SERVICE_NAME"
        tektonResultWatcherStatefulControllerOrdinal = "STATEFUL_CONTROLLER_ORDINAL"
        tektonResultleaderElectionConfig             = "tekton-results-config-leader-election"
)

var (
        resultDeployementNames = []string{resultAPIDeployment, resultWatcherDeployment}
        // allowed property secret keys
        allowedPropertySecretKeys = []string{
                "S3_BUCKET_NAME",
                "S3_ENDPOINT",
                "S3_HOSTNAME_IMMUTABLE",
                "S3_REGION",
                "S3_ACCESS_KEY_ID",
                "S3_SECRET_ACCESS_KEY",
                "S3_MULTI_PART_SIZE",
        }
        DB_USER     = "DB_USER"
        DB_PASSWORD = "DB_PASSWORD"
        // maps container env key with db secret key
        ContainerEnvKeys = map[string]string{
                DB_USER:     "POSTGRES_USER",
                DB_PASSWORD: "POSTGRES_PASSWORD",
        }
)

// transform mutates the passed manifest to one with common, component
// and platform transformations applied
func (r *Reconciler) transform(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        instance := comp.(*v1alpha1.TektonResult)
        resultImgs := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ResultsImagePrefix))

        targetNs := comp.GetSpec().GetTargetNamespace()
        filterExternalDB(instance, manifest)
        extra := []mf.Transformer{
                common.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdResults),
                common.ApplyProxySettings,
                common.ReplaceNamespaceInDeploymentArgs([]string{resultWatcherDeployment}, targetNs),
                common.ReplaceNamespaceInDeploymentEnv(resultDeployementNames, targetNs),
                updateApiConfig(instance.Spec),
                updateApiEnv(instance.Spec),
                enablePVCLogging(instance.Spec.ResultsAPIProperties),
                updateEnvWithSecretName(instance.Spec.ResultsAPIProperties),
                updateEnvWithDBSecretName(instance.Spec.ResultsAPIProperties),
                populateGoogleCreds(instance.Spec.ResultsAPIProperties),
                common.AddDeploymentRestrictedPSA(),
                common.AddConfiguration(instance.Spec.Config),
                common.AddStatefulSetRestrictedPSA(),
                common.DeploymentImages(resultImgs),
                common.DeploymentEnvVarKubernetesMinVersion(),
                common.StatefulSetImages(resultImgs),
                common.AddConfigMapValues(tektonResultleaderElectionConfig, instance.Spec.Performance.PerformanceLeaderElectionConfig),
                common.UpdatePerformanceFlagsInDeploymentAndLeaderConfigMap(&amp;instance.Spec.Performance, tektonResultleaderElectionConfig, resultWatcherDeployment, resultWatcherContainer),
        }

        if instance.Spec.Performance.StatefulsetOrdinals != nil &amp;&amp; *instance.Spec.Performance.StatefulsetOrdinals </span><span class="cov0" title="0">{
                extra = append(extra,
                        common.ConvertDeploymentToStatefulSet(tektonResultWatcherName, tektonResultWatcherServiceName),
                        common.AddStatefulEnvVars(tektonResultWatcherName, tektonResultWatcherServiceName, tektonResultWatcherStatefulServiceName, tektonResultWatcherStatefulControllerOrdinal),
                )
        }</span>

        <span class="cov0" title="0">extra = append(extra, r.extension.Transformers(instance)...)
        err := common.Transform(ctx, manifest, instance, extra...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // additional options transformer
        // always execute as last transformer, so that the values in options will be final update values on the manifests
        <span class="cov0" title="0">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, instance.Spec.GetTargetNamespace(), instance.Spec.Options); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func enablePVCLogging(p v1alpha1.ResultsAPIProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if p.LogsAPI == nil || !*p.LogsAPI || p.LoggingPVCName == "" || p.LogsPath == "" || u.GetKind() != "Deployment" || u.GetName() != deploymentAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">updatePVC := true
                for i := 0; i &lt; len(d.Spec.Template.Spec.Containers[0].VolumeMounts); i++ </span><span class="cov8" title="1">{
                        if d.Spec.Template.Spec.Containers[0].VolumeMounts[i].Name == pvcLoggingVolume </span><span class="cov0" title="0">{
                                d.Spec.Template.Spec.Containers[0].VolumeMounts[i] = corev1.VolumeMount{
                                        Name:      pvcLoggingVolume,
                                        MountPath: p.LogsPath,
                                }
                                updatePVC = false
                        }</span>
                }
                <span class="cov8" title="1">if updatePVC </span><span class="cov8" title="1">{
                        d.Spec.Template.Spec.Containers[0].VolumeMounts = append(
                                d.Spec.Template.Spec.Containers[0].VolumeMounts,
                                corev1.VolumeMount{Name: pvcLoggingVolume,
                                        MountPath: p.LogsPath,
                                })
                }</span>

                <span class="cov8" title="1">updatePVC = true
                vol := corev1.Volume{
                        Name: pvcLoggingVolume,
                        VolumeSource: corev1.VolumeSource{
                                PersistentVolumeClaim: &amp;corev1.PersistentVolumeClaimVolumeSource{
                                        ClaimName: p.LoggingPVCName,
                                },
                        },
                }
                for i := 0; i &lt; len(d.Spec.Template.Spec.Volumes); i++ </span><span class="cov8" title="1">{
                        if d.Spec.Template.Spec.Volumes[i].Name == pvcLoggingVolume </span><span class="cov0" title="0">{
                                d.Spec.Template.Spec.Volumes[i] = vol
                                updatePVC = false
                        }</span>
                }
                <span class="cov8" title="1">if updatePVC </span><span class="cov8" title="1">{
                        d.Spec.Template.Spec.Volumes = append(d.Spec.Template.Spec.Volumes, vol)
                }</span>

                <span class="cov8" title="1">unstrObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

func updateApiConfig(s v1alpha1.TektonResultSpec) mf.Transformer <span class="cov8" title="1">{
        p := s.ResultsAPIProperties

        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{

                kind := strings.ToLower(u.GetKind())
                if kind != "configmap" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">if u.GetName() != configAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">cm := &amp;corev1.ConfigMap{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if cm.Data == nil </span><span class="cov0" title="0">{
                        cm.Data = map[string]string{}
                }</span>

                <span class="cov8" title="1">values := reflect.ValueOf(p)
                types := values.Type()
                prop := make(map[string]string)

                applyLokiStackConfig(prop, s.LokiStackProperties)

                if !s.IsExternalDB </span><span class="cov8" title="1">{
                        prop["DB_HOST"] = "tekton-results-postgres-service." + s.TargetNamespace + ".svc.cluster.local"
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; values.NumField(); i++ </span><span class="cov8" title="1">{
                        key := strings.Split(types.Field(i).Tag.Get("json"), ",")[0]
                        if key == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">ukey := strings.ToUpper(key)

                        if values.Field(i).Kind() == reflect.Bool </span><span class="cov8" title="1">{
                                prop[ukey] = strconv.FormatBool(values.Field(i).Bool())
                                continue</span>
                        }

                        <span class="cov8" title="1">if values.Field(i).Kind() == reflect.Int64 </span><span class="cov0" title="0">{
                                prop[ukey] = strconv.FormatInt(values.Field(i).Int(), 10)
                                continue</span>
                        }

                        <span class="cov8" title="1">if values.Field(i).Kind() == reflect.Uint64 </span><span class="cov0" title="0">{
                                prop[ukey] = strconv.FormatUint(values.Field(i).Uint(), 10)
                                continue</span>
                        }

                        <span class="cov8" title="1">if values.Field(i).Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                innerElem := values.Field(i).Elem()

                                if !innerElem.IsValid() </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">switch innerElem.Kind() </span>{
                                case reflect.Bool:<span class="cov8" title="1">
                                        prop[ukey] = strconv.FormatBool(innerElem.Bool())
                                        continue</span>

                                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                                        prop[ukey] = strconv.FormatInt(innerElem.Int(), 10)
                                        continue</span>

                                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                                        prop[ukey] = strconv.FormatUint(innerElem.Uint(), 10)
                                        continue</span>
                                }
                        }

                        <span class="cov8" title="1">if value := values.Field(i).String(); value != "" </span><span class="cov8" title="1">{
                                prop[ukey] = value
                        }</span>
                }

                <span class="cov8" title="1">config := cm.Data["config"]
                cl := strings.Split(config, "\n")
                for i := range cl </span><span class="cov8" title="1">{
                        key := strings.Split(cl[i], "=")
                        val, ok := prop[key[0]]
                        if ok </span><span class="cov8" title="1">{
                                cl[i] = fmt.Sprintf("%s=%s", key[0], val)
                        }</span>
                }

                <span class="cov8" title="1">config = strings.Join(cl, "\n")

                cm.Data["config"] = config
                unstrObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

// update the api container envs with result api properties
// as result api server configuration depends on the envs
func updateApiEnv(s v1alpha1.TektonResultSpec) mf.Transformer <span class="cov8" title="1">{
        p := s.ResultsAPIProperties
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{

                if u.GetKind() != "Deployment" || u.GetName() != deploymentAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">values := reflect.ValueOf(p)
                types := reflect.TypeOf(p)
                prop := make(map[string]string)

                applyLokiStackConfig(prop, s.LokiStackProperties)

                if !s.IsExternalDB </span><span class="cov8" title="1">{
                        prop["DB_HOST"] = "tekton-results-postgres-service." + s.TargetNamespace + ".svc.cluster.local"
                }</span>

                <span class="cov8" title="1">dep := &amp;appsv1.Deployment{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; values.NumField(); i++ </span><span class="cov8" title="1">{
                        key := strings.Split(types.Field(i).Tag.Get("json"), ",")[0]
                        if key == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">ukey := strings.ToUpper(key)

                        if values.Field(i).Kind() == reflect.Bool </span><span class="cov8" title="1">{
                                prop[ukey] = strconv.FormatBool(values.Field(i).Bool())
                                continue</span>
                        }

                        <span class="cov8" title="1">if values.Field(i).Kind() == reflect.Int64 </span><span class="cov0" title="0">{
                                prop[ukey] = strconv.FormatInt(values.Field(i).Int(), 10)
                                continue</span>
                        }

                        <span class="cov8" title="1">if values.Field(i).Kind() == reflect.Uint64 </span><span class="cov0" title="0">{
                                prop[ukey] = strconv.FormatUint(values.Field(i).Uint(), 10)
                                continue</span>
                        }

                        <span class="cov8" title="1">if values.Field(i).Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                                innerElem := values.Field(i).Elem()

                                if !innerElem.IsValid() </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">switch innerElem.Kind() </span>{
                                case reflect.Bool:<span class="cov8" title="1">
                                        prop[ukey] = strconv.FormatBool(innerElem.Bool())
                                        continue</span>

                                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                                        prop[ukey] = strconv.FormatInt(innerElem.Int(), 10)
                                        continue</span>

                                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                                        prop[ukey] = strconv.FormatUint(innerElem.Uint(), 10)
                                        continue</span>
                                }
                        }

                        <span class="cov8" title="1">if value := values.Field(i).String(); value != "" </span><span class="cov8" title="1">{
                                prop[ukey] = value
                        }</span>
                }

                // finds api container and update the matched env and adds other result properties as env
                <span class="cov8" title="1">for containerIndex, container := range dep.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if container.Name != apiContainerName </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">existingContainerEnv := container.Env
                        if existingContainerEnv == nil </span><span class="cov0" title="0">{
                                existingContainerEnv = make([]corev1.EnvVar, 0)
                        }</span>

                        <span class="cov8" title="1">replaceEnv(existingContainerEnv, prop)
                        for k, v := range prop </span><span class="cov8" title="1">{
                                newEnv := corev1.EnvVar{
                                        Name:  k,
                                        Value: v,
                                }
                                existingContainerEnv = append(existingContainerEnv, newEnv)
                        }</span>
                        <span class="cov8" title="1">dep.Spec.Template.Spec.Containers[containerIndex].Env = existingContainerEnv
                        break</span>
                }

                <span class="cov8" title="1">unstrObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

func applyLokiStackConfig(prop map[string]string, lokiProp v1alpha1.LokiStackProperties) <span class="cov8" title="1">{
        if lokiProp.LokiStackName == "" || lokiProp.LokiStackNamespace == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">lokiURL := "https://" + lokiProp.LokiStackName + "-gateway-http" + "." + lokiProp.LokiStackNamespace + ".svc.cluster.local:8080"
        if prop == nil </span><span class="cov0" title="0">{
                prop = map[string]string{}
        }</span>

        <span class="cov8" title="1">prop[logsAPIKey] = "true"
        prop[logsTypeKey] = "loki"
        prop[loggingProxyPath] = "/api/logs/v1/application"
        prop[loggingAPIURL] = lokiURL
        prop[loggingTokenPath] = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        prop[loggingNamespaceKey] = "kubernetes_namespace_name"
        prop[loggingStaticLabels] = "log_type=application"
        prop[loggingForwarderDelayDuration] = "10"</span>
}

func populateGoogleCreds(props v1alpha1.ResultsAPIProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if props.LogsType != "GCS" || props.GCSCredsSecretName == "" ||
                        props.GCSCredsSecretKey == "" || props.LogsAPI == nil ||
                        !*props.LogsAPI || u.GetKind() != "Deployment" ||
                        u.GetName() != deploymentAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // find the matching container and add env and secret name object
                <span class="cov8" title="1">for i, container := range d.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if container.Name != apiContainerName </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">add := true
                        vol := corev1.Volume{
                                Name: googleCredsVolName,
                                VolumeSource: corev1.VolumeSource{
                                        Secret: &amp;corev1.SecretVolumeSource{
                                                SecretName: props.GCSCredsSecretName,
                                                Items: []corev1.KeyToPath{{
                                                        Key:  props.GCSCredsSecretKey,
                                                        Path: props.GCSCredsSecretKey,
                                                }},
                                        },
                                },
                        }
                        for k := 0; k &lt; len(d.Spec.Template.Spec.Volumes); k++ </span><span class="cov8" title="1">{
                                if d.Spec.Template.Spec.Volumes[k].Name == googleCredsVolName </span><span class="cov8" title="1">{
                                        d.Spec.Template.Spec.Volumes[k] = vol
                                        add = false
                                }</span>
                        }
                        <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                                d.Spec.Template.Spec.Volumes = append(d.Spec.Template.Spec.Volumes, vol)
                        }</span>

                        <span class="cov8" title="1">volMount := corev1.VolumeMount{
                                Name:      googleCredsVolName,
                                MountPath: googleCredsPath,
                        }

                        add = true
                        for k := 0; k &lt; len(d.Spec.Template.Spec.Containers[i].VolumeMounts); k++ </span><span class="cov8" title="1">{
                                if d.Spec.Template.Spec.Containers[i].VolumeMounts[k].Name == googleCredsVolName </span><span class="cov8" title="1">{
                                        d.Spec.Template.Spec.Containers[i].VolumeMounts[k] = volMount
                                        add = false
                                }</span>
                        }
                        <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                                d.Spec.Template.Spec.Containers[i].VolumeMounts = append(
                                        d.Spec.Template.Spec.Containers[i].VolumeMounts, volMount)
                        }</span>

                        <span class="cov8" title="1">path := googleCredsPath + "/" + props.GCSCredsSecretKey
                        newEnv := corev1.EnvVar{
                                Name:  googleAPPCredsEnvName,
                                Value: path,
                        }
                        add = true
                        for k, env := range d.Spec.Template.Spec.Containers[i].Env </span><span class="cov8" title="1">{
                                if env.Name == googleAPPCredsEnvName </span><span class="cov8" title="1">{
                                        d.Spec.Template.Spec.Containers[i].Env[k] = newEnv
                                        add = false
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                                d.Spec.Template.Spec.Containers[i].Env = append(
                                        d.Spec.Template.Spec.Containers[i].Env, newEnv)
                        }</span>

                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">uObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(uObj)
                return nil</span>
        }
}

// updates env keys with the secret name into "tekton-results-api" deployment in "api" container
func updateEnvWithSecretName(props v1alpha1.ResultsAPIProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if props.SecretName == "" || u.GetKind() != "Deployment" || u.GetName() != deploymentAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">dep := &amp;appsv1.Deployment{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // find the matching container and add env and secret name object
                <span class="cov8" title="1">for containerIndex, container := range dep.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if container.Name != apiContainerName </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // get existing env from the container
                        <span class="cov8" title="1">existingEnv := container.Env
                        if existingEnv == nil </span><span class="cov0" title="0">{
                                existingEnv = make([]corev1.EnvVar, 0)
                        }</span>

                        // update only allowed properties
                        <span class="cov8" title="1">for _, propertyKey := range allowedPropertySecretKeys </span><span class="cov8" title="1">{
                                newEnv := corev1.EnvVar{
                                        Name: propertyKey,
                                        ValueFrom: &amp;corev1.EnvVarSource{
                                                SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                        LocalObjectReference: corev1.LocalObjectReference{
                                                                Name: props.SecretName,
                                                        },
                                                        Key:      propertyKey,
                                                        Optional: ptr.Bool(true),
                                                },
                                        },
                                }
                                // if existing entry found, replace that
                                appendNewEnv := true
                                for existingIndex, _env := range existingEnv </span><span class="cov8" title="1">{
                                        if _env.Name == propertyKey </span><span class="cov8" title="1">{
                                                existingEnv[existingIndex] = newEnv
                                                appendNewEnv = false
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if appendNewEnv </span><span class="cov8" title="1">{
                                        existingEnv = append(existingEnv, newEnv)
                                }</span>
                        }

                        // update the changes into the actual container
                        <span class="cov8" title="1">dep.Spec.Template.Spec.Containers[containerIndex].Env = existingEnv
                        break</span>
                }

                <span class="cov8" title="1">uObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(uObj)
                return nil</span>
        }

}

func replaceEnv(envs []corev1.EnvVar, prop map[string]string) <span class="cov8" title="1">{
        for i, env := range envs </span><span class="cov8" title="1">{
                _, ok := prop[env.Name]
                if ok </span><span class="cov8" title="1">{
                        envs[i].Name = prop[env.Name]
                        delete(prop, env.Name)
                }</span>
        }
}

// update api and retention-policy-agent env secret reference with db secret key and name
func updateEnvWithDBSecretName(props v1alpha1.ResultsAPIProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if props.DBSecretName == "" || u.GetKind() != "Deployment" || u.GetName() == resultWatcherDeployment </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">dep := &amp;appsv1.Deployment{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // find the matching container and add env and secret name object
                <span class="cov8" title="1">for containerIndex, container := range dep.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{

                        // get existing env from the container
                        existingEnv := container.Env
                        if existingEnv == nil </span><span class="cov0" title="0">{
                                existingEnv = make([]corev1.EnvVar, 0)
                        }</span>

                        // update the value of container keys with provided db secret key
                        <span class="cov8" title="1">if props.DBSecretUserKey != "" </span><span class="cov8" title="1">{
                                ContainerEnvKeys[DB_USER] = props.DBSecretUserKey
                        }</span>
                        <span class="cov8" title="1">if props.DBSecretPasswordKey != "" </span><span class="cov8" title="1">{
                                ContainerEnvKeys[DB_PASSWORD] = props.DBSecretPasswordKey
                        }</span>
                        <span class="cov8" title="1">for envKey, secretKey := range ContainerEnvKeys </span><span class="cov8" title="1">{
                                var newEnv corev1.EnvVar
                                if envKey == DB_USER </span><span class="cov8" title="1">{
                                        newEnv = corev1.EnvVar{
                                                Name: envKey,
                                                ValueFrom: &amp;corev1.EnvVarSource{
                                                        SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                LocalObjectReference: corev1.LocalObjectReference{
                                                                        Name: props.DBSecretName,
                                                                },
                                                                Key: secretKey,
                                                        },
                                                },
                                        }
                                }</span> else<span class="cov8" title="1"> {
                                        newEnv = corev1.EnvVar{
                                                Name: envKey,
                                                ValueFrom: &amp;corev1.EnvVarSource{
                                                        SecretKeyRef: &amp;corev1.SecretKeySelector{
                                                                LocalObjectReference: corev1.LocalObjectReference{
                                                                        Name: props.DBSecretName,
                                                                },
                                                                Key: secretKey,
                                                        },
                                                },
                                        }
                                }</span>
                                // if existing entry found, replace that
                                <span class="cov8" title="1">appendNewEnv := true
                                for existingIndex, _env := range existingEnv </span><span class="cov8" title="1">{
                                        if _env.Name == envKey </span><span class="cov8" title="1">{
                                                existingEnv[existingIndex] = newEnv
                                                appendNewEnv = false
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if appendNewEnv </span><span class="cov0" title="0">{
                                        existingEnv = append(existingEnv, newEnv)
                                }</span>
                        }
                        // update the changes into the actual container
                        <span class="cov8" title="1">dep.Spec.Template.Spec.Containers[containerIndex].Env = existingEnv
                        break</span>
                }

                <span class="cov8" title="1">uObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(dep)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(uObj)
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file124" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        "context"

        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonTriggerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektontrigger"
        tektonTriggerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektontrigger"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const versionConfigMap = "triggers-info"

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }

                manifest, triggersVer := ctrl.InitController(ctx, common.PayloadOptions{})

                metrics, err := NewRecorder()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to create trigger metrics recorder %v", err)
                }</span>

                <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()

                c := &amp;Reconciler{
                        kubeClientSet:      kubeclient.Get(ctx),
                        pipelineInformer:   tektonPipelineinformer.Get(ctx),
                        installerSetClient: client.NewInstallerSetClient(tisClient, operatorVer, triggersVer, v1alpha1.KindTektonTrigger, metrics),
                        extension:          generator(ctx),
                        manifest:           manifest,
                        triggersVersion:    triggersVer,
                }
                impl := tektonTriggerreconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for TektonTrigger")

                if _, err := tektonTriggerinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonTrigger informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonTrigger{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file125" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        tektontriggerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektontrigger"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

var _ tektontriggerreconciler.Finalizer = (*Reconciler)(nil)

// FinalizeKind removes all resources after deletion of a TektonTrigger CR.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonTrigger) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        //Delete CRDs before deleting rest of resources so that any instance
        //of CRDs which has finalizer set will get deleted before we remove
        //the controller;s deployment for it
        if err := r.manifest.Filter(mf.CRDs).Delete(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to deleted CRDs for TektonTrigger")
                return err
        }</span>

        <span class="cov0" title="0">if err := r.installerSetClient.CleanupMainSet(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to cleanup main installerset: ", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        "context"
        "fmt"
        "time"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        "knative.dev/pkg/metrics"
)

var (
        tReconcileCount = stats.Float64("trigger_reconcile_count",
                "number of trigger install",
                stats.UnitDimensionless)
)

// Recorder holds keys for Tekton metrics
type Recorder struct {
        initialized bool
        status      tag.Key
        version     tag.Key

        ReportingPeriod time.Duration
}

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder() (*Recorder, error) <span class="cov0" title="0">{
        r := &amp;Recorder{
                initialized: true,

                // Default to 30s intervals.
                ReportingPeriod: 30 * time.Second,
        }

        status, err := tag.NewKey("status")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.status = status

        version, err := tag.NewKey("version")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.version = version

        err = view.Register(
                &amp;view.View{
                        Description: tReconcileCount.Description(),
                        Measure:     tReconcileCount,
                        Aggregation: view.Count(),
                        TagKeys:     []tag.Key{r.status, r.version},
                },
        )

        if err != nil </span><span class="cov0" title="0">{
                r.initialized = false
                return r, err
        }</span>

        <span class="cov0" title="0">return r, nil</span>
}

// Count logs number of times a component (pipeline/trigger atm)
// has been installed or failed to install.
func (r *Recorder) Count(status, version string) error <span class="cov0" title="0">{
        if !r.initialized </span><span class="cov0" title="0">{
                return fmt.Errorf(
                        "ignoring the metrics recording for trigger , failed to initialize the metrics recorder")
        }</span>

        <span class="cov0" title="0">ctx, err := tag.New(
                context.Background(),
                tag.Insert(r.status, status),
                tag.Insert(r.version, version),
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">metrics.Record(ctx, tReconcileCount.M(1))
        return nil</span>
}

func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) <span class="cov0" title="0">{
        err := m.Count(status, version)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("%v: Failed to log the metrics : %v", resourceKind, err)
        }</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        pipelineinformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        tektontriggerreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektontrigger"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const resourceKind = v1alpha1.KindTektonTrigger

// Reconciler implements controller.Reconciler for TektonTrigger resources.
type Reconciler struct {
        // kube client to interact with core k8s resources
        kubeClientSet kubernetes.Interface
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // pipelineInformer to query for TektonPipeline
        pipelineInformer pipelineinformer.TektonPipelineInformer
        // manifest has the source manifest of Tekton Triggers for a
        // particular version
        manifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension common.Extension
        // version of triggers which we are installing
        triggersVersion string
}

// Check that our Reconciler implements controller.Reconciler
var _ tektontriggerreconciler.Interface = (*Reconciler)(nil)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, tt *v1alpha1.TektonTrigger) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("tektonTrigger", tt.GetName())
        tt.Status.InitializeConditions()
        tt.Status.SetVersion(r.triggersVersion)

        logger.Infow("Starting TektonTrigger reconciliation",
                "version", r.triggersVersion,
                "status", tt.Status.GetCondition(apis.ConditionReady))

        if tt.GetName() != v1alpha1.TriggerResourceName </span><span class="cov0" title="0">{
                logger.Errorw("Invalid resource name",
                        "expectedName", v1alpha1.TriggerResourceName,
                        "actualName", tt.GetName())
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.TriggerResourceName,
                        tt.GetName())
                tt.Status.MarkNotReady(msg)
                return nil
        }</span>

        <span class="cov0" title="0">if err := r.targetNamespaceCheck(ctx, tt); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Target namespace check failed", "error", err)
                return err
        }</span>

        //Make sure TektonPipeline is installed before proceeding with
        //TektonTrigger
        <span class="cov0" title="0">logger.Debug("Checking TektonPipeline dependency")
        if _, err := common.PipelineReady(r.pipelineInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        logger.Infow("Waiting for TektonPipeline installation to complete")
                        tt.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
                        // wait for pipeline status to change
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                // (tektonpipeline.operator.tekton.dev instance not available yet)
                <span class="cov0" title="0">logger.Errorw("TektonPipeline dependency not found", "error", err)
                tt.Status.MarkDependencyMissing("tekton-pipelines does not exist")
                return err</span>
        }
        <span class="cov0" title="0">tt.Status.MarkDependenciesInstalled()
        logger.Info("All dependencies installed successfully")

        // Pass the object through defaulting
        logger.Debug("Applying defaults to TektonTrigger")
        tt.SetDefaults(ctx)

        if err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to remove obsolete installer sets", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Successfully removed obsolete installer sets")

        logger.Debug("Running pre-reconciliation steps")
        if err := r.extension.PreReconcile(ctx, tt); err != nil </span><span class="cov0" title="0">{
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Infow("PreReconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">msg := fmt.Sprintf("PreReconciliation failed: %s", err.Error())
                logger.Errorw("PreReconciliation failed", "error", err)
                tt.Status.MarkPreReconcilerFailed(msg)
                return nil</span>
        }

        //Mark PreReconcile Complete
        <span class="cov0" title="0">tt.Status.MarkPreReconcilerComplete()
        logger.Info("PreReconciliation completed successfully")

        // Ensure webhook deadlock prevention before applying the manifest
        logger.Debugw("Preventing webhook deadlock")
        if err := common.PreemptDeadlock(ctx, &amp;r.manifest, r.kubeClientSet, v1alpha1.TriggerResourceName); err != nil </span><span class="cov0" title="0">{
                logger.Error("Webhook deadlock prevention failed", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debugw("Webhook deadlock prevention successful")

        logger.Debugw("Running main reconciliation with installer set")
        if err := r.installerSetClient.MainSet(ctx, tt, &amp;r.manifest, filterAndTransform(r.extension)); err != nil </span><span class="cov0" title="0">{
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Info("Main reconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">msg := fmt.Sprintf("Main Reconcilation failed: %s", err.Error())
                logger.Errorw("Main reconciliation failed", "error", err)
                tt.Status.MarkInstallerSetNotReady(msg)
                return nil</span>
        }
        <span class="cov0" title="0">logger.Info("Main reconciliation completed successfully")

        logger.Debug("Running post-reconciliation steps")
        if err := r.extension.PostReconcile(ctx, tt); err != nil </span><span class="cov0" title="0">{
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        logger.Infow("PostReconciliation requested requeue")
                        return err
                }</span>
                <span class="cov0" title="0">msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                logger.Errorw("PostReconciliation failed", "error", err)
                tt.Status.MarkPostReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PostReconcile Complete
        <span class="cov0" title="0">tt.Status.MarkPostReconcilerComplete()
        logger.Infow("TektonTrigger reconciliation completed successfully",
                "ready", tt.Status.GetCondition(apis.ConditionReady).IsTrue(),
                "version", r.triggersVersion)

        return nil</span>
}

func (r *Reconciler) targetNamespaceCheck(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        ns, err := r.kubeClientSet.CoreV1().Namespaces().Get(ctx, comp.GetSpec().GetTargetNamespace(), metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                // if namespace is not there then return wait for it
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the namespace is in deletion state then delete the installerset
        // and create later otherwise it will keep doing api calls to create resources
        // and keep failing
        <span class="cov0" title="0">if ns.DeletionTimestamp != nil </span><span class="cov0" title="0">{
                if err := r.installerSetClient.CleanupMainSet(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return v1alpha1.REQUEUE_EVENT_AFTER</span>
        }
        <span class="cov0" title="0">return err</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

// Triggers ConfigMap
const (
        ConfigDefaults = "config-defaults-triggers"
        FeatureFlag    = "feature-flags-triggers"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                trigger := comp.(*v1alpha1.TektonTrigger)

                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.TriggersImagePrefix))
                triggerImages := common.ImageRegistryDomainOverride(imagesRaw)

                // adding extension's transformers first to run them before `extra` transformers
                trns := extension.Transformers(trigger)
                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdTriggers),
                        common.AddConfigMapValues(ConfigDefaults, trigger.Spec.OptionalTriggersProperties),
                        common.AddConfigMapValues(FeatureFlag, trigger.Spec.TriggersProperties),
                        common.DeploymentImages(triggerImages),
                        common.DeploymentEnvVarKubernetesMinVersion(),
                        common.AddConfiguration(trigger.Spec.Config),
                }
                trns = append(trns, extra...)
                if err := common.Transform(ctx, manifest, trigger, trns...); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov0" title="0">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, trigger.Spec.GetTargetNamespace(), trigger.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov0" title="0">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file129" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package annotation

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/markbates/inflect"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "go.uber.org/zap"
        "gomodules.xyz/jsonpatch/v2"
        admissionv1 "k8s.io/api/admission/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        admissionlisters "k8s.io/client-go/listers/admissionregistration/v1"
        corelisters "k8s.io/client-go/listers/core/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/apis/duck"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmp"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
        certresources "knative.dev/pkg/webhook/certificates/resources"
)

// reconciler implements the AdmissionController for resources
type reconciler struct {
        webhook.StatelessAdmissionImpl
        pkgreconciler.LeaderAwareFuncs

        key  types.NamespacedName
        path string

        withContext func(context.Context) context.Context

        client       kubernetes.Interface
        mwhlister    admissionlisters.MutatingWebhookConfigurationLister
        secretlister corelisters.SecretLister

        disallowUnknownFields bool
        secretName            string
}

var _ controller.Reconciler = (*reconciler)(nil)
var _ pkgreconciler.LeaderAware = (*reconciler)(nil)
var _ webhook.AdmissionController = (*reconciler)(nil)
var _ webhook.StatelessAdmissionController = (*reconciler)(nil)

// Reconcile implements controller.Reconciler
func (ac *reconciler) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        if !ac.IsLeaderFor(ac.key) </span><span class="cov0" title="0">{
                logger.Debugf("Skipping key %q, not the leader.", ac.key)
                return nil
        }</span>

        // Look up the webhook secret, and fetch the CA cert bundle.
        <span class="cov0" title="0">secret, err := ac.secretlister.Secrets(system.Namespace()).Get(ac.secretName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error fetching secret", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">caCert, ok := secret.Data[certresources.CACert]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("secret %q is missing %q key", ac.secretName, certresources.CACert)
        }</span>

        // Reconcile the webhook configuration.
        <span class="cov0" title="0">return ac.reconcileMutatingWebhook(ctx, caCert)</span>
}

// Path implements AdmissionController
func (ac *reconciler) Path() string <span class="cov0" title="0">{
        return ac.path
}</span>

// Admit implements AdmissionController
func (ac *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse <span class="cov0" title="0">{
        if ac.withContext != nil </span><span class="cov0" title="0">{
                ctx = ac.withContext(ctx)
        }</span>

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        switch request.Operation </span>{
        case admissionv1.Create:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                logger.Info("Unhandled webhook operation, letting it through ", request.Operation)
                return &amp;admissionv1.AdmissionResponse{Allowed: true}</span>
        }

        <span class="cov0" title="0">patchBytes, err := ac.mutate(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("mutation failed: %v", err)
        }</span>
        <span class="cov0" title="0">logger.Infof("Kind: %q PatchBytes: %v", request.Kind, string(patchBytes))

        return &amp;admissionv1.AdmissionResponse{
                Patch:   patchBytes,
                Allowed: true,
                PatchType: func() *admissionv1.PatchType </span><span class="cov0" title="0">{
                        pt := admissionv1.PatchTypeJSONPatch
                        return &amp;pt
                }</span>(),
        }
}

func (ac *reconciler) reconcileMutatingWebhook(ctx context.Context, caCert []byte) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        pluralEL := strings.ToLower(inflect.Pluralize("EventListener"))
        rules := []admissionregistrationv1.RuleWithOperations{
                {
                        Operations: []admissionregistrationv1.OperationType{
                                admissionregistrationv1.Create,
                        },
                        Rule: admissionregistrationv1.Rule{
                                APIGroups:   []string{"triggers.tekton.dev"},
                                APIVersions: []string{"v1alpha1", "v1beta1"},
                                Resources:   []string{pluralEL, pluralEL + "/status"},
                        },
                },
        }

        configuredWebhook, err := ac.mwhlister.Get(ac.key.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error retrieving webhook: %w", err)
        }</span>

        <span class="cov0" title="0">webhook := configuredWebhook.DeepCopy()

        // Clear out any previous (bad) OwnerReferences.
        // See: https://github.com/knative/serving/issues/5845
        webhook.OwnerReferences = nil

        for i, wh := range webhook.Webhooks </span><span class="cov0" title="0">{
                if wh.Name != webhook.Name </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">webhook.Webhooks[i].Rules = rules
                webhook.Webhooks[i].NamespaceSelector = &amp;metav1.LabelSelector{
                        MatchExpressions: []metav1.LabelSelectorRequirement{{
                                Key:      "operator.tekton.dev/enable-annotation",
                                Operator: metav1.LabelSelectorOpIn,
                                Values:   []string{"enabled"},
                        }, {
                                // "control-plane" is added to support Azure's AKS, otherwise the controllers fight.
                                // See knative/pkg#1590 for details.
                                Key:      "control-plane",
                                Operator: metav1.LabelSelectorOpDoesNotExist,
                        }},
                }
                webhook.Webhooks[i].ClientConfig.CABundle = caCert
                if webhook.Webhooks[i].ClientConfig.Service == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing service reference for webhook: %s", wh.Name)
                }</span>
                <span class="cov0" title="0">webhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())</span>
        }

        <span class="cov0" title="0">if ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error diffing webhooks: %w", err)
        }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                logger.Info("Updating webhook")
                mwhclient := ac.client.AdmissionregistrationV1().MutatingWebhookConfigurations()
                if _, err := mwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update webhook: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("Webhook is valid")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ac *reconciler) mutate(ctx context.Context, req *admissionv1.AdmissionRequest) ([]byte, error) <span class="cov0" title="0">{
        kind := req.Kind
        newBytes := req.Object.Raw
        oldBytes := req.OldObject.Raw
        // Why, oh why are these different types...
        gvk := schema.GroupVersionKind{
                Group:   kind.Group,
                Version: kind.Version,
                Kind:    kind.Kind,
        }

        logger := logging.FromContext(ctx)
        if gvk.Group != "triggers.tekton.dev" || !(gvk.Version == "v1alpha1" || gvk.Version == "v1beta1") || gvk.Kind != "EventListener" </span><span class="cov0" title="0">{
                logger.Error("Unhandled kind: ", gvk)
                return nil, fmt.Errorf("unhandled kind: %v", gvk)
        }</span>

        // nil values denote absence of `old` (create) or `new` (delete) objects.
        <span class="cov0" title="0">var oldObj, newObj v1beta1.EventListener

        if len(newBytes) != 0 </span><span class="cov0" title="0">{
                newDecoder := json.NewDecoder(bytes.NewBuffer(newBytes))
                if ac.disallowUnknownFields </span><span class="cov0" title="0">{
                        newDecoder.DisallowUnknownFields()
                }</span>
                <span class="cov0" title="0">if err := newDecoder.Decode(&amp;newObj); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot decode incoming new object: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if len(oldBytes) != 0 </span><span class="cov0" title="0">{
                oldDecoder := json.NewDecoder(bytes.NewBuffer(oldBytes))
                if ac.disallowUnknownFields </span><span class="cov0" title="0">{
                        oldDecoder.DisallowUnknownFields()
                }</span>
                <span class="cov0" title="0">if err := oldDecoder.Decode(&amp;oldObj); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot decode incoming old object: %w", err)
                }</span>
        }
        <span class="cov0" title="0">var patches duck.JSONPatch

        var err error
        // Skip this step if the type we're dealing with is a duck type, since it is inherently
        // incomplete and this will patch away all of the unspecified fields.
        // Add these before defaulting fields, otherwise defaulting may cause an illegal patch
        // because it expects the round tripped through Golang fields to be present already.
        rtp, err := roundTripPatch(newBytes, newObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create patch for round tripped newBytes: %w", err)
        }</span>
        <span class="cov0" title="0">patches = append(patches, rtp...)

        ctx = apis.WithinCreate(ctx)
        ctx = apis.WithUserInfo(ctx, &amp;req.UserInfo)

        // Default the new object.
        if patches, err = setDefaults(ctx, patches, newObj); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed the resource specific defaulter", zap.Error(err))
                // Return the error message as-is to give the defaulter callback
                // discretion over (our portion of) the message that the user sees.
                return nil, err
        }</span>

        <span class="cov0" title="0">return json.Marshal(patches)</span>
}

// roundTripPatch generates the JSONPatch that corresponds to round tripping the given bytes through
// the Golang type (JSON -&gt; Golang type -&gt; JSON). Because it is not always true that
// bytes == json.Marshal(json.Unmarshal(bytes)).
//
// For example, if bytes did not contain a 'spec' field and the Golang type specifies its 'spec'
// field without omitempty, then by round tripping through the Golang type, we would have added
// `'spec': {}`.
func roundTripPatch(bytes []byte, unmarshalled interface{}) (duck.JSONPatch, error) <span class="cov0" title="0">{
        if unmarshalled == nil </span><span class="cov0" title="0">{
                return duck.JSONPatch{}, nil
        }</span>
        <span class="cov0" title="0">marshaledBytes, err := json.Marshal(unmarshalled)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot marshal interface: %w", err)
        }</span>
        <span class="cov0" title="0">return jsonpatch.CreatePatch(bytes, marshaledBytes)</span>
}

// setDefaults simply leverages apis.Defaultable to set defaults.
func setDefaults(ctx context.Context, patches duck.JSONPatch, el v1beta1.EventListener) (duck.JSONPatch, error) <span class="cov0" title="0">{
        before, after := el.DeepCopyObject(), el

        secretName := "el-" + el.Name
        after.Annotations = map[string]string{
                "service.beta.openshift.io/serving-cert-secret-name": secretName,
        }
        if after.Spec.Resources.KubernetesResource == nil </span><span class="cov0" title="0">{
                after.Spec.Resources.KubernetesResource = &amp;v1beta1.KubernetesResource{}
                after.Spec.Resources.KubernetesResource = &amp;v1beta1.KubernetesResource{
                        WithPodSpec: duckv1.WithPodSpec{
                                Template: duckv1.PodSpecable{
                                        Spec: corev1.PodSpec{
                                                Containers: getContainers(secretName),
                                        },
                                },
                        },
                }
        }</span>
        <span class="cov0" title="0">envNames := map[string]string{}
        if after.Spec.Resources.KubernetesResource != nil </span><span class="cov0" title="0">{
                if len(after.Spec.Resources.KubernetesResource.Template.Spec.Containers) == 0 </span><span class="cov0" title="0">{
                        after.Spec.Resources.KubernetesResource.Template.Spec.Containers = getContainers(secretName)
                }</span> else<span class="cov0" title="0"> {
                        for i := range after.Spec.Resources.KubernetesResource.Template.Spec.Containers </span><span class="cov0" title="0">{
                                if len(after.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env) == 0 </span><span class="cov0" title="0">{
                                        after.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env = getEnv(secretName)
                                }</span> else<span class="cov0" title="0"> {
                                        for _, v := range after.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env </span><span class="cov0" title="0">{
                                                envNames[v.Name] = v.Name
                                        }</span>
                                        <span class="cov0" title="0">if envNames["TLS_CERT"] != "TLS_CERT" &amp;&amp; envNames["TLS_KEY"] != "TLS_KEY" </span><span class="cov0" title="0">{
                                                after.Spec.Resources.KubernetesResource.Template.Spec.Containers[i].Env = getEnv(secretName)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">patch, err := duck.CreatePatch(before, after)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return append(patches, patch...), nil</span>
}

func getContainers(secretName string) []corev1.Container <span class="cov0" title="0">{
        return []corev1.Container{{
                Env: getEnv(secretName),
        }}
}</span>

func getEnv(secretName string) []corev1.EnvVar <span class="cov0" title="0">{
        return []corev1.EnvVar{{
                Name: "TLS_CERT",
                ValueFrom: &amp;corev1.EnvVarSource{
                        SecretKeyRef: &amp;corev1.SecretKeySelector{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: secretName,
                                },
                                Key: "tls.crt",
                        },
                },
        }, {
                Name: "TLS_KEY",
                ValueFrom: &amp;corev1.EnvVarSource{
                        SecretKeyRef: &amp;corev1.SecretKeySelector{
                                LocalObjectReference: corev1.LocalObjectReference{
                                        Name: secretName,
                                },
                                Key: "tls.key",
                        },
                },
        }}
}</span>
</pre>
		
		<pre class="file" id="file130" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package annotation

import (
        "context"
        // Injection stuff
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        mwhinformer "knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/mutatingwebhookconfiguration"
        "knative.dev/pkg/controller"
        secretinformer "knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
)

// NewAdmissionController constructs a reconciler
func NewAdmissionController(
        ctx context.Context,
        name, path string,
        wc func(context.Context) context.Context,
        disallowUnknownFields bool,
) *controller.Impl <span class="cov0" title="0">{

        client := kubeclient.Get(ctx)
        mwhInformer := mwhinformer.Get(ctx)
        secretInformer := secretinformer.Get(ctx)
        options := webhook.GetOptions(ctx)

        key := types.NamespacedName{Name: name}

        wh := &amp;reconciler{
                LeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{
                        // Have this reconciler enqueue our singleton whenever it becomes leader.
                        PromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                enq(bkt, key)
                                return nil
                        }</span>,
                },

                key:  key,
                path: path,

                withContext:           wc,
                disallowUnknownFields: disallowUnknownFields,
                secretName:            options.SecretName,

                client:       client,
                mwhlister:    mwhInformer.Lister(),
                secretlister: secretInformer.Lister(),
        }

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        c := controller.NewContext(ctx, wh, controller.ControllerOptions{WorkQueueName: "AnnotationDefaultingWebhook", Logger: logger})

        // Reconcile when the named MutatingWebhookConfiguration changes.
        if _, err := mwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithName(name),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named MWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register MutatingWebhookConfugration informer event handler: %w", err)
        }</span>

        // Reconcile when the cert bundle changes.
        <span class="cov0" title="0">if _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), wh.secretName),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named MWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register Secret informer event handler: %w", err)
        }</span>

        <span class="cov0" title="0">return c</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        "encoding/json"

        "github.com/tektoncd/operator/pkg/reconciler/common"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/kubernetes/scheme"
)

const (
        systemCAVolume = "config-trusted-system-cabundle-volume"
        systemCAKey    = "tls-ca-bundle.pem"
        systemCADir    = "/etc/pki/ca-trust/extracted/pem"
)

// ApplyCABundlesToDeployment is a transformer that add the trustedCA volume, mount and
// environment variables so that the deployment uses it.
func ApplyCABundlesToDeployment(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                // Don't do anything on something else than Deployment
                return nil
        }</span>

        <span class="cov8" title="1">deployment := &amp;appsv1.Deployment{}
        if err := scheme.Scheme.Convert(u, deployment, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Let's add the trusted and service CA bundle ConfigMaps as a volume in
        // the PodSpec which will later be mounted to add certs in the pod.
        <span class="cov8" title="1">deployment.Spec.Template.Spec.Volumes = common.AddCABundleConfigMapsToVolumes(deployment.Spec.Template.Spec.Volumes)
        deployment.Spec.Template.Spec.Volumes = common.AddOrReplaceInList(
                deployment.Spec.Template.Spec.Volumes,
                common.NewVolumeWithConfigMap(systemCAVolume, common.TrustedCAConfigMapName, common.TrustedCAKey, systemCAKey),
                func(v corev1.Volume) string </span><span class="cov8" title="1">{ return v.Name }</span>,
        )

        // Now that the injected certificates have been added as a volume, let's
        // mount them via volumeMounts in the containers
        <span class="cov8" title="1">for i := range deployment.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                c := deployment.Spec.Template.Spec.Containers[i] // Create a copy of the container
                common.AddCABundlesToContainerVolumes(&amp;c)
                addCABundlesToContainerSystemCAStore(&amp;c)
                deployment.Spec.Template.Spec.Containers[i] = c
        }</span>

        <span class="cov8" title="1">deployment.SetGroupVersionKind(schema.GroupVersionKind{
                Group:   appsv1.SchemeGroupVersion.Group,
                Version: appsv1.SchemeGroupVersion.Version,
                Kind:    "Deployment",
        })
        m, err := toUnstructured(deployment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.SetUnstructuredContent(m.Object)
        return nil</span>
}

func toUnstructured(v interface{}) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ud := &amp;unstructured.Unstructured{}
        if err := json.Unmarshal(b, ud); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ud, nil</span>
}

// ApplyCABundlesForStatefulSet is a transformer that adds CA bundle configurations to a StatefulSet.
// It configures both trusted CA bundle and service CA bundle by:
// - Adding volumes for the CA bundle ConfigMaps
// - Adding volume mounts to containers
// - Setting up necessary annotations for OpenShift service CA injection
// The function modifies the StatefulSet in place and returns any error encountered.
func ApplyCABundlesForStatefulSet(name string) func(u *unstructured.Unstructured) error <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "StatefulSet" || u.GetName() != name </span><span class="cov0" title="0">{
                        // Don't do anything on something else than the specified StatefulSet
                        return nil
                }</span>

                <span class="cov8" title="1">sts := &amp;appsv1.StatefulSet{}
                if err := scheme.Scheme.Convert(u, sts, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Let's add the trusted and service CA bundle ConfigMaps as a volume in
                // the PodSpec which will later be mounted to add certs in the pod.
                <span class="cov8" title="1">sts.Spec.Template.Spec.Volumes = common.AddCABundleConfigMapsToVolumes(sts.Spec.Template.Spec.Volumes)
                sts.Spec.Template.Spec.Volumes = common.AddOrReplaceInList(
                        sts.Spec.Template.Spec.Volumes,
                        common.NewVolumeWithConfigMap(systemCAVolume, common.TrustedCAConfigMapName, common.TrustedCAKey, systemCAKey),
                        func(v corev1.Volume) string </span><span class="cov8" title="1">{ return v.Name }</span>,
                )

                // Now that the injected certificates have been added as a volume, let's
                // mount them via volumeMounts in the containers
                <span class="cov8" title="1">for i := range sts.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        c := sts.Spec.Template.Spec.Containers[i] // Create a copy of the container
                        common.AddCABundlesToContainerVolumes(&amp;c)
                        addCABundlesToContainerSystemCAStore(&amp;c)
                        sts.Spec.Template.Spec.Containers[i] = c
                }</span>

                <span class="cov8" title="1">sts.SetGroupVersionKind(schema.GroupVersionKind{
                        Group:   appsv1.SchemeGroupVersion.Group,
                        Version: appsv1.SchemeGroupVersion.Version,
                        Kind:    "StatefulSet",
                })
                m, err := toUnstructured(sts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(m.Object)
                return nil</span>
        }
}

// addCABundlesToContainerSystemCAStore mounts the trusted-ca-configmap into the system ca store.
// This is necessary for components shelling out to "legacy applications" (e.g. cURL or git) to
// use the CA bundles, as "legacy applications"  do not respect SSL_CERT_DIR. In the Openshift
// environment the TrustedCAConfigMap has both the default and custom certificates combined.
// Note that the TrustedCAConfigMap does not contain the Service CA bundle. However that is
// utilized for the internal image registry and its tooling respects SSL_CERT_DIR.
//
// NOTE: This transformer should not be applied to pod templates which could reference
// user-defined images such as a TaskRun or PipelineRun since the transformer both assumes the
// image is a RHEL or a similar environment and because it may override a user's image's custom
// certificate bundle.
//
// See `man(8) update-ca-trust` for documentation on the directory structure and usage
// See openshift documentation for CA mounting details:
//
//        https://github.com/openshift/openshift-docs/blob/a8269cf65696fbd08647c8f3b5d065d53a8a1f52/modules/certificate-injection-using-operators.adoc
func addCABundlesToContainerSystemCAStore(container *corev1.Container) <span class="cov8" title="1">{
        newMount := corev1.VolumeMount{
                Name:      systemCAVolume,
                MountPath: systemCADir,
                ReadOnly:  true,
        }

        container.VolumeMounts = common.AddOrReplaceInList(
                container.VolumeMounts,
                newMount,
                func(v corev1.VolumeMount) string </span><span class="cov8" title="1">{ return v.Name }</span>,
        )
}
</pre>
		
		<pre class="file" id="file132" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
        mf "github.com/manifestival/manifestival"
        appsv1 "k8s.io/api/apps/v1"
        batchv1 "k8s.io/api/batch/v1"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
)

// RemoveRunAsUser will remove RunAsUser from all container in a deployment
func RemoveRunAsUser() mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">containers := d.Spec.Template.Spec.Containers
                removeRunAsUser(containers)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// RemoveRunAsUserForJob will remove RunAsUser from all container in a job
func RemoveRunAsUserForJob() mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                if u.GetKind() != "Job" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">jb := &amp;batchv1.Job{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">containers := jb.Spec.Template.Spec.Containers
                removeRunAsUser(containers)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

func removeRunAsUser(containers []v1.Container) <span class="cov8" title="1">{
        for i := range containers </span><span class="cov8" title="1">{
                c := &amp;containers[i]
                if c.SecurityContext != nil </span><span class="cov8" title="1">{
                        // Remove runAsUser
                        c.SecurityContext.RunAsUser = nil
                }</span>
        }
}

// RemoveRunAsGroup will remove runAsGroup from all container in a deployment
func RemoveRunAsGroup() mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for i := range d.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        c := &amp;d.Spec.Template.Spec.Containers[i]
                        if c.SecurityContext != nil </span><span class="cov8" title="1">{
                                // Remove runAsGroup
                                c.SecurityContext.RunAsGroup = nil
                        }</span>
                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// RemoveFsGroupForDeployment will remove FsGroup in a deployment
func RemoveFsGroupForDeployment() mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if d.Spec.Template.Spec.SecurityContext.FSGroup != nil </span><span class="cov8" title="1">{
                        d.Spec.Template.Spec.SecurityContext.FSGroup = nil
                }</span>

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// RemoveFsGroupForJob will remove FsGroup in a job
func RemoveFsGroupForJob() mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                if u.GetKind() != "Job" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">jb := &amp;batchv1.Job{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if jb.Spec.Template.Spec.SecurityContext.FSGroup != nil </span><span class="cov0" title="0">{
                        jb.Spec.Template.Spec.SecurityContext.FSGroup = nil
                }</span>

                <span class="cov0" title="0">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(jb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

func UpdateServiceMonitorTargetNamespace(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ServiceMonitor" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">nsSelector, found, err := unstructured.NestedFieldNoCopy(u.Object, "spec", "namespaceSelector")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">nsSelector.(map[string]interface{})["matchNames"].([]interface{})[0] = targetNamespace
                return nil</span>
        }
}

// RemoveRunAsUserForStatefulset will remove RunAsUser from all container in a statefulset
func RemoveRunAsUserForStatefulSet(name string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "StatefulSet" || u.GetName() != name </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">sts := &amp;appsv1.StatefulSet{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, sts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">containers := sts.Spec.Template.Spec.Containers
                removeRunAsUser(containers)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(sts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// RemoveFsGroupForStatefulSet will remove FsGroup in a statefulset
func RemoveFsGroupForStatefulSet(name string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "StatefulSet" || u.GetName() != name </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">sts := &amp;appsv1.StatefulSet{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, sts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if sts.Spec.Template.Spec.SecurityContext != nil &amp;&amp; sts.Spec.Template.Spec.SecurityContext.FSGroup != nil </span><span class="cov8" title="1">{
                        sts.Spec.Template.Spec.SecurityContext.FSGroup = nil
                }</span>

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(sts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// RemoveRunAsGroupForStatefulSet will remove runAsGroup from all container in a statefulset
func RemoveRunAsGroupForStatefulSet(name string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "StatefulSet" || u.GetName() != name </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">sts := &amp;appsv1.StatefulSet{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, sts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for i := range sts.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        c := &amp;sts.Spec.Template.Spec.Containers[i]
                        if c.SecurityContext != nil </span><span class="cov8" title="1">{
                                // Remove runAsGroup
                                c.SecurityContext.RunAsGroup = nil
                        }</span>
                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(sts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file133" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manualapprovalgate

import (
        "context"

        k8s_ctrl "github.com/tektoncd/operator/pkg/reconciler/kubernetes/manualapprovalgate"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package manualapprovalgate

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        "github.com/tektoncd/operator/pkg/reconciler/common"
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        ext := openshiftExtension{
                operatorClientSet: operatorclient.Get(ctx),
        }
        return ext
}</span>

type openshiftExtension struct {
        operatorClientSet versioned.Interface
}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return []mf.Transformer{}
}</span>

func (oe openshiftExtension) PreReconcile(ctx context.Context, mag v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>

func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>

func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package namespace

import (
        "context"

        "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonconfig"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        vwhinformer "knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/validatingwebhookconfiguration"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        secretinformer "knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
)

func NewNamespaceAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{

        return NewAdmissionController(ctx,

                // Name of the resource webhook.
                "namespace.operator.tekton.dev",

                // The path on which to serve the webhook.
                "/namespace-validation",

                // A function that infuses the context passed to Validate/SetDefaults with custom metadata.
                func(ctx context.Context) context.Context </span><span class="cov0" title="0">{
                        return ctx
                }</span>,

                // Whether to disallow unknown fields.
                true,
        )
}

// NewAdmissionController constructs a reconciler
func NewAdmissionController(
        ctx context.Context,
        name, path string,
        wc func(context.Context) context.Context,
        disallowUnknownFields bool,
) *controller.Impl <span class="cov0" title="0">{

        client := kubeclient.Get(ctx)
        vwhInformer := vwhinformer.Get(ctx)
        secretInformer := secretinformer.Get(ctx)
        options := webhook.GetOptions(ctx)
        tektonConfigInformer := tektonconfig.Get(ctx)

        key := types.NamespacedName{Name: name}

        wh := &amp;reconciler{
                LeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{
                        // Have this reconciler enqueue our singleton whenever it becomes leader.
                        PromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                enq(bkt, key)
                                return nil
                        }</span>,
                },

                key:  key,
                path: path,

                withContext:           wc,
                disallowUnknownFields: disallowUnknownFields,
                secretName:            options.SecretName,

                client:             client,
                vwhlister:          vwhInformer.Lister(),
                secretlister:       secretInformer.Lister(),
                tektonConfigLister: tektonConfigInformer.Lister(),
        }

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        c := controller.NewContext(ctx, wh, controller.ControllerOptions{WorkQueueName: "NamespaceAdmissionWebhook", Logger: logger})

        // Reconcile when the named ValidatingWebhookConfiguration changes.
        if _, err := vwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithName(name),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named VWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register ValidatingWebhookConfugration informer event handler: %w", err)
        }</span>

        // Reconcile when the cert bundle changes.
        <span class="cov0" title="0">if _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), wh.secretName),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named VWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register Secret informer event handler: %w", err)
        }</span>

        <span class="cov0" title="0">return c</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package namespace

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/markbates/inflect"
        "github.com/tektoncd/operator/pkg/client/listers/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/common"
        "github.com/tektoncd/operator/pkg/reconciler/openshift"
        "go.uber.org/zap"

        admissionv1 "k8s.io/api/admission/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        admissionlisters "k8s.io/client-go/listers/admissionregistration/v1"
        corelisters "k8s.io/client-go/listers/core/v1"

        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmp"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
        certresources "knative.dev/pkg/webhook/certificates/resources"
)

// reconciler implements the AdmissionController for resources
type reconciler struct {
        webhook.StatelessAdmissionImpl
        pkgreconciler.LeaderAwareFuncs

        key  types.NamespacedName
        path string

        withContext func(context.Context) context.Context

        client             kubernetes.Interface
        vwhlister          admissionlisters.ValidatingWebhookConfigurationLister
        secretlister       corelisters.SecretLister
        tektonConfigLister v1alpha1.TektonConfigLister

        disallowUnknownFields bool
        secretName            string
}

var _ controller.Reconciler = (*reconciler)(nil)
var _ pkgreconciler.LeaderAware = (*reconciler)(nil)
var _ webhook.AdmissionController = (*reconciler)(nil)
var _ webhook.StatelessAdmissionController = (*reconciler)(nil)

// Reconcile implements controller.Reconciler
func (ac *reconciler) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        if !ac.IsLeaderFor(ac.key) </span><span class="cov0" title="0">{
                logger.Debugf("Skipping key %q, not the leader.", ac.key)
                return nil
        }</span>

        // Look up the webhook secret, and fetch the CA cert bundle.
        <span class="cov0" title="0">secret, err := ac.secretlister.Secrets(system.Namespace()).Get(ac.secretName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error fetching secret", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">caCert, ok := secret.Data[certresources.CACert]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("secret %q is missing %q key", ac.secretName, certresources.CACert)
        }</span>

        // Reconcile the webhook configuration.
        <span class="cov0" title="0">return ac.reconcileValidatingWebhook(ctx, caCert)</span>
}

// Path implements AdmissionController
func (ac *reconciler) Path() string <span class="cov0" title="0">{
        return ac.path
}</span>

// Admit implements AdmissionController
func (ac *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse <span class="cov8" title="1">{
        if ac.withContext != nil </span><span class="cov0" title="0">{
                ctx = ac.withContext(ctx)
        }</span>

        <span class="cov8" title="1">logger := logging.FromContext(ctx)

        // Need to handle both, create and update operations for a namespace
        switch request.Operation </span>{
        case admissionv1.Create, admissionv1.Update:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                logger.Info("Unhandled webhook operation, letting it through ", request.Operation)
                return &amp;admissionv1.AdmissionResponse{Allowed: true}</span>
        }

        <span class="cov8" title="1">isAllowed, status, err := ac.admissionAllowed(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("admission failed for namespace %v", err)
        }</span>

        // Something in status means that admission isn't allowed
        <span class="cov8" title="1">if status != nil </span><span class="cov0" title="0">{
                return &amp;admissionv1.AdmissionResponse{
                        // isAllowed should be false here always
                        Allowed: isAllowed,
                        Result:  status,
                }
        }</span>

        <span class="cov8" title="1">return &amp;admissionv1.AdmissionResponse{
                // At this point, isAllowed should always be true
                Allowed: isAllowed,
        }</span>
}

func (ac *reconciler) admissionAllowed(ctx context.Context, req *admissionv1.AdmissionRequest) (bool, *metav1.Status, error) <span class="cov8" title="1">{
        kind := req.Kind
        namespaceRawBytes := req.Object.Raw

        // Why, oh why are these different types...
        gvk := schema.GroupVersionKind{
                Group:   kind.Group,
                Version: kind.Version,
                Kind:    kind.Kind,
        }

        logger := logging.FromContext(ctx)
        if gvk.Group != "" || gvk.Version != "v1" || gvk.Kind != "Namespace" </span><span class="cov8" title="1">{
                logger.Error("Unhandled kind: ", gvk)
                return false, nil, fmt.Errorf("unhandled kind: %v", gvk)
        }</span>

        // nil values denote absence of `old` (create) or `new` (delete) objects.
        <span class="cov8" title="1">var namespaceObject corev1.Namespace

        if len(namespaceRawBytes) != 0 </span><span class="cov8" title="1">{
                newDecoder := json.NewDecoder(bytes.NewBuffer(namespaceRawBytes))
                if ac.disallowUnknownFields </span><span class="cov0" title="0">{
                        newDecoder.DisallowUnknownFields()
                }</span>
                <span class="cov8" title="1">if err := newDecoder.Decode(&amp;namespaceObject); err != nil </span><span class="cov0" title="0">{
                        return false, nil, fmt.Errorf("cannot decode incoming new object: %w", err)
                }</span>
        }

        <span class="cov8" title="1">nsSCC := namespaceObject.Annotations[openshift.NamespaceSCCAnnotation]
        // If no annotation in namespace, then nothing to do here
        if nsSCC == "" </span><span class="cov8" title="1">{
                return true, nil, nil
        }</span>

        <span class="cov0" title="0">logger.Infof("Trying to admit namespace: %s with SCC: %s", namespaceObject.Name, nsSCC)

        securityClient := common.GetSecurityClient(ctx)

        // verify SCC exists on the cluster
        _, err := securityClient.SecurityV1().SecurityContextConstraints().Get(ctx, nsSCC, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>

        <span class="cov0" title="0">tc, err := ac.tektonConfigLister.Get("config")
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>

        // Check if the SCC requested in namespace is in line with the maxAllowed SCC in TektonConfig
        <span class="cov0" title="0">maxAllowedSCC := tc.Spec.Platforms.OpenShift.SCC.MaxAllowed

        // If no maxAllowed is set, no problem
        if maxAllowedSCC == "" </span><span class="cov0" title="0">{
                logger.Infof("Namespace %s validation: no maxAllowed SCC set in TektonConfig", namespaceObject.Name)
                return true, nil, nil
        }</span>

        <span class="cov0" title="0">prioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, securityClient)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>

        <span class="cov0" title="0">isPriority, err := common.SCCAMoreRestrictiveThanB(prioritizedSCCList, nsSCC, maxAllowedSCC)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>
        <span class="cov0" title="0">logger.Infof("Is maxAllowed SCC: %s less restrictive than namespace SCC: %s? %t", maxAllowedSCC, nsSCC, isPriority)
        if !isPriority </span><span class="cov0" title="0">{
                prioErr := fmt.Sprintf("namespace: %s has requested SCC: %s, but it is less restrictive than 'maxAllowed' SCC: %s", namespaceObject.Name, nsSCC, maxAllowedSCC)
                return false, &amp;metav1.Status{
                        Status:  "Failure",
                        Message: prioErr,
                }, nil
        }</span>

        <span class="cov0" title="0">return true, nil, nil</span>
}

func (ac *reconciler) reconcileValidatingWebhook(ctx context.Context, caCert []byte) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        pluralNS := strings.ToLower(inflect.Pluralize("Namespace"))
        rules := []admissionregistrationv1.RuleWithOperations{
                {
                        Operations: []admissionregistrationv1.OperationType{
                                admissionregistrationv1.Create,
                                admissionregistrationv1.Update,
                        },
                        Rule: admissionregistrationv1.Rule{
                                APIGroups:   []string{""},
                                APIVersions: []string{"v1"},
                                Resources:   []string{pluralNS, pluralNS + "/status"},
                        },
                },
        }

        configuredWebhook, err := ac.vwhlister.Get(ac.key.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error retrieving webhook: %w", err)
        }</span>

        <span class="cov0" title="0">webhook := configuredWebhook.DeepCopy()

        // Clear out any previous (bad) OwnerReferences.
        // See: https://github.com/knative/serving/issues/5845
        webhook.OwnerReferences = nil

        for i, wh := range webhook.Webhooks </span><span class="cov0" title="0">{
                if wh.Name != webhook.Name </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">webhook.Webhooks[i].Rules = rules
                webhook.Webhooks[i].NamespaceSelector = &amp;metav1.LabelSelector{
                        MatchExpressions: []metav1.LabelSelectorRequirement{
                                {
                                        // "control-plane" is added to support Azure's AKS, otherwise the controllers fight.
                                        // See knative/pkg#1590 for details.
                                        Key:      "control-plane",
                                        Operator: metav1.LabelSelectorOpDoesNotExist,
                                },
                        },
                }
                // Exclude system namespaces
                webhook.Webhooks[i].MatchConditions = []admissionregistrationv1.MatchCondition{
                        {
                                Name:       "exclude-system-namespaces",
                                Expression: "!(object.metadata.name.startsWith('kube-') || object.metadata.name.startsWith('openshift-'))",
                        },
                }

                webhook.Webhooks[i].ClientConfig.CABundle = caCert
                if webhook.Webhooks[i].ClientConfig.Service == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing service reference for webhook: %s", wh.Name)
                }</span>
                <span class="cov0" title="0">webhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())</span>
        }

        <span class="cov0" title="0">if ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error diffing webhooks: %w", err)
        }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                logger.Info("Updating webhook")
                vwhclient := ac.client.AdmissionregistrationV1().ValidatingWebhookConfigurations()
                if _, err := vwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update webhook: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("Webhook is valid")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package openshiftpipelinesascode

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        pacInformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/openshiftpipelinesascode"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        pacreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/openshiftpipelinesascode"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const versionConfigMap = "pipelines-as-code-info"

// NewController initializes the controller and is called by the generated code
// Registers event handlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                ctrl := common.Controller{
                        Logger:           logger,
                        VersionConfigMap: versionConfigMap,
                }
                manifest, pacVersion := ctrl.InitController(ctx, common.PayloadOptions{})

                operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()

                metrics, err := common.NoMetrics()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to create trigger metrics recorder %v", err)
                }</span>

                <span class="cov0" title="0">c := &amp;Reconciler{
                        pipelineInformer:      tektonPipelineinformer.Get(ctx),
                        installerSetClient:    client.NewInstallerSetClient(tisClient, operatorVer, pacVersion, v1alpha1.KindOpenShiftPipelinesAsCode, metrics),
                        extension:             generator(ctx),
                        manifest:              manifest,
                        additionalPACManifest: filterAdditionalControllerManifest(manifest),
                        pacVersion:            pacVersion,
                }
                impl := pacreconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for OpenShiftPipelinesAsCode")

                if _, err := pacInformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register OpenShiftPipelinesAsCode informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.OpenShiftPipelinesAsCode{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>
                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file138" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package openshiftpipelinesascode

import (
        "context"
        "os"
        "path/filepath"

        mfc "github.com/manifestival/client-go-client"
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "go.uber.org/zap"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const (
        openshiftNS = "openshift"
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("Error creating client from injected config", zap.Error(err))
        }</span>
        <span class="cov0" title="0">pacManifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("Error creating initial manifest", zap.Error(err))
        }</span>

        <span class="cov0" title="0">pacLocation := filepath.Join(os.Getenv(common.KoEnvKey), "tekton-addon", "pipelines-as-code")
        if err := common.AppendManifest(&amp;pacManifest, pacLocation); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("failed to fetch PAC manifest: %v", err)
        }</span>

        <span class="cov0" title="0">prTemplates, err := fetchPipelineRunTemplates()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("failed to fetch pipelineRun templates: %v", err)
        }</span>

        <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>

        <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()
        return openshiftExtension{
                // component version is used for metrics, passing a dummy
                // value through extension not going to affect execution
                installerSetClient:   client.NewInstallerSetClient(tisClient, operatorVer, "pipelines-as-code-ext", v1alpha1.KindOpenShiftPipelinesAsCode, nil),
                pacManifest:          &amp;pacManifest,
                pipelineRunTemplates: prTemplates,
        }</span>
}

type openshiftExtension struct {
        installerSetClient   *client.InstallerSetClient
        pacManifest          *mf.Manifest
        pipelineRunTemplates *mf.Manifest
}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) PreReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        if err := oe.installerSetClient.PostSet(ctx, comp, oe.pipelineRunTemplates, extFilterAndTransform()); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed post set creation: ", err)
                return err
        }</span>

        <span class="cov0" title="0">if err := updateControllerRouteInConfigMap(oe.pacManifest, comp.GetSpec().GetTargetNamespace()); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to update controller route: ", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>

func extFilterAndTransform() client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                prTemplates, err := manifest.Transform(mf.InjectNamespace(openshiftNS))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;prTemplates, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file139" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package openshiftpipelinesascode

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "sigs.k8s.io/yaml"
)

const (
        pacRuntimeLabel = "pipelinesascode.openshift.io/runtime"
)

var configmapTemplate = `apiVersion: v1
kind: ConfigMap
metadata:
  name: pipelines-as-code-template
  labels:
    app.kubernetes.io/part-of: pipelines-as-code
data:
  template: ""`

func fetchPipelineRunTemplates() (*mf.Manifest, error) <span class="cov0" title="0">{
        prManifests := mf.Manifest{}
        koDataDir := os.Getenv(common.KoEnvKey)
        templateLocation := filepath.Join(koDataDir, "tekton-addon", "pipelines-as-code-templates")
        if err := common.AppendManifest(&amp;prManifests, templateLocation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cmManifest, err := pipelineRunToConfigMapConverter(&amp;prManifests)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cmManifest, nil</span>
}

func pipelineRunToConfigMapConverter(prManifests *mf.Manifest) (*mf.Manifest, error) <span class="cov8" title="1">{
        cm := &amp;v1.ConfigMap{}
        err := yaml.Unmarshal([]byte(configmapTemplate), cm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var temp []unstructured.Unstructured
        for _, res := range prManifests.Resources() </span><span class="cov8" title="1">{
                if res.GetKind() != "PipelineRun" </span><span class="cov0" title="0">{
                        temp = append(temp, res)
                        continue</span>
                }

                <span class="cov8" title="1">data, err := yaml.Marshal(res.Object)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // set pipelineRun
                <span class="cov8" title="1">cm.Data["template"] = string(data)

                // set metadata
                prname := res.GetName()
                cm.SetName(fmt.Sprintf("pipelines-as-code-%s", prname))
                cm.Labels[pacRuntimeLabel] = strings.TrimPrefix(prname, "pipelinerun-")

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">temp = append(temp, unstructured.Unstructured{Object: unstrObj})</span>
        }
        <span class="cov8" title="1">manifest, _ := mf.ManifestFrom(mf.Slice(temp))
        return &amp;manifest, nil</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    hpacp://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package openshiftpipelinesascode

import (
        "context"
        "fmt"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        pipelineinformer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        pacreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/openshiftpipelinesascode"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        // additionalPACController installerset label value
        additionalPACControllerComponentLabelValue = "AdditionalPACController"
)

// Reconciler implements controller.Reconciler for OpenShiftPipelinesAsCode resources.
type Reconciler struct {
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // pipelineInformer to query for TektonPipeline
        pipelineInformer pipelineinformer.TektonPipelineInformer
        // manifest has the source manifest of Openshift Pipelines As Code for a
        // particular version
        manifest mf.Manifest
        // Platform-specific behavior to affect the transform
        extension common.Extension
        // version of PipelinesAsCode which we are installing
        pacVersion string
        // additionalPACManifest has the source manifest for the additional Openshift Pipelines As Code Controller
        additionalPACManifest mf.Manifest
}

// Check that our Reconciler implements controller.Reconciler
var _ pacreconciler.Interface = (*Reconciler)(nil)

// ReconcileKind compares the actual state with the desired, and apacempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, pac *v1alpha1.OpenShiftPipelinesAsCode) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("name", pac.GetName())
        pac.Status.InitializeConditions()
        pac.Status.SetVersion(r.pacVersion)

        if pac.GetName() != v1alpha1.OpenShiftPipelinesAsCodeName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.OpenShiftPipelinesAsCodeName,
                        pac.GetName(),
                )
                logger.Error(msg)
                pac.Status.MarkNotReady(msg)
                return nil
        }</span>

        //Make sure TektonPipeline is installed before proceeding with OpenShiftPipelinesAsCode
        <span class="cov0" title="0">if _, err := common.PipelineReady(r.pipelineInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        pac.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
                        // wait for pipeline status to change
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                // (tektonpipeline.operator.tekton.dev instance not available yet)
                <span class="cov0" title="0">pac.Status.MarkDependencyMissing("tekton-pipelines does not exist")
                return err</span>
        }
        <span class="cov0" title="0">pac.Status.MarkDependenciesInstalled()

        if err := r.extension.PreReconcile(ctx, pac); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //Mark PreReconcile Complete
        <span class="cov0" title="0">pac.Status.MarkPreReconcilerComplete()

        if err := r.installerSetClient.MainSet(ctx, pac, &amp;r.manifest, filterAndTransform(r.extension)); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Main Reconcilation failed: %s", err.Error())
                logger.Error(msg)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">pac.Status.MarkInstallerSetNotReady(msg)
                return nil</span>
        }

        // created additionalPACController for all entries provided
        <span class="cov0" title="0">for name, pacInfo := range pac.Spec.PACSettings.AdditionalPACControllers </span><span class="cov0" title="0">{
                // if it is not enabled then skip creating the additionalPACController
                if !*pacInfo.Enable </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">additionalPACControllerManifest := r.additionalPACManifest
                // if name of configMap is pipeline-as-code, then not create a new configmap
                if pacInfo.ConfigMapName == pipelinesAsCodeCM </span><span class="cov0" title="0">{
                        additionalPACControllerManifest = additionalPACControllerManifest.Filter(mf.Not(mf.ByKind("ConfigMap")))
                }</span>

                // create custome set installerset for the additionalPACController
                <span class="cov0" title="0">if err := r.installerSetClient.CustomSet(ctx, pac, name, &amp;additionalPACControllerManifest, additionalControllerTransform(r.extension, name), additionalPacControllerLabels()); err != nil </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("Additional PACController %s Reconciliation failed: %s", name, err.Error())
                        logger.Error(msg)
                        if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">pac.Status.MarkInstallerSetNotReady(msg)
                        return nil</span>
                }
        }

        // Handle the deletion of obsolute installersets of additionalController
        <span class="cov0" title="0">labelSelector := additionalPacControllerLabelSelector()
        logger.Debugf("checking custom installer sets with labels: %v", labelSelector)
        is, err := r.installerSetClient.ListCustomSet(ctx, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Additional PACController Reconciliation failed: %s", err.Error())
                logger.Error(msg)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        // for all the custom installerset available, iterate and delete which have been removed or disabled
        <span class="cov0" title="0">for _, i := range is.Items </span><span class="cov0" title="0">{
                // get the value of setType label which will be custom-&lt;name&gt;
                setTypeValue := i.GetLabels()[v1alpha1.InstallerSetType]
                // remove the prefix custom- to get the name
                name := strings.TrimPrefix(setTypeValue, fmt.Sprintf("%s-", client.InstallerTypeCustom))
                // check if the name exist in CR spec
                additionalPACinfo, ok := pac.Spec.PACSettings.AdditionalPACControllers[name]
                // if not exist with same name or marked disable, delete the installerset
                if !ok || !*additionalPACinfo.Enable </span><span class="cov0" title="0">{
                        if err := r.installerSetClient.CleanupCustomSet(ctx, name); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">pac.Status.MarkAdditionalPACControllerComplete()

        if err := r.extension.PostReconcile(ctx, pac); err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("PostReconciliation failed: %s", err.Error())
                logger.Error(msg)
                if err == v1alpha1.REQUEUE_EVENT_AFTER </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">pac.Status.MarkPostReconcilerFailed(msg)
                return nil</span>
        }

        // Mark PostReconcile Complete
        <span class="cov0" title="0">pac.Status.MarkPostReconcilerComplete()
        return nil</span>
}

// custom labels to added to the additionalPACController installerset
func additionalPacControllerLabels() map[string]string <span class="cov0" title="0">{
        labels := map[string]string{}
        labels[v1alpha1.ComponentKey] = additionalPACControllerComponentLabelValue
        return labels
}</span>

// labelSelector to filter the customsets of additionalPACController
func additionalPacControllerLabelSelector() string <span class="cov0" title="0">{
        labelSelector := labels.NewSelector()
        createdReq, _ := labels.NewRequirement(v1alpha1.CreatedByKey, selection.Equals, []string{v1alpha1.KindOpenShiftPipelinesAsCode})
        if createdReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*createdReq)
        }</span>
        <span class="cov0" title="0">componentReq, _ := labels.NewRequirement(v1alpha1.ComponentKey, selection.Equals, []string{additionalPACControllerComponentLabelValue})
        if componentReq != nil </span><span class="cov0" title="0">{
                labelSelector = labelSelector.Add(*componentReq)
        }</span>
        <span class="cov0" title="0">return labelSelector.String()</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package openshiftpipelinesascode

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        pacSettings "github.com/openshift-pipelines/pipelines-as-code/pkg/params/settings"
        routev1 "github.com/openshift/api/route/v1"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "github.com/tektoncd/operator/pkg/reconciler/openshift"
        occommon "github.com/tektoncd/operator/pkg/reconciler/openshift/common"
        "go.uber.org/zap"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
)

const (
        pipelinesAsCodeCM                 = "pipelines-as-code"
        additionalPACControllerNameSuffix = "-pac-controller"
)

func filterAndTransform(extension common.Extension) client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                pac := comp.(*v1alpha1.OpenShiftPipelinesAsCode)
                // installerSet adds it's owner as namespace's owner
                // so deleting tekton addon deletes target namespace too
                // to skip it we filter out namespace
                pacManifest := manifest.Filter(mf.Not(mf.ByKind("Namespace")))

                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PacImagePrefix))
                images := common.ImageRegistryDomainOverride(imagesRaw)
                // Run transformers
                tfs := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(openshift.OperandOpenShiftPipelineAsCode),
                        common.DeploymentImages(images),
                        common.DeploymentEnvVarKubernetesMinVersion(),
                        common.AddConfiguration(pac.Spec.Config),
                        occommon.ApplyCABundlesToDeployment,
                        common.CopyConfigMap(pipelinesAsCodeCM, pac.Spec.Settings),
                        occommon.UpdateServiceMonitorTargetNamespace(pac.Spec.TargetNamespace),
                }

                allTfs := append(tfs, extension.Transformers(pac)...)
                if err := common.Transform(ctx, &amp;pacManifest, pac, allTfs...); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov0" title="0">if err := common.ExecuteAdditionalOptionsTransformer(ctx, &amp;pacManifest, pac.Spec.GetTargetNamespace(), pac.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov0" title="0">return &amp;pacManifest, nil</span>
        }
}

func additionalControllerTransform(extension common.Extension, name string) client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                pac := comp.(*v1alpha1.OpenShiftPipelinesAsCode)
                additionalPACControllerConfig := pac.Spec.PACSettings.AdditionalPACControllers[name]

                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.PacImagePrefix))
                images := common.ImageRegistryDomainOverride(imagesRaw)
                // Run transformers
                tfs := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(openshift.OperandOpenShiftPipelineAsCode),
                        common.DeploymentImages(images),
                        common.AddConfiguration(pac.Spec.Config),
                        occommon.ApplyCABundlesToDeployment,
                        occommon.UpdateServiceMonitorTargetNamespace(pac.Spec.TargetNamespace),
                        updateAdditionControllerDeployment(additionalPACControllerConfig, name),
                        updateAdditionControllerService(name),
                        updateAdditionControllerConfigMap(additionalPACControllerConfig),
                        updateAdditionControllerRoute(name),
                        updateAdditionControllerServiceMonitor(name),
                }

                allTfs := append(tfs, extension.Transformers(pac)...)
                if err := common.Transform(ctx, manifest, pac, allTfs...); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                // additional options transformer
                // always execute as last transformer, so that the values in options will be final update values on the manifests
                <span class="cov0" title="0">if err := common.ExecuteAdditionalOptionsTransformer(ctx, manifest, pac.Spec.GetTargetNamespace(), pac.Spec.Options); err != nil </span><span class="cov0" title="0">{
                        return &amp;mf.Manifest{}, err
                }</span>

                <span class="cov0" title="0">return manifest, nil</span>
        }
}

// This returns all resources to deploy for the additional PACController
func filterAdditionalControllerManifest(manifest mf.Manifest) mf.Manifest <span class="cov8" title="1">{
        // filter deployment
        deploymentManifest := manifest.Filter(mf.All(mf.ByName("pipelines-as-code-controller"), mf.ByKind("Deployment")))

        // filter service
        serviceManifest := manifest.Filter(mf.All(mf.ByName("pipelines-as-code-controller"), mf.ByKind("Service")))

        // filter route
        routeManifest := manifest.Filter(mf.All(mf.ByName("pipelines-as-code-controller"), mf.ByKind("Route")))

        // filter configmap
        cmManifest := manifest.Filter(mf.All(mf.ByName("pipelines-as-code"), mf.ByKind("ConfigMap")))

        // filter serviceMonitor
        serviceMonitorManifest := manifest.Filter(mf.All(mf.ByName("pipelines-as-code-controller-monitor"), mf.ByKind("ServiceMonitor")))

        filteredManifest := mf.Manifest{}
        filteredManifest = filteredManifest.Append(cmManifest, deploymentManifest, serviceManifest, serviceMonitorManifest, routeManifest)
        return filteredManifest
}</span>

// This updates additional PACController deployment
func updateAdditionControllerDeployment(config v1alpha1.AdditionalPACControllerConfig, name string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">u.SetName(fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix))

                d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">d.Spec.Selector.MatchLabels["app.kubernetes.io/name"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)

                d.Spec.Template.Labels["app"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                d.Spec.Template.Labels["app.kubernetes.io/name"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)

                for i, container := range d.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        container.Name = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                        containerEnvs := d.Spec.Template.Spec.Containers[i].Env
                        d.Spec.Template.Spec.Containers[i].Env = replaceEnvInDeployment(containerEnvs, config, name)
                        d.Spec.Template.Spec.Containers[i] = container
                }</span>

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// This updates additional PACController Service
func updateAdditionControllerService(name string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Service" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">u.SetName(fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix))

                service := &amp;corev1.Service{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, service)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">labels := service.Labels
                if labels == nil </span><span class="cov0" title="0">{
                        labels = map[string]string{}
                }</span>
                <span class="cov8" title="1">labels["app"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                labels["app.kubernetes.io/name"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                service.SetLabels(labels)

                labelSelector := service.Spec.Selector
                if labelSelector == nil </span><span class="cov0" title="0">{
                        labelSelector = map[string]string{}
                }</span>
                <span class="cov8" title="1">labelSelector["app.kubernetes.io/name"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                service.Spec.Selector = labelSelector

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(service)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

// This updates additional PACController configMap and sets settings data to configMap data
func updateAdditionControllerConfigMap(config v1alpha1.AdditionalPACControllerConfig) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                // set the name
                // set the namespace
                // set the data from settings
                if u.GetKind() != "ConfigMap" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">u.SetName(config.ConfigMapName)

                // apply the defaults here, we are not adding the defaults in CR
                if config.Settings == nil </span><span class="cov8" title="1">{
                        config.Settings = map[string]string{}
                }</span>

                <span class="cov8" title="1">defaultPacSettings := pacSettings.DefaultSettings()
                err := pacSettings.SyncConfig(zap.NewNop().Sugar(), &amp;defaultPacSettings, config.Settings, pacSettings.DefaultValidators())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">config.Settings = v1alpha1.ConvertPacStructToConfigMap(&amp;defaultPacSettings)

                cm := &amp;corev1.ConfigMap{}
                err = runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if cm.Data == nil </span><span class="cov0" title="0">{
                        cm.Data = map[string]string{}
                }</span>

                <span class="cov8" title="1">for key, value := range config.Settings </span><span class="cov8" title="1">{
                        cm.Data[key] = value
                }</span>
                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>

        }
}

// This updates additional PACController route
func updateAdditionControllerRoute(name string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Route" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">u.SetName(fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix))

                route := &amp;routev1.Route{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, route)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">route.Spec.To.Name = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                labels := route.Labels
                if labels == nil </span><span class="cov0" title="0">{
                        labels = map[string]string{}
                }</span>
                <span class="cov8" title="1">labels["app"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                labels["pipelines-as-code/route"] = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                route.SetLabels(labels)

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(route)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}

// This updates additional PACController ServiceMonitor
func updateAdditionControllerServiceMonitor(name string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ServiceMonitor" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">u.SetName(fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix))
                err := unstructured.SetNestedMap(u.Object, map[string]interface{}{
                        "app": fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix),
                }, "spec", "selector", "matchLabels")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// This replaces additional PACController deployment's container env
func replaceEnvInDeployment(envs []corev1.EnvVar, envInfo v1alpha1.AdditionalPACControllerConfig, name string) []corev1.EnvVar <span class="cov8" title="1">{
        for i, e := range envs </span><span class="cov8" title="1">{
                if e.Name == "PAC_CONTROLLER_CONFIGMAP" </span><span class="cov8" title="1">{
                        envs[i].Value = envInfo.ConfigMapName
                }</span>
                <span class="cov8" title="1">if e.Name == "PAC_CONTROLLER_SECRET" </span><span class="cov8" title="1">{
                        envs[i].Value = envInfo.SecretName
                }</span>
                <span class="cov8" title="1">if e.Name == "PAC_CONTROLLER_LABEL" </span><span class="cov8" title="1">{
                        envs[i].Value = fmt.Sprintf("%s%s", name, additionalPACControllerNameSuffix)
                }</span>
        }
        <span class="cov8" title="1">return envs</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package openshiftpipelinesascode

import (
        "fmt"

        mf "github.com/manifestival/manifestival"
        routev1 "github.com/openshift/api/route/v1"
        "github.com/openshift/client-go/route/clientset/versioned/scheme"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
)

const (
        controllerRouteName = "pipelines-as-code-controller"
        infoConfigMapName   = "pipelines-as-code-info"
)

func updateControllerRouteInConfigMap(pacManifest *mf.Manifest, targetNs string) error <span class="cov8" title="1">{
        controllerRoute, err := getControllerRouteHost(pacManifest, targetNs)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get controller route: %v", err)
        }</span>
        <span class="cov8" title="1">if controllerRoute == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get host in route, will try again")
        }</span>
        <span class="cov8" title="1">if err := updateInfoConfigMap(controllerRoute, pacManifest, targetNs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getControllerRouteHost(manifest *mf.Manifest, targetNs string) (string, error) <span class="cov8" title="1">{
        var hostUrl string
        for _, r := range manifest.Filter(mf.ByKind("Route")).Resources() </span><span class="cov8" title="1">{
                r.SetNamespace(targetNs)
                u, err := manifest.Client.Get(&amp;r)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">if u.GetName() == controllerRouteName </span><span class="cov8" title="1">{
                        route := &amp;routev1.Route{}
                        if err := scheme.Scheme.Convert(u, route, nil); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">hostUrl = route.Spec.Host</span>
                }
        }
        <span class="cov8" title="1">return hostUrl, nil</span>
}

func updateInfoConfigMap(route string, pacManifest *mf.Manifest, targetNs string) error <span class="cov8" title="1">{
        for _, r := range pacManifest.Filter(mf.ByKind("ConfigMap")).Resources() </span><span class="cov8" title="1">{
                if r.GetName() != infoConfigMapName </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">r.SetNamespace(targetNs)
                u, err := pacManifest.Client.Get(&amp;r)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">cm := &amp;v1.ConfigMap{}
                err = runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">routeURL := fmt.Sprintf("https://%s", route)

                // set controller url if not the same
                if cm.Data["controller-url"] == routeURL </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">cm.Data["controller-url"] = routeURL

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cm)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                err = pacManifest.Client.Update(u)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package openshiftplatform

import (
        "github.com/tektoncd/operator/pkg/reconciler/platform"
)

// OpenShiftPlatform defines basic configuration for a OpenShift platform
type OpenShiftPlatform struct {
        platform.PlatformConfig
        supportedControllers platform.ControllerMap
}

// NewOpenShiftPlatform returns an instance of OpenShiftPlatform
func NewOpenShiftPlatform(pc platform.PlatformConfig) *OpenShiftPlatform <span class="cov0" title="0">{
        plt := OpenShiftPlatform{
                supportedControllers: openshiftControllers,
        }
        plt.PlatformConfig = pc
        plt.PlatformConfig.Name = PlatformNameOpenShift
        return &amp;plt
}</span>

// AllSupportedControllers returns a platform.ControllerMap of all controllers (reconcilers) of tektoncd/operator
// supported by OpenShift
func (op *OpenShiftPlatform) AllSupportedControllers() platform.ControllerMap <span class="cov0" title="0">{
        return op.supportedControllers
}</span>

// PlatformParams return platform.PlatformConfig of a OpenShiftPlatform
func (op *OpenShiftPlatform) PlatformParams() platform.PlatformConfig <span class="cov0" title="0">{
        return op.PlatformConfig
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

var communityResourceURLs = []string{
        "https://raw.githubusercontent.com/tektoncd/catalog/master/task/jib-maven/0.5/jib-maven.yaml",
        "https://raw.githubusercontent.com/tektoncd/catalog/master/task/helm-upgrade-from-source/0.3/helm-upgrade-from-source.yaml",
        "https://raw.githubusercontent.com/tektoncd/catalog/master/task/helm-upgrade-from-repo/0.2/helm-upgrade-from-repo.yaml",
        "https://raw.githubusercontent.com/tektoncd/catalog/master/task/trigger-jenkins-job/0.1/trigger-jenkins-job.yaml",
        "https://raw.githubusercontent.com/tektoncd/catalog/master/task/pull-request/0.1/pull-request.yaml",
        "https://raw.githubusercontent.com/tektoncd/catalog/master/task/kubeconfig-creator/0.1/kubeconfig-creator.yaml",
        "https://raw.githubusercontent.com/tektoncd/catalog/main/task/argocd-task-sync-and-wait/0.2/argocd-task-sync-and-wait.yaml",
}

func (r *Reconciler) EnsureCommunityResolverTask(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        if len(r.communityResolverTaskManifest.Resources()) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">manifest := *r.communityResolverTaskManifest
        if enable == "true" </span><span class="cov0" title="0">{
                if err := r.installerSetClient.CustomSet(ctx, ta, CommunityResolverTaskInstallerSet, &amp;manifest, filterAndTransformCommunityResolverTask(), nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := r.installerSetClient.CleanupCustomSet(ctx, CommunityResolverTaskInstallerSet); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func filterAndTransformCommunityResolverTask() client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                instance := comp.(*v1alpha1.TektonAddon)
                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))
                addonImages := common.ImageRegistryDomainOverride(imagesRaw)

                extra := []mf.Transformer{
                        injectLabel(labelProviderType, providerTypeCommunity, overwrite, "Task"),
                        common.TaskImages(ctx, addonImages),
                }
                if err := common.Transform(ctx, manifest, instance, extra...); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return manifest, nil</span>
        }
}

func appendCommunityResolverTasks(manifest *mf.Manifest) error <span class="cov0" title="0">{
        urls := strings.Join(communityResourceURLs, ",")
        m, err := mf.ManifestFrom(mf.Path(urls))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*manifest = manifest.Append(m)
        return nil</span>
}

func fetchCommunityResolverTasks(manifest *mf.Manifest) error <span class="cov0" title="0">{
        if err := appendCommunityResolverTasks(manifest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        routev1 "github.com/openshift/api/route/v1"
        "github.com/openshift/client-go/route/clientset/versioned/scheme"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "knative.dev/pkg/logging"
)

func (r *Reconciler) EnsureConsoleCLI(ctx context.Context, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        tknservecliManifest := r.openShiftConsoleManifest
        if err := common.Transform(ctx, tknservecliManifest, ta); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">routeHost, err := getRouteHost(tknservecliManifest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">manifest := *r.consoleCLIManifest
        if err := consoleCLITransform(ctx, &amp;manifest, routeHost); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.installerSetClient.CustomSet(ctx, ta, ConsoleCLIInstallerSet, &amp;manifest, filterAndTransformOCPResources(), nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getRouteHost(manifest *mf.Manifest) (string, error) <span class="cov0" title="0">{
        var hostUrl string
        for _, r := range manifest.Filter(mf.ByKind("Route")).Resources() </span><span class="cov0" title="0">{
                u, err := manifest.Client.Get(&amp;r)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if u.GetName() == "tkn-cli-serve" </span><span class="cov0" title="0">{
                        route := &amp;routev1.Route{}
                        if err := scheme.Scheme.Convert(u, route, nil); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">hostUrl = route.Spec.Host</span>
                }
        }
        <span class="cov0" title="0">return hostUrl, nil</span>
}

func consoleCLITransform(ctx context.Context, manifest *mf.Manifest, baseURL string) error <span class="cov0" title="0">{
        if baseURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("route url should not be empty")
        }</span>
        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        logger.Debug("Transforming manifest")

        transformers := []mf.Transformer{
                replaceURLCCD(baseURL),
        }

        transformManifest, err := manifest.Transform(transformers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*manifest = transformManifest
        return nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"
        "os"

        "github.com/go-logr/zapr"
        mfc "github.com/manifestival/client-go-client"
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonAddoninformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonaddon"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        tektonTriggerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektontrigger"
        tektonAddonreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonaddon"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "go.uber.org/zap"
        apiextensionsclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const (
        versionKey = "VERSION"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewExtendedController(common.NoExtension)(ctx, cmw)
}</span>

// NewExtendedController returns a controller extended to a specific platform
func NewExtendedController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating client from injected config", zap.Error(err))
                }</span>
                <span class="cov0" title="0">crdClient, err := apiextensionsclient.NewForConfig(injection.GetConfig(ctx))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating client from injected config", zap.Error(err))
                }</span>
                <span class="cov0" title="0">mflogger := zapr.NewLogger(logger.Named("manifestival").Desugar())
                manifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating initial manifest", zap.Error(err))
                }</span>

                <span class="cov0" title="0">version := os.Getenv(versionKey)
                if version == "" </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to find version from env")
                }</span>

                <span class="cov0" title="0">tisClient := operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()
                metrics, _ := NewRecorder()

                resolverTaskManifest := &amp;mf.Manifest{}
                if err := applyAddons(resolverTaskManifest, "06-ecosystem/tasks"); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to read namespaced tasks from kodata: %v", err)
                }</span>

                <span class="cov0" title="0">resolverStepActionManifest := &amp;mf.Manifest{}
                if err := applyAddons(resolverStepActionManifest, "06-ecosystem/stepactions"); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to read namespaced stepactions from kodata: %v", err)
                }</span>

                <span class="cov0" title="0">triggersResourcesManifest := &amp;mf.Manifest{}
                if err := applyAddons(triggersResourcesManifest, "01-clustertriggerbindings"); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to read trigger Resources from kodata: %v", err)
                }</span>

                <span class="cov0" title="0">pipelineTemplateManifest := &amp;mf.Manifest{}
                if err := applyAddons(pipelineTemplateManifest, "02-pipelines"); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to read pipeline template from kodata: %v", err)
                }</span>
                <span class="cov0" title="0">if err := addPipelineTemplates(pipelineTemplateManifest); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to add pipeline templates: %v", err)
                }</span>

                <span class="cov0" title="0">openShiftConsoleManifest := &amp;mf.Manifest{Client: mfclient}
                if err := applyAddons(openShiftConsoleManifest, "04-tkncliserve"); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to read openshift console resources from kodata: %v", err)
                }</span>
                <span class="cov0" title="0">if err := getOptionalAddons(openShiftConsoleManifest); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to read optional addon resources from kodata: %v", err)
                }</span>

                <span class="cov0" title="0">consoleCLIManifest := &amp;mf.Manifest{}
                if err := applyAddons(consoleCLIManifest, "03-consolecli"); err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("failed to read console cli from kodata: %v", err)
                }</span>

                <span class="cov0" title="0">communityResolverTaskManifest := &amp;mf.Manifest{}
                if err := fetchCommunityResolverTasks(communityResolverTaskManifest); err != nil </span><span class="cov0" title="0">{
                        // if unable to fetch community task, don't fail
                        logger.Errorf("failed to read community resolver task: %v", err)
                }</span>

                <span class="cov0" title="0">c := &amp;Reconciler{
                        crdClientSet:                  crdClient,
                        installerSetClient:            client.NewInstallerSetClient(tisClient, version, "addon", v1alpha1.KindTektonAddon, metrics),
                        operatorClientSet:             operatorclient.Get(ctx),
                        extension:                     generator(ctx),
                        pipelineInformer:              tektonPipelineinformer.Get(ctx),
                        triggerInformer:               tektonTriggerinformer.Get(ctx),
                        manifest:                      manifest,
                        operatorVersion:               version,
                        resolverTaskManifest:          resolverTaskManifest,
                        resolverStepActionManifest:    resolverStepActionManifest,
                        triggersResourcesManifest:     triggersResourcesManifest,
                        pipelineTemplateManifest:      pipelineTemplateManifest,
                        openShiftConsoleManifest:      openShiftConsoleManifest,
                        consoleCLIManifest:            consoleCLIManifest,
                        communityResolverTaskManifest: communityResolverTaskManifest,
                }
                impl := tektonAddonreconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for TektonAddon")

                if _, err := tektonAddoninformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonAddon informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonAddon{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file147" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import "go.uber.org/zap"

type Recorder struct {
}

func NewRecorder() (*Recorder, error) <span class="cov0" title="0">{
        return &amp;Recorder{}, nil
}</span>

func (m *Recorder) LogMetrics(status, version string, logger *zap.SugaredLogger) {<span class="cov0" title="0">
        // TODO
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"
        "os"
        "path/filepath"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        "k8s.io/apimachinery/pkg/api/errors"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (r *Reconciler) EnsureOpenShiftConsoleResources(ctx context.Context, ta *v1alpha1.TektonAddon) (error, bool) <span class="cov0" title="0">{
        filteredManifest := *r.openShiftConsoleManifest
        consoleYamlSampleExist, err := r.checkCRDExist(ctx, "consoleyamlsamples.console.openshift.io")
        if err != nil </span><span class="cov0" title="0">{
                return err, true
        }</span>
        <span class="cov0" title="0">if !consoleYamlSampleExist </span><span class="cov0" title="0">{
                filteredManifest = filteredManifest.Filter(mf.Not(mf.ByKind("ConsoleYAMLSample")))
        }</span>

        <span class="cov0" title="0">consoleQuickStartExist, err := r.checkCRDExist(ctx, "consolequickstarts.console.openshift.io")
        if err != nil </span><span class="cov0" title="0">{
                return err, true
        }</span>
        <span class="cov0" title="0">if !consoleQuickStartExist </span><span class="cov0" title="0">{
                filteredManifest = filteredManifest.Filter(mf.Not(mf.ByKind("ConsoleQuickStart")))
        }</span>

        <span class="cov0" title="0">consoleCLIDownloadExist, err := r.checkCRDExist(ctx, "consoleclidownloads.console.openshift.io")
        if err != nil </span><span class="cov0" title="0">{
                return err, true
        }</span>
        <span class="cov0" title="0">if !consoleCLIDownloadExist </span><span class="cov0" title="0">{
                filteredManifest = filteredManifest.Filter(mf.Not(mf.Any(mf.ByKind("Deployment"), mf.ByKind("Service"), mf.ByKind("Route"))))
        }</span>

        <span class="cov0" title="0">if len(filteredManifest.Resources()) == 0 </span><span class="cov0" title="0">{
                return nil, consoleCLIDownloadExist
        }</span>
        <span class="cov0" title="0">if err := r.installerSetClient.CustomSet(ctx, ta, OpenShiftConsoleInstallerSet, &amp;filteredManifest, filterAndTransformOCPResources(), nil); err != nil </span><span class="cov0" title="0">{
                return err, consoleCLIDownloadExist
        }</span>
        <span class="cov0" title="0">return nil, consoleCLIDownloadExist</span>
}

func (r *Reconciler) checkCRDExist(ctx context.Context, crdName string) (bool, error) <span class="cov0" title="0">{
        _, err := r.crdClientSet.ApiextensionsV1().CustomResourceDefinitions().Get(ctx, crdName, v1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return true, err</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func filterAndTransformOCPResources() client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                addon := comp.(*v1alpha1.TektonAddon)
                imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))
                images := common.ImageRegistryDomainOverride(imagesRaw)
                tfs := []mf.Transformer{
                        common.DeploymentImages(images),
                        common.AddConfiguration(addon.Spec.Config),
                }
                if err := transformers(ctx, manifest, addon, tfs...); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return manifest, nil</span>
        }
}

func getOptionalAddons(manifest *mf.Manifest) error <span class="cov0" title="0">{
        koDataDir := os.Getenv(common.KoEnvKey)

        optionalLocation := filepath.Join(koDataDir, "tekton-addon", "optional", "samples")
        if err := common.AppendManifest(manifest, optionalLocation); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">optionalLocation = filepath.Join(koDataDir, "tekton-addon", "optional", "quickstarts")
        return common.AppendManifest(manifest, optionalLocation)</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"
        "os"
        "path/filepath"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        tektonaddon "github.com/tektoncd/operator/pkg/reconciler/openshift/tektonaddon/pipelinetemplates"
)

func (r *Reconciler) EnsurePipelineTemplates(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        manifest := *r.pipelineTemplateManifest
        if enable == "true" </span><span class="cov0" title="0">{
                if err := r.installerSetClient.CustomSet(ctx, ta, PipelinesTemplateInstallerSet, &amp;manifest, filterAndTransformCommon(), nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := r.installerSetClient.CleanupCustomSet(ctx, PipelinesTemplateInstallerSet); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func addPipelineTemplates(manifest *mf.Manifest) error <span class="cov0" title="0">{
        koDataDir := os.Getenv(common.KoEnvKey)
        addonLocation := filepath.Join(koDataDir, "tekton-addon", "tekton-pipeline-template")
        return tektonaddon.GeneratePipelineTemplates(addonLocation, manifest)
}</span>
</pre>
		
		<pre class="file" id="file150" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "path"
        "runtime"

        mf "github.com/manifestival/manifestival"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

type generateDeployTask func(map[string]interface{}) map[string]interface{}
type taskGenerator interface {
        generate(pipeline unstructured.Unstructured, usingPipelineResource bool) (unstructured.Unstructured, error)
}

type pipeline struct {
        environment string
        nameSuffix  string
        generateDeployTask
}

type RuntimeSpec struct {
        Runtime string
        Version string
        Default string
}

const (
        LabelPipelineEnvironmentType = "pipeline.openshift.io/type"
        LabelPipelineStrategy        = "pipeline.openshift.io/strategy"
        LabelPipelineRuntime         = "pipeline.openshift.io/runtime"
        AnnotationPreserveNS         = "operator.tekton.dev/preserve-namespace"
)

var (
        Runtimes = map[string]RuntimeSpec{
                "s2i-dotnet": {Runtime: "dotnet", Version: "$(params.VERSION)", Default: "3.1-ubi8"},
                "s2i-go":     {Runtime: "golang", Version: "$(params.VERSION)", Default: "1.14.7-ubi8"},
                "s2i-java":   {Runtime: "java", Version: "$(params.VERSION)", Default: "openjdk-11-ubi8"},
                "s2i-nodejs": {Runtime: "nodejs", Version: "$(params.VERSION)", Default: "14-ubi8"},
                "s2i-perl":   {Runtime: "perl", Version: "$(params.VERSION)", Default: "5.30-ubi8"},
                "s2i-php":    {Runtime: "php", Version: "$(params.VERSION)", Default: "7.4-ubi8"},
                "s2i-python": {Runtime: "python", Version: "$(params.VERSION)", Default: "3.8-ubi8"},
                "s2i-ruby":   {Runtime: "ruby", Version: "$(params.VERSION)", Default: "2.7-ubi8"},
                "buildah":    {},
        }
)

func GeneratePipelineTemplates(templatePath string, manifest *mf.Manifest) error <span class="cov8" title="1">{
        var pipelines []unstructured.Unstructured
        usingPipelineResource := true

        workspacedTemplate, err := mf.NewManifest(path.Join(templatePath, "pipeline_using_workspace.yaml"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">workspacedTaskGenerators := []taskGenerator{
                &amp;pipeline{environment: "openshift", nameSuffix: "", generateDeployTask: openshiftDeployTask},
                &amp;pipeline{environment: "kubernetes", nameSuffix: "-deployment", generateDeployTask: kubernetesDeployTask},
        }

        // install knative tasks only where knative is available
        switch runtime.GOARCH </span>{
        case "amd64", "ppc64le", "s390x":<span class="cov8" title="1">
                workspacedTaskGenerators = append(workspacedTaskGenerators,
                        &amp;pipeline{environment: "knative", nameSuffix: "-knative", generateDeployTask: knativeDeployTask},
                )</span>
        }

        <span class="cov8" title="1">wps, err := generateBasePipeline(workspacedTemplate, workspacedTaskGenerators, !usingPipelineResource)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pipelines = append(pipelines, wps...)

        generatedPipelines, err := mf.ManifestFrom(mf.Slice(pipelines))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*manifest = manifest.Append(generatedPipelines)
        return nil</span>
}

func (p *pipeline) generate(pipeline unstructured.Unstructured, usingPipelineResource bool) (unstructured.Unstructured, error) <span class="cov8" title="1">{
        newTempRes := unstructured.Unstructured{}
        pipeline.DeepCopyInto(&amp;newTempRes)
        labels := newTempRes.GetLabels()
        labels[LabelPipelineEnvironmentType] = p.environment
        newTempRes.SetLabels(labels)
        updatedName := newTempRes.GetName()
        updatedName += p.nameSuffix
        taskDeploy, found, err := unstructured.NestedFieldNoCopy(newTempRes.Object, "spec", "tasks")
        if !found || err != nil </span><span class="cov0" title="0">{
                return unstructured.Unstructured{}, err
        }</span>

        <span class="cov8" title="1">var index = 2
        if usingPipelineResource </span><span class="cov0" title="0">{
                index = 1
                updatedName += "-pr"
        }</span>
        <span class="cov8" title="1">newTempRes.SetName(updatedName)

        p.generateDeployTask(taskDeploy.([]interface{})[index].(map[string]interface{}))
        return newTempRes, nil</span>
}

func openshiftDeployTask(deployTask map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        deployTask["taskRef"] = getTaskRef("openshift-client")
        deployTask["runAfter"] = []interface{}{"build"}
        deployTask["params"] = []interface{}{
                map[string]interface{}{"name": "SCRIPT", "value": "oc rollout status dc/$(params.APP_NAME)"},
        }
        return deployTask
}</span>

func kubernetesDeployTask(deployTask map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        deployTask["taskRef"] = getTaskRef("openshift-client")
        deployTask["runAfter"] = []interface{}{"build"}
        deployTask["params"] = []interface{}{
                map[string]interface{}{"name": "SCRIPT", "value": "oc rollout status deploy/$(params.APP_NAME)"},
        }
        return deployTask
}</span>

func knativeDeployTask(deployTask map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        deployTask["name"] = "kn-service-apply"
        deployTask["taskRef"] = getTaskRef("kn")
        deployTask["runAfter"] = []interface{}{"build"}
        deployTask["params"] = []interface{}{
                map[string]interface{}{"name": "ARGS", "value": []interface{}{"service", "apply", "$(params.APP_NAME)", "--image=$(params.IMAGE_NAME)"}},
        }
        return deployTask
}</span>

func generateBasePipeline(template mf.Manifest, taskGenerators []taskGenerator, usingPipelineResource bool) ([]unstructured.Unstructured, error) <span class="cov8" title="1">{
        var pipelines []unstructured.Unstructured

        for name, spec := range Runtimes </span><span class="cov8" title="1">{
                contextParamName := "CONTEXT"
                newTempRes := unstructured.Unstructured{}
                template.Resources()[0].DeepCopyInto(&amp;newTempRes)
                labels := map[string]string{}
                annotations := map[string]string{}
                if name == "buildah" </span><span class="cov8" title="1">{
                        labels[LabelPipelineStrategy] = "docker"
                }</span> else<span class="cov8" title="1"> {
                        labels[LabelPipelineRuntime] = spec.Runtime
                }</span>

                <span class="cov8" title="1">annotations[AnnotationPreserveNS] = "true"
                newTempRes.SetAnnotations(annotations)
                newTempRes.SetLabels(labels)
                newTempRes.SetName(name)
                pipelineParams, found, err := unstructured.NestedFieldNoCopy(newTempRes.Object, "spec", "params")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">tasks, found, err := unstructured.NestedFieldNoCopy(newTempRes.Object, "spec", "tasks")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">taskName := name
                var index = 1

                taskBuild := tasks.([]interface{})[index].(map[string]interface{})
                taskBuild["taskRef"] = getTaskRef(taskName)
                taskParams, found, err := unstructured.NestedFieldNoCopy(taskBuild, "params")
                if !found || err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">taskParams = append(taskParams.([]interface{}), map[string]interface{}{"name": contextParamName, "value": "$(params.PATH_CONTEXT)"})

                if spec.Version != "" </span><span class="cov8" title="1">{
                        taskParams = append(taskParams.([]interface{}), map[string]interface{}{"name": "VERSION", "value": spec.Version})
                        pipelineParams = append(pipelineParams.([]interface{}), map[string]interface{}{"name": "VERSION", "type": "string", "default": spec.Default})
                }</span>

                <span class="cov8" title="1">if err := unstructured.SetNestedField(newTempRes.Object, pipelineParams, "spec", "params"); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if err := unstructured.SetNestedField(taskBuild, taskParams, "params"); err != nil </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                //adding the deploy task
                <span class="cov8" title="1">for _, tg := range taskGenerators </span><span class="cov8" title="1">{
                        p, err := tg.generate(newTempRes, usingPipelineResource)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">pipelines = append(pipelines, p)</span>
                }
        }
        <span class="cov8" title="1">return pipelines, nil</span>
}

func getTaskRef(taskName string) map[string]interface{} <span class="cov8" title="1">{
        return map[string]interface{}{"params": []interface{}{
                map[string]interface{}{"name": "kind", "value": "task"},
                map[string]interface{}{"name": "name", "value": taskName},
                map[string]interface{}{"name": "namespace", "value": "openshift-pipelines"},
        },
                "resolver": "cluster",
        }
}</span>
</pre>
		
		<pre class="file" id="file151" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

func (r *Reconciler) EnsureResolverTask(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        manifest := *r.resolverTaskManifest
        return r.ensureCustomSet(ctx, enable, ResolverTaskInstallerSet, ta, manifest, r.getTransformer(ctx, KindTask, false))
}</span>

func (r *Reconciler) EnsureResolverStepAction(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        manifest := *r.resolverStepActionManifest
        return r.ensureCustomSet(ctx, enable, ResolverStepActionInstallerSet, ta, manifest, r.getTransformer(ctx, KindStepAction, false))
}</span>

func (r *Reconciler) getTransformer(ctx context.Context, kind string, isVersioned bool) []mf.Transformer <span class="cov0" title="0">{
        imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))
        addonImages := common.ImageRegistryDomainOverride(imagesRaw)
        var (
                mfTransformer, mfVersioned mf.Transformer
        )
        switch kind </span>{
        case KindTask:<span class="cov0" title="0">
                mfTransformer = common.TaskImages(ctx, addonImages)</span>
        case KindStepAction:<span class="cov0" title="0">
                mfTransformer = common.StepActionImages(ctx, addonImages)</span>
        }
        <span class="cov0" title="0">if isVersioned </span><span class="cov0" title="0">{
                mfVersioned = setVersionedNames(r.operatorVersion)
        }</span>
        <span class="cov0" title="0">return []mf.Transformer{
                injectLabel(labelProviderType, providerTypeRedHat, overwrite, kind),
                mfTransformer,
                mfVersioned,
        }</span>
}

func (r *Reconciler) ensureCustomSet(ctx context.Context, enable, installerSetName string, ta *v1alpha1.TektonAddon,
        manifest mf.Manifest, tfs []mf.Transformer) error <span class="cov0" title="0">{
        if enable == "true" </span><span class="cov0" title="0">{
                if err := r.installerSetClient.CustomSet(ctx, ta, installerSetName, &amp;manifest, filterAndTransformResolverTask(tfs), nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := r.installerSetClient.CleanupCustomSet(ctx, installerSetName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func filterAndTransformResolverTask(tfs []mf.Transformer) client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                addon := comp.(*v1alpha1.TektonAddon)
                if err := transformers(ctx, manifest, addon, tfs...); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file152" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
)

func (r *Reconciler) EnsureVersionedResolverTask(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        manifest := *r.resolverTaskManifest
        return r.ensureVersionedCustomSet(ctx, enable, VersionedResolverTaskInstallerSet, installerSetNameForResolverTasks, ta, manifest, r.getTransformer(ctx, KindTask, true))
}</span>

func (r *Reconciler) EnsureVersionedResolverStepAction(ctx context.Context, enable string, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        manifest := *r.resolverStepActionManifest
        return r.ensureVersionedCustomSet(ctx, enable, VersionedResolverStepActionInstallerSet, installerSetNameForResolverStepAction, ta, manifest, r.getTransformer(ctx, KindStepAction, true))
}</span>

func (r *Reconciler) ensureVersionedCustomSet(ctx context.Context, enable, installerSetType, installerSetName string, ta *v1alpha1.TektonAddon,
        manifest mf.Manifest, tfs []mf.Transformer) error <span class="cov0" title="0">{
        if enable == "true" </span><span class="cov0" title="0">{
                if err := r.installerSetClient.VersionedTaskSet(ctx, ta, &amp;manifest, filterAndTransformResolverTask(tfs),
                        installerSetType, installerSetName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := r.installerSetClient.CleanupCustomSet(ctx, installerSetType); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        informer "github.com/tektoncd/operator/pkg/client/informers/externalversions/operator/v1alpha1"
        tektonaddonreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonaddon"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        apiextensionsclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Reconciler implements controller.Reconciler for TektonAddon resources.
type Reconciler struct {
        // installer Set client to do CRUD operations for components
        installerSetClient *client.InstallerSetClient
        // crdClientSet allows us to talk to the k8s for core APIs
        crdClientSet                  *apiextensionsclient.Clientset
        manifest                      mf.Manifest
        operatorClientSet             clientset.Interface
        extension                     common.Extension
        pipelineInformer              informer.TektonPipelineInformer
        triggerInformer               informer.TektonTriggerInformer
        operatorVersion               string
        resolverTaskManifest          *mf.Manifest
        resolverStepActionManifest    *mf.Manifest
        triggersResourcesManifest     *mf.Manifest
        pipelineTemplateManifest      *mf.Manifest
        openShiftConsoleManifest      *mf.Manifest
        consoleCLIManifest            *mf.Manifest
        communityResolverTaskManifest *mf.Manifest
}

const (
        retain int = iota
        overwrite

        labelProviderType                     = "operator.tekton.dev/provider-type"
        providerTypeRedHat                    = "redhat"
        installerSetNameForResolverTasks      = "addon-versioned-resolvertasks"
        installerSetNameForResolverStepAction = "addon-versioned-resolverstepactions"
        providerTypeCommunity                 = "community"
)

// Check that our Reconciler implements controller.Reconciler
var _ tektonaddonreconciler.Interface = (*Reconciler)(nil)
var _ tektonaddonreconciler.Finalizer = (*Reconciler)(nil)

// FinalizeKind removes all resources after deletion of a TektonTriggers.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonAddon) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        if err := r.installerSetClient.CleanupAllCustomSet(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to cleanup custom set: %v", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, ta *v1alpha1.TektonAddon) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        ta.Status.InitializeConditions()
        ta.Status.SetVersion(r.operatorVersion)

        if ta.GetName() != v1alpha1.AddonResourceName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.AddonResourceName,
                        ta.GetName(),
                )
                logger.Error(msg)
                ta.Status.MarkNotReady(msg)
                return nil
        }</span>

        // Pass the object through defaulting
        <span class="cov0" title="0">ta.SetDefaults(ctx)

        // Make sure TektonPipeline &amp; TektonTrigger is installed before proceeding with
        // TektonAddons

        if _, err := common.PipelineReady(r.pipelineInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.PipelineNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        ta.Status.MarkDependencyInstalling("tekton-pipelines is still installing")
                        // wait for pipeline status to change
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                // (tektonpipeline.operator.tekton.dev instance not available yet)
                <span class="cov0" title="0">ta.Status.MarkDependencyMissing("tekton-pipelines does not exist")
                return err</span>
        }

        <span class="cov0" title="0">if _, err := common.TriggerReady(r.triggerInformer); err != nil </span><span class="cov0" title="0">{
                if err.Error() == common.TriggerNotReady || err == v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR </span><span class="cov0" title="0">{
                        ta.Status.MarkDependencyInstalling("tekton-triggers is still installing")
                        // wait for trigger status to change
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                // (tektontrigger.operator.tekton.dev instance not available yet)
                <span class="cov0" title="0">ta.Status.MarkDependencyMissing("tekton-triggers does not exist")
                return err</span>
        }

        <span class="cov0" title="0">ta.Status.MarkDependenciesInstalled()

        // validate the params
        ptVal, _ := findValue(ta.Spec.Params, v1alpha1.PipelineTemplatesParam)
        rtVal, _ := findValue(ta.Spec.Params, v1alpha1.ResolverTasks)
        rsaVal, _ := findValue(ta.Spec.Params, v1alpha1.ResolverStepActions)
        ctVal, _ := findValue(ta.Spec.Params, v1alpha1.CommunityResolverTasks)

        if ptVal == "true" &amp;&amp; rtVal == "false" </span><span class="cov0" title="0">{
                ta.Status.MarkNotReady("pipelineTemplates cannot be true if ResolverTask is false")
                return nil
        }</span>

        <span class="cov0" title="0">if err := r.installerSetClient.RemoveObsoleteSets(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := r.extension.PreReconcile(ctx, ta); err != nil </span><span class="cov0" title="0">{
                ta.Status.MarkPreReconcilerFailed(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">ta.Status.MarkPreReconcilerComplete()

        // this to check if all sets are in ready set
        ready := true
        var errorMsg string

        if err := r.EnsureResolverTask(ctx, rtVal, ta); err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("namespaced tasks not yet ready: %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">if err := r.EnsureVersionedResolverTask(ctx, rtVal, ta); err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("versioned namespaced tasks not yet ready:  %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">if err := r.EnsureResolverStepAction(ctx, rsaVal, ta); err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("namespaced stepactions not yet ready: %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">if err := r.EnsureVersionedResolverStepAction(ctx, rsaVal, ta); err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("versioned namespaced stepactions not yet ready:  %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">if err := r.EnsurePipelineTemplates(ctx, ptVal, ta); err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("pipelines templates not yet ready:  %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">if err := r.EnsureTriggersResources(ctx, ta); err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("triggers resources not yet ready:  %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">err, consoleCLIDownloadExist := r.EnsureOpenShiftConsoleResources(ctx, ta)
        if err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("openshift console resources not yet ready:  %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">if consoleCLIDownloadExist </span><span class="cov0" title="0">{
                if err := r.EnsureConsoleCLI(ctx, ta); err != nil </span><span class="cov0" title="0">{
                        ready = false
                        errorMsg = fmt.Sprintf("console cli not yet ready:  %v", err)
                        logger.Error(errorMsg)
                }</span>
        }

        <span class="cov0" title="0">if err := r.EnsureCommunityResolverTask(ctx, ctVal, ta); err != nil </span><span class="cov0" title="0">{
                ready = false
                errorMsg = fmt.Sprintf("community tasks not yet ready:  %v", err)
                logger.Error(errorMsg)
        }</span>

        <span class="cov0" title="0">if !ready </span><span class="cov0" title="0">{
                ta.Status.MarkInstallerSetNotReady(errorMsg)
                return nil
        }</span>

        <span class="cov0" title="0">ta.Status.MarkInstallerSetReady()

        if err := r.extension.PostReconcile(ctx, ta); err != nil </span><span class="cov0" title="0">{
                ta.Status.MarkPostReconcilerFailed(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">ta.Status.MarkPostReconcilerComplete()
        return nil</span>
}

func applyAddons(manifest *mf.Manifest, subpath string) error <span class="cov0" title="0">{
        koDataDir := os.Getenv(common.KoEnvKey)
        addonLocation := filepath.Join(koDataDir, "tekton-addon", "addons", subpath)
        addons, err := mf.ManifestFrom(mf.Recursive(addonLocation))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // install knative addons only where knative is available
        <span class="cov0" title="0">switch runtime.GOARCH </span>{
        case "amd64", "ppc64le", "s390x":<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                version := common.TargetVersion((*v1alpha1.TektonPipeline)(nil))
                version_formated := strings.Replace(version, ".", "-", -1)
                addons = addons.Filter(
                        mf.Not(mf.Any(
                                mf.ByName("kn"),
                                mf.ByName("kn-v"+version_formated),
                                mf.ByName("kn-apply"),
                                mf.ByName("kn-apply-v"+version_formated),
                        )))</span>
        }
        <span class="cov0" title="0">*manifest = manifest.Append(addons)
        return nil</span>
}

func findValue(params []v1alpha1.Param, name string) (string, bool) <span class="cov0" title="0">{
        for _, p := range params </span><span class="cov0" title="0">{
                if p.Name == name </span><span class="cov0" title="0">{
                        return p.Value, true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/openshift"
)

func transformers(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent, addnTfs ...mf.Transformer) error <span class="cov0" title="0">{
        instance := comp.(*v1alpha1.TektonAddon)

        imagesRaw := common.ToLowerCaseKeys(common.ImagesFromEnv(common.AddonsImagePrefix))
        addonImages := common.ImageRegistryDomainOverride(imagesRaw)

        addonTfs := []mf.Transformer{
                // using common.InjectOperandNameLabelPreserveExisting instead of common.InjectLabelOverwriteExisting
                // to highlight that TektonAddon is a basket of various operands(components)
                // note: using common.InjectLabelOverwriteExisting here  doesnot affect the ability to
                // use InjectOperandNameLabelPreserveExisting or InjectLabelOverwriteExisting again in the transformer chain
                // However, it is recomended to use InjectOperandNameLabelPreserveExisting here (in Addons) as we cannot be sure
                // about order of future addition of transformers in this reconciler or in sub functions which take care of various addons
                common.InjectOperandNameLabelPreserveExisting(openshift.OperandOpenShiftPipelinesAddons),
                common.TaskImages(ctx, addonImages),
        }
        addonTfs = append(addonTfs, addnTfs...)
        return common.Transform(ctx, manifest, instance, addonTfs...)
}</span>
</pre>
		
		<pre class="file" id="file155" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "fmt"
        "strings"

        mf "github.com/manifestival/manifestival"
        console "github.com/openshift/api/console/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
)

// injectLabel adds label key:value to a resource
// overwritePolicy (Retain/Overwrite) decides whehther to overwrite an already existing label
// []kinds specify the Kinds on which the label should be applied
// if len(kinds) = 0, label will be apllied to all/any resources irrespective of its Kind
func injectLabel(key, value string, overwritePolicy int, kinds ...string) mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                kind := u.GetKind()
                if len(kinds) != 0 &amp;&amp; !itemInSlice(kind, kinds) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">labels, found, err := unstructured.NestedStringMap(u.Object, "metadata", "labels")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not find labels set, %q", err)
                }</span>
                <span class="cov0" title="0">if overwritePolicy == retain &amp;&amp; found </span><span class="cov0" title="0">{
                        if _, ok := labels[key]; ok </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        labels = map[string]string{}
                }</span>
                <span class="cov0" title="0">labels[key] = value
                err = unstructured.SetNestedStringMap(u.Object, labels, "metadata", "labels")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error updating labels for %s:%s, %s", kind, u.GetName(), err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func itemInSlice(item string, items []string) bool <span class="cov0" title="0">{
        for _, v := range items </span><span class="cov0" title="0">{
                if v == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func getlinks(baseURL string) []console.CLIDownloadLink <span class="cov8" title="1">{
        platformURLs := []struct {
                platform string
                tknURL   string
        }{
                {"Linux x86_64", "tkn/tkn-linux-amd64.tar.gz"},
                {"Linux ARM 64", "tkn/tkn-linux-arm64.tar.gz"},
                {"IBM Power", "tkn/tkn-linux-ppc64le.tar.gz"},
                {"IBM Z", "tkn/tkn-linux-s390x.tar.gz"},
                {"Mac x86_64", "tkn/tkn-macos-amd64.tar.gz"},
                {"Mac ARM 64", "tkn/tkn-macos-arm64.tar.gz"},
                {"Windows x86_64", "tkn/tkn-windows-amd64.zip"},
                {"Windows ARM 64", "tkn/tkn-windows-arm64.zip"},
        }
        links := []console.CLIDownloadLink{}
        for _, platformURL := range platformURLs </span><span class="cov8" title="1">{
                links = append(links,
                        // tkn and tkn-pac, single archive
                        console.CLIDownloadLink{
                                Href: getURL(baseURL, platformURL.tknURL),
                                Text: fmt.Sprintf("Download tkn and tkn-pac for %s", platformURL.platform),
                        },
                )
        }</span>
        <span class="cov8" title="1">return links</span>
}

func getURL(baseURL string, path string) string <span class="cov8" title="1">{
        return fmt.Sprintf("https://%s/%s", baseURL, path)
}</span>

func replaceURLCCD(baseURL string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ConsoleCLIDownload" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">ccd := &amp;console.ConsoleCLIDownload{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, ccd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ccd.Spec.Links = getlinks(baseURL)
                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(ccd)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

func setVersionedNames(operatorVersion string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Task" &amp;&amp; u.GetKind() != "StepAction" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">name := u.GetName()
                formattedVersion := formattedVersionMajorMinorX(operatorVersion, versionedClusterTaskPatchChar)
                name = fmt.Sprintf("%s-%s", name, formattedVersion)
                u.SetName(name)
                return nil</span>
        }
}

func formattedVersionMajorMinorX(version, x string) string <span class="cov8" title="1">{
        ver := getPatchVersionTrimmed(version)
        ver = fmt.Sprintf("%s.%s", ver, x)
        return formattedVersionSnake(ver)
}</span>

func formattedVersionSnake(version string) string <span class="cov8" title="1">{
        ver := strings.TrimPrefix(version, "v")
        return strings.Replace(ver, ".", "-", -1)
}</span>

// To get the minor major version for label i.e. v1.6
func getPatchVersionTrimmed(version string) string <span class="cov8" title="1">{
        endIndex := strings.LastIndex(version, ".")
        if endIndex != -1 </span><span class="cov8" title="1">{
                version = version[:endIndex]
        }</span>
        <span class="cov8" title="1">return version</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonaddon

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
)

func (r *Reconciler) EnsureTriggersResources(ctx context.Context, ta *v1alpha1.TektonAddon) error <span class="cov0" title="0">{
        manifest := *r.triggersResourcesManifest
        if err := r.installerSetClient.CustomSet(ctx, ta, TriggersResourcesInstallerSet, &amp;manifest, filterAndTransformCommon(), nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func filterAndTransformCommon() client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                addon := comp.(*v1alpha1.TektonAddon)
                if err := transformers(ctx, manifest, addon); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return manifest, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file157" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonchain

import (
        "context"

        k8s_ctrl "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonchain"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonchain

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        occommon "github.com/tektoncd/operator/pkg/reconciler/openshift/common"
)

const (
        tektonChainsControllerName = "tekton-chains-controller"
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        ext := openshiftExtension{
                operatorClientSet: operatorclient.Get(ctx),
        }
        return ext
}</span>

type openshiftExtension struct {
        operatorClientSet versioned.Interface
}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return []mf.Transformer{
                occommon.RemoveRunAsUser(),
                occommon.RemoveRunAsGroup(),
                occommon.RemoveRunAsUserForStatefulSet(tektonChainsControllerName),
                occommon.RemoveRunAsGroupForStatefulSet(tektonChainsControllerName),
                occommon.ApplyCABundlesToDeployment,
                occommon.ApplyCABundlesForStatefulSet(tektonChainsControllerName),
        }
}</span>
func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func createInstallerSet(ctx context.Context, oc versioned.Interface, tc *v1alpha1.TektonConfig, releaseVersion string) error <span class="cov8" title="1">{

        // add pipelines-scc
        pipelinescc := &amp;mf.Manifest{}
        pipelinesSCCLocation := filepath.Join(os.Getenv(common.KoEnvKey), "tekton-pipeline", "00-prereconcile")
        if err := common.AppendManifest(pipelinescc, pipelinesSCCLocation); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">is := makeInstallerSet(tc, releaseVersion)
        is.Spec.Manifests = pipelinescc.Resources()

        createdIs, err := oc.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, is, metav1.CreateOptions{})
        if err != nil &amp;&amp; !errors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(tc.Status.TektonInstallerSet) == 0 </span><span class="cov8" title="1">{
                tc.Status.TektonInstallerSet = map[string]string{}
        }</span>

        // Update the status of tektonConfig with created installerSet name
        <span class="cov8" title="1">tc.Status.TektonInstallerSet[rbacInstallerSetType] = createdIs.Name
        return nil</span>
}

func makeInstallerSet(tc *v1alpha1.TektonConfig, releaseVersion string) *v1alpha1.TektonInstallerSet <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())
        return &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: rbacInstallerSetNamePrefix,
                        Labels: map[string]string{
                                v1alpha1.CreatedByKey:      createdByValue,
                                v1alpha1.InstallerSetType:  rbacInstallerSetType,
                                v1alpha1.ReleaseVersionKey: releaseVersion,
                        },
                        Annotations: map[string]string{
                                v1alpha1.ReleaseVersionKey:  releaseVersion,
                                v1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
        }
}</span>

func deleteInstallerSet(ctx context.Context, oc versioned.Interface, tc *v1alpha1.TektonConfig, component string) error <span class="cov0" title="0">{
        labelSelector, err := common.LabelSelector(rbacInstallerSetSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = oc.OperatorV1alpha1().TektonInstallerSets().DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // clear the name of installer set from TektonConfig status
        <span class="cov0" title="0">delete(tc.Status.TektonInstallerSet, component)

        return nil</span>
}

// checkIfInstallerSetExist checks if installer set exists for a component and return true/false based on it
// and if installer set which already exist is of older version then it deletes and return false to create a new
// installer set
func checkIfInstallerSetExist(ctx context.Context, oc versioned.Interface, relVersion string,
        tc *v1alpha1.TektonConfig) (*v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{

        labelSelector, err := common.LabelSelector(rbacInstallerSetSelector)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retreive labelSelector with selector %v: %w", rbacInstallerSetSelector, err)
        }</span>
        <span class="cov8" title="1">existingInstallerSet, err := tektoninstallerset.CurrentInstallerSetName(ctx, oc, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to retreive existing InstallerSet with selector %v: %w", labelSelector, err)
        }</span>
        <span class="cov8" title="1">if existingInstallerSet == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // if already created then check which version it is
        <span class="cov8" title="1">ctIs, err := oc.OperatorV1alpha1().TektonInstallerSets().
                Get(ctx, existingInstallerSet, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if version, ok := ctIs.Annotations[v1alpha1.ReleaseVersionKey]; ok &amp;&amp; version == relVersion </span><span class="cov8" title="1">{
                // if installer set already exist and release version is same
                // then ignore and move on
                return ctIs, nil
        }</span>

        // release version doesn't exist or is different from expected
        // deleted existing InstallerSet and create a new one

        <span class="cov0" title="0">err = oc.OperatorV1alpha1().TektonInstallerSets().
                Delete(ctx, existingInstallerSet, metav1.DeleteOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "fmt"
        "os"
        "strings"
        "sync"

        "github.com/go-logr/zapr"
        mf "github.com/manifestival/manifestival"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
)

const (
        // manifests console plugin yaml directory location
        consolePluginReconcileYamlDirectory = "static/tekton-config/00-console-plugin"
        // installerSet label value
        consolePluginReconcileLabelCreatedByValue = "tekton-config-console-plugin-manifests"
        // pipelines console plugin environment variable key
        PipelinesConsolePluginImageEnvironmentKey = "IMAGE_PIPELINES_CONSOLE_PLUGIN"
        // pipelines console plugin container name, used to replace the image from the environment
        PipelinesConsolePluginContainerName = "pipelines-console-plugin"
)

var (
        // label filter to set/get installerSet specific to this reconciler
        consolePluginReconcileInstallerSetLabel = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.InstallerSetType: v1alpha1.ConfigResourceName,
                        v1alpha1.CreatedByKey:     consolePluginReconcileLabelCreatedByValue,
                },
        }
)

type consolePluginReconciler struct {
        logger                      *zap.SugaredLogger
        operatorClientSet           versioned.Interface
        syncOnce                    sync.Once
        resourcesYamlDirectory      string
        operatorVersion             string
        pipelinesConsolePluginImage string
        manifest                    mf.Manifest
}

// reconcile steps
// 1. get console plugin manifests from kodata
// 2. verify the existing installerSet hash value
// 3. if there is a mismatch or the installerSet not available, (re)create it
func (cpr *consolePluginReconciler) reconcile(ctx context.Context, tektonConfigCR *v1alpha1.TektonConfig) error <span class="cov8" title="1">{

        cpr.updateOnce(ctx)

        // verify he availability of the installerSet
        labelSelector, err := common.LabelSelector(consolePluginReconcileInstallerSetLabel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">installerSetList, err := cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().List(ctx, metav1.ListOptions{LabelSelector: labelSelector})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">doCreateInstallerSet := false
        var deployedInstallerSet v1alpha1.TektonInstallerSet

        if len(installerSetList.Items) &gt; 1 </span><span class="cov8" title="1">{
                for _, installerSet := range installerSetList.Items </span><span class="cov8" title="1">{
                        err = cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, installerSet.GetName(), metav1.DeleteOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">doCreateInstallerSet = true</span>
        } else<span class="cov8" title="1"> if len(installerSetList.Items) == 1 </span><span class="cov8" title="1">{
                deployedInstallerSet = installerSetList.Items[0]
        }</span> else<span class="cov8" title="1"> {
                doCreateInstallerSet = true
        }</span>

        // clone the manifest
        <span class="cov8" title="1">manifest := cpr.manifest.Append()
        // apply transformations
        if err := cpr.transform(ctx, &amp;manifest, tektonConfigCR); err != nil </span><span class="cov0" title="0">{
                tektonConfigCR.Status.MarkNotReady(fmt.Sprintf("transformation failed: %s", err.Error()))
                return err
        }</span>

        // get expected hash value of the manifests
        <span class="cov8" title="1">expectedHash, err := cpr.getHash(manifest.Resources())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !doCreateInstallerSet </span><span class="cov8" title="1">{
                // compute hash from the deployed installerSet
                deployedHash, err := cpr.getHash(deployedInstallerSet.Spec.Manifests)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">releaseVersion := deployedInstallerSet.GetLabels()[v1alpha1.ReleaseVersionKey]
                // delete the existing installerSet,
                // if hash mismatch or version mismatch
                if expectedHash != deployedHash || cpr.operatorVersion != releaseVersion </span><span class="cov8" title="1">{
                        if err := cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, deployedInstallerSet.GetName(), metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">doCreateInstallerSet = true</span>
                }
        }

        <span class="cov8" title="1">if doCreateInstallerSet </span><span class="cov8" title="1">{
                return cpr.createInstallerSet(ctx, &amp;manifest, tektonConfigCR)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (cpr *consolePluginReconciler) updateOnce(ctx context.Context) <span class="cov8" title="1">{
        // reads all yaml files from the directory, it is an expensive process to access disk on each reconcile call.
        // hence fetch only once at startup, it helps not to degrade the performance of the reconcile loop
        // also it not necessary to read the files frequently, as the files are shipped along the container and never change
        cpr.syncOnce.Do(func() </span><span class="cov8" title="1">{
                // fetch manifest from disk
                manifest, err := mf.NewManifest(cpr.resourcesYamlDirectory, mf.UseLogger(zapr.NewLogger(cpr.logger.Desugar())))
                if err != nil </span><span class="cov0" title="0">{
                        cpr.logger.Fatal("error getting manifests",
                                "manifestsLocation", cpr.resourcesYamlDirectory,
                                err,
                        )
                }</span>
                <span class="cov8" title="1">cpr.manifest = manifest

                // update pipelines console image details
                consoleImage, found := os.LookupEnv(PipelinesConsolePluginImageEnvironmentKey)
                if found </span><span class="cov8" title="1">{
                        cpr.pipelinesConsolePluginImage = consoleImage
                        cpr.logger.Debugw("pipelines console plugin image found from environment",
                                "image", consoleImage,
                                "environmentVariable", PipelinesConsolePluginImageEnvironmentKey,
                        )
                }</span> else<span class="cov8" title="1"> {
                        cpr.logger.Warnw("pipelines console plugin image not found from environment, continuing with the default image from the manifest",
                                "environmentVariable", PipelinesConsolePluginImageEnvironmentKey,
                        )
                }</span>
        })
}

func (cpr *consolePluginReconciler) createInstallerSet(ctx context.Context, manifest *mf.Manifest, tektonConfigCR *v1alpha1.TektonConfig) error <span class="cov8" title="1">{
        // setup installerSet
        ownerRef := *metav1.NewControllerRef(tektonConfigCR, tektonConfigCR.GetGroupVersionKind())
        installerSet := &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: "tekton-config-console-plugin-manifests-",
                        Labels:       consolePluginReconcileInstallerSetLabel.MatchLabels,
                        Annotations: map[string]string{
                                v1alpha1.TargetNamespaceKey: tektonConfigCR.Spec.TargetNamespace,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }
        // update operator version
        installerSet.Labels[v1alpha1.ReleaseVersionKey] = cpr.operatorVersion

        // creates installerSet in the cluster
        _, err := cpr.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Create(ctx, installerSet, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                cpr.logger.Error("error on creating installerset", err)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// apply transformations
func (cpr *consolePluginReconciler) transform(ctx context.Context, manifest *mf.Manifest, tektonConfigCR *v1alpha1.TektonConfig) error <span class="cov8" title="1">{
        // load required transformers
        transformers := []mf.Transformer{
                // updates "metadata.namespace" to targetNamespace
                common.ReplaceNamespace(tektonConfigCR.Spec.TargetNamespace),
                cpr.transformerConsolePlugin(tektonConfigCR.Spec.TargetNamespace),
                common.AddConfiguration(tektonConfigCR.Spec.Config),
        }

        if cpr.pipelinesConsolePluginImage != "" </span><span class="cov8" title="1">{
                // updates deployments container image
                transformers = append(transformers, common.DeploymentImages(map[string]string{
                        // on the transformer, in the container name, the '-' replaced with '_'
                        strings.ReplaceAll(PipelinesConsolePluginContainerName, "-", "_"): cpr.pipelinesConsolePluginImage,
                }))
        }</span>

        // perform transformation
        <span class="cov8" title="1">return common.Transform(ctx, manifest, tektonConfigCR, transformers...)</span>
}

func (cpr *consolePluginReconciler) getHash(resources []unstructured.Unstructured) (string, error) <span class="cov8" title="1">{
        return hash.Compute(resources)
}</span>

func (cpr *consolePluginReconciler) transformerConsolePlugin(targetNamespace string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "ConsolePlugin" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">return unstructured.SetNestedField(u.Object, targetNamespace, "spec", "backend", "service", "namespace")</span>
        }
}
</pre>
		
		<pre class="file" id="file161" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        openshiftpipelinesascodeinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/openshiftpipelinesascode"
        tektonAddoninformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonaddon"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        ctrl := tektonconfig.NewExtensibleController(OpenShiftExtension)(ctx, cmw)
        if _, err := tektonAddoninformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterController(&amp;v1alpha1.TektonConfig{}),
                Handler:    controller.HandleAll(ctrl.EnqueueControllerOf),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register TektonAddon informer event handler: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := openshiftpipelinesascodeinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterController(&amp;v1alpha1.TektonConfig{}),
                Handler:    controller.HandleAll(ctrl.EnqueueControllerOf),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register OpenShiftPipelinesAsCode informer event handler: %w", err)
        }</span>
        <span class="cov0" title="0">return ctrl</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        mf "github.com/manifestival/manifestival"
        security "github.com/openshift/client-go/security/clientset/versioned"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        pkgCommon "github.com/tektoncd/operator/pkg/common"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/openshift/tektonconfig/extension"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        nsV1 "k8s.io/client-go/informers/core/v1"
        rbacV1 "k8s.io/client-go/informers/rbac/v1"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        namespaceinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/namespace"
        rbacInformer "knative.dev/pkg/client/injection/kube/informers/rbac/v1/clusterrolebinding"
        "knative.dev/pkg/logging"
)

const (
        versionKey = "VERSION"
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        operatorVer, err := common.OperatorVersion(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal(err)
        }</span>

        <span class="cov0" title="0">ext := openshiftExtension{
                operatorClientSet: operatorclient.Get(ctx),
                kubeClientSet:     kubeclient.Get(ctx),
                rbacInformer:      rbacInformer.Get(ctx),
                nsInformer:        namespaceinformer.Get(ctx),
                securityClientSet: pkgCommon.GetSecurityClient(ctx),
                operatorVersion:   operatorVer,
        }

        ext.consolePluginReconciler = &amp;consolePluginReconciler{
                resourcesYamlDirectory: filepath.Join(common.ComponentBaseDir(), consolePluginReconcileYamlDirectory),
                logger:                 logger,
                operatorClientSet:      ext.operatorClientSet,
                operatorVersion:        operatorVer,
        }

        return ext</span>
}

type openshiftExtension struct {
        operatorClientSet       versioned.Interface
        kubeClientSet           kubernetes.Interface
        rbacInformer            rbacV1.ClusterRoleBindingInformer
        nsInformer              nsV1.NamespaceInformer
        consolePluginReconciler *consolePluginReconciler

        // OpenShift clientsets are a bit... special, we need to get each
        // clientset separately
        securityClientSet security.Interface

        operatorVersion string
}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return []mf.Transformer{
                // update namespace in pruner RBAC
                common.ReplaceNamespaceInServiceAccount(comp.GetSpec().GetTargetNamespace()),
                common.ReplaceNamespaceInClusterRoleBinding(comp.GetSpec().GetTargetNamespace()),
        }
}</span>

func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        config := tc.(*v1alpha1.TektonConfig)
        r := rbac{
                kubeClientSet:     oe.kubeClientSet,
                operatorClientSet: oe.operatorClientSet,
                securityClientSet: oe.securityClientSet,
                rbacInformer:      oe.rbacInformer,
                nsInformer:        oe.nsInformer,
                version:           os.Getenv(versionKey),
                tektonConfig:      config,
        }

        // set openshift specific defaults
        r.setDefault()

        // below code helps to retain state of pre-existing SA at the time of upgrade
        if existingSAWithOwnerRef(r.tektonConfig) </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)
                logger.Infof("Found pre-existing ServiceAccount. Changing owner reference during upgrade.")

                if err := changeOwnerRefOfPreExistingSA(ctx, r.kubeClientSet, *config); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to change owner reference for pre-existing SA: %v", err)
                        return err
                }</span>

                // Get current labels to retain any existing labels
                <span class="cov0" title="0">tcLabels := config.GetLabels()
                if tcLabels == nil </span><span class="cov0" title="0">{
                        tcLabels = map[string]string{}
                }</span>

                // Add or update the serviceAccountCreationLabel without removing other labels
                <span class="cov0" title="0">tcLabels[serviceAccountCreationLabel] = "true"

                // Prepare the patch to update only the labels, keeping the existing ones
                jsonLabels, err := common.SerializeLabelsToJSON(tcLabels)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error(err)
                        return err
                }</span>
                <span class="cov0" title="0">patchData := []byte(fmt.Sprintf(`{"metadata":{"labels":%s}}`, jsonLabels))

                // Apply the patch to the TektonConfig
                if _, err := oe.operatorClientSet.OperatorV1alpha1().TektonConfigs().Patch(ctx, config.Name, types.MergePatchType, patchData, metav1.PatchOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to patch TektonConfig with new label: %v", err)
                        return err
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully patched TektonConfig with serviceAccountCreationLabel set to true")</span>
        }

        <span class="cov0" title="0">for _, v := range config.Spec.Params </span><span class="cov0" title="0">{
                // check for param name and if its matches to createRbacResource
                // then disable auto creation of RBAC resources by deleting installerSet
                if v.Name == rbacParamName &amp;&amp; v.Value == "false" </span><span class="cov0" title="0">{
                        if err := deleteInstallerSet(ctx, r.operatorClientSet, r.tektonConfig, componentNameRBAC); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // remove openshift-pipelines.tekton.dev/namespace-reconcile-version label from namespaces while deleting RBAC resources.
                        <span class="cov0" title="0">if err := r.cleanUp(ctx); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        // TODO: Remove this after v0.55.0 release, by following a depreciation notice
        // --------------------
        <span class="cov0" title="0">if err := r.cleanUpRBACNameChange(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // --------------------

        <span class="cov0" title="0">return r.createResources(ctx)</span>
}

func (oe openshiftExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        configInstance := comp.(*v1alpha1.TektonConfig)

        if configInstance.Spec.Profile == v1alpha1.ProfileAll </span><span class="cov0" title="0">{
                if _, err := extension.EnsureTektonAddonExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonAddons(), configInstance, oe.operatorVersion); err != nil </span><span class="cov0" title="0">{
                        configInstance.Status.MarkComponentNotReady(fmt.Sprintf("TektonAddon: %s", err.Error()))
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
        }
        <span class="cov0" title="0">if configInstance.Spec.Profile == v1alpha1.ProfileLite || configInstance.Spec.Profile == v1alpha1.ProfileBasic </span><span class="cov0" title="0">{
                if err := extension.EnsureTektonAddonCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonAddons()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">pac := configInstance.Spec.Platforms.OpenShift.PipelinesAsCode
        if pac != nil &amp;&amp; *pac.Enable </span><span class="cov0" title="0">{
                if _, err := extension.EnsureOpenShiftPipelinesAsCodeExists(ctx, oe.operatorClientSet.OperatorV1alpha1().OpenShiftPipelinesAsCodes(), configInstance, oe.operatorVersion); err != nil </span><span class="cov0" title="0">{
                        configInstance.Status.MarkComponentNotReady(fmt.Sprintf("OpenShiftPipelinesAsCode: %s", err.Error()))
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
        } else<span class="cov0" title="0"> {
                if err := extension.EnsureOpenShiftPipelinesAsCodeCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().OpenShiftPipelinesAsCodes()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // execute console plugin reconciler
        <span class="cov0" title="0">return oe.consolePluginReconciler.reconcile(ctx, configInstance)</span>
}

func (oe openshiftExtension) Finalize(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        configInstance := comp.(*v1alpha1.TektonConfig)
        if configInstance.Spec.Profile == v1alpha1.ProfileAll </span><span class="cov0" title="0">{
                if err := extension.EnsureTektonAddonCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().TektonAddons()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">if configInstance.Spec.Platforms.OpenShift.PipelinesAsCode != nil &amp;&amp; *configInstance.Spec.Platforms.OpenShift.PipelinesAsCode.Enable </span><span class="cov0" title="0">{
                if err := extension.EnsureOpenShiftPipelinesAsCodeCRNotExists(ctx, oe.operatorClientSet.OperatorV1alpha1().OpenShiftPipelinesAsCodes()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">r := rbac{
                kubeClientSet: oe.kubeClientSet,
                version:       os.Getenv(versionKey),
        }
        return r.cleanUp(ctx)</span>
}

// configOwnerRef returns owner reference pointing to passed instance
func configOwnerRef(tc v1alpha1.TektonInstallerSet) metav1.OwnerReference <span class="cov8" title="1">{
        return *metav1.NewControllerRef(&amp;tc, tc.GetGroupVersionKind())
}</span>

// tektonConfigOwnerRef returns owner reference of tektonConfig
func tektonConfigOwnerRef(tc v1alpha1.TektonConfig) metav1.OwnerReference <span class="cov8" title="1">{
        return *metav1.NewControllerRef(&amp;tc, tc.GetGroupVersionKind())
}</span>

func changeOwnerRefOfPreExistingSA(ctx context.Context, kc kubernetes.Interface, tc v1alpha1.TektonConfig) error <span class="cov0" title="0">{
        allSAs, err := kc.CoreV1().ServiceAccounts("").List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, sa := range allSAs.Items </span><span class="cov0" title="0">{
                if sa.Name == "pipeline" &amp;&amp; !nsRegex.MatchString(sa.Namespace) </span><span class="cov0" title="0">{
                        // set tektonconfig ownerRef
                        tcOwnerRef := tektonConfigOwnerRef(tc)
                        sa.SetOwnerReferences([]metav1.OwnerReference{tcOwnerRef})
                        if _, err := kc.CoreV1().ServiceAccounts(sa.Namespace).Update(ctx, &amp;sa, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// existingSAWithOwnerRef checks if openshift-pipelines.tekton.dev/sa-created label is present on tektonconfig
// we add this label from pipelines 1.8, and do not add tektoninstaller set as owner of serviceaccount created
// if label not present it means SA was created earlier and we need to remove ownerRef before we do the update
// this helps us to keep pre-existing SA as it is.
func existingSAWithOwnerRef(tc *v1alpha1.TektonConfig) bool <span class="cov0" title="0">{
        labels := tc.GetLabels()
        if labels == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return labels[serviceAccountCreationLabel] != "true"</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package extension

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

func EnsureTektonAddonExists(ctx context.Context, clients op.TektonAddonInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.TektonAddon, error) <span class="cov8" title="1">{
        taCR, err := GetAddon(ctx, clients, v1alpha1.AddonResourceName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if _, err = createAddon(ctx, clients, config, operatorVersion); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">taCR, err = updateAddon(ctx, taCR, config, clients, operatorVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ok, err := isTektonAddonReady(taCR, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return taCR, err</span>
}

func createAddon(ctx context.Context, clients op.TektonAddonInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.TektonAddon, error) <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())

        taCR := &amp;v1alpha1.TektonAddon{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.AddonResourceName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                        Labels: map[string]string{
                                v1alpha1.ReleaseVersionKey: operatorVersion,
                        },
                },
                Spec: v1alpha1.TektonAddonSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Addon: v1alpha1.Addon{
                                Params: config.Spec.Addon.Params,
                        },
                        Config: config.Spec.Config,
                },
        }
        if _, err := clients.Create(ctx, taCR, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return taCR, nil</span>
}

func GetAddon(ctx context.Context, clients op.TektonAddonInterface, name string) (*v1alpha1.TektonAddon, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

func updateAddon(ctx context.Context, taCR *v1alpha1.TektonAddon, config *v1alpha1.TektonConfig,
        clients op.TektonAddonInterface, operatorVersion string,
) (*v1alpha1.TektonAddon, error) <span class="cov8" title="1">{
        // if the addon spec is changed then update the instance
        updated := false

        // initialize labels(map) object
        if taCR.ObjectMeta.Labels == nil </span><span class="cov0" title="0">{
                taCR.ObjectMeta.Labels = map[string]string{}
        }</span>

        <span class="cov8" title="1">if config.Spec.TargetNamespace != taCR.Spec.TargetNamespace </span><span class="cov8" title="1">{
                taCR.Spec.TargetNamespace = config.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(config.Spec.Addon, taCR.Spec.Addon) </span><span class="cov0" title="0">{
                taCR.Spec.Addon = config.Spec.Addon
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(taCR.Spec.Config, config.Spec.Config) </span><span class="cov0" title="0">{
                taCR.Spec.Config = config.Spec.Config
                updated = true
        }</span>

        <span class="cov8" title="1">if taCR.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
                taCR.ObjectMeta.OwnerReferences = []metav1.OwnerReference{ownerRef}
                updated = true
        }</span>

        <span class="cov8" title="1">oldLabels, oldHasLabels := taCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        if !oldHasLabels || (oldLabels != operatorVersion) </span><span class="cov8" title="1">{
                taCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = operatorVersion
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, taCR, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">return taCR, nil</span>
}

// isTektonAddonReady will check the status conditions of the TektonAddon and return true if the TektonAddon is ready.
func isTektonAddonReady(s *v1alpha1.TektonAddon, err error) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), nil</span>
}

func EnsureTektonAddonCRNotExists(ctx context.Context, clients op.TektonAddonInterface) error <span class="cov8" title="1">{
        if _, err := GetAddon(ctx, clients, v1alpha1.AddonResourceName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // TektonAddon CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.AddonResourceName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // TektonAddon CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TektonAddon %q failed to delete: %v", v1alpha1.AddonResourceName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package extension

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

func EnsureOpenShiftPipelinesAsCodeExists(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.OpenShiftPipelinesAsCode, error) <span class="cov8" title="1">{
        opacCR, err := GetPAC(ctx, clients, v1alpha1.OpenShiftPipelinesAsCodeName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if _, err = createOPAC(ctx, clients, config, operatorVersion); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">opacCR, err = updateOPAC(ctx, opacCR, config, clients, operatorVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ok, err := isOPACReady(opacCR, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return opacCR, err</span>
}

func createOPAC(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface, config *v1alpha1.TektonConfig, operatorVersion string) (*v1alpha1.OpenShiftPipelinesAsCode, error) <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())

        opacCR := &amp;v1alpha1.OpenShiftPipelinesAsCode{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.OpenShiftPipelinesAsCodeName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                        Labels: map[string]string{
                                v1alpha1.ReleaseVersionKey: operatorVersion,
                        },
                },
                Spec: v1alpha1.OpenShiftPipelinesAsCodeSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Config: config.Spec.Config,
                        PACSettings: v1alpha1.PACSettings{
                                Settings:                 config.Spec.Platforms.OpenShift.PipelinesAsCode.Settings,
                                AdditionalPACControllers: config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.AdditionalPACControllers,
                        },
                },
        }
        if _, err := clients.Create(ctx, opacCR, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return opacCR, nil</span>
}

func GetPAC(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface, name string) (*v1alpha1.OpenShiftPipelinesAsCode, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

func updateOPAC(ctx context.Context, opacCR *v1alpha1.OpenShiftPipelinesAsCode, config *v1alpha1.TektonConfig,
        clients op.OpenShiftPipelinesAsCodeInterface, operatorVersion string,
) (*v1alpha1.OpenShiftPipelinesAsCode, error) <span class="cov8" title="1">{
        // if the pac spec is changed then update the instance
        updated := false

        // initialize labels(map) object
        if opacCR.ObjectMeta.Labels == nil </span><span class="cov0" title="0">{
                opacCR.ObjectMeta.Labels = map[string]string{}
        }</span>

        <span class="cov8" title="1">if config.Spec.TargetNamespace != opacCR.Spec.TargetNamespace </span><span class="cov8" title="1">{
                opacCR.Spec.TargetNamespace = config.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(opacCR.Spec.Config, config.Spec.Config) </span><span class="cov0" title="0">{
                opacCR.Spec.Config = config.Spec.Config
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(opacCR.Spec.Settings, config.Spec.Platforms.OpenShift.PipelinesAsCode.Settings) </span><span class="cov0" title="0">{
                opacCR.Spec.PACSettings.Settings = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Settings
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(opacCR.Spec.PACSettings.Options, config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options) </span><span class="cov0" title="0">{
                opacCR.Spec.PACSettings.Options = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(opacCR.Spec.PACSettings.AdditionalPACControllers, config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.AdditionalPACControllers) </span><span class="cov0" title="0">{
                opacCR.Spec.PACSettings.AdditionalPACControllers = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.AdditionalPACControllers
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(opacCR.Spec.PACSettings.Options, config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options) </span><span class="cov0" title="0">{
                opacCR.Spec.PACSettings.Options = config.Spec.Platforms.OpenShift.PipelinesAsCode.PACSettings.Options
                updated = true
        }</span>

        <span class="cov8" title="1">if opacCR.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
                opacCR.ObjectMeta.OwnerReferences = []metav1.OwnerReference{ownerRef}
                updated = true
        }</span>

        <span class="cov8" title="1">oldLabels, oldHasLabels := opacCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        if !oldHasLabels || (oldLabels != operatorVersion) </span><span class="cov0" title="0">{
                opacCR.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = operatorVersion
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, opacCR, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">return opacCR, nil</span>
}

// isOPACReady will check the status conditions of the OpenShiftPipelinesAsCode and return true if the OpenShiftPipelinesAsCode is ready.
func isOPACReady(s *v1alpha1.OpenShiftPipelinesAsCode, err error) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), err</span>
}

func EnsureOpenShiftPipelinesAsCodeCRNotExists(ctx context.Context, clients op.OpenShiftPipelinesAsCodeInterface) error <span class="cov8" title="1">{
        if _, err := GetPAC(ctx, clients, v1alpha1.OpenShiftPipelinesAsCodeName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // OpenShiftPipelinesAsCode CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.OpenShiftPipelinesAsCodeName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // OpenShiftPipelinesAsCode CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("OpenShiftPipelinesAsCode %q failed to delete: %v", v1alpha1.OpenShiftPipelinesAsCodeName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "encoding/json"
        "fmt"
        "math"
        "regexp"
        "time"

        security "github.com/openshift/client-go/security/clientset/versioned"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        "github.com/tektoncd/operator/pkg/common"
        reconcilerCommon "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/openshift"

        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/selection"
        "k8s.io/apimachinery/pkg/types"
        nsV1 "k8s.io/client-go/informers/core/v1"
        rbacV1 "k8s.io/client-go/informers/rbac/v1"
        "k8s.io/client-go/kubernetes"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "knative.dev/pkg/logging"
)

const (
        pipelinesSCCRole        = "pipelines-scc-role"
        pipelinesSCCClusterRole = "pipelines-scc-clusterrole"
        pipelinesSCCRoleBinding = "pipelines-scc-rolebinding"
        pipelineSA              = "pipeline"
        PipelineRoleBinding     = "openshift-pipelines-edit"

        // TODO: Remove this after v0.55.0 release, by following a depreciation notice
        // --------------------
        pipelineRoleBindingOld  = "edit"
        rbacInstallerSetNameOld = "rbac-resources"
        // --------------------
        serviceCABundleConfigMap    = "config-service-cabundle"
        trustedCABundleConfigMap    = "config-trusted-cabundle"
        clusterInterceptors         = "openshift-pipelines-clusterinterceptors"
        namespaceVersionLabel       = "openshift-pipelines.tekton.dev/namespace-reconcile-version"
        namespaceTrustedConfigLabel = "openshift-pipelines.tekton.dev/namespace-trusted-configmaps-version"
        createdByValue              = "RBAC"
        componentNameRBAC           = "rhosp-rbac"
        rbacInstallerSetType        = "rhosp-rbac"
        rbacInstallerSetNamePrefix  = "rhosp-rbac-"
        rbacParamName               = "createRbacResource"
        trustedCABundleParamName    = "createCABundleConfigMaps"
        legacyPipelineRbacParamName = "legacyPipelineRbac"
        legacyPipelineRbac          = "true"
        serviceAccountCreationLabel = "openshift-pipelines.tekton.dev/sa-created"
)

var (
        rbacInstallerSetSelector = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     createdByValue,
                        v1alpha1.InstallerSetType: componentNameRBAC,
                },
        }
)

// Namespace Regex to ignore the namespace for creating rbac resources.
var nsRegex = regexp.MustCompile(reconcilerCommon.NamespaceIgnorePattern)

type rbac struct {
        kubeClientSet     kubernetes.Interface
        operatorClientSet clientset.Interface
        securityClientSet security.Interface
        rbacInformer      rbacV1.ClusterRoleBindingInformer
        nsInformer        nsV1.NamespaceInformer
        ownerRef          metav1.OwnerReference
        version           string
        tektonConfig      *v1alpha1.TektonConfig
}

type NamespaceServiceAccount struct {
        ServiceAccount *corev1.ServiceAccount
        Namespace      corev1.Namespace
}

// NamespacesToReconcile holds the namespaces that need reconciliation for different features
type NamespacesToReconcile struct {
        RBACNamespaces []corev1.Namespace
        CANamespaces   []corev1.Namespace
}

func (r *rbac) cleanUp(ctx context.Context) error <span class="cov8" title="1">{

        // fetch the list of all namespaces which have label
        // `openshift-pipelines.tekton.dev/namespace-reconcile-version: &lt;release-version&gt;`
        labelSelector := fmt.Sprintf("%s = %s", namespaceVersionLabel, r.version)
        namespaces, err := r.kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{
                LabelSelector: labelSelector,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to retreive namespaces with labelSeleclector %s: %v", labelSelector, err)
        }</span>
        // loop on namespaces and remove label if exist
        <span class="cov8" title="1">for _, n := range namespaces.Items </span><span class="cov0" title="0">{
                labels := n.GetLabels()
                delete(labels, namespaceVersionLabel)
                n.SetLabels(labels)
                if _, err := r.kubeClientSet.CoreV1().Namespaces().Update(ctx, &amp;n, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update namespace %s: %v", n.Name, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *rbac) EnsureRBACInstallerSet(ctx context.Context) (*v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        if err := r.removeObsoleteRBACInstallerSet(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rbacISet, err := checkIfInstallerSetExist(ctx, r.operatorClientSet, r.version, r.tektonConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if rbacISet != nil </span><span class="cov8" title="1">{
                return rbacISet, nil
        }</span>
        // A new installer needs to be created
        // either because of operator version upgrade or installerSet gone missing;
        // therefore all relevant namespaces need to be reconciled for RBAC resources.
        // Hence, remove the necessary labels to ensure that the namespaces will be 'not skipped'
        // RBAC reconcile logic
        <span class="cov8" title="1">err = r.cleanUp(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">err = createInstallerSet(ctx, r.operatorClientSet, r.tektonConfig, r.version)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
}

func (r *rbac) setDefault() <span class="cov8" title="1">{
        var rbacParamFound, legacyParamFound, caBundleParamFound bool
        var createRbacResourceValue string

        for i, v := range r.tektonConfig.Spec.Params </span><span class="cov8" title="1">{
                if v.Name == rbacParamName </span><span class="cov8" title="1">{
                        rbacParamFound = true
                        createRbacResourceValue = v.Value
                        if v.Value != "false" &amp;&amp; v.Value != "true" </span><span class="cov8" title="1">{
                                r.tektonConfig.Spec.Params[i].Value = "true"
                        }</span>
                }
                <span class="cov8" title="1">if v.Name == legacyPipelineRbacParamName </span><span class="cov8" title="1">{
                        legacyParamFound = true
                        if v.Value != "false" &amp;&amp; v.Value != "true" </span><span class="cov8" title="1">{
                                r.tektonConfig.Spec.Params[i].Value = "true"
                        }</span>
                }
                <span class="cov8" title="1">if v.Name == trustedCABundleParamName </span><span class="cov8" title="1">{
                        caBundleParamFound = true
                        if v.Value != "false" &amp;&amp; v.Value != "true" </span><span class="cov8" title="1">{
                                r.tektonConfig.Spec.Params[i].Value = "true"
                        }</span>
                }
        }
        <span class="cov8" title="1">if !rbacParamFound </span><span class="cov8" title="1">{
                r.tektonConfig.Spec.Params = append(r.tektonConfig.Spec.Params, v1alpha1.Param{
                        Name:  rbacParamName,
                        Value: "true",
                })
        }</span>
        <span class="cov8" title="1">if !legacyParamFound </span><span class="cov8" title="1">{
                r.tektonConfig.Spec.Params = append(r.tektonConfig.Spec.Params, v1alpha1.Param{
                        Name:  legacyPipelineRbacParamName,
                        Value: "true",
                })
        }</span>

        // TODO: Remove this upgrade workaround after version 1.22.
        // This logic is only needed to preserve backward compatibility for users upgrading to 1.21
        // who had createRbacResource=false and no createCABundleConfigMaps param set.
        <span class="cov8" title="1">if !caBundleParamFound </span><span class="cov8" title="1">{
                defaultVal := "true"
                if rbacParamFound &amp;&amp; createRbacResourceValue == "false" </span><span class="cov8" title="1">{
                        defaultVal = "false"
                }</span>
                <span class="cov8" title="1">r.tektonConfig.Spec.Params = append(r.tektonConfig.Spec.Params,
                        v1alpha1.Param{Name: trustedCABundleParamName, Value: defaultVal},
                )</span>
        }
}

// ensurePreRequisites validates the resources before creation
func (r *rbac) ensurePreRequisites(ctx context.Context) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        rbacISet, err := r.EnsureRBACInstallerSet(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">r.ownerRef = configOwnerRef(*rbacISet)

        // make sure default SCC is in place
        defaultSCC := r.tektonConfig.Spec.Platforms.OpenShift.SCC.Default
        if defaultSCC == "" </span><span class="cov0" title="0">{
                // Should not really happen due to defaulting, but okay...
                return fmt.Errorf("tektonConfig.Spec.Platforms.OpenShift.SCC.Default cannot be empty")
        }</span>
        <span class="cov8" title="1">logger.Infof("default SCC set to: %s", defaultSCC)
        if err := common.VerifySCCExists(ctx, defaultSCC, r.securityClientSet); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to verify scc %s exists, %w", defaultSCC, err)
        }</span>

        <span class="cov8" title="1">prioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, r.securityClientSet)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // validate maxAllowed SCC
        <span class="cov8" title="1">maxAllowedSCC := r.tektonConfig.Spec.Platforms.OpenShift.SCC.MaxAllowed
        if maxAllowedSCC != "" </span><span class="cov0" title="0">{
                if err := common.VerifySCCExists(ctx, maxAllowedSCC, r.securityClientSet); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to verify scc %s exists, %w", maxAllowedSCC, err)
                }</span>

                <span class="cov0" title="0">isPriority, err := common.SCCAMoreRestrictiveThanB(prioritizedSCCList, defaultSCC, maxAllowedSCC)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infof("Is maxAllowed SCC: %s less restrictive than default SCC: %s? %t", maxAllowedSCC, defaultSCC, isPriority)
                if !isPriority </span><span class="cov0" title="0">{
                        return fmt.Errorf("maxAllowed SCC: %s must be less restrictive than the default SCC: %s", maxAllowedSCC, defaultSCC)
                }</span>
                <span class="cov0" title="0">logger.Infof("maxAllowed SCC set to: %s", maxAllowedSCC)</span>
        } else<span class="cov8" title="1"> {
                logger.Info("No maxAllowed SCC set in TektonConfig")
        }</span>

        // Maintaining a separate cluster role for the scc declaration.
        // to assist us in managing this the scc association in a
        // granular way.
        // We need to make sure the pipelines-scc-clusterrole is up-to-date
        // irrespective of the fact that we get reconcilable namespaces or not.
        <span class="cov8" title="1">if err := r.ensurePipelinesSCClusterRole(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *rbac) getNamespacesToBeReconciled(ctx context.Context) (*NamespacesToReconcile, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // fetch the list of all namespaces
        allNamespaces, err := r.kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := &amp;NamespacesToReconcile{
                RBACNamespaces: []corev1.Namespace{},
                CANamespaces:   []corev1.Namespace{},
        }

        for _, ns := range allNamespaces.Items </span><span class="cov8" title="1">{
                // ignore namespaces with name passing regex `^(openshift|kube)-`
                if ignore := nsRegex.MatchString(ns.GetName()); ignore </span><span class="cov0" title="0">{
                        logger.Debugf("Ignoring system namespace: %s", ns.GetName())
                        continue</span>
                }

                // ignore namespaces with DeletionTimestamp set
                <span class="cov8" title="1">if ns.GetObjectMeta().GetDeletionTimestamp() != nil </span><span class="cov0" title="0">{
                        logger.Debugf("Ignoring namespace being deleted: %s", ns.GetName())
                        continue</span>
                }

                // Check if namespace needs RBAC reconciliation
                <span class="cov8" title="1">needsRBAC := false
                // We want to monitor namespaces with the SCC annotation set
                if ns.Annotations[openshift.NamespaceSCCAnnotation] != "" </span><span class="cov0" title="0">{
                        needsRBAC = true
                }</span>
                // Then we want to accept namespaces that have not been reconciled yet
                <span class="cov8" title="1">if ns.Labels[namespaceVersionLabel] != r.version </span><span class="cov8" title="1">{
                        needsRBAC = true
                }</span> else<span class="cov0" title="0"> {
                        // Now we're left with namespaces that have already been reconciled.
                        // We must make sure that the default SCC is in force via the ClusterRole.
                        sccRoleBinding, err := r.kubeClientSet.RbacV1().RoleBindings(ns.Name).Get(ctx, pipelinesSCCRoleBinding, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                // Reconcile a namespace again with missing RoleBinding
                                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                        logger.Debugf("could not find roleBinding %s in namespace %s", pipelinesSCCRoleBinding, ns.Name)
                                        needsRBAC = true
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("error fetching rolebinding %s from namespace %s: %w", pipelinesSCCRoleBinding, ns.Name, err)
                                }</span>
                        } else<span class="cov0" title="0"> if sccRoleBinding.RoleRef.Kind != "ClusterRole" </span><span class="cov0" title="0">{
                                logger.Infof("RoleBinding %s in namespace: %s should have CluterRole with default SCC, will reconcile again...", pipelinesSCCRoleBinding, ns.Name)
                                needsRBAC = true
                        }</span>
                }

                <span class="cov8" title="1">if needsRBAC </span><span class="cov8" title="1">{
                        logger.Debugf("Adding namespace for RBAC reconciliation: %s", ns.GetName())
                        result.RBACNamespaces = append(result.RBACNamespaces, ns)
                }</span>

                // Check if namespace needs CA bundle reconciliation
                <span class="cov8" title="1">if ns.Labels[namespaceTrustedConfigLabel] != r.version </span><span class="cov8" title="1">{
                        logger.Debugf("Adding namespace for CA bundle reconciliation: %s", ns.GetName())
                        result.CANamespaces = append(result.CANamespaces, ns)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (r *rbac) getSCCRoleInNamespace(ns *corev1.Namespace) *rbacv1.RoleRef <span class="cov8" title="1">{
        nsAnnotations := ns.GetAnnotations()
        nsSCC := nsAnnotations[openshift.NamespaceSCCAnnotation]
        // If SCC is requested by namespace annotation, then we need a Role
        if nsSCC != "" </span><span class="cov0" title="0">{
                return &amp;rbacv1.RoleRef{
                        APIGroup: rbacv1.GroupName,
                        Kind:     "Role",
                        Name:     pipelinesSCCRole,
                }
        }</span>
        // If no SCC annotation is present in the namespace, we will use the
        // pipelines-scc-clusterrole
        <span class="cov8" title="1">return &amp;rbacv1.RoleRef{
                APIGroup: rbacv1.GroupName,
                Kind:     "ClusterRole",
                Name:     pipelinesSCCClusterRole,
        }</span>
}

func (r *rbac) handleSCCInNamespace(ctx context.Context, ns *corev1.Namespace) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        nsName := ns.GetName()
        nsAnnotations := ns.GetAnnotations()
        nsSCC := nsAnnotations[openshift.NamespaceSCCAnnotation]

        // No SCC is requested in the namespace
        if nsSCC == "" </span><span class="cov8" title="1">{
                // If we don't have a namespace annotation, then we don't need a
                // Role in this namespace as we will bind to the ClusterRole.
                // This happens in cases when the SCC annotation was removed from
                // the namespace.
                _, err := r.kubeClientSet.RbacV1().Roles(nsName).Get(ctx, pipelinesSCCRole, metav1.GetOptions{})
                if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>

                // If `err == nil` AND role was found, it means that role exists
                <span class="cov8" title="1">if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Infof("Found leftover role: %s in namespace: %s, deleting...", pipelinesSCCRole, nsName)
                        err := r.kubeClientSet.RbacV1().Roles(nsName).Delete(ctx, pipelinesSCCRole, metav1.DeleteOptions{})
                        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                // Don't proceed further if no SCC requested by namespace
                <span class="cov8" title="1">return nil</span>
        }

        // We're here, so the namespace has actually requested an SCC
        <span class="cov0" title="0">logger.Infof("Namespace: %s has requested SCC: %s", nsName, nsSCC)

        // Make sure that SCC exists on cluster
        if err := common.VerifySCCExists(ctx, nsSCC, r.securityClientSet); err != nil </span><span class="cov0" title="0">{
                logger.Error(err)

                // Create an event in the namespace if the SCC does not exist
                eventErr := r.createSCCFailureEventInNamespace(ctx, nsName, nsSCC)
                if eventErr != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to create SCC not found event in namepsace: %s", nsName)
                        return eventErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Make sure SCC requested in the namespace has a lower or equal priority
        // than the SCC mentioned in maxAllowed
        <span class="cov0" title="0">maxAllowedSCC := r.tektonConfig.Spec.Platforms.OpenShift.SCC.MaxAllowed
        if maxAllowedSCC != "" </span><span class="cov0" title="0">{
                prioritizedSCCList, err := common.GetSCCRestrictiveList(ctx, r.securityClientSet)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">isPriority, err := common.SCCAMoreRestrictiveThanB(prioritizedSCCList, nsSCC, maxAllowedSCC)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infof("Is maxAllowed SCC: %s less restrictive than namespace SCC: %s? %t", maxAllowedSCC, nsSCC, isPriority)
                if !isPriority </span><span class="cov0" title="0">{
                        return fmt.Errorf("namespace: %s has requested SCC: %s, but it is less restrictive than the 'maxAllowed' SCC: %s", nsName, nsSCC, maxAllowedSCC)
                }</span>
        }

        // Make sure a Role exists with the SCC attached in the namespace
        <span class="cov0" title="0">if err := r.ensureSCCRoleInNamespace(ctx, nsName, nsSCC); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processRBAC encapsulates the logic for processing RBAC in a single namespace.
func (r *rbac) processRBAC(ctx context.Context, ns corev1.Namespace) (*NamespaceServiceAccount, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Infof("Processing RBAC for namespace %s", ns.GetName())

        // Create or update ServiceAccount
        sa, err := r.ensureSA(ctx, &amp;ns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ensure ServiceAccount in namespace %s: %v", ns.Name, err)
        }</span>

        <span class="cov8" title="1">if sa == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ServiceAccount is nil for namespace %s", ns.Name)
        }</span>

        // Handle SCC in namespace
        <span class="cov8" title="1">if err := r.handleSCCInNamespace(ctx, &amp;ns); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to handle SCC in namespace %s: %v", ns.Name, err)
        }</span>

        // Get and apply role reference
        <span class="cov8" title="1">roleRef := r.getSCCRoleInNamespace(&amp;ns)
        if roleRef != nil </span><span class="cov8" title="1">{
                if err := r.ensurePipelinesSCCRoleBinding(ctx, sa, roleRef); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to ensure pipelines SCC role binding in namespace %s: %v", ns.Name, err)
                }</span>
        }

        // Ensure role bindings
        <span class="cov8" title="1">if err := r.ensureRoleBindings(ctx, sa); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to ensure role bindings in namespace %s: %v", ns.Name, err)
        }</span>

        <span class="cov8" title="1">return &amp;NamespaceServiceAccount{
                ServiceAccount: sa,
                Namespace:      ns,
        }, nil</span>
}

// patch namespace with reconciled label
func (r *rbac) patchNamespaceLabel(ctx context.Context, ns corev1.Namespace) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        logger.Infof("add label namespace-reconcile-version to mark namespace '%s' as reconciled", ns.Name)

        // Prepare a patch to add/update just one label without overwriting others
        patch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "labels": map[string]interface{}{
                                namespaceVersionLabel: r.version,
                        },
                },
        }

        patchPayload, err := json.Marshal(patch)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to marshal patch payload: %v", err)
                return fmt.Errorf("failed to marshal label patch for namespace %s: %w", ns.Name, err)
        }</span>

        // Use PATCH to update just the target label
        <span class="cov8" title="1">if _, err := r.kubeClientSet.CoreV1().Namespaces().Patch(ctx, ns.Name, types.StrategicMergePatchType, patchPayload, metav1.PatchOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to patch namespace %s: %v", ns.Name, err)
                return fmt.Errorf("failed to patch namespace %s: %w", ns.Name, err)
        }</span>

        <span class="cov8" title="1">logger.Infof("namespace '%s' successfully reconciled with label %q=%q", ns.Name, namespaceVersionLabel, r.version)
        return nil</span>
}

// createResources handles the reconciliation of RBAC resources and CA bundle configmaps
// across namespaces. It processes each feature independently based on their respective
// configuration flags and only reconciles namespaces that need updates.
func (r *rbac) createResources(ctx context.Context) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // Step 1: Check feature flags
        createCABundles := true
        createRBACResource := true

        // Check feature flags
        for _, v := range r.tektonConfig.Spec.Params </span><span class="cov8" title="1">{
                if v.Name == trustedCABundleParamName &amp;&amp; v.Value == "false" </span><span class="cov8" title="1">{
                        createCABundles = false
                        logger.Info("CA bundle creation is disabled")
                }</span>
                <span class="cov8" title="1">if v.Name == rbacParamName &amp;&amp; v.Value == "false" </span><span class="cov8" title="1">{
                        createRBACResource = false
                        logger.Info("RBAC resource creation is disabled")
                }</span>
        }

        // If both features are disabled, nothing to do
        <span class="cov8" title="1">if !createCABundles &amp;&amp; !createRBACResource </span><span class="cov8" title="1">{
                logger.Info("Both CA bundle and RBAC creation are disabled, nothing to do")
                return nil
        }</span>

        // Step 2: Ensure prerequisites (only if RBAC is enabled)
        <span class="cov8" title="1">if createRBACResource </span><span class="cov8" title="1">{
                if err := r.ensurePreRequisites(ctx); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("error validating resources: %v", err)
                        return err
                }</span>
        }

        // Step 3: Get namespaces to be reconciled for both RBAC and CA bundles
        <span class="cov8" title="1">namespacesToReconcile, err := r.getNamespacesToBeReconciled(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        // Early return if no namespaces need reconciliation for either feature
        <span class="cov8" title="1">if len(namespacesToReconcile.RBACNamespaces) == 0 &amp;&amp; len(namespacesToReconcile.CANamespaces) == 0 </span><span class="cov0" title="0">{
                logger.Info("No namespaces need reconciliation for either RBAC or CA bundles")
                return nil
        }</span>

        // Step 4: Handle RBAC if enabled
        <span class="cov8" title="1">if createRBACResource </span><span class="cov8" title="1">{
                if len(namespacesToReconcile.RBACNamespaces) == 0 </span><span class="cov0" title="0">{
                        logger.Info("No namespaces need RBAC reconciliation")
                }</span> else<span class="cov8" title="1"> {
                        logger.Debugf("Found %d namespaces to be reconciled for RBAC", len(namespacesToReconcile.RBACNamespaces))

                        // Remove and update namespaces from Cluster Interceptors
                        if err := r.removeAndUpdateNSFromCI(ctx); err != nil </span><span class="cov0" title="0">{
                                logger.Error(err)
                                return err
                        }</span>

                        <span class="cov8" title="1">var namespacesToUpdate []NamespaceServiceAccount
                        // Process each namespace for RBAC
                        for _, ns := range namespacesToReconcile.RBACNamespaces </span><span class="cov8" title="1">{
                                logger.Infof("Processing namespace %s for RBAC", ns.Name)
                                nsSA, err := r.processRBAC(ctx, ns)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("failed processing namespace %s: %v", ns.Name, err)
                                        continue</span>
                                }
                                <span class="cov8" title="1">namespacesToUpdate = append(namespacesToUpdate, *nsSA)</span>
                        }

                        // Bulk update ClusterRoleBinding
                        <span class="cov8" title="1">if len(namespacesToUpdate) &gt; 0 </span><span class="cov8" title="1">{
                                if err := r.handleClusterRoleBinding(ctx, namespacesToUpdate); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("failed to ensure clusterrolebinding update: %v", err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">logger.Info("Successfully updated cluster role bindings")

                                // Patch namespace labels for RBAC
                                for _, nsSA := range namespacesToUpdate </span><span class="cov8" title="1">{
                                        logger.Infof("Reconciling namespace %s for RBAC", nsSA.Namespace.Name)
                                        if err := r.patchNamespaceLabel(ctx, nsSA.Namespace); err != nil </span><span class="cov0" title="0">{
                                                logger.Errorf("failed reconciling namespace %s: %v", nsSA.Namespace.Name, err)
                                        }</span>
                                }
                        }
                }
        }

        // Step 5: Handle CA bundles if enabled
        <span class="cov8" title="1">if createCABundles </span><span class="cov8" title="1">{
                if len(namespacesToReconcile.CANamespaces) == 0 </span><span class="cov0" title="0">{
                        logger.Info("No namespaces need CA bundle reconciliation")
                }</span> else<span class="cov8" title="1"> {
                        logger.Debugf("Found %d namespaces to be reconciled for CA bundles", len(namespacesToReconcile.CANamespaces))

                        for _, ns := range namespacesToReconcile.CANamespaces </span><span class="cov8" title="1">{
                                logger.Infof("Processing namespace %s for CA bundles", ns.Name)
                                if err := r.ensureCABundlesInNamespace(ctx, &amp;ns); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("failed to ensure CA bundles in namespace %s: %v", ns.Name, err)
                                        continue</span>
                                }
                                // Patch namespace with trusted configmaps label
                                <span class="cov8" title="1">if err := r.patchNamespaceTrustedConfigLabel(ctx, ns); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("failed to patch trusted config label for namespace %s: %v", ns.Name, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (r *rbac) createSCCFailureEventInNamespace(ctx context.Context, namespace string, scc string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        failureEvent := corev1.Event{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName:    "pipelines-scc-failure-",
                        Namespace:       namespace,
                        OwnerReferences: []metav1.OwnerReference{r.ownerRef},
                },
                EventTime:           metav1.NewMicroTime(time.Now()),
                Reason:              "RequestedSCCNotFound",
                Type:                "Warning",
                Action:              "SCCNotUpdated",
                Message:             fmt.Sprintf("SCC '%s' requested in annotation '%s' not found, SCC not updated in the namespace", scc, openshift.NamespaceSCCAnnotation),
                ReportingController: "openshift-pipelines-operator",
                ReportingInstance:   r.ownerRef.Name,
                InvolvedObject: corev1.ObjectReference{
                        Kind:       "Namespace",
                        Name:       namespace,
                        APIVersion: "v1",
                        Namespace:  namespace,
                },
        }

        logger.Infof("Creating SCC failure event in namespace: %s", namespace)
        _, err := r.kubeClientSet.CoreV1().Events(namespace).Create(ctx, &amp;failureEvent, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create failure event in namespace %s, %w", namespace, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *rbac) ensureCABundles(ctx context.Context, ns *corev1.Namespace) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        cfgInterface := r.kubeClientSet.CoreV1().ConfigMaps(ns.Name)

        // Ensure trusted CA bundle
        logger.Infof("finding configmap: %s/%s", ns.Name, trustedCABundleConfigMap)
        caBundleCM, getErr := cfgInterface.Get(ctx, trustedCABundleConfigMap, metav1.GetOptions{})
        if getErr != nil &amp;&amp; !errors.IsNotFound(getErr) </span><span class="cov0" title="0">{
                return getErr
        }</span>

        <span class="cov8" title="1">if getErr != nil &amp;&amp; errors.IsNotFound(getErr) </span><span class="cov8" title="1">{
                logger.Infof("creating configmap %s in %s namespace", trustedCABundleConfigMap, ns.Name)
                var err error
                if caBundleCM, err = createCABundleConfigMaps(ctx, cfgInterface, trustedCABundleConfigMap, ns.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // If config map already exist then remove owner ref
        <span class="cov8" title="1">if getErr == nil </span><span class="cov0" title="0">{
                caBundleCM.SetOwnerReferences(nil)
                if _, err := cfgInterface.Update(ctx, caBundleCM, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Ensure service CA bundle
        <span class="cov8" title="1">logger.Infof("finding configmap: %s/%s", ns.Name, serviceCABundleConfigMap)
        serviceCABundleCM, getErr := cfgInterface.Get(ctx, serviceCABundleConfigMap, metav1.GetOptions{})
        if getErr != nil &amp;&amp; !errors.IsNotFound(getErr) </span><span class="cov0" title="0">{
                return getErr
        }</span>

        <span class="cov8" title="1">if getErr != nil &amp;&amp; errors.IsNotFound(getErr) </span><span class="cov8" title="1">{
                logger.Infof("creating configmap %s in %s namespace", serviceCABundleConfigMap, ns.Name)
                var err error
                if serviceCABundleCM, err = createServiceCABundleConfigMap(ctx, cfgInterface, serviceCABundleConfigMap, ns.Name); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // If config map already exist then remove owner ref
        <span class="cov8" title="1">if getErr == nil </span><span class="cov0" title="0">{
                serviceCABundleCM.SetOwnerReferences(nil)
                if _, err := cfgInterface.Update(ctx, serviceCABundleCM, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func createCABundleConfigMaps(ctx context.Context, cfgInterface v1.ConfigMapInterface,
        name, ns string) (*corev1.ConfigMap, error) <span class="cov8" title="1">{
        c := &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: ns,
                        Labels: map[string]string{
                                "app.kubernetes.io/part-of": "tekton-pipelines",
                                // user-provided and system CA certificates
                                "config.openshift.io/inject-trusted-cabundle": "true",
                        },
                        // No OwnerReferences
                },
        }

        cm, err := cfgInterface.Create(ctx, c, metav1.CreateOptions{})
        if err != nil &amp;&amp; !errors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return cm, nil</span>
}

func createServiceCABundleConfigMap(ctx context.Context, cfgInterface v1.ConfigMapInterface,
        name, ns string) (*corev1.ConfigMap, error) <span class="cov8" title="1">{
        c := &amp;corev1.ConfigMap{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: ns,
                        Labels: map[string]string{
                                "app.kubernetes.io/part-of": "tekton-pipelines",
                        },
                        Annotations: map[string]string{
                                // service serving certificates (required to talk to the internal registry)
                                "service.beta.openshift.io/inject-cabundle": "true",
                        },
                        // No OwnerReferences
                },
        }

        cm, err := cfgInterface.Create(ctx, c, metav1.CreateOptions{})
        if err != nil &amp;&amp; !errors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return cm, nil</span>
}

func (r *rbac) ensureSA(ctx context.Context, ns *corev1.Namespace) (*corev1.ServiceAccount, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Infof("finding sa: %s/%s", ns.Name, "pipeline")
        saInterface := r.kubeClientSet.CoreV1().ServiceAccounts(ns.Name)

        sa, err := saInterface.Get(ctx, pipelineSA, metav1.GetOptions{})
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err != nil &amp;&amp; errors.IsNotFound(err) </span><span class="cov8" title="1">{
                logger.Info("creating sa ", pipelineSA, " ns", ns.Name)
                return createSA(ctx, saInterface, ns.Name, *r.tektonConfig)
        }</span>

        // set tektonConfig ownerRef
        <span class="cov0" title="0">tcOwnerRef := tektonConfigOwnerRef(*r.tektonConfig)
        sa.SetOwnerReferences([]metav1.OwnerReference{tcOwnerRef})

        return saInterface.Update(ctx, sa, metav1.UpdateOptions{})</span>
}

func createSA(ctx context.Context, saInterface v1.ServiceAccountInterface, ns string, tc v1alpha1.TektonConfig) (*corev1.ServiceAccount, error) <span class="cov8" title="1">{
        tcOwnerRef := tektonConfigOwnerRef(tc)
        sa := &amp;corev1.ServiceAccount{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            pipelineSA,
                        Namespace:       ns,
                        OwnerReferences: []metav1.OwnerReference{tcOwnerRef},
                },
        }

        sa, err := saInterface.Create(ctx, sa, metav1.CreateOptions{})
        if err != nil &amp;&amp; !errors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Initialize labels map if it doesn't exist
        <span class="cov8" title="1">if tc.Labels == nil </span><span class="cov8" title="1">{
                tc.Labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">tc.Labels[serviceAccountCreationLabel] = "true"
        return sa, nil</span>
}

// ensureSCCRoleInNamespace ensures that the SCC role exists in the namespace
func (r *rbac) ensureSCCRoleInNamespace(ctx context.Context, namespace string, scc string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        logger.Infof("finding role: %s in namespace %s", pipelinesSCCRole, namespace)

        sccRole := &amp;rbacv1.Role{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            pipelinesSCCRole,
                        Namespace:       namespace,
                        OwnerReferences: []metav1.OwnerReference{r.ownerRef},
                },
                Rules: []rbacv1.PolicyRule{
                        {
                                APIGroups: []string{
                                        "security.openshift.io",
                                },
                                ResourceNames: []string{
                                        scc,
                                },
                                Resources: []string{
                                        "securitycontextconstraints",
                                },
                                Verbs: []string{
                                        "use",
                                },
                        },
                },
        }

        rbacClient := r.kubeClientSet.RbacV1()
        if _, err := rbacClient.Roles(namespace).Get(ctx, pipelinesSCCRole, metav1.GetOptions{}); err != nil </span><span class="cov0" title="0">{
                // If the role does not exist, then create it and exit
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        _, err = rbacClient.Roles(namespace).Create(ctx, sccRole, metav1.CreateOptions{})
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // Update the role if it already exists
        <span class="cov0" title="0">_, err := rbacClient.Roles(namespace).Update(ctx, sccRole, metav1.UpdateOptions{})
        return err</span>
}

// ensurePipelinesSCClusterRole ensures that `pipelines-scc` ClusterRole exists
// in the cluster. The SCC used in the ClusterRole is read from SCC config
// in TektonConfig (`pipelines-scc` by default)
func (r *rbac) ensurePipelinesSCClusterRole(ctx context.Context) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        logger.Info("finding cluster role:", pipelinesSCCClusterRole)

        clusterRole := &amp;rbacv1.ClusterRole{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            pipelinesSCCClusterRole,
                        OwnerReferences: []metav1.OwnerReference{r.ownerRef},
                },
                Rules: []rbacv1.PolicyRule{
                        {
                                APIGroups: []string{
                                        "security.openshift.io",
                                },
                                ResourceNames: []string{
                                        r.tektonConfig.Spec.Platforms.OpenShift.SCC.Default,
                                },
                                Resources: []string{
                                        "securitycontextconstraints",
                                },
                                Verbs: []string{
                                        "use",
                                },
                        },
                },
        }

        rbacClient := r.kubeClientSet.RbacV1()
        if _, err := rbacClient.ClusterRoles().Get(ctx, pipelinesSCCClusterRole, metav1.GetOptions{}); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        _, err = rbacClient.ClusterRoles().Create(ctx, clusterRole, metav1.CreateOptions{})
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov0" title="0">_, err := rbacClient.ClusterRoles().Update(ctx, clusterRole, metav1.UpdateOptions{})
        return err</span>
}

func (r *rbac) ensurePipelinesSCCRoleBinding(ctx context.Context, sa *corev1.ServiceAccount, roleRef *rbacv1.RoleRef) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        rbacClient := r.kubeClientSet.RbacV1()

        roleKind := roleRef.Kind
        roleName := roleRef.Name
        if roleRef.Kind == "Role" </span><span class="cov0" title="0">{
                logger.Infof("finding %s: %s", roleKind, roleName)
                if _, err := rbacClient.Roles(sa.Namespace).Get(ctx, roleName, metav1.GetOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "finding %s failed: %s", roleKind, roleName)
                        return err
                }</span>
        } else<span class="cov8" title="1"> if roleKind == "ClusterRole" </span><span class="cov8" title="1">{
                logger.Infof("finding %s: %s", roleKind, roleName)
                if _, err := rbacClient.ClusterRoles().Get(ctx, roleName, metav1.GetOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "finding %s failed: %s", roleKind, roleName)
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("incorrect value set for roleKind - %s, needs to be Role or ClusterRole", roleKind)
        }</span>

        <span class="cov8" title="1">logger.Info("finding role-binding", pipelinesSCCRoleBinding)
        pipelineRB, rbErr := rbacClient.RoleBindings(sa.Namespace).Get(ctx, pipelinesSCCRoleBinding, metav1.GetOptions{})
        if rbErr != nil &amp;&amp; !errors.IsNotFound(rbErr) </span><span class="cov0" title="0">{
                logger.Error(rbErr, "rbac get error", pipelinesSCCRoleBinding)
                return rbErr
        }</span>

        <span class="cov8" title="1">if rbErr != nil &amp;&amp; errors.IsNotFound(rbErr) </span><span class="cov8" title="1">{
                return r.createSCCRoleBinding(ctx, sa, roleRef)
        }</span>

        // We cannot update RoleRef in a RoleBinding, we need to delete and
        // recreate the binding in that case
        <span class="cov0" title="0">if pipelineRB.RoleRef.Kind != roleKind || pipelineRB.RoleRef.Name != roleName </span><span class="cov0" title="0">{
                logger.Infof("Need to update RoleRef in RoleBinding %s in namespace: %s, deleting and recreating...", pipelinesSCCRoleBinding, sa.Namespace)
                err := rbacClient.RoleBindings(sa.Namespace).Delete(ctx, pipelinesSCCRoleBinding, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return r.createSCCRoleBinding(ctx, sa, roleRef)</span>
        }

        <span class="cov0" title="0">logger.Info("found rbac", "subjects", pipelineRB.Subjects)
        return r.updateRoleBinding(ctx, pipelineRB, sa, roleRef)</span>
}

func (r *rbac) createSCCRoleBinding(ctx context.Context, sa *corev1.ServiceAccount, roleRef *rbacv1.RoleRef) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        rbacClient := r.kubeClientSet.RbacV1()

        logger.Info("create new rolebinding:", pipelinesSCCRoleBinding)
        rb := &amp;rbacv1.RoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            pipelinesSCCRoleBinding,
                        Namespace:       sa.Namespace,
                        OwnerReferences: []metav1.OwnerReference{r.ownerRef},
                },
                RoleRef:  *roleRef,
                Subjects: []rbacv1.Subject{{Kind: rbacv1.ServiceAccountKind, Name: sa.Name, Namespace: sa.Namespace}},
        }

        _, err := rbacClient.RoleBindings(sa.Namespace).Create(ctx, rb, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "creation of rolebinding failed:", pipelinesSCCRoleBinding)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (r *rbac) updateRoleBinding(ctx context.Context, rb *rbacv1.RoleBinding, sa *corev1.ServiceAccount, roleRef *rbacv1.RoleRef) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        subject := rbacv1.Subject{Kind: rbacv1.ServiceAccountKind, Name: sa.Name, Namespace: sa.Namespace}

        hasSubject := hasSubject(rb.Subjects, subject)
        if !hasSubject </span><span class="cov0" title="0">{
                rb.Subjects = append(rb.Subjects, subject)
        }</span>

        <span class="cov0" title="0">rb.RoleRef = *roleRef

        rbacClient := r.kubeClientSet.RbacV1()
        hasOwnerRef := hasOwnerRefernce(rb.GetOwnerReferences(), r.ownerRef)

        ownerRef := r.updateOwnerRefs(rb.GetOwnerReferences())
        rb.SetOwnerReferences(ownerRef)

        // If owners are different then we need to set from r.ownerRef and update the roleBinding.
        if !hasOwnerRef </span><span class="cov0" title="0">{
                if _, err := rbacClient.RoleBindings(sa.Namespace).Update(ctx, rb, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to update edit rb")
                        return err
                }</span>
        }

        <span class="cov0" title="0">if hasSubject &amp;&amp; (len(ownerRef) != 0) </span><span class="cov0" title="0">{
                logger.Info("rolebinding is up to date ", "action ", "none")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Infof("update existing rolebinding %s/%s", rb.Namespace, rb.Name)

        _, err := rbacClient.RoleBindings(sa.Namespace).Update(ctx, rb, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("%v: failed to update rolebinding %s/%s", err, rb.Namespace, rb.Name)
                return err
        }</span>
        <span class="cov0" title="0">logger.Infof("successfully updated rolebinding %s/%s", rb.Namespace, rb.Name)
        return nil</span>
}

func hasSubject(subjects []rbacv1.Subject, x rbacv1.Subject) bool <span class="cov0" title="0">{
        for _, v := range subjects </span><span class="cov0" title="0">{
                if v.Name == x.Name &amp;&amp; v.Kind == x.Kind &amp;&amp; v.Namespace == x.Namespace </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// CompareLists compares two slices of rbacv1.Subject, ignoring order
func CompareSubjects(list1, list2 []rbacv1.Subject) bool <span class="cov0" title="0">{
        // Check if lengths are different
        if len(list1) != len(list2) </span><span class="cov0" title="0">{
                return false
        }</span>
        // Create sets (maps) for both lists
        <span class="cov0" title="0">set1 := make(map[string]struct{})
        set2 := make(map[string]struct{})

        // Populate set1 with subjects from list1
        for _, subject := range list1 </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s/%s/%s", subject.Kind, subject.Name, subject.Namespace)
                set1[key] = struct{}{}
        }</span>
        // Populate set2 with subjects from list2
        <span class="cov0" title="0">for _, subject := range list2 </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s/%s/%s", subject.Kind, subject.Name, subject.Namespace)
                set2[key] = struct{}{}
        }</span>

        // Compare the sets
        <span class="cov0" title="0">if len(set1) != len(set2) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if all elements in set1 are in set2
        <span class="cov0" title="0">for key := range set1 </span><span class="cov0" title="0">{
                if _, exists := set2[key]; !exists </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func mergeSubjects(subjects []rbacv1.Subject, x []rbacv1.Subject) []rbacv1.Subject <span class="cov0" title="0">{
        // Map to track subjects in the existing list
        existingSubjects := make(map[string]struct{})

        // Iterate over `subjects` and track each unique combination of Kind, Name, and Namespace
        for _, subject := range subjects </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s/%s/%s", subject.Kind, subject.Name, subject.Namespace)
                existingSubjects[key] = struct{}{}
        }</span>

        // Final list to store the merged subjects
        <span class="cov0" title="0">var finalSubjects []rbacv1.Subject

        // Add all subjects from the original list (list1)
        finalSubjects = append(finalSubjects, subjects...)

        // Append subjects from `x` (list2) that are not in `existingSubjects`
        for _, subject := range x </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s/%s/%s", subject.Kind, subject.Name, subject.Namespace)
                if _, found := existingSubjects[key]; !found </span><span class="cov0" title="0">{
                        finalSubjects = append(finalSubjects, subject)
                }</span>
        }

        <span class="cov0" title="0">return finalSubjects</span>
}

func hasOwnerRefernce(old []metav1.OwnerReference, new metav1.OwnerReference) bool <span class="cov0" title="0">{
        for _, v := range old </span><span class="cov0" title="0">{
                if v.APIVersion == new.APIVersion &amp;&amp; v.Kind == new.Kind &amp;&amp; v.Name == new.Name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (r *rbac) isLegacyRBACEnabled() bool <span class="cov8" title="1">{
        for _, v := range r.tektonConfig.Spec.Params </span><span class="cov8" title="1">{
                if v.Name == legacyPipelineRbacParamName </span><span class="cov0" title="0">{
                        return v.Value != "false"
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (r *rbac) ensureRoleBindings(ctx context.Context, sa *corev1.ServiceAccount) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        rbacClient := r.kubeClientSet.RbacV1()

        legacyEnabled := r.isLegacyRBACEnabled()

        editRB, err := rbacClient.RoleBindings(sa.Namespace).Get(ctx, PipelineRoleBinding, metav1.GetOptions{})

        if !legacyEnabled &amp;&amp; err == nil </span><span class="cov0" title="0">{
                logger.Infof("Legacy Pipeline RBAC is disabled, removing existing role binding %s/%s",
                        editRB.Namespace, editRB.Name)
                return rbacClient.RoleBindings(sa.Namespace).Delete(ctx, PipelineRoleBinding, metav1.DeleteOptions{})
        }</span>

        <span class="cov8" title="1">if !legacyEnabled </span><span class="cov0" title="0">{
                logger.Infof("Legacy Pipeline RBAC is disabled, skipping role binding creation")
                return nil
        }</span>

        <span class="cov8" title="1">logger.Infof("Legacy Pipeline RBAC is enabled")

        if err == nil </span><span class="cov0" title="0">{
                logger.Infof("Found rolebinding %s/%s, updating if needed", editRB.Namespace, editRB.Name)
                return r.updateRoleBinding(ctx, editRB, sa, &amp;rbacv1.RoleRef{
                        APIGroup: rbacv1.GroupName,
                        Kind:     "ClusterRole",
                        Name:     "edit",
                })
        }</span>

        <span class="cov8" title="1">if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                logger.Infof("Role binding not found, creating new one")
                return r.createRoleBinding(ctx, sa)
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (r *rbac) createRoleBinding(ctx context.Context, sa *corev1.ServiceAccount) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        logger.Infof("create new rolebinding %s/%s", sa.Namespace, sa.Name)
        rbacClient := r.kubeClientSet.RbacV1()

        logger.Info("finding clusterrole edit")
        if _, err := rbacClient.ClusterRoles().Get(ctx, "edit", metav1.GetOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "getting clusterRole 'edit' failed")
                return err
        }</span>

        <span class="cov8" title="1">rb := &amp;rbacv1.RoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            PipelineRoleBinding,
                        Namespace:       sa.Namespace,
                        OwnerReferences: []metav1.OwnerReference{r.ownerRef},
                },
                RoleRef:  rbacv1.RoleRef{APIGroup: rbacv1.GroupName, Kind: "ClusterRole", Name: "edit"},
                Subjects: []rbacv1.Subject{{Kind: rbacv1.ServiceAccountKind, Name: sa.Name, Namespace: sa.Namespace}},
        }

        if _, err := rbacClient.RoleBindings(sa.Namespace).Create(ctx, rb, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("%v: failed creation of rolebinding %s/%s", err, rb.Namespace, rb.Name)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *rbac) removeAndUpdateNSFromCI(ctx context.Context) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        rbacClient := r.kubeClientSet.RbacV1()
        rb, err := r.rbacInformer.Lister().Get(clusterInterceptors)
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                logger.Error(err, "failed to get"+clusterInterceptors)
                return err
        }</span>
        <span class="cov8" title="1">if rb == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">req, err := labels.NewRequirement(namespaceVersionLabel, selection.Equals, []string{r.version})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "failed to create requirement: ")
                return err
        }</span>

        <span class="cov0" title="0">namespaces, err := r.nsInformer.Lister().List(labels.NewSelector().Add(*req))
        if err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                logger.Error(err, "failed to list namespace: ")
                return err
        }</span>

        <span class="cov0" title="0">nsMap := map[string]string{}
        for i := range namespaces </span><span class="cov0" title="0">{
                nsMap[namespaces[i].Name] = namespaces[i].Name
        }</span>

        <span class="cov0" title="0">var update bool
        for i := 0; i &lt;= len(rb.Subjects)-1; i++ </span><span class="cov0" title="0">{
                if len(nsMap) != len(rb.Subjects) </span><span class="cov0" title="0">{
                        if _, ok := nsMap[rb.Subjects[i].Namespace]; !ok </span><span class="cov0" title="0">{
                                rb.Subjects = removeIndex(rb.Subjects, i)
                                update = true
                        }</span>
                }
        }
        <span class="cov0" title="0">if update </span><span class="cov0" title="0">{
                if _, err := rbacClient.ClusterRoleBindings().Update(ctx, rb, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to update "+clusterInterceptors+" crb")
                        return err
                }</span>
                <span class="cov0" title="0">logger.Infof("successfully removed namespace and updated %s ", clusterInterceptors)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func removeIndex(s []rbacv1.Subject, index int) []rbacv1.Subject <span class="cov0" title="0">{
        return append(s[:index], s[index+1:]...)
}</span>

func (r *rbac) handleClusterRoleBinding(ctx context.Context, namespacesToUpdate []NamespaceServiceAccount) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        rbacClient := r.kubeClientSet.RbacV1()
        logger.Info("finding cluster-role ", clusterInterceptors)
        if _, err := rbacClient.ClusterRoles().Get(ctx, clusterInterceptors, metav1.GetOptions{}); errors.IsNotFound(err) </span><span class="cov8" title="1">{
                if e := r.createClusterRole(ctx); e != nil </span><span class="cov0" title="0">{
                        return e
                }</span>
        }

        // Prepare a list of Subjects from the namespacesToUpdate
        <span class="cov8" title="1">var subjects []rbacv1.Subject

        for _, nsSA := range namespacesToUpdate </span><span class="cov8" title="1">{
                sa := nsSA.ServiceAccount
                ns := nsSA.Namespace

                logger.Infof("Processing Subject for ServiceAccount %s in Namespace %s", sa.Name, ns.Name)

                // Create the Subject for the ClusterRoleBinding
                subject := rbacv1.Subject{
                        Kind:      rbacv1.ServiceAccountKind,
                        Name:      sa.Name,
                        Namespace: sa.Namespace,
                }

                // Append the subject to the list
                subjects = append(subjects, subject)
        }</span>

        <span class="cov8" title="1">logger.Info("finding cluster-role-binding ", clusterInterceptors)

        viewCRB, err := rbacClient.ClusterRoleBindings().Get(ctx, clusterInterceptors, metav1.GetOptions{})

        if err == nil </span><span class="cov0" title="0">{
                logger.Infof("found clusterrolebinding %s", viewCRB.Name)
                return r.bulkUpdateClusterRoleBinding(ctx, viewCRB, subjects)
        }</span>

        <span class="cov8" title="1">if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                logger.Infof("could not find clusterrolebinding %s proceeding to create", viewCRB.Name)
                return r.bulkCreateClusterRoleBinding(ctx, subjects)
        }</span>

        <span class="cov0" title="0">return err</span>
}

// bulk update Cluster rolebinding with all reconciled namespaces and service accounts
func (r *rbac) bulkUpdateClusterRoleBinding(ctx context.Context, rb *rbacv1.ClusterRoleBinding, subjectlist []rbacv1.Subject) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        hasSubject := CompareSubjects(rb.Subjects, subjectlist)
        if !hasSubject </span><span class="cov0" title="0">{
                rb.Subjects = mergeSubjects(rb.Subjects, subjectlist)
        }</span>

        <span class="cov0" title="0">rbacClient := r.kubeClientSet.RbacV1()
        hasOwnerRef := hasOwnerRefernce(rb.GetOwnerReferences(), r.ownerRef)

        ownerRef := r.updateOwnerRefs(rb.GetOwnerReferences())
        rb.SetOwnerReferences(ownerRef)

        // If owners are different then we need to set from r.ownerRef and update the clusterRolebinding.
        if !hasOwnerRef </span><span class="cov0" title="0">{
                if _, err := rbacClient.ClusterRoleBindings().Update(ctx, rb, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err, "failed to update "+clusterInterceptors+" crb")
                        return err
                }</span>
        }

        <span class="cov0" title="0">if hasSubject &amp;&amp; (len(ownerRef) != 0) </span><span class="cov0" title="0">{
                logger.Info("clusterrolebinding is up to date", "action", "none")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Info("update existing clusterrolebinding ", clusterInterceptors)

        if _, err := rbacClient.ClusterRoleBindings().Update(ctx, rb, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "failed to update "+clusterInterceptors+" crb")
                return err
        }</span>
        <span class="cov0" title="0">logger.Info("successfully updated ", clusterInterceptors)
        return nil</span>
}

// create Cluster rolebinding with all reconciled namespaces and service accounts
func (r *rbac) bulkCreateClusterRoleBinding(ctx context.Context, subjectlist []rbacv1.Subject) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        logger.Info("create new clusterrolebinding ", clusterInterceptors)
        rbacClient := r.kubeClientSet.RbacV1()

        logger.Info("finding clusterrole ", clusterInterceptors)
        if _, err := rbacClient.ClusterRoles().Get(ctx, clusterInterceptors, metav1.GetOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, " getting clusterRole "+clusterInterceptors+" failed")
                return err
        }</span>

        <span class="cov8" title="1">crb := &amp;rbacv1.ClusterRoleBinding{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            clusterInterceptors,
                        OwnerReferences: []metav1.OwnerReference{r.ownerRef},
                },
                RoleRef:  rbacv1.RoleRef{APIGroup: rbacv1.GroupName, Kind: "ClusterRole", Name: clusterInterceptors},
                Subjects: subjectlist,
        }

        if _, err := rbacClient.ClusterRoleBindings().Create(ctx, crb, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, " creation of "+clusterInterceptors+" failed")
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *rbac) createClusterRole(ctx context.Context) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        logger.Info("create new clusterrole ", clusterInterceptors)
        rbacClient := r.kubeClientSet.RbacV1()

        cr := &amp;rbacv1.ClusterRole{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            clusterInterceptors,
                        OwnerReferences: []metav1.OwnerReference{r.ownerRef},
                },
                Rules: []rbacv1.PolicyRule{{
                        APIGroups: []string{"triggers.tekton.dev"},
                        Resources: []string{"clusterinterceptors"},
                        Verbs:     []string{"get", "list", "watch"},
                }},
        }

        if _, err := rbacClient.ClusterRoles().Create(ctx, cr, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Error(err, "creation of "+clusterInterceptors+" clusterrole failed")
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *rbac) updateOwnerRefs(ownerRef []metav1.OwnerReference) []metav1.OwnerReference <span class="cov0" title="0">{
        if len(ownerRef) == 0 </span><span class="cov0" title="0">{
                return []metav1.OwnerReference{r.ownerRef}
        }</span>

        <span class="cov0" title="0">for i, ref := range ownerRef </span><span class="cov0" title="0">{
                if ref.APIVersion != r.ownerRef.APIVersion || ref.Kind != r.ownerRef.Kind || ref.Name != r.ownerRef.Name </span><span class="cov0" title="0">{
                        // if owner reference are different remove the existing oand override with r.ownerRef
                        return r.removeAndUpdate(ownerRef, i)
                }</span>
        }

        <span class="cov0" title="0">return ownerRef</span>
}

func (r *rbac) removeAndUpdate(slice []metav1.OwnerReference, s int) []metav1.OwnerReference <span class="cov0" title="0">{
        ownerRef := append(slice[:s], slice[s+1:]...)
        ownerRef = append(ownerRef, r.ownerRef)
        return ownerRef
}</span>

// TODO: Remove this after v0.55.0 release, by following a depreciation notice
// --------------------
// cleanUpRBACNameChange will check remove ownerReference: RBAC installerset from
// 'edit' rolebindings from all relevant namespaces
// it will also remove 'pipeline' sa from subject list as
// the new 'openshift-pipelines-edit' rolebinding
func (r *rbac) cleanUpRBACNameChange(ctx context.Context) error <span class="cov0" title="0">{
        rbacClient := r.kubeClientSet.RbacV1()

        // fetch the list of all namespaces
        namespaces, err := r.kubeClientSet.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, ns := range namespaces.Items </span><span class="cov0" title="0">{
                nsName := ns.GetName()

                // filter namespaces:
                // ignore ns with name passing regex `^(openshift|kube)-`
                if ignore := nsRegex.MatchString(nsName); ignore </span><span class="cov0" title="0">{
                        continue</span>
                }

                // check if "edit" rolebinding exists in "ns" namespace
                <span class="cov0" title="0">editRB, err := rbacClient.RoleBindings(ns.GetName()).
                        Get(ctx, pipelineRoleBindingOld, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        // if "edit" rolebinding does not exists in "ns" namesapce, then do nothing
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }

                // check if 'pipeline' serviceaccount is listed as a subject in 'edit' rolebinding
                <span class="cov0" title="0">depSub := rbacv1.Subject{Kind: rbacv1.ServiceAccountKind, Name: pipelineSA, Namespace: nsName}
                subIdx := math.MinInt16
                for i, s := range editRB.Subjects </span><span class="cov0" title="0">{
                        if s.Name == depSub.Name &amp;&amp; s.Kind == depSub.Kind &amp;&amp; s.Namespace == depSub.Namespace </span><span class="cov0" title="0">{
                                subIdx = i
                                break</span>
                        }
                }

                // if 'pipeline' serviceaccount is listed as a subject in 'edit' rolebinding
                // remove 'pipeline' serviceaccount from subject list
                <span class="cov0" title="0">if subIdx &gt;= 0 </span><span class="cov0" title="0">{
                        editRB.Subjects = append(editRB.Subjects[:subIdx], editRB.Subjects[subIdx+1:]...)
                }</span>

                // if 'pipeline' serviceaccount was the only item in the subject list of 'edit' rolebinding,
                // then we can delete 'edit' rolebinding as nobody else is using it
                <span class="cov0" title="0">if len(editRB.Subjects) == 0 </span><span class="cov0" title="0">{
                        if err := rbacClient.RoleBindings(nsName).Delete(ctx, editRB.GetName(), metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // remove TektonInstallerSet ownerReferece from "edit" rolebinding
                <span class="cov0" title="0">ownerRefs := editRB.GetOwnerReferences()
                ownerRefIdx := math.MinInt16
                for i, ownerRef := range ownerRefs </span><span class="cov0" title="0">{
                        if ownerRef.Kind == "TektonInstallerSet" </span><span class="cov0" title="0">{
                                ownerRefIdx = i
                                break</span>
                        }
                }
                <span class="cov0" title="0">if ownerRefIdx &gt;= 0 </span><span class="cov0" title="0">{
                        ownerRefs := append(ownerRefs[:ownerRefIdx], ownerRefs[ownerRefIdx+1:]...)
                        editRB.SetOwnerReferences(ownerRefs)

                }</span>

                // if ownerReference or subject was updated, then update editRB resource on cluster
                <span class="cov0" title="0">if ownerRefIdx &lt; 0 &amp;&amp; subIdx &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if _, err := rbacClient.RoleBindings(nsName).Update(ctx, editRB, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// TODO: Remove this after v0.55.0 release, by following a depreciation notice
// --------------------
func (r *rbac) removeObsoleteRBACInstallerSet(ctx context.Context) error <span class="cov8" title="1">{
        isClient := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets()
        err := isClient.Delete(ctx, rbacInstallerSetNameOld, metav1.DeleteOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *rbac) ensureCABundlesInNamespace(ctx context.Context, ns *corev1.Namespace) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Infow("Ensuring CA bundle configmaps in namespace", "namespace", ns.GetName())
        return r.ensureCABundles(ctx, ns)
}</span>

// Add new method for patching namespace with trusted configmaps label
func (r *rbac) patchNamespaceTrustedConfigLabel(ctx context.Context, ns corev1.Namespace) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        logger.Infof("add label namespace-trusted-configmaps-version to mark namespace '%s' as reconciled", ns.Name)

        // Prepare a patch to add/update just one label without overwriting others
        patch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "labels": map[string]interface{}{
                                namespaceTrustedConfigLabel: r.version,
                        },
                },
        }

        patchPayload, err := json.Marshal(patch)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to marshal patch payload: %v", err)
                return fmt.Errorf("failed to marshal label patch for namespace %s: %w", ns.Name, err)
        }</span>

        // Use PATCH to update just the target label
        <span class="cov8" title="1">if _, err := r.kubeClientSet.CoreV1().Namespaces().Patch(ctx, ns.Name, types.StrategicMergePatchType, patchPayload, metav1.PatchOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to patch namespace %s: %v", ns.Name, err)
                return fmt.Errorf("failed to patch namespace %s: %w", ns.Name, err)
        }</span>

        <span class="cov8" title="1">logger.Infof("namespace '%s' successfully reconciled with label %q=%q", ns.Name, namespaceTrustedConfigLabel, r.version)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonhub

import (
        "context"

        k8s_ctrl "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonhub"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>
</pre>
		
		<pre class="file" id="file167" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonhub

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/go-logr/zapr"
        mfc "github.com/manifestival/client-go-client"
        mf "github.com/manifestival/manifestival"
        console "github.com/openshift/api/console/v1"
        routev1 "github.com/openshift/api/route/v1"
        "github.com/openshift/client-go/route/clientset/versioned/scheme"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        openshiftCommon "github.com/tektoncd/operator/pkg/reconciler/openshift/common"
        "go.uber.org/zap"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const (
        hubprefix                  string = "tekton-hub"
        tektonHubAPIResourceKey    string = "api"
        tektonHubUiResourceKey     string = "ui"
        CreatedByValue             string = "TektonHub"
        ConsoleHubLinkInstallerSet        = "ConsoleHubLink"
)

var replaceVal = map[string]string{
        "POSTGRES_DB":       "POSTGRESQL_DATABASE",
        "POSTGRES_USER":     "POSTGRESQL_USER",
        "POSTGRES_PASSWORD": "POSTGRESQL_PASSWORD",
}

var (
        db  string = fmt.Sprintf("%s-%s", hubprefix, "db")
        api string = fmt.Sprintf("%s-%s", hubprefix, "api")
        ui  string = fmt.Sprintf("%s-%s", hubprefix, "ui")
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("error creating client from injected config", zap.Error(err))
        }</span>
        <span class="cov0" title="0">mflogger := zapr.NewLogger(logger.Named("manifestival").Desugar())
        manifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("error creating initial manifest", zap.Error(err))
        }</span>

        <span class="cov0" title="0">ext := openshiftExtension{
                operatorClientSet: operatorclient.Get(ctx),
                kubeClientSet:     kubeclient.Get(ctx),
                manifest:          manifest,
        }
        return ext</span>
}

type openshiftExtension struct {
        operatorClientSet versioned.Interface
        kubeClientSet     kubernetes.Interface
        manifest          mf.Manifest
}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return []mf.Transformer{
                UpdateDbDeployment(),
                openshiftCommon.RemoveRunAsUser(),
                openshiftCommon.RemoveRunAsUserForJob(),
                openshiftCommon.RemoveFsGroupForDeployment(),
                openshiftCommon.RemoveFsGroupForJob(),
        }
}</span>

func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        th := tc.(*v1alpha1.TektonHub)
        logger := logging.FromContext(ctx)
        targetNs := th.Spec.GetTargetNamespace()
        hubDir := filepath.Join(common.ComponentDir(th), common.TargetVersion(th), tektonHubAPIResourceKey)
        manifest := oe.manifest.Append()

        if err := common.AppendManifest(&amp;manifest, hubDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">apiRouteManifest := manifest.Filter(mf.ByKind("Route"))
        apiRouteManifest, err := apiRouteManifest.Transform(
                mf.InjectOwner(th),
                mf.InjectNamespace(targetNs),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to transform manifest")
                return err
        }</span>
        <span class="cov0" title="0">if err := apiRouteManifest.Apply(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Get the host of API route
        <span class="cov0" title="0">apiRoute, err := getRouteHost(&amp;apiRouteManifest, api)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">th.Status.SetApiRoute(fmt.Sprintf("https://%s", apiRoute))

        // Set Auth Url in Tekton Hub Status
        if err := oe.SetAuthBaseURL(ctx, th, apiRouteManifest); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create UI route based on the value of ui i.e. false/true
        <span class="cov0" title="0">uiHubDir := filepath.Join(common.ComponentDir(th), common.TargetVersion(th), tektonHubUiResourceKey)
        uiManifest := oe.manifest.Append()

        if err := common.AppendManifest(&amp;uiManifest, uiHubDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">uiRouteManifest := uiManifest.Filter(mf.ByKind("Route"))
        uiRouteManifest, err = uiRouteManifest.Transform(
                mf.InjectOwner(th),
                mf.InjectNamespace(targetNs),
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to transform manifest")
                return err
        }</span>
        <span class="cov0" title="0">if err := uiRouteManifest.Apply(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">uiRoute, err := getRouteHost(&amp;uiRouteManifest, ui)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">th.Status.SetUiRoute(fmt.Sprintf("https://%s", uiRoute))

        return nil</span>
}

func (oe openshiftExtension) PostReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        th := tc.(*v1alpha1.TektonHub)
        consoleCLILS := metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.InstallerSetType: ConsoleHubLinkInstallerSet,
                },
        }

        consoleHubLinkLabelSelector, err := common.LabelSelector(consoleCLILS)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">exist, err := checkIfInstallerSetExist(ctx, oe.operatorClientSet, common.TargetVersion(th), consoleHubLinkLabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                hubConsoleLinkManifest := oe.manifest.Append()
                if err := applyHubConsoleLinkManifest(&amp;hubConsoleLinkManifest); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := consoleLinkTransform(ctx, &amp;hubConsoleLinkManifest, th.Status.GetUiRoute()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := createInstallerSet(ctx, oe.operatorClientSet, th, hubConsoleLinkManifest,
                        common.TargetVersion(th), ConsoleHubLinkInstallerSet, "console-link-hub"); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func checkIfInstallerSetExist(ctx context.Context, oc clientset.Interface, relVersion string,
        labelSelector string) (bool, error) <span class="cov0" title="0">{

        installerSets, err := oc.OperatorV1alpha1().TektonInstallerSets().
                List(ctx, metav1.ListOptions{
                        LabelSelector: labelSelector,
                })
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if len(installerSets.Items) == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if len(installerSets.Items) == 1 </span><span class="cov0" title="0">{
                // if already created then check which version it is
                version, ok := installerSets.Items[0].Labels[v1alpha1.ReleaseVersionKey]
                if ok &amp;&amp; version == relVersion </span><span class="cov0" title="0">{
                        // if installer set already exist and release version is same
                        // then ignore and move on
                        return true, nil
                }</span>
        }

        // release version doesn't exist or is different from expected
        // deleted existing InstallerSet and create a new one
        // or there is more than one installerset (unexpected)
        <span class="cov0" title="0">if err = oc.OperatorV1alpha1().TektonInstallerSets().
                DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{
                        LabelSelector: labelSelector,
                }); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return false, v1alpha1.RECONCILE_AGAIN_ERR</span>
}

func createInstallerSet(ctx context.Context, oc clientset.Interface, ta *v1alpha1.TektonHub,
        manifest mf.Manifest, releaseVersion, component, installerSetPrefix string) error <span class="cov0" title="0">{

        is := makeInstallerSet(ta, manifest, installerSetPrefix, releaseVersion, component)

        if _, err := oc.OperatorV1alpha1().TektonInstallerSets().
                Create(ctx, is, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func makeInstallerSet(ta *v1alpha1.TektonHub, manifest mf.Manifest, prefix, releaseVersion, component string) *v1alpha1.TektonInstallerSet <span class="cov0" title="0">{
        ownerRef := *metav1.NewControllerRef(ta, ta.GetGroupVersionKind())
        labels := map[string]string{
                v1alpha1.CreatedByKey:      CreatedByValue,
                v1alpha1.InstallerSetType:  component,
                v1alpha1.ReleaseVersionKey: releaseVersion,
        }
        namePrefix := fmt.Sprintf("%s-", prefix)

        return &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: namePrefix,
                        Labels:       labels,
                        Annotations: map[string]string{
                                v1alpha1.TargetNamespaceKey: ta.Spec.TargetNamespace,
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }
}</span>

func applyHubConsoleLinkManifest(manifest *mf.Manifest) error <span class="cov0" title="0">{
        koDataDir := os.Getenv(common.KoEnvKey)
        location := filepath.Join(koDataDir, "openshift", "tekton-hub")
        return common.AppendManifest(manifest, location)
}</span>

func consoleLinkTransform(ctx context.Context, manifest *mf.Manifest, baseURL string) error <span class="cov0" title="0">{
        if baseURL == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("route url should not be empty")
        }</span>
        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        logger.Debug("Transforming manifest")

        transformers := []mf.Transformer{
                replaceURLConsoleLink(baseURL),
        }

        transformManifest, err := manifest.Transform(transformers...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">*manifest = transformManifest
        return nil</span>
}

func replaceURLConsoleLink(baseURL string) mf.Transformer <span class="cov0" title="0">{
        return func(u *unstructured.Unstructured) error </span><span class="cov0" title="0">{
                if u.GetKind() != "ConsoleLink" </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">cl := &amp;console.ConsoleLink{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, cl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">cl.Spec.Href = baseURL

                unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(cl)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">u.SetUnstructuredContent(unstrObj)
                return nil</span>
        }
}

func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>

// Get the Host value of the Route created
func getRouteHost(manifest *mf.Manifest, routeName string) (string, error) <span class="cov0" title="0">{
        var hostUrl string
        for _, r := range manifest.Filter(mf.ByKind("Route")).Resources() </span><span class="cov0" title="0">{
                u, err := manifest.Client.Get(&amp;r)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if u.GetName() == routeName </span><span class="cov0" title="0">{
                        route := &amp;routev1.Route{}
                        if err := scheme.Scheme.Convert(u, route, nil); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">hostUrl = route.Spec.Host</span>
                }
        }
        <span class="cov0" title="0">return hostUrl, nil</span>
}

func UpdateDbDeployment() mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if d.Name == db </span><span class="cov8" title="1">{
                        env := d.Spec.Template.Spec.Containers[0].Env

                        replaceEnv(env)

                        d.Spec.Template.Spec.Containers[0].Env = env

                        mountPath := "/var/lib/pgsql/data"
                        d.Spec.Template.Spec.Containers[0].VolumeMounts[0].MountPath = mountPath

                        replaceProbeCommand(d.Spec.Template.Spec.Containers[0].ReadinessProbe.Exec.Command)
                        replaceProbeCommand(d.Spec.Template.Spec.Containers[0].LivenessProbe.Exec.Command)

                        unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                        return nil</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

func (oe openshiftExtension) SetAuthBaseURL(ctx context.Context, th *v1alpha1.TektonHub, apiRouteManifest mf.Manifest) error <span class="cov0" title="0">{
        // Get the api secret
        secret, err := oe.kubeClientSet.CoreV1().Secrets(th.Spec.GetTargetNamespace()).Get(ctx, "tekton-hub-api", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        th.Status.SetAuthRoute("")
                }</span> else<span class="cov0" title="0"> {
                        return err
                }</span>
        }

        <span class="cov0" title="0">if len(secret.Data["GH_CLIENT_ID"]) != 0 || len(secret.Data["GL_CLIENT_ID"]) != 0 || len(secret.Data["BB_CLIENT_ID"]) != 0 </span><span class="cov0" title="0">{
                // Get the host of Auth route
                authRoute, err := getRouteHost(&amp;apiRouteManifest, "tekton-hub-auth")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">th.Status.SetAuthRoute(fmt.Sprintf("https://%s", authRoute))

                if secret.Data == nil || string(secret.Data["AUTH_BASE_URL"]) != th.Status.AuthRouteUrl </span><span class="cov0" title="0">{

                        if secret.StringData == nil </span><span class="cov0" title="0">{
                                secret.StringData = make(map[string]string)
                        }</span>

                        <span class="cov0" title="0">secret.StringData["AUTH_BASE_URL"] = th.Status.AuthRouteUrl

                        _, err = oe.kubeClientSet.CoreV1().Secrets(th.Spec.GetTargetNamespace()).Update(ctx, secret, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                th.Status.SetAuthRoute("")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func replaceProbeCommand(data []string) <span class="cov8" title="1">{
        if strings.Contains(data[2], "POSTGRES_USER") </span><span class="cov8" title="1">{
                data[2] = strings.ReplaceAll(data[2], "POSTGRES_USER", "POSTGRESQL_USER")
        }</span>
        <span class="cov8" title="1">if strings.Contains(data[2], "POSTGRES_DB") </span><span class="cov8" title="1">{
                data[2] = strings.ReplaceAll(data[2], "POSTGRES_DB", "POSTGRESQL_DATABASE")
        }</span>
}

func replaceEnv(envs []corev1.EnvVar) <span class="cov8" title="1">{
        for i, e := range envs </span><span class="cov8" title="1">{
                _, ok := replaceVal[e.Name]
                if ok </span><span class="cov8" title="1">{
                        envs[i].Name = replaceVal[e.Name]
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file168" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpipeline

import (
        "context"

        k8s_ctrl "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpipeline"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>
</pre>
		
		<pre class="file" id="file169" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpipeline

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        occommon "github.com/tektoncd/operator/pkg/reconciler/openshift/common"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/logging"
)

const (
        monitoringLabelKey = "openshift.io/cluster-monitoring"
        enableMetricsKey   = "enableMetrics"
        versionKey         = "VERSION"

        tektonPipelinesControllerName       = "tekton-pipelines-controller"
        tektonRemoteResolversControllerName = "tekton-pipelines-remote-resolvers"
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        version := os.Getenv(versionKey)
        if version == "" </span><span class="cov0" title="0">{
                logger.Fatal("Failed to find version from env")
        }</span>

        <span class="cov0" title="0">ext := openshiftExtension{
                // component version is used for metrics, passing a dummy
                // value through extension not going to affect execution
                installerSetClient: client.NewInstallerSetClient(operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets(),
                        version, "pipelines-ext", v1alpha1.KindTektonPipeline, nil),
                kubeClientSet: kubeclient.Get(ctx),
        }
        return ext</span>
}

type openshiftExtension struct {
        installerSetClient *client.InstallerSetClient
        kubeClientSet      kubernetes.Interface
}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        trns := []mf.Transformer{
                occommon.ApplyCABundlesToDeployment,
                occommon.RemoveRunAsUser(),
                occommon.RemoveRunAsUserForStatefulSet(tektonPipelinesControllerName),
                occommon.RemoveRunAsUserForStatefulSet(tektonRemoteResolversControllerName),
                occommon.ApplyCABundlesForStatefulSet(tektonPipelinesControllerName),
                occommon.ApplyCABundlesForStatefulSet(tektonRemoteResolversControllerName),
        }
        return trns
}</span>
func (oe openshiftExtension) PreReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        manifest, err := preManifest()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Filtering out the namespace because it add TektonPipeline as OwnerRef in targetNamespace
        <span class="cov0" title="0">*manifest = manifest.Filter(mf.Not(mf.ByKind("Namespace")))
        if err := oe.installerSetClient.PreSet(ctx, comp, manifest, filterAndTransform()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // update monitoring label based on metric enable status under params
        // namespace creation/modifications are not handled by manifests, see above, namespace filtered from manifests
        <span class="cov0" title="0">pipeline := comp.(*v1alpha1.TektonPipeline)
        value := strings.ToLower(findParam(pipeline.Spec.Params, enableMetricsKey))
        labels := map[string]string{
                monitoringLabelKey: "false",
        }
        if value == "" || value == "true" </span><span class="cov0" title="0">{
                labels[monitoringLabelKey] = "true"
        }</span>

        // reconcile namespace with updated labels
        <span class="cov0" title="0">return common.ReconcileTargetNamespace(ctx, labels, nil, comp, oe.kubeClientSet)</span>
}

func (oe openshiftExtension) PostReconcile(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        pipeline := comp.(*v1alpha1.TektonPipeline)

        // Install monitoring if metrics is enabled
        value := strings.ToLower(findParam(pipeline.Spec.Params, enableMetricsKey))

        if value == "" || value == "true" </span><span class="cov0" title="0">{
                manifest, err := postManifest()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := oe.installerSetClient.PostSet(ctx, comp, manifest, filterAndTransform()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := oe.installerSetClient.CleanupPostSet(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
func (oe openshiftExtension) Finalize(ctx context.Context, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        if err := oe.installerSetClient.CleanupPostSet(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := oe.installerSetClient.CleanupPreSet(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func preManifest() (*mf.Manifest, error) <span class="cov0" title="0">{
        koDataDir := os.Getenv(common.KoEnvKey)
        manifest := &amp;mf.Manifest{}

        // make sure that openshift-pipelines namespace exists
        namespaceLocation := filepath.Join(koDataDir, "tekton-namespace")
        if err := common.AppendManifest(manifest, namespaceLocation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // add inject CA bundles manifests
        <span class="cov0" title="0">cabundlesLocation := filepath.Join(koDataDir, "cabundles")
        if err := common.AppendManifest(manifest, cabundlesLocation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return manifest, nil</span>
}

func postManifest() (*mf.Manifest, error) <span class="cov0" title="0">{
        koDataDir := os.Getenv(common.KoEnvKey)
        manifest := &amp;mf.Manifest{}

        monitoringLocation := filepath.Join(koDataDir, "openshift-monitoring")
        if err := common.AppendManifest(manifest, monitoringLocation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return manifest, nil</span>
}

func filterAndTransform() client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                if err := common.Transform(ctx, manifest, comp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return manifest, nil</span>
        }
}

func findParam(params []v1alpha1.Param, param string) string <span class="cov0" title="0">{
        for _, p := range params </span><span class="cov0" title="0">{
                if p.Name == param </span><span class="cov0" title="0">{
                        return p.Value
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import (
        "context"

        k8sctrl "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner"

        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
)

func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return k8sctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>
</pre>
		
		<pre class="file" id="file171" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonpruner

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        occommon "github.com/tektoncd/operator/pkg/reconciler/openshift/common"
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        return openshiftExtension{}
}</span>

type openshiftExtension struct{}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return []mf.Transformer{
                occommon.RemoveRunAsUser(),
                occommon.RemoveRunAsGroup(),
        }
}</span>
func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        "context"

        k8s_ctrl "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonresult

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset/client"
        occommon "github.com/tektoncd/operator/pkg/reconciler/openshift/common"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        k8sruntime "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/logging"
)

const (
        // manifests console plugin yaml directory location
        routeRBACYamlDirectory  = "static/tekton-results/route-rbac"
        internalDBYamlDirectory = "static/tekton-results/internal-db"
        logsRBACYamlDirectory   = "static/tekton-results/logs-rbac"
        deploymentAPI           = "tekton-results-api"
        serviceAPI              = "tekton-results-api-service"
        routeAPI                = "tekton-results-api"
        secretAPITLS            = "tekton-results-tls"
        apiContainerName        = "api"
        boundSAVolume           = "bound-sa-token"
        boundSAPath             = "/var/run/secrets/openshift/serviceaccount"
        lokiStackTLSCAEnvVar    = "LOGGING_PLUGIN_CA_CERT"
        tektonResultWatcherName = "tekton-results-watcher"
)

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        version := os.Getenv(v1alpha1.VersionEnvKey)
        if version == "" </span><span class="cov0" title="0">{
                logger.Fatal("Failed to find version from env")
        }</span>

        <span class="cov0" title="0">routeManifest, err := getRouteManifest()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to fetch route rbac static manifest: %v", err)
        }</span>

        <span class="cov0" title="0">internalDBManifest, err := getDBManifest()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to fetch internal db static manifest: %v", err)
        }</span>

        <span class="cov0" title="0">logsRBACManifest, err := getloggingRBACManifest()
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to fetch logs RBAC manifest: %v", err)
        }</span>

        <span class="cov0" title="0">ext := &amp;openshiftExtension{
                installerSetClient: client.NewInstallerSetClient(operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets(),
                        version, "results-ext", v1alpha1.KindTektonResult, nil),
                internalDBManifest: internalDBManifest,
                routeManifest:      routeManifest,
                logsRBACManifest:   logsRBACManifest,
        }
        return ext</span>
}

type openshiftExtension struct {
        installerSetClient *client.InstallerSetClient
        routeManifest      *mf.Manifest
        internalDBManifest *mf.Manifest
        logsRBACManifest   *mf.Manifest
        removePreset       bool
}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        instance := comp.(*v1alpha1.TektonResult)

        return []mf.Transformer{
                occommon.RemoveRunAsUser(),
                occommon.RemoveRunAsGroup(),
                occommon.ApplyCABundlesToDeployment,
                occommon.RemoveRunAsUserForStatefulSet(tektonResultWatcherName),
                occommon.RemoveRunAsGroupForStatefulSet(tektonResultWatcherName),
                occommon.ApplyCABundlesForStatefulSet(tektonResultWatcherName),
                injectBoundSAToken(instance.Spec.ResultsAPIProperties),
                injectLokiStackTLSCACert(instance.Spec.LokiStackProperties),
                injectResultsAPIServiceCACert(instance.Spec.ResultsAPIProperties),
        }
}</span>

func (oe *openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        result := tc.(*v1alpha1.TektonResult)
        mf := mf.Manifest{}

        if !result.Spec.IsExternalDB </span><span class="cov0" title="0">{
                mf = *oe.internalDBManifest
                oe.removePreset = true
        }</span>
        <span class="cov0" title="0">if result.Spec.IsExternalDB &amp;&amp; oe.removePreset </span><span class="cov0" title="0">{
                if err := oe.installerSetClient.CleanupPreSet(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">oe.removePreset = false</span>
        }
        <span class="cov0" title="0">if (result.Spec.LokiStackName != "" &amp;&amp; result.Spec.LokiStackNamespace != "") ||
                strings.EqualFold(result.Spec.LogsType, "LOKI") </span><span class="cov0" title="0">{
                mf = mf.Append(*oe.logsRBACManifest)
        }</span>

        <span class="cov0" title="0">return oe.installerSetClient.PreSet(ctx, tc, &amp;mf, filterAndTransform())</span>
}

func (oe openshiftExtension) PostReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        manifest := *oe.routeManifest

        result := tc.(*v1alpha1.TektonResult)
        if !isEnableRoute(result) </span><span class="cov0" title="0">{
                manifest = manifest.Filter(mf.Not(mf.ByKind("Route")))
        }</span>

        <span class="cov0" title="0">return oe.installerSetClient.PostSet(ctx, tc, &amp;manifest, filterAndTransform())</span>
}

func (oe openshiftExtension) Finalize(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        if err := oe.installerSetClient.CleanupPostSet(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := oe.installerSetClient.CleanupPreSet(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func getRouteManifest() (*mf.Manifest, error) <span class="cov8" title="1">{
        manifest := &amp;mf.Manifest{}
        resultsRbac := filepath.Join(common.ComponentBaseDir(), routeRBACYamlDirectory)
        if err := common.AppendManifest(manifest, resultsRbac); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return manifest, nil</span>
}

func getDBManifest() (*mf.Manifest, error) <span class="cov0" title="0">{
        manifest := &amp;mf.Manifest{}
        internalDB := filepath.Join(common.ComponentBaseDir(), internalDBYamlDirectory)
        if err := common.AppendManifest(manifest, internalDB); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return manifest, nil</span>
}

// function to add fine grained access control to results api if results config specifies that
// pipeline logs are managed by OpenShift Logging with OpenShift logging and OpenShift loki operators
func getloggingRBACManifest() (*mf.Manifest, error) <span class="cov8" title="1">{
        manifest := &amp;mf.Manifest{}
        logsRbac := filepath.Join(common.ComponentBaseDir(), logsRBACYamlDirectory)
        if err := common.AppendManifest(manifest, logsRbac); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return manifest, nil</span>
}

func filterAndTransform() client.FilterAndTransform <span class="cov0" title="0">{
        return func(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) (*mf.Manifest, error) </span><span class="cov0" title="0">{
                resultImgs := common.ToLowerCaseKeys(common.ImagesFromEnv(common.ResultsImagePrefix))
                instance := comp.(*v1alpha1.TektonResult)

                extra := []mf.Transformer{
                        common.InjectOperandNameLabelOverwriteExisting(v1alpha1.OperandTektoncdResults),
                        common.ApplyProxySettings,
                        common.AddStatefulSetRestrictedPSA(),
                        common.DeploymentImages(resultImgs),
                        common.StatefulSetImages(resultImgs),
                        injectResultsAPIRoute(instance.Spec.ResultsAPIProperties),
                }

                if err := common.Transform(ctx, manifest, comp, extra...); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return manifest, nil</span>
        }
}

func injectResultsAPIServiceCACert(props v1alpha1.ResultsAPIProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Service" || u.GetName() != serviceAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">s := &amp;corev1.Service{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">annotations := s.Annotations
                if annotations == nil </span><span class="cov8" title="1">{
                        annotations = make(map[string]string)
                }</span>
                <span class="cov8" title="1">annotations["service.beta.openshift.io/serving-cert-secret-name"] = secretAPITLS
                s.SetAnnotations(annotations)

                uObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(s)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(uObj)
                return nil</span>
        }
}

// injectBoundSAToken adds a sa token projected volume to the Results Deployment
func injectBoundSAToken(props v1alpha1.ResultsAPIProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if props.LogsAPI == nil || !*props.LogsAPI ||
                        u.GetKind() != "Deployment" || u.GetName() != deploymentAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // find the matching container and add env and secret name object
                <span class="cov8" title="1">for i, container := range d.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if container.Name != apiContainerName </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">add := true
                        vol := corev1.Volume{
                                Name: boundSAVolume,
                                VolumeSource: corev1.VolumeSource{
                                        Projected: &amp;corev1.ProjectedVolumeSource{
                                                Sources: []corev1.VolumeProjection{
                                                        {
                                                                ServiceAccountToken: &amp;corev1.ServiceAccountTokenProjection{
                                                                        Audience: "openshift",
                                                                        Path:     "token",
                                                                },
                                                        },
                                                },
                                        },
                                },
                        }
                        for k := 0; k &lt; len(d.Spec.Template.Spec.Volumes); k++ </span><span class="cov8" title="1">{
                                if d.Spec.Template.Spec.Volumes[k].Name == boundSAVolume </span><span class="cov0" title="0">{
                                        d.Spec.Template.Spec.Volumes[k] = vol
                                        add = false
                                }</span>
                        }
                        <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                                d.Spec.Template.Spec.Volumes = append(d.Spec.Template.Spec.Volumes, vol)
                        }</span>

                        <span class="cov8" title="1">volMount := corev1.VolumeMount{
                                Name:      boundSAVolume,
                                MountPath: boundSAPath,
                        }

                        add = true
                        for k := 0; k &lt; len(d.Spec.Template.Spec.Containers[i].VolumeMounts); k++ </span><span class="cov8" title="1">{
                                if d.Spec.Template.Spec.Containers[i].VolumeMounts[k].Name == boundSAVolume </span><span class="cov0" title="0">{
                                        d.Spec.Template.Spec.Containers[i].VolumeMounts[k] = volMount
                                        add = false
                                }</span>
                        }
                        <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                                d.Spec.Template.Spec.Containers[i].VolumeMounts = append(
                                        d.Spec.Template.Spec.Containers[i].VolumeMounts, volMount)
                        }</span>

                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">uObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(uObj)
                return nil</span>
        }
}

// injectLokiStackTLSCACert adds a tls ca cert environment variable to the Results Deployment
// If the env variable already exists, it will be overwritten
func injectLokiStackTLSCACert(prop v1alpha1.LokiStackProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if prop.LokiStackNamespace == "" || prop.LokiStackName == "" ||
                        u.GetKind() != "Deployment" || u.GetName() != deploymentAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := k8sruntime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // find the matching container and add env and secret name object
                <span class="cov8" title="1">for i, container := range d.Spec.Template.Spec.Containers </span><span class="cov8" title="1">{
                        if container.Name != apiContainerName </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">add := true
                        env := corev1.EnvVar{
                                Name: lokiStackTLSCAEnvVar,
                                ValueFrom: &amp;corev1.EnvVarSource{
                                        ConfigMapKeyRef: &amp;corev1.ConfigMapKeySelector{
                                                LocalObjectReference: corev1.LocalObjectReference{
                                                        Name: "openshift-service-ca.crt",
                                                },
                                                Key: "service-ca.crt",
                                        },
                                },
                        }

                        // Check if the env variable already exists in the container
                        // If it does, overwrite it
                        for k := 0; k &lt; len(d.Spec.Template.Spec.Containers[i].Env); k++ </span><span class="cov8" title="1">{
                                if d.Spec.Template.Spec.Containers[i].Env[k].Name == lokiStackTLSCAEnvVar </span><span class="cov0" title="0">{
                                        d.Spec.Template.Spec.Containers[i].Env[k] = env
                                        add = false
                                }</span>
                        }

                        // If it doesn't exist, add it
                        <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                                d.Spec.Template.Spec.Containers[i].Env = append(
                                        d.Spec.Template.Spec.Containers[i].Env, env)
                        }</span>

                        <span class="cov8" title="1">break</span>
                }

                <span class="cov8" title="1">uObj, err := k8sruntime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(uObj)
                return nil</span>
        }
}

// isEnableRoute determines if route should be enabled for results API
func isEnableRoute(result *v1alpha1.TektonResult) bool <span class="cov0" title="0">{
        // Default to false if not explicitly set
        if result.Spec.RouteEnabled == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return *result.Spec.RouteEnabled</span>
}

// injectResultsAPIRoute adds ResultSpec route properties to Results route
func injectResultsAPIRoute(props v1alpha1.ResultsAPIProperties) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Route" || u.GetName() != routeAPI </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Apply custom host if specified
                <span class="cov8" title="1">if props.RouteHost != "" </span><span class="cov8" title="1">{
                        if err := unstructured.SetNestedField(u.Object, props.RouteHost, "spec", "host"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Apply custom path if specified
                <span class="cov8" title="1">if props.RoutePath != "" </span><span class="cov8" title="1">{
                        if err := unstructured.SetNestedField(u.Object, props.RoutePath, "spec", "path"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // Apply custom TLS termination if specified
                <span class="cov8" title="1">if props.RouteTLSTermination != "" </span><span class="cov8" title="1">{
                        if err := unstructured.SetNestedField(u.Object, props.RouteTLSTermination, "spec", "tls", "termination"); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file174" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        "context"

        k8s_ctrl "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
)

// NewController initializes the controller and is called by the generated code
// Registers eventhandlers to enqueue events
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return k8s_ctrl.NewExtendedController(OpenShiftExtension)(ctx, cmw)
}</span>
</pre>
		
		<pre class="file" id="file175" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektontrigger"
        occommon "github.com/tektoncd/operator/pkg/reconciler/openshift/common"
        "knative.dev/pkg/ptr"
)

// triggersProperties holds fields for configuring runAsUser and runAsGroup.
type triggersProperties struct {
        DefaultRunAsUser  *string `json:"default-run-as-user,omitempty"`
        DefaultRunAsGroup *string `json:"default-run-as-group,omitempty"`
        DefaultFSGroup    *string `json:"default-fs-group,omitempty"`
}

// Updating the default values of runAsUser and runAsGroup to an empty string
// to ensure compatibility with OpenShift's requirements for managing these settings
// in Triggers Eventlistener containers SCC.
var triggersData = triggersProperties{
        DefaultRunAsUser:  ptr.String(""),
        DefaultRunAsGroup: ptr.String(""),
        DefaultFSGroup:    ptr.String(""),
}

func OpenShiftExtension(ctx context.Context) common.Extension <span class="cov0" title="0">{
        return openshiftExtension{}
}</span>

type openshiftExtension struct{}

func (oe openshiftExtension) Transformers(comp v1alpha1.TektonComponent) []mf.Transformer <span class="cov0" title="0">{
        return []mf.Transformer{
                occommon.RemoveRunAsUser(),
                occommon.RemoveRunAsGroup(),
                occommon.ApplyCABundlesToDeployment,
                common.AddConfigMapValues(tektontrigger.ConfigDefaults, triggersData),
                replaceDeploymentArgs("-el-events", "enable"),
        }
}</span>
func (oe openshiftExtension) PreReconcile(ctx context.Context, tc v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) PostReconcile(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
func (oe openshiftExtension) Finalize(context.Context, v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file176" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektontrigger

import (
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        appsv1 "k8s.io/api/apps/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime"
)

// replace the value of a deployment arg provided argToReplace and value
func replaceDeploymentArgs(argToReplace, value string) mf.Transformer <span class="cov8" title="1">{
        return func(u *unstructured.Unstructured) error </span><span class="cov8" title="1">{
                if u.GetKind() != "Deployment" </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">d := &amp;appsv1.Deployment{}
                err := runtime.DefaultUnstructuredConverter.FromUnstructured(u.Object, d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">containers := d.Spec.Template.Spec.Containers
                for _, container := range containers </span><span class="cov8" title="1">{
                        if len(container.Args) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for j, arg := range container.Args </span><span class="cov8" title="1">{
                                // for scenario when key and value are in single arg e.g. "key=value"
                                if argVal, hasArg := common.SplitsByEqual(arg); hasArg </span><span class="cov8" title="1">{
                                        if argVal[0] == argToReplace </span><span class="cov0" title="0">{
                                                container.Args[j] = argVal[0] + "=" + value
                                        }</span>
                                        <span class="cov8" title="1">continue</span>
                                }
                                // for scenario, when key and value are in different args, eg. "key","value"
                                <span class="cov8" title="1">if arg == argToReplace </span><span class="cov8" title="1">{
                                        container.Args[j+1] = value
                                }</span>
                        }

                }

                <span class="cov8" title="1">unstrObj, err := runtime.DefaultUnstructuredConverter.ToUnstructured(d)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">u.SetUnstructuredContent(unstrObj)

                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file177" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package platform

import (
        "errors"
        "flag"
        "fmt"
        "log"
        "os"
        "strings"
)

func init() <span class="cov8" title="1">{
        RegisterFlags()
}</span>

const (
        FlagControllers       string = "controllers"
        FlagSharedMainName    string = "unique-process-name"
        DefaultSharedMainName string = "tekton-operator"
)

var (
        ErrSharedMainNameEmpty = fmt.Errorf("sharedMainName cannot be empty string")
        ErrControllerNamesNil  = fmt.Errorf("ControllerNames slice should be non-nil")
        ctrlArgs               string
        processName            string
)

// RegisterFlags adds platform specific command line flags
// this logic is written in a separate function to make it convenient
// to write unit-tests
func RegisterFlags() <span class="cov8" title="1">{
        flag.StringVar(
                &amp;ctrlArgs,
                FlagControllers,
                "",
                "comma separated list of names of controllers to be enabled (\"\" enables all controllers)",
        )

        // The role of this flag to make sure that instances of this process running as different
        // containers have unique "sharedMain Name"
        // The name has to be unique otherwise knative/pkg will consider the 2 containers as copies (like replicas in a deployment) of
        // same process as leader election and logging are setup using this "sharedMain Name"
        flag.StringVar(
                &amp;processName,
                FlagSharedMainName,
                DefaultSharedMainName,
                "name of the sharedMain process used in leader election (unique among containers of same pod)")
}</span>

// NewConfigFromFlags returns PlatformConfig created using
// inputs from command line flags
func NewConfigFromFlags() PlatformConfig <span class="cov8" title="1">{

        config, err := newConfig(flagsConfigReader)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to read platform from flags: %v", err)
        }</span>
        <span class="cov8" title="1">return config</span>
}

// NewConfigFromEnv returns PlatformConfig created using
// inputs from environment variables
func NewConfigFromEnv() PlatformConfig <span class="cov0" title="0">{
        config, err := newConfig(envConfigReader)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to read platform from env: %v", err)
        }</span>
        <span class="cov0" title="0">return config</span>
}

// envConfigReader of type 'configReader' is modular implementation of the logic
// to read platform specific inputs from environment variables
func envConfigReader(pc *PlatformConfig) error <span class="cov0" title="0">{
        ctrlArgs := os.Getenv(EnvControllerNames)
        c := os.Getenv(EnvSharedMainName)
        pc.SharedMainName = c
        pc.ControllerNames = stringToControllerNamesSlice(ctrlArgs)
        return nil
}</span>

// flagsConfigReader 'configReader' is modular implementation of the logic
// to read platform specific inputs from command line flags
func flagsConfigReader(pc *PlatformConfig) error <span class="cov8" title="1">{
        flag.Parse()
        pc.SharedMainName = processName
        pc.ControllerNames = stringToControllerNamesSlice(ctrlArgs)
        return nil
}</span>

// newConfig returns PlatformConfig created using inputs read by
// provided implementation of 'configReader'
func newConfig(inFn configReader) (PlatformConfig, error) <span class="cov8" title="1">{
        config := PlatformConfig{}
        err := inFn(&amp;config)
        if err != nil </span><span class="cov8" title="1">{
                return PlatformConfig{}, err
        }</span>
        <span class="cov8" title="1">if err := validateConfig(&amp;config); err != nil </span><span class="cov8" title="1">{
                return PlatformConfig{}, err
        }</span>
        <span class="cov8" title="1">return config, nil</span>
}

// validateConfig does basic validation on platform specific configuration
func validateConfig(pc *PlatformConfig) error <span class="cov8" title="1">{
        violations := []string{}

        if len(pc.SharedMainName) == 0 </span><span class="cov8" title="1">{
                violations = append(violations, ErrSharedMainNameEmpty.Error())
        }</span>
        // TODO: set a maximum length for pc.SharedMainName

        <span class="cov8" title="1">if pc.ControllerNames == nil </span><span class="cov8" title="1">{
                violations = append(violations, ErrControllerNamesNil.Error())
        }</span>
        <span class="cov8" title="1">if len(violations) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return errors.New(strings.Join(violations, ","))</span>
}

// stringToControllerNamesSlice returns a []ControllerName
// created from controllerNames in a comma separated string "ctrl1,ctrl2"
func stringToControllerNamesSlice(s string) []ControllerName <span class="cov8" title="1">{
        result := []ControllerName{}
        if len(s) == 0 </span><span class="cov8" title="1">{
                return result
        }</span>
        <span class="cov8" title="1">for _, val := range strings.Split(s, ",") </span><span class="cov8" title="1">{
                result = append(result, ControllerName(val))
        }</span>
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package platform

import (
        "context"
        "fmt"
        "log"
        "strings"

        installer "github.com/tektoncd/operator/pkg/reconciler/shared/tektoninstallerset"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/injection/sharedmain"
        "knative.dev/pkg/signals"
)

// validateControllerNamesOrDie ensures that the list of controller names to be enabled
// are supported by a platform. This function exits on error
func validateControllerNamesOrDie(p Platform) <span class="cov0" title="0">{
        if err := validateControllerNames(p); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("error validating provided controller names: %v", err)
        }</span>

}

// validateControllerNames ensures that the list of controller names to be enabled
// are supported by a platform
func validateControllerNames(p Platform) error <span class="cov8" title="1">{
        pParams := p.PlatformParams()
        supportedCtrls := p.AllSupportedControllers()
        invalidNamesStr := invalidNames(supportedCtrls, pParams.ControllerNames)
        if len(invalidNamesStr) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return ErrorControllerNames(invalidNamesStr, supportedCtrls.ControllerNames())</span>
}

// invalidNames checks if whether there are any names in []CotrollerNames which are
// not present in (supported by) given ControllerMap
func invalidNames(supportedCtrls ControllerMap, cNames []ControllerName) string <span class="cov8" title="1">{
        invalidNames := strings.Builder{}
        for _, cName := range cNames </span><span class="cov8" title="1">{
                if _, ok := supportedCtrls[cName]; !ok </span><span class="cov8" title="1">{
                        invalidNames.WriteString(string(cName))
                        invalidNames.WriteString(",")
                }</span>
        }

        <span class="cov8" title="1">return strings.TrimSuffix(invalidNames.String(), ",")</span>
}

// ErrorControllerNames is a error message format helper
func ErrorControllerNames(invalidNames string, validNames []string) error <span class="cov8" title="1">{
        return fmt.Errorf("un-identified controller names: %s, supported names: %v", invalidNames, validNames)
}</span>

// activeControllers returns a map of the controllers that should be run
// the returned map is a subset of the platform specific map which stores all-supported-controllers
func activeControllers(p Platform) ControllerMap <span class="cov8" title="1">{
        pParams := p.PlatformParams()
        result := ControllerMap{}
        for _, name := range pParams.ControllerNames </span><span class="cov8" title="1">{
                if namedCtrl, ok := p.AllSupportedControllers()[name]; ok </span><span class="cov8" title="1">{
                        result[name] = namedCtrl
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// disabledControllers returns a map of the controllers that should not be run
// the result of disabledControllers is the set of controllers excluded by activeControllers function
// in other words, disabledControllers returns a map which has controllers "not" specified in the controlelrNames input to a platform
// the returned map is a subset of the platform specific map which stores all-supported-controllers
func disabledControllers(p Platform) ControllerMap <span class="cov8" title="1">{
        pParams := p.PlatformParams()
        result := p.AllSupportedControllers()
        for _, name := range pParams.ControllerNames </span><span class="cov8" title="1">{
                delete(result, name)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// contextWithPlatformName  adds platform name to a given context
func contextWithPlatformName(ctx context.Context, pName string) context.Context <span class="cov0" title="0">{
        ctx = context.WithValue(ctx, PlatformNameKey{}, pName)
        return ctx
}</span>

// startMain starts a knative/pkg sharedMain with a context that stores platform name
// and a list of controllers which should be enabled for the given platform
func startMain(p Platform, ctrls ControllerMap) <span class="cov0" title="0">{
        pParams := p.PlatformParams()
        cfg := injection.ParseAndGetRESTConfigOrDie()
        cfg.QPS = 50
        ctx, _ := injection.EnableInjectionOrDie(signals.NewContext(), cfg)
        ctx = contextWithPlatformName(ctx, pParams.Name)
        installer.InitTektonInstallerSetClient(ctx)
        sharedmain.MainWithConfig(ctx,
                pParams.SharedMainName,
                cfg,
                ctrls.ControllerConstructors()...,
        )
}</span>

// StartMainWithAllControllers calls startMain with all controllers
// supported by a platform
func StartMainWithAllControllers(p Platform) <span class="cov0" title="0">{
        startMain(p, p.AllSupportedControllers())
}</span>

// StartMainWithSelectedControllers starts the main control loop with only the controllers
// that are explicitly specified in the platform configuration.
func StartMainWithSelectedControllers(p Platform) <span class="cov0" title="0">{
        validateControllerNamesOrDie(p)
        selectedCtrls := activeControllers(p)
        startMain(p, selectedCtrls)
}</span>
</pre>
		
		<pre class="file" id="file179" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package platform

type FakePlatform struct {
        pParams           func() PlatformConfig
        allSupportedCtrls func() ControllerMap
}

func (fp *FakePlatform) PlatformParams() PlatformConfig <span class="cov8" title="1">{
        return fp.pParams()
}</span>

func (fp *FakePlatform) AllSupportedControllers() ControllerMap <span class="cov8" title="1">{
        return fp.allSupportedCtrls()
}</span>

func SeededFakePlatform(cn []ControllerName, ctrls ControllerMap) *FakePlatform <span class="cov8" title="1">{
        f := FakePlatform{}
        f.pParams = func() PlatformConfig </span><span class="cov8" title="1">{
                return PlatformConfig{
                        ControllerNames: cn,
                }
        }</span>
        <span class="cov8" title="1">f.allSupportedCtrls = func() ControllerMap </span><span class="cov8" title="1">{
                return ctrls
        }</span>
        <span class="cov8" title="1">return &amp;f</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package platform

import (
        "knative.dev/pkg/injection"
)

type configReader func(config *PlatformConfig) error

// PlatformConfig defines basic configuration that
// all platforms should support
type PlatformConfig struct {
        Name            string
        ControllerNames []ControllerName
        SharedMainName  string
}

// PlatformNameKey is defines a 'key' for adding platform name to an instance of context.Context
type PlatformNameKey struct{}

// ControllerName defines a name given to a controller(reconciler) in a platform
type ControllerName string

// ControllerMap defines map that maps a name given to a controller(reconciler) to its injection.ControllerConstructor
type ControllerMap map[ControllerName]injection.NamedControllerConstructor

// ControllerNames returns a []string of names of all controllers (reconciers)
// supported in a given ControlelrMap
func (cm ControllerMap) ControllerNames() []string <span class="cov8" title="1">{
        result := []string{}
        for _, namedCtrl := range cm </span><span class="cov8" title="1">{
                result = append(result, namedCtrl.Name)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ControllerConstructor returns a []injection.ControllerConstructor of all controllers (reconciers)
// supported in a given ControlelrMap
// Some versions of sharedMain functions in knative/pkg expect
// a variadic list of supported cotrollers as []injection.ControllerConstructor
func (cm ControllerMap) ControllerConstructors() []injection.ControllerConstructor <span class="cov8" title="1">{
        result := []injection.ControllerConstructor{}
        for _, namedCtrl := range cm </span><span class="cov8" title="1">{
                result = append(result, namedCtrl.ControllerConstructor)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ControllerConstructor returns a []injection.NamedControllerConstructor of all controllers (reconciers)
// supported in a given ControlelrMap
// Some versions of sharedMain functions in knative/pkg expect
// a variadic list of supported cotrollers as []injection.NamedControllerConstructor
func (cm ControllerMap) NamedControllerConstructors() []injection.NamedControllerConstructor <span class="cov8" title="1">{
        result := []injection.NamedControllerConstructor{}
        for _, namedCtrl := range cm </span><span class="cov8" title="1">{
                result = append(result, namedCtrl)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Platform defines a Kubernetes platform (Vanila Kubernetes, OpenShift...)
type Platform interface {
        PlatformParams() PlatformConfig
        AllSupportedControllers() ControllerMap
}
</pre>
		
		<pre class="file" id="file181" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package proxy

import (
        "context"
        "os"

        "knative.dev/pkg/configmap"

        "knative.dev/pkg/injection"
        "knative.dev/pkg/signals"

        // Injection stuff
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        mwhinformer "knative.dev/pkg/client/injection/kube/informers/admissionregistration/v1/mutatingwebhookconfiguration"
        "knative.dev/pkg/controller"
        secretinformer "knative.dev/pkg/injection/clients/namespacedkube/informers/core/v1/secret"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
)

// NewAdmissionController constructs a reconciler
func NewAdmissionController(
        ctx context.Context,
        name, path string,
        wc func(context.Context) context.Context,
        disallowUnknownFields bool,
) *controller.Impl <span class="cov0" title="0">{

        client := kubeclient.Get(ctx)
        mwhInformer := mwhinformer.Get(ctx)
        secretInformer := secretinformer.Get(ctx)
        options := webhook.GetOptions(ctx)

        key := types.NamespacedName{Name: name}

        wh := &amp;reconciler{
                LeaderAwareFuncs: pkgreconciler.LeaderAwareFuncs{
                        // Have this reconciler enqueue our singleton whenever it becomes leader.
                        PromoteFunc: func(bkt pkgreconciler.Bucket, enq func(pkgreconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                enq(bkt, key)
                                return nil
                        }</span>,
                },

                key:  key,
                path: path,

                withContext:           wc,
                disallowUnknownFields: disallowUnknownFields,
                secretName:            options.SecretName,

                client:       client,
                mwhlister:    mwhInformer.Lister(),
                secretlister: secretInformer.Lister(),
        }

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        c := controller.NewContext(ctx, wh, controller.ControllerOptions{WorkQueueName: "DefaultingWebhook", Logger: logger})

        // Reconcile when the named MutatingWebhookConfiguration changes.
        if _, err := mwhInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithName(name),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named MWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register MutatingWebhookConfugration informer event handler: %w", err)
        }</span>

        // Reconcile when the cert bundle changes.
        <span class="cov0" title="0">if _, err := secretInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterWithNameAndNamespace(system.Namespace(), wh.secretName),
                // It doesn't matter what we enqueue because we will always Reconcile
                // the named MWH resource.
                Handler: controller.HandleAll(c.Enqueue),
        }); err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register Secret informer event handler: %w", err)
        }</span>

        <span class="cov0" title="0">return c</span>
}

func Getctx() context.Context <span class="cov0" title="0">{
        serviceName := os.Getenv("WEBHOOK_SERVICE_NAME")
        if serviceName == "" </span><span class="cov0" title="0">{
                serviceName = "tekton-operator-proxy-webhook"
        }</span>

        <span class="cov0" title="0">secretName := os.Getenv("WEBHOOK_SECRET_NAME")
        if secretName == "" </span><span class="cov0" title="0">{
                secretName = "proxy-webhook-certs"
        }</span>
        <span class="cov0" title="0">systemNamespace := os.Getenv("SYSTEM_NAMESPACE")

        // Scope informers to the webhook's namespace instead of cluster-wide
        ctx := injection.WithNamespaceScope(signals.NewContext(), systemNamespace)

        // Set up a signal context with our webhook options
        ctx = webhook.WithOptions(ctx, webhook.Options{
                ServiceName: serviceName,
                Port:        8443,
                SecretName:  secretName,
        })
        return ctx</span>
}

func NewProxyDefaultingAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{

        return NewAdmissionController(ctx,

                // Name of the resource webhook.
                "proxy.operator.tekton.dev",

                // The path on which to serve the webhook.
                "/defaulting",

                // A function that infuses the context passed to Validate/SetDefaults with custom metadata.
                func(ctx context.Context) context.Context </span><span class="cov0" title="0">{
                        return ctx
                }</span>,

                // Whether to disallow unknown fields.
                true,
        )
}
</pre>
		
		<pre class="file" id="file182" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package proxy

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "strings"

        "github.com/markbates/inflect"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "go.uber.org/zap"
        "gomodules.xyz/jsonpatch/v2"
        admissionv1 "k8s.io/api/admission/v1"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        admissionlisters "k8s.io/client-go/listers/admissionregistration/v1"
        corelisters "k8s.io/client-go/listers/core/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/apis/duck"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmp"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
        certresources "knative.dev/pkg/webhook/certificates/resources"
)

// reconciler implements the AdmissionController for resources
type reconciler struct {
        webhook.StatelessAdmissionImpl
        pkgreconciler.LeaderAwareFuncs

        key  types.NamespacedName
        path string

        withContext func(context.Context) context.Context

        client       kubernetes.Interface
        mwhlister    admissionlisters.MutatingWebhookConfigurationLister
        secretlister corelisters.SecretLister

        disallowUnknownFields bool
        secretName            string
}

var _ controller.Reconciler = (*reconciler)(nil)
var _ pkgreconciler.LeaderAware = (*reconciler)(nil)
var _ webhook.AdmissionController = (*reconciler)(nil)
var _ webhook.StatelessAdmissionController = (*reconciler)(nil)

// Reconcile implements controller.Reconciler
func (ac *reconciler) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        if !ac.IsLeaderFor(ac.key) </span><span class="cov0" title="0">{
                logger.Debugf("Skipping key %q, not the leader.", ac.key)
                return nil
        }</span>

        // Look up the webhook secret, and fetch the CA cert bundle.
        <span class="cov0" title="0">secret, err := ac.secretlister.Secrets(system.Namespace()).Get(ac.secretName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error fetching secret", zap.Error(err))
                return err
        }</span>
        <span class="cov0" title="0">caCert, ok := secret.Data[certresources.CACert]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("secret %q is missing %q key", ac.secretName, certresources.CACert)
        }</span>

        // Reconcile the webhook configuration.
        <span class="cov0" title="0">return ac.reconcileMutatingWebhook(ctx, caCert)</span>
}

// Path implements AdmissionController
func (ac *reconciler) Path() string <span class="cov0" title="0">{
        return ac.path
}</span>

// Admit implements AdmissionController
func (ac *reconciler) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse <span class="cov0" title="0">{
        if ac.withContext != nil </span><span class="cov0" title="0">{
                ctx = ac.withContext(ctx)
        }</span>

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        switch request.Operation </span>{
        case admissionv1.Create:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                logger.Info("Unhandled webhook operation, letting it through ", request.Operation)
                return &amp;admissionv1.AdmissionResponse{Allowed: true}</span>
        }

        <span class="cov0" title="0">patchBytes, err := ac.mutate(ctx, request)
        if err != nil </span><span class="cov0" title="0">{
                return webhook.MakeErrorStatus("mutation failed: %v", err)
        }</span>
        <span class="cov0" title="0">logger.Infof("Kind: %q PatchBytes: %v", request.Kind, string(patchBytes))

        return &amp;admissionv1.AdmissionResponse{
                Patch:   patchBytes,
                Allowed: true,
                PatchType: func() *admissionv1.PatchType </span><span class="cov0" title="0">{
                        pt := admissionv1.PatchTypeJSONPatch
                        return &amp;pt
                }</span>(),
        }
}

func (ac *reconciler) reconcileMutatingWebhook(ctx context.Context, caCert []byte) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        plural := strings.ToLower(inflect.Pluralize("Pod"))
        rules := []admissionregistrationv1.RuleWithOperations{
                {
                        Operations: []admissionregistrationv1.OperationType{
                                admissionregistrationv1.Create,
                        },
                        Rule: admissionregistrationv1.Rule{
                                APIGroups:   []string{""},
                                APIVersions: []string{"v1"},
                                Resources:   []string{plural, plural + "/status"},
                        },
                },
        }

        configuredWebhook, err := ac.mwhlister.Get(ac.key.Name)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error retrieving webhook: %w", err)
        }</span>

        <span class="cov0" title="0">webhook := configuredWebhook.DeepCopy()

        // Clear out any previous (bad) OwnerReferences.
        // See: https://github.com/knative/serving/issues/5845
        webhook.OwnerReferences = nil

        for i, wh := range webhook.Webhooks </span><span class="cov0" title="0">{
                if wh.Name != webhook.Name </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">webhook.Webhooks[i].Rules = rules
                webhook.Webhooks[i].NamespaceSelector = &amp;metav1.LabelSelector{
                        MatchExpressions: []metav1.LabelSelectorRequirement{{
                                Key:      "operator.tekton.dev/disable-proxy",
                                Operator: metav1.LabelSelectorOpDoesNotExist,
                        }, {
                                // "control-plane" is added to support Azure's AKS, otherwise the controllers fight.
                                // See knative/pkg#1590 for details.
                                Key:      "control-plane",
                                Operator: metav1.LabelSelectorOpDoesNotExist,
                        }},
                }
                webhook.Webhooks[i].ObjectSelector = &amp;metav1.LabelSelector{
                        MatchExpressions: []metav1.LabelSelectorRequirement{
                                {
                                        Key:      "app.kubernetes.io/managed-by",
                                        Values:   []string{"tekton-pipelines", "pipelinesascode.tekton.dev"},
                                        Operator: metav1.LabelSelectorOpIn,
                                },
                        },
                }
                webhook.Webhooks[i].ClientConfig.CABundle = caCert
                if webhook.Webhooks[i].ClientConfig.Service == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing service reference for webhook: %s", wh.Name)
                }</span>
                <span class="cov0" title="0">webhook.Webhooks[i].ClientConfig.Service.Path = ptr.String(ac.Path())</span>
        }

        <span class="cov0" title="0">if ok, err := kmp.SafeEqual(configuredWebhook, webhook); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error diffing webhooks: %w", err)
        }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                logger.Info("Updating webhook")
                mwhclient := ac.client.AdmissionregistrationV1().MutatingWebhookConfigurations()
                if _, err := mwhclient.Update(ctx, webhook, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update webhook: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Info("Webhook is valid")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ac *reconciler) mutate(ctx context.Context, req *admissionv1.AdmissionRequest) ([]byte, error) <span class="cov0" title="0">{
        kind := req.Kind
        newBytes := req.Object.Raw
        oldBytes := req.OldObject.Raw
        // Why, oh why are these different types...
        gvk := schema.GroupVersionKind{
                Group:   kind.Group,
                Version: kind.Version,
                Kind:    kind.Kind,
        }

        logger := logging.FromContext(ctx)
        if gvk.Group != "" || gvk.Version != "v1" || gvk.Kind != "Pod" </span><span class="cov0" title="0">{
                logger.Error("Unhandled kind: ", gvk)
                return nil, fmt.Errorf("unhandled kind: %v", gvk)
        }</span>

        // nil values denote absence of `old` (create) or `new` (delete) objects.
        <span class="cov0" title="0">var oldObj, newObj corev1.Pod

        if len(newBytes) != 0 </span><span class="cov0" title="0">{
                newDecoder := json.NewDecoder(bytes.NewBuffer(newBytes))
                if ac.disallowUnknownFields </span><span class="cov0" title="0">{
                        newDecoder.DisallowUnknownFields()
                }</span>
                <span class="cov0" title="0">if err := newDecoder.Decode(&amp;newObj); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot decode incoming new object: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if len(oldBytes) != 0 </span><span class="cov0" title="0">{
                oldDecoder := json.NewDecoder(bytes.NewBuffer(oldBytes))
                if ac.disallowUnknownFields </span><span class="cov0" title="0">{
                        oldDecoder.DisallowUnknownFields()
                }</span>
                <span class="cov0" title="0">if err := oldDecoder.Decode(&amp;oldObj); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot decode incoming old object: %w", err)
                }</span>
        }
        <span class="cov0" title="0">var patches duck.JSONPatch

        var err error
        // Skip this step if the type we're dealing with is a duck type, since it is inherently
        // incomplete and this will patch away all of the unspecified fields.
        // Add these before defaulting fields, otherwise defaulting may cause an illegal patch
        // because it expects the round tripped through Golang fields to be present already.
        rtp, err := roundTripPatch(newBytes, newObj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot create patch for round tripped newBytes: %w", err)
        }</span>
        <span class="cov0" title="0">patches = append(patches, rtp...)

        ctx = apis.WithinCreate(ctx)
        ctx = apis.WithUserInfo(ctx, &amp;req.UserInfo)

        // Default the new object.
        if patches, err = setDefaults(ac.client, ctx, patches, newObj); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed the resource specific defaulter", zap.Error(err))
                // Return the error message as-is to give the defaulter callback
                // discretion over (our portion of) the message that the user sees.
                return nil, err
        }</span>

        <span class="cov0" title="0">return json.Marshal(patches)</span>
}

// roundTripPatch generates the JSONPatch that corresponds to round tripping the given bytes through
// the Golang type (JSON -&gt; Golang type -&gt; JSON). Because it is not always true that
// bytes == json.Marshal(json.Unmarshal(bytes)).
//
// For example, if bytes did not contain a 'spec' field and the Golang type specifies its 'spec'
// field without omitempty, then by round tripping through the Golang type, we would have added
// `'spec': {}`.
func roundTripPatch(bytes []byte, unmarshalled interface{}) (duck.JSONPatch, error) <span class="cov0" title="0">{
        if unmarshalled == nil </span><span class="cov0" title="0">{
                return duck.JSONPatch{}, nil
        }</span>
        <span class="cov0" title="0">marshaledBytes, err := json.Marshal(unmarshalled)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot marshal interface: %w", err)
        }</span>
        <span class="cov0" title="0">return jsonpatch.CreatePatch(bytes, marshaledBytes)</span>
}

// setDefaults simply leverages apis.Defaultable to set defaults.
func setDefaults(client kubernetes.Interface, ctx context.Context, patches duck.JSONPatch, pod corev1.Pod) (duck.JSONPatch, error) <span class="cov0" title="0">{
        before, after := pod.DeepCopyObject(), pod

        var proxyEnv = []corev1.EnvVar{{
                Name:  "HTTPS_PROXY",
                Value: os.Getenv("HTTPS_PROXY"),
        }, {
                Name:  "HTTP_PROXY",
                Value: os.Getenv("HTTP_PROXY"),
        }, {
                Name:  "NO_PROXY",
                Value: os.Getenv("NO_PROXY"),
        }}

        if after.Spec.Containers != nil </span><span class="cov0" title="0">{
                for i, container := range after.Spec.Containers </span><span class="cov0" title="0">{
                        newEnvs := updateAndMergeEnv(container.Env, proxyEnv)
                        after.Spec.Containers[i].Env = newEnvs
                }</span>
        }

        <span class="cov0" title="0">after = updateVolumeOptional(after)
        patch, err := duck.CreatePatch(before, after)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return append(patches, patch...), nil</span>
}

// updateVolumeOptional adds CA bundle ConfigMaps as optional volumes to avoid API call overhead.
// This function uses optional ConfigMap volumes that allow pods to start even when ConfigMaps don't exist,
// eliminating the need for expensive API calls during webhook processing.
func updateVolumeOptional(pod corev1.Pod) corev1.Pod <span class="cov8" title="1">{
        // Add the trusted and service CA bundle ConfigMaps as optional volumes
        pod.Spec.Volumes = common.AddCABundleConfigMapsToVolumesOptional(pod.Spec.Volumes)

        // Mount the volumes in all containers
        for i, c := range pod.Spec.Containers </span><span class="cov8" title="1">{
                common.AddCABundlesToContainerVolumes(&amp;c)
                pod.Spec.Containers[i] = c
        }</span>
        <span class="cov8" title="1">return pod</span>
}

// updateAndMergeEnv will merge two slices of env
// precedence will be given to second input if exist with same name key
func updateAndMergeEnv(containerenvs []corev1.EnvVar, proxyEnv []corev1.EnvVar) []corev1.EnvVar <span class="cov0" title="0">{
        containerEnv := map[string]string{}

        for _, env := range containerenvs </span><span class="cov0" title="0">{
                containerEnv[env.Name] = env.Value
        }</span>
        <span class="cov0" title="0">for _, env := range proxyEnv </span><span class="cov0" title="0">{
                var updated bool
                if _, ok := containerEnv[env.Name]; ok </span><span class="cov0" title="0">{
                        // If proxy set at global level and pipelinerun/taskrun level are same
                        // then priority will be given to pipelinerun/taskrun.
                        updated = true
                }</span> else<span class="cov0" title="0"> {
                        if env.Value != "" </span><span class="cov0" title="0">{
                                updated = false
                        }</span> else<span class="cov0" title="0"> {
                                updated = true
                        }</span>
                }
                <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                        containerenvs = append(containerenvs, corev1.EnvVar{
                                Name:  env.Name,
                                Value: env.Value,
                        })
                }</span>
        }
        <span class="cov0" title="0">return containerenvs</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package hash

import (
        "crypto/md5"
        "crypto/sha256"
        "encoding/json"
        "fmt"

        "golang.org/x/mod/sumdb/dirhash"
)

// Compute generates an unique hash/string for the object pass to it.
// with sha256
func Compute(obj interface{}) (string, error) <span class="cov8" title="1">{
        d, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">hashSha256 := sha256.New()
        hashSha256.Write(d)
        return fmt.Sprintf("%x", hashSha256.Sum(nil)), nil</span>
}

// Compute generates an unique hash/string for the object pass to it.
// with md5
func ComputeMd5(obj interface{}) (string, error) <span class="cov8" title="1">{
        d, err := json.Marshal(obj)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">hashMd5 := md5.New()
        hashMd5.Write(d)
        return fmt.Sprintf("%x", hashMd5.Sum(nil)), nil</span>
}

// computes has for the given directory, tasks the directory and files recursively
// "prefix" used internally to produce constant base path,
// actual location will be replaced with this prefix on hash calculation
func ComputeHashDir(dirLocation, prefix string) (string, error) <span class="cov0" title="0">{
        return dirhash.HashDir(dirLocation, prefix, dirhash.DefaultHash)
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package chain

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

func EnsureTektonChainExists(ctx context.Context, clients op.TektonChainInterface, tc *v1alpha1.TektonChain) (*v1alpha1.TektonChain, error) <span class="cov8" title="1">{
        tcCR, err := GetChain(ctx, clients, v1alpha1.ChainResourceName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := CreateChain(ctx, clients, tc); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">tcCR, err = UpdateChain(ctx, tcCR, tc, clients)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ready, err := isTektonChainReady(tcCR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !ready </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return tcCR, err</span>
}

func EnsureTektonChainCRNotExists(ctx context.Context, clients op.TektonChainInterface) error <span class="cov8" title="1">{
        if _, err := GetChain(ctx, clients, v1alpha1.ChainResourceName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // TektonChain CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.ChainResourceName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // TektonChain CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TektonChain %q failed to delete: %v", v1alpha1.ChainResourceName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}

func GetChain(ctx context.Context, clients op.TektonChainInterface, name string) (*v1alpha1.TektonChain, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

func CreateChain(ctx context.Context, clients op.TektonChainInterface, tt *v1alpha1.TektonChain) error <span class="cov8" title="1">{
        _, err := clients.Create(ctx, tt, metav1.CreateOptions{})
        return err
}</span>

func UpdateChain(ctx context.Context, old *v1alpha1.TektonChain, new *v1alpha1.TektonChain, clients op.TektonChainInterface) (*v1alpha1.TektonChain, error) <span class="cov8" title="1">{
        // if the chain spec is changed then update the instance
        updated := false

        // initialize labels(map) object
        if old.ObjectMeta.Labels == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.Labels = map[string]string{}
        }</span>

        <span class="cov8" title="1">if new.Spec.TargetNamespace != old.Spec.TargetNamespace </span><span class="cov8" title="1">{
                old.Spec.TargetNamespace = new.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Chain, new.Spec.Chain) </span><span class="cov0" title="0">{
                old.Spec.Chain = new.Spec.Chain
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) </span><span class="cov0" title="0">{
                old.Spec.Config = new.Spec.Config
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Chain.Options, new.Spec.Chain.Options) </span><span class="cov0" title="0">{
                old.Spec.Chain.Options = new.Spec.Chain.Options
                updated = true
        }</span>

        <span class="cov8" title="1">if old.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences
                updated = true
        }</span>

        <span class="cov8" title="1">oldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        newLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        if !oldHasLabels || (newHasLabels &amp;&amp; oldLabels != newLabels) </span><span class="cov8" title="1">{
                old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, old, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }
        <span class="cov8" title="1">return old, nil</span>
}

// isTektonChainReady will check the status conditions of the TektonChain and return true if the TektonChain is ready.
func isTektonChainReady(s *v1alpha1.TektonChain) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), nil</span>
}

func GetTektonChainCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonChain <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
        return &amp;v1alpha1.TektonChain{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.ChainResourceName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                        Labels: map[string]string{
                                v1alpha1.ReleaseVersionKey: operatorVersion,
                        },
                },
                Spec: v1alpha1.TektonChainSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Config: config.Spec.Config,
                        Chain:  config.Spec.Chain,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file185" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "os"
        "regexp"

        "github.com/go-logr/zapr"
        mfc "github.com/manifestival/client-go-client"
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        tektonChaininformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonchain"
        tektonConfiginformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonconfig"
        tektonInstallerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektoninstallerset"
        tektonPipelineinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonpipeline"
        tektonResultinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektonresult"
        tektonTriggerinformer "github.com/tektoncd/operator/pkg/client/injection/informers/operator/v1alpha1/tektontrigger"
        tektonConfigreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonconfig"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade"
        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        namespaceinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/namespace"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
)

// NewExtensibleController returns a controller extended to a specific platform
func NewExtensibleController(generator common.ExtensionGenerator) injection.ControllerConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                logger := logging.FromContext(ctx)

                mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating client from injected config", zap.Error(err))
                }</span>
                <span class="cov0" title="0">mflogger := zapr.NewLogger(logger.Named("manifestival").Desugar())

                manifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalw("Error creating initial manifest", zap.Error(err))
                }</span>

                <span class="cov0" title="0">operatorVer, err := common.OperatorVersion(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal(err)
                }</span>

                <span class="cov0" title="0">c := &amp;Reconciler{
                        kubeClientSet:     kubeclient.Get(ctx),
                        operatorClientSet: operatorclient.Get(ctx),
                        extension:         generator(ctx),
                        manifest:          manifest,
                        operatorVersion:   operatorVer,
                }
                c.upgrade = upgrade.New(operatorVer, c.kubeClientSet, c.operatorClientSet, injection.GetConfig(ctx))

                impl := tektonConfigreconciler.NewImpl(ctx, c)

                logger.Debug("Setting up event handlers for TektonConfig")

                if _, err := tektonConfiginformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonConfig informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonPipelineinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonConfig{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonPipeline informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonTriggerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonConfig{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonTrigger informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonChaininformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonConfig{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonChain informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonResultinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonConfig{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonResult informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tektonInstallerinformer.Get(ctx).Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1alpha1.TektonConfig{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register TektonInstallerSet informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := namespaceinformer.Get(ctx).Informer().AddEventHandler(controller.HandleAll(enqueueCustomName(impl, v1alpha1.ConfigResourceName))); err != nil </span><span class="cov0" title="0">{
                        logger.Panicf("Couldn't register Namespace informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">if os.Getenv("AUTOINSTALL_COMPONENTS") == "true" </span><span class="cov0" title="0">{
                        // try to ensure that there is an instance of tektonConfig
                        newTektonConfig(operatorclient.Get(ctx), kubeclient.Get(ctx)).ensureInstance(ctx)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}

// enqueueCustomName adds an event with name `config` in work queue so that
// whenever a namespace event occurs, the TektonConfig reconciler get triggered.
// This is required because we want to get our TektonConfig reconciler triggered
// for already existing and new namespaces, without manual intervention like adding
// a label/annotation on namespace to make it manageable by Tekton controller.
// This will also filter the namespaces by regex `^(openshift|kube)-`
// and enqueue only when namespace doesn't match the regex
func enqueueCustomName(impl *controller.Impl, name string) func(obj interface{}) <span class="cov0" title="0">{
        return func(obj interface{}) </span><span class="cov0" title="0">{
                var nsRegex = regexp.MustCompile(common.NamespaceIgnorePattern)
                object, err := kmeta.DeletionHandlingAccessor(obj)
                if err == nil &amp;&amp; !nsRegex.MatchString(object.GetName()) </span><span class="cov0" title="0">{
                        impl.EnqueueKey(types.NamespacedName{Namespace: "", Name: name})
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file186" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "errors"
        "fmt"
        "path/filepath"
        "sync"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektoninstallerset"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
)

const (
        yamlDirNamePrunerManifest = "tekton-pruner"
        labelCreatedByValue       = "TektonConfig"
)

var (
        prunerInstallerSetLabel = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     labelCreatedByValue,
                        v1alpha1.InstallerSetType: v1alpha1.PrunerResourceName,
                },
        }

        prunerYamlDirHashFunc sync.Once
        prunerManifestHash    prunerManifestSpec
)

type prunerManifestSpec struct {
        YamlLocation    string
        ComputedHash    string // this hash value computed from the pruner resources directory
        TargetNamespace string
}

func (pms *prunerManifestSpec) GetHash() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%s", pms.TargetNamespace, pms.ComputedHash)
}</span>

// reconciles pruner InstallerSets
// for pruner we manage RBAC and ServiceAccount via installer sets
// RBAC and ServiceAccount details are in yaml file and it is located in "config/pruner/00-pruner.yaml"
// in the runtime container the directory will be as "$KO_DATA_PATH/tekton-pruner/"
func (r *Reconciler) reconcilePrunerInstallerSet(ctx context.Context, tc *v1alpha1.TektonConfig) error <span class="cov0" title="0">{
        // we have to calculate hash for the entire pruner yaml directory to confirm the changes.
        // reads all yaml files from the directory and computes hash, it is expensive process to access disk on each call.
        // hence calculate only once at startup, it helps not to degrade the performance of the reconcile loop
        // also it not necessary to read the files frequently, as the files are shipped along the container and never change
        prunerYamlDirHashFunc.Do(func() </span><span class="cov0" title="0">{
                yamlDirLocation := filepath.Join(common.ComponentBaseDir(), yamlDirNamePrunerManifest)
                computedHash, err := hash.ComputeHashDir(yamlDirLocation, "/tekton-pruner-")
                if err != nil </span><span class="cov0" title="0">{
                        logger := logging.FromContext(ctx)
                        logger.Errorw("error on calculating hash for pruner manifest yaml directory",
                                "directory", yamlDirLocation,
                                err,
                        )
                }</span>
                <span class="cov0" title="0">prunerManifestHash = prunerManifestSpec{
                        YamlLocation: yamlDirLocation,
                        ComputedHash: computedHash,
                }</span>
        })

        // update targetNamespace
        <span class="cov0" title="0">prunerManifestHash.TargetNamespace = tc.Spec.TargetNamespace

        // report error if the hash not calculated
        // actual error will be printer on the log from above func on the first call of this method
        if prunerManifestHash.ComputedHash == "" </span><span class="cov0" title="0">{
                return errors.New("error on calculation hash for pruner manifest yaml directory")
        }</span>

        // verify availability of pruner InstallerSet
        <span class="cov0" title="0">labelSelector, err := common.LabelSelector(prunerInstallerSetLabel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">actualInstallerSetName, err := tektoninstallerset.CurrentInstallerSetName(ctx, r.operatorClientSet, labelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">createInstallerSet := false
        if actualInstallerSetName == "" </span><span class="cov0" title="0">{
                // set create installerSet flag
                createInstallerSet = true
        }</span>

        <span class="cov0" title="0">if !createInstallerSet </span><span class="cov0" title="0">{
                // get the existing installerSet and compare the hash value
                // if it is mismatch, have to delete the old one and create new one with the supplied yaml file
                actualInstallerSet, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Get(ctx, actualInstallerSetName, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">appliedHash, found := actualInstallerSet.GetAnnotations()[v1alpha1.LastAppliedHashKey]
                if !found || prunerManifestHash.GetHash() != appliedHash </span><span class="cov0" title="0">{
                        // delete the existing installerSet
                        if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, actualInstallerSetName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // set create installerSet flag
                        <span class="cov0" title="0">createInstallerSet = true</span>
                }
        }

        <span class="cov0" title="0">if createInstallerSet </span><span class="cov0" title="0">{
                // create installerSet with changes
                return r.createPrunerInstallerSet(ctx, tc)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *Reconciler) createPrunerInstallerSet(ctx context.Context, tc *v1alpha1.TektonConfig) error <span class="cov0" title="0">{
        // get new manifest
        manifest := r.manifest.Append()

        // add resources to manifest from yaml files
        if err := common.AppendManifest(&amp;manifest, prunerManifestHash.YamlLocation); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // apply transformers
        <span class="cov0" title="0">if err := r.transformPruner(ctx, &amp;manifest, tc); err != nil </span><span class="cov0" title="0">{
                tc.Status.MarkNotReady("transformation failed: " + err.Error())
                return err
        }</span>

        // setup installerSet
        <span class="cov0" title="0">ownerRef := *metav1.NewControllerRef(tc, tc.GetGroupVersionKind())
        prunerInstallerSet := &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-", v1alpha1.PrunerResourceName),
                        Labels: map[string]string{
                                v1alpha1.CreatedByKey:      labelCreatedByValue,
                                v1alpha1.InstallerSetType:  v1alpha1.PrunerResourceName,
                                v1alpha1.ReleaseVersionKey: r.operatorVersion,
                        },
                        Annotations: map[string]string{
                                v1alpha1.TargetNamespaceKey: tc.Spec.TargetNamespace,
                                v1alpha1.LastAppliedHashKey: prunerManifestHash.GetHash(),
                        },
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        // include resources from manifest
                        Manifests: manifest.Resources(),
                },
        }

        // creates installerSet in the cluster
        _, err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().Create(ctx, prunerInstallerSet, metav1.CreateOptions{})
        return err</span>
}

// mutates the passed manifest with list of transformers
func (r *Reconciler) transformPruner(ctx context.Context, manifest *mf.Manifest, comp v1alpha1.TektonComponent) error <span class="cov0" title="0">{
        extra := []mf.Transformer{
                common.InjectOperandNameLabelOverwriteExisting(v1alpha1.PrunerResourceName),
        }
        extra = append(extra, r.extension.Transformers(comp)...)
        return common.Transform(ctx, manifest, comp, extra...)
}</span>
</pre>
		
		<pre class="file" id="file187" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "os"
        "time"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/logging"
)

const (
        // RetryInterval specifies the time between two polls.
        RetryInterval = 10 * time.Second

        // RetryTimeout specifies the timeout for the function PollImmediate to
        // reach a certain status.
        RetryTimeout = 5 * time.Minute

        // DefaultCRName specifies the default targetnamespaceto be used
        // in autocreated TektonConfig instance
        DefaultCRName = "config"
)

type tektonConfig struct {
        operatorClientSet versioned.Interface
        kubeClientSet     kubernetes.Interface
        namespace         string
}

func newTektonConfig(operatorClientSet versioned.Interface, kubeClientSet kubernetes.Interface) tektonConfig <span class="cov0" title="0">{

        return tektonConfig{
                operatorClientSet: operatorClientSet,
                kubeClientSet:     kubeClientSet,
                namespace:         os.Getenv("DEFAULT_TARGET_NAMESPACE"),
        }
}</span>

// try to ensure an instance of TektonConfig exists
// if there is an error log error,and continue (an instance of TektonConfig will
// then need to be created by the user to get Tekton Pipelines components installed
func (tc tektonConfig) ensureInstance(ctx context.Context) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        logger.Debugw("Ensuring TektonConfig instance exists")

        waitErr := wait.PollUntilContextTimeout(ctx, RetryInterval, RetryTimeout, true, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                //note: the code in this block will be retired until
                // an error is returned, or
                // 'true' is returned, or
                // timeout
                instance, err := tc.operatorClientSet.
                        OperatorV1alpha1().
                        TektonConfigs().Get(ctx, DefaultCRName, metav1.GetOptions{})
                if err == nil </span><span class="cov0" title="0">{
                        logger.Infow("Found existing TektonConfig instance",
                                "name", instance.GetName(),
                                "generation", instance.GetGeneration(),
                                "resourceVersion", instance.GetResourceVersion())
                        return true, nil
                }</span>
                <span class="cov0" title="0">if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        logger.Errorw("Error getting TektonConfig", "error", err)
                        return false, nil
                }</span>

                <span class="cov0" title="0">logger.Debugw("TektonConfig instance not found, creating new instance")
                err = tc.createInstance(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to create TektonConfig instance", "error", err)
                        return false, nil
                }</span>

                <span class="cov0" title="0">logger.Infow("TektonConfig instance created, verifying on next iteration")
                // even if there is no error after create,
                // loop again to ensure the create is successful with a 'get; api call
                return false, nil</span>
        })

        <span class="cov0" title="0">if waitErr != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to ensure TektonConfig instance exists after timeout",
                        "retryInterval", RetryInterval.String(),
                        "timeout", RetryTimeout.String(),
                        "error", waitErr)
                logger.Warnw("TektonConfig instance must be created manually to install Pipelines components")
        }</span> else<span class="cov0" title="0"> {
                logger.Infow("Successfully ensured TektonConfig instance exists")
        }</span>
}

func (tc tektonConfig) createInstance(ctx context.Context) error <span class="cov0" title="0">{
        pruneKeep := v1alpha1.PrunerDefaultKeep
        tcCR := &amp;v1alpha1.TektonConfig{
                ObjectMeta: metav1.ObjectMeta{
                        Name: v1alpha1.ConfigResourceName,
                },
                Spec: v1alpha1.TektonConfigSpec{
                        Profile: v1alpha1.ProfileAll,
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: tc.namespace,
                        },
                        Pruner: v1alpha1.Prune{
                                Disabled:  false,
                                Resources: v1alpha1.PruningDefaultResources,
                                Keep:      &amp;pruneKeep,
                                KeepSince: nil,
                                Schedule:  v1alpha1.PrunerDefaultSchedule,
                        },
                },
        }
        tcCR.SetDefaults(ctx)
        _, err := tc.operatorClientSet.OperatorV1alpha1().
                TektonConfigs().Create(ctx, tcCR, metav1.CreateOptions{})
        return err
}</span>
</pre>
		
		<pre class="file" id="file188" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipeline

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "knative.dev/pkg/apis"

        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func EnsureTektonPipelineExists(ctx context.Context, clients op.TektonPipelineInterface, tp *v1alpha1.TektonPipeline) (*v1alpha1.TektonPipeline, error) <span class="cov8" title="1">{
        tpCR, err := GetPipeline(ctx, clients, v1alpha1.PipelineResourceName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := CreatePipeline(ctx, clients, tp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">tpCR, err = UpdatePipeline(ctx, tpCR, tp, clients)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ok, err := isTektonPipelineReady(tpCR, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return tpCR, err</span>
}

func GetPipeline(ctx context.Context, clients op.TektonPipelineInterface, name string) (*v1alpha1.TektonPipeline, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

func GetTektonPipelineCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonPipeline <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
        return &amp;v1alpha1.TektonPipeline{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.PipelineResourceName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                        Labels: map[string]string{
                                v1alpha1.ReleaseVersionKey: operatorVersion,
                        },
                },
                Spec: v1alpha1.TektonPipelineSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Pipeline: config.Spec.Pipeline,
                        Config:   config.Spec.Config,
                },
        }
}</span>

func CreatePipeline(ctx context.Context, clients op.TektonPipelineInterface, tp *v1alpha1.TektonPipeline) error <span class="cov8" title="1">{
        _, err := clients.Create(ctx, tp, metav1.CreateOptions{})
        return err
}</span>

func UpdatePipeline(ctx context.Context, old *v1alpha1.TektonPipeline, new *v1alpha1.TektonPipeline, clients op.TektonPipelineInterface) (*v1alpha1.TektonPipeline, error) <span class="cov8" title="1">{
        // if the pipeline spec is changed then update the instance
        updated := false

        // initialize labels(map) object
        if old.ObjectMeta.Labels == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.Labels = map[string]string{}
        }</span>

        <span class="cov8" title="1">if new.Spec.TargetNamespace != old.Spec.TargetNamespace </span><span class="cov8" title="1">{
                old.Spec.TargetNamespace = new.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Pipeline, new.Spec.Pipeline) </span><span class="cov0" title="0">{
                old.Spec.Pipeline = new.Spec.Pipeline
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) </span><span class="cov0" title="0">{
                old.Spec.Config = new.Spec.Config
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Performance, new.Spec.Performance) </span><span class="cov0" title="0">{
                old.Spec.Performance = new.Spec.Performance
                updated = true
        }</span>

        <span class="cov8" title="1">if old.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences
                updated = true
        }</span>

        <span class="cov8" title="1">oldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        newLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        if !oldHasLabels || (newHasLabels &amp;&amp; oldLabels != newLabels) </span><span class="cov8" title="1">{
                old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Options, new.Spec.Options) </span><span class="cov0" title="0">{
                old.Spec.Options = new.Spec.Options
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, old, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }
        <span class="cov8" title="1">return old, nil</span>
}

// IsTektonPipelineReady will check the status conditions of the TektonPipeline and return true if the TektonPipeline is ready.
func isTektonPipelineReady(s *v1alpha1.TektonPipeline, err error) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), err</span>
}

func GetTektonConfig() *v1alpha1.TektonConfig <span class="cov8" title="1">{
        return &amp;v1alpha1.TektonConfig{
                ObjectMeta: metav1.ObjectMeta{
                        Name: v1alpha1.ConfigResourceName,
                },
                Spec: v1alpha1.TektonConfigSpec{
                        Profile: "all",
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: "tekton-pipelines",
                        },
                },
        }
}</span>

func EnsureTektonPipelineCRNotExists(ctx context.Context, clients op.TektonPipelineInterface) error <span class="cov8" title="1">{
        if _, err := GetPipeline(ctx, clients, v1alpha1.PipelineResourceName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // TektonPipeline CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.PipelineResourceName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // TektonPipeline CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TektonPipeline %q failed to delete: %v", v1alpha1.PipelineResourceName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file189" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pruner

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"

        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

func EnsureTektonPrunerExists(ctx context.Context, clients op.TektonPrunerInterface, tp *v1alpha1.TektonPruner) (*v1alpha1.TektonPruner, error) <span class="cov8" title="1">{
        tpCR, err := GetPruner(ctx, clients, v1alpha1.TektonPrunerResourceName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := CreatePruner(ctx, clients, tp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">tpCR, err = UpdatePruner(ctx, tpCR, tp, clients)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ok, err := isTektonPrunerReady(tpCR, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return tpCR, err</span>
}

func GetPruner(ctx context.Context, clients op.TektonPrunerInterface, name string) (*v1alpha1.TektonPruner, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

func GetTektonPrunerCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonPruner <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
        return &amp;v1alpha1.TektonPruner{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.TektonPrunerResourceName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                        Labels: map[string]string{
                                v1alpha1.ReleaseVersionKey: operatorVersion,
                        },
                },
                Spec: v1alpha1.TektonPrunerSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Config: config.Spec.Config,
                        Pruner: config.Spec.TektonPruner,
                },
        }
}</span>

func CreatePruner(ctx context.Context, clients op.TektonPrunerInterface, tp *v1alpha1.TektonPruner) error <span class="cov8" title="1">{
        _, err := clients.Create(ctx, tp, metav1.CreateOptions{})
        return err
}</span>

func UpdatePruner(ctx context.Context, old *v1alpha1.TektonPruner, new *v1alpha1.TektonPruner, clients op.TektonPrunerInterface) (*v1alpha1.TektonPruner, error) <span class="cov8" title="1">{
        // if the pruner spec is changed then update the instance
        updated := false
        // initialize labels(map) object
        if old.ObjectMeta.Labels == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.Labels = map[string]string{}
        }</span>

        <span class="cov8" title="1">if new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] != old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] </span><span class="cov8" title="1">{
                old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
                updated = true
        }</span>

        <span class="cov8" title="1">if new.Spec.TargetNamespace != old.Spec.TargetNamespace </span><span class="cov8" title="1">{
                old.Spec.TargetNamespace = new.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Pruner, new.Spec.Pruner) </span><span class="cov0" title="0">{
                old.Spec.Pruner = new.Spec.Pruner
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) </span><span class="cov0" title="0">{
                old.Spec.Config = new.Spec.Config
                updated = true
        }</span>

        <span class="cov8" title="1">if old.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences
                updated = true
        }</span>

        <span class="cov8" title="1">oldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        newLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        if !oldHasLabels || (newHasLabels &amp;&amp; oldLabels != newLabels) </span><span class="cov0" title="0">{
                old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, old, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }
        <span class="cov8" title="1">return old, nil</span>
}

// isTektonPrunerReady will check the status conditions of the TektonPruner and return true if the TektonPruner is ready.
func isTektonPrunerReady(s *v1alpha1.TektonPruner, err error) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), err</span>
}

func EnsureTektonPrunerCRNotExists(ctx context.Context, clients op.TektonPrunerInterface) error <span class="cov8" title="1">{
        if _, err := GetPruner(ctx, clients, v1alpha1.TektonPrunerResourceName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // TektonPruner CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.TektonPrunerResourceName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // TektonPruner CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TektonPruner %q failed to delete: %v", v1alpha1.TektonPrunerResourceName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file190" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package result

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// This Ensure TektonResult CR is exist or not
// if it exist then update it otherwise creates a new TektonResult CR
func EnsureTektonResultExists(ctx context.Context, clients op.TektonResultInterface, tr *v1alpha1.TektonResult) (*v1alpha1.TektonResult, error) <span class="cov8" title="1">{
        trCR, err := GetResult(ctx, clients, v1alpha1.ResultResourceName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := CreateResult(ctx, clients, tr); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">trCR, err = UpdateResult(ctx, trCR, tr, clients)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ready, err := isTektonResultReady(trCR)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !ready </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return trCR, err</span>
}

// This Ensure TektonResult CR is deleted successfully
func EnsureTektonResultCRNotExists(ctx context.Context, clients op.TektonResultInterface) error <span class="cov8" title="1">{
        if _, err := GetResult(ctx, clients, v1alpha1.ResultResourceName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // TektonResult CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.ResultResourceName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // TektonResult CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TektonResult %q failed to delete: %v", v1alpha1.ResultResourceName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}

// Get the TektonResult CR
func GetResult(ctx context.Context, clients op.TektonResultInterface, name string) (*v1alpha1.TektonResult, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

// Create the TektonResult CR
func CreateResult(ctx context.Context, clients op.TektonResultInterface, tr *v1alpha1.TektonResult) error <span class="cov8" title="1">{
        _, err := clients.Create(ctx, tr, metav1.CreateOptions{})
        return err
}</span>

func isTektonResultReady(s *v1alpha1.TektonResult) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), nil</span>
}

// This update the existing TektonResult CR with updated TektonResult CR
func UpdateResult(ctx context.Context, old *v1alpha1.TektonResult, new *v1alpha1.TektonResult, clients op.TektonResultInterface) (*v1alpha1.TektonResult, error) <span class="cov8" title="1">{
        // if the result spec is changed then update the instance
        updated := false

        // initialize labels(map) object
        if old.ObjectMeta.Labels == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.Labels = map[string]string{}
        }</span>

        <span class="cov8" title="1">if new.Spec.TargetNamespace != old.Spec.TargetNamespace </span><span class="cov8" title="1">{
                old.Spec.TargetNamespace = new.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.ResultsAPIProperties, new.Spec.ResultsAPIProperties) </span><span class="cov0" title="0">{
                old.Spec.ResultsAPIProperties = new.Spec.ResultsAPIProperties
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.LokiStackProperties, new.Spec.LokiStackProperties) </span><span class="cov0" title="0">{
                old.Spec.LokiStackProperties = new.Spec.LokiStackProperties
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Options, new.Spec.Options) </span><span class="cov0" title="0">{
                old.Spec.Options = new.Spec.Options
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Performance, new.Spec.Performance) </span><span class="cov0" title="0">{
                old.Spec.Performance = new.Spec.Performance
                updated = true
        }</span>

        <span class="cov8" title="1">if old.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences
                updated = true
        }</span>

        <span class="cov8" title="1">oldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        newLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        if !oldHasLabels || (newHasLabels &amp;&amp; oldLabels != newLabels) </span><span class="cov8" title="1">{
                old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, old, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }
        <span class="cov8" title="1">return old, nil</span>
}

// GetTektonResultCR create a TektonResult CR
func GetTektonResultCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonResult <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
        return &amp;v1alpha1.TektonResult{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.ResultResourceName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                        Labels: map[string]string{
                                v1alpha1.ReleaseVersionKey: operatorVersion,
                        },
                },
                Spec: v1alpha1.TektonResultSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Result: config.Spec.Result,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file191" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektonconfig

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        tektonConfigreconciler "github.com/tektoncd/operator/pkg/client/injection/reconciler/operator/v1alpha1/tektonconfig"
        "github.com/tektoncd/operator/pkg/reconciler/common"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/chain"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/pipeline"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/pruner"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/result"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/trigger"
        "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

// Reconciler implements controller.Reconciler for TektonConfig resources.
type Reconciler struct {
        // kubeClientSet allows us to talk to the k8s for core APIs
        kubeClientSet kubernetes.Interface
        // operatorClientSet allows us to configure operator objects
        operatorClientSet clientset.Interface
        // Platform-specific behavior to affect the transform
        extension       common.Extension
        manifest        mf.Manifest
        operatorVersion string
        // performs pre and post upgrade operations
        upgrade *upgrade.Upgrade
}

// Check that our Reconciler implements controller.Reconciler
var (
        _ tektonConfigreconciler.Interface = (*Reconciler)(nil)
        _ tektonConfigreconciler.Finalizer = (*Reconciler)(nil)
)

// FinalizeKind removes all resources after deletion of a TektonConfig.
func (r *Reconciler) FinalizeKind(ctx context.Context, original *v1alpha1.TektonConfig) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        if err := r.extension.Finalize(ctx, original); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to finalize platform resources", err)
        }</span>

        <span class="cov0" title="0">if original.Spec.Profile == v1alpha1.ProfileLite </span><span class="cov0" title="0">{
                return pipeline.EnsureTektonPipelineCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPipelines())
        }</span> else<span class="cov0" title="0"> {
                // TektonPipeline and TektonTrigger is common for profile type basic and all
                if err := trigger.EnsureTektonTriggerCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonTriggers()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := chain.EnsureTektonChainCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonChains()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := result.EnsureTektonResultCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonResults()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := pipeline.EnsureTektonPipelineCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPipelines()); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // remove pruner tektonInstallerSet
        <span class="cov0" title="0">labelSelector, err := common.LabelSelector(prunerInstallerSetLabel)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err := r.operatorClientSet.OperatorV1alpha1().TektonInstallerSets().DeleteCollection(
                ctx,
                metav1.DeleteOptions{},
                metav1.ListOptions{LabelSelector: labelSelector},
        ); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to delete pruner installerSet", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, tc *v1alpha1.TektonConfig) pkgreconciler.Event <span class="cov0" title="0">{
        logger := logging.FromContext(ctx).With("tektonconfig", tc.Name)
        tc.Status.InitializeConditions()
        tc.Status.SetVersion(r.operatorVersion)

        logger.Debugw("Starting TektonConfig reconciliation",
                "version", r.operatorVersion,
                "profile", tc.Spec.Profile,
                "status", tc.Status.GetCondition(apis.ConditionReady))

        if tc.GetName() != v1alpha1.ConfigResourceName </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("Resource ignored, Expected Name: %s, Got Name: %s",
                        v1alpha1.ConfigResourceName,
                        tc.GetName(),
                )
                logger.Errorw("Invalid resource name", "expectedName", v1alpha1.ConfigResourceName, "actualName", tc.GetName())
                tc.Status.MarkNotReady(msg)
                return nil
        }</span>

        // run pre upgrade
        <span class="cov0" title="0">if err := r.upgrade.RunPreUpgrade(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Pre-upgrade failed", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Pre-upgrade completed successfully")

        // Mark TektonConfig Instance as Not Ready if an upgrade is needed
        if err := r.markUpgrade(ctx, tc); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to mark upgrade status", "error", err)
                return err
        }</span>

        // reconcile target namespace
        <span class="cov0" title="0">nsMetaLabels := map[string]string{}
        nsMetaAnnotations := map[string]string{}
        if tc.Spec.TargetNamespaceMetadata != nil </span><span class="cov0" title="0">{
                nsMetaLabels = tc.Spec.TargetNamespaceMetadata.Labels
                nsMetaAnnotations = tc.Spec.TargetNamespaceMetadata.Annotations
        }</span>
        <span class="cov0" title="0">logger.Debugw("Reconciling target namespace",
                "labelCount", len(nsMetaLabels),
                "annotationCount", len(nsMetaAnnotations))

        if err := common.ReconcileTargetNamespace(ctx, nsMetaLabels, nsMetaAnnotations, tc, r.kubeClientSet); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to reconcile target namespace", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Target namespace reconciled successfully")

        // Pre-reconcile extension hooks
        if err := r.extension.PreReconcile(ctx, tc); err != nil </span><span class="cov0" title="0">{
                if err == v1alpha1.RECONCILE_AGAIN_ERR </span><span class="cov0" title="0">{
                        logger.Infow("Extensions requested requeue")
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">logger.Errorw("Pre-install hook failed", "error", err)
                tc.Status.MarkPreInstallFailed(err.Error())
                return err</span>
        }

        <span class="cov0" title="0">tc.Status.MarkPreInstallComplete()
        logger.Debug("Pre-install completed successfully")

        // Ensure Pipeline CR
        tektonpipeline := pipeline.GetTektonPipelineCR(tc, r.operatorVersion)
        logger.Debug("Ensuring TektonPipeline CR exists")
        if _, err := pipeline.EnsureTektonPipelineExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPipelines(), tektonpipeline); err != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("TektonPipeline: %s", err.Error())
                logger.Errorw("Failed to ensure TektonPipeline exists", "error", err)
                tc.Status.MarkComponentNotReady(errMsg)
                if err == v1alpha1.RECONCILE_AGAIN_ERR </span><span class="cov0" title="0">{
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">logger.Debug("TektonPipeline CR reconciled successfully")

        // Start Event based Pruner only if old Job based Pruner is Disabled.
        if tc.Spec.TektonPruner.IsDisabled() </span><span class="cov0" title="0">{
                logger.Infof("TektonPruner is disabled. Shutting down event based pruner")
                if err := pruner.EnsureTektonPrunerCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPruners()); err != nil </span><span class="cov0" title="0">{
                        tc.Status.MarkComponentNotReady(fmt.Sprintf("TektonPruner: %s", err.Error()))
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
        } else<span class="cov0" title="0"> if !tc.Spec.Pruner.Disabled </span><span class="cov0" title="0">{
                msg := "Invalid Pruner Configuration!! Both pruners, tektonpruner(event based) and pruner(job based) cannot be enabled simultaneously. Please disable one of them."
                logger.Error(msg)
                tc.Status.MarkComponentNotReady(msg)
                return v1alpha1.REQUEUE_EVENT_AFTER
        }</span> else<span class="cov0" title="0"> {
                logger.Infof("TektonPruner is enabled.Creating TektonPipeline CR")
                tektonPruner := pruner.GetTektonPrunerCR(tc, r.operatorVersion)
                if _, err := pruner.EnsureTektonPrunerExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonPruners(), tektonPruner); err != nil </span><span class="cov0" title="0">{
                        tc.Status.MarkComponentNotReady(fmt.Sprintf("TektonPruner %s", err.Error()))
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
        }

        // Ensure Pipeline Trigger
        <span class="cov0" title="0">if !tc.Spec.Trigger.Disabled &amp;&amp; (tc.Spec.Profile == v1alpha1.ProfileAll || tc.Spec.Profile == v1alpha1.ProfileBasic) </span><span class="cov0" title="0">{
                tektontrigger := trigger.GetTektonTriggerCR(tc, r.operatorVersion)
                logger.Debug("Ensuring TektonTrigger CR exists")
                if _, err := trigger.EnsureTektonTriggerExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonTriggers(), tektontrigger); err != nil </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("TektonTrigger: %s", err.Error())
                        logger.Errorw("Failed to ensure TektonTrigger exists", "error", err)
                        tc.Status.MarkComponentNotReady(errMsg)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">logger.Debug("TektonTrigger CR reconciled successfully")</span>
        } else<span class="cov0" title="0"> {
                logger.Debugw("Ensuring TektonTrigger CR doesn't exist", "profile", tc.Spec.Profile, "triggerDisabled", tc.Spec.Trigger.Disabled)
                if err := trigger.EnsureTektonTriggerCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonTriggers()); err != nil </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("TektonTrigger: %s", err.Error())
                        logger.Errorw("Failed to ensure TektonTrigger has been deleted", "error", err)
                        tc.Status.MarkComponentNotReady(errMsg)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">logger.Debug("TektonTrigger CR removal reconciled successfully")</span>
        }

        // Ensure Chain CR
        <span class="cov0" title="0">if !tc.Spec.Chain.Disabled </span><span class="cov0" title="0">{
                tektonchain := chain.GetTektonChainCR(tc, r.operatorVersion)
                logger.Debug("Ensuring TektonChain CR exists")
                if _, err := chain.EnsureTektonChainExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonChains(), tektonchain); err != nil </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("TektonChain: %s", err.Error())
                        logger.Errorw("Failed to ensure TektonChain exists", "error", err)
                        tc.Status.MarkComponentNotReady(errMsg)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">logger.Debug("TektonChain CR reconciled successfully")</span>
        } else<span class="cov0" title="0"> {
                logger.Debugw("Ensuring TektonChain CR doesn't exist", "chainDisabled", tc.Spec.Chain.Disabled)
                if err := chain.EnsureTektonChainCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonChains()); err != nil </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("TektonChain: %s", err.Error())
                        logger.Errorw("Failed to ensure TektonChain has been deleted", "error", err)
                        tc.Status.MarkComponentNotReady(errMsg)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">logger.Debug("TektonChain CR removal reconciled successfully")</span>
        }

        // Ensure Result CR
        <span class="cov0" title="0">if !tc.Spec.Result.Disabled </span><span class="cov0" title="0">{
                tektonresult := result.GetTektonResultCR(tc, r.operatorVersion)
                logger.Debug("Ensuring TektonResult CR exists")
                if _, err := result.EnsureTektonResultExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonResults(), tektonresult); err != nil </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("TektonResult %s", err.Error())
                        logger.Errorw("Failed to ensure TektonResult exists", "error", err)
                        tc.Status.MarkComponentNotReady(errMsg)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">logger.Debug("TektonResult CR reconciled successfully")</span>
        } else<span class="cov0" title="0"> {
                logger.Debugw("Ensuring TektonResult CR doesn't exist", "resultDisabled", tc.Spec.Result.Disabled)
                if err := result.EnsureTektonResultCRNotExists(ctx, r.operatorClientSet.OperatorV1alpha1().TektonResults()); err != nil </span><span class="cov0" title="0">{
                        errMsg := fmt.Sprintf("TektonResult: %s", err.Error())
                        logger.Errorw("Failed to ensure TektonResult has been deleted", "error", err)
                        tc.Status.MarkComponentNotReady(errMsg)
                        return v1alpha1.REQUEUE_EVENT_AFTER
                }</span>
                <span class="cov0" title="0">logger.Debug("TektonResult CR removal reconciled successfully")</span>
        }

        // Ensure Pruner
        <span class="cov0" title="0">if !tc.Spec.Pruner.Disabled </span><span class="cov0" title="0">{
                logger.Debugw("Reconciling pruner installer set", "prunerDisabled", tc.Spec.Pruner.Disabled)
                err := r.reconcilePrunerInstallerSet(ctx, tc)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to reconcile pruner installer set", "error", err)
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debug("Pruner installer set reconciled successfully")</span>
        }

        // Run resource pruning
        <span class="cov0" title="0">if err := common.Prune(ctx, r.kubeClientSet, tc); err != nil </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("tekton-resource-pruner: %s", err.Error())
                logger.Errorw("Resource pruning failed", "error", err)
                tc.Status.MarkComponentNotReady(errMsg)
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Resource pruning completed successfully")
        }</span>

        <span class="cov0" title="0">tc.Status.MarkComponentsReady()
        logger.Debug("All components marked ready")

        // Post-reconcile extension hooks
        if err := r.extension.PostReconcile(ctx, tc); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Post-reconcile hook failed", "error", err)
                return err
        }</span>

        <span class="cov0" title="0">tc.Status.MarkPostInstallComplete()
        logger.Debug("Post-install completed successfully")

        // Update the object for any spec changes
        logger.Debug("Updating TektonConfig status")
        if _, err := r.operatorClientSet.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, tc, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to update TektonConfig status", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("TektonConfig status updated successfully")

        // run post upgrade
        if err := r.upgrade.RunPostUpgrade(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Post-upgrade failed", "error", err)
                return err
        }</span>
        <span class="cov0" title="0">logger.Debug("Post-upgrade completed successfully")

        logger.Debugw("TektonConfig reconciliation completed successfully",
                "status", tc.Status.GetCondition(apis.ConditionReady))
        return nil</span>
}

func (r *Reconciler) markUpgrade(ctx context.Context, tc *v1alpha1.TektonConfig) error <span class="cov0" title="0">{
        labels := tc.GetLabels()
        ver, ok := labels[v1alpha1.ReleaseVersionKey]
        if ok &amp;&amp; ver == r.operatorVersion </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if ok &amp;&amp; ver != r.operatorVersion </span><span class="cov0" title="0">{
                tc.Status.MarkComponentNotReady("Upgrade Pending")
                tc.Status.MarkPreInstallFailed(v1alpha1.UpgradePending)
                tc.Status.MarkPostInstallFailed(v1alpha1.UpgradePending)
                tc.Status.MarkNotReady("Upgrade Pending")
        }</span>
        <span class="cov0" title="0">if labels == nil </span><span class="cov0" title="0">{
                labels = map[string]string{}
        }</span>
        <span class="cov0" title="0">labels[v1alpha1.ReleaseVersionKey] = r.operatorVersion
        tc.SetLabels(labels)

        // Update the object for any spec changes
        if _, err := r.operatorClientSet.OperatorV1alpha1().TektonConfigs().Update(ctx, tc, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file192" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package trigger

import (
        "context"
        "fmt"
        "reflect"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        op "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

func EnsureTektonTriggerExists(ctx context.Context, clients op.TektonTriggerInterface, tt *v1alpha1.TektonTrigger) (*v1alpha1.TektonTrigger, error) <span class="cov8" title="1">{
        ttCR, err := GetTrigger(ctx, clients, v1alpha1.TriggerResourceName)
        if err != nil </span><span class="cov8" title="1">{
                if !apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := CreateTrigger(ctx, clients, tt); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }

        <span class="cov8" title="1">ttCR, err = UpdateTrigger(ctx, ttCR, tt, clients)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ok, err := isTektonTriggerReady(ttCR, err)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return nil, v1alpha1.RECONCILE_AGAIN_ERR
        }</span>

        <span class="cov8" title="1">return ttCR, err</span>
}

func GetTrigger(ctx context.Context, clients op.TektonTriggerInterface, name string) (*v1alpha1.TektonTrigger, error) <span class="cov8" title="1">{
        return clients.Get(ctx, name, metav1.GetOptions{})
}</span>

func GetTektonTriggerCR(config *v1alpha1.TektonConfig, operatorVersion string) *v1alpha1.TektonTrigger <span class="cov8" title="1">{
        ownerRef := *metav1.NewControllerRef(config, config.GroupVersionKind())
        return &amp;v1alpha1.TektonTrigger{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            v1alpha1.TriggerResourceName,
                        OwnerReferences: []metav1.OwnerReference{ownerRef},
                        Labels: map[string]string{
                                v1alpha1.ReleaseVersionKey: operatorVersion,
                        },
                },
                Spec: v1alpha1.TektonTriggerSpec{
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: config.Spec.TargetNamespace,
                        },
                        Config:  config.Spec.Config,
                        Trigger: config.Spec.Trigger,
                },
        }
}</span>

func CreateTrigger(ctx context.Context, clients op.TektonTriggerInterface, tt *v1alpha1.TektonTrigger) error <span class="cov8" title="1">{
        _, err := clients.Create(ctx, tt, metav1.CreateOptions{})
        return err
}</span>

func UpdateTrigger(ctx context.Context, old *v1alpha1.TektonTrigger, new *v1alpha1.TektonTrigger, clients op.TektonTriggerInterface) (*v1alpha1.TektonTrigger, error) <span class="cov8" title="1">{
        // if the trigger spec is changed then update the instance
        updated := false

        // initialize labels(map) object
        if old.ObjectMeta.Labels == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.Labels = map[string]string{}
        }</span>

        <span class="cov8" title="1">if new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] != old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] </span><span class="cov8" title="1">{
                old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
                updated = true
        }</span>

        <span class="cov8" title="1">if new.Spec.TargetNamespace != old.Spec.TargetNamespace </span><span class="cov8" title="1">{
                old.Spec.TargetNamespace = new.Spec.TargetNamespace
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Trigger, new.Spec.Trigger) </span><span class="cov0" title="0">{
                old.Spec.Trigger = new.Spec.Trigger
                updated = true
        }</span>

        <span class="cov8" title="1">if !reflect.DeepEqual(old.Spec.Config, new.Spec.Config) </span><span class="cov0" title="0">{
                old.Spec.Config = new.Spec.Config
                updated = true
        }</span>

        <span class="cov8" title="1">if old.ObjectMeta.OwnerReferences == nil </span><span class="cov0" title="0">{
                old.ObjectMeta.OwnerReferences = new.ObjectMeta.OwnerReferences
                updated = true
        }</span>

        <span class="cov8" title="1">oldLabels, oldHasLabels := old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        newLabels, newHasLabels := new.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey]
        if !oldHasLabels || (newHasLabels &amp;&amp; oldLabels != newLabels) </span><span class="cov0" title="0">{
                old.ObjectMeta.Labels[v1alpha1.ReleaseVersionKey] = newLabels
                updated = true
        }</span>

        <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                _, err := clients.Update(ctx, old, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return nil, v1alpha1.RECONCILE_AGAIN_ERR</span>
        }
        <span class="cov8" title="1">return old, nil</span>
}

// isTektonTriggerReady will check the status conditions of the TektonTrigger and return true if the TektonTrigger is ready.
func isTektonTriggerReady(s *v1alpha1.TektonTrigger, err error) (bool, error) <span class="cov8" title="1">{
        if s.GetStatus() != nil &amp;&amp; s.GetStatus().GetCondition(apis.ConditionReady) != nil </span><span class="cov8" title="1">{
                if strings.Contains(s.GetStatus().GetCondition(apis.ConditionReady).Message, v1alpha1.UpgradePending) </span><span class="cov0" title="0">{
                        return false, v1alpha1.DEPENDENCY_UPGRADE_PENDING_ERR
                }</span>
        }
        <span class="cov8" title="1">return s.Status.IsReady(), err</span>
}

func GetTektonConfig() *v1alpha1.TektonConfig <span class="cov8" title="1">{
        return &amp;v1alpha1.TektonConfig{
                ObjectMeta: metav1.ObjectMeta{
                        Name: v1alpha1.ConfigResourceName,
                },
                Spec: v1alpha1.TektonConfigSpec{
                        Profile: "all",
                        CommonSpec: v1alpha1.CommonSpec{
                                TargetNamespace: "tekton-pipelines",
                        },
                },
        }
}</span>

func EnsureTektonTriggerCRNotExists(ctx context.Context, clients op.TektonTriggerInterface) error <span class="cov8" title="1">{
        if _, err := GetTrigger(ctx, clients, v1alpha1.TriggerResourceName); err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        // TektonTrigger CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        // if the Get was successful, try deleting the CR
        <span class="cov8" title="1">if err := clients.Delete(ctx, v1alpha1.TriggerResourceName, metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        // TektonTrigger CR is gone, hence return nil
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("TektonTrigger %q failed to delete: %v", v1alpha1.TriggerResourceName, err)</span>
        }
        // if the Delete API call was success,
        // then return requeue_event
        // so that in a subsequent reconcile call the absence of the CR is verified by one of the 2 checks above
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// copied from: https://github.com/knative/pkg/blob/2783cd8cfad9ba907e6f31cafeef3eb2943424ee/apiextensions/storageversion/migrator.go
// local changes: continue the execution even though error happens on patching a resource
//---

package upgrade

import (
        "context"
        "fmt"

        "go.uber.org/zap"
        apix "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        apixclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/tools/pager"
)

// Migrator will read custom resource definitions and upgrade
// the associated resources to the latest storage version
type Migrator struct {
        dynamicClient dynamic.Interface
        apixClient    apixclient.Interface
        logger        *zap.SugaredLogger
}

// NewMigrator will return a new Migrator
func NewMigrator(d dynamic.Interface, a apixclient.Interface, logger *zap.SugaredLogger) *Migrator <span class="cov8" title="1">{
        return &amp;Migrator{
                dynamicClient: d,
                apixClient:    a,
                logger:        logger,
        }
}</span>

// Migrate takes a group resource (ie. resource.some.group.dev) and
// updates instances of the resource to the latest storage version
//
// This is done by listing all the resources and performing an empty patch
// which triggers a migration on the K8s API server
//
// Finally the migrator will update the CRD's status and drop older storage
// versions
func (m *Migrator) Migrate(ctx context.Context, gr schema.GroupResource) error <span class="cov8" title="1">{
        crdClient := m.apixClient.ApiextensionsV1().CustomResourceDefinitions()

        crd, err := crdClient.Get(ctx, gr.String(), metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to fetch crd %s - %w", gr, err)
        }</span>

        <span class="cov8" title="1">version := storageVersion(crd)

        if version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to determine storage version for %s", gr)
        }</span>

        <span class="cov8" title="1">if err := m.migrateResources(ctx, gr.WithVersion(version)); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">patch := `{"status":{"storedVersions":["` + version + `"]}}`
        _, err = crdClient.Patch(ctx, crd.Name, types.StrategicMergePatchType, []byte(patch), metav1.PatchOptions{}, "status")
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("unable to drop storage version definition %s - %w", gr, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *Migrator) migrateResources(ctx context.Context, gvr schema.GroupVersionResource) error <span class="cov8" title="1">{
        client := m.dynamicClient.Resource(gvr)

        listFunc := func(ctx context.Context, opts metav1.ListOptions) (runtime.Object, error) </span><span class="cov8" title="1">{
                return client.Namespace(metav1.NamespaceAll).List(ctx, opts)
        }</span>

        <span class="cov8" title="1">onEach := func(obj runtime.Object) error </span><span class="cov8" title="1">{
                item := obj.(metav1.Object)

                _, err := client.Namespace(item.GetNamespace()).
                        Patch(ctx, item.GetName(), types.MergePatchType, []byte("{}"), metav1.PatchOptions{})

                if err != nil &amp;&amp; !apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        m.logger.Errorw("unable to patch a resource",
                                "resourceName", item.GetName(),
                                "namespace", item.GetNamespace(),
                                "groupVersionResource", gvr,
                                err,
                        )
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">pager := pager.New(listFunc)
        return pager.EachListItem(ctx, metav1.ListOptions{}, onEach)</span>
}

func storageVersion(crd *apix.CustomResourceDefinition) string <span class="cov8" title="1">{
        var version string

        for _, v := range crd.Spec.Versions </span><span class="cov8" title="1">{
                if v.Storage </span><span class="cov8" title="1">{
                        version = v.Name
                        break</span>
                }
        }

        <span class="cov8" title="1">return version</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package upgrade

import (
        "context"

        "go.uber.org/zap"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// performs crd storage version upgrade
// lists all the resources and,
// keeps only one storage version on the crd
// continues the execution, even though exception happens
func MigrateStorageVersion(ctx context.Context, logger *zap.SugaredLogger, migrator *Migrator, crdGroups []string) <span class="cov8" title="1">{
        logger.Infof("migrating %d group resources", len(crdGroups))

        for _, crdGroupString := range crdGroups </span><span class="cov8" title="1">{
                crdGroup := schema.ParseGroupResource(crdGroupString)
                if crdGroup.Empty() </span><span class="cov0" title="0">{
                        logger.Errorf("unable to parse group version: '%s'", crdGroupString)
                        continue</span>
                }
                <span class="cov8" title="1">logger.Infow("migrating group resource", "crdGroup", crdGroup)
                if err := migrator.Migrate(ctx, crdGroup); err != nil </span><span class="cov8" title="1">{
                        if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                                logger.Infow("ignoring resource migration - unable to fetch a crdGroup",
                                        "crdGroup", crdGroup,
                                        err,
                                )
                                continue</span>
                        }
                        <span class="cov0" title="0">logger.Errorw("failed to migrate a crdGroup",
                                "crdGroup", crdGroup,
                                err,
                        )</span>
                        // continue the execution, even though failures on the crd migration
                } else<span class="cov8" title="1"> {
                        logger.Infow("migration completed", "crdGroup", crdGroup)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file195" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package upgrade

import (
        "context"
        "fmt"
        "slices"
        "strings"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"

        "github.com/tektoncd/operator/pkg/reconciler/common"
        upgrade "github.com/tektoncd/operator/pkg/reconciler/shared/tektonconfig/upgrade/helper"
        "go.uber.org/zap"
        apixclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
)

const (
        taskVersiondRetentionCount = 2
)

// performs storage versions upgrade
// lists all the resources and keeps only one storage version
func upgradeStorageVersion(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov0" title="0">{
        // resources to be upgraded
        crdGroups := []string{

                // dashboard
                "extensions.dashboard.tekton.dev",

                // pipelines
                "clustertasks.tekton.dev",
                "customruns.tekton.dev",
                "pipelineruns.tekton.dev",
                "pipelines.tekton.dev",
                "taskruns.tekton.dev",
                "tasks.tekton.dev",
                "verificationpolicies.tekton.dev",
                "resolutionrequests.resolution.tekton.dev",

                // Pipelines-as-code
                "repositories.pipelinesascode.tekton.dev",

                // triggers
                "clusterinterceptors.triggers.tekton.dev",
                "clustertriggerbindings.triggers.tekton.dev",
                "eventlisteners.triggers.tekton.dev",
                "interceptors.triggers.tekton.dev",
                "triggerbindings.triggers.tekton.dev",
                "triggers.triggers.tekton.dev",
                "triggertemplates.triggers.tekton.dev",
        }

        migrator := upgrade.NewMigrator(
                dynamic.NewForConfigOrDie(restConfig),
                apixclient.NewForConfigOrDie(restConfig),
                logger,
        )

        upgrade.MigrateStorageVersion(ctx, logger, migrator, crdGroups)

        return nil
}</span>

// removeClusterTaskInstallerSets removes clusterTask, community clusterTask and all versioned clusterTask from the cluster
// as clusterTask has been removed
func removeClusterTaskInstallerSets(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov0" title="0">{

        if !v1alpha1.IsOpenShiftPlatform() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">clusterInstallerSetsList := []string{"ClusterTask", "CommunityClusterTask", "VersionedClusterTask"}
        tisClient := operatorClient.OperatorV1alpha1().TektonInstallerSets()

        for _, clusterIS := range clusterInstallerSetsList </span><span class="cov0" title="0">{
                installerSetsLabelSelector := metav1.LabelSelector{
                        MatchLabels: map[string]string{
                                v1alpha1.InstallerSetType: fmt.Sprintf("%s-%s", "custom", strings.ToLower(clusterIS)),
                        },
                }
                installerSetsLabel, err := common.LabelSelector(installerSetsLabelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // deletes clusterTask installersets
                <span class="cov0" title="0">if err := tisClient.DeleteCollection(ctx, metav1.DeleteOptions{}, metav1.ListOptions{
                        LabelSelector: installerSetsLabel,
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("failed to delete a installerset", "installerSetName", clusterIS, err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// removeVersionedTaskInstallerSets removes the versioned resolver tasks installersets except latest 2 versions
func removeVersionedTaskInstallerSets(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov0" title="0">{

        if !v1alpha1.IsOpenShiftPlatform() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">taskInstallerSetsLabelSelector := metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.InstallerSetType: fmt.Sprintf("%s-%s", "custom", "versionedresolvertask"),
                },
        }
        taskInstallerSetsLabel, err := common.LabelSelector(taskInstallerSetsLabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return findAndDeleteInstallerSetsByLabelName(ctx, logger, operatorClient, taskInstallerSetsLabel)</span>
}

// removeVersionedStepActionsInstallerSets removes the versioned resolver step actions installersets except latest 2 versions
func removeVersionedStepActionsInstallerSets(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov0" title="0">{

        if !v1alpha1.IsOpenShiftPlatform() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">stepActionsInstallerSetsLabelSelector := metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.InstallerSetType: fmt.Sprintf("%s-%s", "custom", "versionedresolverstepaction"),
                },
        }
        stepActionsInstallerSetsLabel, err := common.LabelSelector(stepActionsInstallerSetsLabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return findAndDeleteInstallerSetsByLabelName(ctx, logger, operatorClient, stepActionsInstallerSetsLabel)</span>
}

func findAndDeleteInstallerSetsByLabelName(ctx context.Context, logger *zap.SugaredLogger, operatorClient versioned.Interface, installerSetsLabel string) error <span class="cov0" title="0">{
        tsClient := operatorClient.OperatorV1alpha1().TektonInstallerSets()

        installerSets, err := tsClient.List(ctx, metav1.ListOptions{LabelSelector: installerSetsLabel})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(installerSets.Items) &lt; taskVersiondRetentionCount </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">installerListName := []string{}
        for _, taskIS := range installerSets.Items </span><span class="cov0" title="0">{
                installerListName = append(installerListName, taskIS.Name)
        }</span>

        <span class="cov0" title="0">slices.Sort(installerListName)
        slices.Reverse(installerListName)

        for i := taskVersiondRetentionCount; i &lt; len(installerListName); i++ </span><span class="cov0" title="0">{
                if err := tsClient.Delete(ctx, installerListName[i], metav1.DeleteOptions{}); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("failed to delete a installerset", "installerSetName", installerListName[i], err)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package upgrade

import (
        "context"

        "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonpruner"
        "gopkg.in/yaml.v3"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        tektonresult "github.com/tektoncd/operator/pkg/reconciler/kubernetes/tektonresult"
        "go.uber.org/zap"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/ptr"
)

// previous version of tekton operator uses a condition type called "InstallSucceeded" in status
// but in the recent version we do not have that field, hence "InstallSucceeded" condition never updated.
// for some reason, if it was in failed state, tektonConfig CR always in failed state
// even though all the resources are up and running. as the operator sums all the status conditions
// to avoid this, remove all the existing conditions from the status of the CR.
// conditions will be repopulated
func resetTektonConfigConditions(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov8" title="1">{
        // fetch the current tektonConfig CR
        tcCR, err := operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // remove all the existing conditions
        <span class="cov8" title="1">tcCR.Status.Conditions = duckv1.Conditions{}
        // update the status
        _, err = operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, tcCR, metav1.UpdateOptions{})
        return err</span>
}

// previous version of the tekton operator uses default value which is false for enable-step-actions.
// In the new version, we are shipping stepAction, allowing users to create tasks using stepAction.
// Therefore, we are changing the enable-step-actions setting from false to true.
func upgradePipelineProperties(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov8" title="1">{
        // fetch the current tektonConfig CR
        tcCR, err := operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // For historical reasons, if it is upgraded from a historical version, this field may be nil
        <span class="cov8" title="1">if tcCR.Spec.Pipeline.EnableStepActions == nil || !*tcCR.Spec.Pipeline.EnableStepActions </span><span class="cov8" title="1">{
                // update enable-step-actions to true from false which is default.
                tcCR.Spec.Pipeline.EnableStepActions = ptr.Bool(true)
                _, err = operatorClient.OperatorV1alpha1().TektonConfigs().Update(ctx, tcCR, metav1.UpdateOptions{})
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// previous version of the Tekton Operator created default tekton-results-tls on Openshift Platform
// causing it Tekton Results api failure
func deleteTektonResultsTLSSecret(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov0" title="0">{
        if !v1alpha1.IsOpenShiftPlatform() </span><span class="cov0" title="0">{
                return nil
        }</span>

        // get the TekonResult CR
        <span class="cov0" title="0">trCR, err := operatorClient.OperatorV1alpha1().TektonResults().Get(ctx, v1alpha1.ResultResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // get the tekton-results-tls secret
        <span class="cov0" title="0">tlsSecret, err := k8sClient.CoreV1().Secrets(trCR.Spec.TargetNamespace).Get(ctx, tektonresult.TlsSecretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                if apierrs.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // delete default tekton-results-tls secret which has no OwnerReferences
        <span class="cov0" title="0">if len(tlsSecret.OwnerReferences) == 0 </span><span class="cov0" title="0">{
                err = k8sClient.CoreV1().Secrets(trCR.Spec.TargetNamespace).Delete(ctx, tektonresult.TlsSecretName, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// TODO: Remove the preUpgradeTektonPruner upgrade function in next operator release
func preUpgradeTektonPruner(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error <span class="cov8" title="1">{
        // get tektonConfig CR
        logger.Infof("Performing Preupgrade for TektonPruner")
        tc, err := operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorw("error on getting TektonConfig CR", err)
                return err
        }</span>

        <span class="cov8" title="1">if tc.Spec.TektonPruner.IsDisabled() </span><span class="cov0" title="0">{
                logger.Infof("TektonPruner is disabled, skipping pre-upgrade for TektonPruner")
                return nil
        }</span>

        <span class="cov8" title="1">var prunerConfig v1alpha1.TektonPrunerConfig
        cm, err := k8sClient.CoreV1().ConfigMaps(tc.Spec.TargetNamespace).Get(ctx, tektonpruner.PrunerConfigMapName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        prunerConfig = v1alpha1.TektonPrunerConfig{}
                }</span>
        }
        <span class="cov8" title="1">key := "global-config"
        if cm != nil &amp;&amp; cm.Data[key] != "" </span><span class="cov8" title="1">{
                if err := yaml.Unmarshal([]byte(cm.Data[key]), &amp;prunerConfig.GlobalConfig); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error on Unmarshal TektonPruner ConfigMap data", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">tc.Spec.TektonPruner.GlobalConfig = prunerConfig.GlobalConfig

        _, err = operatorClient.OperatorV1alpha1().TektonConfigs().Update(ctx, tc, metav1.UpdateOptions{})
        return err</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package upgrade

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        "go.uber.org/zap"
        apierrs "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/logging"
)

var (
        // pre upgrade functions
        preUpgradeFunctions = []upgradeFunc{
                resetTektonConfigConditions, // upgrade #1: removes conditions from TektonConfig CR, clears outdated conditions
                upgradePipelineProperties,   // upgrade #2: update default value of enable-step-actions from false to true
                // Todo: Remove the deleteTektonResultsTLSSecret upgrade function in next operator release
                deleteTektonResultsTLSSecret, // upgrade #5: deletes default tekton results tls certificate
                // TODO: Remove the preUpgradeTektonPruner upgrade function in next operator release
                preUpgradeTektonPruner, // upgrade #5: pre upgrade tekton pruner
        }

        // post upgrade functions
        postUpgradeFunctions = []upgradeFunc{
                upgradeStorageVersion,                   // upgrade #1: performs storage version migration
                removeClusterTaskInstallerSets,          // upgrade #2: removes the clusterTask installerset
                removeVersionedTaskInstallerSets,        // upgrade #3: remove the older versioned resolver task installersets
                removeVersionedStepActionsInstallerSets, // upgrade #4: remove the older versioned step action resolver installersets
        }
)

type upgradeFunc = func(ctx context.Context, logger *zap.SugaredLogger, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) error

type Upgrade struct {
        logger          *zap.SugaredLogger
        operatorVersion string
        k8sClient       kubernetes.Interface
        operatorClient  versioned.Interface
        restConfig      *rest.Config
}

func New(operatorVersion string, k8sClient kubernetes.Interface, operatorClient versioned.Interface, restConfig *rest.Config) *Upgrade <span class="cov0" title="0">{
        return &amp;Upgrade{
                k8sClient:       k8sClient,
                operatorClient:  operatorClient,
                operatorVersion: operatorVersion,
                restConfig:      restConfig,
        }
}</span>

func (ug *Upgrade) RunPreUpgrade(ctx context.Context) error <span class="cov8" title="1">{
        return ug.executeUpgrade(ctx, preUpgradeFunctions, true)
}</span>

func (ug *Upgrade) RunPostUpgrade(ctx context.Context) error <span class="cov8" title="1">{
        return ug.executeUpgrade(ctx, postUpgradeFunctions, false)
}</span>

func (ug *Upgrade) executeUpgrade(ctx context.Context, upgradeFunctions []upgradeFunc, isPreUpgrade bool) error <span class="cov8" title="1">{
        // update logger
        ug.logger = logging.FromContext(ctx).Named("upgrade")

        // if upgrade not required return from here
        isUpgradeRequired, err := ug.isUpgradeRequired(ctx, isPreUpgrade)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !isUpgradeRequired </span><span class="cov8" title="1">{
                return ug.markUpgradeComplete(ctx, isPreUpgrade)
        }</span>

        <span class="cov8" title="1">if isPreUpgrade </span><span class="cov8" title="1">{
                if err := ug.markUpgradeFalse(ctx, isPreUpgrade, "Performing PreUpgrade", "Pre upgrade is in progress"); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">ug.logger.Debugw("executing pre upgrade functions", "numberOfFunctions", len(upgradeFunctions))</span>
        } else<span class="cov8" title="1"> {
                if err := ug.markUpgradeFalse(ctx, isPreUpgrade, "Performing PostUpgrade", "Post upgrade is in progress"); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">ug.logger.Debugw("executing post upgrade functions", "numberOfFunctions", len(upgradeFunctions))</span>
        }

        // execute upgrade functions
        <span class="cov8" title="1">for _, _upgradeFunc := range upgradeFunctions </span><span class="cov8" title="1">{
                if err := _upgradeFunc(ctx, ug.logger, ug.k8sClient, ug.operatorClient, ug.restConfig); err != nil </span><span class="cov8" title="1">{
                        ug.logger.Error("error on upgrade", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">if isPreUpgrade </span><span class="cov8" title="1">{
                ug.logger.Debug("completed pre upgrade execution")
        }</span> else<span class="cov8" title="1"> {
                ug.logger.Debug("completed post upgrade execution")
        }</span>

        // update upgrade version
        <span class="cov8" title="1">return ug.updateUpgradeVersion(ctx, isPreUpgrade)</span>
}

func (ug *Upgrade) isUpgradeRequired(ctx context.Context, isPreUpgrade bool) (bool, error) <span class="cov8" title="1">{
        tcCR, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if apierrs.IsNotFound(err) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">ug.logger.Error("error on getting TektonConfig CR", err)
                return false, err</span>
        }

        <span class="cov8" title="1">appliedUpgradeVersion := tcCR.Status.GetPostUpgradeVersion()
        if isPreUpgrade </span><span class="cov8" title="1">{
                appliedUpgradeVersion = tcCR.Status.GetPreUpgradeVersion()
        }</span>

        <span class="cov8" title="1">_isUpgradeRequired := ug.operatorVersion != appliedUpgradeVersion
        return _isUpgradeRequired, nil</span>
}

func (ug *Upgrade) updateUpgradeVersion(ctx context.Context, isPreUpgrade bool) error <span class="cov8" title="1">{
        _cr, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                ug.logger.Error("error on getting TektonConfig CR", err)
                return err
        }</span>

        // update upgrade version into TektonConfig CR, under status
        <span class="cov8" title="1">if isPreUpgrade </span><span class="cov8" title="1">{
                _cr.Status.SetPreUpgradeVersion(ug.operatorVersion)
        }</span> else<span class="cov8" title="1"> {
                _cr.Status.SetPostUpgradeVersion(ug.operatorVersion)
        }</span>

        <span class="cov8" title="1">_, err = ug.operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, _cr, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                ug.logger.Errorw("error on updating TektonConfig CR status", "version", ug.operatorVersion, err)
                return err
        }</span>
        <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
}

func (ug *Upgrade) markUpgradeFalse(ctx context.Context, isPreUpgrade bool, reason, message string) error <span class="cov8" title="1">{
        _cr, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                ug.logger.Error("error on getting TektonConfig CR", err)
                return err
        }</span>

        <span class="cov8" title="1">isStatusChanged := false
        if isPreUpgrade </span><span class="cov8" title="1">{
                isStatusChanged = _cr.Status.MarkPreUpgradeFalse(reason, message)
        }</span> else<span class="cov8" title="1"> {
                isStatusChanged = _cr.Status.MarkPostUpgradeFalse(reason, message)
        }</span>

        <span class="cov8" title="1">if isStatusChanged </span><span class="cov8" title="1">{
                _, err = ug.operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, _cr, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        ug.logger.Errorw("error on updating TektonConfig CR status", "version", ug.operatorVersion, err)
                        return err
                }</span>
                <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (ug *Upgrade) markUpgradeComplete(ctx context.Context, isPreUpgrade bool) error <span class="cov8" title="1">{
        _cr, err := ug.operatorClient.OperatorV1alpha1().TektonConfigs().Get(ctx, v1alpha1.ConfigResourceName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                ug.logger.Error("error on getting TektonConfig CR", err)
                return err
        }</span>

        <span class="cov8" title="1">isStatusChanged := false
        if isPreUpgrade </span><span class="cov8" title="1">{
                isStatusChanged = _cr.Status.MarkPreUpgradeComplete()
        }</span> else<span class="cov8" title="1"> {
                isStatusChanged = _cr.Status.MarkPostUpgradeComplete()
        }</span>

        <span class="cov8" title="1">if isStatusChanged </span><span class="cov8" title="1">{
                _, err = ug.operatorClient.OperatorV1alpha1().TektonConfigs().UpdateStatus(ctx, _cr, metav1.UpdateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        ug.logger.Errorw("error on updating TektonConfig CR status", "version", ug.operatorVersion, err)
                        return err
                }</span>
                <span class="cov8" title="1">return v1alpha1.RECONCILE_AGAIN_ERR</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file198" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"

        versionedClients "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
)

var (
        tisClient versionedClients.TektonInstallerSetInterface
)

func InitTektonInstallerSetClient(ctx context.Context) <span class="cov0" title="0">{
        tisClient = operatorclient.Get(ctx).OperatorV1alpha1().TektonInstallerSets()
}</span>

func getTektonInstallerSetClient() versionedClients.TektonInstallerSetInterface <span class="cov0" title="0">{
        return tisClient
}</span>
</pre>
		
		<pre class="file" id="file199" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"

        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        versionedClients "github.com/tektoncd/operator/pkg/client/clientset/versioned/typed/operator/v1alpha1"
        "github.com/tektoncd/operator/pkg/reconciler/shared/hash"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Generates the installerset with name
func GenerateInstallerSetWithName(ctx context.Context, ci ComponentInstaller, name string) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        newISM := newTisMetaWithName(name)
        return generateInstallerSet(ctx, ci, newISM)
}</span>

// Generates the installerset with prefix name
func GenerateInstallerSetWithPrefixName(ctx context.Context, ci ComponentInstaller, namePrefix string) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        newISM := newTisMetaWithGenerateName(namePrefix)
        return generateInstallerSet(ctx, ci, newISM)
}</span>

// Generates the installerset without applying on the cluster
func generateInstallerSet(ctx context.Context, ci ComponentInstaller, tis *tisMeta) (*v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        tis.config(ctx, ci)

        manifest, err := ci.GetManifest(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">is, err := makeInstallerSet(manifest, tis)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return is, nil</span>
}

// Creates the installerset on the cluster
func Create(ctx context.Context, is *v1alpha1.TektonInstallerSet) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        client := getTektonInstallerSetClient()
        return createWithClient(ctx, client, is)
}</span>

func createWithClient(ctx context.Context, client versionedClients.TektonInstallerSetInterface, is *v1alpha1.TektonInstallerSet) (*v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{
        createdIs, err := client.Create(ctx, is, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return createdIs, nil</span>
}

func makeInstallerSet(manifest *mf.Manifest, mt *tisMeta) (*v1alpha1.TektonInstallerSet, error) <span class="cov8" title="1">{

        is := &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        Name:            mt.Name,
                        GenerateName:    mt.GenerateName,
                        Labels:          mt.Labels,
                        Annotations:     mt.Annotations,
                        OwnerReferences: mt.OwnerReferences,
                },
                Spec: installerSpec(manifest),
        }

        specHash, err := getHash(is.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">is.Annotations[v1alpha1.LastAppliedHashKey] = specHash

        return is, nil</span>
}

// Returns the spec of Installerset
func installerSpec(manifest *mf.Manifest) v1alpha1.TektonInstallerSetSpec <span class="cov8" title="1">{
        return v1alpha1.TektonInstallerSetSpec{
                Manifests: manifest.Resources(),
        }
}</span>

// Computes the hash using spec of TektonInstallerSet
func getHash(spec v1alpha1.TektonInstallerSetSpec) (string, error) <span class="cov8" title="1">{
        specHash, err := hash.Compute(spec)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return specHash, nil</span>
}
</pre>
		
		<pre class="file" id="file200" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tektoninstallerset

import (
        "context"
        "fmt"

        mf "github.com/manifestival/manifestival"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type ComponentInstaller interface {
        GetManifest(ctx context.Context) (*mf.Manifest, error)
        GetLabels(ctx context.Context) map[string]string
        GetAnnotations(ctx context.Context) map[string]string
        GetOwnerReferences(ctx context.Context) []metav1.OwnerReference
}

// TektonInstallerSet Meta
type tisMeta struct {
        Labels          map[string]string
        Annotations     map[string]string
        OwnerReferences []metav1.OwnerReference
        Name            string
        GenerateName    string
}

func newTisMeta() *tisMeta <span class="cov8" title="1">{
        return &amp;tisMeta{}
}</span>

func newTisMetaWithName(name string) *tisMeta <span class="cov8" title="1">{
        tis := newTisMeta()
        tis.Name = name

        return tis
}</span>

func newTisMetaWithGenerateName(namePrefix string) *tisMeta <span class="cov0" title="0">{
        tis := newTisMeta()
        tis.GenerateName = fmt.Sprintf("%s-", namePrefix)

        return tis
}</span>

func (tis *tisMeta) config(ctx context.Context, ci ComponentInstaller) <span class="cov8" title="1">{
        tis.Labels = ci.GetLabels(ctx)
        tis.Annotations = ci.GetAnnotations(ctx)
        tis.OwnerReferences = ci.GetOwnerReferences(ctx)
}</span>
</pre>
		
		<pre class="file" id="file201" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package webhook

import (
        "context"

        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/webhook/configmaps"
        "knative.dev/pkg/webhook/resourcesemantics"
        "knative.dev/pkg/webhook/resourcesemantics/defaulting"
        "knative.dev/pkg/webhook/resourcesemantics/validation"
)

var types = map[schema.GroupVersionKind]resourcesemantics.GenericCRD{
        v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonConfig):   &amp;v1alpha1.TektonConfig{},
        v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonPipeline): &amp;v1alpha1.TektonPipeline{},
        v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonTrigger):  &amp;v1alpha1.TektonTrigger{},
        v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonHub):      &amp;v1alpha1.TektonHub{},
        v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonResult):   &amp;v1alpha1.TektonResult{},
        v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonChain):    &amp;v1alpha1.TektonChain{},
}

func SetTypes(platform string) <span class="cov0" title="0">{
        if platform == "openshift" </span><span class="cov0" title="0">{
                types[v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonAddon)] = &amp;v1alpha1.TektonAddon{}
                types[v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindOpenShiftPipelinesAsCode)] = &amp;v1alpha1.OpenShiftPipelinesAsCode{}
        }</span> else<span class="cov0" title="0"> {
                types[v1alpha1.SchemeGroupVersion.WithKind(v1alpha1.KindTektonDashboard)] = &amp;v1alpha1.TektonDashboard{}
        }</span>
}

func NewDefaultingAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return defaulting.NewAdmissionController(ctx,

                // Name of the resource webhook.
                "webhook.operator.tekton.dev",
                // The path on which to serve the webhook.
                "/defaulting",

                // The resources to validate and default.
                types,

                // A function that infuses the context passed to Validate/SetDefaults with custom metadata.
                func(ctx context.Context) context.Context </span><span class="cov0" title="0">{
                        return ctx
                }</span>,

                // Whether to disallow unknown fields.
                true,
        )
}

func NewValidationAdmissionController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return validation.NewAdmissionController(ctx,

                // Name of the resource webhook.
                "validation.webhook.operator.tekton.dev",

                // The path on which to serve the webhook.
                "/resource-validation",

                // The resources to validate and default.
                types,

                // A function that infuses the context passed to Validate/SetDefaults with custom metadata.
                func(ctx context.Context) context.Context </span><span class="cov0" title="0">{
                        return ctx
                }</span>,

                // Whether to disallow unknown fields.
                true,
        )
}

func NewConfigValidationController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return configmaps.NewAdmissionController(ctx,
                // Name of the configmap webhook.
                "config.webhook.operator.tekton.dev",

                // The path on which to serve the webhook.
                "/config-validation",

                configmap.Constructors{
                        logging.ConfigMapName(): logging.NewConfigFromConfigMap,
                },
        )
}</span>
</pre>
		
		<pre class="file" id="file202" style="display: none">package webhook

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/go-logr/zapr"
        mfc "github.com/manifestival/client-go-client"
        mf "github.com/manifestival/manifestival"
        "github.com/tektoncd/operator/pkg/apis/operator/v1alpha1"
        clientset "github.com/tektoncd/operator/pkg/client/clientset/versioned"
        operatorclient "github.com/tektoncd/operator/pkg/client/injection/client"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        "github.com/tektoncd/operator/pkg/reconciler/common"
        "go.uber.org/zap"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

const (
        // deprecated label, used in old versions
        // keeps this reference to remove the existing webhook installersets
        DEPRECATED_WEBHOOK_INSTALLERSET_LABEL = "validating-defaulting-webhooks.operator.tekton.dev"

        // this label is used to terminate the created webhook installerset on graceful termination
        // use unique name, to identify the resource created by this pod
        WEBHOOK_UNIQUE_LABEL = "operator.tekton.dev/webhook-unique-identifier"

        // primary label values to track webhook installersets
        labelCreatedByValue        = "operator-webhook-init"
        labelInstallerSetTypeValue = "operatorValidatingDefaultingWebhook"

        POD_NAMESPACE_ENV_KEY = "SYSTEM_NAMESPACE"
        POD_NAME_ENV_KEY      = "WEBHOOK_POD_NAME"
)

var (
        ErrNamespaceEnvNotSet = fmt.Errorf("namespace environment key %q not set", POD_NAMESPACE_ENV_KEY)

        // primary labelSelector to list available webhooks installersets
        primaryLabelSelector = metav1.LabelSelector{
                MatchLabels: map[string]string{
                        v1alpha1.CreatedByKey:     labelCreatedByValue,
                        v1alpha1.InstallerSetType: labelInstallerSetTypeValue,
                },
        }
)

func CleanupWebhookResources(ctx context.Context) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        client := operatorclient.Get(ctx)

        // cannot use the ctx passed from main as it will be cancelled
        // by the time we use in kube api calls
        freshContext := context.Background()

        // delete the webhook installersets created by this pod
        err := deleteExistingInstallerSets(freshContext, client, true)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error on deleting webhook installersets", err)
        }</span>
}

func CreateWebhookResources(ctx context.Context) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        manifest, err := fetchManifests(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("error creating initial manifest", zap.Error(err))
        }</span>

        <span class="cov0" title="0">client := operatorclient.Get(ctx)
        err = deleteExistingInstallerSets(ctx, client, false)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("error deleting webhook installerset", zap.Error(err))
        }</span>

        <span class="cov0" title="0">if err := createInstallerSet(ctx, client, *manifest); err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("error creating webhook installerset", zap.Error(err))
        }</span>
}

func fetchManifests(ctx context.Context) (*mf.Manifest, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        mfclient, err := mfc.NewClient(injection.GetConfig(ctx))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">mflogger := zapr.NewLogger(logger.Named("manifestival").Desugar())
        manifest, err := mf.ManifestFrom(mf.Slice{}, mf.UseClient(mfclient), mf.UseLogger(mflogger))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read manifests
        <span class="cov0" title="0">koDataDir := os.Getenv(common.KoEnvKey)
        validating_defaulting_webhooks := filepath.Join(koDataDir, "validating-defaulting-webhook")
        if err := common.AppendManifest(&amp;manifest, validating_defaulting_webhooks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return manifestTransform(&amp;manifest)</span>
}

func manifestTransform(m *mf.Manifest) (*mf.Manifest, error) <span class="cov8" title="1">{
        ns, ok := os.LookupEnv(POD_NAMESPACE_ENV_KEY)
        if !ok || ns == "" </span><span class="cov8" title="1">{
                return nil, ErrNamespaceEnvNotSet
        }</span>
        <span class="cov8" title="1">tfs := []mf.Transformer{
                mf.InjectNamespace(ns),
        }
        result, err := m.Transform(tfs...)
        return &amp;result, err</span>
}

func deleteExistingInstallerSets(ctx context.Context, client clientset.Interface, includeUniqueIdentifier bool) error <span class="cov8" title="1">{
        // deleting the existing deprecated webhook installersets
        installerSetList, err := client.OperatorV1alpha1().TektonInstallerSets().List(
                ctx,
                metav1.ListOptions{LabelSelector: DEPRECATED_WEBHOOK_INSTALLERSET_LABEL},
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, is := range installerSetList.Items </span><span class="cov8" title="1">{
                err = client.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, is.Name, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">_primaryLabelSelector := primaryLabelSelector.DeepCopy()
        // this pod name
        if includeUniqueIdentifier </span><span class="cov8" title="1">{
                podName, ok := os.LookupEnv(POD_NAME_ENV_KEY)
                if !ok </span><span class="cov8" title="1">{
                        // if pod env not set return
                        return fmt.Errorf("pod name environment variable[%s] details are not set", POD_NAME_ENV_KEY)
                }</span>
                // use pod name as unique reference
                <span class="cov8" title="1">_primaryLabelSelector.MatchLabels[WEBHOOK_UNIQUE_LABEL] = podName</span>
        }

        // delete all the existing webhook installersets
        <span class="cov8" title="1">labelSelector, err := common.LabelSelector(*_primaryLabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">installerSetList, err = client.OperatorV1alpha1().TektonInstallerSets().List(
                ctx,
                metav1.ListOptions{LabelSelector: labelSelector},
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, is := range installerSetList.Items </span><span class="cov8" title="1">{
                err = client.OperatorV1alpha1().TektonInstallerSets().Delete(ctx, is.Name, metav1.DeleteOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func createInstallerSet(ctx context.Context, oc clientset.Interface, manifest mf.Manifest) error <span class="cov0" title="0">{
        is, err := makeInstallerSet(manifest)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">item, err := oc.OperatorV1alpha1().TektonInstallerSets().Create(ctx, is, metav1.CreateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        logger.Debugw("webhook installerset created",
                "name", item.Name,
        )
        return nil</span>
}

func makeInstallerSet(manifest mf.Manifest) (*v1alpha1.TektonInstallerSet, error) <span class="cov0" title="0">{
        // this pod name
        podName, ok := os.LookupEnv(POD_NAME_ENV_KEY)
        if !ok </span><span class="cov0" title="0">{
                // if pod env not set return
                return nil, fmt.Errorf("pod name environment variable[%s] details are not set", POD_NAME_ENV_KEY)
        }</span>
        // use pod name as unique reference
        <span class="cov0" title="0">_primaryLabelSelector := primaryLabelSelector.DeepCopy()
        _primaryLabelSelector.MatchLabels[WEBHOOK_UNIQUE_LABEL] = podName

        installerSet := &amp;v1alpha1.TektonInstallerSet{
                ObjectMeta: metav1.ObjectMeta{
                        GenerateName: fmt.Sprintf("%s-", "validating-mutating-webhook"),
                        Labels:       _primaryLabelSelector.MatchLabels,
                },
                Spec: v1alpha1.TektonInstallerSetSpec{
                        Manifests: manifest.Resources(),
                },
        }

        return installerSet, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
