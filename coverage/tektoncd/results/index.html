
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>fieldmask: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/results/internal/fieldmask/fieldmask.go (67.9%)</option>
				
				<option value="file1">github.com/tektoncd/results/pkg/api/server/cel/cel.go (37.5%)</option>
				
				<option value="file2">github.com/tektoncd/results/pkg/api/server/cel/env.go (0.0%)</option>
				
				<option value="file3">github.com/tektoncd/results/pkg/api/server/cel2sql/concat.go (95.8%)</option>
				
				<option value="file4">github.com/tektoncd/results/pkg/api/server/cel2sql/convert.go (77.8%)</option>
				
				<option value="file5">github.com/tektoncd/results/pkg/api/server/cel2sql/functions.go (84.1%)</option>
				
				<option value="file6">github.com/tektoncd/results/pkg/api/server/cel2sql/index.go (88.5%)</option>
				
				<option value="file7">github.com/tektoncd/results/pkg/api/server/cel2sql/interpreter.go (74.0%)</option>
				
				<option value="file8">github.com/tektoncd/results/pkg/api/server/cel2sql/operators.go (100.0%)</option>
				
				<option value="file9">github.com/tektoncd/results/pkg/api/server/cel2sql/select.go (90.9%)</option>
				
				<option value="file10">github.com/tektoncd/results/pkg/api/server/cel2sql/type_coercion.go (89.5%)</option>
				
				<option value="file11">github.com/tektoncd/results/pkg/api/server/config/config.go (0.0%)</option>
				
				<option value="file12">github.com/tektoncd/results/pkg/api/server/db/errors/errors.go (0.0%)</option>
				
				<option value="file13">github.com/tektoncd/results/pkg/api/server/db/errors/sqlite/sqlite.go (0.0%)</option>
				
				<option value="file14">github.com/tektoncd/results/pkg/api/server/db/log_level.go (0.0%)</option>
				
				<option value="file15">github.com/tektoncd/results/pkg/api/server/db/model.go (72.7%)</option>
				
				<option value="file16">github.com/tektoncd/results/pkg/api/server/db/pagination/pagination.go (82.6%)</option>
				
				<option value="file17">github.com/tektoncd/results/pkg/api/server/features/features.go (85.3%)</option>
				
				<option value="file18">github.com/tektoncd/results/pkg/api/server/logger/logger.go (0.0%)</option>
				
				<option value="file19">github.com/tektoncd/results/pkg/api/server/v1alpha2/auth/impersonation/impersonation.go (75.6%)</option>
				
				<option value="file20">github.com/tektoncd/results/pkg/api/server/v1alpha2/auth/nop.go (0.0%)</option>
				
				<option value="file21">github.com/tektoncd/results/pkg/api/server/v1alpha2/auth/rbac.go (75.0%)</option>
				
				<option value="file22">github.com/tektoncd/results/pkg/api/server/v1alpha2/handlers.go (0.0%)</option>
				
				<option value="file23">github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/aggregator.go (28.0%)</option>
				
				<option value="file24">github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/filter.go (92.3%)</option>
				
				<option value="file25">github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/limit.go (100.0%)</option>
				
				<option value="file26">github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/lister.go (15.8%)</option>
				
				<option value="file27">github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/offset.go (100.0%)</option>
				
				<option value="file28">github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/order.go (86.5%)</option>
				
				<option value="file29">github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/page_token.go (69.2%)</option>
				
				<option value="file30">github.com/tektoncd/results/pkg/api/server/v1alpha2/log/file.go (78.6%)</option>
				
				<option value="file31">github.com/tektoncd/results/pkg/api/server/v1alpha2/log/gcs.go (42.9%)</option>
				
				<option value="file32">github.com/tektoncd/results/pkg/api/server/v1alpha2/log/log.go (72.7%)</option>
				
				<option value="file33">github.com/tektoncd/results/pkg/api/server/v1alpha2/log/s3.go (40.8%)</option>
				
				<option value="file34">github.com/tektoncd/results/pkg/api/server/v1alpha2/logs.go (62.0%)</option>
				
				<option value="file35">github.com/tektoncd/results/pkg/api/server/v1alpha2/ordering.go (100.0%)</option>
				
				<option value="file36">github.com/tektoncd/results/pkg/api/server/v1alpha2/pagination.go (100.0%)</option>
				
				<option value="file37">github.com/tektoncd/results/pkg/api/server/v1alpha2/plugin/plugin_logs.go (37.5%)</option>
				
				<option value="file38">github.com/tektoncd/results/pkg/api/server/v1alpha2/plugin/server.go (80.0%)</option>
				
				<option value="file39">github.com/tektoncd/results/pkg/api/server/v1alpha2/record/record.go (63.3%)</option>
				
				<option value="file40">github.com/tektoncd/results/pkg/api/server/v1alpha2/records.go (87.1%)</option>
				
				<option value="file41">github.com/tektoncd/results/pkg/api/server/v1alpha2/result/result.go (76.0%)</option>
				
				<option value="file42">github.com/tektoncd/results/pkg/api/server/v1alpha2/results.go (88.9%)</option>
				
				<option value="file43">github.com/tektoncd/results/pkg/api/server/v1alpha2/server.go (69.2%)</option>
				
				<option value="file44">github.com/tektoncd/results/pkg/api/server/v1alpha2/summary.go (0.0%)</option>
				
				<option value="file45">github.com/tektoncd/results/pkg/apis/config/metrics.go (72.2%)</option>
				
				<option value="file46">github.com/tektoncd/results/pkg/apis/config/retention.go (40.6%)</option>
				
				<option value="file47">github.com/tektoncd/results/pkg/apis/config/store.go (91.7%)</option>
				
				<option value="file48">github.com/tektoncd/results/pkg/apis/v1alpha3/types.go (0.0%)</option>
				
				<option value="file49">github.com/tektoncd/results/pkg/cli/client/base.go (66.7%)</option>
				
				<option value="file50">github.com/tektoncd/results/pkg/cli/client/logs/logs.go (0.0%)</option>
				
				<option value="file51">github.com/tektoncd/results/pkg/cli/client/records/records.go (76.2%)</option>
				
				<option value="file52">github.com/tektoncd/results/pkg/cli/client/response.go (33.3%)</option>
				
				<option value="file53">github.com/tektoncd/results/pkg/cli/common/format.go (0.0%)</option>
				
				<option value="file54">github.com/tektoncd/results/pkg/cli/common/labels.go (0.0%)</option>
				
				<option value="file55">github.com/tektoncd/results/pkg/cli/common/params.go (0.0%)</option>
				
				<option value="file56">github.com/tektoncd/results/pkg/cli/common/prerun/prerun.go (0.0%)</option>
				
				<option value="file57">github.com/tektoncd/results/pkg/cli/common/utils.go (0.0%)</option>
				
				<option value="file58">github.com/tektoncd/results/pkg/cli/config/config.go (66.5%)</option>
				
				<option value="file59">github.com/tektoncd/results/pkg/cli/config/extension.go (87.5%)</option>
				
				<option value="file60">github.com/tektoncd/results/pkg/cli/config/host.go (8.2%)</option>
				
				<option value="file61">github.com/tektoncd/results/pkg/cli/config/platform.go (61.5%)</option>
				
				<option value="file62">github.com/tektoncd/results/pkg/cli/dev/client/client.go (15.0%)</option>
				
				<option value="file63">github.com/tektoncd/results/pkg/cli/dev/config/config.go (48.3%)</option>
				
				<option value="file64">github.com/tektoncd/results/pkg/cli/dev/flags/flags.go (0.0%)</option>
				
				<option value="file65">github.com/tektoncd/results/pkg/cli/dev/format/format.go (0.0%)</option>
				
				<option value="file66">github.com/tektoncd/results/pkg/cli/dev/portforward/portforward.go (0.0%)</option>
				
				<option value="file67">github.com/tektoncd/results/pkg/cli/flags/flags.go (82.0%)</option>
				
				<option value="file68">github.com/tektoncd/results/pkg/cli/options/describe.go (0.0%)</option>
				
				<option value="file69">github.com/tektoncd/results/pkg/cli/options/list.go (0.0%)</option>
				
				<option value="file70">github.com/tektoncd/results/pkg/cli/options/logs.go (0.0%)</option>
				
				<option value="file71">github.com/tektoncd/results/pkg/cli/testutils/cobra.go (0.0%)</option>
				
				<option value="file72">github.com/tektoncd/results/pkg/cli/testutils/kubeconfig.go (0.0%)</option>
				
				<option value="file73">github.com/tektoncd/results/pkg/cli/testutils/mock_rest_client.go (0.0%)</option>
				
				<option value="file74">github.com/tektoncd/results/pkg/cli/testutils/params.go (0.0%)</option>
				
				<option value="file75">github.com/tektoncd/results/pkg/cli/testutils/utils.go (0.0%)</option>
				
				<option value="file76">github.com/tektoncd/results/pkg/converter/convert.go (0.0%)</option>
				
				<option value="file77">github.com/tektoncd/results/pkg/internal/jsonutil/jsonutil.go (0.0%)</option>
				
				<option value="file78">github.com/tektoncd/results/pkg/internal/protoutil/protoutil.go (38.9%)</option>
				
				<option value="file79">github.com/tektoncd/results/pkg/logs/writer.go (84.8%)</option>
				
				<option value="file80">github.com/tektoncd/results/pkg/pipelinerunmetrics/metrics.go (69.1%)</option>
				
				<option value="file81">github.com/tektoncd/results/pkg/retention/config.go (0.0%)</option>
				
				<option value="file82">github.com/tektoncd/results/pkg/retention/job.go (56.0%)</option>
				
				<option value="file83">github.com/tektoncd/results/pkg/taskrunmetrics/metrics.go (74.3%)</option>
				
				<option value="file84">github.com/tektoncd/results/pkg/watcher/convert/convert.go (70.0%)</option>
				
				<option value="file85">github.com/tektoncd/results/pkg/watcher/grpc/creds.go (0.0%)</option>
				
				<option value="file86">github.com/tektoncd/results/pkg/watcher/logs/client.go (0.0%)</option>
				
				<option value="file87">github.com/tektoncd/results/pkg/watcher/reconciler/annotation/annotation.go (97.7%)</option>
				
				<option value="file88">github.com/tektoncd/results/pkg/watcher/reconciler/client/client.go (0.0%)</option>
				
				<option value="file89">github.com/tektoncd/results/pkg/watcher/reconciler/config.go (35.7%)</option>
				
				<option value="file90">github.com/tektoncd/results/pkg/watcher/reconciler/dynamic/dynamic.go (52.5%)</option>
				
				<option value="file91">github.com/tektoncd/results/pkg/watcher/reconciler/leaderelection/leader_election.go (0.0%)</option>
				
				<option value="file92">github.com/tektoncd/results/pkg/watcher/reconciler/pipelinerun/controller.go (0.0%)</option>
				
				<option value="file93">github.com/tektoncd/results/pkg/watcher/reconciler/pipelinerun/reconciler.go (77.5%)</option>
				
				<option value="file94">github.com/tektoncd/results/pkg/watcher/reconciler/taskrun/controller.go (0.0%)</option>
				
				<option value="file95">github.com/tektoncd/results/pkg/watcher/reconciler/taskrun/reconciler.go (66.1%)</option>
				
				<option value="file96">github.com/tektoncd/results/pkg/watcher/results/eventlist.go (0.0%)</option>
				
				<option value="file97">github.com/tektoncd/results/pkg/watcher/results/logs.go (50.0%)</option>
				
				<option value="file98">github.com/tektoncd/results/pkg/watcher/results/results.go (79.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package fieldmask

import (
        "context"
        "log"
        "net/http"
        "os"
        "strings"
        "sync/atomic"

        jsoniter "github.com/json-iterator/go"
        "github.com/tidwall/gjson"
        "google.golang.org/grpc"
        "google.golang.org/grpc/metadata"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
        "google.golang.org/protobuf/types/known/fieldmaskpb"
)

const (
        key = "fields"

        errStr = "\033[35m" + "%s\n" + "\033[0m" + "\033[31m" + "[error] " + "\033[0m"
)

var (
        logger = newLogger()
)

// Logger logger interface
type Logger interface {
        Error(context.Context, string, ...interface{})
}

func newLogger() Logger <span class="cov8" title="1">{
        return &amp;stdLogger{
                log: log.New(os.Stdout, "\r\n", log.LstdFlags),
        }
}</span>

type stdLogger struct {
        log *log.Logger
}

func (l *stdLogger) Error(_ context.Context, msg string, data ...interface{}) <span class="cov0" title="0">{
        l.log.Printf(errStr+msg, data...)
}</span>

// SetLogger sets the logger for the fieldmask package.
func SetLogger(l Logger) <span class="cov0" title="0">{
        logger = l
}</span>

// FieldMask is recursive structure to define a path mask
//
// Reference: https://protobuf.dev/reference/protobuf/google.protobuf/#json-encoding-field-masks
//
// Reference: https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/field_mask.proto
//
// For example, given the message:
//
//        f {
//          b {
//            d: 1
//            x: 2
//          }
//          c: [1]
//        }
//
// then if the path is:
//
// paths: ["f.b.d"]
//
// then the result will be:
//
//        f {
//          b {
//            d: 10
//          }
//        }
type FieldMask map[string]FieldMask

// Build populates a FieldMask from the input array of paths recursively.
// The array should contain JSON paths with dot "." notation.
func (fm FieldMask) Build(paths []string) <span class="cov8" title="1">{
        if len(paths) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">fields := strings.Split(paths[0], ".")
        m := fm
        for _, field := range fields </span><span class="cov8" title="1">{
                if _, ok := m[field]; !ok </span><span class="cov8" title="1">{
                        m[field] = FieldMask{}
                }</span>
                <span class="cov8" title="1">m = m[field]</span>
        }

        <span class="cov8" title="1">fm.Build(paths[1:])</span> //nolint:gosec // disable G602
}

// Filter takes a Proto message as input and updates the message according to the FieldMask.
func (fm FieldMask) Filter(message proto.Message) <span class="cov8" title="1">{
        if len(fm) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">reflect := message.ProtoReflect()
        reflect.Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool </span><span class="cov8" title="1">{
                mask, ok := fm[string(fd.Name())]
                if !ok </span><span class="cov8" title="1">{
                        reflect.Clear(fd)
                }</span>

                <span class="cov8" title="1">if len(mask) == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">switch </span>{
                case fd.IsMap():<span class="cov0" title="0">
                        m := reflect.Get(fd).Map()
                        m.Range(func(k protoreflect.MapKey, v protoreflect.Value) bool </span><span class="cov0" title="0">{
                                if fm, ok := mask[k.String()]; ok </span><span class="cov0" title="0">{
                                        if i, ok := v.Interface().(protoreflect.Message); ok &amp;&amp; len(fm) &gt; 0 </span><span class="cov0" title="0">{
                                                fm.Filter(i.Interface())
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        m.Clear(k)
                                }</span>
                                <span class="cov0" title="0">return true</span>
                        })
                case fd.IsList():<span class="cov8" title="1">
                        list := reflect.Get(fd).List()
                        for i := 0; i &lt; list.Len(); i++ </span><span class="cov8" title="1">{
                                mask.Filter(list.Get(i).Message().Interface())
                        }</span>
                case fd.Kind() == protoreflect.MessageKind:<span class="cov0" title="0">
                        mask.Filter(reflect.Get(fd).Message().Interface())</span>
                case fd.Kind() == protoreflect.BytesKind:<span class="cov8" title="1">
                        if b := v.Bytes(); gjson.ValidBytes(b) </span><span class="cov8" title="1">{
                                b, err := jsoniter.Marshal(mask.FilterJSON(b, []string{}))
                                if err == nil </span><span class="cov8" title="1">{
                                        reflect.Set(fd, protoreflect.ValueOfBytes(b))
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        // TODO: We can configure zap logger from main instead of using default logger.
                        logger.Error(context.Background(), "unsupported field type: %s", fd.Kind())</span>
                }
                <span class="cov8" title="1">return true</span>
        })
}

// Paths return the dot "." JSON notation os all the paths in the FieldMask.
// Parameter root []string is used internally for recursion, but it can also be used for setting an initial root path.
func (fm FieldMask) Paths(path []string) (paths []string) <span class="cov8" title="1">{
        for k, v := range fm </span><span class="cov8" title="1">{
                path = append(path, k)
                if len(v) == 0 </span><span class="cov8" title="1">{
                        paths = append(paths, strings.Join(path, "."))
                }</span>
                <span class="cov8" title="1">paths = append(paths, v.Paths(path)...)
                path = path[:len(path)-1]</span>
        }
        <span class="cov8" title="1">return</span>
}

// FilterJSON takes a JSON as input and return a map of the filtered JSON according to the FieldMask.
func (fm FieldMask) FilterJSON(json []byte, path []string) (out map[string]any) <span class="cov8" title="1">{
        for k, v := range fm </span><span class="cov8" title="1">{
                if out == nil </span><span class="cov8" title="1">{
                        out = make(map[string]interface{})
                }</span>
                <span class="cov8" title="1">path = append(path, k)
                if len(v) == 0 </span><span class="cov8" title="1">{
                        out[k] = gjson.GetBytes(json, strings.Join(path, ".")).Value()
                }</span> else<span class="cov8" title="1"> {
                        out[k] = v.FilterJSON(json, path)
                }</span>
                <span class="cov8" title="1">path = path[:len(path)-1]</span>
        }
        <span class="cov8" title="1">return</span>
}

// FromMetadata gets all the filter definitions from gRPC metadata.
func FromMetadata(md metadata.MD) FieldMask <span class="cov8" title="1">{
        fm := &amp;fieldmaskpb.FieldMask{}
        masks := md.Get(key)
        for _, mask := range masks </span><span class="cov8" title="1">{
                paths := strings.Split(mask, ",")
                for _, path := range paths </span><span class="cov8" title="1">{
                        fm.Paths = append(fm.Paths, strings.TrimSpace(path))
                }</span>
        }
        <span class="cov8" title="1">fm.Normalize()
        m := FieldMask{}
        m.Build(fm.Paths)
        return m</span>
}

// MetadataAnnotator injects key from query parameter to gRPC metadata (for REST client).
func MetadataAnnotator(_ context.Context, req *http.Request) metadata.MD <span class="cov8" title="1">{
        if err := req.ParseForm(); err == nil &amp;&amp; req.Form.Has(key) </span><span class="cov8" title="1">{
                return metadata.Pairs(key, req.Form.Get(key))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// UnaryServerInterceptor updates the response message according to the FieldMask.
func UnaryServerInterceptor(enabled *atomic.Bool) grpc.UnaryServerInterceptor <span class="cov0" title="0">{
        return func(ctx context.Context, req any, _ *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) </span><span class="cov0" title="0">{
                resp, err := handler(ctx, req)
                if err != nil || !enabled.Load() </span><span class="cov0" title="0">{
                        return resp, err
                }</span>

                <span class="cov0" title="0">message, ok := resp.(proto.Message)
                if !ok </span><span class="cov0" title="0">{
                        return resp, err
                }</span>

                <span class="cov0" title="0">md, ok := metadata.FromIncomingContext(ctx)
                if !ok </span><span class="cov0" title="0">{
                        return resp, err
                }</span>

                <span class="cov0" title="0">fm := FromMetadata(md)
                fm.Filter(message)
                return resp, err</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package cel provides definitions for defining the Results CEL environment.
package cel

import (
        "context"
        "log"

        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/decls"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
        ppb "github.com/tektoncd/results/proto/pipeline/v1/pipeline_go_proto"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// NewEnv returns the CEL environment for Results, loading in definitions for
// known types.
func NewEnv() (*cel.Env, error) <span class="cov8" title="1">{
        return cel.NewEnv(
                cel.Types(&amp;pb.Result{}, &amp;pb.Record{}, &amp;ppb.PipelineRun{}, &amp;ppb.TaskRun{}),
                cel.VariableDecls(decls.NewVariable("result", cel.ObjectType("tekton.results.v1alpha2.Result"))),
                cel.VariableDecls(decls.NewVariable("record", cel.ObjectType("tekton.results.v1alpha2.Record"))),
        )
}</span>

// ParseFilter creates a CEL program based on the given filter string.
func ParseFilter(env *cel.Env, filter string) (cel.Program, error) <span class="cov8" title="1">{
        if filter == "" </span><span class="cov8" title="1">{
                return allowAll{}, nil
        }</span>

        <span class="cov8" title="1">ast, issues := env.Compile(filter)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "error parsing filter: %v", issues.Err())
        }</span>

        <span class="cov8" title="1">prg, err := env.Program(ast)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "error creating filter query evaluator: %v", err)
        }</span>
        <span class="cov8" title="1">return prg, nil</span>
}

// allowAll is a CEL program implementation that always returns true.
type allowAll struct{}

func (allowAll) ContextEval(context.Context, any) (ref.Val, *cel.EvalDetails, error) <span class="cov0" title="0">{
        return types.Bool(true), nil, nil
}</span>

func (allowAll) Eval(any) (ref.Val, *cel.EvalDetails, error) <span class="cov0" title="0">{
        return types.Bool(true), nil, nil
}</span>

// Match determines whether the given CEL filter matches the result.
func Match(prg cel.Program, data map[string]any) (bool, error) <span class="cov0" title="0">{
        if prg == nil </span><span class="cov0" title="0">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if data == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">out, details, err := prg.Eval(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to evaluate the expression: %v", err)
                return false, status.Errorf(codes.InvalidArgument, "failed to evaluate filter: %v. Details: %+v", err, details)
        }</span>
        <span class="cov0" title="0">b, ok := out.Value().(bool)
        if !ok </span><span class="cov0" title="0">{
                return false, status.Errorf(codes.InvalidArgument, "expected boolean result, got %s", out.Type().TypeName())
        }</span>
        <span class="cov0" title="0">return b, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cel

import (
        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/types"
        resultspb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        typePipelineRun = "tekton.dev/v1.PipelineRun"
        typeTaskRun     = "tekton.dev/v1.TaskRun"
)

// NewResultsEnv creates a CEL program to build SQL filters for Result objects.
func NewResultsEnv() (*cel.Env, error) <span class="cov0" title="0">{
        return cel.NewEnv(
                cel.Constant("PIPELINE_RUN", cel.StringType, types.String(typePipelineRun)),
                cel.Constant("TASK_RUN", cel.StringType, types.String(typeTaskRun)),
                cel.Constant("UNKNOWN", cel.IntType, types.Int(resultspb.RecordSummary_UNKNOWN)),
                cel.Constant("SUCCESS", cel.IntType, types.Int(resultspb.RecordSummary_SUCCESS)),
                cel.Constant("FAILURE", cel.IntType, types.Int(resultspb.RecordSummary_FAILURE)),
                cel.Constant("TIMEOUT", cel.IntType, types.Int(resultspb.RecordSummary_TIMEOUT)),
                cel.Constant("CANCELLED", cel.IntType, types.Int(resultspb.RecordSummary_CANCELLED)),
                cel.Types(&amp;resultspb.RecordSummary{},
                        &amp;timestamppb.Timestamp{}),
                cel.Variable("parent", cel.StringType),
                cel.Variable("uid", cel.StringType),
                cel.Variable("annotations", cel.MapType(cel.StringType, cel.StringType)),
                cel.Variable("summary",
                        cel.ObjectType("tekton.results.v1alpha2.RecordSummary")),
                cel.Variable("create_time",
                        cel.ObjectType("google.protobuf.Timestamp")),
                cel.Variable("update_time",
                        cel.ObjectType("google.protobuf.Timestamp")),
        )
}</span>

// NewRecordsEnv creates a CEL program to build SQL filters for Record objects.
func NewRecordsEnv() (*cel.Env, error) <span class="cov0" title="0">{
        return cel.NewEnv(
                cel.Constant("PIPELINE_RUN", cel.StringType, types.String(typePipelineRun)),
                cel.Constant("TASK_RUN", cel.StringType, types.String(typeTaskRun)),
                cel.Variable("parent", cel.StringType),
                cel.Variable("result_name", cel.StringType),
                cel.Variable("name", cel.StringType),
                cel.Variable("data_type", cel.StringType),
                cel.Variable("data", cel.AnyType),
        )
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        "fmt"

        exprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
)

// mayBeTranslatedToStringConcatExpression returns a boolean whether the
// expression is a string concatenation. If it is, returns both arguments.
func (i *interpreter) mayBeTranslatedToStringConcatExpression(expr *exprpb.Expr_Call) bool <span class="cov8" title="1">{
        if function := expr.GetFunction(); !isAddOperator(function) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">arg1 := expr.Args[0]
        arg2 := expr.Args[1]
        return i.isString(arg1) || i.isString(arg2)</span>
}

func (i interpreter) allStringConcatArgs(expr *exprpb.Expr) []*exprpb.Expr <span class="cov8" title="1">{
        args := []*exprpb.Expr{}
        switch node := expr.ExprKind.(type) </span>{
        case *exprpb.Expr_CallExpr:<span class="cov8" title="1">
                if isAddOperator(node.CallExpr.Function) </span><span class="cov8" title="1">{
                        arg1 := node.CallExpr.Args[0]
                        arg2 := node.CallExpr.Args[1]
                        args = append(args, i.allStringConcatArgs(arg1)...)
                        args = append(args, i.allStringConcatArgs(arg2)...)
                }</span>
        default:<span class="cov8" title="1">
                args = append(args, expr)</span>
        }
        <span class="cov8" title="1">return args</span>
}

func (i *interpreter) translateToStringConcatExpression(expr *exprpb.Expr) error <span class="cov8" title="1">{
        args := i.allStringConcatArgs(expr)
        fmt.Fprintf(&amp;i.query, "CONCAT(")
        for j, arg := range args </span><span class="cov8" title="1">{
                err := i.interpretExpr(arg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if j != len(args)-1 </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;i.query, ", ")
                }</span>
        }
        <span class="cov8" title="1">fmt.Fprintf(&amp;i.query, ")")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        "fmt"

        "github.com/google/cel-go/cel"
)

// Convert takes CEL expressions and attempt to convert them into Postgres SQL
// filters.
func Convert(env *cel.Env, filters string) (string, error) <span class="cov8" title="1">{
        ast, issues := env.Compile(filters)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error compiling CEL filters: %w", issues.Err())
        }</span>

        <span class="cov8" title="1">if outputType := ast.OutputType(); !outputType.IsAssignableType(cel.BoolType) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("expected boolean expression, but got %s", outputType.String())
        }</span>

        <span class="cov8" title="1">interpreter, err := newInterpreter(ast)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating cel2sql interpreter: %w", err)
        }</span>

        <span class="cov8" title="1">return interpreter.interpret()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        "fmt"

        "github.com/google/cel-go/common/overloads"
        exprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
)

func (i *interpreter) interpretFunctionCallExpr(id int64, expr *exprpb.Expr_Call) error <span class="cov8" title="1">{
        function := expr.GetFunction()
        switch function </span>{
        case overloads.Contains:<span class="cov8" title="1">
                return i.interpretContainsFunction(expr)</span>

        case overloads.EndsWith:<span class="cov8" title="1">
                return i.translateToBinaryCall(expr, "LIKE '%' ||")</span>

        case overloads.TimeGetDate:<span class="cov8" title="1">
                return i.translateToExtractFunctionCall(expr, "DAY", false)</span>

        case overloads.TimeGetDayOfMonth:<span class="cov8" title="1">
                return i.translateToExtractFunctionCall(expr, "DAY", true)</span>

        case overloads.TimeGetDayOfWeek:<span class="cov8" title="1">
                return i.translateToExtractFunctionCall(expr, "DOW", false)</span>

        case overloads.TimeGetDayOfYear:<span class="cov8" title="1">
                return i.translateToExtractFunctionCall(expr, "DOY", true)</span>

        case overloads.TimeGetFullYear:<span class="cov8" title="1">
                return i.translateToExtractFunctionCall(expr, "YEAR", false)</span>

        case overloads.StartsWith:<span class="cov8" title="1">
                return i.interpretStartsWithFunction(expr)</span>

        case overloads.Matches:<span class="cov8" title="1">
                return i.translateToBinaryCall(expr, "~")</span>

        case overloads.TypeConvertTimestamp:<span class="cov8" title="1">
                return i.interpretTimestampFunction(expr)</span>

        }

        <span class="cov0" title="0">return i.unsupportedExprError(id, fmt.Sprintf("`%s` function", function))</span>
}

func (i *interpreter) interpretContainsFunction(expr *exprpb.Expr_Call) error <span class="cov8" title="1">{
        fmt.Fprintf(&amp;i.query, "POSITION(")
        if err := i.interpretExpr(expr.Args[0]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(&amp;i.query, " IN ")
        if err := i.interpretExpr(expr.GetTarget()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.query.WriteString(") &lt;&gt; 0")
        return nil</span>
}

func (i *interpreter) interpretStartsWithFunction(expr *exprpb.Expr_Call) error <span class="cov8" title="1">{
        if err := i.translateToBinaryCall(expr, "LIKE"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.query.WriteString(" || '%'")
        return nil</span>
}

func (i *interpreter) translateToBinaryCall(expr *exprpb.Expr_Call, infixTerm string) error <span class="cov8" title="1">{
        if err := i.interpretExpr(expr.GetTarget()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(&amp;i.query, " %s ", infixTerm)
        return i.interpretExpr(expr.Args[0])</span>
}

func (i *interpreter) translateToExtractFunctionCall(expr *exprpb.Expr_Call, field string, decrementReturnValue bool) error <span class="cov8" title="1">{
        if decrementReturnValue </span><span class="cov8" title="1">{
                i.query.WriteString("(")
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(&amp;i.query, "EXTRACT(%s FROM ", field)
        if err := i.interpretExpr(expr.GetTarget()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if i.isDyn(expr.Target) </span><span class="cov8" title="1">{
                i.coerceWellKnownType(exprpb.Type_TIMESTAMP)
        }</span>
        <span class="cov8" title="1">i.query.WriteString(")")
        if decrementReturnValue </span><span class="cov8" title="1">{
                i.query.WriteString(" - 1)")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (i *interpreter) interpretTimestampFunction(expr *exprpb.Expr_Call) error <span class="cov8" title="1">{
        if err := i.interpretExpr(expr.Args[0]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.query.WriteString("::TIMESTAMP WITH TIME ZONE")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        "fmt"

        "github.com/google/cel-go/common/operators"
        exprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
)

func (i *interpreter) mayBeTranslatedToJSONPathContainsExpression(arg1 *exprpb.Expr, function string, arg2 *exprpb.Expr) bool <span class="cov8" title="1">{
        constExpr := arg2.GetConstExpr()
        if constExpr == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if _, ok := constExpr.GetConstantKind().(*exprpb.Constant_StringValue); !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return isIndexExpr(arg1) &amp;&amp;
                function == operators.Equals &amp;&amp;
                !i.isDyn(arg1.GetCallExpr().Args[0])</span>
}

func isIndexExpr(expr *exprpb.Expr) bool <span class="cov8" title="1">{
        if callExpr := expr.GetCallExpr(); callExpr != nil &amp;&amp; isIndexOperator(callExpr.GetFunction()) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func isIndexOperator(symbol string) bool <span class="cov8" title="1">{
        return symbol == operators.Index
}</span>

func (i *interpreter) translateToJSONPathContainsExpression(arg1 *exprpb.Expr, arg2 *exprpb.Expr) error <span class="cov8" title="1">{
        callExprArgs := arg1.GetCallExpr().GetArgs()
        key := callExprArgs[len(callExprArgs)-1]
        for _, expr := range callExprArgs[0 : len(callExprArgs)-1] </span><span class="cov8" title="1">{
                if err := i.interpretExpr(expr); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">fmt.Fprintf(&amp;i.query, ` @&gt; '{"%s":"%s"}'::jsonb`,
                key.GetConstExpr().GetStringValue(),
                arg2.GetConstExpr().GetStringValue())

        return nil</span>
}

func (i *interpreter) interpretIndexExpr(id int64, expr *exprpb.Expr_Call) error <span class="cov8" title="1">{
        args := expr.GetArgs()
        if args[0].GetSelectExpr() != nil </span><span class="cov8" title="1">{
                return i.interpretSelectExpr(id, args[0].ExprKind.(*exprpb.Expr_SelectExpr), args[1])
        }</span>
        <span class="cov8" title="1">if args[0].GetIdentExpr() != nil </span><span class="cov8" title="1">{
                if err := i.interpretExpr(args[0]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">fmt.Fprintf(&amp;i.query, "-&gt;&gt;'%s'", args[1].GetConstExpr().GetStringValue())

                return nil</span>
        }
        <span class="cov0" title="0">return i.unsupportedExprError(args[1].Id, "index")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        "errors"
        "fmt"
        "strings"
        "time"

        "github.com/google/cel-go/cel"
        exprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
)

const (
        space = " "
)

// ErrUnsupportedExpression is a sentinel error returned when the CEL expression
// cannot be converted to a set of compatible SQL filters.
var ErrUnsupportedExpression = errors.New("unsupported CEL")

// interpreter is a statefull converter of CEL expressions to equivalent SQL
// filters in the Postgres dialect.
type interpreter struct {
        checkedExpr *exprpb.CheckedExpr

        query strings.Builder
}

// newInterpreter takes an abstract syntax tree and returns an Interpreter object capable
// of converting it to a set of SQL filters.
func newInterpreter(ast *cel.Ast) (*interpreter, error) <span class="cov8" title="1">{
        checkedExpr, err := cel.AstToCheckedExpr(ast)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;interpreter{
                checkedExpr: checkedExpr,
        }, nil</span>
}

// interpret attempts to convert the CEL AST into a set of valid SQL filters. It
// returns an error if the conversion cannot be done.
func (i *interpreter) interpret() (string, error) <span class="cov8" title="1">{
        if err := i.interpretExpr(i.checkedExpr.Expr); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(i.query.String()), nil</span>
}

func (i *interpreter) interpretExpr(expr *exprpb.Expr) error <span class="cov8" title="1">{
        id := expr.Id
        switch node := expr.ExprKind.(type) </span>{
        case *exprpb.Expr_ConstExpr:<span class="cov8" title="1">
                return i.interpretConstExpr(id, node.ConstExpr)</span>

        case *exprpb.Expr_IdentExpr:<span class="cov8" title="1">
                return i.interpretIdentExpr(id, node)</span>

        case *exprpb.Expr_SelectExpr:<span class="cov8" title="1">
                return i.interpretSelectExpr(id, node)</span>

        case *exprpb.Expr_CallExpr:<span class="cov8" title="1">
                return i.interpretCallExpr(id, expr)</span>

        case *exprpb.Expr_ListExpr:<span class="cov8" title="1">
                return i.interpretListExpr(node)</span>

        default:<span class="cov0" title="0">
                return i.unsupportedExprError(id, "")</span>
        }
}

// unsupportedExprError attempts to return a descriptive error on why the
// provided CEL expression could not be converted.
func (i *interpreter) unsupportedExprError(id int64, name string) error <span class="cov0" title="0">{
        sourceInfo := i.checkedExpr.SourceInfo
        column := sourceInfo.Positions[id]
        var line int
        for i, offset := range sourceInfo.LineOffsets </span><span class="cov0" title="0">{
                line = i + 1
                if offset &gt; column </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if name != "" </span><span class="cov0" title="0">{
                name += " "
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("%w %sstatement at line %d, column %d", ErrUnsupportedExpression, name, line, column)</span>
}

func (i *interpreter) interpretConstExpr(id int64, expr *exprpb.Constant) error <span class="cov8" title="1">{
        switch expr.ConstantKind.(type) </span>{

        case *exprpb.Constant_NullValue:<span class="cov0" title="0">
                i.query.WriteString("NULL")</span>

        case *exprpb.Constant_BoolValue:<span class="cov0" title="0">
                if expr.GetBoolValue() </span><span class="cov0" title="0">{
                        i.query.WriteString("TRUE")
                }</span> else<span class="cov0" title="0"> {
                        i.query.WriteString("FALSE")
                }</span>

        case *exprpb.Constant_Int64Value:<span class="cov8" title="1">
                fmt.Fprintf(&amp;i.query, "%d", expr.GetInt64Value())</span>

        case *exprpb.Constant_Uint64Value:<span class="cov0" title="0">
                fmt.Fprintf(&amp;i.query, "%d", expr.GetInt64Value())</span>

        case *exprpb.Constant_DoubleValue:<span class="cov0" title="0">
                fmt.Fprintf(&amp;i.query, "%f", expr.GetDoubleValue())</span>

        case *exprpb.Constant_StringValue:<span class="cov8" title="1">
                fmt.Fprintf(&amp;i.query, "'%s'", expr.GetStringValue())</span>

        case *exprpb.Constant_DurationValue:<span class="cov0" title="0">
                fmt.Fprintf(&amp;i.query, "'%d SECONDS'", expr.GetDurationValue().Seconds)</span>

        case *exprpb.Constant_TimestampValue:<span class="cov0" title="0">
                timestamp := expr.GetTimestampValue()
                fmt.Fprintf(&amp;i.query, "TIMESTAMP WITH TIME ZONE '%s'", timestamp.AsTime().Format(time.RFC3339))</span>

        default:<span class="cov0" title="0">
                return i.unsupportedExprError(id, "constant")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

var identToColumn = map[string]string{
        "uid":         "id",
        "create_time": "created_time",
        "update_time": "updated_time",
        "data_type":   "type",
}

func (i *interpreter) interpretIdentExpr(id int64, expr *exprpb.Expr_IdentExpr) error <span class="cov8" title="1">{
        if reference, found := i.checkedExpr.ReferenceMap[id]; found &amp;&amp; reference.GetValue() != nil </span><span class="cov8" title="1">{
                return i.interpretConstExpr(id, reference.GetValue())
        }</span>
        <span class="cov8" title="1">name := expr.IdentExpr.GetName()
        if column, found := identToColumn[name]; found </span><span class="cov8" title="1">{
                name = column
        }</span>
        <span class="cov8" title="1">i.query.WriteString(name)
        return nil</span>
}

type Unquoted struct {
        s string
}

func (u *Unquoted) String() string <span class="cov8" title="1">{
        return u.s
}</span>

type SingleQuoted struct {
        s string
}

func (s *SingleQuoted) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("'%s'", s.s)
}</span>

func (i *interpreter) getIndexKey(expr *exprpb.Expr) (fmt.Stringer, error) <span class="cov8" title="1">{
        callExprArgs := expr.GetCallExpr().GetArgs()
        lastArg := callExprArgs[len(callExprArgs)-1]
        key := lastArg.GetConstExpr()

        switch key.ConstantKind.(type) </span>{
        case *exprpb.Constant_Int64Value:<span class="cov8" title="1">
                return &amp;Unquoted{fmt.Sprintf("%d", key.GetInt64Value())}, nil</span>

        case *exprpb.Constant_StringValue:<span class="cov8" title="1">
                return &amp;SingleQuoted{key.GetStringValue()}, nil</span>

        default:<span class="cov0" title="0">
                return nil, i.unsupportedExprError(lastArg.Id, "constant")</span>
        }
}

func (i *interpreter) getSelectFields(expr *exprpb.Expr) ([]fmt.Stringer, error) <span class="cov8" title="1">{
        var target *exprpb.Expr
        fields := []fmt.Stringer{}
        switch node := expr.ExprKind.(type) </span>{
        case *exprpb.Expr_SelectExpr:<span class="cov8" title="1">
                fields = append(fields, &amp;SingleQuoted{node.SelectExpr.GetField()})
                target = node.SelectExpr.GetOperand()</span>

        case *exprpb.Expr_CallExpr:<span class="cov8" title="1">
                if !isIndexExpr(expr) </span><span class="cov0" title="0">{
                        // TODO: return which function is not supported
                        return nil, i.unsupportedExprError(expr.Id, "function")
                }</span>
                // Sanity check, index function should always have two arguments
                <span class="cov8" title="1">if len(node.CallExpr.Args) != 2 </span><span class="cov0" title="0">{
                        return nil, ErrUnsupportedExpression
                }</span>
                <span class="cov8" title="1">target = node.CallExpr.Args[0]
                index, err := i.getIndexKey(expr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">fields = append(fields, index)</span>
        case *exprpb.Expr_IdentExpr:<span class="cov8" title="1">
                fields = append(fields, &amp;Unquoted{node.IdentExpr.GetName()})
                target = nil</span>
        default:<span class="cov0" title="0">
                return nil, ErrUnsupportedExpression</span>
        }

        <span class="cov8" title="1">if target != nil </span><span class="cov8" title="1">{
                newFields, err := i.getSelectFields(target)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">fields = append(fields, newFields...)</span>
        }

        <span class="cov8" title="1">return fields, nil</span>
}

func (i *interpreter) interpretSelectExpr(id int64, expr *exprpb.Expr_SelectExpr, additionalExprs ...*exprpb.Expr) error <span class="cov8" title="1">{
        fields, err := i.getSelectFields(&amp;exprpb.Expr{Id: id, ExprKind: expr})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">reversedFields := make([]fmt.Stringer, len(fields))
        for j, k := 0, len(fields)-1; j &lt; len(reversedFields); j, k = j+1, k-1 </span><span class="cov8" title="1">{
                reversedFields[j] = fields[k]
        }</span>

        <span class="cov8" title="1">for _, node := range additionalExprs </span><span class="cov8" title="1">{
                switch node.ExprKind.(type) </span>{
                case *exprpb.Expr_ConstExpr:<span class="cov8" title="1">
                        reversedFields = append(reversedFields, &amp;SingleQuoted{node.GetConstExpr().GetStringValue()})</span>

                default:<span class="cov0" title="0">
                        return ErrUnsupportedExpression</span>
                }
        }

        <span class="cov8" title="1">if i.isDyn(expr.SelectExpr.GetOperand()) </span><span class="cov8" title="1">{
                i.translateToJSONAccessors(reversedFields)
                return nil
        }</span>

        <span class="cov8" title="1">if i.isRecordSummary(expr.SelectExpr.GetOperand()) </span><span class="cov8" title="1">{
                i.translateToRecordSummaryColumn(reversedFields)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("%w. %s: not recognized field", i.unsupportedExprError(id, "select"), reversedFields[0])</span>
}

func (i *interpreter) interpretCallExpr(id int64, expr *exprpb.Expr) error <span class="cov8" title="1">{
        callExpr := expr.GetCallExpr()
        function := callExpr.GetFunction()
        if isUnaryOperator(function) </span><span class="cov8" title="1">{
                return i.interpretUnaryCallExpr(callExpr)
        }</span>
        <span class="cov8" title="1">if isBinaryOperator(function) </span><span class="cov8" title="1">{
                return i.interpretBinaryCallExpr(expr)
        }</span>

        <span class="cov8" title="1">if isIndexOperator(function) </span><span class="cov8" title="1">{
                return i.interpretIndexExpr(id, callExpr)
        }</span>

        <span class="cov8" title="1">return i.interpretFunctionCallExpr(id, callExpr)</span>
}

func (i *interpreter) interpretUnaryCallExpr(expr *exprpb.Expr_Call) error <span class="cov8" title="1">{
        sqlOperator := unaryOperators[expr.GetFunction()]
        i.query.WriteString(sqlOperator)
        i.query.WriteString(space)
        i.query.WriteString("(")
        if err := i.interpretExpr(expr.Args[0]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">i.query.WriteString(")")
        return nil</span>
}

func (i *interpreter) interpretBinaryCallExpr(expr *exprpb.Expr) error <span class="cov8" title="1">{
        callExpr := expr.GetCallExpr()
        if isConcat := i.mayBeTranslatedToStringConcatExpression(callExpr); isConcat </span><span class="cov8" title="1">{
                return i.translateToStringConcatExpression(expr)
        }</span>

        <span class="cov8" title="1">function := callExpr.GetFunction()
        arg1 := callExpr.Args[0]
        arg2 := callExpr.Args[1]

        if i.mayBeTranslatedToJSONPathContainsExpression(arg1, function, arg2) </span><span class="cov8" title="1">{
                return i.translateToJSONPathContainsExpression(arg1, arg2)
        }</span>

        <span class="cov8" title="1">if i.mayBeTranslatedToJSONPathContainsExpression(arg2, function, arg1) </span><span class="cov8" title="1">{
                return i.translateToJSONPathContainsExpression(arg2, arg1)
        }</span>

        <span class="cov8" title="1">sqlOperator := binaryOperators[function]
        if (i.isString(arg1) || i.isString(arg2)) &amp;&amp; isAddOperator(function) </span><span class="cov0" title="0">{
                sqlOperator = postgresqlConcatOperator
        }</span>

        <span class="cov8" title="1">i.query.WriteString("(")

        if err := i.interpretExpr(arg1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Implicit coercion
        <span class="cov8" title="1">if i.isDyn(arg1) </span><span class="cov8" title="1">{
                if err := i.coerceToTypeOf(arg2); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">i.query.WriteString(space)
        i.query.WriteString(sqlOperator)
        i.query.WriteString(space)

        if err := i.interpretExpr(arg2); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Implicit coercion
        <span class="cov8" title="1">if i.isDyn(arg2) </span><span class="cov8" title="1">{
                if err := i.coerceToTypeOf(arg1); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">i.query.WriteString(")")

        return nil</span>
}

func (i *interpreter) interpretListExpr(expr *exprpb.Expr_ListExpr) error <span class="cov8" title="1">{
        elements := expr.ListExpr.GetElements()
        i.query.WriteString("(")
        for index, elem := range elements </span><span class="cov8" title="1">{
                if err := i.interpretExpr(elem); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if index &lt; len(elements)-1 </span><span class="cov8" title="1">{
                        i.query.WriteString(", ")
                }</span>
        }
        <span class="cov8" title="1">i.query.WriteString(")")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        "github.com/google/cel-go/common/operators"
)

var (
        unaryOperators = map[string]string{
                operators.LogicalNot: "NOT",
        }

        binaryOperators = map[string]string{
                operators.LogicalAnd:    "AND",
                operators.LogicalOr:     "OR",
                operators.Equals:        "=",
                operators.NotEquals:     "&lt;&gt;",
                operators.Less:          "&lt;",
                operators.LessEquals:    "&lt;=",
                operators.Greater:       "&gt;",
                operators.GreaterEquals: "&gt;=",
                operators.Add:           "+",
                operators.Subtract:      "-",
                operators.Multiply:      "*",
                operators.Divide:        "/",
                operators.Modulo:        "%",
                operators.In:            "IN",
        }
        postgresqlConcatOperator = "||"
)

// isUnaryOperator returns true if the symbol in question is a CEL unary
// operator.
func isUnaryOperator(symbol string) bool <span class="cov8" title="1">{
        _, found := unaryOperators[symbol]
        return found
}</span>

// isBinaryOperator returns true if the symbol in question is a CEL binary
// operator.
func isBinaryOperator(symbol string) bool <span class="cov8" title="1">{
        _, found := binaryOperators[symbol]
        return found
}</span>

func isAddOperator(symbol string) bool <span class="cov8" title="1">{
        return symbol == operators.Add
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        "fmt"

        "gorm.io/gorm/schema"
)

// translateToJSONAccessors converts the provided field path to a Postgres JSON
// property selection directive. This allows us to yield appropriate SQL
// expressions to navigate through the record.data field, for instance.
func (i *interpreter) translateToJSONAccessors(fieldPath []fmt.Stringer) <span class="cov8" title="1">{
        lastField := fieldPath[len(fieldPath)-1]
        fmt.Fprintf(&amp;i.query, "(")
        if len(fieldPath) &gt; 1 </span><span class="cov8" title="1">{
                for _, field := range fieldPath[0 : len(fieldPath)-1] </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;i.query, "%s-&gt;", field)
                }</span>
        }
        <span class="cov8" title="1">fmt.Fprintf(&amp;i.query, "&gt;%s", lastField)
        fmt.Fprintf(&amp;i.query, ")")</span>
}

// translateToRecordSummaryColumn
func (i *interpreter) translateToRecordSummaryColumn(fieldPath []fmt.Stringer) <span class="cov8" title="1">{
        namer := &amp;schema.NamingStrategy{}
        switch f := fieldPath[1].(type) </span>{
        case *Unquoted:<span class="cov0" title="0">
                fmt.Fprintf(&amp;i.query, "recordsummary_%s", namer.ColumnName("", f.s))</span>
        case *SingleQuoted:<span class="cov8" title="1">
                fmt.Fprintf(&amp;i.query, "recordsummary_%s", namer.ColumnName("", f.s))</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cel2sql

import (
        exprpb "google.golang.org/genproto/googleapis/api/expr/v1alpha1"
)

// isDyn returns true if the provided expression is a CEL dyn type or false
// otherwise.
func (i *interpreter) isDyn(expr *exprpb.Expr) bool <span class="cov8" title="1">{
        if theType, found := i.checkedExpr.TypeMap[expr.GetId()]; found </span><span class="cov8" title="1">{
                if _, ok := theType.GetTypeKind().(*exprpb.Type_Dyn); ok </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isString returns true if the provided expression is a CEL string type or
// false otherwise.
func (i *interpreter) isString(expr *exprpb.Expr) bool <span class="cov8" title="1">{
        if theType, found := i.checkedExpr.TypeMap[expr.GetId()]; found </span><span class="cov8" title="1">{
                if p, ok := theType.GetTypeKind().(*exprpb.Type_Primitive); ok </span><span class="cov8" title="1">{
                        return p.Primitive == exprpb.Type_STRING
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (i *interpreter) isRecordSummary(expr *exprpb.Expr) bool <span class="cov8" title="1">{
        if theType, found := i.checkedExpr.TypeMap[expr.GetId()]; found </span><span class="cov8" title="1">{
                if messageType := theType.GetMessageType(); messageType == "tekton.results.v1alpha2.RecordSummary" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// coerceToTypeOf writes a Postgres cast directive to the current position of
// the SQL statement in the buffer, in order to cast the current SQL expression
// to the SQL type of the provided CEL expression. This feature provides
// implicit coercion to the supported expressions, by allowing users to compare
// dyn types to more specific types in a transparent manner.
//
// For instance, in the following expression:
// ```go
// data.status.completionTime &gt; timestamp("2022/10/30T21:45:00.000Z")
// ```
// the data field is a dyn type which maps to a jsonb in the Postgres
// database. The implicit coercion casts the completionTime to a SQL timestamp
// in the returned SQL filter.
func (i *interpreter) coerceToTypeOf(expr *exprpb.Expr) error <span class="cov8" title="1">{
        if theType, found := i.checkedExpr.TypeMap[expr.GetId()]; found </span><span class="cov8" title="1">{
                switch theType.GetTypeKind().(type) </span>{

                case *exprpb.Type_WellKnown:<span class="cov8" title="1">
                        i.coerceWellKnownType(theType.GetWellKnown())</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov0" title="0">return ErrUnsupportedExpression</span>
}

func (i *interpreter) coerceWellKnownType(wellKnown exprpb.Type_WellKnownType) <span class="cov8" title="1">{
        switch wellKnown </span>{

        case exprpb.Type_TIMESTAMP:<span class="cov8" title="1">
                i.query.WriteString("::TIMESTAMP WITH TIME ZONE")</span>

        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "log"

        "github.com/spf13/viper"
)

type Config struct {
        DB_USER                  string `mapstructure:"DB_USER"`
        DB_PASSWORD              string `mapstructure:"DB_PASSWORD"`
        DB_HOST                  string `mapstructure:"DB_HOST"`
        DB_PORT                  string `mapstructure:"DB_PORT"`
        DB_NAME                  string `mapstructure:"DB_NAME"`
        DB_SSLMODE               string `mapstructure:"DB_SSLMODE"`
        DB_SSLROOTCERT           string `mapstructure:"DB_SSLROOTCERT"`
        DB_ENABLE_AUTO_MIGRATION bool   `mapstructure:"DB_ENABLE_AUTO_MIGRATION"`
        DB_MAX_IDLE_CONNECTIONS  int    `mapstructure:"DB_MAX_IDLE_CONNECTIONS"`
        DB_MAX_OPEN_CONNECTIONS  int    `mapstructure:"DB_MAX_OPEN_CONNECTIONS"`
        SERVER_PORT              string `mapstructure:"SERVER_PORT"`
        PROMETHEUS_PORT          string `mapstructure:"PROMETHEUS_PORT"`
        PROMETHEUS_HISTOGRAM     bool   `mapstructure:"PROMETHEUS_HISTOGRAM"`
        LOG_LEVEL                string `mapstructure:"LOG_LEVEL"`
        SQL_LOG_LEVEL            string `mapstructure:"SQL_LOG_LEVEL"`
        TLS_PATH                 string `mapstructure:"TLS_PATH"`
        FEATURE_GATES            string `mapstructure:"FEATURE_GATES"`

        GRPC_WORKER_POOL int `mapstructure:"GRPC_WORKER_POOL"`
        K8S_QPS          int `mapstructure:"K8S_QPS"`
        K8S_BURST        int `mapstructure:"K8S_BURST"`

        AUTH_DISABLE     bool `mapstructure:"AUTH_DISABLE"`
        AUTH_IMPERSONATE bool `mapstructure:"AUTH_IMPERSONATE"`

        LOGS_API         bool   `mapstructure:"LOGS_API"`
        LOGS_TYPE        string `mapstructure:"LOGS_TYPE"`
        LOGS_BUFFER_SIZE int    `mapstructure:"LOGS_BUFFER_SIZE"`
        LOGS_PATH        string `mapstructure:"LOGS_PATH"`
        LOGS_TIMESTAMPS  bool   `mapstructure:"LOGS_TIMESTAMPS"`

        PROFILING      bool   `mapstructure:"PROFILING"`
        PROFILING_PORT string `mapstructure:"PROFILING_PORT"`

        GCS_BUCKET_NAME       string `mapstructure:"GCS_BUCKET_NAME"`
        STORAGE_EMULATOR_HOST string `mapstructure:"STORAGE_EMULATOR_HOST"`

        S3_BUCKET_NAME        string `mapstructure:"S3_BUCKET_NAME"`
        S3_ENDPOINT           string `mapstructure:"S3_ENDPOINT"`
        S3_HOSTNAME_IMMUTABLE bool   `mapstructure:"S3_HOSTNAME_IMMUTABLE"`
        S3_REGION             string `mapstructure:"S3_REGION"`
        S3_ACCESS_KEY_ID      string `mapstructure:"S3_ACCESS_KEY_ID"`
        S3_SECRET_ACCESS_KEY  string `mapstructure:"S3_SECRET_ACCESS_KEY"`
        S3_MULTI_PART_SIZE    int64  `mapstructure:"S3_MULTI_PART_SIZE"`

        CONVERTER_ENABLE   bool `mapstructure:"CONVERTER_ENABLE"`
        CONVERTER_DB_LIMIT int  `mapstructure:"CONVERTER_DB_LIMIT"`

        LOGGING_PLUGIN_API_URL                  string `mapstructure:"LOGGING_PLUGIN_API_URL"`
        LOGGING_PLUGIN_NAMESPACE_KEY            string `mapstructure:"LOGGING_PLUGIN_NAMESPACE_KEY"`
        LOGGING_PLUGIN_CONTAINER_KEY            string `mapstructure:"LOGGING_PLUGIN_CONTAINER_KEY"`
        LOGGING_PLUGIN_STATIC_LABELS            string `mapstructure:"LOGGING_PLUGIN_STATIC_LABELS"`
        LOGGING_PLUGIN_TOKEN_PATH               string `mapstructure:"LOGGING_PLUGIN_TOKEN_PATH"`
        LOGGING_PLUGIN_PROXY_PATH               string `mapstructure:"LOGGING_PLUGIN_PROXY_PATH"`
        LOGGING_PLUGIN_CA_CERT                  string `mapstructure:"LOGGING_PLUGIN_CA_CERT"`
        LOGGING_PLUGIN_QUERY_LIMIT              uint   `mapstructure:"LOGGING_PLUGIN_QUERY_LIMIT"`
        LOGGING_PLUGIN_TLS_VERIFICATION_DISABLE bool   `mapstructure:"LOGGING_PLUGIN_TLS_VERIFICATION_DISABLE"`
        LOGGING_PLUGIN_FORWARDER_DELAY_DURATION int64  `mapstructure:"LOGGING_PLUGIN_FORWARDER_DELAY_DURATION"`
        LOGGING_PLUGIN_QUERY_PARAMS             string `mapstructure:"LOGGING_PLUGIN_QUERY_PARAMS"`
        LOGGING_PLUGIN_MULTIPART_REGEX          string `mapstructure:"LOGGING_PLUGIN_MULTIPART_REGEX"`
}

func Get() *Config <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("env")
        viper.AddConfigPath("/etc/tekton/results")
        viper.AddConfigPath("config/base/env")
        viper.AddConfigPath("config")
        viper.AddConfigPath(".")

        viper.AutomaticEnv()

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error reading config: %v", err)
        }</span>

        <span class="cov0" title="0">config := Config{}
        if err := viper.Unmarshal(&amp;config); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Cannot load config:", err)
        }</span>

        <span class="cov0" title="0">return &amp;config</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package errors

import (
        "errors"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gorm.io/gorm"
)

var (
        errorSpace ErrorSpace
)

// ErrorSpace allows implementations to inject database specific error checking
// to the application.
type ErrorSpace func(error) codes.Code

// RegisterErrorSpace registers the ErrorSpace - last one wins.
func RegisterErrorSpace(f ErrorSpace) <span class="cov0" title="0">{
        errorSpace = f
}</span>

// Wrap converts database error codes into their corresponding gRPC status
// codes.
func Wrap(err error) error <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check for gorm provided errors first - these are more likely to be
        // supported across drivers.
        <span class="cov0" title="0">if code, ok := gormCode(err); ok </span><span class="cov0" title="0">{
                return status.Error(code, err.Error())
        }</span>

        // Fallback to implementation specific codes.
        <span class="cov0" title="0">if errorSpace != nil </span><span class="cov0" title="0">{
                return status.Error(errorSpace(err), err.Error())
        }</span>

        <span class="cov0" title="0">return err</span>
}

// gormCode returns gRPC status codes corresponding to gorm errors. This is not
// an exhaustive list.
// See https://pkg.go.dev/gorm.io/gorm@v1.20.7#pkg-variables for list of
// errors.
func gormCode(err error) (codes.Code, bool) <span class="cov0" title="0">{
        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                return codes.NotFound, true
        }</span>
        <span class="cov0" title="0">return codes.Unknown, false</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package sqlite provides sqlite-specific error checking. This is
// purposefully broken out from the rest of the errors package so that we can
// isolate go-sqlite3's cgo dependency away from the main MySQL based library
// to simplify our testing + deployment.
package sqlite

import (
        "github.com/mattn/go-sqlite3"
        "github.com/tektoncd/results/pkg/api/server/db/errors"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// sqlite converts sqlite3 error codes to gRPC status codes. This is not an
// exhaustive list.
// See https://pkg.go.dev/github.com/mattn/go-sqlite3#pkg-variables for list of
// error codes.
func sqlite(err error) codes.Code <span class="cov0" title="0">{
        serr, ok := err.(sqlite3.Error)
        if !ok </span><span class="cov0" title="0">{
                return status.Code(err)
        }</span>

        <span class="cov0" title="0">switch serr.Code </span>{
        case sqlite3.ErrConstraint:<span class="cov0" title="0">
                switch serr.ExtendedCode </span>{
                case sqlite3.ErrConstraintUnique:<span class="cov0" title="0">
                        return codes.AlreadyExists</span>
                case sqlite3.ErrConstraintForeignKey:<span class="cov0" title="0">
                        return codes.FailedPrecondition</span>
                }
                <span class="cov0" title="0">return codes.InvalidArgument</span>
        case sqlite3.ErrNotFound:<span class="cov0" title="0">
                return codes.NotFound</span>
        }
        <span class="cov0" title="0">return status.Code(err)</span>
}

func init() <span class="cov0" title="0">{
        errors.RegisterErrorSpace(sqlite)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2025 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package db defines database models for Result data.
package db

import (
        "errors"

        gormlogger "gorm.io/gorm/logger"
)

var (
        logLevel = map[string]gormlogger.LogLevel{
                "silent": gormlogger.Silent,
                "error":  gormlogger.Error,
                "warn":   gormlogger.Warn,
                "info":   gormlogger.Info,
        }
)

// SetLogLevel for the Default GormLogger
func SetLogLevel(level string) error <span class="cov0" title="0">{
        if _, ok := logLevel[level]; !ok </span><span class="cov0" title="0">{
                return errors.New("undefined log level for sql")
        }</span>
        <span class="cov0" title="0">gormlogger.Default.LogMode(logLevel[level])
        return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package db defines database models for Result data.
package db

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "fmt"
        "time"
)

// Result is the database model of a Result.
type Result struct {
        Parent      string      `gorm:"primaryKey;uniqueIndex:results_by_name,priority:1;size:64;"`
        ID          string      `gorm:"primaryKey;size:64;"`
        Name        string      `gorm:"uniqueIndex:results_by_name,priority:2;size:64;"`
        Annotations Annotations `gorm:"type:jsonb;"`

        CreatedTime time.Time `gorm:"default:current_timestamp;"`
        UpdatedTime time.Time `gorm:"default:current_timestamp;"`

        Summary RecordSummary `gorm:"embedded;embeddedPrefix:recordsummary_;"`

        Etag string `gorm:"size:128;"`
}

// RecordSummary is the database model of a Result.RecordSummary.
type RecordSummary struct {
        Record string `gorm:"size:256;"`
        // Napkin Math (with a bit of buffer): 256 (DNS Subdomain) * 3 (Group +
        // Version + Kind).
        Type        string `gorm:"size:768;"`
        StartTime   *time.Time
        EndTime     *time.Time
        Status      int32
        Annotations Annotations `gorm:"type:jsonb;"`
}

func (r Result) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("(%s, %s)", r.Parent, r.ID)
}</span>

// Record is the database model of a Record
type Record struct {
        // Result is used to create the relationship between the Result and Records
        // table. Data will not be returned here during reads. Use the foreign key
        // fields instead.
        Result     Result `gorm:"foreignKey:Parent,ResultID;references:Parent,ID;constraint:OnUpdate:CASCADE,OnDelete:CASCADE;"`
        Parent     string `gorm:"primaryKey;uniqueIndex:records_by_name,priority:1;size:64;"`
        ResultID   string `gorm:"primaryKey;size:64;"`
        ResultName string `gorm:"uniqueIndex:records_by_name,priority:2;size:64;"`

        ID   string `gorm:"primaryKey;size:64;"`
        Name string `gorm:"index:records_by_name,priority:3;size:64;"`

        // Napkin Math (with a bit of buffer): 256 (DNS Subdomain) * 3 (Group +
        // Version + Kind).
        Type string `gorm:"size:768;"`
        Data []byte `gorm:"type:jsonb;"`

        CreatedTime time.Time `gorm:"default:current_timestamp;"`
        UpdatedTime time.Time `gorm:"default:current_timestamp;"`

        Etag string `gorm:"size:128;"`
}

// Annotations is a custom-defined type of a gorm model field.
type Annotations map[string]string

// Scan resolves serialized data read from database into an Annotation.
// This implements the sql.Scanner interface.
func (ann *Annotations) Scan(value any) error <span class="cov8" title="1">{
        if ann == nil </span><span class="cov8" title="1">{
                return errors.New("the annotation pointer mustn't be nil")
        }</span>
        <span class="cov8" title="1">bytes, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("wanted []byte, got %T: %+v", value, value)
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(bytes, ann)</span>
}

// Value returns the value of Annotations for database driver. This implements driver.Valuer.
// gorm uses this function to convert a database model's Annotation field into a type that gorm
// driver can write into the database.
func (ann Annotations) Value() (driver.Value, error) <span class="cov8" title="1">{
        bytes, err := json.Marshal(ann)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bytes, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pagination

import (
        "encoding/base64"
        "math"

        pb "github.com/tektoncd/results/pkg/api/server/db/pagination/proto/internal_go_proto"
        "google.golang.org/protobuf/proto"
)

// EncodeToken encodes a name + filter to an opaque page token
func EncodeToken(name, filter string) (token string, err error) <span class="cov8" title="1">{
        pi := &amp;pb.ListPageIdentifier{
                Name:   name,
                Filter: filter,
        }
        var tokenByte []byte
        if tokenByte, err = proto.Marshal(pi); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">encodedResult := make([]byte, base64.RawURLEncoding.EncodedLen(len(tokenByte)))
        base64.RawURLEncoding.Encode(encodedResult, tokenByte)
        return base64.RawURLEncoding.EncodeToString(encodedResult), nil</span>
}

// DecodeToken decodes an opaque page token into its name and filter parts.
func DecodeToken(token string) (name, filter string, err error) <span class="cov8" title="1">{
        var encodedToken []byte
        if encodedToken, err = base64.RawURLEncoding.DecodeString(token); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">tokenByte := make([]byte, base64.RawURLEncoding.DecodedLen(len(encodedToken)))
        if _, err = base64.RawURLEncoding.Decode(tokenByte, encodedToken); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">pi := &amp;pb.ListPageIdentifier{}
        if err = proto.Unmarshal(tokenByte, pi); err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>
        <span class="cov8" title="1">return pi.GetName(), pi.GetFilter(), err</span>
}

// Batcher suggests dynamic batch sizes for list queries.
type Batcher struct {
        // Total number of items we want to fetch
        want int

        // Min/Max thresholds of number of items to fetch for a given batch.
        min, max int

        // ratio is used to detemine batch sizes relative to the wanted number of
        // results. This value changes each iteration based the number of items
        // successfully fetches and the total number of items fetched in the
        // previous batch. The less the previous ratio is, the bigger the upcoming
        // batch_size is.
        ratio float64
}

// NewBatcher creates a new batcher for the given requested page size.
func NewBatcher(want, mini, maxi int) *Batcher <span class="cov8" title="1">{
        return &amp;Batcher{
                want:  want,
                min:   mini,
                max:   maxi,
                ratio: 1,
        }
}</span>

// Update updates the Batcher based on the results of the last batch.
// `matched` is the number of items successfully matched by filters.
// `total` is the total number of rows last fetched.
// This calculates a new value to be used for calls to Next.
func (b *Batcher) Update(matched, total int) <span class="cov8" title="1">{
        b.ratio = float64(matched) / float64(total)
}</span>

// Next returns the recommended next batch size to query.
func (b *Batcher) Next() int <span class="cov8" title="1">{
        n := int(math.Ceil(float64(b.want) / b.ratio))
        if n &gt; b.max </span><span class="cov8" title="1">{
                return b.max
        }</span>
        <span class="cov8" title="1">return n</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package features

import (
        "fmt"
        "sort"
        "strconv"
        "strings"
        "sync/atomic"
)

// Feature is a string representation of a set of enabled/disabled features.
type Feature string

const (
        // PartialResponse feature enables response filtering
        PartialResponse Feature = "PartialResponse"
)

var defaultFeatures = map[Feature]bool{
        PartialResponse: false,
}

// FeatureGate provides a interface to manipulate features.
type FeatureGate interface {
        // Get returns true if the key is enabled.
        Get(f Feature) *atomic.Bool
        // Set parses and stores flag gates for known features
        // from a string like feature1=true,feature2=false,...
        Set(value string) error
        // String returns a string representation of the known features
        // in the following form feature1=true,feature2=false,...
        String() string
        // Enable will enable a feature
        Enable(f Feature)
        // Disable will disable a feature
        Disable(f Feature)
}

type featureGate map[Feature]*atomic.Bool

// NewFeatureGate creates a new FeatureGate
func NewFeatureGate() FeatureGate <span class="cov8" title="1">{
        fg := featureGate{}
        for k, v := range defaultFeatures </span><span class="cov8" title="1">{
                a := new(atomic.Bool)
                a.Store(v)
                fg[k] = a
        }</span>
        <span class="cov8" title="1">return fg</span>
}

// Get returns if a feature is enabled
func (fg featureGate) Get(f Feature) *atomic.Bool <span class="cov8" title="1">{
        if v, ok := fg[f]; ok </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Set parses an input string and sets the FeatureGate
func (fg featureGate) Set(value string) error <span class="cov8" title="1">{
        value = strings.TrimSpace(value)
        for _, s := range strings.Split(value, ",") </span><span class="cov8" title="1">{
                if len(s) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">pair := strings.SplitN(s, "=", 2)
                f := Feature(pair[0])
                v := pair[1]
                if len(pair) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("missing value for feature %s", f)
                }</span>
                <span class="cov8" title="1">b, err := strconv.ParseBool(v)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid value of %s=%s, err: %v", f, v, err)
                }</span>
                <span class="cov8" title="1">if v, ok := fg[f]; ok </span><span class="cov8" title="1">{
                        v.Swap(b)
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("feature '%s' is not supported", f)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Disable disables a feature
func (fg featureGate) Disable(f Feature) <span class="cov8" title="1">{
        if v, ok := fg[f]; ok </span><span class="cov8" title="1">{
                v.Swap(false)
        }</span>
}

// Enable enables a feature
func (fg featureGate) Enable(f Feature) <span class="cov8" title="1">{
        if v, ok := fg[f]; ok </span><span class="cov8" title="1">{
                v.Swap(true)
        }</span>
}

// String returns the value of the FeatureGate as string representation
func (fg featureGate) String() string <span class="cov8" title="1">{
        var pairs []string
        for k, v := range fg </span><span class="cov8" title="1">{
                pairs = append(pairs, fmt.Sprintf("%s=%t", k, v.Load()))
        }</span>
        <span class="cov8" title="1">sort.Strings(pairs)
        return strings.Join(pairs, ",")</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package logger

import (
        "log"

        "go.uber.org/zap"
)

// Get returns instance sugared zap logger with production configuration
func Get(level string) *zap.SugaredLogger <span class="cov0" title="0">{
        config := zap.NewProductionConfig()
        if len(level) &gt; 0 </span><span class="cov0" title="0">{
                var err error
                if config.Level, err = zap.ParseAtomicLevel(level); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to parse log level from config: %v", err)
                }</span>
        }

        <span class="cov0" title="0">logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize zap logger: %v", err)
        }</span>

        <span class="cov0" title="0">return logger.Sugar()</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package impersonation

import (
        "context"
        "errors"
        "fmt"

        "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
        "google.golang.org/grpc/metadata"
        authenticationv1 "k8s.io/api/authentication/v1"
        authorizationv1 "k8s.io/api/authorization/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apiserver/pkg/authentication/user"
        authorizationclient "k8s.io/client-go/kubernetes/typed/authorization/v1"

        "net/url"
        "strings"

        "k8s.io/apiserver/pkg/authentication/serviceaccount"
)

// Impersonation represents component to add Kubernetes impersonation header processing,
// make impersonation access check and RBAC for Tekton results resources with impersonated user data
type Impersonation struct {
        resourceAttributes []authorizationv1.ResourceAttributes
        userInfo           *user.DefaultInfo
}

var (
        // ErrNoImpersonationData is an error message for no impersonation data case
        ErrNoImpersonationData = errors.New("no impersonation data found")
        // ErrImpersonateUserRequired is an error message about required impersonate user to impersonate another info.
        ErrImpersonateUserRequired = errors.New("impersonate user is required to impersonate groups, UID, extra")
)

// NewImpersonation returns an impersonation request if any impersonation data is found, returns error otherwise.
func NewImpersonation(md metadata.MD) (*Impersonation, error) <span class="cov8" title="1">{
        i := &amp;Impersonation{}
        if err := i.parseMetadata(md); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return i, nil</span>
}

// parseMetadata parses the gRPC metadata and returns a lst of object references that represents the Impersonation data.
func (i *Impersonation) parseMetadata(md metadata.MD) error <span class="cov8" title="1">{
        i.userInfo = &amp;user.DefaultInfo{}
        users := md.Get(authenticationv1.ImpersonateUserHeader)
        hasUser := len(users) &gt; 0
        if hasUser </span><span class="cov8" title="1">{
                if namespace, name, err := serviceaccount.SplitUsername(users[0]); err == nil </span><span class="cov0" title="0">{
                        i.userInfo.Name = serviceaccount.MakeUsername(namespace, name)
                        i.resourceAttributes = append(i.resourceAttributes, authorizationv1.ResourceAttributes{
                                Name:      name,
                                Namespace: namespace,
                                Resource:  "serviceaccounts",
                                Verb:      "impersonate",
                        })

                        // If groups aren't specified for a service account, we know the groups because it's a fixed mapping.
                        if len(md.Get(authenticationv1.ImpersonateGroupHeader)) == 0 </span><span class="cov0" title="0">{
                                i.userInfo.Groups = serviceaccount.MakeGroupNames(namespace)
                        }</span>
                } else<span class="cov8" title="1"> {
                        i.userInfo.Name = users[0]
                        i.resourceAttributes = append(i.resourceAttributes, authorizationv1.ResourceAttributes{
                                Name:     users[0],
                                Resource: "users",
                                Verb:     "impersonate",
                        })
                }</span>
        }

        <span class="cov8" title="1">groups := md.Get(authenticationv1.ImpersonateGroupHeader)
        hasGroups := len(groups) &gt; 0
        if hasGroups </span><span class="cov8" title="1">{
                for _, group := range groups </span><span class="cov8" title="1">{
                        i.userInfo.Groups = append(i.userInfo.Groups, group)
                        i.resourceAttributes = append(i.resourceAttributes, authorizationv1.ResourceAttributes{
                                Name:     group,
                                Resource: "groups",
                                Verb:     "impersonate",
                        })
                }</span>
        }

        <span class="cov8" title="1">UIDs := md.Get(authenticationv1.ImpersonateUIDHeader)
        hasUID := len(UIDs) &gt; 0
        if hasUID </span><span class="cov8" title="1">{
                i.userInfo.UID = UIDs[0]
                i.resourceAttributes = append(i.resourceAttributes, authorizationv1.ResourceAttributes{
                        Group:    authenticationv1.SchemeGroupVersion.Group,
                        Name:     UIDs[0],
                        Resource: "uids",
                        Verb:     "impersonate",
                })
        }</span>

        <span class="cov8" title="1">hasExtra := false
        for name, values := range md </span><span class="cov8" title="1">{
                if !strings.HasPrefix(name, strings.ToLower(authenticationv1.ImpersonateUserExtraHeaderPrefix)) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">hasExtra = true
                extraKey := unescapeExtraKey(strings.ToLower(name[len(authenticationv1.ImpersonateUserExtraHeaderPrefix):]))
                i.userInfo.Extra = make(map[string][]string)
                // Each extra value is a separate resource to check.
                for _, value := range values </span><span class="cov8" title="1">{
                        i.userInfo.Extra[extraKey] = append(i.userInfo.Extra[extraKey], value)
                        i.resourceAttributes = append(i.resourceAttributes, authorizationv1.ResourceAttributes{
                                Group:       authenticationv1.SchemeGroupVersion.Group,
                                Name:        value,
                                Resource:    "userextras",
                                Subresource: extraKey,
                                Verb:        "impersonate",
                        })
                }</span>
        }

        // When impersonating a non-anonymous user, include the 'system:authenticated' group in the impersonated user info:
        // - if no groups were specified
        // - if a group has been specified other than 'system:authenticated'
        // If 'system:unauthenticated' group has been specified we should not include the 'system:authenticated' group.
        <span class="cov8" title="1">if hasUser </span><span class="cov8" title="1">{
                if i.userInfo.Name != user.Anonymous </span><span class="cov8" title="1">{
                        addAuthenticated := true
                        for _, group := range i.userInfo.Groups </span><span class="cov8" title="1">{
                                if group == user.AllAuthenticated || group == user.AllUnauthenticated </span><span class="cov0" title="0">{
                                        addAuthenticated = false
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">if addAuthenticated </span><span class="cov8" title="1">{
                                i.userInfo.Groups = append(i.userInfo.Groups, user.AllAuthenticated)
                        }</span>
                } else<span class="cov0" title="0"> {
                        addUnauthenticated := true
                        for _, group := range i.userInfo.Groups </span><span class="cov0" title="0">{
                                if group == user.AllUnauthenticated </span><span class="cov0" title="0">{
                                        addUnauthenticated = false
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if addUnauthenticated </span><span class="cov0" title="0">{
                                i.userInfo.Groups = append(i.userInfo.Groups, user.AllUnauthenticated)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                i.userInfo = nil

                // Impersonate-User header is mandatory.
                // https://kubernetes.io/docs/reference/access-authn-authz/authentication/#user-impersonation
                if hasGroups || hasExtra || hasUID </span><span class="cov8" title="1">{
                        return ErrImpersonateUserRequired
                }</span>
                <span class="cov8" title="1">return ErrNoImpersonationData</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func unescapeExtraKey(encodedKey string) string <span class="cov8" title="1">{
        key, err := url.PathUnescape(encodedKey) // Decode %-encoded bytes.
        if err != nil </span><span class="cov0" title="0">{
                return encodedKey // Always record extra strings, even if malformed/unencoded.
        }</span>
        <span class="cov8" title="1">return key</span>
}

// Check checks if the requester has permission to impersonate every resource.
func (i *Impersonation) Check(ctx context.Context, authorizer authorizationclient.AuthorizationV1Interface, requester string) error <span class="cov8" title="1">{
        if i.resourceAttributes == nil </span><span class="cov0" title="0">{
                return ErrNoImpersonationData
        }</span>
        <span class="cov8" title="1">for _, resourceAttribute := range i.resourceAttributes </span><span class="cov8" title="1">{
                sar, err := authorizer.SubjectAccessReviews().Create(ctx, &amp;authorizationv1.SubjectAccessReview{
                        Spec: authorizationv1.SubjectAccessReviewSpec{
                                User: requester,
                                ResourceAttributes: &amp;authorizationv1.ResourceAttributes{
                                        Group:       resourceAttribute.Group,
                                        Name:        resourceAttribute.Name,
                                        Namespace:   resourceAttribute.Namespace,
                                        Resource:    resourceAttribute.Resource,
                                        Subresource: resourceAttribute.Subresource,
                                        Verb:        resourceAttribute.Verb,
                                },
                        },
                }, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !sar.Status.Allowed </span><span class="cov8" title="1">{
                        return fmt.Errorf("forbidden: '%s' doesn't have permission to impersonate '%s'", requester, resourceAttribute.Resource)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetUserInfo returns the impersonated user information.
func (i *Impersonation) GetUserInfo() *user.DefaultInfo <span class="cov0" title="0">{
        return i.userInfo
}</span>

// HeaderMatcher matches the impersonation header for adding to GRPC metadata.
func HeaderMatcher(key string) (string, bool) <span class="cov8" title="1">{
        if strings.HasPrefix(key, authenticationv1.ImpersonateUserExtraHeaderPrefix) </span><span class="cov8" title="1">{
                return key, true
        }</span>

        <span class="cov8" title="1">switch key </span>{
        case authenticationv1.ImpersonateUserHeader:<span class="cov8" title="1">
                return key, true</span>
        case authenticationv1.ImpersonateGroupHeader:<span class="cov0" title="0">
                return key, true</span>
        case authenticationv1.ImpersonateUIDHeader:<span class="cov0" title="0">
                return key, true</span>
        default:<span class="cov8" title="1">
                return runtime.DefaultHeaderMatcher(key)</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2021 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package auth

import "context"

// AllowAll is an auth check that allows every request, regardless of the
// params. Useful for testing or cases where you want to disable auth checks.
type AllowAll struct{}

// Check does nothing.
func (AllowAll) Check(context.Context, string, string, string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2021 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package auth

import (
        "context"
        "errors"
        "fmt"
        "log"
        "strings"

        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth/impersonation"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        authnv1 "k8s.io/api/authentication/v1"
        authzv1 "k8s.io/api/authorization/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        authnclient "k8s.io/client-go/kubernetes/typed/authentication/v1"
        authzclient "k8s.io/client-go/kubernetes/typed/authorization/v1"
)

// RBAC is a Kubernetes RBAC based auth checker. This uses the Kubernetes
// TokenReview and SubjectAccessReview APIs to defer auth decisions to the
// cluster.
// Users should pass in `token` metadata through the gRPC context.
// This checks RBAC permissions in the `results.tekton.dev` group, and assumes
// checks are done at the namespace
type RBAC struct {
        allowImpersonation bool
        authn              authnclient.AuthenticationV1Interface
        authz              authzclient.AuthorizationV1Interface
}

// Option is configuration option for RBAC checker.
type Option func(*RBAC)

// NewRBAC returns new instance of the Kubernetes RBAC based auth checker.
func NewRBAC(client kubernetes.Interface, options ...Option) *RBAC <span class="cov8" title="1">{
        rbac := &amp;RBAC{
                authn: client.AuthenticationV1(),
                authz: client.AuthorizationV1(),
        }
        for _, option := range options </span><span class="cov8" title="1">{
                option(rbac)
        }</span>
        <span class="cov8" title="1">return rbac</span>
}

// Check determines if resource can be accessed with impersonation metadata stored in the context.
func (r *RBAC) Check(ctx context.Context, namespace, resource, verb string) error <span class="cov8" title="1">{
        md, ok := metadata.FromIncomingContext(ctx)
        if !ok </span><span class="cov0" title="0">{
                return status.Error(codes.Unauthenticated, "unable to get context metadata")
        }</span>

        // Parse Impersonation header if the feature is enabled
        <span class="cov8" title="1">var impersonator *impersonation.Impersonation
        var err error
        if r.allowImpersonation </span><span class="cov8" title="1">{
                impersonator, err = impersonation.NewImpersonation(md)
                // Ignore ErrorNoImpersonationData errors. This means that the request does not have any
                // impersonation headers and should be processed normally.
                if err != nil &amp;&amp; !errors.Is(err, impersonation.ErrNoImpersonationData) </span><span class="cov0" title="0">{
                        log.Println(err)
                        return status.Error(codes.Unauthenticated, "invalid impersonation data")
                }</span>
        }

        <span class="cov8" title="1">v := md.Get("authorization")
        if len(v) == 0 </span><span class="cov0" title="0">{
                return status.Error(codes.Unauthenticated, "unable to find token")
        }</span>

        <span class="cov8" title="1">if verb == PermissionList &amp;&amp; namespace == "-" </span><span class="cov0" title="0">{
                // In list operations `-` means that the caller wants to list
                // resources across all parents. Thus, let's assume all
                // namespaces here.
                namespace = corev1.NamespaceAll
        }</span>

        <span class="cov8" title="1">retMsg := "permission denied"
        for _, raw := range v </span><span class="cov8" title="1">{
                // We expect tokens to be in the form "Bearer &lt;token&gt;". Parse the token out.
                s := strings.SplitN(raw, " ", 2)
                if len(s) &lt; 2 </span><span class="cov0" title="0">{
                        log.Println("unknown auth token format")
                        continue</span>
                }
                <span class="cov8" title="1">t := s[1]

                // Authenticate the token by sending it to the API Server for review.
                tr, err := r.authn.TokenReviews().Create(ctx, &amp;authnv1.TokenReview{
                        Spec: authnv1.TokenReviewSpec{
                                Token: t,
                        },
                }, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        continue</span>
                }
                <span class="cov8" title="1">if !tr.Status.Authenticated </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">user := tr.Status.User.Username
                UID := tr.Status.User.UID
                groups := tr.Status.User.Groups
                extra := convertExtra[authnv1.ExtraValue](tr.Status.User.Extra)

                // Check whether the authenticated user has permission to impersonate
                if impersonator != nil </span><span class="cov8" title="1">{
                        if err := impersonator.Check(ctx, r.authz, user); err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                                retMsg = fmt.Sprintf("%s: %s", retMsg, err.Error())
                                return status.Error(codes.Unauthenticated, retMsg)
                        }</span>
                        // Change user data to impersonated user
                        <span class="cov8" title="1">userInfo := impersonator.GetUserInfo()
                        user = userInfo.GetName()
                        UID = userInfo.GetUID()
                        groups = userInfo.GetGroups()
                        extra = convertExtra[[]string](userInfo.GetExtra())</span>
                }

                // Authorize the request by checking the RBAC permissions for the resource.
                <span class="cov8" title="1">sar, err := r.authz.SubjectAccessReviews().Create(ctx, &amp;authzv1.SubjectAccessReview{
                        Spec: authzv1.SubjectAccessReviewSpec{
                                User:   user,
                                UID:    UID,
                                Groups: groups,
                                Extra:  extra,
                                ResourceAttributes: &amp;authzv1.ResourceAttributes{
                                        Namespace: namespace,
                                        Group:     "results.tekton.dev",
                                        Resource:  resource,
                                        Verb:      verb,
                                },
                        },
                }, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        retMsg = fmt.Sprintf("%s user %q in groups %q employing %q against %q: %s", retMsg, user, groups, verb, resource, err.Error())
                        log.Println(err)
                        continue</span>
                }
                <span class="cov8" title="1">if sar.Status.Allowed </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        // Return Unauthenticated - we don't know if we failed because of invalid
        // token or unauthorized user, so this is safer to not leak any state.
        <span class="cov8" title="1">return status.Error(codes.Unauthenticated, retMsg)</span>
}

// convertExtra converts the map[string][]string or authnv1.ExtraValue to map[string]ExtraValue for Subject Access Review.
func convertExtra[T []string | authnv1.ExtraValue](extra map[string]T) map[string]authzv1.ExtraValue <span class="cov8" title="1">{
        var newExtra = make(map[string]authzv1.ExtraValue)
        for key, value := range extra </span><span class="cov8" title="1">{
                newExtra[key] = authzv1.ExtraValue(value)
        }</span>
        <span class="cov8" title="1">return newExtra</span>
}

// WithImpersonation is an option function to enable Impersonation
func WithImpersonation(enabled bool) Option <span class="cov8" title="1">{
        return func(r *RBAC) </span><span class="cov8" title="1">{
                r.allowImpersonation = enabled
        }</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package server

import (
        "net/http"

        "github.com/tektoncd/results/pkg/api/server/v1alpha2/plugin"
)

// Handler returns a http.Handler that serves the gRPC server and the log plugin server
func Handler(grpcMux http.Handler, pluginServer *plugin.LogServer) http.Handler <span class="cov0" title="0">{
        mux := http.NewServeMux()
        mux.Handle("/", grpcMux)
        if pluginServer != nil &amp;&amp; pluginServer.IsLogPluginEnabled </span><span class="cov0" title="0">{
                mux.Handle("/apis/results.tekton.dev/v1alpha2/parents/{parent}/results/{resultID}/logs/{recordID}", pluginServer.LogMux())
                mux.Handle("/apis/results.tekton.dev/v1alpha3/parents/{parent}/results/{resultID}/logs/{recordID}", pluginServer.LogMux())
        }</span>
        <span class="cov0" title="0">return mux</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2021 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lister

import (
        "context"
        "fmt"
        "regexp"
        "strings"

        "github.com/google/cel-go/cel"
        tdb "github.com/tektoncd/results/pkg/api/server/db"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/structpb"
        "gorm.io/gorm"
)

const (
        durationQuery          = "(data-&gt;'status'-&gt;&gt;'completionTime')::TIMESTAMP WITH TIME ZONE - (data-&gt;'status'-&gt;&gt;'startTime')::TIMESTAMP WITH TIME ZONE"
        statusQuery            = "(data-&gt;'status'-&gt;'conditions'-&gt;0-&gt;&gt;'reason')"
        groupByTimeQuery       = "(data-&gt;'metadata'-&gt;&gt;'creationTimestamp')::TIMESTAMP WITH TIME ZONE"
        groupByParentQuery     = "data-&gt;'metadata'-&gt;&gt;'namespace'"
        groupByPipelineQuery   = "data-&gt;'metadata'-&gt;'labels'-&gt;&gt;'tekton.dev/pipeline'"
        groupByRepositoryQuery = "data-&gt;'metadata'-&gt;'annotations'-&gt;&gt;'pipelinesascode.tekton.dev/repository'"
        startTimeQuery         = "(data-&gt;'status'-&gt;&gt;'startTime')::TIMESTAMP WITH TIME ZONE"
)

type summaryRequest interface {
        GetParent() string
        GetFilter() string
        GetGroupBy() string
        GetSummary() string
        GetOrderBy() string
}

// Aggregator contains the query builders for filters and aggregate functions for summary
type Aggregator struct {
        queryBuilders []queryBuilder
        aggregators   []aggregateFunc
}

func newAggregator(env *cel.Env, aggregateObjectRequest summaryRequest, clauses ...equalityClause) (*Aggregator, error) <span class="cov0" title="0">{
        filters := &amp;filter{
                env:             env,
                expr:            strings.TrimSpace(aggregateObjectRequest.GetFilter()),
                equalityClauses: clauses,
        }

        // Summary is required
        summary := strings.Split(strings.TrimSpace(aggregateObjectRequest.GetSummary()), ",")
        if len(summary) == 1 &amp;&amp; summary[0] == "" </span><span class="cov0" title="0">{
                // include 'total' by default
                summary = append(summary, "total")
        }</span>

        <span class="cov0" title="0">aggregators, err := getAggregateFunc(summary)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Group by is optional
        <span class="cov0" title="0">group := strings.TrimSpace(aggregateObjectRequest.GetGroupBy())
        if group != "" </span><span class="cov0" title="0">{
                groupQuery, err := checkAndBuildGroupQuery(group)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">aggregators = append(aggregators, groupBy(groupQuery))</span>
        }

        <span class="cov0" title="0">orderQuery := strings.TrimSpace(aggregateObjectRequest.GetOrderBy())
        // Order by is only allowed when group by is present
        if orderQuery != "" &amp;&amp; group != "" </span><span class="cov0" title="0">{
                orderSelect, err := checkAndBuildOrderBy(orderQuery, summary)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">aggregators = append(aggregators, orderBy(orderSelect))</span>
        }

        <span class="cov0" title="0">return &amp;Aggregator{
                aggregators: aggregators,
                queryBuilders: []queryBuilder{
                        filters,
                },
        }, nil</span>
}

// Aggregate function runs the aggregation tasks and returns Summary
func (a *Aggregator) Aggregate(ctx context.Context, db *gorm.DB) (*pb.RecordListSummary, error) <span class="cov0" title="0">{
        var err error
        summary := make([]map[string]interface{}, 0)
        db = db.Model(&amp;tdb.Record{})
        db, err = a.buildQuery(ctx, db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">db = a.applyAggregateFunc(ctx, db)
        db.Scan(&amp;summary)

        sm, err := toSummary(summary)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return sm, nil</span>
}

// buildQuery applies filters
func (a *Aggregator) buildQuery(ctx context.Context, db *gorm.DB) (*gorm.DB, error) <span class="cov0" title="0">{
        var err error
        db = db.WithContext(ctx)

        for _, builder := range a.queryBuilders </span><span class="cov0" title="0">{
                db, err = builder.build(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>
        }
        <span class="cov0" title="0">return db, err</span>
}

// ToSummary converts the array of summary map to Summary proto
func toSummary(summary []map[string]interface{}) (*pb.RecordListSummary, error) <span class="cov0" title="0">{
        var data []*structpb.Struct
        for _, s := range summary </span><span class="cov0" title="0">{
                m := make(map[string]*structpb.Value)
                for sk, sv := range s </span><span class="cov0" title="0">{
                        pbValue, err := structpb.NewValue(sv)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">m[sk] = pbValue</span>
                }
                <span class="cov0" title="0">data = append(data, &amp;structpb.Struct{Fields: m})</span>
        }

        <span class="cov0" title="0">return &amp;pb.RecordListSummary{
                Summary: data,
        }, nil</span>
}

// aggregateFunc is a function that applies aggregate functions to the query
type aggregateFunc func(db *gorm.DB) *gorm.DB

var summaryFuncs = map[string]aggregateFunc{
        "total":          getCount("*", "total"),
        "avg_duration":   getDuration("AVG", durationQuery, "avg_duration"),
        "max_duration":   getDuration("MAX", durationQuery, "max_duration"),
        "total_duration": getDuration("SUM", durationQuery, "total_duration"),
        "min_duration":   getDuration("MIN", durationQuery, "min_duration"),
        "last_runtime":   getTime("MAX", startTimeQuery, "last_runtime"),
        "succeeded":      getStatus(statusQuery, "Succeeded"),
        "failed":         getStatus(statusQuery, "Failed"),
        "cancelled":      getStatus(statusQuery, "Cancelled"),
        "running":        getStatus(statusQuery, "Running"),
        "others":         getStatus(statusQuery, "Others"),
}

func getAggregateFunc(queries []string) ([]aggregateFunc, error) <span class="cov0" title="0">{
        fns := make([]aggregateFunc, 0, len(queries))
        for _, q := range queries </span><span class="cov0" title="0">{
                fn, ok := summaryFuncs[q]
                if !ok </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.InvalidArgument, "invalid aggregate query: %s", q)
                }</span>
                <span class="cov0" title="0">fns = append(fns, fn)</span>
        }
        <span class="cov0" title="0">return fns, nil</span>
}

func (a *Aggregator) applyAggregateFunc(ctx context.Context, db *gorm.DB) *gorm.DB <span class="cov0" title="0">{
        db = db.WithContext(ctx)
        for _, fn := range a.aggregators </span><span class="cov0" title="0">{
                db = fn(db)
        }</span>
        <span class="cov0" title="0">return db</span>
}

func getStatus(query, reason string) aggregateFunc <span class="cov8" title="1">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                statusSelect := ""
                switch reason </span>{
                case "Succeeded":<span class="cov0" title="0">
                        statusSelect = fmt.Sprintf("COUNT(CASE WHEN %s IN ('Succeeded', 'Completed') THEN 1 END) AS %s",
                                query, strings.ToLower(reason))</span>
                case "Others":<span class="cov0" title="0">
                        statusSelect = fmt.Sprintf("COUNT(CASE WHEN %s NOT IN ('Failed', 'Succeeded', 'Cancelled', 'Running', 'Completed') THEN 1 END) AS %s",
                                query, strings.ToLower(reason))</span>
                default:<span class="cov0" title="0">
                        statusSelect = fmt.Sprintf("COUNT(CASE WHEN %s = '%s' THEN 1 END) AS %s",
                                query, reason, strings.ToLower(reason))</span>
                }
                <span class="cov0" title="0">return db.Select(db.Statement.Selects, statusSelect)</span>
        }
}

func getCount(query, countName string) aggregateFunc <span class="cov8" title="1">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                return db.Select(db.Statement.Selects, fmt.Sprintf("COUNT(%s) AS %s", query, countName))
        }</span>
}

func getDuration(fn, query, value string) aggregateFunc <span class="cov8" title="1">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                return db.Select(db.Statement.Selects, fmt.Sprintf("%s(%s)::INTERVAL AS %s", fn, query, value))
        }</span>
}

func getTime(fn, query, as string) aggregateFunc <span class="cov8" title="1">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                return db.Select(db.Statement.Selects, fmt.Sprintf("%s(EXTRACT(EPOCH FROM %s)) AS %s", fn, query, as))
        }</span>
}

var validGroups = map[string]bool{
        "year":       true,
        "month":      true,
        "week":       true,
        "day":        true,
        "hour":       true,
        "minute":     true,
        "pipeline":   false,
        "namespace":  false,
        "repository": false,
}

func groupBy(groupSelect string) aggregateFunc <span class="cov0" title="0">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                return db.Select(db.Statement.Selects, groupSelect).Group("group_value")
        }</span>
}

// checkAndBuildGroupQuery checks if the group by query is valid and returns the group by select query
func checkAndBuildGroupQuery(query string) (string, error) <span class="cov8" title="1">{
        parts := strings.Split(query, " ")
        isTime, ok := validGroups[parts[0]]
        if !ok </span><span class="cov8" title="1">{
                return "", status.Errorf(codes.InvalidArgument, "group_by does not recognize %s", query)
        }</span>
        <span class="cov8" title="1">switch </span>{
        case isTime &amp;&amp; len(parts) == 1:<span class="cov8" title="1">
                return fmt.Sprintf("EXTRACT(EPOCH FROM DATE_TRUNC('%s', %s)) AS group_value", parts[0], groupByTimeQuery), nil</span>
        case isTime &amp;&amp; len(parts) == 2:<span class="cov8" title="1">
                if parts[1] != "completionTime" &amp;&amp; parts[1] != "startTime" </span><span class="cov0" title="0">{
                        return "", status.Errorf(codes.InvalidArgument, "group_by does not recognize %s", parts[1])
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("EXTRACT(EPOCH FROM DATE_TRUNC('%s', (data-&gt;'status'-&gt;&gt;'%s')::TIMESTAMP WITH TIME ZONE)) AS group_value", parts[0], parts[1]), nil</span>
        case !isTime &amp;&amp; len(parts) == 1:<span class="cov8" title="1">
                switch parts[0] </span>{
                case "namespace":<span class="cov8" title="1">
                        return fmt.Sprintf("%s AS group_value", groupByParentQuery), nil</span>
                case "pipeline":<span class="cov8" title="1">
                        // use 'namespace/pipeline' as group value because different namespaces may have pipelines with same name
                        return fmt.Sprintf("CONCAT(%s, '/', %s) AS group_value", groupByParentQuery, groupByPipelineQuery), nil</span>
                case "repository":<span class="cov8" title="1">
                        return fmt.Sprintf("CONCAT(%s, '/', %s) AS group_value", groupByParentQuery, groupByRepositoryQuery), nil</span>
                }
        default:<span class="cov0" title="0">
                return "", status.Errorf(codes.InvalidArgument, "group_by does not recognize %s", query)</span>
        }
        <span class="cov0" title="0">return "", nil</span>
}

func orderBy(orderSelect string) aggregateFunc <span class="cov0" title="0">{
        return func(db *gorm.DB) *gorm.DB </span><span class="cov0" title="0">{
                return db.Select(db.Statement.Selects).Order(orderSelect)
        }</span>
}

// checkAndBuildOrderBy checks if the order by query is valid and returns the order by select query
func checkAndBuildOrderBy(query string, allowedFields []string) (string, error) <span class="cov8" title="1">{
        parts := strings.Split(query, " ")
        var orderByPattern = regexp.MustCompile(`^([\w\.]+)\s*(ASC|asc|DESC|desc)?$`)

        if len(parts) != 2 || !orderByPattern.MatchString(query) </span><span class="cov8" title="1">{
                return "", status.Errorf(codes.InvalidArgument, "order_by does not recognize %s", query)
        }</span>

        <span class="cov8" title="1">fieldName := parts[0]
        orderDirection := strings.ToUpper(parts[1])

        // Check if the field name is in the list of allowed fields, must be one of the summary query
        isAllowedField := false
        for _, field := range allowedFields </span><span class="cov8" title="1">{
                if field == fieldName </span><span class="cov8" title="1">{
                        isAllowedField = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !isAllowedField </span><span class="cov8" title="1">{
                return "", status.Errorf(codes.InvalidArgument, "field name %s is not allowed, must be one of summary", fieldName)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%s %s", fieldName, orderDirection), nil</span>
}

// OfRecordList returns a new Aggregator for Record List Summary Request
func OfRecordList(env *cel.Env, resultParent, resultName string, request *pb.RecordListSummaryRequest) (*Aggregator, error) <span class="cov0" title="0">{
        return newAggregator(env, request, equalityClause{
                columnName: "parent",
                value:      resultParent,
        }, equalityClause{
                columnName: "result_name",
                value:      resultName,
        })
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lister

import (
        "fmt"
        "strings"

        pagetokenpb "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/proto/pagetoken_go_proto"

        "github.com/google/cel-go/cel"
        "github.com/tektoncd/results/pkg/api/server/cel2sql"
        "gorm.io/gorm"
)

type filter struct {
        env             *cel.Env
        expr            string
        equalityClauses []equalityClause
}

type equalityClause struct {
        columnName string
        value      any
}

// validateToken implements the queryBuilder interface.
func (f *filter) validateToken(token *pagetokenpb.PageToken) error <span class="cov8" title="1">{
        if strings.TrimSpace(f.expr) != strings.TrimSpace(token.Filter) </span><span class="cov8" title="1">{
                return fmt.Errorf("the provided filter differs from the filter used in the previous query\nexpected: %s\ngot: %s", token.Filter, f.expr)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// build implements the queryBuilder interface.
func (f *filter) build(db *gorm.DB) (*gorm.DB, error) <span class="cov8" title="1">{
        for _, clause := range f.equalityClauses </span><span class="cov8" title="1">{
                // Specifying `-` allows users to read Results/Records
                // without passing the parent.
                // See https://google.aip.dev/159 for more details.
                if clause.value == "-" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">db = db.Where(clause.columnName+" = ?", clause.value)</span>
        }

        <span class="cov8" title="1">if expr := strings.TrimSpace(f.expr); expr != "" </span><span class="cov8" title="1">{
                sql, err := cel2sql.Convert(f.env, expr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">db = db.Where(sql)</span>
        }
        <span class="cov8" title="1">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lister

import (
        "fmt"

        pagetokenpb "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/proto/pagetoken_go_proto"
        "gorm.io/gorm"
)

const (
        defaultPageSize = 50
        minPageSize     = 5
        maxPageSize     = 10000
)

type limit struct {
        pageSize int
}

// validateToken implements the queryBuilder interface.
func (l *limit) validateToken(token *pagetokenpb.PageToken) error <span class="cov8" title="1">{ //nolint:revive
        return nil
}</span>

// build implements the queryBuilder interface.
func (l *limit) build(db *gorm.DB) (*gorm.DB, error) <span class="cov8" title="1">{
        if l.pageSize &lt; minPageSize || l.pageSize &gt; maxPageSize </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid page size (%d): value must be greater than %d and less than %d", l.pageSize, minPageSize, maxPageSize)
        }</span>
        // Fetch n + 1 items to determine whether there are more pages and
        // therefore, whether a page token should be included in the response.
        <span class="cov8" title="1">db = db.Limit(l.pageSize + 1)
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lister

import (
        "context"
        "strings"

        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/google/cel-go/cel"
        "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/api/server/db/errors"
        pagetokenpb "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/proto/pagetoken_go_proto"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/result"
        resultspb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gorm.io/gorm"
)

// wireObject represents commonalities of Results and Records for the purposes of
// this package.
type wireObject interface {
        GetUid() string
        GetCreateTime() *timestamppb.Timestamp
        GetUpdateTime() *timestamppb.Timestamp
}

// request represents commonalities of ListResultsRequest and ListRecordsRequest
// objects.
type request interface {
        GetParent() string
        GetFilter() string
        GetOrderBy() string
        GetPageSize() int32
        GetPageToken() string
}

type queryBuilder interface {
        validateToken(token *pagetokenpb.PageToken) error
        build(db *gorm.DB) (*gorm.DB, error)
}

// Converter is a generic function which converts a database model to its wire
// form.
type Converter[M any, W wireObject] func(M) W

// PageTokenGenerator takes a wire object and returns a page token for
// retrieving more resources from thee API.
type PageTokenGenerator func(wireObject) (string, error)

// Lister is a generic utility to list, filter, sort and paginate Results and
// Records in a uniform and consistent manner.
type Lister[M any, W wireObject] struct {
        queryBuilders    []queryBuilder
        pageSize         int
        pageToken        *pagetokenpb.PageToken
        convert          Converter[M, W]
        genNextPageToken PageTokenGenerator
}

func (l *Lister[M, W]) buildQuery(ctx context.Context, db *gorm.DB) (*gorm.DB, error) <span class="cov8" title="1">{
        var err error
        db = db.WithContext(ctx)
        for _, builder := range l.queryBuilders </span><span class="cov8" title="1">{
                // First, let queryBuilders validate the incoming token if
                // applicable to make sure that the query parameters match those
                // passed in the previous request or that the token in question
                // wasn't improperly modified by the caller.
                if l.pageToken != nil </span><span class="cov8" title="1">{
                        if err := builder.validateToken(l.pageToken); err != nil </span><span class="cov8" title="1">{
                                return nil, status.Errorf(codes.InvalidArgument, "invalid page token: %v", err)
                        }</span>
                }

                // Add clauses for filtering, sorting and paginating resources.
                <span class="cov8" title="1">db, err = builder.build(db)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, err.Error())
                }</span>
        }
        <span class="cov8" title="1">return db, nil</span>
}

// List lists resources applying filters, sorting elements and handling
// pagination. It returns resources in their wire form and a token to be used
// later for retrieving more pages if applicable.
func (l *Lister[M, W]) List(ctx context.Context, db *gorm.DB) ([]W, string, error) <span class="cov0" title="0">{
        var err error
        db, err = l.buildQuery(ctx, db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">var models = make([]M, 0)
        db.Find(&amp;models)

        if err := errors.Wrap(err); err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">wire := make([]W, 0, len(models))
        for _, model := range models </span><span class="cov0" title="0">{
                wire = append(wire, l.convert(model))
        }</span>

        <span class="cov0" title="0">var nextPageToken string
        if len(wire) &gt; l.pageSize </span><span class="cov0" title="0">{
                // Generate the page token using the last resource in thee
                // returned collection, so it will be used as the starting point
                // for next queries.
                wire = wire[:l.pageSize]
                nextPageToken, err = l.genNextPageToken(wire[len(wire)-1])
        }</span>

        <span class="cov0" title="0">return wire, nextPageToken, err</span>
}

// OfResults creates a Lister for Result objects.
func OfResults(env *cel.Env, request *resultspb.ListResultsRequest) (*Lister[*db.Result, *resultspb.Result], error) <span class="cov0" title="0">{
        return newLister(env, resultFieldsToColumns, request, result.ToAPI, equalityClause{
                columnName: "parent",
                value:      strings.TrimSpace(request.GetParent()),
        })
}</span>

func newLister[M any, W wireObject](env *cel.Env, fieldsToColumns map[string]string, listObjectsRequest request, convert Converter[M, W], clauses ...equalityClause) (*Lister[M, W], error) <span class="cov0" title="0">{
        pageToken, err := decodePageToken(strings.TrimSpace(listObjectsRequest.GetPageToken()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">parent := strings.TrimSpace(listObjectsRequest.GetParent())
        if pageToken != nil &amp;&amp; pageToken.Parent != parent </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid page token: provided parent (%s) differs from the parent used in the previous query (%s)", parent, pageToken.Parent)
        }</span>

        <span class="cov0" title="0">order, err := newOrder(strings.TrimSpace(listObjectsRequest.GetOrderBy()), fieldsToColumns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filter := &amp;filter{
                env:             env,
                expr:            strings.TrimSpace(listObjectsRequest.GetFilter()),
                equalityClauses: clauses,
        }

        pageSize := listObjectsRequest.GetPageSize()
        if pageSize == 0 </span><span class="cov0" title="0">{
                pageSize = defaultPageSize
        }</span>

        <span class="cov0" title="0">return &amp;Lister[M, W]{
                queryBuilders: []queryBuilder{
                        &amp;offset{order: order, pageToken: pageToken},
                        filter,
                        order,
                        &amp;limit{pageSize: int(pageSize)},
                },
                pageSize:         int(pageSize),
                pageToken:        pageToken,
                convert:          convert,
                genNextPageToken: makePageTokenGenerator(parent, filter.expr, order),
        }, nil</span>
}

func makePageTokenGenerator(parent, filter string, order *order) PageTokenGenerator <span class="cov0" title="0">{
        return func(obj wireObject) (string, error) </span><span class="cov0" title="0">{
                pageToken := &amp;pagetokenpb.PageToken{
                        Parent: parent,
                        Filter: filter,
                        LastItem: &amp;pagetokenpb.Item{
                                Uid: obj.GetUid(),
                        },
                }

                if fieldName := order.fieldName; fieldName != "" </span><span class="cov0" title="0">{
                        pageToken.LastItem.OrderBy = &amp;pagetokenpb.Order{
                                FieldName: fieldName,
                                Value:     getTimestamp(obj, fieldName),
                                Direction: pagetokenpb.Order_Direction(pagetokenpb.Order_Direction_value[order.direction]),
                        }
                }</span>

                <span class="cov0" title="0">return encodePageToken(pageToken)</span>
        }
}

func getTimestamp(in wireObject, fieldName string) (timestamp *timestamppb.Timestamp) <span class="cov0" title="0">{
        switch fieldName </span>{
        case "create_time":<span class="cov0" title="0">
                timestamp = in.GetCreateTime()</span>

        case "update_time":<span class="cov0" title="0">
                timestamp = in.GetUpdateTime()</span>

        case "summary.start_time":<span class="cov0" title="0">
                if result, ok := in.(*resultspb.Result); ok </span><span class="cov0" title="0">{
                        if summary := result.Summary; summary != nil </span><span class="cov0" title="0">{
                                timestamp = summary.GetStartTime()
                        }</span>
                }

        case "summary.end_time":<span class="cov0" title="0">
                if result, ok := in.(*resultspb.Result); ok </span><span class="cov0" title="0">{
                        if summary := result.Summary; summary != nil </span><span class="cov0" title="0">{
                                timestamp = summary.GetEndTime()
                        }</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

// OfRecords creates a Lister for Record objects.
func OfRecords(env *cel.Env, resultParent, resultName string, request *resultspb.ListRecordsRequest) (*Lister[*db.Record, *resultspb.Record], error) <span class="cov0" title="0">{
        return newLister(env, recordFieldsToColumns, request, record.ToAPI, equalityClause{
                columnName: "parent",
                value:      resultParent,
        },
                equalityClause{
                        columnName: "result_name",
                        value:      resultName,
                })
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lister

import (
        "errors"
        "fmt"

        pagetokenpb "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/proto/pagetoken_go_proto"
        "gorm.io/gorm"
)

type offset struct {
        order     *order
        pageToken *pagetokenpb.PageToken
}

// validateToken implements the queryBuilder interface.
func (o *offset) validateToken(token *pagetokenpb.PageToken) error <span class="cov8" title="1">{
        lastItem := token.LastItem
        if lastItem == nil </span><span class="cov8" title="1">{
                return errors.New("last_item: missing required field")
        }</span>
        <span class="cov8" title="1">if lastItem.Uid == "" </span><span class="cov8" title="1">{
                return errors.New("last_item.uid: missing required field")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// build implements the queryBuilder interface.
func (o *offset) build(db *gorm.DB) (*gorm.DB, error) <span class="cov8" title="1">{
        if o.pageToken != nil </span><span class="cov8" title="1">{
                if lastItem := o.pageToken.LastItem; lastItem != nil </span><span class="cov8" title="1">{
                        var leftHandSideExpression, rightHandSideExpression string
                        comparisonOperator := "&gt;"
                        values := []any{}
                        if orderBy := lastItem.OrderBy; orderBy != nil </span><span class="cov8" title="1">{
                                leftHandSideExpression = fmt.Sprintf("(%s, %s)", o.order.columnName, defaultOrderByColumn)
                                rightHandSideExpression = "(?, ?)"
                                values = append(values, orderBy.Value.AsTime())
                                if orderBy.Direction == pagetokenpb.Order_DESC </span><span class="cov8" title="1">{
                                        comparisonOperator = "&lt;"
                                }</span>
                        } else<span class="cov8" title="1"> {
                                leftHandSideExpression = defaultOrderByColumn
                                rightHandSideExpression = "?"
                        }</span>
                        <span class="cov8" title="1">values = append(values, lastItem.Uid)
                        db = db.Where(fmt.Sprintf("%s %s %s", leftHandSideExpression, comparisonOperator, rightHandSideExpression), values...)</span>
                }
        }
        <span class="cov8" title="1">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lister

import (
        "errors"
        "fmt"
        "regexp"
        "sort"
        "strings"

        pagetokenpb "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/proto/pagetoken_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gorm.io/gorm"
)

const (
        defaultOrderByColumn    = "id"
        defaultOrderByDirection = "ASC"
)

var (
        resultFieldsToColumns = map[string]string{
                "create_time": "created_time",
                "update_time": "updated_time",

                // Fields of RecordSummary type.
                "summary.start_time": "recordsummary_start_time",
                "summary.end_time":   "recordsummary_end_time",
        }

        recordFieldsToColumns = map[string]string{
                "create_time": "created_time",
                "update_time": "updated_time",
        }

        orderByPattern = regexp.MustCompile(`^([\w\.]+)\s*(ASC|asc|DESC|desc)?$`)
)

type order struct {
        columnName string
        fieldName  string
        direction  string
}

// validateToken implements the queryBuilder interface.
func (o *order) validateToken(token *pagetokenpb.PageToken) error <span class="cov8" title="1">{
        // Validate the token only if the caller wants to sort the collection by
        // a custom field.
        if fieldName := o.fieldName; fieldName != "" </span><span class="cov8" title="1">{
                orderBy := token.LastItem.OrderBy
                if orderBy == nil </span><span class="cov8" title="1">{
                        return errors.New("last_item.order_by: missing required field")
                }</span>
                <span class="cov8" title="1">tokenDirection := pagetokenpb.Order_Direction_name[int32(orderBy.Direction)]
                if orderBy.FieldName != fieldName || tokenDirection != o.direction </span><span class="cov8" title="1">{
                        return fmt.Errorf("the provided order by clause differs from the value passed in the previous query\nexpected: %s %s\ngot: %s %s",
                                orderBy.FieldName, tokenDirection,
                                fieldName, o.direction)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// build implements the queryBuilder interface.
func (o *order) build(db *gorm.DB) (*gorm.DB, error) <span class="cov8" title="1">{
        direction := defaultOrderByDirection
        if o.direction != "" </span><span class="cov8" title="1">{
                direction = o.direction
        }</span>
        <span class="cov8" title="1">if o.columnName != "" </span><span class="cov8" title="1">{
                db = db.Order(o.columnName + " " + direction)
        }</span>
        <span class="cov8" title="1">return db.Order(defaultOrderByColumn + " " + direction), nil</span>
}

// parseOrderBy attempts to parse the input into a suitable tuple of column and
// direction to be used in the sql order by clause.
func parseOrderBy(in string, fieldsToColumns map[string]string) (columnName string, fieldName string, direction string, err error) <span class="cov8" title="1">{
        in = strings.TrimSpace(in)
        if in == "" </span><span class="cov0" title="0">{
                return "", "", "", nil
        }</span>

        <span class="cov8" title="1">matches := orderByPattern.FindStringSubmatch(in)
        if matches == nil </span><span class="cov8" title="1">{
                return "", "", "", status.Errorf(codes.InvalidArgument, "invalid order by statement:\n%s", explainOrderByFormat(fieldsToColumns))
        }</span>

        <span class="cov8" title="1">fieldName = matches[1]
        columnName = fieldsToColumns[fieldName]
        if columnName == "" </span><span class="cov8" title="1">{
                return "", "", "", status.Errorf(codes.InvalidArgument, "%s: field is unknown or cannot be used in the order by clause\n%s", fieldName, explainOrderByFormat(fieldsToColumns))
        }</span>

        <span class="cov8" title="1">if desiredDirection := matches[2]; desiredDirection == "" </span><span class="cov8" title="1">{
                direction = defaultOrderByDirection
        }</span> else<span class="cov8" title="1"> {
                direction = strings.ToUpper(strings.TrimSpace(matches[2]))
        }</span>

        <span class="cov8" title="1">return</span>
}

// explainOrderByFormat returns a descriptive message to inform callers on the
// OrderBy field's correct format.
func explainOrderByFormat(fieldsToColumns map[string]string) string <span class="cov8" title="1">{
        validFields := make([]string, 0, len(fieldsToColumns))
        for field := range fieldsToColumns </span><span class="cov8" title="1">{
                validFields = append(validFields, field)
        }</span>
        <span class="cov8" title="1">sort.Strings(validFields)
        return fmt.Sprintf("the value must obey the format &lt;%s&gt; [asc|desc]", strings.Join(validFields, "|"))</span>
}

// newOrder creates a new order object from the provided orderBy value.
func newOrder(orderBy string, fieldsToColumns map[string]string) (*order, error) <span class="cov0" title="0">{
        column, field, direction, err := parseOrderBy(orderBy, fieldsToColumns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;order{
                columnName: column,
                fieldName:  field,
                direction:  direction,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lister

import (
        "encoding/base64"

        pagetokenpb "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister/proto/pagetoken_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
)

// decodePageToken attempts to convert the provided token into a PageToken
// object.
func decodePageToken(in string) (*pagetokenpb.PageToken, error) <span class="cov8" title="1">{
        if in == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">decodedData, err := base64.RawURLEncoding.DecodeString(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov8" title="1">pageToken := new(pagetokenpb.PageToken)
        if err := proto.Unmarshal(decodedData, pageToken); err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov8" title="1">return pageToken, nil</span>
}

// encodePageToken turns the PageToken object into a string suitable to be
// delivered by the API.
func encodePageToken(in *pagetokenpb.PageToken) (string, error) <span class="cov8" title="1">{
        wire, err := proto.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return "", status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov8" title="1">return base64.RawURLEncoding.EncodeToString(wire), nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package log

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/tektoncd/results/pkg/api/server/config"

        "github.com/tektoncd/results/pkg/apis/v1alpha3"
)

type fileStream struct {
        path string
        size int
        ctx  context.Context
}

// NewFileStream returns a LogStreamer that streams directly from a log file on local disk.
func NewFileStream(ctx context.Context, log *v1alpha3.Log, config *config.Config) (Stream, error) <span class="cov8" title="1">{
        if log.Status.Path == "" </span><span class="cov8" title="1">{
                filePath, err := FilePath(log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">log.Status.Path = filePath</span>
        }

        <span class="cov8" title="1">size := config.LOGS_BUFFER_SIZE
        if size &lt; 1 </span><span class="cov8" title="1">{
                size = DefaultBufferSize
        }</span>

        <span class="cov8" title="1">return &amp;fileStream{
                path: filepath.Join(config.LOGS_PATH, log.Status.Path),
                size: size,
                ctx:  ctx,
        }, nil</span>
}

func (*fileStream) Type() string <span class="cov8" title="1">{
        return string(v1alpha3.FileLogType)
}</span>

// WriteTo reads the contents of the TaskRun log file and writes them to the provided writer, such
// as os.Stdout.
func (fs *fileStream) WriteTo(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        _, err = os.Stat(fs.path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to stat %s: %w", fs.path, err)
        }</span>
        <span class="cov8" title="1">file, err := os.Open(fs.path)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to open file %s: %w", fs.path, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                closeErr := file.Close()
                if err == nil &amp;&amp; closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }()
        // Use the buffered reader to ensure file contents are not read entirely into memory
        <span class="cov8" title="1">reader := bufio.NewReaderSize(file, fs.size)
        n, err = reader.WriteTo(w)
        return</span>
}

// ReadFrom reads the log contents from the provided io.Reader, and writes them to the TaskRun log
// file on disk.
func (fs *fileStream) ReadFrom(r io.Reader) (n int64, err error) <span class="cov8" title="1">{
        // Ensure that the directories in the path already exist
        dir := filepath.Dir(fs.path)
        err = os.MkdirAll(dir, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to create directory %s, %w", dir, err)
        }</span>
        // Open the file with Append + Create + WriteOnly modes.
        // This ensures the file is created if it does not exist.
        // If the file does exist, data is appended instead of overwritten/truncated
        <span class="cov8" title="1">file, err := os.OpenFile(fs.path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to open file %s: %w", fs.path, err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                closeErr := file.Close()
                if err == nil &amp;&amp; closeErr != nil </span><span class="cov0" title="0">{
                        err = closeErr
                }</span>
        }()
        <span class="cov8" title="1">writer := bufio.NewWriterSize(file, fs.size)
        n, err = writer.ReadFrom(r)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">err = writer.Flush()
        return</span>
}

func (fs *fileStream) Delete() error <span class="cov8" title="1">{
        return os.RemoveAll(fs.path)
}</span>

func (fs *fileStream) Flush() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package log

import (
        "path/filepath"

        "golang.org/x/oauth2/google"

        "context"
        "fmt"
        "io"
        "os"

        server "github.com/tektoncd/results/pkg/api/server/config"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"

        "gocloud.dev/blob/gcsblob"
        "gocloud.dev/gcp"
)

type gcsStream struct {
        ctx    context.Context
        config *server.Config
        key    string
        client *gcp.HTTPClient
}

// NewGCSStream returns a log streamer for the GCS storage type.
func NewGCSStream(ctx context.Context, log *v1alpha3.Log, config *server.Config) (Stream, error) <span class="cov0" title="0">{
        if log.Status.Path == "" </span><span class="cov0" title="0">{
                filePath, err := FilePath(log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Status.Path = filePath</span>
        }

        <span class="cov0" title="0">filePath := filepath.Join(config.LOGS_PATH, log.Status.Path)

        if config.STORAGE_EMULATOR_HOST != "" </span><span class="cov0" title="0">{
                os.Setenv("STORAGE_EMULATOR_HOST", config.STORAGE_EMULATOR_HOST)
        }</span>
        <span class="cov0" title="0">client, err := getGCSClient(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">gcs := &amp;gcsStream{
                ctx:    ctx,
                config: config,
                key:    filePath,
                client: client,
        }

        return gcs, nil</span>
}

func getGCSClient(ctx context.Context, cfg *server.Config) (*gcp.HTTPClient, error) <span class="cov0" title="0">{
        var creds *google.Credentials

        if cfg.STORAGE_EMULATOR_HOST != "" </span><span class="cov0" title="0">{
                creds, _ = google.CredentialsFromJSON(ctx, []byte(`{"type": "service_account", "project_id": "my-project-id"}`))
        }</span> else<span class="cov0" title="0"> {
                var err error
                creds, err = gcp.DefaultCredentials(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return gcp.NewHTTPClient(
                gcp.DefaultTransport(),
                gcp.CredentialsTokenSource(creds))</span>
}

func (*gcsStream) Type() string <span class="cov0" title="0">{
        return string(v1alpha3.GCSLogType)
}</span>

func (gcs *gcsStream) WriteTo(w io.Writer) (int64, error) <span class="cov8" title="1">{
        bucket, err := gcsblob.OpenBucket(gcs.ctx, gcs.client, gcs.config.GCS_BUCKET_NAME, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("could not open bucket: %v", err)
        }</span>
        <span class="cov8" title="1">defer bucket.Close()

        r, err := bucket.NewReader(gcs.ctx, gcs.key, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("could not create bucket reader: %v for the key: %s", err, gcs.key)
        }</span>
        <span class="cov8" title="1">n, err := r.WriteTo(w)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("could not read data from bucket: %v for the key: %s", err, gcs.key)
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

func (gcs *gcsStream) ReadFrom(r io.Reader) (n int64, err error) <span class="cov8" title="1">{
        bucket, err := gcsblob.OpenBucket(gcs.ctx, gcs.client, gcs.config.GCS_BUCKET_NAME, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("could not open bucket: %v for the key: %s", err, gcs.key)
        }</span>
        <span class="cov8" title="1">defer bucket.Close()

        w, err := bucket.NewWriter(gcs.ctx, gcs.key, nil)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("could not create bucket writer: %v for the key: %s", err, gcs.key)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                err = w.Close()
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("could not flush data to bucket: %v for the key: %s", err, gcs.key)
                }</span>
        }()

        <span class="cov8" title="1">n, err = w.ReadFrom(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("could not write data to bucket: %v for the key: %s", err, gcs.key)
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

func (gcs *gcsStream) Flush() error <span class="cov0" title="0">{
        return nil
}</span>

func (gcs *gcsStream) Delete() error <span class="cov8" title="1">{
        bucket, err := gcsblob.OpenBucket(gcs.ctx, gcs.client, gcs.config.GCS_BUCKET_NAME, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not open bucket: %v for the key: %s", err, gcs.key)
        }</span>
        <span class="cov8" title="1">defer bucket.Close()

        if err := bucket.Delete(gcs.ctx, gcs.key); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not delete bucket data: %v for the key: %s", err, gcs.key)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package log

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "path/filepath"
        "regexp"

        "github.com/tektoncd/results/pkg/api/server/config"
        "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        // DefaultBufferSize is the default buffer size. This based on the recommended
        // gRPC message size for streamed content, which ranges from 16 to 64 KiB. Choosing 32 KiB as a
        // middle ground between the two.
        DefaultBufferSize = 32 * 1024
)

var (
        // NameRegex matches valid name specs for a Result.
        NameRegex = regexp.MustCompile("(^[a-z0-9_-]{1,63})/results/([a-z0-9_-]{1,63})/logs/([a-z0-9_-]{1,63}$)")
)

// ParseName splits a full Result name into its individual (parent, result, name)
// components.
func ParseName(raw string) (parent, result, name string, err error) <span class="cov8" title="1">{
        s := NameRegex.FindStringSubmatch(raw)
        if len(s) != 4 </span><span class="cov8" title="1">{
                return "", "", "", status.Errorf(codes.InvalidArgument, "name must match %s", NameRegex.String())
        }</span>
        <span class="cov8" title="1">return s[1], s[2], s[3], nil</span>
}

// FormatName takes in a parent ("a/results/b") and record name ("c") and
// returns the full resource name ("a/results/b/logs/c").
func FormatName(parent, name string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/logs/%s", parent, name)
}</span>

// Stream is an interface that defines the behavior of a streaming log service.
type Stream interface {
        io.ReaderFrom
        io.WriterTo
        Type() string
        Delete() error
        Flush() error
}

// NewStream returns a LogStreamer for the given Log.
// LogStreamers do the following:
//
// 1. Write log data from their respective source to an io.Writer interface.
// 2. Read log data from a source, and store it in the respective backend if that behavior is supported.
//
// All LogStreamers support writing log data to an io.Writer from the provided source.
// LogStreamers do not need to receive and store data from the provided source.
//
// NewStream may mutate the Log object's status, to provide implementation information
// for reading and writing files.
func NewStream(ctx context.Context, log *v1alpha3.Log, config *config.Config) (Stream, error) <span class="cov8" title="1">{
        switch log.Spec.Type </span>{
        case v1alpha3.FileLogType:<span class="cov8" title="1">
                return NewFileStream(ctx, log, config)</span>
        case v1alpha3.S3LogType:<span class="cov0" title="0">
                return NewS3Stream(ctx, log, config)</span>
        case v1alpha3.GCSLogType:<span class="cov0" title="0">
                return NewGCSStream(ctx, log, config)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("log streamer type %s is not supported", log.Spec.Type)</span>
}

// ToStorage converts log record to marshaled json bytes
func ToStorage(record *pb.Record, config *config.Config) ([]byte, error) <span class="cov8" title="1">{
        log := &amp;v1alpha3.Log{}
        if len(record.GetData().Value) &gt; 0 </span><span class="cov8" title="1">{
                err := json.Unmarshal(record.GetData().Value, log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">log.Default()

        if log.Spec.Type == "" </span><span class="cov0" title="0">{
                log.Spec.Type = v1alpha3.LogType(config.LOGS_TYPE)
                if len(log.Spec.Type) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to set up log storage type to spec")
                }</span>
        }
        <span class="cov8" title="1">return json.Marshal(log)</span>
}

// ToStream returns three arguments.
// First one is a new log streamer created by log record.
// Second one is log API resource retrieved from log record.
// Third argument is an error.
func ToStream(ctx context.Context, record *db.Record, config *config.Config) (Stream, *v1alpha3.Log, error) <span class="cov8" title="1">{
        if record.Type != v1alpha3.LogRecordType &amp;&amp; record.Type != v1alpha3.LogRecordTypeV2 </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("record type %s cannot stream logs", record.Type)
        }</span>
        <span class="cov8" title="1">log := &amp;v1alpha3.Log{}
        err := json.Unmarshal(record.Data, log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("could not decode Log record: %w", err)
        }</span>
        <span class="cov8" title="1">stream, err := NewStream(ctx, log, config)
        return stream, log, err</span>
}

// FilePath returns file path to store log. This file path can be
// path in the real file system or virtual value depending on storage type.
func FilePath(log *v1alpha3.Log) (string, error) <span class="cov8" title="1">{
        filePath := filepath.Join(log.GetNamespace(), string(log.GetUID()), log.Name)
        if filePath == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid file path")
        }</span>
        <span class="cov8" title="1">return filePath, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package log

import (
        "bufio"
        "bytes"
        "path/filepath"

        v4 "github.com/aws/aws-sdk-go-v2/aws/signer/v4"

        "context"
        "io"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/s3/types"
        server "github.com/tektoncd/results/pkg/api/server/config"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"
)

const (
        defaultS3MultiPartSize = 1024 * 1024 * 5
)

type s3Client interface {
        AbortMultipartUpload(context.Context, *s3.AbortMultipartUploadInput, ...func(*s3.Options)) (*s3.AbortMultipartUploadOutput, error)
        CompleteMultipartUpload(context.Context, *s3.CompleteMultipartUploadInput, ...func(*s3.Options)) (*s3.CompleteMultipartUploadOutput, error)
        CreateMultipartUpload(context.Context, *s3.CreateMultipartUploadInput, ...func(*s3.Options)) (*s3.CreateMultipartUploadOutput, error)
        DeleteObject(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)
        GetObject(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) (*s3.GetObjectOutput, error)
        UploadPart(context.Context, *s3.UploadPartInput, ...func(*s3.Options)) (*s3.UploadPartOutput, error)
}

type s3Stream struct {
        config        *server.Config
        ctx           context.Context
        size          int
        buffer        bytes.Buffer
        client        s3Client
        bucket        string
        key           string
        partNumber    int32
        partSize      int64
        uploadID      string
        parts         []types.CompletedPart
        multiPartSize int64
}

// NewS3Stream returns a log streamer for the S3 log storage type.
func NewS3Stream(ctx context.Context, log *v1alpha3.Log, config *server.Config) (Stream, error) <span class="cov0" title="0">{
        if log.Status.Path == "" </span><span class="cov0" title="0">{
                filePath, err := FilePath(log)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">log.Status.Path = filePath</span>
        }

        <span class="cov0" title="0">filePath := filepath.Join(config.LOGS_PATH, log.Status.Path)

        client, err := initConfig(ctx, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">multipartUpload, err := client.CreateMultipartUpload(ctx,
                &amp;s3.CreateMultipartUploadInput{
                        Bucket: &amp;config.S3_BUCKET_NAME,
                        Key:    &amp;filePath,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">multiPartSize := config.S3_MULTI_PART_SIZE
        if multiPartSize == 0 </span><span class="cov0" title="0">{
                multiPartSize = defaultS3MultiPartSize
        }</span>

        <span class="cov0" title="0">size := config.LOGS_BUFFER_SIZE
        if size &lt; 1 </span><span class="cov0" title="0">{
                size = DefaultBufferSize
        }</span>

        <span class="cov0" title="0">s3s := &amp;s3Stream{
                config:        config,
                ctx:           ctx,
                size:          size,
                bucket:        config.S3_BUCKET_NAME,
                key:           filePath,
                buffer:        bytes.Buffer{},
                uploadID:      *multipartUpload.UploadId,
                client:        client,
                partNumber:    1,
                multiPartSize: multiPartSize,
        }

        return s3s, nil</span>
}

func initConfig(ctx context.Context, cfg *server.Config) (*s3.Client, error) <span class="cov0" title="0">{
        credentialsOpt := config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(cfg.S3_ACCESS_KEY_ID, cfg.S3_SECRET_ACCESS_KEY, ""))

        var awsConfig aws.Config
        var err error
        if len(cfg.S3_ENDPOINT) &gt; 0 </span><span class="cov0" title="0">{
                customResolver := aws.EndpointResolverWithOptionsFunc(func(_, region string, _ ...any) (aws.Endpoint, error) </span><span class="cov0" title="0">{ //nolint:staticcheck
                        if region == cfg.S3_REGION </span><span class="cov0" title="0">{
                                return aws.Endpoint{ //nolint:staticcheck
                                        URL:               cfg.S3_ENDPOINT,
                                        SigningRegion:     cfg.S3_REGION,
                                        HostnameImmutable: cfg.S3_HOSTNAME_IMMUTABLE,
                                }, nil
                        }</span>
                        <span class="cov0" title="0">return aws.Endpoint{}, &amp;aws.EndpointNotFoundError{}</span> //nolint:staticcheck
                })
                <span class="cov0" title="0">awsConfig, err = config.LoadDefaultConfig(ctx, config.WithRegion(cfg.S3_REGION), credentialsOpt, config.WithEndpointResolverWithOptions(customResolver))</span> //nolint:staticcheck
        } else<span class="cov0" title="0"> {
                awsConfig, err = config.LoadDefaultConfig(ctx, config.WithRegion(cfg.S3_REGION), credentialsOpt)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s3.NewFromConfig(awsConfig, func(o *s3.Options) </span><span class="cov0" title="0">{
                o.UsePathStyle = true
        }</span>), nil
}

func (*s3Stream) Type() string <span class="cov0" title="0">{
        return string(v1alpha3.S3LogType)
}</span>

func (s3s *s3Stream) WriteTo(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        outPut, err := s3s.client.GetObject(s3s.ctx, &amp;s3.GetObjectInput{
                Bucket: &amp;s3s.bucket,
                Key:    &amp;s3s.key,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">defer outPut.Body.Close()

        reader := bufio.NewReaderSize(outPut.Body, s3s.size)
        n, err = reader.WriteTo(w)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s3s *s3Stream) ReadFrom(r io.Reader) (int64, error) <span class="cov8" title="1">{
        n, err := s3s.buffer.ReadFrom(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">size := s3s.partSize + n
        if size &gt;= s3s.multiPartSize </span><span class="cov8" title="1">{
                err = s3s.uploadMultiPart(&amp;s3s.buffer, s3s.partNumber, size)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">s3s.partSize = 0
                s3s.buffer.Reset()</span>
        } else<span class="cov8" title="1"> {
                s3s.partSize = size
        }</span>

        <span class="cov8" title="1">return s3s.partSize, err</span>
}

func (s3s *s3Stream) uploadMultiPart(reader io.Reader, partNumber int32, partSize int64) error <span class="cov8" title="1">{
        if partSize == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">part, err := s3s.client.UploadPart(s3s.ctx, &amp;s3.UploadPartInput{
                UploadId:      &amp;s3s.uploadID,
                Bucket:        &amp;s3s.bucket,
                Key:           &amp;s3s.key,
                PartNumber:    &amp;partNumber,
                Body:          reader,
                ContentLength: &amp;partSize,
        }, s3.WithAPIOptions(
                v4.SwapComputePayloadSHA256ForUnsignedPayloadMiddleware,
        ))

        if err != nil </span><span class="cov0" title="0">{
                s3s.client.AbortMultipartUpload(s3s.ctx, &amp;s3.AbortMultipartUploadInput{ //nolint:errcheck
                        Bucket:   &amp;s3s.bucket,
                        Key:      &amp;s3s.key,
                        UploadId: &amp;s3s.uploadID,
                })
                return err
        }</span>

        <span class="cov8" title="1">s3s.parts = append(s3s.parts, types.CompletedPart{PartNumber: &amp;partNumber, ETag: part.ETag})
        s3s.partNumber++

        return err</span>
}

func (s3s *s3Stream) Flush() error <span class="cov8" title="1">{
        if err := s3s.uploadMultiPart(&amp;s3s.buffer, s3s.partNumber, int64(s3s.buffer.Len())); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err := s3s.client.CompleteMultipartUpload(s3s.ctx, &amp;s3.CompleteMultipartUploadInput{
                Bucket:   &amp;s3s.bucket,
                Key:      &amp;s3s.key,
                UploadId: &amp;s3s.uploadID,
                MultipartUpload: &amp;types.CompletedMultipartUpload{
                        Parts: s3s.parts,
                },
        })
        return err</span>
}

func (s3s *s3Stream) Delete() error <span class="cov8" title="1">{
        _, err := s3s.client.DeleteObject(s3s.ctx, &amp;s3.DeleteObjectInput{
                Bucket: &amp;s3s.bucket,
                Key:    &amp;s3s.key,
        })
        return err
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package server

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"

        "github.com/golang/protobuf/ptypes/empty"
        "github.com/google/cel-go/cel"
        celenv "github.com/tektoncd/results/pkg/api/server/cel"
        "github.com/tektoncd/results/pkg/api/server/db/errors"
        "github.com/tektoncd/results/pkg/api/server/db/pagination"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/result"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "gorm.io/gorm"

        "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/log"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"
        "github.com/tektoncd/results/pkg/logs"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// GetLog streams log record by log request
func (s *Server) GetLog(req *pb.GetLogRequest, srv pb.Logs_GetLogServer) error <span class="cov8" title="1">{
        parent, res, name, err := log.ParseName(req.GetName())
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return status.Error(codes.InvalidArgument, "Invalid Name")
        }</span>

        <span class="cov8" title="1">if err := s.auth.Check(srv.Context(), parent, auth.ResourceLogs, auth.PermissionGet); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                // unauthenticated status code and debug message produced by Check
                return err
        }</span>

        <span class="cov8" title="1">rec, err := getRecord(s.db, parent, res, name)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return err
        }</span>
        // Check if the input record is referenced in any logs record in the result
        <span class="cov8" title="1">if rec.Type != v1alpha3.LogRecordType &amp;&amp; rec.Type != v1alpha3.LogRecordTypeV2 </span><span class="cov0" title="0">{
                rec, err = getLogRecord(s.db, parent, res, name)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">stream, object, err := log.ToStream(srv.Context(), rec, s.config)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        // Handle v1alpha2 and earlier differently from v1alpha3 until v1alpha2 and earlier are deprecated
        <span class="cov8" title="1">if "results.tekton.dev/v1alpha3" == object.APIVersion </span><span class="cov8" title="1">{
                if !object.Status.IsStored || object.Status.Size == 0 </span><span class="cov0" title="0">{
                        s.logger.Errorf("no logs exist for %s", req.GetName())
                        return status.Error(codes.NotFound, "Log doesn't exist")
                }</span>
        } else<span class="cov0" title="0"> {
                // For v1alpha2 checking log size is the best way to ensure if logs are stored
                // this is however susceptible to race condition
                if object.Status.Size == 0 </span><span class="cov0" title="0">{
                        s.logger.Errorf("no logs exist for %s", req.GetName())
                        return status.Error(codes.NotFound, "Log doesn't exist")
                }</span>
        }

        <span class="cov8" title="1">writer := logs.NewBufferedHTTPWriter(srv, req.GetName(), s.config.LOGS_BUFFER_SIZE)
        if _, err = stream.WriteTo(writer); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return status.Error(codes.Internal, "Error streaming log")
        }</span>
        <span class="cov8" title="1">_, err = writer.Flush()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return status.Error(codes.Internal, "Error streaming log")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getLogRecord(txn *gorm.DB, parent, result, name string) (*db.Record, error) <span class="cov0" title="0">{
        store := &amp;db.Record{}
        q := txn.
                Where(&amp;db.Record{Result: db.Result{Parent: parent, Name: result}}).
                Where("data -&gt; 'spec' -&gt; 'resource' -&gt;&gt; 'uid' =  ?", name).
                First(store)
        if err := errors.Wrap(q.Error); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return store, nil</span>
}

// UpdateLog updates log record content
func (s *Server) UpdateLog(srv pb.Logs_UpdateLogServer) error <span class="cov8" title="1">{
        var name, parent, resultName, recordName string
        var bytesWritten int64
        var rec *db.Record
        var object *v1alpha3.Log
        var stream log.Stream
        // fyi we cannot defer the flush call in case we need to return the error
        // but instead we pass the stream into handleError to preserve the behavior of
        // calling Flush regardless when we previously called Flush via defer
        for </span><span class="cov8" title="1">{
                // the underlying grpc stream RecvMsg method blocks until this receives a message or it is done,
                recv, err := srv.Recv()
                // If we reach the end of the srv, we receive an io.EOF error
                if err != nil </span><span class="cov8" title="1">{
                        return s.handleReturn(srv, rec, object, bytesWritten, stream, err, true)
                }</span>
                // Ensure that we are receiving logs for the same record
                <span class="cov8" title="1">if name == "" </span><span class="cov8" title="1">{
                        name = recv.GetName()
                        s.logger.Debugf("receiving logs for %s", name)
                        parent, resultName, recordName, err = log.ParseName(name)
                        if err != nil </span><span class="cov0" title="0">{
                                return s.handleReturn(srv, rec, object, bytesWritten, stream, err, true)
                        }</span>

                        <span class="cov8" title="1">if err = s.auth.Check(srv.Context(), parent, auth.ResourceLogs, auth.PermissionUpdate); err != nil </span><span class="cov0" title="0">{
                                return s.handleReturn(srv, rec, object, bytesWritten, stream, err, false)
                        }</span>
                }
                <span class="cov8" title="1">if name != recv.GetName() </span><span class="cov0" title="0">{
                        err = fmt.Errorf("cannot put logs for multiple records in the same server")
                        return s.handleReturn(srv,
                                rec,
                                object,
                                bytesWritten,
                                stream,
                                err,
                                false)
                }</span>

                <span class="cov8" title="1">if rec == nil </span><span class="cov8" title="1">{
                        rec, err = getRecord(s.db.WithContext(srv.Context()), parent, resultName, recordName)
                        if err != nil </span><span class="cov0" title="0">{
                                return s.handleReturn(srv, rec, object, bytesWritten, stream, err, true)
                        }</span>
                }

                <span class="cov8" title="1">if stream == nil </span><span class="cov8" title="1">{
                        stream, object, err = log.ToStream(srv.Context(), rec, s.config)
                        if err != nil </span><span class="cov0" title="0">{
                                return s.handleReturn(srv, rec, object, bytesWritten, stream, err, false)
                        }</span>
                }

                <span class="cov8" title="1">buffer := bytes.NewBuffer(recv.GetData())
                var written int64
                written, err = stream.ReadFrom(buffer)
                bytesWritten += written

                if err != nil </span><span class="cov0" title="0">{
                        return s.handleReturn(srv, rec, object, bytesWritten, stream, err, true)
                }</span>
        }
}

func (s *Server) handleReturn(srv pb.Logs_UpdateLogServer, rec *db.Record, log *v1alpha3.Log, written int64, stream log.Stream, returnErr error, isRetryableErr bool) error <span class="cov8" title="1">{
        // When the srv reaches the end, srv.Recv() returns an io.EOF error
        // Therefore we should not return io.EOF if it is received in this function.
        // Otherwise, we should return the original error and not mask any subsequent errors handling cleanup/return.

        returnErrorStr := ""
        if returnErr != nil </span><span class="cov8" title="1">{
                returnErrorStr = returnErr.Error()
        }</span>

        // If no database record or Log, return the original error
        <span class="cov8" title="1">if rec == nil || log == nil </span><span class="cov0" title="0">{
                if stream != nil </span><span class="cov0" title="0">{
                        if flushErr := stream.Flush(); flushErr != nil </span><span class="cov0" title="0">{
                                s.logger.Error(flushErr)
                                return fmt.Errorf("got flush error %s with returnErr: %s", flushErr.Error(), returnErrorStr)
                        }</span>
                }
                <span class="cov0" title="0">return returnErr</span>
        }
        <span class="cov8" title="1">apiRec := record.ToAPI(rec)
        apiRec.UpdateTime = timestamppb.Now()
        log.Status.Size = written
        log.Status.IsStored = returnErr == io.EOF
        if returnErr != nil &amp;&amp; returnErr != io.EOF </span><span class="cov0" title="0">{
                log.Status.ErrorOnStoreMsg = returnErr.Error()
                log.Status.IsRetryableErr = isRetryableErr
        }</span>

        <span class="cov8" title="1">data, err := json.Marshal(log)
        if err != nil </span><span class="cov0" title="0">{
                if stream != nil </span><span class="cov0" title="0">{
                        if flushErr := stream.Flush(); flushErr != nil </span><span class="cov0" title="0">{
                                s.logger.Error(flushErr)
                                return fmt.Errorf("got flush error %s with returnErr: %s", flushErr.Error(), returnErrorStr)
                        }</span>
                }
                <span class="cov0" title="0">if !isNilOrEOF(returnErr) </span><span class="cov0" title="0">{
                        return returnErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">apiRec.Data = &amp;pb.Any{
                Type:  rec.Type,
                Value: data,
        }

        _, err = s.UpdateRecord(srv.Context(), &amp;pb.UpdateRecordRequest{
                Record: apiRec,
                Etag:   rec.Etag,
        })

        if err != nil </span><span class="cov0" title="0">{
                if stream != nil </span><span class="cov0" title="0">{
                        if flushErr := stream.Flush(); flushErr != nil </span><span class="cov0" title="0">{
                                s.logger.Error(flushErr)
                                return fmt.Errorf("got flush error %s with returnErr: %s", flushErr.Error(), returnErrorStr)
                        }</span>
                }
                <span class="cov0" title="0">if !isNilOrEOF(returnErr) </span><span class="cov0" title="0">{
                        return returnErr
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if returnErr == io.EOF </span><span class="cov8" title="1">{
                if stream != nil </span><span class="cov8" title="1">{
                        if flushErr := stream.Flush(); flushErr != nil </span><span class="cov0" title="0">{
                                s.logger.Error(flushErr)
                                return flushErr
                        }</span>
                }
                <span class="cov8" title="1">s.logger.Debugf("received %d bytes for %s", written, apiRec.GetName())
                return srv.SendAndClose(&amp;pb.LogSummary{
                        Record:        apiRec.Name,
                        BytesReceived: written,
                })</span>
        }
        <span class="cov0" title="0">if stream != nil </span><span class="cov0" title="0">{
                if flushErr := stream.Flush(); flushErr != nil </span><span class="cov0" title="0">{
                        s.logger.Error(flushErr)
                        return fmt.Errorf("got flush error %s with returnErr: %s", flushErr.Error(), returnErrorStr)
                }</span>
        }
        <span class="cov0" title="0">return returnErr</span>
}

func isNilOrEOF(err error) bool <span class="cov0" title="0">{
        return err == nil || err == io.EOF
}</span>

// ListLogs returns list log records
func (s *Server) ListLogs(ctx context.Context, req *pb.ListRecordsRequest) (*pb.ListRecordsResponse, error) <span class="cov8" title="1">{
        if req.GetParent() == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Parent missing")
        }</span>
        <span class="cov8" title="1">parent, _, err := result.ParseName(req.GetParent())
        if err != nil </span><span class="cov8" title="1">{
                s.logger.Error(err)
                return nil, status.Error(codes.InvalidArgument, "Invalid Name")
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceLogs, auth.PermissionList); err != nil </span><span class="cov0" title="0">{
                s.logger.Debug(err)
                // unauthenticated status code and debug message produced by Check
                return nil, err

        }</span>

        <span class="cov8" title="1">userPageSize, err := pageSize(int(req.GetPageSize()))
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">start, err := pageStart(req.GetPageToken(), req.GetFilter())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sortOrder, err := orderBy(req.GetOrderBy())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">env, err := recordCEL()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">prg, err := celenv.ParseFilter(env, req.GetFilter())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // Fetch n+1 items to get the next token.
        <span class="cov8" title="1">rec, err := s.getFilteredPaginatedSortedLogRecords(ctx, req.GetParent(), start, userPageSize+1, prg, sortOrder)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If we returned the full n+1 items, use the last element as the next page
        // token.
        <span class="cov8" title="1">var nextToken string
        if len(rec) &gt; userPageSize </span><span class="cov8" title="1">{
                next := rec[len(rec)-1]
                var err error
                nextToken, err = pagination.EncodeToken(next.GetUid(), req.GetFilter())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">rec = rec[:len(rec)-1]</span>
        }

        <span class="cov8" title="1">return &amp;pb.ListRecordsResponse{
                Records:       rec,
                NextPageToken: nextToken,
        }, nil</span>
}

// getFilteredPaginatedSortedLogRecords returns the specified number of results that
// match the given CEL program.
func (s *Server) getFilteredPaginatedSortedLogRecords(ctx context.Context, parent, start string, pageSize int, prg cel.Program, sortOrder string) ([]*pb.Record, error) <span class="cov8" title="1">{
        parent, resultName, err := result.ParseName(parent)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rec := make([]*pb.Record, 0, pageSize)
        batcher := pagination.NewBatcher(pageSize, minPageSize, maxPageSize)
        for len(rec) &lt; pageSize </span><span class="cov8" title="1">{
                batchSize := batcher.Next()
                dbrecords := make([]*db.Record, 0, batchSize)
                q := s.db.WithContext(ctx).Where("type = ?", v1alpha3.LogRecordType)
                q = q.Where("id &gt; ?", start)
                // Specifying `-` allows users to read Records across Results.
                // See https://google.aip.dev/159 for more details.
                if parent != "-" </span><span class="cov8" title="1">{
                        q = q.Where("parent = ?", parent)
                }</span>
                <span class="cov8" title="1">if resultName != "-" </span><span class="cov8" title="1">{
                        q = q.Where("result_name = ?", resultName)
                }</span>
                <span class="cov8" title="1">if sortOrder != "" </span><span class="cov8" title="1">{
                        q = q.Order(sortOrder)
                }</span>
                <span class="cov8" title="1">q = q.Limit(batchSize).Find(&amp;dbrecords)
                if err := errors.Wrap(q.Error); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Only return results that match the filter.
                <span class="cov8" title="1">for _, r := range dbrecords </span><span class="cov8" title="1">{
                        api := record.ToAPI(r)
                        ok, err := record.Match(api, prg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Change resource name to log format
                        <span class="cov8" title="1">parent, resultName, recordName, err := record.ParseName(api.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">api.Name = log.FormatName(result.FormatName(parent, resultName), recordName)

                        rec = append(rec, api)
                        if len(rec) &gt;= pageSize </span><span class="cov8" title="1">{
                                return rec, nil
                        }</span>
                }

                // We fetched fewer results than requested - this means we've exhausted all items.
                <span class="cov8" title="1">if len(dbrecords) &lt; batchSize </span><span class="cov8" title="1">{
                        break</span>
                }

                // Set params for next batch.
                <span class="cov0" title="0">start = dbrecords[len(dbrecords)-1].ID
                batcher.Update(len(dbrecords), batchSize)</span>
        }
        <span class="cov8" title="1">return rec, nil</span>
}

// DeleteLog deletes a given record and the stored log.
func (s *Server) DeleteLog(ctx context.Context, req *pb.DeleteLogRequest) (*empty.Empty, error) <span class="cov8" title="1">{
        parent, res, name, err := log.ParseName(req.GetName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceLogs, auth.PermissionDelete); err != nil </span><span class="cov0" title="0">{
                return &amp;empty.Empty{}, err
        }</span>

        // Check in the input record exists in the database
        <span class="cov8" title="1">rec, err := getRecord(s.db, parent, res, name)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;empty.Empty{}, err
        }</span>
        // Check if the input record is referenced in any logs record
        <span class="cov8" title="1">if rec.Type != v1alpha3.LogRecordType </span><span class="cov0" title="0">{
                rec, err = getLogRecord(s.db, parent, res, name)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;empty.Empty{}, err
                }</span>
        }

        <span class="cov8" title="1">streamer, _, err := log.ToStream(ctx, rec, s.config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = streamer.Delete()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;empty.Empty{}, errors.Wrap(s.db.WithContext(ctx).Delete(&amp;db.Record{}, rec).Error)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
        "fmt"
        "strings"

        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

var allowedOrderByFields = []string{"created_time", "updated_time"}

// orderBy validates and returns a string formatted suitably for
// a sql order by clause.
func orderBy(fields string) (string, error) <span class="cov8" title="1">{
        if strings.TrimSpace(fields) == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">var orderBy []string
        for _, field := range strings.Split(fields, ",") </span><span class="cov8" title="1">{
                ob, err := normalizeOrderByField(field)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>
                <span class="cov8" title="1">orderBy = append(orderBy, ob)</span>
        }

        <span class="cov8" title="1">return strings.Join(orderBy, ","), nil</span>
}

// normalizeOrderByField takes a field string, validating and formatting
// it for use in a sql query. An error is returned if the format of the string
// doesn't match either "field_name" or "field_name direction".
func normalizeOrderByField(field string) (string, error) <span class="cov8" title="1">{
        f := strings.Fields(field)
        fieldName := ""
        direction := ""
        switch len(f) </span>{
        case 1:<span class="cov8" title="1">
                fieldName = f[0]</span>
        case 2:<span class="cov8" title="1">
                fieldName = f[0]
                direction = f[1]</span>
        default:<span class="cov8" title="1">
                return "", status.Errorf(codes.InvalidArgument, "invalid order_by %q", field)</span>
        }

        <span class="cov8" title="1">if !isAllowedField(fieldName) </span><span class="cov8" title="1">{
                return "", status.Errorf(codes.InvalidArgument, "order by %s not supported", fieldName)
        }</span>

        <span class="cov8" title="1">if direction == "" </span><span class="cov8" title="1">{
                return fieldName, nil
        }</span>
        <span class="cov8" title="1">return orderByDirection(fieldName, direction)</span>
}

func isAllowedField(name string) bool <span class="cov8" title="1">{
        for i := range allowedOrderByFields </span><span class="cov8" title="1">{
                if name == allowedOrderByFields[i] </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func orderByDirection(field string, direction string) (string, error) <span class="cov8" title="1">{
        switch strings.ToLower(direction) </span>{
        case "asc":<span class="cov8" title="1">
                return fmt.Sprintf("%s ASC", field), nil</span>
        case "desc":<span class="cov8" title="1">
                return fmt.Sprintf("%s DESC", field), nil</span>
        default:<span class="cov8" title="1">
                return "", status.Errorf(codes.InvalidArgument, "invalid sort direction %q", direction)</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
        "fmt"

        "github.com/tektoncd/results/pkg/api/server/db/pagination"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        minPageSize = 50
        maxPageSize = 10000
)

func pageSize(in int) (int, error) <span class="cov8" title="1">{
        if in &lt; 0 </span><span class="cov8" title="1">{ //nolint:gocritic
                return 0, status.Error(codes.InvalidArgument, "PageSize should be greater than 0")
        }</span> else<span class="cov8" title="1"> if in == 0 </span><span class="cov8" title="1">{
                return minPageSize, nil
        }</span> else<span class="cov8" title="1"> if in &gt; maxPageSize </span><span class="cov8" title="1">{
                return maxPageSize, nil
        }</span>
        <span class="cov8" title="1">return in, nil</span>
}

func pageStart(token, filter string) (string, error) <span class="cov8" title="1">{
        if token == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">tokenName, tokenFilter, err := pagination.DecodeToken(token)
        if err != nil </span><span class="cov8" title="1">{
                return "", status.Error(codes.InvalidArgument, fmt.Sprintf("invalid PageToken: %v", err))
        }</span>
        <span class="cov8" title="1">if filter != tokenFilter </span><span class="cov8" title="1">{
                return "", status.Error(codes.InvalidArgument, "filter does not match previous query")
        }</span>
        <span class="cov8" title="1">return tokenName, nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package plugin

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/http/httputil"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "slices"
        "sort"
        "strconv"
        "strings"
        "time"

        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/metadata"
        "google.golang.org/grpc/status"
        "gorm.io/gorm"

        "gocloud.dev/blob"

        // Adding the driver for gcs.
        _ "gocloud.dev/blob/gcsblob"
        // Adding the driver for s3.
        _ "gocloud.dev/blob/s3blob"

        "github.com/tektoncd/results/pkg/api/server/db"
        dbErrors "github.com/tektoncd/results/pkg/api/server/db/errors"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/log"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"
        "github.com/tektoncd/results/pkg/logs"
        pb3 "github.com/tektoncd/results/proto/v1alpha3/results_go_proto"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

const (
        lokiQueryPath      = "/loki/api/v1/query_range"
        splunkQueryPath    = "/services/search/v2/jobs"
        typePipelineRun    = "tekton.dev/v1.PipelineRun"
        typeTaskRun        = "tekton.dev/v1.TaskRun"
        typeTaskRunV1Beta1 = "tekton.dev/v1beta1.TaskRun"

        legacyLogType = "v1alpha2LogType"
        // TODO: make this key configurable in a future release
        defaultBlobPathParams = "/%s/%s/%s/" // parent/result/record

        // TODO make these key configurable in a future release
        pipelineRunUIDKey         = "kubernetes.labels.tekton_dev_pipelineRunUID"
        taskRunUIDKey             = "kubernetes.labels.tekton_dev_taskRunUID"
        splunkPollInterval        = 5 * time.Second
        splunkPollTimeoutDuration = 1 * time.Minute
        splunkTokenEnv            = "SPLUNK_SEARCH_TOKEN"
        splunkOutputFormat        = "?output_mode=json"
)

var (
        openBucket = func(ctx context.Context, urlString string) (*blob.Bucket, error) <span class="cov0" title="0">{
                bucket, err := blob.OpenBucket(ctx, urlString)
                return bucket, err
        }</span>
        clean = func(bucket *blob.Bucket, logger *zap.SugaredLogger) <span class="cov0" title="0">{
                err := bucket.Close()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Got error while closing bucket %s", err)
                }</span>
        }
)

type getLog func(s *LogServer, writer io.Writer, parent string, rec *db.Record) error

// GetLog streams log record by log request
func (s *LogServer) GetLog(req *pb3.GetLogRequest, srv pb3.Logs_GetLogServer) error <span class="cov8" title="1">{
        parent, res, name, err := log.ParseName(req.GetName())
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return status.Error(codes.InvalidArgument, "Invalid Name")
        }</span>

        <span class="cov8" title="1">if err := s.auth.Check(srv.Context(), parent, auth.ResourceLogs, auth.PermissionGet); err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                // unauthenticated status code and debug message produced by Check
                return err
        }</span>

        <span class="cov8" title="1">rec, err := getRecord(s.db, parent, res, name)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return err
        }</span>

        <span class="cov8" title="1">if rec == nil </span><span class="cov0" title="0">{
                s.logger.Errorf("records not found: parent: %s, result: %s, name: %s", parent, res, name)
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">writer := logs.NewBufferedHTTPWriter(srv, req.GetName(), s.config.LOGS_BUFFER_SIZE)

        err = s.getLog(s, writer, parent, rec)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
        }</span>

        <span class="cov8" title="1">_, err = writer.Flush()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return status.Error(codes.Internal, "Error streaming log")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getLokiLogs(s *LogServer, writer io.Writer, parent string, rec *db.Record) error <span class="cov8" title="1">{
        URL, err := url.Parse(s.config.LOGGING_PLUGIN_API_URL)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">URL.Path = path.Join(URL.Path, s.config.LOGGING_PLUGIN_PROXY_PATH, lokiQueryPath)

        var startTime, endTime, uidKey string
        switch rec.Type </span>{
        case typePipelineRun:<span class="cov8" title="1">
                uidKey = pipelineRunUIDKey
                data := &amp;pipelinev1.PipelineRun{}
                err := json.Unmarshal(rec.Data, data)
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to marshal pipelinerun data for fetching log, err: %s", err.Error())
                        s.logger.Error(err)
                        return err
                }</span>

                <span class="cov8" title="1">if data.Status.StartTime == nil </span><span class="cov0" title="0">{
                        err = errors.New("there's no startime in pipelinerun")
                        s.logger.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">startTime = strconv.FormatInt(data.Status.StartTime.UTC().Unix(), 10)

                if data.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                        err = errors.New("there's no completion in pipelinerun")
                        s.logger.Error(err)
                        return err
                }</span>
                <span class="cov8" title="1">endTime = strconv.FormatInt(data.Status.CompletionTime.Add(s.forwarderDelayDuration).UTC().Unix(), 10)</span>

        case typeTaskRun:<span class="cov0" title="0">
                uidKey = taskRunUIDKey
                data := &amp;pipelinev1.TaskRun{}
                err := json.Unmarshal(rec.Data, data)
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("failed to marshal taskrun data for fetching log, err: %s", err.Error())
                        s.logger.Error(err)
                        return err
                }</span>
                <span class="cov0" title="0">if data.Status.StartTime == nil </span><span class="cov0" title="0">{
                        err = errors.New("there's no startime in taskrun")
                        s.logger.Error(err)
                        return err
                }</span>
                <span class="cov0" title="0">startTime = strconv.FormatInt(data.Status.StartTime.UTC().Unix(), 10)

                if data.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                        err = errors.New("there's no completion in taskrun")
                        s.logger.Error(err)
                        return err
                }</span>
                <span class="cov0" title="0">endTime = strconv.FormatInt(data.Status.CompletionTime.Add(s.forwarderDelayDuration).UTC().Unix(), 10)</span>

        default:<span class="cov0" title="0">
                s.logger.Errorf("record type is invalid, record ID: %v, Name: %v, result Name: %v, result ID:  %v", rec.ID, rec.Name, rec.ResultName, rec.ResultID)
                return errors.New("record type is invalid")</span>
        }

        <span class="cov8" title="1">parameters := url.Values{}
        for k, v := range s.queryParams </span><span class="cov8" title="1">{
                parameters.Add(k, v)
        }</span>
        <span class="cov8" title="1">query := `{ ` + s.staticLabels + s.config.LOGGING_PLUGIN_NAMESPACE_KEY + `="` + parent + `" }|json uid="` + uidKey + `", message="message" |uid="` + rec.Name + `"| line_format "{{.message}}"`
        if s.config.LOGGING_PLUGIN_CONTAINER_KEY != "" </span><span class="cov8" title="1">{
                query = `{ ` + s.staticLabels + s.config.LOGGING_PLUGIN_NAMESPACE_KEY + `="` + parent + `" }|json uid="` + uidKey + `", container="` + s.config.LOGGING_PLUGIN_CONTAINER_KEY + `", message="message" |uid="` + rec.Name + `"| line_format "container-{{.container}}: message={{.message}}"`
        }</span>
        <span class="cov8" title="1">parameters.Add("query", query)
        parameters.Add("end", endTime)
        parameters.Add("start", startTime)
        parameters.Add("limit", strconv.FormatUint(uint64(s.queryLimit), 10))

        URL.RawQuery = parameters.Encode()
        s.logger.Debugf("loki request url:%s", URL.String())

        req, err := http.NewRequest("GET", URL.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("new request to loki failed, err: %s:", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">token, err := s.tokenSource.Token()
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to fetch token", err)
                return err
        }</span>

        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+token.AccessToken)
        resp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                dump, derr := httputil.DumpRequest(req, true)
                if derr == nil </span><span class="cov0" title="0">{
                        s.logger.Debugf("Request Dump***:\n %q\n", dump)
                }</span>
                <span class="cov0" title="0">s.logger.Errorf("request to loki failed, err: %s, req: %v", err.Error(), req)
                return status.Error(codes.Internal, "Error streaming log")</span>
        }

        <span class="cov8" title="1">if resp == nil </span><span class="cov0" title="0">{
                dump, err := httputil.DumpRequest(req, true)
                if err == nil </span><span class="cov0" title="0">{
                        s.logger.Debugf("Request Dump***:\n %q\n", dump)
                }</span>
                <span class="cov0" title="0">s.logger.Errorf("request to loki failed, received nil response")
                s.logger.Debugf("loki request url:%s", URL.String())
                return status.Error(codes.Internal, "Error streaming log")</span>
        }

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                s.logger.Errorf("Loki API request failed with HTTP status code: %d", resp.StatusCode)
                dump, err := httputil.DumpRequest(req, true)
                if err == nil </span><span class="cov0" title="0">{
                        s.logger.Debugf("Request Dump***:\n %q\n", dump)
                }</span>
                <span class="cov0" title="0">dump, err = httputil.DumpResponse(resp, true)
                if err == nil </span><span class="cov0" title="0">{
                        s.logger.Debugf("Response Dump***:\n %q\n", dump)
                }</span>
                <span class="cov0" title="0">return status.Error(codes.Internal, "Error fetching log data")</span>
        }

        <span class="cov8" title="1">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to read response body, err: %s", err.Error())
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">var lokiResponse struct {
                Status string `json:"status"`
                Error  string `json:"error"`
                Data   struct {
                        Result []struct {
                                Stream struct {
                                        Message string `json:"message"`
                                } `json:"stream"`
                                Values [][]string `json:"values"`
                        } `json:"result"`
                        Stats map[string]interface{} `json:"stats"`
                } `json:"data"`
        }

        if err := json.Unmarshal(data, &amp;lokiResponse); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to unmarshal Loki response, err: %s, data: %s", err.Error(), string(data))
                return status.Error(codes.Internal, fmt.Sprintf("Error processing fetched log data, err: %s, data: %s",
                        err.Error(), string(data)))
        }</span>

        <span class="cov8" title="1">s.logger.Debugf("stats.summary %v", lokiResponse.Data.Stats["summary"])

        if lokiResponse.Status != "success" </span><span class="cov0" title="0">{
                s.logger.Errorf("Loki API request failed with status: %s, error: %s", lokiResponse.Status, lokiResponse.Error)
                return status.Error(codes.Internal, "Error fetching log data from Loki")
        }</span>

        <span class="cov8" title="1">var logMessages [][]string
        for _, result := range lokiResponse.Data.Result </span><span class="cov8" title="1">{
                logMessages = append(logMessages, result.Values...)
        }</span>

        <span class="cov8" title="1">sort.Slice(logMessages, func(i, j int) bool </span><span class="cov8" title="1">{
                if len(logMessages[i]) == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">if len(logMessages[j]) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">return logMessages[i][0] &lt; logMessages[j][0]</span>
        })

        <span class="cov8" title="1">var orderMessages []string
        for _, val := range logMessages </span><span class="cov8" title="1">{
                if len(val) &lt;= 1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">orderMessages = append(orderMessages, val[1:]...)</span>
        }

        <span class="cov8" title="1">formattedLogs := strings.Join(orderMessages, "\n")

        if _, err = writer.Write([]byte(formattedLogs)); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to write log data, err: %s", err.Error())
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getBlobLogs(s *LogServer, writer io.Writer, parent string, rec *db.Record) error <span class="cov0" title="0">{
        u, err := url.Parse(s.config.LOGGING_PLUGIN_API_URL)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">legacy := false
        queryParams := u.Query()

        for k, v := range s.queryParams </span><span class="cov0" title="0">{
                if k == legacyLogType &amp;&amp; v == "true" </span><span class="cov0" title="0">{
                        legacy = true
                        continue</span>
                }
                <span class="cov0" title="0">queryParams.Add(k, v)</span>
        }
        <span class="cov0" title="0">u.RawQuery = queryParams.Encode()

        logPath := []string{}

        ctx := context.Background()
        s.logger.Debugf("blob bucket: %s", u.String())
        bucket, err := openBucket(ctx, u.String())
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("error opening bucket: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">defer clean(bucket, s.logger)

        switch rec.Type </span>{
        case typePipelineRun:<span class="cov0" title="0">
                err := errors.New("pipelinerun not supported, please use taskrun")
                s.logger.Error(err)
                return err</span>
        case typeTaskRunV1Beta1:<span class="cov0" title="0">
                if legacy </span><span class="cov0" title="0">{
                        logRec, err := getLogRecord(s.db, parent, rec.ResultID, rec.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                s.logger.Debugf("error getting legacy log record: %s", err)
                        }</span>
                        <span class="cov0" title="0">if logRec != nil </span><span class="cov0" title="0">{
                                log := &amp;v1alpha3.Log{}
                                err := json.Unmarshal(logRec.Data, log)
                                if err != nil </span><span class="cov0" title="0">{
                                        err = fmt.Errorf("could not decode Log record: %w", err)
                                        s.logger.Error(err)
                                        return err
                                }</span>
                                <span class="cov0" title="0">logPath = append(logPath, filepath.Join(s.config.LOGS_PATH, log.Status.Path))</span>
                        }
                } else<span class="cov0" title="0"> {
                        s.logger.Errorf("record type is invalid %s", rec.Type)
                        return fmt.Errorf("record type is invalid %s", rec.Type)
                }</span>
        case typeTaskRun:<span class="cov0" title="0">
                s.logger.Debugf("taskrun type")
                iter := bucket.List(&amp;blob.ListOptions{
                        Prefix: strings.TrimPrefix(s.config.LOGS_PATH+fmt.Sprintf(defaultBlobPathParams, parent, rec.ResultName, rec.Name), "/"),
                })
                s.logger.Debugf("prefix: %s", strings.TrimPrefix(s.config.LOGS_PATH+fmt.Sprintf(defaultBlobPathParams, parent, rec.ResultName, rec.Name), "/"))
                // bucket.List returns the objects sorted alphabetically by key (name), we need that sorted by last modified time
                toSort := []*blob.ListObject{}
                for </span><span class="cov0" title="0">{
                        obj, err := iter.Next(ctx)
                        if err == io.EOF </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                err := fmt.Errorf("error listing log bucket objects: %w", err)
                                s.logger.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">toSort = append(toSort, obj)</span>
                }
                // S3 objects ModTime is rounded to the second (not milliseconds), so objects stored in the same second are still ordered alphabetically
                <span class="cov0" title="0">slices.SortFunc(toSort, func(a, b *blob.ListObject) int </span><span class="cov0" title="0">{
                        return time.Time.Compare(a.ModTime, b.ModTime)
                }</span>)
                <span class="cov0" title="0">for _, obj := range toSort </span><span class="cov0" title="0">{
                        logPath = append(logPath, obj.Key)
                }</span>

                <span class="cov0" title="0">s.logger.Debugf("logPath: %v", logPath)</span>
        case v1alpha3.LogRecordType, v1alpha3.LogRecordTypeV2:<span class="cov0" title="0">
                log := &amp;v1alpha3.Log{}
                err := json.Unmarshal(rec.Data, log)
                if err != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("could not decode Log record: %w", err)
                        s.logger.Error(err)
                        return err
                }</span>
                <span class="cov0" title="0">logPath = append(logPath, filepath.Join(s.config.LOGS_PATH, log.Status.Path))</span>
        default:<span class="cov0" title="0">
                s.logger.Errorf("record type is invalid, record ID: %v, Name: %v, result Name: %v, result ID:  %v", rec.ID, rec.Name, rec.ResultName, rec.ResultID)
                return fmt.Errorf("record type is invalid %s", rec.Type)</span>
        }

        <span class="cov0" title="0">regex := s.config.LOGGING_PLUGIN_MULTIPART_REGEX
        re, err := regexp.Compile(regex)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to compile regexp: %s", err)
                return err
        }</span>
        <span class="cov0" title="0">mergedLogParts := mergeLogParts(logPath, re)

        for _, parts := range mergedLogParts </span><span class="cov0" title="0">{
                baseName := re.ReplaceAllString(parts[0], "")
                s.logger.Debugf("mergedLogParts key: %s value: %v", baseName, parts)
                _, file := filepath.Split(baseName)
                fmt.Fprint(writer, strings.TrimRight(file, ".log")+" :-\n")
                for _, part := range parts </span><span class="cov0" title="0">{
                        err := func() error </span><span class="cov0" title="0">{
                                rc, err := bucket.NewReader(ctx, part, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("error creating bucket reader: %s for log part: %s", err, part)
                                        return err
                                }</span>
                                <span class="cov0" title="0">defer rc.Close()

                                _, err = rc.WriteTo(writer)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("error writing the logs: %s", err)
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }()
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                s.logger.Error(err)
                                return err
                        }</span>
                        <span class="cov0" title="0">fmt.Fprint(writer, "\n")</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// mergeLogParts organizes in groups objects part of the same log
func mergeLogParts(logPath []string, re *regexp.Regexp) [][]string <span class="cov8" title="1">{
        merged := [][]string{}
        // use extra mapping [log_base_name:index_of_slice_of_parts] to preserve the order of elements
        baseNameIndexes := map[string]int{}
        index := 0
        for _, log := range logPath </span><span class="cov8" title="1">{
                baseName := re.ReplaceAllString(log, "")
                if existingIndex, ok := baseNameIndexes[baseName]; ok </span><span class="cov8" title="1">{
                        merged[existingIndex] = append(merged[existingIndex], log)
                }</span> else<span class="cov8" title="1"> {
                        baseNameIndexes[baseName] = index
                        merged = append(merged, []string{log})
                        index++
                }</span>
        }
        <span class="cov8" title="1">return merged</span>
}

// getSplunkLogs retrieves logs for a given record from a Splunk backend and writes them to the provided writer.
//
// It constructs a Splunk search job using the record's UID and namespace, submits the job, polls for completion, and fetches the resulting logs.
// The function requires a valid Splunk API URL, a search token from the environment, and an "index" query parameter.
// Returns an error if any step in the process fails, including job creation, polling, or log retrieval.
func getSplunkLogs(s *LogServer, writer io.Writer, parent string, rec *db.Record) error <span class="cov8" title="1">{
        URL, err := url.Parse(s.config.LOGGING_PLUGIN_API_URL)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error(err)
                return err
        }</span>
        <span class="cov8" title="1">URL.Path = path.Join(URL.Path, splunkQueryPath)

        token := os.Getenv(splunkTokenEnv)
        if token == "" </span><span class="cov0" title="0">{
                s.logger.Error("splunk token not set SPLUNK_SEARCH_TOKEN")
                return errors.New("splunk token not set")

        }</span>

        <span class="cov8" title="1">var uidKey string
        switch rec.Type </span>{
        case typePipelineRun:<span class="cov0" title="0">
                uidKey = pipelineRunUIDKey</span>
        case typeTaskRun:<span class="cov8" title="1">
                uidKey = taskRunUIDKey</span>
        default:<span class="cov0" title="0">
                s.logger.Errorf("record type is invalid, record ID: %v, Name: %v, result Name: %v, result ID:  %v, rec Type: %v", rec.ID, rec.Name, rec.ResultName, rec.ResultID, rec.Type)
                return errors.New("record type is invalid")</span>
        }
        <span class="cov8" title="1">index, ok := s.queryParams["index"]
        if !ok </span><span class="cov0" title="0">{
                s.logger.Errorf("index not specified in queryParams: %v\n", s.queryParams)
                return errors.New("index not specified in query parameters")

        }</span>
        <span class="cov8" title="1">s.logger.Debugf("splunk request url:%s", URL.String()+splunkOutputFormat)

        query := fmt.Sprintf(`search index=%s %s=%q %s=%q | table message structured.msg %s`,
                index, uidKey, rec.Name, s.config.LOGGING_PLUGIN_NAMESPACE_KEY, parent,
                s.config.LOGGING_PLUGIN_CONTAINER_KEY)

        queryData := url.Values{}
        queryData.Set("search", query)

        req, err := http.NewRequest("POST", URL.String()+splunkOutputFormat, bytes.NewReader([]byte(queryData.Encode())))
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("new request to splunk failed, err: %s:", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        req.Header.Set("Authorization", "Bearer "+token)
        resp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("request to splunk failed, err: %s, req: %v", err.Error(), req)
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">if resp == nil </span><span class="cov0" title="0">{
                s.logger.Errorf("request to splunk failed, received nil response")
                s.logger.Debugf("splunk request url:%s", URL.String())
                return status.Error(codes.Internal, "Error streaming log")
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                s.logger.Errorf("Splunk Job Creation API request failed with HTTP status code: %d", resp.StatusCode)
                return status.Error(codes.Internal, "Error fetching log data - search job creation failed")
        }</span>

        <span class="cov8" title="1">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to read response body, err: %s", err.Error())
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">var searchResponse struct {
                SID string `json:"sid"`
        }

        if err := json.Unmarshal(data, &amp;searchResponse); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to unmarshal Splunk Search response, err: %s, data: %s", err.Error(), string(data))
                return status.Error(codes.Internal, fmt.Sprintf("Error processing fetched log data, err: %s, data: %s",
                        err.Error(), string(data)))
        }</span>

        <span class="cov8" title="1">if err := pollSplunkJobStatus(s, URL.String()+"/"+searchResponse.SID+splunkOutputFormat, token); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to poll splunk job status, err: %v", err)
                return status.Error(codes.Internal, fmt.Sprintf("Error failed to poll splunk search job status, err: %s", err.Error()))
        }</span>

        <span class="cov8" title="1">req, err = http.NewRequest("GET", URL.String()+"/"+searchResponse.SID+"/results?output_mode=json_rows&amp;count=0", nil)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("new request to splunk failed, err: %s:", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+token)
        lresp, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("request to fetch log from  splunk failed, err: %s, req: %v", err.Error(), req)
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">if lresp == nil </span><span class="cov0" title="0">{
                s.logger.Errorf("request to splunk failed, received nil response")
                s.logger.Debugf("splunk request url:%s", URL.String())
                return status.Error(codes.Internal, "Error streaming log")
        }</span>
        <span class="cov8" title="1">defer lresp.Body.Close()

        if lresp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                s.logger.Errorf("Splunk Fetch Log API request failed with HTTP status code: %d", resp.StatusCode)
                return status.Error(codes.Internal, "Error fetching log data - fetch log api failed")
        }</span>

        <span class="cov8" title="1">data, err = io.ReadAll(lresp.Body)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to read response body, err: %s", err.Error())
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">var logData struct {
                Rows [][]string `json:"rows"`
        }
        if err := json.Unmarshal(data, &amp;logData); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to unmarshal Splunk log data, err: %s, data: %s", err.Error(), string(data))
                return fmt.Errorf("failed to unmarshal Splunk log data, err: %s", err.Error())
        }</span>

        <span class="cov8" title="1">var logMessages []string
        step := ""
        for _, msg := range logData.Rows </span><span class="cov8" title="1">{
                if len(msg) != 3 </span><span class="cov0" title="0">{
                        s.logger.Errorf("mismatch in column data, should be 3 received: %v, %v", len(msg), msg)
                        continue</span>
                }
                <span class="cov8" title="1">if step != msg[2] </span><span class="cov8" title="1">{
                        step = msg[2]
                        logMessages = append(logMessages, step+":-")
                }</span>
                <span class="cov8" title="1">logMessages = append(logMessages, msg[0]+msg[1])</span>
        }

        <span class="cov8" title="1">formattedLogs := strings.Join(logMessages, "\n")
        if _, err = writer.Write([]byte(formattedLogs)); err != nil </span><span class="cov0" title="0">{
                s.logger.Errorf("failed to write log data, err: %s", err.Error())
                return status.Error(codes.Internal, "Error streaming log")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// pollSplunkJobStatus polls the status of a Splunk search job until it is complete, fails, or times out.
// It sends periodic GET requests to the provided Splunk job status URL using the given token.
// Returns an error if the job fails, is canceled, or does not complete within the timeout period.
func pollSplunkJobStatus(s *LogServer, url, token string) error <span class="cov8" title="1">{
        ticker := time.NewTicker(splunkPollInterval)
        defer ticker.Stop()

        timeout := time.After(splunkPollTimeoutDuration)

        errSplunkJobFailed := errors.New("splunk job failed")

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-timeout:<span class="cov0" title="0">
                        s.logger.Errorf("timeout reached for splunk search job, url: %v", url)
                        return fmt.Errorf("timeout reached for splunk search job, url: %v", url)</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        err := func() error </span><span class="cov8" title="1">{
                                req, err := http.NewRequest("GET", url, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("new request to splunk failed, err: %s:", err.Error())
                                        return fmt.Errorf("new request to splunk failed: err: %s", err.Error())
                                }</span>

                                <span class="cov8" title="1">req.Header.Set("Authorization", "Bearer "+token)
                                resp, err := s.client.Do(req)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("request to splunk failed, err: %s, req: %v", err.Error(), req)
                                        return fmt.Errorf("request to splunk failed, err: %s, req: %v", err.Error(), req)
                                }</span>

                                <span class="cov8" title="1">if resp == nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("request to splunk failed, received nil response,: %s", url)
                                        return fmt.Errorf("request to splunk failed, received nil response,: %s", url)
                                }</span>
                                <span class="cov8" title="1">defer resp.Body.Close()
                                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                                        s.logger.Errorf("Splunk Job Creation API request failed with HTTP status code: %d", resp.StatusCode)
                                        return fmt.Errorf("splunk job creation API request failed with HTTP status code: %d", resp.StatusCode)
                                }</span>

                                <span class="cov8" title="1">data, err := io.ReadAll(resp.Body)
                                if err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("failed to read response body, err: %s", err.Error())
                                        return fmt.Errorf("failed to read response body, err: %s", err.Error())
                                }</span>

                                <span class="cov8" title="1">var jobResp struct {
                                        Entry []struct {
                                                Content struct {
                                                        DispatchState string `json:"dispatchState"`
                                                } `json:"content"`
                                        } `json:"entry"`
                                }

                                if err := json.Unmarshal(data, &amp;jobResp); err != nil </span><span class="cov0" title="0">{
                                        s.logger.Errorf("failed to unmarshal Splunk Search response, err: %s, data: %s", err.Error(), string(data))
                                        return fmt.Errorf("failed to unmarshal Splunk Search response, err: %s, data: %s", err.Error(), string(data))
                                }</span>
                                <span class="cov8" title="1">if len(jobResp.Entry) == 0 </span><span class="cov0" title="0">{
                                        s.logger.Errorf("empty Splunk Search response entry, data: %s", string(data))
                                        return fmt.Errorf("empty Splunk Search response entry, data: %s", string(data))
                                }</span>

                                <span class="cov8" title="1">switch jobResp.Entry[0].Content.DispatchState </span>{
                                case "DONE":<span class="cov8" title="1">
                                        return nil</span>
                                case "INTERNAL_CANCEL", "USER_CANCEL", "BAD_INPUT_CANCEL", "QUIT", "FAILED":<span class="cov0" title="0">
                                        return fmt.Errorf("%w: state: %s", errSplunkJobFailed, jobResp.Entry[0].Content.DispatchState)</span>
                                default:<span class="cov0" title="0">
                                        return fmt.Errorf("waiting for job to be done: current state %s", jobResp.Entry[0].Content.DispatchState)</span>
                                }
                        }()
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, errSplunkJobFailed) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }
        }
}

func (s *LogServer) setLogPlugin() bool <span class="cov8" title="1">{
        switch strings.ToLower(s.config.LOGS_TYPE) </span>{
        case string(v1alpha3.LokiLogType):<span class="cov8" title="1">
                s.IsLogPluginEnabled = true
                s.getLog = getLokiLogs</span>
        case string(v1alpha3.BlobLogType):<span class="cov0" title="0">
                s.IsLogPluginEnabled = true
                s.getLog = getBlobLogs</span>
        case string(v1alpha3.SplunkLogType):<span class="cov8" title="1">
                s.IsLogPluginEnabled = true
                s.getLog = getSplunkLogs</span>
        default:<span class="cov0" title="0">
                // TODO(xinnjie) when s.config.LOGS_TYPE is File also show this error log
                s.IsLogPluginEnabled = false
                s.logger.Warnf("Plugin Logs API Disable: unsupported type of logs given for plugin, " +
                        "legacy logging system might work")</span>
        }
        <span class="cov8" title="1">return s.IsLogPluginEnabled</span>
}

// LogMux returns a http.Handler that serves the log plugin server
func (s *LogServer) LogMux() http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // TODO: Create a new log handler
                ctx := r.Context()
                md := metadata.MD(r.Header)
                ctx = metadata.NewIncomingContext(ctx, md)
                parent := r.PathValue("parent")
                recID := r.PathValue("recordID")
                res := r.PathValue("resultID")
                s.logger.Debugf("recordID: %s resultID: %s name: %s md: %+v", recID, res, parent, r.Header)
                if err := s.auth.Check(ctx, parent, auth.ResourceLogs, auth.PermissionGet); err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err)
                        http.Error(w, "Not Authorized", http.StatusUnauthorized)
                        return
                }</span>
                <span class="cov0" title="0">rec, err := getRecord(s.db, parent, res, recID)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">if rec == nil </span><span class="cov0" title="0">{
                        s.logger.Errorf("records not found: parent: %s, result: %s, recID: %s", parent, res, recID)
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">err = s.getLog(s, w, parent, rec)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error(err)
                        http.Error(w, "Failed to stream logs err: "+err.Error(), http.StatusInternalServerError)
                        return
                }</span>
        })
}

func getRecord(txn *gorm.DB, parent, result, name string) (*db.Record, error) <span class="cov8" title="1">{
        store := &amp;db.Record{}
        q := txn.
                Where(&amp;db.Record{Parent: parent, ResultName: result, Name: name}).
                First(store)
        if err := dbErrors.Wrap(q.Error); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return store, nil</span>
}

func getLogRecord(txn *gorm.DB, parent, resultID, name string) (*db.Record, error) <span class="cov0" title="0">{
        store := &amp;db.Record{}
        q := txn.
                Where(&amp;db.Record{Parent: parent, ResultID: resultID}).
                Where("data -&gt; 'spec' -&gt; 'resource' -&gt;&gt; 'uid' =  ?", name).
                First(store)
        if err := dbErrors.Wrap(q.Error); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return store, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package plugin

import (
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "net"
        "net/http"
        "strings"
        "time"

        "github.com/tektoncd/results/pkg/api/server/config"
        "go.uber.org/zap"

        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth"
        "golang.org/x/oauth2"
        "gorm.io/gorm"

        pb3 "github.com/tektoncd/results/proto/v1alpha3/results_go_proto"

        "k8s.io/client-go/transport"
)

// LogServer is the server for the log plugin server
type LogServer struct {
        pb3.UnimplementedLogsServer

        IsLogPluginEnabled bool
        staticLabels       string

        config *config.Config
        logger *zap.SugaredLogger
        auth   auth.Checker
        db     *gorm.DB
        client *http.Client

        forwarderDelayDuration time.Duration

        queryLimit uint

        queryParams map[string]string

        // TODO: In future add support for non Oauth support
        tokenSource oauth2.TokenSource

        getLog getLog
}

// NewLogServer returns a plugin log server
func NewLogServer(config *config.Config, logger *zap.SugaredLogger, auth auth.Checker, db *gorm.DB) (*LogServer, error) <span class="cov8" title="1">{
        s := &amp;LogServer{
                config: config,
                logger: logger,
                auth:   auth,
                db:     db,
        }

        s.logger.Debugf("LOGS_TYPE: %s", strings.ToLower(s.config.LOGS_TYPE))
        // If the logs type is not plugin supported,
        //  we don't need to set up the LogPluginServer
        if !s.setLogPlugin() </span><span class="cov0" title="0">{
                return s, nil
        }</span>

        <span class="cov8" title="1">s.logger.Info("Setting up LogPluginServer")

        if s.config.LOGGING_PLUGIN_STATIC_LABELS != "" </span><span class="cov8" title="1">{
                labels := strings.Split(s.config.LOGGING_PLUGIN_STATIC_LABELS, ",")
                for _, v := range labels </span><span class="cov8" title="1">{
                        label := strings.Split(v, "=")
                        if len(label) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("incorrect format for LOGGING_STATIC_LABELS: %s", v)
                        }</span>
                        <span class="cov8" title="1">s.staticLabels += label[0] + `="` + label[1] + `",`</span>
                }
        }

        <span class="cov8" title="1">s.client = &amp;http.Client{
                Transport: &amp;http.Transport{
                        Dial: (&amp;net.Dialer{
                                Timeout:   5 * time.Minute,
                                KeepAlive: 10 * time.Minute,
                        }).Dial,
                        TLSHandshakeTimeout:   10 * time.Second,
                        ResponseHeaderTimeout: 10 * time.Second,
                        ExpectContinueTimeout: 1 * time.Second,
                },
        }

        if s.config.LOGGING_PLUGIN_CA_CERT != "" </span><span class="cov0" title="0">{
                caCertPool := x509.NewCertPool()
                caCertPool.AppendCertsFromPEM([]byte(s.config.LOGGING_PLUGIN_CA_CERT))
                // #nosec G402
                s.client.Transport.(*http.Transport).TLSClientConfig = &amp;tls.Config{
                        RootCAs: caCertPool, //nolint:gosec  // needed when we have our own CA
                }
        }</span> else<span class="cov8" title="1"> if s.config.LOGGING_PLUGIN_TLS_VERIFICATION_DISABLE </span><span class="cov8" title="1">{
                s.client.Transport.(*http.Transport).TLSClientConfig = &amp;tls.Config{
                        InsecureSkipVerify: true, //nolint:gosec  // needed for skipping tls verification
                }
        }</span>

        <span class="cov8" title="1">s.forwarderDelayDuration = time.Duration(s.config.LOGGING_PLUGIN_FORWARDER_DELAY_DURATION) * time.Minute

        s.tokenSource = transport.NewCachedFileTokenSource(s.config.LOGGING_PLUGIN_TOKEN_PATH)
        s.queryLimit = s.config.LOGGING_PLUGIN_QUERY_LIMIT

        s.queryParams = map[string]string{}
        if s.config.LOGGING_PLUGIN_QUERY_PARAMS != "" </span><span class="cov8" title="1">{
                for _, v := range strings.Split(s.config.LOGGING_PLUGIN_QUERY_PARAMS, "&amp;") </span><span class="cov8" title="1">{
                        queryParam := strings.Split(v, "=")
                        if len(queryParam) != 2 </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("incorrect format for LOGGING_PLUGIN_QUERY_PARAMS: %s", v)
                        }</span>
                        <span class="cov8" title="1">s.queryParams[queryParam[0]] = queryParam[1]</span>
                }
        }

        <span class="cov8" title="1">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package record provides utilities for manipulating and validating Records.
package record

import (
        "encoding/json"
        "fmt"
        "regexp"

        "github.com/tektoncd/results/pkg/api/server/config"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/log"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"

        "github.com/google/cel-go/cel"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        resultscel "github.com/tektoncd/results/pkg/api/server/cel"
        "github.com/tektoncd/results/pkg/api/server/db"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        typeSize = 768
)

var (
        // NameRegex matches valid name specs for a Result.
        NameRegex = regexp.MustCompile("(^[a-z0-9_-]{1,63})/results/([a-z0-9_-]{1,63})/records/([a-z0-9_-]{1,63}$)")
)

// ParseName splits a full Result name into its individual (parent, result, name)
// components.
func ParseName(raw string) (parent, result, name string, err error) <span class="cov8" title="1">{
        s := NameRegex.FindStringSubmatch(raw)
        if len(s) != 4 </span><span class="cov8" title="1">{
                return "", "", "", status.Errorf(codes.InvalidArgument, "name must match %s", NameRegex.String())
        }</span>
        <span class="cov8" title="1">return s[1], s[2], s[3], nil</span>
}

// FormatName takes in a parent ("a/results/b") and record name ("c") and
// returns the full resource name ("a/results/b/records/c").
func FormatName(parent, name string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/records/%s", parent, name)
}</span>

// ToStorage converts an API Record into its corresponding database storage
// equivalent.
// parent,result,name should be the name parts (e.g. not containing "/results/" or "/records/").
func ToStorage(parent, resultName, resultID, name string, r *pb.Record, config *config.Config) (*db.Record, error) <span class="cov8" title="1">{
        if err := validateData(r.GetData()); err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>

        <span class="cov8" title="1">id := r.GetUid()
        if id == "" </span><span class="cov8" title="1">{
                id = r.GetId()
        }</span>

        <span class="cov8" title="1">dbr := &amp;db.Record{
                Parent:     parent,
                ResultName: resultName,
                ResultID:   resultID,

                ID:   id,
                Name: name,

                Type: r.GetData().GetType(),
                Data: r.GetData().GetValue(),

                Etag: r.Etag,
        }

        if r.CreatedTime.IsValid() </span><span class="cov8" title="1">{
                dbr.CreatedTime = r.CreatedTime.AsTime()
        }</span>
        <span class="cov8" title="1">if r.CreateTime.IsValid() </span><span class="cov8" title="1">{
                dbr.CreatedTime = r.CreateTime.AsTime()
        }</span>
        <span class="cov8" title="1">if r.UpdatedTime.IsValid() </span><span class="cov8" title="1">{
                dbr.UpdatedTime = r.UpdatedTime.AsTime()
        }</span>
        <span class="cov8" title="1">if r.UpdateTime.IsValid() </span><span class="cov8" title="1">{
                dbr.UpdatedTime = r.UpdateTime.AsTime()
        }</span>
        <span class="cov8" title="1">if dbr.Type == v1alpha3.LogRecordType || dbr.Type == v1alpha3.LogRecordTypeV2 </span><span class="cov0" title="0">{
                data, err := log.ToStorage(r, config)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">dbr.Data = data</span>
        }

        <span class="cov8" title="1">return dbr, nil</span>
}

// ToAPI converts a database storage Record into its corresponding API
// equivalent.
func ToAPI(r *db.Record) *pb.Record <span class="cov8" title="1">{
        out := &amp;pb.Record{
                Name: fmt.Sprintf("%s/results/%s/records/%s", r.Parent, r.ResultName, r.Name),
                Id:   r.ID,
                Uid:  r.ID,
                Etag: r.Etag,
        }

        if !r.CreatedTime.IsZero() </span><span class="cov8" title="1">{
                out.CreatedTime = timestamppb.New(r.CreatedTime)
                out.CreateTime = timestamppb.New(r.CreatedTime)
        }</span>
        <span class="cov8" title="1">if !r.UpdatedTime.IsZero() </span><span class="cov0" title="0">{
                out.UpdatedTime = timestamppb.New(r.UpdatedTime)
                out.UpdateTime = timestamppb.New(r.UpdatedTime)
        }</span>

        <span class="cov8" title="1">if r.Data != nil </span><span class="cov8" title="1">{
                out.Data = &amp;pb.Any{
                        Type:  r.Type,
                        Value: r.Data,
                }
        }</span>

        <span class="cov8" title="1">return out</span>
}

// Match determines whether the given CEL filter matches the result.
func Match(r *pb.Record, prg cel.Program) (bool, error) <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">var m map[string]any
        if d := r.GetData().GetValue(); d != nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal(r.GetData().GetValue(), &amp;m); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
        }

        <span class="cov0" title="0">return resultscel.Match(prg, map[string]any{
                "name":      r.GetName(),
                "data_type": r.GetData().GetType(),
                "data":      m,
        })</span>
}

// UpdateEtag updates the etag field of a record according to its content.
// The record should at least have its `Id` and `UpdatedTime` fields set.
func UpdateEtag(r *db.Record) error <span class="cov0" title="0">{
        if r.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("the ID field must be set")
        }</span>
        <span class="cov0" title="0">if r.UpdatedTime.IsZero() </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, "the UpdatedTime field must be set")
        }</span>
        <span class="cov0" title="0">r.Etag = fmt.Sprintf("%s-%v", r.ID, r.UpdatedTime.UnixNano())
        return nil</span>
}

func validateData(m *pb.Any) error <span class="cov8" title="1">{
        if err := ValidateType(m.GetType()); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if m == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">switch m.GetType() </span>{
        case "pipeline.tekton.dev/TaskRun":<span class="cov0" title="0">
                return json.Unmarshal(m.GetValue(), &amp;v1.TaskRun{})</span>
        case "pipeline.tekton.dev/PipelineRun":<span class="cov0" title="0">
                return json.Unmarshal(m.GetValue(), &amp;v1.PipelineRun{})</span>
        case "results.tekton.dev/v1alpha3.Log":<span class="cov0" title="0">
                return json.Unmarshal(m.GetValue(), &amp;v1alpha3.Log{})</span>
        default:<span class="cov8" title="1">
                // If it's not a well known type, just check that the message is a valid JSON document.
                return json.Unmarshal(m.GetValue(), &amp;json.RawMessage{})</span>
        }
}

// ValidateType validates line t to ensure it can be stored in the database.
func ValidateType(t string) error <span class="cov8" title="1">{
        // Certain DBs like sqlite will massage CHAR types to TEXT, so enforce
        // this in our code for consistency.
        if len(t) &gt; typeSize </span><span class="cov8" title="1">{
                return status.Errorf(codes.InvalidArgument, "type must not exceed %d characters", typeSize)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
        "context"

        "github.com/golang/protobuf/ptypes/empty"
        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/checker/decls"
        "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/api/server/db/errors"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/result"
        "github.com/tektoncd/results/pkg/internal/protoutil"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"
        "gorm.io/gorm"
)

// CreateRecord creates a new record in the database.
func (s *Server) CreateRecord(ctx context.Context, req *pb.CreateRecordRequest) (*pb.Record, error) <span class="cov8" title="1">{
        r := req.GetRecord()

        // Validate the incoming request
        parent, resultName, name, err := record.ParseName(r.GetName())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if req.GetParent() != result.FormatName(parent, resultName) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "requested parent does not match resource name")
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceRecords, auth.PermissionCreate); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Look up the result ID from the name. This does not have to happen
        // transactionally with the insert since name&lt;-&gt;ID mappings are immutable,
        // and if the parent result is deleted mid-request, the insert should
        // fail due to foreign key constraints.
        <span class="cov8" title="1">resultID, err := s.getResultID(ctx, parent, resultName)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Populate Result with server provided fields.
        <span class="cov8" title="1">protoutil.ClearOutputOnly(r)
        r.Id = uid()
        r.Uid = r.Id
        ts := timestamppb.New(clock.Now())
        r.CreatedTime = ts
        r.CreateTime = ts
        r.UpdatedTime = ts
        r.UpdateTime = ts

        store, err := record.ToStorage(parent, resultName, resultID, name, req.GetRecord(), s.config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := record.UpdateEtag(store); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">q := s.db.WithContext(ctx).
                Model(store).
                Create(store).Error
        if err := errors.Wrap(q); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return record.ToAPI(store), nil</span>
}

// resultID is a utility struct to extract partial Result data representing
// Result name &lt;-&gt; ID mappings.
type resultID struct {
        Name string
        ID   string
}

func (s *Server) getResultIDImpl(ctx context.Context, parent, result string) (string, error) <span class="cov8" title="1">{
        id := new(resultID)
        q := s.db.WithContext(ctx).
                Model(&amp;db.Result{}).
                Where(&amp;db.Result{Parent: parent, Name: result}).
                First(id)
        if err := errors.Wrap(q.Error); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return id.ID, nil</span>
}

// GetRecord returns a single Record.
func (s *Server) GetRecord(ctx context.Context, req *pb.GetRecordRequest) (*pb.Record, error) <span class="cov8" title="1">{
        parent, result, name, err := record.ParseName(req.GetName())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceRecords, auth.PermissionGet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r, err := getRecord(s.db.WithContext(ctx), parent, result, name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return record.ToAPI(r), nil</span>
}

func getRecord(txn *gorm.DB, parent, result, name string) (*db.Record, error) <span class="cov8" title="1">{
        // Note: set the Parent, ResultName and Name fields in the model used to
        // query the database to take advantage of the records_by_name composite
        // index. Although the Name is an unique value as well, leveraging the
        // index speeds up the query significantly. See
        // https://github.com/tektoncd/results/issues/336.
        store := &amp;db.Record{}
        q := txn.
                Where(&amp;db.Record{Parent: parent, ResultName: result, Name: name}).
                First(store)
        if err := errors.Wrap(q.Error); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return store, nil</span>
}

// ListRecords returns list records from the database.
func (s *Server) ListRecords(ctx context.Context, req *pb.ListRecordsRequest) (*pb.ListRecordsResponse, error) <span class="cov8" title="1">{
        if req.GetParent() == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "parent missing")
        }</span>

        // Authentication
        <span class="cov8" title="1">parent, resultName, err := result.ParseName(req.GetParent())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceRecords, auth.PermissionList); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">recordsLister, err := lister.OfRecords(s.recordsEnv, parent, resultName, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">records, nextPageToken, err := recordsLister.List(ctx, s.db)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pb.ListRecordsResponse{
                Records:       records,
                NextPageToken: nextPageToken,
        }, nil</span>
}

// UpdateRecord updates a record in the database.
func (s *Server) UpdateRecord(ctx context.Context, req *pb.UpdateRecordRequest) (*pb.Record, error) <span class="cov8" title="1">{
        in := req.GetRecord()

        parent, result, name, err := record.ParseName(in.GetName())
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceRecords, auth.PermissionUpdate); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">protoutil.ClearOutputOnly(in)

        var out *pb.Record
        err = s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                r, err := getRecord(tx, parent, result, name)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // If the user provided the Etag field, then make sure the value of this field matches what saved in the database.
                // See https://google.aip.dev/154 for more information.
                <span class="cov8" title="1">if req.GetEtag() != "" &amp;&amp; req.GetEtag() != r.Etag </span><span class="cov8" title="1">{
                        return status.Error(codes.FailedPrecondition, "the etag mismatches")
                }</span>

                // Merge existing data with user request.
                <span class="cov8" title="1">pb := record.ToAPI(r)
                // TODO: field mask support.
                proto.Merge(pb, in)

                updateTime := timestamppb.New(clock.Now())
                pb.UpdatedTime = updateTime
                pb.UpdateTime = updateTime

                // Convert back to storage and store.
                s, err := record.ToStorage(r.Parent, r.ResultName, r.ResultID, r.Name, pb, s.config)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := record.UpdateEtag(s); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := errors.Wrap(tx.Save(s).Error); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">pb.Etag = s.Etag
                out = pb
                return nil</span>
        })
        <span class="cov8" title="1">return out, err</span>
}

// DeleteRecord deletes a given record.
func (s *Server) DeleteRecord(ctx context.Context, req *pb.DeleteRecordRequest) (*empty.Empty, error) <span class="cov8" title="1">{
        parent, result, name, err := record.ParseName(req.GetName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceRecords, auth.PermissionDelete); err != nil </span><span class="cov0" title="0">{
                return &amp;empty.Empty{}, err
        }</span>

        // First get the current record. This ensures that we return NOT_FOUND if
        // the entry is already deleted.
        // This does not need to be done in the same transaction as to delete,
        // since the identifiers are immutable.
        <span class="cov8" title="1">r, err := getRecord(s.db, parent, result, name)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;empty.Empty{}, err
        }</span>
        <span class="cov8" title="1">return &amp;empty.Empty{}, errors.Wrap(s.db.WithContext(ctx).Delete(&amp;db.Record{}, r).Error)</span>
}

// recordCEL defines the CEL environment for querying Record data.
// Fields are broken up explicitly in order to support dynamic handling of the
// data field as a key-value document.
func recordCEL() (*cel.Env, error) <span class="cov8" title="1">{
        return cel.NewEnv(
                cel.Types(&amp;pb.Record{}),
                cel.Declarations(decls.NewVar("name", decls.String)),
                cel.Declarations(decls.NewVar("data_type", decls.String)),
                cel.Declarations(decls.NewVar("data", decls.Dyn)),
        )
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package result provides utilities for manipulating and validating Results.
package result

import (
        "fmt"
        "regexp"
        "time"

        "github.com/google/cel-go/cel"
        resultscel "github.com/tektoncd/results/pkg/api/server/cel"
        "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
        "knative.dev/pkg/ptr"
)

var (
        // NameRegex matches valid name specs for a Result.
        NameRegex = regexp.MustCompile("(^[a-z0-9_-]{1,63})/results/([a-z0-9_-]{1,63}$)")
)

// ParseName splits a full Result name into its individual (parent, name)
// components.
func ParseName(raw string) (parent, name string, err error) <span class="cov8" title="1">{
        s := NameRegex.FindStringSubmatch(raw)
        if len(s) != 3 </span><span class="cov8" title="1">{
                return "", "", status.Errorf(codes.InvalidArgument, "name must match %s", NameRegex.String())
        }</span>
        <span class="cov8" title="1">return s[1], s[2], nil</span>
}

// FormatName takes in a parent ("a") and result name ("b") and
// returns the full resource name ("a/results/b").
func FormatName(parent, name string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/results/%s", parent, name)
}</span>

// ToStorage converts an API Result into its corresponding database storage
// equivalent.
// parent,name should be the name parts (e.g. not containing "/results/").
func ToStorage(r *pb.Result) (*db.Result, error) <span class="cov8" title="1">{
        parent, name, err := ParseName(r.GetName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">id := r.GetUid()
        if id == "" </span><span class="cov8" title="1">{
                id = r.GetId()
        }</span>
        <span class="cov8" title="1">result := &amp;db.Result{
                Parent:      parent,
                ID:          id,
                Name:        name,
                Annotations: r.Annotations,
                Etag:        r.Etag,
        }

        if r.CreatedTime.IsValid() </span><span class="cov8" title="1">{
                result.CreatedTime = r.CreatedTime.AsTime()
        }</span>
        <span class="cov8" title="1">if r.CreateTime.IsValid() </span><span class="cov8" title="1">{
                result.CreatedTime = r.CreateTime.AsTime()
        }</span>
        <span class="cov8" title="1">if r.UpdatedTime.IsValid() </span><span class="cov8" title="1">{
                result.UpdatedTime = r.UpdatedTime.AsTime()
        }</span>
        <span class="cov8" title="1">if r.UpdateTime.IsValid() </span><span class="cov8" title="1">{
                result.UpdatedTime = r.UpdateTime.AsTime()
        }</span>

        <span class="cov8" title="1">if s := r.GetSummary(); s != nil </span><span class="cov8" title="1">{
                if s.GetRecord() == "" || s.GetType() == "" </span><span class="cov8" title="1">{
                        return nil, status.Errorf(codes.InvalidArgument, "record and type fields required for RecordSummary")
                }</span>
                <span class="cov8" title="1">if !record.NameRegex.MatchString(s.GetRecord()) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.InvalidArgument, "invalid record format")
                }</span>
                <span class="cov8" title="1">if err := record.ValidateType(s.GetType()); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">summary := db.RecordSummary{
                        Record:      s.GetRecord(),
                        Type:        s.GetType(),
                        Status:      int32(s.GetStatus()),
                        Annotations: s.Annotations,
                }
                if s.StartTime.IsValid() </span><span class="cov8" title="1">{
                        summary.StartTime = ptr.Time(s.StartTime.AsTime())
                }</span>
                <span class="cov8" title="1">if s.EndTime.IsValid() </span><span class="cov8" title="1">{
                        summary.EndTime = ptr.Time(s.EndTime.AsTime())
                }</span>
                <span class="cov8" title="1">result.Summary = summary</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// ToAPI converts a database storage Result into its corresponding API
// equivalent.
func ToAPI(r *db.Result) *pb.Result <span class="cov8" title="1">{
        var summary *pb.RecordSummary
        if r.Summary.Record != "" </span><span class="cov0" title="0">{
                summary = &amp;pb.RecordSummary{
                        Record:      r.Summary.Record,
                        Type:        r.Summary.Type,
                        StartTime:   newTS(r.Summary.StartTime),
                        EndTime:     newTS(r.Summary.EndTime),
                        Status:      pb.RecordSummary_Status(r.Summary.Status),
                        Annotations: r.Summary.Annotations,
                }
        }</span>

        <span class="cov8" title="1">return &amp;pb.Result{
                Name:        FormatName(r.Parent, r.Name),
                Id:          r.ID,
                Uid:         r.ID,
                CreatedTime: timestamppb.New(r.CreatedTime),
                CreateTime:  timestamppb.New(r.CreatedTime),
                UpdatedTime: timestamppb.New(r.UpdatedTime),
                UpdateTime:  timestamppb.New(r.UpdatedTime),
                Annotations: r.Annotations,
                Etag:        r.Etag,
                Summary:     summary,
        }</span>
}

func newTS(t *time.Time) *timestamppb.Timestamp <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return timestamppb.New(*t)</span>
}

// Match determines whether the given CEL filter matches the result.
func Match(r *pb.Result, prg cel.Program) (bool, error) <span class="cov8" title="1">{
        if r == nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return resultscel.Match(prg, map[string]any{
                "result": r,
        })</span>
}

// UpdateEtag updates the etag field of a result according to its content.
// The result should at least have its `Id` and `UpdatedTime` fields set.
func UpdateEtag(r *db.Result) error <span class="cov0" title="0">{
        if r.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("the ID field must be set")
        }</span>
        <span class="cov0" title="0">if r.UpdatedTime.IsZero() </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, "the UpdatedTime field must be set")
        }</span>
        <span class="cov0" title="0">r.Etag = fmt.Sprintf("%s-%v", r.ID, r.UpdatedTime.UnixNano())
        return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
        "context"
        "log"

        "github.com/golang/protobuf/ptypes/empty"
        "gorm.io/gorm"

        "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/api/server/db/errors"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/result"
        "github.com/tektoncd/results/pkg/internal/protoutil"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// CreateResult creates a new result in the database.
func (s *Server) CreateResult(ctx context.Context, req *pb.CreateResultRequest) (*pb.Result, error) <span class="cov8" title="1">{
        r := req.GetResult()

        // Validate the incoming request
        parent, _, err := result.ParseName(r.GetName())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov8" title="1">if req.GetParent() != parent </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "requested parent does not match resource name")
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceResults, auth.PermissionCreate); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Populate Result with server provided fields.
        <span class="cov8" title="1">protoutil.ClearOutputOnly(r)
        id := uid()
        r.Id = id
        r.Uid = id
        ts := timestamppb.New(clock.Now())
        r.CreatedTime = ts
        r.CreateTime = ts
        r.UpdatedTime = ts
        r.UpdateTime = ts

        store, err := result.ToStorage(r)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := result.UpdateEtag(store); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := errors.Wrap(s.db.WithContext(ctx).Create(store).Error); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result.ToAPI(store), nil</span>
}

// GetResult returns a single Result.
func (s *Server) GetResult(ctx context.Context, req *pb.GetResultRequest) (*pb.Result, error) <span class="cov8" title="1">{
        parent, name, err := result.ParseName(req.GetName())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceResults, auth.PermissionGet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">store, err := getResultByParentName(s.db, parent, name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return result.ToAPI(store), nil</span>
}

// UpdateResult updates a Result in the database.
func (s *Server) UpdateResult(ctx context.Context, req *pb.UpdateResultRequest) (*pb.Result, error) <span class="cov8" title="1">{
        // Retrieve result from database by name
        parent, name, err := result.ParseName(req.GetName())
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, err.Error())
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceResults, auth.PermissionUpdate); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var out *pb.Result
        err = s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov8" title="1">{
                prev, err := getResultByParentName(tx, parent, name)
                if err != nil </span><span class="cov8" title="1">{
                        return status.Errorf(codes.NotFound, "failed to find a result: %v", err)
                }</span>

                // If the user provided the Etag field, then make sure the value of this field matches what saved in the database.
                // See https://google.aip.dev/154 for more information.
                <span class="cov8" title="1">if req.GetEtag() != "" &amp;&amp; req.GetEtag() != prev.Etag </span><span class="cov8" title="1">{
                        return status.Error(codes.FailedPrecondition, "the etag mismatches")
                }</span>

                <span class="cov8" title="1">newpb := result.ToAPI(prev)
                reqpb := req.GetResult()
                protoutil.ClearOutputOnly(reqpb)
                // Merge requested Result with previous Result to apply updates,
                // making sure to filter out any OUTPUT_ONLY fields, and only
                // updatable fields.
                // We can't use proto.Merge, since empty fields in the req should take
                // precedence, so set each updatable field here.
                newpb.Annotations = reqpb.GetAnnotations()
                newpb.Summary = reqpb.GetSummary()
                toDB, err := result.ToStorage(newpb)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Set server-side provided fields
                <span class="cov8" title="1">toDB.UpdatedTime = clock.Now()
                if err := result.UpdateEtag(toDB); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Write result back to database.
                <span class="cov8" title="1">if err = errors.Wrap(tx.Save(toDB).Error); err != nil </span><span class="cov0" title="0">{
                        log.Printf("failed to save result into database: %v", err)
                        return err
                }</span>
                <span class="cov8" title="1">out = result.ToAPI(toDB)

                return nil</span>
        })
        <span class="cov8" title="1">return out, err</span>
}

// DeleteResult deletes a given result.
func (s *Server) DeleteResult(ctx context.Context, req *pb.DeleteResultRequest) (*empty.Empty, error) <span class="cov8" title="1">{
        parent, name, err := result.ParseName(req.GetName())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := s.auth.Check(ctx, parent, auth.ResourceResults, auth.PermissionDelete); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // First get the current result. This ensures that we return NOT_FOUND if
        // the entry is already deleted.
        // This does not need to be done in the same transaction as to delete,
        // since the identifiers are immutable.
        <span class="cov8" title="1">r := &amp;db.Result{}
        get := s.db.WithContext(ctx).
                Where(&amp;db.Result{Parent: parent, Name: name}).
                First(r)
        if err := errors.Wrap(get.Error); err != nil </span><span class="cov8" title="1">{
                return &amp;empty.Empty{}, err
        }</span>

        // Delete the result.
        <span class="cov8" title="1">del := s.db.WithContext(ctx).Delete(&amp;db.Result{}, r)
        return &amp;empty.Empty{}, errors.Wrap(del.Error)</span>
}

// ListResults returns list results from the database.
func (s *Server) ListResults(ctx context.Context, req *pb.ListResultsRequest) (*pb.ListResultsResponse, error) <span class="cov8" title="1">{
        if req.GetParent() == "" </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "parent missing")
        }</span>

        <span class="cov8" title="1">if err := s.auth.Check(ctx, req.GetParent(), auth.ResourceResults, auth.PermissionList); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">resultsLister, err := lister.OfResults(s.resultsEnv, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">results, nextPageToken, err := resultsLister.List(ctx, s.db)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;pb.ListResultsResponse{
                Results:       results,
                NextPageToken: nextPageToken,
        }, nil</span>
}

func getResultByParentName(gdb *gorm.DB, parent, name string) (*db.Result, error) <span class="cov8" title="1">{
        r := &amp;db.Result{}
        q := gdb.
                Where(&amp;db.Result{Parent: parent, Name: name}).
                First(r)
        if err := errors.Wrap(q.Error); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package server

import (
        "context"
        "fmt"

        "github.com/google/cel-go/cel"
        "github.com/tektoncd/results/pkg/api/server/config"
        "go.uber.org/zap"

        "github.com/google/uuid"
        cw "github.com/jonboulle/clockwork"
        resultscel "github.com/tektoncd/results/pkg/api/server/cel"
        model "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/plugin"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "gorm.io/gorm"
)

var (
        uid = func() string <span class="cov0" title="0">{
                return uuid.New().String()
        }</span>
        clock cw.Clock = cw.NewRealClock()
)

type getResultID func(ctx context.Context, parent, result string) (string, error)

// Server with implementation of API server
type Server struct {
        pb.UnimplementedResultsServer
        pb.UnimplementedLogsServer
        config          *config.Config
        logger          *zap.SugaredLogger
        env             *cel.Env
        resultsEnv      *cel.Env
        recordsEnv      *cel.Env
        db              *gorm.DB
        auth            auth.Checker
        LogPluginServer *plugin.LogServer

        // testing.
        getResultID getResultID
}

// New set up environment for the api server
func New(config *config.Config, logger *zap.SugaredLogger, db *gorm.DB, opts ...Option) (*Server, error) <span class="cov8" title="1">{
        env, err := resultscel.NewEnv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create CEL environment: %w", err)
        }</span>
        // TODO: turn the func into a MustX that should panic on error.
        <span class="cov8" title="1">resultsEnv, err := resultscel.NewResultsEnv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">recordsEnv, err := resultscel.NewRecordsEnv()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">srv := &amp;Server{
                db:         db,
                env:        env,
                resultsEnv: resultsEnv,
                recordsEnv: recordsEnv,
                config:     config,
                logger:     logger,
                // Default open auth for easier testing.
                auth: auth.AllowAll{},
        }

        // Set default impls of overridable behavior
        srv.getResultID = srv.getResultIDImpl

        for _, o := range opts </span><span class="cov8" title="1">{
                o(srv)
        }</span>

        <span class="cov8" title="1">if config.DB_ENABLE_AUTO_MIGRATION </span><span class="cov8" title="1">{
                if err := db.AutoMigrate(&amp;model.Result{}, &amp;model.Record{}); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error automigrating DB: %w", err)
                }</span>
        }

        <span class="cov8" title="1">pluginServer, err := plugin.NewLogServer(srv.config, srv.logger, srv.auth, srv.db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log plugin server: %w", err)
        }</span>
        <span class="cov8" title="1">srv.LogPluginServer = pluginServer

        return srv, nil</span>
}

// Option is customization for server configuration.
type Option func(*Server)

// WithAuth is an option to enable auth checker for Server
func WithAuth(c auth.Checker) Option <span class="cov0" title="0">{
        return func(s *Server) </span><span class="cov0" title="0">{
                s.auth = c
        }</span>
}

func withGetResultID(f getResultID) Option <span class="cov8" title="1">{
        return func(s *Server) </span><span class="cov8" title="1">{
                s.getResultID = f
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package server

import (
        "context"

        "github.com/tektoncd/results/pkg/api/server/v1alpha2/auth"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/lister"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/result"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// GetRecordListSummary returns the summary and aggregation for a given list of records
func (s *Server) GetRecordListSummary(ctx context.Context, req *pb.RecordListSummaryRequest) (*pb.RecordListSummary, error) <span class="cov0" title="0">{
        if req.GetParent() == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "parent missing")
        }</span>

        <span class="cov0" title="0">parent, resultName, err := result.ParseName(req.GetParent())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.auth.Check(ctx, parent, auth.ResourceRecords, auth.PermissionGet); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">recordAggregator, err := lister.OfRecordList(s.recordsEnv, parent, resultName, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">agg, err := recordAggregator.Aggregate(ctx, s.db)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return agg, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package config

import (
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/metrics"
)

const (
        // metricsTaskrunLevel determines to what level to aggregate metrics
        // for taskrun
        metricsTaskrunLevelKey = "metrics.taskrun.level"

        // metricsPipelinerunLevel determines to what level to aggregate metrics
        // for pipelinerun
        metricsPipelinerunLevelKey = "metrics.pipelinerun.level"
        // metricsDurationTaskrunType determines what type of
        // metrics to use for aggregating duration for taskrun
        metricsDurationTaskrunType = "metrics.taskrun.duration-type"
        // metricsDurationPipelinerunType determines what type of
        // metrics to use for aggregating duration for pipelinerun
        metricsDurationPipelinerunType = "metrics.pipelinerun.duration-type"

        // DefaultTaskrunLevel determines to what level to aggregate metrics
        // when it isn't specified in configmap
        DefaultTaskrunLevel = TaskrunLevelAtTask
        // TaskrunLevelAtTask specify that aggregation will be done at task level
        TaskrunLevelAtTask = "task"
        // TaskrunLevelAtNS specify that aggregation will be done at namespace level
        TaskrunLevelAtNS = "namespace"
        // DefaultPipelinerunLevel determines to what level to aggregate metrics
        // when it isn't specified in configmap
        DefaultPipelinerunLevel = PipelinerunLevelAtPipeline
        // PipelinerunLevelAtPipeline specify that aggregation will be done at
        // pipeline level
        PipelinerunLevelAtPipeline = "pipeline"
        // PipelinerunLevelAtNS specify that aggregation will be done at
        // namespace level
        PipelinerunLevelAtNS = "namespace"

        // DefaultDurationTaskrunType determines what type
        // of metrics to use when we don't specify one in
        // configmap
        DefaultDurationTaskrunType = "histogram"
        // DurationTaskrunTypeHistogram specify that histogram
        // type metrics need to be used for Duration of Taskrun
        DurationTaskrunTypeHistogram = "histogram"
        // DurationTaskrunTypeLastValue specify that lastValue or
        // gauge type metrics need to be used for Duration of Taskrun
        DurationTaskrunTypeLastValue = "lastvalue"

        // DefaultDurationPipelinerunType determines what type
        // of metrics to use when we don't specify one in
        // configmap
        DefaultDurationPipelinerunType = "histogram"
        // DurationPipelinerunTypeHistogram specify that histogram
        // type metrics need to be used for Duration of Pipelinerun
        DurationPipelinerunTypeHistogram = "histogram"
        // DurationPipelinerunTypeLastValue specify that lastValue or
        // gauge type metrics need to be used for Duration of Pipelinerun
        DurationPipelinerunTypeLastValue = "lastvalue"
)

// Metrics holds the configurations for the metrics
type Metrics struct {
        TaskrunLevel            string
        PipelinerunLevel        string
        DurationTaskrunType     string
        DurationPipelinerunType string
}

// DeepCopy copying the receiver, creating a new Metrics.
// deepcopy-gen hasn't been introduced in results repo, so handcraft here for now
func (cfg *Metrics) DeepCopy() *Metrics <span class="cov8" title="1">{
        return &amp;Metrics{
                TaskrunLevel:            cfg.TaskrunLevel,
                PipelinerunLevel:        cfg.PipelinerunLevel,
                DurationTaskrunType:     cfg.DurationTaskrunType,
                DurationPipelinerunType: cfg.DurationPipelinerunType,
        }
}</span>

// GetMetricsConfigName returns the name of the configmap containing all
// customizations for the storage bucket.
func GetMetricsConfigName() string <span class="cov8" title="1">{
        return metrics.ConfigMapName()
}</span>

// Equals returns true if two Configs are identical
func (cfg *Metrics) Equals(other *Metrics) bool <span class="cov0" title="0">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if cfg == nil || other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return other.TaskrunLevel == cfg.TaskrunLevel &amp;&amp;
                other.PipelinerunLevel == cfg.PipelinerunLevel &amp;&amp;
                other.DurationTaskrunType == cfg.DurationTaskrunType &amp;&amp;
                other.DurationPipelinerunType == cfg.DurationPipelinerunType</span>
}

// newMetricsFromMap returns a Config given a map corresponding to a ConfigMap
func newMetricsFromMap(cfgMap map[string]string) (*Metrics, error) <span class="cov8" title="1">{
        tc := Metrics{
                TaskrunLevel:            DefaultTaskrunLevel,
                PipelinerunLevel:        DefaultPipelinerunLevel,
                DurationTaskrunType:     DefaultDurationTaskrunType,
                DurationPipelinerunType: DefaultDurationPipelinerunType,
        }

        if taskrunLevel, ok := cfgMap[metricsTaskrunLevelKey]; ok </span><span class="cov8" title="1">{
                tc.TaskrunLevel = taskrunLevel
        }</span>

        <span class="cov8" title="1">if pipelinerunLevel, ok := cfgMap[metricsPipelinerunLevelKey]; ok </span><span class="cov8" title="1">{
                tc.PipelinerunLevel = pipelinerunLevel
        }</span>
        <span class="cov8" title="1">if durationTaskrun, ok := cfgMap[metricsDurationTaskrunType]; ok </span><span class="cov8" title="1">{
                tc.DurationTaskrunType = durationTaskrun
        }</span>
        <span class="cov8" title="1">if durationPipelinerun, ok := cfgMap[metricsDurationPipelinerunType]; ok </span><span class="cov8" title="1">{
                tc.DurationPipelinerunType = durationPipelinerun
        }</span>
        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// NewMetricsFromConfigMap returns a Config for the given configmap
func NewMetricsFromConfigMap(config *corev1.ConfigMap) (*Metrics, error) <span class="cov8" title="1">{
        return newMetricsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package config

import (
        "fmt"
        "log"
        "os"
        "strconv"
        "strings"
        "time"

        "gopkg.in/yaml.v2"
        corev1 "k8s.io/api/core/v1"
)

const (
        runAt            = "runAt"
        maxRetention     = "maxRetention"
        defaultRetention = "defaultRetention"
        policiesKey      = "policies"
        retentionCMName  = "tekton-results-config-results-retention-policy"
        // DefaultRunAt is the default value for RunAt
        DefaultRunAt = "7 7 * * 7"
        // DefaultDefaultRetention is the default value for DefaultRetention
        DefaultDefaultRetention = time.Hour * 24 * 30
)

// ParseDuration parses a string into a time.Duration.
// It handles standard formats like "24h", "90m", as well as the "d" suffix for days.
// If no unit is specified, it defaults to days.
func ParseDuration(durationStr string) (time.Duration, error) <span class="cov8" title="1">{
        if strings.HasSuffix(durationStr, "d") </span><span class="cov8" title="1">{
                days, err := strconv.Atoi(strings.TrimSuffix(durationStr, "d"))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return time.Duration(days) * 24 * time.Hour, nil</span>
        }
        <span class="cov8" title="1">if days, err := strconv.Atoi(durationStr); err == nil </span><span class="cov8" title="1">{
                return time.Duration(days) * 24 * time.Hour, nil
        }</span>
        <span class="cov0" title="0">return time.ParseDuration(durationStr)</span>
}

// Policy defines a single retention policy rule.
type Policy struct {
        Name      string   `yaml:"name"`
        Selector  Selector `yaml:"selector"`
        Retention string   `yaml:"retention"`
}

// Selector defines the selection criteria for a policy.
type Selector struct {
        MatchNamespaces  []string            `yaml:"matchNamespaces"`
        MatchLabels      map[string][]string `yaml:"matchLabels"`
        MatchAnnotations map[string][]string `yaml:"matchAnnotations"`
        MatchStatuses    []string            `yaml:"matchStatuses"`
}

// RetentionPolicy holds the configurations for the Retention Policy of the DB
type RetentionPolicy struct {
        RunAt            string
        DefaultRetention time.Duration
        Policies         []Policy
}

// DeepCopy copying the receiver, creating a new RetentionPolicy.
// deepcopy-gen hasn't been introduced in results repo, so handcraft here for now
func (cfg *RetentionPolicy) DeepCopy() *RetentionPolicy <span class="cov0" title="0">{
        if cfg == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">newCfg := &amp;RetentionPolicy{
                RunAt:            cfg.RunAt,
                DefaultRetention: cfg.DefaultRetention,
        }
        if cfg.Policies != nil </span><span class="cov0" title="0">{
                newCfg.Policies = make([]Policy, len(cfg.Policies))
                for i, p := range cfg.Policies </span><span class="cov0" title="0">{
                        newCfg.Policies[i] = *p.DeepCopy()
                }</span>
        }
        <span class="cov0" title="0">return newCfg</span>
}

// DeepCopy returns a deep copy of the Policy.
func (p *Policy) DeepCopy() *Policy <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;Policy{
                Name:      p.Name,
                Selector:  *p.Selector.DeepCopy(),
                Retention: p.Retention,
        }</span>
}

// DeepCopy returns a deep copy of the Selector.
func (s *Selector) DeepCopy() *Selector <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := &amp;Selector{}
        if s.MatchNamespaces != nil </span><span class="cov0" title="0">{
                out.MatchNamespaces = append([]string(nil), s.MatchNamespaces...)
        }</span>
        <span class="cov0" title="0">if s.MatchStatuses != nil </span><span class="cov0" title="0">{
                out.MatchStatuses = append([]string(nil), s.MatchStatuses...)
        }</span>
        <span class="cov0" title="0">if s.MatchLabels != nil </span><span class="cov0" title="0">{
                out.MatchLabels = make(map[string][]string, len(s.MatchLabels))
                for k, v := range s.MatchLabels </span><span class="cov0" title="0">{
                        out.MatchLabels[k] = append([]string(nil), v...)
                }</span>
        }
        <span class="cov0" title="0">if s.MatchAnnotations != nil </span><span class="cov0" title="0">{
                out.MatchAnnotations = make(map[string][]string, len(s.MatchAnnotations))
                for k, v := range s.MatchAnnotations </span><span class="cov0" title="0">{
                        out.MatchAnnotations[k] = append([]string(nil), v...)
                }</span>
        }
        <span class="cov0" title="0">return out</span>
}

// Equals returns true if two Configs are identical
func (cfg *RetentionPolicy) Equals(other *RetentionPolicy) bool <span class="cov0" title="0">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if cfg == nil || other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return other.RunAt == cfg.RunAt &amp;&amp;
                other.DefaultRetention == cfg.DefaultRetention</span>
}

func newRetentionPolicyFromMap(cfgMap map[string]string) (*RetentionPolicy, error) <span class="cov8" title="1">{
        rp := RetentionPolicy{
                RunAt:            DefaultRunAt,
                DefaultRetention: DefaultDefaultRetention,
        }

        if schedule, ok := cfgMap[runAt]; ok </span><span class="cov0" title="0">{
                rp.RunAt = schedule
        }</span>

        <span class="cov8" title="1">if duration, ok := cfgMap[defaultRetention]; ok </span><span class="cov8" title="1">{
                v, err := ParseDuration(duration)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("incorrect configuration for defaultRetention: %w", err)
                }</span>
                <span class="cov8" title="1">rp.DefaultRetention = v</span>
        } else<span class="cov8" title="1"> if duration, ok := cfgMap[maxRetention]; ok </span><span class="cov8" title="1">{
                log.Println("WARNING: configuration key 'maxRetention' is deprecated; please use 'defaultRetention' instead.")
                v, err := ParseDuration(duration)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("incorrect configuration for maxRetention: %w", err)
                }</span>
                <span class="cov8" title="1">rp.DefaultRetention = v</span>
        }

        <span class="cov8" title="1">if policiesYAML, ok := cfgMap[policiesKey]; ok </span><span class="cov8" title="1">{
                var policies []Policy
                if err := yaml.Unmarshal([]byte(policiesYAML), &amp;policies); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal policies: %w", err)
                }</span>
                <span class="cov8" title="1">rp.Policies = policies</span>
        }

        <span class="cov8" title="1">return &amp;rp, nil</span>
}

// NewRetentionPolicyFromConfigMap returns a Config for the given configmap
func NewRetentionPolicyFromConfigMap(config *corev1.ConfigMap) (*RetentionPolicy, error) <span class="cov8" title="1">{
        return newRetentionPolicyFromMap(config.Data)
}</span>

// GetRetentionPolicyConfigName returns the name of the configmap containing
// retention policy.
func GetRetentionPolicyConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_RETENTION_POLICY_NAME"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return retentionCMName</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package config

import (
        "context"

        "knative.dev/pkg/configmap"
)

type cfgKey struct{}

// Config holds the collection of configurations that we attach to contexts.
type Config struct {
        Metrics *Metrics
}

// FromContext extracts a Config from the provided context.
func FromContext(ctx context.Context) *Config <span class="cov8" title="1">{
        x, ok := ctx.Value(cfgKey{}).(*Config)
        if ok </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ToContext attaches the provided Config to the provided context, returning the
// new context with the Config attached.
func ToContext(ctx context.Context, c *Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, cfgKey{}, c)
}</span>

// Store is a typed wrapper around configmap.Untyped store to handle our configmaps.
type Store struct {
        *configmap.UntypedStore
}

// NewStore creates a new store of Configs and optionally calls functions when ConfigMaps are updated.
func NewStore(logger configmap.Logger, onAfterStore ...func(name string, value any)) *Store <span class="cov8" title="1">{
        store := &amp;Store{
                UntypedStore: configmap.NewUntypedStore(
                        "results",
                        logger,
                        configmap.Constructors{
                                GetMetricsConfigName():         NewMetricsFromConfigMap,
                                GetRetentionPolicyConfigName(): NewRetentionPolicyFromConfigMap,
                        },
                        onAfterStore...,
                ),
        }

        return store
}</span>

// ToContext attaches the current Config state to the provided context.
func (s *Store) ToContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        return ToContext(ctx, s.Load())
}</span>

// Load creates a Config from the current config state of the Store.
func (s *Store) Load() *Config <span class="cov8" title="1">{
        metrics := s.UntypedLoad(GetMetricsConfigName())
        if metrics == nil </span><span class="cov8" title="1">{
                metrics, _ = newMetricsFromMap(map[string]string{})
        }</span>
        <span class="cov8" title="1">return &amp;Config{
                Metrics: metrics.(*Metrics).DeepCopy(),
        }</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package v1alpha3

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
)

// EventListRecordType represents the API resource type for EventSet records.
const EventListRecordType = "results.tekton.dev/v1.EventList"

// LogRecordType represents the API resource type for Tekton log records.
const LogRecordType = "results.tekton.dev/v1alpha3.Log"

// LogRecordTypeV2 represents the API resource type for Tekton log records deprecated now.
const LogRecordTypeV2 = "results.tekton.dev/v1alpha2.Log"

// Log represents the API resource for Tekton results Log.
type Log struct {
        metav1.TypeMeta   `json:",inline"`
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec   LogSpec   `json:"spec"`
        Status LogStatus `json:"status,omitempty"`
}

// LogSpec represents the specification for the Tekton Log resource.
// It contains information about corresponding log resource.
type LogSpec struct {
        Resource Resource `json:"resource"`
        Type     LogType  `json:"type"`
}

// Resource represents information to identify a Kubernetes API resource.
// It should be used to match the corresponding log to this resource.
type Resource struct {
        Kind      string    `json:"kind,omitempty"`
        Namespace string    `json:"namespace"`
        Name      string    `json:"name"`
        UID       types.UID `json:"uid,omitempty"`
}

// LogType represents the log storage type.
// This information is useful to determine how the resource will be stored.
type LogType string

const (
        // FileLogType defines the log type for logs stored in the file system.
        FileLogType LogType = "File"

        // S3LogType defines the log type for logs stored in the S3 object storage or S3 compatible alternatives.
        S3LogType LogType = "S3"

        // GCSLogType defines the log type for logs stored in the GCS object storage or GCS compatible alternatives.
        GCSLogType LogType = "GCS"

        // LokiLogType defines the log type for logs stored in the Loki.
        LokiLogType LogType = "loki"

        // BlobLogType defines the log type for logs stored in the Blob - GCS, S3 compatible storage.
        BlobLogType LogType = "blob"

        // SplunkLogType defines the log type for logs stored in the Splunk.
        SplunkLogType LogType = "splunk"
)

// LogStatus defines the current status of the log resource.
type LogStatus struct {
        Path            string `json:"path,omitempty"`
        Size            int64  `json:"size"`
        IsStored        bool   `json:"isStored"`
        ErrorOnStoreMsg string `json:"errorOnStoreMsg"`
        IsRetryableErr  bool   `json:"isRetryableErr"`
}

// Default sets up default values for Log TypeMeta, such as API version and kind.
func (t *Log) Default() <span class="cov0" title="0">{
        t.TypeMeta.Kind = "Log"
        t.TypeMeta.APIVersion = "results.tekton.dev/v1alpha3"
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package client

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "path"
        "time"

        "k8s.io/client-go/transport"

        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

// Error represents an error that occurred during a client operation
type Error struct {
        Message string
        Code    int
}

func (e *Error) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("client error: %s (code: %d)", e.Message, e.Code)
}</span>

// NewError creates a new Error
func NewError(message string, code int) error <span class="cov0" title="0">{
        return &amp;Error{
                Message: message,
                Code:    code,
        }
}</span>

// Config for the HTTP client
type Config struct {
        URL       *url.URL
        Timeout   time.Duration
        Transport *transport.Config
}

// RESTClient handles HTTP communication with the server
type RESTClient struct {
        baseURL    *url.URL
        httpClient *http.Client
}

// NewRESTClient creates a new REST client.
func NewRESTClient(c *Config) (*RESTClient, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>
        <span class="cov8" title="1">if c.URL == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config.URL cannot be nil")
        }</span>
        <span class="cov8" title="1">if c.Transport == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("config.Transport cannot be nil")
        }</span>

        <span class="cov8" title="1">rt, err := transport.New(c.Transport)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;RESTClient{
                baseURL: c.URL,
                httpClient: &amp;http.Client{
                        Transport: rt,
                        Timeout:   c.Timeout,
                },
        }, nil</span>
}

// DoRequest performs an HTTP request and handles the response
func (c *RESTClient) DoRequest(ctx context.Context, method, url string, in proto.Message) (*Response, error) <span class="cov8" title="1">{
        var body io.Reader
        if in != nil </span><span class="cov0" title="0">{
                data, err := protojson.Marshal(in)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal request: %v", err)
                }</span>
                <span class="cov0" title="0">body = bytes.NewReader(data)</span>
        }

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, method, url, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %v", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send request: %v", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                return nil, NewError(string(body), resp.StatusCode)
        }</span>

        <span class="cov8" title="1">data, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %v", err)
        }</span>

        <span class="cov8" title="1">return NewResponse(data), nil</span>
}

// BuildURL constructs a URL with the given path and query parameters
func (c *RESTClient) BuildURL(p string, params url.Values) string <span class="cov8" title="1">{
        u := *c.baseURL
        u.Path = path.Join(u.Path, p)
        if params != nil </span><span class="cov8" title="1">{
                u.RawQuery = params.Encode()
        }</span>
        <span class="cov8" title="1">return u.String()</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package logs

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "strings"

        "github.com/tektoncd/results/pkg/cli/client"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
)

// Client is a client for interacting with logs.
type Client struct {
        *client.RESTClient
}

// NewClient creates a new logs client.
func NewClient(rc *client.RESTClient) *Client <span class="cov0" title="0">{
        return &amp;Client{RESTClient: rc}
}</span>

// GetLog gets a log by name.
func (c *Client) GetLog(ctx context.Context, req *pb.GetLogRequest) (io.Reader, error) <span class="cov0" title="0">{
        // Create a pipe to stream the logs
        pr, pw := io.Pipe()

        // Start a goroutine to handle the streaming response
        go func() </span><span class="cov0" title="0">{
                defer pw.Close()

                // Build the URL for the log request, replacing "records" with "logs" in the path
                url := c.BuildURL(fmt.Sprintf("parents/%s", strings.Replace(req.Name, "records", "logs", 1)), nil)

                // Make the request using the RESTClient's DoRequest method
                resp, err := c.DoRequest(ctx, http.MethodGet, url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        pw.CloseWithError(fmt.Errorf("failed to get log: %v", err))
                        return
                }</span>

                // Write the log data to the pipe
                <span class="cov0" title="0">if _, err := pw.Write(resp.Body()); err != nil </span><span class="cov0" title="0">{
                        pw.CloseWithError(fmt.Errorf("failed to write log data: %v", err))
                        return
                }</span>
        }()

        <span class="cov0" title="0">return pr, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package records

import (
        "context"
        "fmt"
        "net/http"
        "net/url"

        "github.com/tektoncd/results/pkg/cli/client"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
)

// RecordClient defines the interface for record-related operations
type RecordClient interface {
        ListRecords(ctx context.Context, in *pb.ListRecordsRequest, fields string) (*pb.ListRecordsResponse, error)
}

// recordClient implements the RecordClient interface
type recordClient struct {
        *client.RESTClient
}

// NewClient creates a new record client
func NewClient(rc *client.RESTClient) RecordClient <span class="cov8" title="1">{
        return &amp;recordClient{RESTClient: rc}
}</span>

// ListRecords makes request to get record list
func (c *recordClient) ListRecords(ctx context.Context, in *pb.ListRecordsRequest, fields string) (*pb.ListRecordsResponse, error) <span class="cov8" title="1">{
        out := &amp;pb.ListRecordsResponse{}

        // Add query parameters
        params := url.Values{}
        if in.Filter != "" </span><span class="cov0" title="0">{
                params.Set("filter", in.Filter)
        }</span>
        <span class="cov8" title="1">if in.OrderBy != "" </span><span class="cov0" title="0">{
                params.Set("order_by", in.OrderBy)
        }</span>
        <span class="cov8" title="1">if in.PageSize &gt; 0 </span><span class="cov8" title="1">{
                params.Set("page_size", fmt.Sprintf("%d", in.PageSize))
        }</span>
        <span class="cov8" title="1">if in.PageToken != "" </span><span class="cov0" title="0">{
                params.Set("page_token", in.PageToken)
        }</span>

        // Add fields parameter for partial response
        // (Only add fields parameter if provided)
        <span class="cov8" title="1">if fields != "" </span><span class="cov0" title="0">{
                params.Set("fields", fields)
        }</span>

        // Construct the URL with parents prefix
        <span class="cov8" title="1">buildURL := c.BuildURL(fmt.Sprintf("parents/%s/records", in.Parent), params)

        // Make the request
        resp, err := c.DoRequest(ctx, http.MethodGet, buildURL, in)

        if err != nil </span><span class="cov8" title="1">{
                return out, err
        }</span>

        // Unmarshall the response
        <span class="cov8" title="1">err = resp.ProtoUnmarshal(out)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>

        <span class="cov8" title="1">return out, err</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package client

import (
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

// Response represents a generic API response containing the raw body bytes.
type Response struct {
        body []byte
}

// Body returns the raw response body as a byte slice.
func (r *Response) Body() []byte <span class="cov0" title="0">{
        return r.body
}</span>

// ProtoUnmarshal unmarshals the response body into the provided proto.Message.
func (r *Response) ProtoUnmarshal(out proto.Message) error <span class="cov0" title="0">{
        return protojson.Unmarshal(r.body, out)
}</span>

// NewResponse creates a new Response with the given body bytes.
func NewResponse(body []byte) *Response <span class="cov8" title="1">{
        return &amp;Response{
                body: body,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package common

import (
        "fmt"
        "time"

        "github.com/jonboulle/clockwork"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// FormatAge returns a human-readable string representation of how long ago a timestamp occurred.
// The output format varies based on duration: seconds (&lt;1m), minutes (&lt;1h), hours (&lt;24h), or days.
func FormatAge(t *metav1.Time, c clockwork.Clock) string <span class="cov0" title="0">{
        if t == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">age := c.Since(t.Time)
        if age &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%ds ago", int(age.Seconds()))
        }</span>
        <span class="cov0" title="0">if age &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dm ago", int(age.Minutes()))
        }</span>
        <span class="cov0" title="0">if age &lt; 24*time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dh ago", int(age.Hours()))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dd ago", int(age.Hours()/24))</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package common

import (
        "fmt"
        "strings"
)

// ValidateLabels validates the format of the provided labels string.
// Labels should be in the format "key=value" or "key=value,key2=value2".
// Returns an error if the format is invalid.
func ValidateLabels(labels string) error <span class="cov0" title="0">{
        labelPairs := strings.Split(labels, ",")
        for _, pair := range labelPairs </span><span class="cov0" title="0">{
                parts := strings.Split(strings.TrimSpace(pair), "=")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid label format: %s. Expected format: key=value", pair)
                }</span>

                // Check for whitespace in key before trimming
                <span class="cov0" title="0">if strings.ContainsAny(parts[0], " \t") </span><span class="cov0" title="0">{
                        return fmt.Errorf("label key cannot contain whitespace: %s", parts[0])
                }</span>

                <span class="cov0" title="0">key := strings.TrimSpace(parts[0])
                value := strings.TrimSpace(parts[1])

                if key == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("label key cannot be empty in pair: %s", pair)
                }</span>
                <span class="cov0" title="0">if value == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("label value cannot be empty in pair: %s", pair)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// FilterOptions defines the interface for filter options
type FilterOptions interface {
        GetLabel() string
        GetResourceName() string
        GetPipelineRun() string
        GetResourceType() string
        GetUID() string
}

// BuildFilterString constructs the filter string for the ListRecordsRequest
func BuildFilterString(opts FilterOptions) string <span class="cov0" title="0">{
        const (
                contains = "data.metadata.%s.contains(\"%s\")"
                equal    = "data.metadata.%s[\"%s\"]==\"%s\""
                dataType = "data_type==\"%s\""
        )

        var filters []string

        switch opts.GetResourceType() </span>{
        case ResourceTypePipelineRun:<span class="cov0" title="0">
                // Add data type filter for both v1 and v1beta1 PipelineRuns
                filters = append(filters, fmt.Sprintf(`(%s || %s)`,
                        fmt.Sprintf(dataType, "tekton.dev/v1.PipelineRun"),
                        fmt.Sprintf(dataType, "tekton.dev/v1beta1.PipelineRun")))</span>
        case ResourceTypeTaskRun:<span class="cov0" title="0">
                // Add data type filter for both v1 and v1beta1 TaskRuns
                filters = append(filters, fmt.Sprintf(`(%s || %s)`,
                        fmt.Sprintf(dataType, "tekton.dev/v1.TaskRun"),
                        fmt.Sprintf(dataType, "tekton.dev/v1beta1.TaskRun")))</span>
        }

        // Handle label filters
        <span class="cov0" title="0">if opts.GetLabel() != "" </span><span class="cov0" title="0">{
                // Split by comma to get individual label pairs
                labelPairs := strings.Split(opts.GetLabel(), ",")
                for _, pair := range labelPairs </span><span class="cov0" title="0">{
                        // Split each pair by = to get key and value
                        parts := strings.Split(strings.TrimSpace(pair), "=")
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                filters = append(filters, fmt.Sprintf(equal, "labels", key, value))
                        }</span>
                }
        }

        // Handle pipeline name filter
        <span class="cov0" title="0">if opts.GetResourceName() != "" </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf(contains, "name", opts.GetResourceName()))
        }</span>

        // Handle UID filter
        <span class="cov0" title="0">if opts.GetUID() != "" </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf(contains, "uid", opts.GetUID()))
        }</span>

        // Add PipelineRun filter if provided
        <span class="cov0" title="0">if opts.GetPipelineRun() != "" </span><span class="cov0" title="0">{
                filters = append(filters, fmt.Sprintf(`data.metadata.labels['tekton.dev/pipelineRun'] == '%s'`, opts.GetPipelineRun()))
        }</span>

        <span class="cov0" title="0">return strings.Join(filters, " &amp;&amp; ")</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package common

import (
        "github.com/tektoncd/results/pkg/cli/client"
        "k8s.io/client-go/tools/clientcmd"
)

// ResultsParams holds configuration parameters for interacting with Kubernetes and API endpoints.
type ResultsParams struct {
        kubeConfigPath string
        kubeContext    string
        namespace      string
        host           string
        token          string
        apiPath        string
        skipTLSVerify  bool

        // Simple client storage
        restClient *client.RESTClient
}

var _ Params = (*ResultsParams)(nil)

// KubeConfigPath returns the path to the Kubernetes configuration file.
func (p *ResultsParams) KubeConfigPath() string <span class="cov0" title="0">{
        return p.kubeConfigPath
}</span>

// KubeContext returns the Kubernetes context name.
func (p *ResultsParams) KubeContext() string <span class="cov0" title="0">{
        return p.kubeContext
}</span>

// SetKubeConfigPath sets the path to the Kubernetes configuration file.
//
// Parameters:
//   - path: The file path to the Kubernetes configuration.
func (p *ResultsParams) SetKubeConfigPath(path string) <span class="cov0" title="0">{
        p.kubeConfigPath = path
}</span>

// SetKubeContext sets the Kubernetes context name.
//
// Parameters:
//   - context: The name of the Kubernetes context to use.
func (p *ResultsParams) SetKubeContext(context string) <span class="cov0" title="0">{
        p.kubeContext = context
}</span>

// SetNamespace sets the Kubernetes namespace.
//
// Parameters:
//   - ns: The namespace to set. If empty, the default namespace from kubeconfig will be used.
func (p *ResultsParams) SetNamespace(ns string) <span class="cov0" title="0">{
        if ns == "" </span><span class="cov0" title="0">{
                loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
                if p.kubeConfigPath != "" </span><span class="cov0" title="0">{
                        loadingRules.ExplicitPath = p.kubeConfigPath
                }</span>
                <span class="cov0" title="0">configOverrides := &amp;clientcmd.ConfigOverrides{}
                if p.kubeContext != "" </span><span class="cov0" title="0">{
                        configOverrides.CurrentContext = p.kubeContext
                }</span>
                <span class="cov0" title="0">kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
                namespace, _, err := kubeConfig.Namespace()
                if err == nil </span><span class="cov0" title="0">{
                        p.namespace = namespace
                        return
                }</span>
        }
        <span class="cov0" title="0">p.namespace = ns</span>
}

// Namespace returns the current Kubernetes namespace.
func (p *ResultsParams) Namespace() string <span class="cov0" title="0">{
        return p.namespace
}</span>

// Host returns the API server host address.
func (p *ResultsParams) Host() string <span class="cov0" title="0">{
        return p.host
}</span>

// SetHost sets the API server host address.
//
// Parameters:
//   - host: The host address to set.
func (p *ResultsParams) SetHost(host string) <span class="cov0" title="0">{
        p.host = host
}</span>

// Token returns the authentication token.
func (p *ResultsParams) Token() string <span class="cov0" title="0">{
        return p.token
}</span>

// SetToken sets the authentication token.
//
// Parameters:
//   - token: The authentication token to set.
func (p *ResultsParams) SetToken(token string) <span class="cov0" title="0">{
        p.token = token
}</span>

// APIPath returns the API path prefix.
func (p *ResultsParams) APIPath() string <span class="cov0" title="0">{
        return p.apiPath
}</span>

// SetAPIPath sets the API path prefix.
//
// Parameters:
//   - path: The API path prefix to set.
func (p *ResultsParams) SetAPIPath(path string) <span class="cov0" title="0">{
        p.apiPath = path
}</span>

// SkipTLSVerify returns whether TLS verification should be skipped.
func (p *ResultsParams) SkipTLSVerify() bool <span class="cov0" title="0">{
        return p.skipTLSVerify
}</span>

// SetSkipTLSVerify sets whether TLS verification should be skipped.
//
// Parameters:
//   - skip: Whether to skip TLS verification.
func (p *ResultsParams) SetSkipTLSVerify(skip bool) <span class="cov0" title="0">{
        p.skipTLSVerify = skip
}</span>

// SetRESTClient injects a REST client
func (p *ResultsParams) SetRESTClient(client *client.RESTClient) <span class="cov0" title="0">{
        p.restClient = client
}</span>

// RESTClient returns the injected REST client
func (p *ResultsParams) RESTClient() *client.RESTClient <span class="cov0" title="0">{
        return p.restClient
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package prerun

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/tektoncd/results/pkg/cli/client"
        "github.com/tektoncd/results/pkg/cli/common"
        "github.com/tektoncd/results/pkg/cli/config"
        "github.com/tektoncd/results/pkg/cli/flags"
)

// PersistentPreRunE returns a function that can be used as a persistent pre-run
// function for Cobra commands. It initializes the provided parameters using
// the flags defined in the command.
//
// Parameters:
//   - p: A common.Params struct that will be initialized with values from command flags.
//
// Returns:
//   - A function that takes a *cobra.Command and a []string, and returns an error.
//     This function initializes the params using flags.InitParams and returns any error encountered.
func PersistentPreRunE(p common.Params) func(*cobra.Command, []string) error <span class="cov0" title="0">{
        return func(cmd *cobra.Command, _ []string) error </span><span class="cov0" title="0">{
                return flags.InitParams(p, cmd)
        }</span>
}

// InitClient initializes the REST client for the command based on direct connection flags or kubeconfig.
//
// Parameters:
//   - p: common.Params containing configuration parameters.
//   - cmd: The cobra.Command being executed.
//
// Returns:
//   - *client.RESTClient: The initialized REST client.
//   - error: An error if client initialization fails.
func InitClient(p common.Params, cmd *cobra.Command) (*client.RESTClient, error) <span class="cov0" title="0">{
        // Check if any of the direct connection flags are set
        // if not fetch restConfig from k8s extension
        if config.ServerConnectionFlagsChanged(cmd) </span><span class="cov0" title="0">{
                cfg, err := config.BuildDirectClientConfig(p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return client.NewRESTClient(cfg)</span>
        }

        <span class="cov0" title="0">c, err := config.NewConfig(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := c.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config. You may need to run the 'config set' command to configure the CLI: %w", err)
        }</span>
        <span class="cov0" title="0">return client.NewRESTClient(c.Get())</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package common

import (
        "errors"
        "fmt"
        "strings"

        "k8s.io/client-go/tools/clientcmd/api"
)

// BuildConfigContextInfo extracts cluster name, username, and constructs the config context name
// from a Kubernetes context.
//
// Parameters:
//   - context: The Kubernetes context object from kubeconfig
//
// Returns:
//   - configContextName: The config context name in format "tekton-results-config/{cluster}/{user}".
//   - clusterName: The cluster name from the context.
//   - userName: The extracted username (part before "/" if present).
//   - error: An error if the context is missing cluster/user information.
func BuildConfigContextInfo(context *api.Context) (configContextName, clusterName, userName string, err error) <span class="cov0" title="0">{
        if context == nil </span><span class="cov0" title="0">{
                return "", "", "", errors.New("context is nil")
        }</span>

        <span class="cov0" title="0">clusterName = context.Cluster
        if clusterName == "" </span><span class="cov0" title="0">{
                return "", "", "", errors.New("no cluster specified in context")
        }</span>

        <span class="cov0" title="0">userName = context.AuthInfo
        if userName == "" </span><span class="cov0" title="0">{
                return "", "", "", errors.New("no user specified in context")
        }</span>

        // Extract just the username part before "/" for config context isolation
        // In some cases user also has cluster name in the format "user/cluster"
        <span class="cov0" title="0">if slashIndex := strings.Index(userName, "/"); slashIndex != -1 </span><span class="cov0" title="0">{
                userName = userName[:slashIndex]
        }</span>

        // Construct the config context name (tekton-results-config context for config storage)
        <span class="cov0" title="0">configContextName = fmt.Sprintf("tekton-results-config/%s/%s", clusterName, userName)
        return configContextName, clusterName, userName, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package config

import (
        "encoding/json"
        "errors"
        "fmt"
        "path"
        "strconv"
        "time"

        "github.com/tektoncd/results/pkg/cli/client"

        "github.com/AlecAivazis/survey/v2"
        "github.com/spf13/cobra"
        "github.com/tektoncd/results/pkg/cli/common"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/clientcmd/api"
)

// Constants defining various labels, names, and paths used in the Tekton Results configuration.
const (
        ExtensionName string = "tekton-results"
        Group         string = "results.tekton.dev"
        Version       string = "v1alpha2"
        Kind          string = "Client"
        Path          string = "apis"
)

// Config defines the interface for managing Tekton Results configuration.
type Config interface {
        Get() *client.Config
        GetObject() runtime.Object
        Set(prompt bool, p common.Params) error
        Reset(p common.Params) error
        Validate() error
}

type config struct {
        ConfigAccess clientcmd.ConfigAccess
        APIConfig    *api.Config
        RESTConfig   *rest.Config
        ClientConfig *client.Config
        Extension    *Extension
}

// NewConfig creates a new Config instance based on the provided parameters.
//
// It loads the kubeconfig, sets up the client configuration, and initializes
// the extension for Tekton Results.
//
// Parameters:
//   - p: common.Params containing configuration parameters such as kubeconfig path and context.
//
// Returns:
//   - Config: A new Config instance if successful.
//   - error: An error if any step in the configuration process fails.
func NewConfig(p common.Params) (Config, error) <span class="cov8" title="1">{
        kubeconfigPath := clientcmd.RecommendedHomeFile
        if p.KubeConfigPath() != "" </span><span class="cov8" title="1">{
                kubeconfigPath = p.KubeConfigPath()
        }</span>
        // Load kubeConfig
        <span class="cov8" title="1">cc := getRawKubeConfigLoader(kubeconfigPath)
        ca := cc.ConfigAccess()
        ac, err := cc.RawConfig()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Get the desired context from user input
        <span class="cov8" title="1">ctx := p.KubeContext()
        if ctx == "" </span><span class="cov8" title="1">{
                // If no context is provided, use the current default context
                ctx = ac.CurrentContext
        }</span>

        // Validate if the specified context exists
        <span class="cov8" title="1">if _, exists := ac.Contexts[ctx]; !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("context '%s' not found in kubeconfig", ctx)
        }</span>

        // Create a REST config using the specified context
        <span class="cov8" title="1">overriddenConfig := clientcmd.NewNonInteractiveClientConfig(ac, ctx, &amp;clientcmd.ConfigOverrides{}, ca)
        rc, err := overriddenConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c := &amp;config{
                ConfigAccess: ca,
                APIConfig:    &amp;ac,
                RESTConfig:   rc,
        }
        if err := c.LoadExtension(p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, c.LoadClientConfig()</span>
}

// LoadClientConfig loads and configures the client configuration based on the current config state.
// It sets up the REST client configuration, including the GroupVersion, Host, APIPath, and authentication details.
// The function also configures TLS settings and timeout, and creates a common.Config with transport and URL information.
//
// Returns:
//   - error: An error if any step in the configuration process fails, nil otherwise.
func (c *config) LoadClientConfig() error <span class="cov8" title="1">{
        rc := rest.CopyConfig(c.RESTConfig)

        gv := c.Extension.TypeMeta.GroupVersionKind().GroupVersion()
        rc.GroupVersion = &amp;gv

        if c.Extension.Host != "" </span><span class="cov8" title="1">{
                rc.Host = c.Extension.Host
        }</span>

        <span class="cov8" title="1">if c.Extension.APIPath != "" </span><span class="cov8" title="1">{
                rc.APIPath = c.Extension.APIPath
        }</span>

        <span class="cov8" title="1">if c.Extension.Token != "" </span><span class="cov8" title="1">{
                rc.BearerToken = c.Extension.Token
        }</span>
        <span class="cov8" title="1">if i, err := strconv.ParseBool(c.Extension.InsecureSkipTLSVerify); err == nil </span><span class="cov8" title="1">{
                if i </span><span class="cov8" title="1">{
                        rc.TLSClientConfig = rest.TLSClientConfig{}
                }</span>
                <span class="cov8" title="1">rc.Insecure = i</span>
        }

        <span class="cov8" title="1">if d, err := time.ParseDuration(c.Extension.Timeout); err != nil </span><span class="cov8" title="1">{
                rc.Timeout = d
        }</span>

        <span class="cov8" title="1">tc, err := rc.TransportConfig()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rc.APIPath = path.Join(rc.APIPath, Path)
        u, p, err := rest.DefaultServerUrlFor(rc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">u.Path = p

        c.ClientConfig = &amp;client.Config{
                Transport: tc,
                URL:       u,
                Timeout:   c.RESTConfig.Timeout,
        }

        return nil</span>
}

func (c *config) SetVersion() <span class="cov8" title="1">{
        c.Extension.TypeMeta.SetGroupVersionKind(schema.GroupVersionKind{
                Group:   Group,
                Version: Version,
                Kind:    Kind,
        })
}</span>

// GetObject returns the runtime object representation of the configuration.
func (c *config) GetObject() runtime.Object <span class="cov8" title="1">{
        return c.Extension
}</span>

// Get retrieves the current common configuration.
func (c *config) Get() *client.Config <span class="cov8" title="1">{
        return c.ClientConfig
}</span>

func (c *config) Persist(p common.Params) error <span class="cov8" title="1">{
        // Get the config context info for storing configuration
        configContextName, clusterName, userName, err := c.getConfigContextInfo(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Look for existing config context or create it
        <span class="cov8" title="1">configContext, exists := c.APIConfig.Contexts[configContextName]
        if !exists </span><span class="cov8" title="1">{
                configContext = &amp;api.Context{
                        Cluster:    clusterName,
                        AuthInfo:   userName,
                        Namespace:  "default",
                        Extensions: make(map[string]runtime.Object), // Initialize extensions
                }
                c.APIConfig.Contexts[configContextName] = configContext
        }</span>

        // Ensure Extensions map is initialized even for existing contexts
        <span class="cov8" title="1">if configContext.Extensions == nil </span><span class="cov0" title="0">{
                configContext.Extensions = make(map[string]runtime.Object)
        }</span>

        // Store/update extension in the config context
        <span class="cov8" title="1">extensionData, err := json.Marshal(c.Extension)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal extension: %w", err)
        }</span>

        <span class="cov8" title="1">configContext.Extensions[ExtensionName] = &amp;runtime.Unknown{
                TypeMeta: c.Extension.TypeMeta,
                Raw:      extensionData,
        }

        return clientcmd.ModifyConfig(c.ConfigAccess, *c.APIConfig, false)</span>
}

// getConfigContextInfo extracts cluster and user information from the current context and constructs
// the config context name for storing Tekton Results configuration.
//
// Parameters:
//   - p: common.Params containing configuration parameters, including the KubeContext.
//
// Returns:
//   - configContextName: The config context name in format "tekton-results-config/{cluster}/{user}".
//   - clusterName: The cluster name from the current context.
//   - userName: The username from the current context.
//   - error: An error if the current context is not set or missing cluster/user information.
func (c *config) getConfigContextInfo(p common.Params) (configContextName, clusterName, userName string, err error) <span class="cov8" title="1">{
        ctx := c.APIConfig.CurrentContext
        if p.KubeContext() != "" </span><span class="cov8" title="1">{
                ctx = p.KubeContext()
        }</span>

        // Get the context to extract cluster and user info
        <span class="cov8" title="1">context := c.APIConfig.Contexts[ctx]
        if context == nil </span><span class="cov0" title="0">{
                return "", "", "", errors.New("current context is not set in kubeconfig")
        }</span>

        <span class="cov8" title="1">return common.BuildConfigContextInfo(context)</span>
}

// Set configures the Extension settings for the config object.
// It either prompts the user for input or uses provided parameters to set the values.
//
// Parameters:
//   - prompt: A boolean flag indicating whether to prompt the user for input.
//   - p: A common.Params object containing configuration parameters.
//
// Returns:
//   - error: An error if any step in the configuration process fails, nil otherwise.
func (c *config) Set(prompt bool, p common.Params) error <span class="cov8" title="1">{
        // get data from prompt in enabled
        if prompt </span><span class="cov8" title="1">{
                host := c.Host()
                if err := c.Prompt("Host", &amp;c.Extension.Host, host); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov0" title="0">token := c.Token()
                if err, ok := token.(error); ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get token: %w", err)
                }</span>
                <span class="cov0" title="0">if err := c.Prompt("Token", &amp;c.Extension.Token, token); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := c.Prompt("API Path", &amp;c.Extension.APIPath, ""); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := c.Prompt("Insecure Skip TLS Verify", &amp;c.Extension.InsecureSkipTLSVerify, []string{"false", "true"}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                if p.Host() != "" </span><span class="cov8" title="1">{
                        c.Extension.Host = p.Host()
                }</span>
                <span class="cov8" title="1">if p.Token() != "" </span><span class="cov8" title="1">{
                        c.Extension.Token = p.Token()
                }</span>
                <span class="cov8" title="1">if p.APIPath() != "" </span><span class="cov8" title="1">{
                        c.Extension.APIPath = p.APIPath()
                }</span>
                <span class="cov8" title="1">if p.SkipTLSVerify() </span><span class="cov8" title="1">{
                        c.Extension.InsecureSkipTLSVerify = strconv.FormatBool(p.SkipTLSVerify())
                }</span>
        }

        <span class="cov8" title="1">return c.Persist(p)</span>
}

// Reset resets the Tekton Results extension configuration to its default state.//+
//
// Parameters:
//   - p: A common.Params object containing configuration parameters.
//
// Returns an error if the reset process fails, nil otherwise.
func (c *config) Reset(p common.Params) error <span class="cov8" title="1">{
        c.Extension = new(Extension)
        c.SetVersion()
        return c.Persist(p)
}</span>

func (c *config) Prompt(name string, value *string, data any) error <span class="cov8" title="1">{
        var p survey.Prompt

        m := name + " : "

        switch d := data.(type) </span>{
        case string:<span class="cov8" title="1">
                p = &amp;survey.Input{
                        Message: m,
                        Default: d,
                }</span>
        case []string:<span class="cov0" title="0">
                p = &amp;survey.Select{
                        Message: m,
                        Options: d,
                }</span>
        default:<span class="cov0" title="0">
                p = &amp;survey.Input{
                        Message: m,
                }</span>
        }

        <span class="cov8" title="1">return survey.AskOne(p, value)</span>
}

// LoadExtension loads the Tekton Results extension configuration from the kubeconfig.
// It loads from a dedicated "tekton-results-config" context to ensure configuration
// persists regardless of current namespace context changes (e.g., 'oc project').
//
// Parameters:
//   - p: common.Params containing configuration parameters, including the KubeContext.
//
// Returns:
//   - error: An error if the current context is not set or if there's an issue unmarshaling the extension data.
func (c *config) LoadExtension(p common.Params) error <span class="cov8" title="1">{
        // Get the config context info for loading configuration
        configContextName, _, _, err := c.getConfigContextInfo(p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check if config context exists
        <span class="cov8" title="1">if configContext, exists := c.APIConfig.Contexts[configContextName]; exists </span><span class="cov8" title="1">{
                if configContext.Extensions != nil </span><span class="cov8" title="1">{
                        if ext := configContext.Extensions[ExtensionName]; ext != nil </span><span class="cov8" title="1">{
                                // Load existing extension
                                c.Extension = new(Extension)
                                if err := json.Unmarshal(ext.(*runtime.Unknown).Raw, c.Extension); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to unmarshal extension: %w", err)
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }
                }
        }

        // No config context or no extension found - create empty extension
        <span class="cov8" title="1">c.Extension = new(Extension)
        c.SetVersion()
        return nil</span>
}

// Host retrieves the host URL for the Tekton Results API based on external access detection.
// It automatically detects the platform and tries to find a healthy tekton-results-api-service.
//
// Returns:
//   - string: The detected host URL if successful, or empty string if detection fails.
func (c *config) Host() string <span class="cov8" title="1">{
        url, err := getHostURL(c.RESTConfig)
        if err != nil </span><span class="cov8" title="1">{
                return "" // Return empty string so user can enter manually
        }</span>
        <span class="cov0" title="0">return url</span> // Return the detected URL as default
}

// Token returns the bearer token from the REST configuration.
// It returns an error if the REST configuration is not properly initialized.
//
// Returns:
//   - any: The bearer token string if successful, or an error if the configuration is invalid.
func (c *config) Token() any <span class="cov8" title="1">{
        if c.RESTConfig == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("REST configuration is not initialized")
        }</span>
        <span class="cov8" title="1">return c.RESTConfig.BearerToken</span>
}

// getRawKubeConfigLoader creates and returns a clientcmd.ClientConfig based on the provided kubeconfig path.
// This function is equivalent to ToRawKubeConfigLoader() and is used to load the kubeconfig file.
//
// Parameters:
//   - kubeconfigPath: A string representing the path to the kubeconfig file.
//
// Returns:
//   - clientcmd.ClientConfig: A non-interactive deferred loading client configuration
//     that uses the specified kubeconfig path and default overrides.
func getRawKubeConfigLoader(kubeconfigPath string) clientcmd.ClientConfig <span class="cov8" title="1">{
        // Set explicit path for kubeconfig
        loadingRules := &amp;clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfigPath}
        configOverrides := &amp;clientcmd.ConfigOverrides{}

        // Return the clientcmd.ClientConfig (equivalent to ToRawKubeConfigLoader)
        return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
}</span>

// ServerConnectionFlagsChanged returns true if any server connection flags are set.
func ServerConnectionFlagsChanged(cmd *cobra.Command) bool <span class="cov0" title="0">{
        return cmd.Flags().Changed("host") ||
                cmd.Flags().Changed("token") ||
                cmd.Flags().Changed("insecure-skip-tls-verify") ||
                cmd.Flags().Changed("api-path")
}</span>

// BuildDirectClientConfig builds a client.Config from CLI flags (host, token, api-path, insecure-skip-tls-verify).
func BuildDirectClientConfig(p common.Params) (*client.Config, error) <span class="cov0" title="0">{
        host := p.Host()
        token := p.Token()
        if host == "" || token == "" </span><span class="cov0" title="0">{
                return nil, errors.New("--host and --token flag must be set if using direct connection flags")
        }</span>
        <span class="cov0" title="0">rc := &amp;rest.Config{
                Host:        host,
                BearerToken: token,
        }
        if p.APIPath() != "" </span><span class="cov0" title="0">{
                rc.APIPath = p.APIPath()
        }</span>

        <span class="cov0" title="0">rc.Insecure = p.SkipTLSVerify()
        // Optionally set timeout (default 60s)
        rc.Timeout = 60 * time.Second

        rc.APIPath = path.Join(rc.APIPath, Path)

        rc.GroupVersion = &amp;schema.GroupVersion{
                Group:   Group,
                Version: Version,
        }
        u, pth, err := rest.DefaultServerUrlFor(rc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">u.Path = pth

        tcfg, err := rc.TransportConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;client.Config{
                URL:       u,
                Timeout:   rc.Timeout,
                Transport: tcfg,
        }, nil</span>
}

// Validate validates the configuration of the client.
// It checks if the client configuration and extension are properly set up.
//
// Parameters:
//   - c: A Config interface containing the client configuration and extension.
//
// Returns:
//   - error: An error if the configuration is invalid, nil otherwise.
func (c *config) Validate() error <span class="cov0" title="0">{
        // Check if the configuration is properly set up
        clientConfig := c.Get()
        if clientConfig == nil || clientConfig.URL == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("client configuration missing: URL not set")
        }</span>

        // Check if essential configuration values are missing
        <span class="cov0" title="0">extensionObj := c.GetObject()
        extension, ok := extensionObj.(*Extension)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid extension type: expected *Extension, got %T", extensionObj)
        }</span>

        <span class="cov0" title="0">if extension.Host == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("API server host not configured: host field is empty")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package config

import "k8s.io/apimachinery/pkg/runtime"

// Extension represents the configuration for an API extension.
// It includes details necessary for connecting to and authenticating with an external API.
type Extension struct {
        // TypeMeta is embedded to provide API version and kind information.
        runtime.TypeMeta `json:",inline"`

        // APIPath is the path to the API endpoint.
        APIPath string `json:"api-path"`

        // Host is the hostname or IP address of the API server.
        Host string `json:"host"`

        // Token is the authentication token used for API requests.
        Token string `json:"token"`

        // Timeout specifies the maximum duration for API requests.
        // It is optional and can be omitted.
        Timeout string `json:"timeout,omitempty"`

        // InsecureSkipTLSVerify indicates whether to skip TLS certificate verification.
        // It is optional and can be omitted. If set, it should be used with caution.
        InsecureSkipTLSVerify string `json:"insecure-skip-tls-verify,omitempty"`
}

// DeepCopy is an autogenerated deep copy function, copying the receiver, creating a new Extension.
func (in *Extension) DeepCopy() *Extension <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(Extension)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deep copy function, copying the receiver, creating a new runtime.Object.
func (in *Extension) DeepCopyObject() runtime.Object <span class="cov8" title="1">{
        return in.DeepCopy()
}</span>

// DeepCopyInto is an autogenerated deep copy function, copying the receiver, writing into out. in must be non-nil.
func (in *Extension) DeepCopyInto(out *Extension) <span class="cov8" title="1">{
        *out = *in
        out.TypeMeta = in.TypeMeta
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package config

import (
        "errors"
        "fmt"
        "net"
        "net/url"
        "strings"
        "time"

        "k8s.io/client-go/rest"
)

// getHostURL retrieves the external access URL for Tekton Results API.
// It automatically detects the platform and tries to connect to the standard tekton-results-api-service endpoint.
//
// Parameters:
//   - c: A pointer to a rest.Config struct containing the Kubernetes REST configuration.
//
// Returns:
//   - A string containing the external access URL.
//   - An error if any step in the process fails.
func getHostURL(c *rest.Config) (string, error) <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return "", errors.New("nil REST config provided")
        }</span>

        <span class="cov8" title="1">platform := DetectPlatform(c)

        switch platform </span>{
        case PlatformOpenShift:<span class="cov0" title="0">
                return tryConnectToRoute(c)</span>
        case PlatformKubernetes:<span class="cov0" title="0">
                return "", fmt.Errorf("kubernetes ingress not supported")</span>
        default:<span class="cov8" title="1">
                return "", errors.New("unable to detect platform type")</span>
        }
}

// tryConnectToRoute attempts to construct and test OpenShift route URLs to check the server's health
func tryConnectToRoute(c *rest.Config) (string, error) <span class="cov0" title="0">{
        clusterDomain, err := extractClusterDomain(c.Host)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to extract cluster domain")
        }</span>

        // OpenShift route patterns: tekton-results-api-service-{namespace}.apps.{cluster-domain}
        <span class="cov0" title="0">namespace := "openshift-pipelines"
        serviceName := "tekton-results-api-service"

        // Try HTTPS first (most common for OpenShift routes)
        httpsURL := fmt.Sprintf("https://%s-%s.apps.%s", serviceName, namespace, clusterDomain)
        if isURLReachable(httpsURL) </span><span class="cov0" title="0">{
                return httpsURL, nil
        }</span>

        // Try HTTP as fallback
        <span class="cov0" title="0">httpURL := fmt.Sprintf("http://%s-%s.apps.%s", serviceName, namespace, clusterDomain)
        if isURLReachable(httpURL) </span><span class="cov0" title="0">{
                return httpURL, nil
        }</span>
        <span class="cov0" title="0">return "", fmt.Errorf("no reachable route found")</span>
}

// extractClusterDomain extracts the cluster domain from the Kubernetes API server URL
// Example: https://api.mycluster.example.com:6443 -&gt; mycluster.example.com
func extractClusterDomain(apiServerURL string) (string, error) <span class="cov0" title="0">{
        if apiServerURL == "" </span><span class="cov0" title="0">{
                return "", errors.New("empty API server URL")
        }</span>

        // Parse the URL
        <span class="cov0" title="0">u, err := url.Parse(apiServerURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to parse URL")
        }</span>

        <span class="cov0" title="0">hostname := u.Hostname()
        if hostname == "" </span><span class="cov0" title="0">{
                return "", errors.New("failed to extract hostname")
        }</span>

        // For OpenShift/K8s, API server is typically: api.{cluster-domain}
        // Extract {cluster-domain} part
        <span class="cov0" title="0">if strings.HasPrefix(hostname, "api.") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(hostname, "api."), nil
        }</span>

        // If it doesn't start with "api.", try to extract domain differently
        // Handle cases like: k8s-api-server.cluster.example.com -&gt; cluster.example.com
        <span class="cov0" title="0">parts := strings.Split(hostname, ".")
        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                // Take the last two parts as domain (example.com)
                // or more if it looks like a full domain
                if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                        return strings.Join(parts[1:], "."), nil // Skip first part
                }</span>
                <span class="cov0" title="0">return strings.Join(parts, "."), nil</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("unable to extract cluster domain")</span>
}

// isURLReachable checks if a URL is reachable with a simple TCP connection test
func isURLReachable(testURL string) bool <span class="cov0" title="0">{
        // Parse URL to extract hostname and determine port
        parsedURL, err := url.Parse(testURL)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Get hostname and add appropriate port
        <span class="cov0" title="0">hostname := parsedURL.Hostname()
        var port string
        switch parsedURL.Scheme </span>{
        case "https":<span class="cov0" title="0">
                port = "443"</span>
        case "http":<span class="cov0" title="0">
                port = "80"</span>
        default:<span class="cov0" title="0">
                return false</span> // unsupported scheme
        }

        // Create host:port for dialing
        <span class="cov0" title="0">hostPort := hostname + ":" + port

        // Test TCP connectivity
        conn, err := net.DialTimeout("tcp", hostPort, 5*time.Second)
        if conn != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
        }</span>
        <span class="cov0" title="0">return err == nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package config

import (
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/rest"
)

// PlatformType represents the type of Kubernetes platform
type PlatformType string

// Platform types for identifying the underlying Kubernetes platform
const (
        PlatformUnknown    PlatformType = "Unknown"
        PlatformOpenShift  PlatformType = "OpenShift"
        PlatformKubernetes PlatformType = "Kubernetes"
)

// DetectPlatform determines if we're running on OpenShift or Kubernetes
// Checks for OpenShift-specific API groups
func DetectPlatform(c *rest.Config) PlatformType <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return PlatformUnknown
        }</span>

        <span class="cov8" title="1">discoveryClient, err := discovery.NewDiscoveryClientForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                return PlatformKubernetes // Default to Kubernetes if discovery fails
        }</span>

        // Check for OpenShift-specific API groups using a map for efficient lookup
        <span class="cov8" title="1">openShiftAPIGroups := map[string]bool{
                "route.openshift.io":    true, // Routes (core OpenShift feature)
                "image.openshift.io":    true, // Image streams
                "apps.openshift.io":     true, // DeploymentConfigs
                "security.openshift.io": true, // Security Context Constraints
                "project.openshift.io":  true, // Projects
                "user.openshift.io":     true, // Users and groups
                "oauth.openshift.io":    true, // OAuth
                "config.openshift.io":   true, // Cluster configuration
        }

        apiGroupList, err := discoveryClient.ServerGroups()
        if err != nil </span><span class="cov8" title="1">{
                return PlatformUnknown
        }</span>

        // Check if any OpenShift API groups are present
        <span class="cov0" title="0">for _, group := range apiGroupList.Groups </span><span class="cov0" title="0">{
                if openShiftAPIGroups[group.Name] </span><span class="cov0" title="0">{
                        return PlatformOpenShift
                }</span>
        }

        // No OpenShift API groups found - this is Kubernetes
        <span class="cov0" title="0">return PlatformKubernetes</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package client

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "io"
        "os"
        "time"

        "github.com/tektoncd/results/pkg/cli/dev/config"

        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        pb3 "github.com/tektoncd/results/proto/v1alpha3/results_go_proto"
        "golang.org/x/oauth2"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/oauth"
        v1 "k8s.io/api/authentication/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"

        // Load auth plugins
        _ "k8s.io/client-go/plugin/pkg/client/auth"
        "k8s.io/client-go/tools/clientcmd"
)

//lint:ignore SA1019

// Factory contains the configuration for creating a k8s client.
type Factory struct {
        k8s kubernetes.Interface
        cfg *config.Config
}

// NewDefaultFactory creates a new Factory with the default configuration.
func NewDefaultFactory() (*Factory, error) <span class="cov0" title="0">{
        cfg := config.GetConfig()

        rules := clientcmd.NewDefaultClientConfigLoadingRules()
        kubeconfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(rules, nil)
        clientconfig, err := kubeconfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if cfg.ServiceAccount != nil &amp;&amp; cfg.ServiceAccount.Name != "" &amp;&amp;
                cfg.ServiceAccount.Namespace == "" </span><span class="cov0" title="0">{
                ns, _, err := kubeconfig.Namespace()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">cfg.ServiceAccount.Namespace = ns</span>
        }
        <span class="cov0" title="0">client, err := kubernetes.NewForConfig(clientconfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Factory{
                k8s: client,
                cfg: cfg,
        }, nil</span>
}

// ResultsClient creates a new Results gRPC client for the given factory settings.
// TODO: Refactor this with watcher client code?
func (f *Factory) ResultsClient(ctx context.Context, overrideAPIAddr string) (pb.ResultsClient, error) <span class="cov0" title="0">{
        token, err := f.token(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var creds credentials.TransportCredentials
        if f.cfg.Insecure </span><span class="cov0" title="0">{
                creds = credentials.NewTLS(&amp;tls.Config{
                        //nolint:gosec // needed for --insecure flag
                        InsecureSkipVerify: true,
                })
        }</span> else<span class="cov0" title="0"> {
                certs, err := f.certs()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">creds = credentials.NewClientTLSFromCert(certs, f.cfg.SSL.ServerNameOverride)</span>
        }

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()
        addr := f.cfg.Address
        if overrideAPIAddr != "" </span><span class="cov0" title="0">{
                addr = overrideAPIAddr
        }</span>
        <span class="cov0" title="0">conn, err := grpc.DialContext(ctx, addr, grpc.WithBlock(), //nolint:staticcheck
                grpc.WithTransportCredentials(creds),
                grpc.WithDefaultCallOptions(grpc.PerRPCCredentials(oauth.TokenSource{
                        TokenSource: oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}),
                })),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Dial: %v\n", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return pb.NewResultsClient(conn), nil</span>
}

// DefaultResultsClient creates a new results client.
// Will dial overrideAPIAddr if overrideAPIAddr is not empty
func DefaultResultsClient(ctx context.Context, overrideAPIAddr string) (pb.ResultsClient, error) <span class="cov0" title="0">{
        f, err := NewDefaultFactory()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := f.ResultsClient(ctx, overrideAPIAddr)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

// LogClient creates a new Results gRPC client for the given factory settings.
// TODO: Refactor this with watcher client code?
func (f *Factory) LogClient(ctx context.Context, overrideAPIAddr string) (pb.LogsClient, error) <span class="cov0" title="0">{
        token, err := f.token(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var creds credentials.TransportCredentials
        if f.cfg.Insecure </span><span class="cov0" title="0">{
                creds = credentials.NewTLS(&amp;tls.Config{
                        //nolint:gosec // needed for --insecure flag
                        InsecureSkipVerify: true,
                })
        }</span> else<span class="cov0" title="0"> {
                certs, err := f.certs()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">creds = credentials.NewClientTLSFromCert(certs, f.cfg.SSL.ServerNameOverride)</span>
        }

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()
        addr := f.cfg.Address
        if overrideAPIAddr != "" </span><span class="cov0" title="0">{
                addr = overrideAPIAddr
        }</span>
        <span class="cov0" title="0">conn, err := grpc.DialContext(ctx, addr, grpc.WithBlock(), //nolint:staticcheck
                grpc.WithTransportCredentials(creds),
                grpc.WithDefaultCallOptions(grpc.PerRPCCredentials(oauth.TokenSource{
                        TokenSource: oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}),
                })),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Dial: %v\n", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return pb.NewLogsClient(conn), nil</span>
}

// DefaultLogsClient creates a new default logs client.
func DefaultLogsClient(ctx context.Context, overrideAPIAddr string) (pb.LogsClient, error) <span class="cov0" title="0">{
        f, err := NewDefaultFactory()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := f.LogClient(ctx, overrideAPIAddr)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func (f *Factory) certs() (*x509.CertPool, error) <span class="cov8" title="1">{
        certs, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if path := f.cfg.SSL.RootsFilePath; path != "" </span><span class="cov8" title="1">{
                f, err := os.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer f.Close()
                b, err := io.ReadAll(f)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to read TLS cert file: %v", err)
                }</span>
                <span class="cov8" title="1">if ok := certs.AppendCertsFromPEM(b); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unable to add cert to pool")
                }</span>
        }
        <span class="cov8" title="1">return certs, nil</span>
}

// PluginLogsClient creates a new Results gRPC client for the given factory settings.
func (f *Factory) PluginLogsClient(ctx context.Context, overrideAPIAddr string) (pb3.LogsClient, error) <span class="cov0" title="0">{
        token, err := f.token(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var creds credentials.TransportCredentials
        if f.cfg.Insecure </span><span class="cov0" title="0">{
                creds = credentials.NewTLS(&amp;tls.Config{
                        //nolint:gosec // needed for --insecure flag
                        InsecureSkipVerify: true,
                })
        }</span> else<span class="cov0" title="0"> {
                certs, err := f.certs()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">creds = credentials.NewClientTLSFromCert(certs, f.cfg.SSL.ServerNameOverride)</span>
        }

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()
        addr := f.cfg.Address
        if overrideAPIAddr != "" </span><span class="cov0" title="0">{
                addr = overrideAPIAddr
        }</span>
        <span class="cov0" title="0">conn, err := grpc.DialContext(ctx, addr, grpc.WithBlock(), //nolint:staticcheck
                grpc.WithTransportCredentials(creds),
                grpc.WithDefaultCallOptions(grpc.PerRPCCredentials(oauth.TokenSource{
                        TokenSource: oauth2.StaticTokenSource(&amp;oauth2.Token{AccessToken: token}),
                })),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Dial: %v\n", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return pb3.NewLogsClient(conn), nil</span>
}

// DefaultPluginLogsClient creates a new default logs client.
func DefaultPluginLogsClient(ctx context.Context, overrideAPIAddr string) (pb3.LogsClient, error) <span class="cov0" title="0">{
        f, err := NewDefaultFactory()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">client, err := f.PluginLogsClient(ctx, overrideAPIAddr)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}

func (f *Factory) token(ctx context.Context) (string, error) <span class="cov8" title="1">{
        if f.cfg == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if t := f.cfg.Token; t != "" </span><span class="cov8" title="1">{
                return t, nil
        }</span>

        <span class="cov8" title="1">if sa := f.cfg.ServiceAccount; sa != nil </span><span class="cov8" title="1">{
                t, err := f.k8s.CoreV1().ServiceAccounts(sa.Namespace).CreateToken(ctx, sa.Name, &amp;v1.TokenRequest{}, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("error getting service account token: %w", err)
                }</span>
                <span class="cov8" title="1">return t.Status.Token, nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package config

import (
        "log"

        "github.com/spf13/viper"
)

const (
        // EnvSSLRootFilePath is the environment variable name for the path to
        // local SSL cert to use for requests.
        EnvSSLRootFilePath = "TKN_RESULTS_SSL_ROOTS_FILE_PATH"
        // EnvSSLServerNameOverride is the environment variable name for the SSL server
        // name override.
        EnvSSLServerNameOverride = "TKN_RESULTS_SSL_SERVER_NAME_OVERRIDE"
)

var (
        env = map[string]string{
                EnvSSLRootFilePath:       "Path to local SSL cert to use.",
                EnvSSLServerNameOverride: "SSL server name override (useful if using with a proxy such as kubectl port-forward).",
        }
        cfg *Config
)

// Config contains configuration information for the Results CLI.
type Config struct {
        // Address is the server address to connect to.
        Address string

        // Token is the bearer token to use for authentication. Takes priority over ServiceAccount.
        Token string
        // ServiceAccount is the Kubernetes Service Account to use to authenticate with the Results API.
        // When specified, the client will fetch a bearer token from the Kubernetes API and use that token
        // for all Results API requests.
        ServiceAccount *ServiceAccount `mapstructure:"service_account"`

        // SSL contains SSL configuration information.
        SSL SSLConfig
        // Portforward enable auto portforwarding to tekton-results-api-service
        // When Address is set and Portforward is true, tkn-results will portforward tekton-results-api-service automatically
        Portforward bool
        // Insecure determines whether to use insecure GRPC tls communication
        Insecure bool

        // v1alpha2
        UseV1Alpha2 bool
}

// SSLConfig contains SSL configuration information.
type SSLConfig struct {
        RootsFilePath      string `mapstructure:"roots_file_path"`
        ServerNameOverride string `mapstructure:"server_name_override"`
}

// ServiceAccount contains information about a Kubernetes ServiceAccount.
type ServiceAccount struct {
        Namespace string
        Name      string
}

// Init sets defaults and reads in config from the config file.
func Init() <span class="cov0" title="0">{
        viper.SetConfigName("results")
        viper.SetConfigType("yaml")
        viper.AddConfigPath("$HOME/.config/tkn")
        err := setConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("error setting up flags and config", err)
        }</span>
}

func setConfig() error <span class="cov8" title="1">{
        for k := range env </span><span class="cov8" title="1">{
                if err := viper.BindEnv(k); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Config should be evaluated in the following order (last wins):
        // 1. Environment variables
        // 2. Config File
        // 3. Flags

        // Initial config is contains the env variables,
        // so that the unmarshal can take priority if those values are set.
        <span class="cov8" title="1">cfg = &amp;Config{
                SSL: SSLConfig{
                        RootsFilePath:      viper.GetString(EnvSSLRootFilePath),
                        ServerNameOverride: viper.GetString(EnvSSLServerNameOverride),
                },
        }

        if err := viper.ReadInConfig(); err == nil </span><span class="cov8" title="1">{
                if err := viper.Unmarshal(cfg); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Flags should override other values.
        <span class="cov8" title="1">if s := viper.GetString("addr"); s != "" </span><span class="cov8" title="1">{
                cfg.Address = s
        }</span>
        <span class="cov8" title="1">if s := viper.GetString("authtoken"); s != "" </span><span class="cov0" title="0">{
                cfg.Token = viper.GetString("authtoken")
        }</span>
        <span class="cov8" title="1">if s := viper.GetString("sa"); s != "" </span><span class="cov0" title="0">{
                cfg.ServiceAccount = &amp;ServiceAccount{}
                cfg.ServiceAccount.Name = viper.GetString("sa")
                if s := viper.GetString("sa-ns"); s != "" </span><span class="cov0" title="0">{
                        cfg.ServiceAccount.Namespace = viper.GetString("sa-ns")
                }</span>

        }

        <span class="cov8" title="1">cfg.Portforward = viper.GetBool("portforward")
        cfg.Insecure = viper.GetBool("insecure")
        cfg.UseV1Alpha2 = viper.GetBool("v1alpha2")
        return nil</span>
}

// GetConfig returns the current config.
func GetConfig() *Config <span class="cov8" title="1">{
        return cfg
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package flags

import (
        "github.com/jonboulle/clockwork"
        "github.com/spf13/cobra"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        pb3 "github.com/tektoncd/results/proto/v1alpha3/results_go_proto"
)

// Params contains a ResultsClient and LogsClient
type Params struct {
        ResultsClient    pb.ResultsClient
        LogsClient       pb.LogsClient
        PluginLogsClient pb3.LogsClient

        Clock clockwork.Clock
}

// ListOptions is used on commands that list Results, Records or Logs
type ListOptions struct {
        Filter    string
        Limit     int32
        PageToken string
        Format    string
}

// AddListFlags is a helper function that adds common flags for commands that list things
func AddListFlags(options *ListOptions, cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.Flags().StringVarP(&amp;options.Filter, "filter", "f", "", "[To be deprecated] CEL Filter")
        cmd.Flags().Int32VarP(&amp;options.Limit, "limit", "l", 0, "[To be deprecated] number of items to return. Response may be truncated due to server limits.")
        cmd.Flags().StringVarP(&amp;options.PageToken, "page", "p", "", "[To be deprecated] pagination token to use for next page")
        cmd.Flags().StringVarP(&amp;options.Format, "output", "o", "tab", "[To be deprecated] output format. Valid values: tab|textproto|json")
}</span>

// GetOptions used on commands that get a single Result, Record or Log
type GetOptions struct {
        Format string
}

// AddGetFlags is a helper function that adds common flags for get commands
func AddGetFlags(options *GetOptions, cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.Flags().StringVarP(&amp;options.Format, "output", "o", "json", "[To be deprecated] output format. Valid values: textproto|json")
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package format

import (
        "fmt"
        "io"
        "strings"
        "text/tabwriter"
        "time"

        "github.com/hako/durafmt"
        "github.com/jonboulle/clockwork"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/encoding/prototext"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// PrintProto prints the given proto message to the given writer in the given format.
// Valid formats are: tab, textproto, json
func PrintProto(w io.Writer, m proto.Message, format string) error <span class="cov0" title="0">{
        switch format </span>{
        case "tab":<span class="cov0" title="0">
                tw := tabwriter.NewWriter(w, 40, 2, 2, ' ', 0)
                switch t := m.(type) </span>{
                case *pb.ListResultsResponse:<span class="cov0" title="0">
                        fmt.Fprintln(tw, strings.Join([]string{"Name", "Start", "Update"}, "\t"))
                        for _, r := range t.GetResults() </span><span class="cov0" title="0">{
                                fmt.Fprintln(tw, strings.Join([]string{
                                        r.GetName(),
                                        r.GetCreateTime().AsTime().Truncate(time.Second).Local().String(),
                                        r.GetUpdateTime().AsTime().Truncate(time.Second).Local().String(),
                                }, "\t"))
                        }</span>
                case *pb.ListRecordsResponse:<span class="cov0" title="0">
                        fmt.Fprintln(tw, strings.Join([]string{"Name", "Type", "Start", "Update"}, "\t"))
                        for _, r := range t.GetRecords() </span><span class="cov0" title="0">{
                                fmt.Fprintln(tw, strings.Join([]string{
                                        r.GetName(),
                                        r.GetData().GetType(),
                                        r.GetCreateTime().AsTime().Truncate(time.Second).Local().String(),
                                        r.GetUpdateTime().AsTime().Truncate(time.Second).Local().String(),
                                }, "\t"))
                        }</span>
                }
                <span class="cov0" title="0">tw.Flush()</span>
        case "textproto":<span class="cov0" title="0">
                opts := prototext.MarshalOptions{
                        Multiline: true,
                }
                b, err := opts.Marshal(m)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(b); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case "json":<span class="cov0" title="0">
                opts := protojson.MarshalOptions{
                        Multiline: true,
                }
                b, err := opts.Marshal(m)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if _, err := w.Write(b); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown output format %q", format)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Age returns the age of the given timestamp in a human-readable format.
func Age(timestamp *timestamppb.Timestamp, c clockwork.Clock) string <span class="cov0" title="0">{
        if timestamp == nil </span><span class="cov0" title="0">{
                return "---"
        }</span>
        <span class="cov0" title="0">t := timestamp.AsTime()
        if t.IsZero() </span><span class="cov0" title="0">{
                return "---"
        }</span>
        <span class="cov0" title="0">duration := c.Since(t)
        return durafmt.ParseShort(duration).String() + " ago"</span>
}

// Duration returns the duration between two timestamps in a human-readable format.
func Duration(timestamp1, timestamp2 *timestamppb.Timestamp) string <span class="cov0" title="0">{
        if timestamp1 == nil || timestamp2 == nil </span><span class="cov0" title="0">{
                return "---"
        }</span>
        <span class="cov0" title="0">t1 := timestamp1.AsTime()
        t2 := timestamp2.AsTime()
        if t1.IsZero() || t2.IsZero() </span><span class="cov0" title="0">{
                return "---"
        }</span>
        <span class="cov0" title="0">duration := t2.Sub(t1)
        return duration.String()</span>
}

// Status returns the status of the given record summary in a human-readable format.
func Status(status pb.RecordSummary_Status) string <span class="cov0" title="0">{
        switch status </span>{
        case pb.RecordSummary_SUCCESS:<span class="cov0" title="0">
                return "Succeeded"</span>
        case pb.RecordSummary_FAILURE:<span class="cov0" title="0">
                return "Failed"</span>
        case pb.RecordSummary_TIMEOUT:<span class="cov0" title="0">
                return "Timed Out"</span>
        case pb.RecordSummary_CANCELLED:<span class="cov0" title="0">
                return "Cancelled"</span>
        }
        <span class="cov0" title="0">return "Unknown"</span>
}

// Namespace returns the namespace of the given result name.
func Namespace(resultName string) string <span class="cov0" title="0">{
        return strings.Split(resultName, "/")[0]
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package portforward

import (
        "context"
        "fmt"
        "log"
        "net"
        "net/http"
        "os"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        "k8s.io/client-go/tools/clientcmd"
        "k8s.io/client-go/tools/portforward"
        "k8s.io/client-go/transport/spdy"
)

// PortForward provides port-forwarding functionality to results api service,
// so cli users would not bother to open a new terminal and type `kubectrl port-forward` manually
type PortForward struct {
        clientConfig *rest.Config
        clientSet    kubernetes.Interface
}

// NewPortForward create a new PortForward to do port-forwarding staff
func NewPortForward() (*PortForward, error) <span class="cov0" title="0">{
        kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(clientcmd.NewDefaultClientConfigLoadingRules(), nil)
        clientConfig, err := kubeConfig.ClientConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">clientSet, err := kubernetes.NewForConfig(clientConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;PortForward{clientSet: clientSet, clientConfig: clientConfig}, nil</span>
}

// ForwardPortBackground do port-forwarding in background.
// stopChan control when port-forwarding stops, port specify which port on localhost port-forwarding will occupy
func (pf *PortForward) ForwardPortBackground(stopChan &lt;-chan struct{}, port int) error <span class="cov0" title="0">{
        resultsAPIService, err := pf.clientSet.CoreV1().Services("tekton-pipelines").Get(context.TODO(), "tekton-results-api-service", metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resultsPodSelector := labels.Set(resultsAPIService.Spec.Selector)
        pods, err := pf.clientSet.CoreV1().Pods("tekton-pipelines").List(context.TODO(), metav1.ListOptions{
                LabelSelector: resultsPodSelector.String(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">resultsAPIPod := pods.Items[0]
        req := pf.clientSet.CoreV1().RESTClient().Post().Namespace("tekton-pipelines").Resource("pods").Name(resultsAPIPod.Name).SubResource("portforward")

        transport, upgrader, err := spdy.RoundTripperFor(pf.clientConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">dialer := spdy.NewDialer(upgrader, &amp;http.Client{Transport: transport}, "POST", req.URL())

        readyChan := make(chan struct{})
        fw, err := portforward.NewOnAddresses(dialer, []string{"localhost"}, []string{fmt.Sprintf("%d:8080", port)}, stopChan, readyChan, nil, os.Stderr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                err := fw.ForwardPorts()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("err forward ports: %v", err)
                }</span>
        }()

        // wait for port-forward ready
        <span class="cov0" title="0">&lt;-readyChan
        return nil</span>
}

// PickFreePort asks the kernel for a free open port that is ready to use.
func PickFreePort() (port int, err error) <span class="cov0" title="0">{
        var a *net.TCPAddr
        a, err = net.ResolveTCPAddr("tcp", "localhost:0")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">var l *net.TCPListener
        l, err = net.ListenTCP("tcp", a)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer l.Close()
        return l.Addr().(*net.TCPAddr).Port, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package flags

import (
        "github.com/spf13/cobra"
        "github.com/tektoncd/cli/pkg/formatted"
        "github.com/tektoncd/results/pkg/cli/common"
)

const (
        kubeConfig            = "kubeconfig"
        context               = "context"
        namespace             = "namespace"
        host                  = "host"
        token                 = "token"
        apiPath               = "api-path"
        insecureSkipTLSVerify = "insecure-skip-tls-verify"
)

// ResultsOptions all global Results options
type ResultsOptions struct {
        KubeConfig, Context, Namespace, Host, Token, APIPath string
        InsecureSkipTLSVerify                                bool
}

// AddResultsOptions amends the provided command by adding flags required to initialize a cli.Param.
// It adds persistent flags for kubeconfig, context, namespace, host, token, API path, and TLS verification.
//
// Parameters:
//   - cmd: A pointer to a cobra.Command to which the flags will be added.
//
// This function does not return any value.
func AddResultsOptions(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.PersistentFlags().StringP(
                kubeConfig, "k", "",
                "kubectl config file (default: $HOME/.kube/config)")

        cmd.PersistentFlags().StringP(
                context, "c", "",
                "name of the kubeconfig context to use (default: kubectl config current-context)")

        cmd.PersistentFlags().StringP(
                namespace, "n", "",
                "namespace to use (default: from $KUBECONFIG)")
        _ = cmd.RegisterFlagCompletionFunc(namespace,
                func(_ *cobra.Command, args []string, _ string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                        return formatted.BaseCompletion("namespace", args)
                }</span>,
        )

        <span class="cov8" title="1">cmd.PersistentFlags().StringP(
                host, "", "",
                "host to use (default: value provided in config set command)")

        cmd.PersistentFlags().StringP(
                token, "", "",
                "bearer token to use (default: value provided in config set command)")

        cmd.PersistentFlags().StringP(
                apiPath, "", "",
                "api path to use (default: value provided in config set command)")

        cmd.PersistentFlags().BoolP(
                insecureSkipTLSVerify, "", false,
                "skip server's certificate validation for requests (default: false)")</span>

}

// GetResultsOptions retrieves the global Results Options that are not passed to subcommands.
// It extracts flag values from the provided command and returns them as a ResultsOptions struct.
//
// Parameters:
//   - cmd: A pointer to a cobra.Command from which to retrieve flag values.
//
// Returns:
//   - ResultsOptions: A struct containing the extracted flag values for kubeconfig, context,
//     namespace, host, token, API path, and TLS verification settings.
func GetResultsOptions(cmd *cobra.Command) ResultsOptions <span class="cov8" title="1">{
        kcPath, _ := cmd.Flags().GetString(kubeConfig)
        kubeContext, _ := cmd.Flags().GetString(context)
        ns, _ := cmd.Flags().GetString(namespace)
        h, _ := cmd.Flags().GetString(host)
        t, _ := cmd.Flags().GetString(token)
        ap, _ := cmd.Flags().GetString(apiPath)
        skipTLSVerify, _ := cmd.Flags().GetBool(insecureSkipTLSVerify)
        return ResultsOptions{
                KubeConfig:            kcPath,
                Context:               kubeContext,
                Namespace:             ns,
                Host:                  h,
                Token:                 t,
                APIPath:               ap,
                InsecureSkipTLSVerify: skipTLSVerify,
        }
}</span>

// InitParams initializes cli.Params based on flags defined in the command.
//
// This function retrieves flag values from the provided cobra.Command and sets
// the corresponding values in the common.Params object. It handles flags for
// kubeconfig, context, namespace, host, token, API path, and TLS verification.
//
// Parameters:
//   - p: A common.Params object to be initialized with flag values.
//   - cmd: A *cobra.Command object containing the flags to be processed.
//
// Returns:
//   - An error if any flag retrieval operation fails, nil otherwise.
//
// Note: This function uses cmd.Flags() instead of cmd.PersistentFlags() to
// access flags, which may break symmetry with AddResultsOptions. This is because
// it could be a subcommand trying to access flags defined by the parent command.
func InitParams(p common.Params, cmd *cobra.Command) error <span class="cov8" title="1">{
        // First set kubeconfig and context
        kcPath, err := cmd.Flags().GetString(kubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.SetKubeConfigPath(kcPath)

        kubeContext, err := cmd.Flags().GetString(context)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.SetKubeContext(kubeContext)

        // Then set namespace, which will use the kubeconfig and context if needed
        ns, err := cmd.Flags().GetString(namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.SetNamespace(ns)

        // Set other flags
        h, err := cmd.Flags().GetString(host)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if h != "" </span><span class="cov8" title="1">{
                p.SetHost(h)
        }</span>

        <span class="cov8" title="1">t, err := cmd.Flags().GetString(token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if t != "" </span><span class="cov8" title="1">{
                p.SetToken(t)
        }</span>

        <span class="cov8" title="1">ap, err := cmd.Flags().GetString(apiPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if ap != "" </span><span class="cov8" title="1">{
                p.SetAPIPath(ap)
        }</span>

        <span class="cov8" title="1">skipTLSVerify, err := cmd.Flags().GetBool(insecureSkipTLSVerify)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">p.SetSkipTLSVerify(skipTLSVerify)

        return nil</span>
}

// AnyResultsFlagChanged checks if any of the Results flags (host, token, api-path, insecure-skip-tls-verify)
// have been changed from their default values.
//
// Parameters:
//   - cmd: A pointer to a cobra.Command to check the flags.
//
// Returns:
//   - bool: true if any of the Results flags have been changed, false otherwise.
func AnyResultsFlagChanged(cmd *cobra.Command) bool <span class="cov0" title="0">{
        return cmd.Flags().Changed(host) ||
                cmd.Flags().Changed(token) ||
                cmd.Flags().Changed(apiPath) ||
                cmd.Flags().Changed(insecureSkipTLSVerify)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package options

import "github.com/tektoncd/results/pkg/cli/client"

// DescribeOptions contains options for describing a resource.
type DescribeOptions struct {
        Client       *client.RESTClient
        UID          string
        ResourceType string
        ResourceName string
}

// GetLabel implements FilterOptions interface
func (o *DescribeOptions) GetLabel() string <span class="cov0" title="0">{
        return "" // Label field is not relevant in the describe commands
}</span>

// GetResourceName implements FilterOptions interface
func (o *DescribeOptions) GetResourceName() string <span class="cov0" title="0">{
        return o.ResourceName
}</span>

// GetPipelineRun implements FilterOptions interface
func (o *DescribeOptions) GetPipelineRun() string <span class="cov0" title="0">{
        return "" // PipelineRun field is not relevant in the describe commands
}</span>

// GetResourceType implements FilterOptions interface
func (o *DescribeOptions) GetResourceType() string <span class="cov0" title="0">{
        return o.ResourceType
}</span>

// GetUID implements FilterOptions interface
func (o *DescribeOptions) GetUID() string <span class="cov0" title="0">{
        return o.UID
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package options

import (
        "github.com/tektoncd/results/pkg/cli/client"
)

// ListOptions holds the options for listing resources
type ListOptions struct {
        Client        *client.RESTClient
        Limit         int32
        AllNamespaces bool
        Label         string
        PipelineRun   string
        SinglePage    bool
        ResourceName  string
        ResourceType  string
}

// GetLabel implements FilterOptions interface
func (o *ListOptions) GetLabel() string <span class="cov0" title="0">{
        return o.Label
}</span>

// GetResourceName implements FilterOptions interface
func (o *ListOptions) GetResourceName() string <span class="cov0" title="0">{
        return o.ResourceName
}</span>

// GetPipelineRun implements FilterOptions interface
func (o *ListOptions) GetPipelineRun() string <span class="cov0" title="0">{
        return o.PipelineRun
}</span>

// GetResourceType implements FilterOptions interface
func (o *ListOptions) GetResourceType() string <span class="cov0" title="0">{
        return o.ResourceType
}</span>

// GetUID implements FilterOptions interface
func (o *ListOptions) GetUID() string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package options

import "github.com/tektoncd/results/pkg/cli/client"

// LogsOptions contains options for fetching logs for a resource.
type LogsOptions struct {
        Client       *client.RESTClient
        UID          string
        ResourceType string
        ResourceName string
}

// GetLabel implements FilterOptions interface
func (o *LogsOptions) GetLabel() string <span class="cov0" title="0">{
        return "" // Label field is not relevant in the logs commands
}</span>

// GetResourceName implements FilterOptions interface
func (o *LogsOptions) GetResourceName() string <span class="cov0" title="0">{
        return o.ResourceName
}</span>

// GetPipelineRun implements FilterOptions interface
func (o *LogsOptions) GetPipelineRun() string <span class="cov0" title="0">{
        return "" // PipelineRun field is not relevant in the logs commands
}</span>

// GetResourceType implements FilterOptions interface
func (o *LogsOptions) GetResourceType() string <span class="cov0" title="0">{
        return o.ResourceType
}</span>

// GetUID implements FilterOptions interface
func (o *LogsOptions) GetUID() string <span class="cov0" title="0">{
        return o.UID
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package testutils

import (
        "bytes"

        "github.com/spf13/cobra"
)

// ExecuteCommand executes the root command passing the args and returns
// the output as a string and error
func ExecuteCommand(c *cobra.Command, args ...string) (string, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        c.SetOut(buf)
        c.SetErr(buf)
        c.SetArgs(args)
        c.SilenceUsage = true

        _, err := c.ExecuteC()

        return buf.String(), err
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">// Package testutils provides test utility functions for the CLI package
package testutils

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "testing"

        "github.com/tektoncd/results/pkg/cli/common"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/clientcmd"
)

// CreateTestKubeconfig creates a temporary kubeconfig file for testing
// If namespace is empty, no namespace is set in the context
func CreateTestKubeconfig(t *testing.T, namespace string) string <span class="cov0" title="0">{
        t.Helper()

        dir := t.TempDir()
        kubeconfigPath := filepath.Join(dir, "kubeconfig.yaml")

        // Build context section with optional namespace
        contextSection := `    cluster: test-cluster
    user: test-user`
        if namespace != "" </span><span class="cov0" title="0">{
                contextSection = fmt.Sprintf(`    cluster: test-cluster
    namespace: %s
    user: test-user`, namespace)
        }</span>

        <span class="cov0" title="0">kubeconfigContent := fmt.Sprintf(`apiVersion: v1
clusters:
- cluster:
    server: http://test-host
  name: test-cluster
contexts:
- context:
%s
  name: test-context
current-context: test-context
kind: Config
preferences: {}
users:
- name: test-user
`, contextSection)

        if err := os.WriteFile(kubeconfigPath, []byte(kubeconfigContent), 0600); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write kubeconfig: %v", err)
        }</span>

        <span class="cov0" title="0">return kubeconfigPath</span>
}

// ReadKubeconfigExtensionRaw reads the tekton-results extension from a kubeconfig file as raw data
// This avoids import cycles by not depending on config package types
func ReadKubeconfigExtensionRaw(t *testing.T, kubeconfigPath, extensionName string) ([]byte, error) <span class="cov0" title="0">{
        t.Helper()

        configLoadingRules := &amp;clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfigPath}
        apiConfig, err := configLoadingRules.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">context := apiConfig.Contexts[apiConfig.CurrentContext]
        if context == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Use the shared function from common package to build context info
        <span class="cov0" title="0">configContextName, _, _, err := common.BuildConfigContextInfo(context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Look for config context using direct lookup
        <span class="cov0" title="0">configContext, exists := apiConfig.Contexts[configContextName]
        if !exists || configContext.Extensions == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">extensionData, exists := configContext.Extensions[extensionName]
        if !exists </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Return the raw extension data
        <span class="cov0" title="0">return extensionData.(*runtime.Unknown).Raw, nil</span>
}

// ReadKubeconfigExtension reads and unmarshals a kubeconfig extension into the provided target
// The target parameter should be a pointer to the struct you want to unmarshal into
// Returns true if the extension was found and unmarshaled successfully, false if not found
func ReadKubeconfigExtension(t *testing.T, kubeconfigPath, extensionName string, target interface{}) (bool, error) <span class="cov0" title="0">{
        t.Helper()

        rawData, err := ReadKubeconfigExtensionRaw(t, kubeconfigPath, extensionName)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if rawData == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // Unmarshal the raw data into the target
        <span class="cov0" title="0">if err := json.Unmarshal(rawData, target); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}

// UpdateKubeconfigNamespace updates the namespace of the current context in a kubeconfig file
func UpdateKubeconfigNamespace(t *testing.T, kubeconfigPath, newNamespace string) <span class="cov0" title="0">{
        t.Helper()

        // Load the kubeconfig
        configLoadingRules := &amp;clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfigPath}
        apiConfig, err := configLoadingRules.Load()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to load kubeconfig: %v", err)
        }</span>

        // Update the namespace of the current context
        <span class="cov0" title="0">currentContext := apiConfig.Contexts[apiConfig.CurrentContext]
        if currentContext == nil </span><span class="cov0" title="0">{
                t.Fatalf("Current context not found in kubeconfig")
        }</span>

        <span class="cov0" title="0">currentContext.Namespace = newNamespace

        // Write the updated kubeconfig
        if err := clientcmd.WriteToFile(*apiConfig, kubeconfigPath); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to write updated kubeconfig: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package testutils

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"
        "net/url"
        "strings"
        "time"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/results/pkg/cli/client"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/protobuf/encoding/protojson"
        "k8s.io/client-go/transport"
)

// filterRecordsByNamespace filters records based on the namespace in the URL path
func filterRecordsByNamespace(records []*pb.Record, urlPath string) []*pb.Record <span class="cov0" title="0">{
        // Extract parent from URL path like "/parents/{parent}/results/-/records"
        // parent can be:
        // - "namespace" for specific namespace (e.g., "production", "default")
        // - "-" for all namespaces

        parts := strings.Split(urlPath, "/")
        var parent string
        for i, part := range parts </span><span class="cov0" title="0">{
                if part == "parents" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov0" title="0">{
                        parent = parts[i+1]
                        break</span>
                }
        }

        // If parent is "-", return all records (all namespaces mode)
        <span class="cov0" title="0">if parent == "-" </span><span class="cov0" title="0">{
                return records
        }</span>

        // Parent is the namespace directly (URL structure: /parents/{namespace}/results/-/records)
        <span class="cov0" title="0">targetNamespace := parent

        // Filter records by namespace
        var filteredRecords []*pb.Record
        for _, record := range records </span><span class="cov0" title="0">{
                // Parse the PipelineRun data to get the namespace
                var pipelineRun v1.PipelineRun
                if err := json.Unmarshal(record.Data.Value, &amp;pipelineRun); err == nil </span><span class="cov0" title="0">{
                        if pipelineRun.Namespace == targetNamespace </span><span class="cov0" title="0">{
                                filteredRecords = append(filteredRecords, record)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filteredRecords</span>
}

// filterRecordsByPipelineName filters records based on pipeline name from the filter query parameter
func filterRecordsByPipelineName(records []*pb.Record, filterQuery string) []*pb.Record <span class="cov0" title="0">{
        // Parse the filter query to extract pipeline name filter
        // Example filter: "(data_type==\"tekton.dev/v1.PipelineRun\" || data_type==\"tekton.dev/v1beta1.PipelineRun\") &amp;&amp; data.metadata.name.contains(\"build-pipeline\")"

        // Look for the pattern: data.metadata.name.contains("pipeline-name")
        nameFilterPrefix := "data.metadata.name.contains(\""
        nameFilterSuffix := "\")"

        startIdx := strings.Index(filterQuery, nameFilterPrefix)
        if startIdx == -1 </span><span class="cov0" title="0">{
                // No pipeline name filter found, return all records
                return records
        }</span>

        <span class="cov0" title="0">startIdx += len(nameFilterPrefix)
        endIdx := strings.Index(filterQuery[startIdx:], nameFilterSuffix)
        if endIdx == -1 </span><span class="cov0" title="0">{
                // Malformed filter, return all records
                return records
        }</span>

        <span class="cov0" title="0">pipelineName := filterQuery[startIdx : startIdx+endIdx]

        // Filter records by pipeline name (contains match)
        var filteredRecords []*pb.Record
        for _, record := range records </span><span class="cov0" title="0">{
                // Parse the PipelineRun data to get the name
                var pipelineRun v1.PipelineRun
                if err := json.Unmarshal(record.Data.Value, &amp;pipelineRun); err == nil </span><span class="cov0" title="0">{
                        if strings.Contains(pipelineRun.Name, pipelineName) </span><span class="cov0" title="0">{
                                filteredRecords = append(filteredRecords, record)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filteredRecords</span>
}

// filterRecordsByLabels filters records based on label filters from the filter query parameter
func filterRecordsByLabels(records []*pb.Record, filterQuery string) []*pb.Record <span class="cov0" title="0">{
        // Parse the filter query to extract label filters
        // Example filter: "data.metadata.labels[\"app\"]==\"myapp\" &amp;&amp; data.metadata.labels[\"env\"]==\"prod\""

        // Look for the pattern: data.metadata.labels["key"]=="value"
        labelFilterPrefix := "data.metadata.labels[\""
        labelFilterSuffix := "\"]=="

        // Extract all label filters from the query
        var labelFilters []struct {
                key   string
                value string
        }

        searchStart := 0
        for </span><span class="cov0" title="0">{
                startIdx := strings.Index(filterQuery[searchStart:], labelFilterPrefix)
                if startIdx == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">startIdx += searchStart + len(labelFilterPrefix)

                // Find the end of the key
                keyEndIdx := strings.Index(filterQuery[startIdx:], labelFilterSuffix)
                if keyEndIdx == -1 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">key := filterQuery[startIdx : startIdx+keyEndIdx]
                valueStartIdx := startIdx + keyEndIdx + len(labelFilterSuffix)

                // Find the value (enclosed in quotes)
                if valueStartIdx &gt;= len(filterQuery) || filterQuery[valueStartIdx] != '"' </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">valueStartIdx++ // Skip opening quote

                valueEndIdx := strings.Index(filterQuery[valueStartIdx:], "\"")
                if valueEndIdx == -1 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">value := filterQuery[valueStartIdx : valueStartIdx+valueEndIdx]
                labelFilters = append(labelFilters, struct {
                        key   string
                        value string
                }{key: key, value: value})

                searchStart = valueStartIdx + valueEndIdx + 1</span>
        }

        // If no label filters found, return all records
        <span class="cov0" title="0">if len(labelFilters) == 0 </span><span class="cov0" title="0">{
                return records
        }</span>

        // Filter records by labels (all labels must match)
        <span class="cov0" title="0">var filteredRecords []*pb.Record
        for _, record := range records </span><span class="cov0" title="0">{
                // Parse the PipelineRun data to get the labels
                var pipelineRun v1.PipelineRun
                if err := json.Unmarshal(record.Data.Value, &amp;pipelineRun); err == nil </span><span class="cov0" title="0">{
                        // Check if all label filters match
                        allMatch := true
                        for _, labelFilter := range labelFilters </span><span class="cov0" title="0">{
                                if pipelineRun.Labels == nil </span><span class="cov0" title="0">{
                                        allMatch = false
                                        break</span>
                                }
                                <span class="cov0" title="0">if labelValue, exists := pipelineRun.Labels[labelFilter.key]; !exists || labelValue != labelFilter.value </span><span class="cov0" title="0">{
                                        allMatch = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if allMatch </span><span class="cov0" title="0">{
                                filteredRecords = append(filteredRecords, record)
                        }</span>
                }
        }

        <span class="cov0" title="0">return filteredRecords</span>
}

// MockRESTClientFromRecords creates a mock REST client with comprehensive filtering support
func MockRESTClientFromRecords(records []*pb.Record) (*client.RESTClient, error) <span class="cov0" title="0">{
        // Create HTTP server that handles multiple endpoints with filtering
        server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json")

                switch </span>{
                case r.Method == "GET" &amp;&amp; strings.Contains(r.URL.Path, "/records"):<span class="cov0" title="0">
                        // Handle ListRecords with namespace and pipeline name filtering
                        filteredRecords := filterRecordsByNamespace(records, r.URL.Path)

                        // Apply filtering from query parameters
                        if filter := r.URL.Query().Get("filter"); filter != "" </span><span class="cov0" title="0">{
                                filteredRecords = filterRecordsByPipelineName(filteredRecords, filter)
                                filteredRecords = filterRecordsByLabels(filteredRecords, filter)
                        }</span>

                        // Create response with filtered records (no pagination)
                        <span class="cov0" title="0">grpcResp := &amp;pb.ListRecordsResponse{
                                Records:       filteredRecords,
                                NextPageToken: "", // No pagination support
                        }
                        jsonData, err := protojson.Marshal(grpcResp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to marshal records response", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">if _, err := w.Write(jsonData); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to write response", http.StatusInternalServerError)
                        }</span>
                        <span class="cov0" title="0">return</span>

                case r.Method == "GET" &amp;&amp; strings.Contains(r.URL.Path, "/logs"):<span class="cov0" title="0">
                        // Handle logs endpoints - can be extended as needed
                        // For now, return empty response
                        logsResp := &amp;pb.ListRecordsResponse{Records: nil}
                        jsonData, err := protojson.Marshal(logsResp)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to marshal logs response", http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">if _, err := w.Write(jsonData); err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to write response", http.StatusInternalServerError)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">http.NotFound(w, r)</span>
        }))

        <span class="cov0" title="0">serverURL, err := url.Parse(server.URL + "/apis/results.tekton.dev/v1alpha2")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse server URL: %w", err)
        }</span>

        <span class="cov0" title="0">config := &amp;client.Config{
                URL:       serverURL,
                Timeout:   30 * time.Second,
                Transport: &amp;transport.Config{},
        }

        restClient, err := client.NewRESTClient(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create REST client: %w", err)
        }</span>

        <span class="cov0" title="0">return restClient, nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package testutils

import (
        "github.com/tektoncd/results/pkg/cli/client"
        "github.com/tektoncd/results/pkg/cli/common"
)

// Params implements common.Params interface for testing
// This allows injecting fake/mock clients during tests
type Params struct {
        kubeConfigPath string
        kubeContext    string
        namespace      string
        host           string
        token          string
        apiPath        string
        skipTLSVerify  bool

        // Simple client storage for testing
        restClient *client.RESTClient
}

// Ensure Params implements the interface
var _ common.Params = (*Params)(nil)

// NewParams creates a new test Params with sensible defaults
func NewParams() *Params <span class="cov0" title="0">{
        return &amp;Params{
                host:      "http://localhost:8080",
                namespace: "default",
        }
}</span>

// SetKubeConfigPath sets the kubeconfig file path
func (p *Params) SetKubeConfigPath(path string) <span class="cov0" title="0">{ p.kubeConfigPath = path }</span>

// KubeConfigPath returns the kubeconfig file path
func (p *Params) KubeConfigPath() string <span class="cov0" title="0">{ return p.kubeConfigPath }</span>

// SetKubeContext sets the kubernetes context
func (p *Params) SetKubeContext(context string) <span class="cov0" title="0">{ p.kubeContext = context }</span>

// KubeContext returns the kubernetes context
func (p *Params) KubeContext() string <span class="cov0" title="0">{ return p.kubeContext }</span>

// SetNamespace sets the kubernetes namespace, preserving default if empty
func (p *Params) SetNamespace(ns string) <span class="cov0" title="0">{
        // For testing, simulate the kubeconfig resolution behavior:
        // If empty string is provided, keep the existing namespace (simulates kubeconfig default)
        if ns != "" </span><span class="cov0" title="0">{
                p.namespace = ns
        }</span>
        // If ns is empty, keep the existing namespace (set in NewParams() as "default")
}

// Namespace returns the kubernetes namespace
func (p *Params) Namespace() string <span class="cov0" title="0">{ return p.namespace }</span>

// SetHost sets the API host
func (p *Params) SetHost(host string) <span class="cov0" title="0">{ p.host = host }</span>

// Host returns the API host
func (p *Params) Host() string <span class="cov0" title="0">{ return p.host }</span>

// SetToken sets the authentication token
func (p *Params) SetToken(token string) <span class="cov0" title="0">{ p.token = token }</span>

// Token returns the authentication token
func (p *Params) Token() string <span class="cov0" title="0">{ return p.token }</span>

// SetAPIPath sets the API path
func (p *Params) SetAPIPath(path string) <span class="cov0" title="0">{ p.apiPath = path }</span>

// APIPath returns the API path
func (p *Params) APIPath() string <span class="cov0" title="0">{ return p.apiPath }</span>

// SetSkipTLSVerify sets whether to skip TLS verification
func (p *Params) SetSkipTLSVerify(skip bool) <span class="cov0" title="0">{ p.skipTLSVerify = skip }</span>

// SkipTLSVerify returns whether to skip TLS verification
func (p *Params) SkipTLSVerify() bool <span class="cov0" title="0">{ return p.skipTLSVerify }</span>

// SetRESTClient injects a REST client for testing purposes
func (p *Params) SetRESTClient(client *client.RESTClient) <span class="cov0" title="0">{
        p.restClient = client
}</span>

// RESTClient returns the injected REST client for testing
func (p *Params) RESTClient() *client.RESTClient <span class="cov0" title="0">{
        return p.restClient
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package testutils

import (
        "time"

        "github.com/jonboulle/clockwork"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/protobuf/types/known/timestamppb"
)

const (
        // Common test constants
        defaultNamespace     = "default"
        defaultConditionType = "Succeeded"
        pipelineRunKind      = "tekton.dev/v1.PipelineRun"
)

// TimePtr converts time.Time to *time.Time
func TimePtr(t time.Time) *time.Time <span class="cov0" title="0">{
        return &amp;t
}</span>

// CreateTestRecord creates a test record with all possible options
// Use empty string for namespace to use default, nil for labels to omit them
func CreateTestRecord(clock clockwork.Clock, name, uid, namespace string, startTime, endTime *time.Time, conditionStatus string, labels map[string]string) *pb.Record <span class="cov0" title="0">{
        // Use default namespace if not specified
        if namespace == "" </span><span class="cov0" title="0">{
                namespace = defaultNamespace
        }</span>

        <span class="cov0" title="0">conditionType := defaultConditionType
        createTime := clock.Now().Add(-5 * time.Minute)

        var completionTimeJSON string
        if endTime != nil </span><span class="cov0" title="0">{
                completionTimeJSON = `"completionTime": "` + endTime.Format(time.RFC3339) + `",`
        }</span>

        <span class="cov0" title="0">var startTimeJSON string
        if startTime != nil </span><span class="cov0" title="0">{
                startTimeJSON = `"startTime": "` + startTime.Format(time.RFC3339) + `",`
        }</span>

        // Build labels JSON
        <span class="cov0" title="0">var labelsJSON string
        if len(labels) &gt; 0 </span><span class="cov0" title="0">{
                labelsJSON = `,"labels": {`
                first := true
                for key, value := range labels </span><span class="cov0" title="0">{
                        if !first </span><span class="cov0" title="0">{
                                labelsJSON += ","
                        }</span>
                        <span class="cov0" title="0">labelsJSON += `"` + key + `": "` + value + `"`
                        first = false</span>
                }
                <span class="cov0" title="0">labelsJSON += `}`</span>
        }

        <span class="cov0" title="0">return &amp;pb.Record{
                Name:       namespace + "/results/" + name + "/records/" + name,
                Uid:        "record-" + uid,
                CreateTime: timestamppb.New(createTime),
                Data: &amp;pb.Any{
                        Type: pipelineRunKind,
                        Value: []byte(`{
                                "apiVersion": "tekton.dev/v1",
                                "kind": "PipelineRun",
                                "metadata": {
                                        "name": "` + name + `",
                                        "namespace": "` + namespace + `",
                                        "uid": "` + uid + `"` + labelsJSON + `
                                },
                                "status": {
                                        ` + startTimeJSON + `
                                        ` + completionTimeJSON + `
                                        "conditions": [
                                                {
                                                        "type": "` + conditionType + `",
                                                        "status": "` + conditionStatus + `"
                                                }
                                        ]
                                }
                        }`),
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package converter

import (
        "context"
        "encoding/json"

        "github.com/google/martian/v3/log"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/results/pkg/api/server/db"
        "github.com/tektoncd/results/pkg/api/server/db/errors"
        "go.uber.org/zap"
        "gorm.io/gorm"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
)

// New provides an instance of converter which converts v1beta1 to v1 API in db
// revive:disable:unexported-return
func New(logger *zap.SugaredLogger, db *gorm.DB, limit int) *convertor <span class="cov0" title="0">{
        return &amp;convertor{
                db:     db,
                logger: logger,
                limit:  limit,
        }
}</span>

type convertor struct {
        logger *zap.SugaredLogger
        db     *gorm.DB
        limit  int
}

func (c *convertor) Start(ctx context.Context) <span class="cov0" title="0">{
        c.convert(ctx, "tekton.dev/v1beta1.TaskRun")
        c.convert(ctx, "tekton.dev/v1beta1.PipelineRun")
}</span>

func (c *convertor) convert(ctx context.Context, recType string) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        var conv func(ctx context.Context, record *db.Record) error
        switch recType </span>{
        case "tekton.dev/v1beta1.TaskRun":<span class="cov0" title="0">
                conv = c.convertTR</span>
        case "tekton.dev/v1beta1.PipelineRun":<span class="cov0" title="0">
                conv = c.convertPR</span>
        default:<span class="cov0" title="0">
                logger.Error("Incorrect Type of record for conversion")</span>
        }
        <span class="cov0" title="0">pending := true
        for pending </span><span class="cov0" title="0">{
                records, err := c.getRecords(ctx, recType)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to fetch records", err)
                        continue</span>
                }
                <span class="cov0" title="0">if len(records) == 0 </span><span class="cov0" title="0">{
                        log.Infof("No %s in db", recType)
                        pending = false
                }</span>
                <span class="cov0" title="0">for i := range records </span><span class="cov0" title="0">{
                        err := conv(ctx, &amp;records[i])
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("failed to convert record name:%s id: %s  err: %v", records[i].Name, records[i].ID, err.Error())
                        }</span>
                }
                <span class="cov0" title="0">err = c.setRecords(ctx, records)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to set records %v", err.Error())
                        continue</span>
                }
        }
}

func (c *convertor) convertTR(ctx context.Context, record *db.Record) error <span class="cov0" title="0">{
        var tr v1beta1.TaskRun //nolint:staticcheck
        err := json.Unmarshal(record.Data, &amp;tr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">trV1 := &amp;v1.TaskRun{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "tekton.dev/v1",
                        Kind:       "TaskRun"},
        }

        if err := tr.ConvertTo(ctx, trV1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, _ := json.Marshal(trV1)
        record.Data = data
        record.Type = "tekton.dev/v1.TaskRun"
        return nil</span>
}

func (c *convertor) convertPR(ctx context.Context, record *db.Record) error <span class="cov0" title="0">{
        var pr v1beta1.PipelineRun //nolint:staticcheck
        err := json.Unmarshal(record.Data, &amp;pr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">trV1 := &amp;v1.PipelineRun{
                TypeMeta: metav1.TypeMeta{
                        APIVersion: "tekton.dev/v1",
                        Kind:       "PipelineRun"},
        }

        if err := pr.ConvertTo(ctx, trV1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">data, _ := json.Marshal(trV1)
        record.Data = data
        record.Type = "tekton.dev/v1.PipelineRun"
        return nil</span>
}

func (c *convertor) getRecords(ctx context.Context, recType string) ([]db.Record, error) <span class="cov0" title="0">{
        txn := c.db.WithContext(ctx)
        records := []db.Record{}
        q := txn.Limit(c.limit).Find(&amp;records, &amp;db.Record{Type: recType})
        if err := errors.Wrap(q.Error); err != nil </span><span class="cov0" title="0">{
                return records, err
        }</span>
        <span class="cov0" title="0">return records, nil</span>
}

func (c *convertor) setRecords(ctx context.Context, records []db.Record) error <span class="cov0" title="0">{
        var err error
        txn := c.db.WithContext(ctx)
        transaction := txn.Begin()
        for i := range records </span><span class="cov0" title="0">{
                transaction.Model(&amp;records[i]).Updates(db.Record{Data: records[i].Data, Type: records[i].Type})
        }</span>
        <span class="cov0" title="0">err = transaction.Commit().Error
        return err</span>

}
</pre>
		
		<pre class="file" id="file77" style="display: none">package jsonutil

import (
        "encoding/json"
        "testing"
)

// AnyBytes returns the marshalled bytes of an Any proto wrapping the given
// message, or causes the test to fail.
func AnyBytes(t testing.TB, v any) []byte <span class="cov0" title="0">{
        t.Helper()
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error marshalling Any proto: %v", err)
        }</span>
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package protoutil provides utilities for manipulating protos in tests.
package protoutil

import (
        "testing"

        "github.com/google/go-cmp/cmp"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        fbpb "google.golang.org/genproto/googleapis/api/annotations"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/reflect/protoreflect"
        "google.golang.org/protobuf/testing/protocmp"
        "google.golang.org/protobuf/types/descriptorpb"
        "google.golang.org/protobuf/types/known/anypb"
)

// Any wraps a proto message in an Any proto, or causes the test to fail.
func Any(t testing.TB, m proto.Message) *anypb.Any <span class="cov0" title="0">{
        t.Helper()
        a, err := anypb.New(m)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error wrapping Any proto: %v", err)
        }</span>
        <span class="cov0" title="0">return a</span>
}

// AnyBytes returns the marshalled bytes of an Any proto wrapping the given
// message, or causes the test to fail.
func AnyBytes(t testing.TB, m proto.Message) []byte <span class="cov0" title="0">{
        t.Helper()
        b, err := proto.Marshal(Any(t, m))
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("error marshalling Any proto: %v", err)
        }</span>
        <span class="cov0" title="0">return b</span>
}

// ClearOutputOnly clears any proto fields marked as OUTPUT_ONLY.
func ClearOutputOnly(pb proto.Message) <span class="cov8" title="1">{
        m := pb.ProtoReflect()
        m.Range(func(fd protoreflect.FieldDescriptor, _ protoreflect.Value) bool </span><span class="cov8" title="1">{
                opts := fd.Options().(*descriptorpb.FieldOptions)
                for _, b := range proto.GetExtension(opts, fbpb.E_FieldBehavior).([]fbpb.FieldBehavior) </span><span class="cov8" title="1">{
                        if b == fbpb.FieldBehavior_OUTPUT_ONLY </span><span class="cov8" title="1">{
                                m.Clear(fd)
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        })
}

// IgnoreResultOutputOnly ignores all fields marked OUTPUT_ONLY during cmp
// comparisons.
func IgnoreResultOutputOnly() cmp.Option <span class="cov0" title="0">{
        // We might be able to something fancy with protocmp / cmp to filter
        // by the actual extension value, but for now this is straightforward
        // and works.
        return protocmp.IgnoreFields(&amp;pb.Result{}, "update_time", "updated_time", "etag", "uid", "id", "create_time", "created_time")
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package logs

import (
        "bytes"

        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/genproto/googleapis/api/httpbody"
)

const (
        // DefaultBufferSize is the default buffer size. This based on the recommended
        // gRPC message size for streamed content, which ranges from 16 to 64 KiB. Choosing 32 KiB as a
        // middle ground between the two.
        DefaultBufferSize = 64 * 1024
)

// LogSender is an interface that defines the contract for sending log data.
type LogSender interface {
        Send(*pb.Log) error
}

// HTTPSender is an interface that defines the contract for sending log data in HTTP body.
type HTTPSender interface {
        Send(*httpbody.HttpBody) error
}

// BufferedLog is in memory buffered log sender.
type BufferedLog struct {
        sender any
        name   string
        size   int
        buffer bytes.Buffer
}

// NewBufferedWriter returns an io.Writer that writes log chunk messages to the gRPC sender for the
// named Tekton result. The chunk size determines the maximum size of a single sent message - if
// less than zero, this defaults to DefaultBufferSize.
func NewBufferedWriter(sender LogSender, name string, size int) *BufferedLog <span class="cov8" title="1">{
        if size &lt; 1 </span><span class="cov0" title="0">{
                size = DefaultBufferSize
        }</span>

        <span class="cov8" title="1">return &amp;BufferedLog{
                sender: sender,
                name:   name,
                size:   size,
                buffer: *bytes.NewBuffer(make([]byte, 0)),
        }</span>
}

// NewBufferedHTTPWriter returns an io.Writer that writes log chunk messages to the gRPC sender for the
// named Tekton result. The chunk size determines the maximum size of a single sent message - if
// less than zero, this defaults to DefaultBufferSize.
func NewBufferedHTTPWriter(sender HTTPSender, name string, size int) *BufferedLog <span class="cov8" title="1">{
        if size &lt; 1 </span><span class="cov0" title="0">{
                size = DefaultBufferSize
        }</span>

        <span class="cov8" title="1">return &amp;BufferedLog{
                sender: sender,
                name:   name,
                size:   size,
                buffer: *bytes.NewBuffer(make([]byte, 0)),
        }</span>
}

// Write sends bytes to the buffer and/or consumer (e.g., gRPC stream).
// This method combines the bytes from the buffer with a new portion of p bytes in memory.
// Bytes larger than the buffer size will be truncated and sent to the consumer,
// while the remaining bytes will be stored in the buffer.
func (w *BufferedLog) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        allBts := w.buffer.Bytes()
        allBts = append(allBts, p...)

        btsLength := len(allBts)
        remainBytes := btsLength % w.size

        amountChunks := (btsLength - remainBytes) / w.size

        for i := 0; i &lt; amountChunks; i++ </span><span class="cov8" title="1">{
                offSet := i * w.size
                _, err = w.sendBytes(allBts[offSet : offSet+w.size])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        }

        <span class="cov8" title="1">var b []byte
        if remainBytes &gt; 0 </span><span class="cov8" title="1">{
                b = allBts[(amountChunks * w.size):]
        }</span>

        <span class="cov8" title="1">w.buffer.Reset()

        if _, err = w.buffer.Write(b); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return len(p), err</span>
}

// Flush sends all remaining bytes in the buffer to consumer.
func (w *BufferedLog) Flush() (int, error) <span class="cov8" title="1">{
        if len(w.buffer.Bytes()) &gt; 0 </span><span class="cov8" title="1">{
                return w.sendBytes(w.buffer.Bytes())
        }</span>
        <span class="cov8" title="1">return 0, nil</span>
}

// sendBytes sends the provided byte array over gRPC.
func (w *BufferedLog) sendBytes(p []byte) (int, error) <span class="cov8" title="1">{
        var err error
        switch t := w.sender.(type) </span>{
        case HTTPSender:<span class="cov8" title="1">
                err = t.Send(&amp;httpbody.HttpBody{
                        ContentType: "text/plain",
                        Data:        p,
                })</span>
        case LogSender:<span class="cov8" title="1">
                err = t.Send(&amp;pb.Log{
                        Name: w.name,
                        Data: p,
                })</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return len(p), nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package pipelinerunmetrics

import (
        "context"
        "errors"
        "time"

        "github.com/jonboulle/clockwork"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/results/pkg/apis/config"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/metrics"
)

var (
        prDeleteCount        = stats.Int64("pipelinerun_delete_count", "total number of deleted pipelineruns", stats.UnitDimensionless)
        prDeleteCountView    *view.View
        prDeleteDuration     = stats.Float64("pipelinerun_delete_duration_seconds", "the pipelinerun deletion time in seconds", stats.UnitSeconds)
        prDeleteDurationView *view.View
        pipelineTag          = tag.MustNewKey("pipeline")
        namespaceTag         = tag.MustNewKey("namespace")
        statusTag            = tag.MustNewKey("status")
)

// Recorder is used to actually record PipelineRun metrics
type Recorder struct {
        clock clockwork.Clock
}

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder() *Recorder <span class="cov0" title="0">{
        return &amp;Recorder{clock: clockwork.NewRealClock()}
}</span>

func viewRegister(logger *zap.SugaredLogger, cfg *config.Metrics) error <span class="cov8" title="1">{
        var tags []tag.Key
        switch cfg.PipelinerunLevel </span>{
        case config.PipelinerunLevelAtPipeline:<span class="cov8" title="1">
                tags = []tag.Key{pipelineTag}</span>
        case config.PipelinerunLevelAtNS:<span class="cov0" title="0">
                tags = []tag.Key{}</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid config for PipelinerunLevel: " + cfg.PipelinerunLevel)</span>
        }
        <span class="cov8" title="1">prDeleteCountView = &amp;view.View{
                Description: prDeleteCount.Description(),
                TagKeys:     []tag.Key{statusTag, namespaceTag},
                Measure:     prDeleteCount,
                Aggregation: view.Count(),
        }

        var distribution *view.Aggregation
        switch cfg.DurationPipelinerunType </span>{
        case config.DurationPipelinerunTypeLastValue:<span class="cov8" title="1">
                distribution = view.LastValue()</span>
        case config.DurationPipelinerunTypeHistogram:<span class="cov0" title="0">
                distribution = view.Distribution(10, 30, 60, 300, 900, 1800, 3600, 5400, 10800, 21600, 43200, 86400)</span>
        }

        <span class="cov8" title="1">prDeleteDurationView = &amp;view.View{
                Description: prDeleteCount.Description(),
                TagKeys:     append([]tag.Key{statusTag, namespaceTag}, tags...),
                Measure:     prDeleteDuration,
                Aggregation: distribution,
        }
        logger.Debug("registering pipelinerun metrics view")
        return view.Register(prDeleteCountView, prDeleteDurationView)</span>
}

func viewUnregister(logger *zap.SugaredLogger) <span class="cov8" title="1">{
        logger.Debug("unregistering pipelinerun metrics view")
        if prDeleteCountView != nil </span><span class="cov8" title="1">{
                view.Unregister(prDeleteCountView)
        }</span>

        <span class="cov8" title="1">if prDeleteDurationView != nil </span><span class="cov8" title="1">{
                view.Unregister(prDeleteDurationView)
        }</span>
}

// MetricsOnStore returns a function that checks if metrics are configured for a config.Store, and registers it if so
func MetricsOnStore(logger *zap.SugaredLogger) func(name string,
        value any) <span class="cov0" title="0">{
        return func(name string, value any) </span><span class="cov0" title="0">{
                if name != config.GetMetricsConfigName() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">cfg, ok := value.(*config.Metrics)
                if !ok </span><span class="cov0" title="0">{
                        logger.Error("Failed to do type insertion for extracting metrics config")
                        return
                }</span>
                <span class="cov0" title="0">viewUnregister(logger)
                err := viewRegister(logger, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to register View %v ", err)
                        return
                }</span>
        }
}

// DurationAndCountDeleted counts for deleted number and records duration PipelineRuns
func (r *Recorder) DurationAndCountDeleted(ctx context.Context, cfg *config.Metrics, pr *pipelinev1.PipelineRun) error <span class="cov8" title="1">{
        pipelineName := "anonymous"
        now := r.clock.Now()

        if pr.Spec.PipelineRef != nil &amp;&amp; pr.Spec.PipelineRef.Name != "" </span><span class="cov8" title="1">{
                pipelineName = pr.Spec.PipelineRef.Name
        }</span>

        // Metrics status tag meaning should be consistent with pipeline repo definition
        // TODO(xinnjie) metrics status query function should be defined in pipeline repo, and use that function here
        <span class="cov8" title="1">status := "success"
        deleteDuration := time.Duration(0)

        if cond := pr.Status.GetCondition(apis.ConditionSucceeded); cond.Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                status = "failed"
                // Use failedTime to compute delete duration in case of completion time being nil
                failedTime := cond.LastTransitionTime.Inner.Time
                if !failedTime.After(now) </span><span class="cov8" title="1">{
                        deleteDuration = now.Sub(failedTime)
                }</span>
                <span class="cov8" title="1">if cond.Reason == "Cancelled" </span><span class="cov8" title="1">{
                        status = "cancelled"
                }</span>
        }

        <span class="cov8" title="1">var tags []tag.Mutator
        if cfg.PipelinerunLevel == config.PipelinerunLevelAtPipeline </span><span class="cov8" title="1">{
                tags = []tag.Mutator{tag.Insert(pipelineTag, pipelineName)}
        }</span>
        <span class="cov8" title="1">ctx, err := tag.New(ctx, append([]tag.Mutator{tag.Insert(namespaceTag, pr.Namespace), tag.Insert(statusTag, status)}, tags...)...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if pr.Status.CompletionTime != nil &amp;&amp; !pr.Status.CompletionTime.After(now) </span><span class="cov8" title="1">{
                deleteDuration = now.Sub(pr.Status.CompletionTime.Time)
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, prDeleteCount.M(1))
        metrics.Record(ctx, prDeleteDuration.M(float64(deleteDuration/time.Second)))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package retention

import (
        "log"
        "sync"

        "github.com/tektoncd/results/pkg/apis/config"
        "go.uber.org/zap"
        "gorm.io/gorm"

        "github.com/robfig/cron/v3"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/injection/sharedmain"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/signals"
)

const (
        // ResultsRetentionPolicyAgent is the name of the logger for the retention policy agent cmd
        ResultsRetentionPolicyAgent = "results-retention-policy-agent"
)

// Agent have all the information needed to run retention job
type Agent struct {
        config.RetentionPolicy

        mutex sync.Mutex

        Logger *zap.SugaredLogger

        db *gorm.DB

        cron *cron.Cron
}

// NewAgent returns the Retention Policy Agent
func NewAgent(db *gorm.DB) (*Agent, error) <span class="cov0" title="0">{

        cfg := injection.ParseAndGetRESTConfigOrDie()

        ctx := signals.NewContext()
        ctx = injection.WithConfig(ctx, cfg)
        ctx, informers := injection.Default.SetupInformers(ctx, cfg)

        if err := controller.StartInformers(ctx.Done(), informers...); err != nil </span><span class="cov0" title="0">{
                log.Fatal("failed to start informers:", err)
        }</span>

        <span class="cov0" title="0">logger := logging.FromContext(ctx)
        ctx = logging.WithLogger(ctx, logger)

        cmw := sharedmain.SetupConfigMapWatchOrDie(ctx, logger)

        agent := Agent{
                Logger: logger,
                db:     db,
        }
        configStore := config.NewStore(logger.Named("config-store"), agent.AgentOnStore(logger))
        configStore.WatchConfigs(cmw)

        if err := cmw.Start(ctx.Done()); err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("Failed to start configuration manager", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return &amp;agent, nil</span>
}

// AgentOnStore returns a function that checks if agent are configured for a config.Store, and registers it if so
func (a *Agent) AgentOnStore(logger *zap.SugaredLogger) func(name string,
        value interface{}) <span class="cov0" title="0">{
        return func(name string, value interface{}) </span><span class="cov0" title="0">{
                if name == config.GetRetentionPolicyConfigName() </span><span class="cov0" title="0">{
                        cfg, ok := value.(*config.RetentionPolicy)
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error("Failed to do type assertion for extracting retention policy config")
                                return
                        }</span>
                        <span class="cov0" title="0">a.setAgentConfig(cfg)
                        a.stop()
                        a.start()</span>
                }
        }
}

func (a *Agent) setAgentConfig(cfg *config.RetentionPolicy) <span class="cov0" title="0">{
        a.mutex.Lock()
        defer a.mutex.Unlock()
        a.RetentionPolicy = *cfg
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package retention

import (
        "fmt"
        "strings"
        "time"

        "github.com/robfig/cron/v3"
        "github.com/tektoncd/results/pkg/api/server/db/errors"
        "github.com/tektoncd/results/pkg/apis/config"
)

func (a *Agent) start() <span class="cov0" title="0">{
        c := cron.New()
        _, err := c.AddFunc(a.RunAt, a.job)
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Fatalf("failed to add function for cronjob %s", err.Error())
        }</span>
        <span class="cov0" title="0">a.cron = c
        a.cron.Start()</span>
}

func (a *Agent) stop() <span class="cov0" title="0">{
        if a.cron == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">a.cron.Stop()</span>
}

func (a *Agent) job() <span class="cov0" title="0">{
        a.Logger.Infof("retention job started at: %s, retention policy: %+v", time.Now().String(), a.RetentionPolicy)

        caseStatement, err := buildCaseStatement(a.Policies, a.DefaultRetention)
        if err != nil </span><span class="cov0" title="0">{
                a.Logger.Errorf("failed to build case statement: %v", err)
                return
        }</span>

        // First, clean up PipelineRun results.
        <span class="cov0" title="0">a.cleanupResults(caseStatement, "tekton.dev/v1.PipelineRun")

        // Second, clean up top-level TaskRun results.
        a.cleanupResults(caseStatement, "tekton.dev/v1.TaskRun")

        a.Logger.Infof("retention job finished at: %s", time.Now().String())</span>
}

func (a *Agent) cleanupResults(caseStatement, recordType string) <span class="cov0" title="0">{
        deleteQuery := fmt.Sprintf(`
        DELETE FROM results
        WHERE id IN (
            SELECT result_id FROM (
                SELECT
                    r.result_id,
                    r.updated_time,
                    %s AS expiration_time
                FROM records r
                WHERE r.type = '%s'
            ) AS subquery
            WHERE updated_time &lt; expiration_time
        )
    `, caseStatement, recordType)

        if err := errors.Wrap(a.db.Exec(deleteQuery).Error); err != nil </span><span class="cov0" title="0">{
                a.Logger.Errorf("failed to delete results for record type %s: %s", recordType, err.Error())
        }</span>
}

func buildCaseStatement(policies []config.Policy, defaultRetention time.Duration) (string, error) <span class="cov8" title="1">{
        if len(policies) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("NOW() - INTERVAL '%f seconds'", defaultRetention.Seconds()), nil
        }</span>
        <span class="cov8" title="1">var caseClauses []string
        for _, policy := range policies </span><span class="cov8" title="1">{
                whereClause, err := buildWhereClause(policy.Selector)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">retentionDuration, err := config.ParseDuration(policy.Retention)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">caseClauses = append(caseClauses, fmt.Sprintf("WHEN %s THEN NOW() - INTERVAL '%f seconds'", whereClause, retentionDuration.Seconds()))</span>
        }

        <span class="cov8" title="1">defaultRetentionSeconds := defaultRetention.Seconds()
        caseClauses = append(caseClauses, fmt.Sprintf("ELSE NOW() - INTERVAL '%f seconds'", defaultRetentionSeconds))

        return fmt.Sprintf("CASE %s END", strings.Join(caseClauses, " ")), nil</span>
}

func buildWhereClause(selector config.Selector) (string, error) <span class="cov8" title="1">{
        var conditions []string
        if len(selector.MatchNamespaces) &gt; 0 </span><span class="cov8" title="1">{
                conditions = append(conditions, fmt.Sprintf("parent IN (%s)", quoteAndJoin(selector.MatchNamespaces)))
        }</span>
        <span class="cov8" title="1">for key, values := range selector.MatchLabels </span><span class="cov8" title="1">{
                conditions = append(conditions, fmt.Sprintf("data-&gt;'metadata'-&gt;'labels'-&gt;&gt;'%s' IN (%s)", key, quoteAndJoin(values)))
        }</span>
        <span class="cov8" title="1">for key, values := range selector.MatchAnnotations </span><span class="cov8" title="1">{
                conditions = append(conditions, fmt.Sprintf("data-&gt;'metadata'-&gt;'annotations'-&gt;&gt;'%s' IN (%s)", key, quoteAndJoin(values)))
        }</span>
        <span class="cov8" title="1">if len(selector.MatchStatuses) &gt; 0 </span><span class="cov8" title="1">{
                conditions = append(conditions, fmt.Sprintf("data-&gt;'status'-&gt;'conditions'-&gt;0-&gt;&gt;'reason' IN (%s)", quoteAndJoin(selector.MatchStatuses)))
        }</span>
        <span class="cov8" title="1">if len(conditions) == 0 </span><span class="cov8" title="1">{
                return "1=1", nil // No specific selectors, so match all.
        }</span>
        <span class="cov8" title="1">return strings.Join(conditions, " AND "), nil</span>
}

func quoteAndJoin(items []string) string <span class="cov8" title="1">{
        quoted := make([]string, len(items))
        for i, item := range items </span><span class="cov8" title="1">{
                quoted[i] = fmt.Sprintf("'%s'", item)
        }</span>
        <span class="cov8" title="1">return strings.Join(quoted, ",")</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package taskrunmetrics

import (
        "context"
        "errors"
        "time"

        "github.com/jonboulle/clockwork"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/results/pkg/apis/config"
        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/metrics"
)

var (
        trDeleteCount        = stats.Int64("taskrun_delete_count", "total number of deleted taskruns", stats.UnitDimensionless)
        trDeleteCountView    *view.View
        trDeleteDuration     = stats.Float64("taskrun_delete_duration_seconds", "the pipelinerun deletion time in seconds", stats.UnitSeconds)
        trDeleteDurationView *view.View
        pipelineTag          = tag.MustNewKey("pipeline")
        taskTag              = tag.MustNewKey("task")
        namespaceTag         = tag.MustNewKey("namespace")
        statusTag            = tag.MustNewKey("status")
)

// Recorder is used to actually record TaskRun metrics
type Recorder struct {
        clock clockwork.Clock
}

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder() *Recorder <span class="cov0" title="0">{
        return &amp;Recorder{clock: clockwork.NewRealClock()}
}</span>

func viewRegister(logger *zap.SugaredLogger, cfg *config.Metrics) error <span class="cov8" title="1">{
        var tags []tag.Key
        switch cfg.TaskrunLevel </span>{
        case config.TaskrunLevelAtTask:<span class="cov8" title="1">
                tags = []tag.Key{taskTag}</span>
        case config.TaskrunLevelAtNS:<span class="cov0" title="0">
                tags = []tag.Key{}</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid config for TaskrunLevel: " + cfg.TaskrunLevel)</span>
        }

        <span class="cov8" title="1">switch cfg.PipelinerunLevel </span>{
        case config.PipelinerunLevelAtPipeline:<span class="cov8" title="1">
                tags = append(tags, pipelineTag)</span>
        case config.PipelinerunLevelAtNS:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return errors.New("invalid config for PipelinerunLevel: " + cfg.PipelinerunLevel)</span>
        }

        <span class="cov8" title="1">trDeleteCountView = &amp;view.View{
                Description: trDeleteCount.Description(),
                TagKeys:     []tag.Key{statusTag, namespaceTag},
                Measure:     trDeleteCount,
                Aggregation: view.Count(),
        }

        var distribution *view.Aggregation
        switch cfg.DurationPipelinerunType </span>{
        case config.DurationTaskrunTypeLastValue:<span class="cov8" title="1">
                distribution = view.LastValue()</span>
        case config.DurationTaskrunTypeHistogram:<span class="cov0" title="0">
                distribution = view.Distribution(10, 30, 60, 300, 900, 1800, 3600, 5400, 10800, 21600, 43200, 86400)</span>
        }

        <span class="cov8" title="1">trDeleteDurationView = &amp;view.View{
                Description: trDeleteDuration.Description(),
                TagKeys:     append([]tag.Key{statusTag, namespaceTag}, tags...),
                Measure:     trDeleteDuration,
                Aggregation: distribution,
        }
        logger.Debug("registering taskrun metrics view")
        return view.Register(trDeleteCountView, trDeleteDurationView)</span>
}

func viewUnregister(logger *zap.SugaredLogger) <span class="cov8" title="1">{
        logger.Debug("unregistering taskrun metrics view")
        if trDeleteCountView != nil </span><span class="cov8" title="1">{
                view.Unregister(trDeleteCountView)
        }</span>
        <span class="cov8" title="1">if trDeleteDurationView != nil </span><span class="cov8" title="1">{
                view.Unregister(trDeleteDurationView)
        }</span>
}

// MetricsOnStore returns a function that checks if metrics are configured for a config.Store, and registers it if so
func MetricsOnStore(logger *zap.SugaredLogger) func(name string,
        value any) <span class="cov0" title="0">{
        return func(name string, value any) </span><span class="cov0" title="0">{
                if name != config.GetMetricsConfigName() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">cfg, ok := value.(*config.Metrics)
                if !ok </span><span class="cov0" title="0">{
                        logger.Error("Failed to do type insertion for extracting metrics config")
                        return
                }</span>
                <span class="cov0" title="0">viewUnregister(logger)
                err := viewRegister(logger, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to register View %v ", err)
                        return
                }</span>
        }
}

// DurationAndCountDeleted counts deleted number and record duration for TaskRuns
func (r *Recorder) DurationAndCountDeleted(ctx context.Context, cfg *config.Metrics, tr *pipelinev1.TaskRun) error <span class="cov8" title="1">{
        taskName := "anonymous"
        pipelineName := "anonymous"
        now := r.clock.Now()

        if tr.Spec.TaskRef != nil &amp;&amp; tr.Spec.TaskRef.Name != "" </span><span class="cov8" title="1">{
                taskName = tr.Spec.TaskRef.Name
        }</span>

        <span class="cov8" title="1">status := "success"
        deleteDuration := time.Duration(0)
        if cond := tr.Status.GetCondition(apis.ConditionSucceeded); cond.Status == corev1.ConditionFalse </span><span class="cov8" title="1">{
                status = "failed"

                // Use failedTime to compute delete duration in case of completion time being nil
                failedTime := cond.LastTransitionTime.Inner.Time
                if !failedTime.After(now) </span><span class="cov8" title="1">{
                        deleteDuration = now.Sub(failedTime)
                }</span>
                <span class="cov8" title="1">if cond.Reason == pipelinev1.TaskRunSpecStatusCancelled </span><span class="cov0" title="0">{
                        status = "cancelled"
                }</span>
        }

        <span class="cov8" title="1">tags := []tag.Mutator{tag.Insert(namespaceTag, tr.Namespace), tag.Insert(statusTag, status)}

        if ok, pipeline, _ := isPartOfPipeline(tr); ok </span><span class="cov8" title="1">{
                pipelineName = pipeline
        }</span>

        <span class="cov8" title="1">tags = append(tags, r.insertPipelineTag(cfg, pipelineName)...)
        tags = append(tags, r.insertTaskTag(cfg, taskName)...)

        ctx, err := tag.New(ctx, tags...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if tr.Status.CompletionTime != nil &amp;&amp; !tr.Status.CompletionTime.Time.After(now) </span><span class="cov8" title="1">{
                deleteDuration = now.Sub(tr.Status.CompletionTime.Time)
        }</span>
        <span class="cov8" title="1">metrics.Record(ctx, trDeleteCount.M(1))
        metrics.Record(ctx, trDeleteDuration.M(float64(deleteDuration/time.Second)))
        return nil</span>
}

func (r *Recorder) insertPipelineTag(cfg *config.Metrics, pipeline string) []tag.Mutator <span class="cov8" title="1">{
        var tags []tag.Mutator
        switch cfg.PipelinerunLevel </span>{
        case config.PipelinerunLevelAtPipeline:<span class="cov8" title="1">
                tags = []tag.Mutator{tag.Insert(pipelineTag, pipeline)}</span>
        case config.PipelinerunLevelAtNS:<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">return tags</span>
}

func (r *Recorder) insertTaskTag(cfg *config.Metrics, task string) []tag.Mutator <span class="cov8" title="1">{
        var tags []tag.Mutator
        switch cfg.TaskrunLevel </span>{
        case config.TaskrunLevelAtTask:<span class="cov8" title="1">
                tags = []tag.Mutator{tag.Insert(taskTag, task)}</span>
        case config.TaskrunLevelAtNS:<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">return tags</span>
}

// IsPartOfPipeline return true if TaskRun is a part of a Pipeline.
// It also returns the name of Pipeline and PipelineRun
func isPartOfPipeline(tr *pipelinev1.TaskRun) (bool, string, string) <span class="cov8" title="1">{
        pipelineLabel, hasPipelineLabel := tr.Labels[pipeline.PipelineLabelKey]
        pipelineRunLabel, hasPipelineRunLabel := tr.Labels[pipeline.PipelineRunLabelKey]

        if hasPipelineLabel &amp;&amp; hasPipelineRunLabel </span><span class="cov8" title="1">{
                return true, pipelineLabel, pipelineRunLabel
        }</span>

        <span class="cov8" title="1">return false, "", ""</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package convert provides a method to convert Pipeline v1 API objects to Results
// API proto objects.
package convert

import (
        "encoding/json"
        "fmt"

        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"

        pipelineV1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"

        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/scheme"
        "github.com/tektoncd/pipeline/pkg/pod"
        rpb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
)

// ToProto converts k8s object to proto object.
func ToProto(in runtime.Object) (*rpb.Any, error) <span class="cov8" title="1">{
        if in == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">b, err := json.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;rpb.Any{
                Type:  TypeName(in),
                Value: b,
        }, nil</span>
}

// ToLogProto converts k8s object to log proto object.
func ToLogProto(in metav1.Object, kind, name string) (*rpb.Any, error) <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">_, _, uid, err := record.ParseName(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">log := &amp;v1alpha3.Log{
                ObjectMeta: metav1.ObjectMeta{
                        Namespace: in.GetNamespace(),
                        Name:      fmt.Sprintf("%s-log", in.GetName()),
                        UID:       types.UID(uid),
                },
                Spec: v1alpha3.LogSpec{
                        Resource: v1alpha3.Resource{
                                Kind:      kind,
                                Namespace: in.GetNamespace(),
                                Name:      in.GetName(),
                                UID:       in.GetUID(),
                        },
                },
        }
        log.Default()
        b, err := json.Marshal(log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;rpb.Any{
                Type:  v1alpha3.LogRecordType,
                Value: b,
        }, nil</span>
}

// TypeName returns a string representation of type Object type.
// We do not know of any formalized spec for identifying objects across API
// versions. Standard GVK string formatting does not produce something that's
// payload friendly (i.e. includes spaces).
// To get around this we append API Version + Kind
// (e.g. tekton.dev/v1.TaskRun).
func TypeName(in runtime.Object) string <span class="cov8" title="1">{
        gvk := in.GetObjectKind().GroupVersionKind()
        if gvk.Empty() </span><span class="cov8" title="1">{
                // GVK not explicitly set in the object, fall back to scheme-based
                // lookup.
                var err error
                gvk, err = InferGVK(in)
                // Avoid returning back "." if the GVK doesn't contain any info.
                if err != nil || gvk.Empty() </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }
        <span class="cov8" title="1">v, k := gvk.ToAPIVersionAndKind()
        return fmt.Sprintf("%s.%s", v, k)</span>
}

// InferGVK infers the GroupVersionKind from the Object via schemes. Currently
// only the Tekton scheme is supported.
func InferGVK(o runtime.Object) (schema.GroupVersionKind, error) <span class="cov8" title="1">{
        gvks, _, err := scheme.Scheme.ObjectKinds(o)
        if err != nil </span><span class="cov8" title="1">{
                return schema.GroupVersionKind{}, err
        }</span>
        // This could potentially match a few different ones (not exactly sure
        // when this would happen), but generally shouldn't because we're using
        // the direct types from the Tekton package.
        <span class="cov8" title="1">if len(gvks) == 0 </span><span class="cov0" title="0">{
                return schema.GroupVersionKind{}, fmt.Errorf("could not determine GroupVersionKind for object")
        }</span>
        <span class="cov8" title="1">return gvks[0], nil</span>
}

// Status maps a Run condition to a general Record status.
func Status(ca apis.ConditionAccessor) rpb.RecordSummary_Status <span class="cov8" title="1">{
        c := ca.GetCondition(apis.ConditionSucceeded)
        if c == nil </span><span class="cov8" title="1">{
                return rpb.RecordSummary_UNKNOWN
        }</span>

        <span class="cov8" title="1">switch pipelineV1.TaskRunReason(c.Reason) </span>{
        case pipelineV1.TaskRunReasonSuccessful:<span class="cov8" title="1">
                return rpb.RecordSummary_SUCCESS</span>
        case pipelineV1.TaskRunReasonFailed:<span class="cov0" title="0">
                return rpb.RecordSummary_FAILURE</span>
        case pipelineV1.TaskRunReasonTimedOut:<span class="cov0" title="0">
                return rpb.RecordSummary_TIMEOUT</span>
        case pipelineV1.TaskRunReasonCancelled:<span class="cov0" title="0">
                return rpb.RecordSummary_CANCELLED</span>
        case pipelineV1.TaskRunReasonRunning, pipelineV1.TaskRunReasonStarted:<span class="cov0" title="0">
                return rpb.RecordSummary_UNKNOWN</span>
        }

        <span class="cov8" title="1">switch pipelineV1.PipelineRunReason(c.Reason) </span>{
        case pipelineV1.PipelineRunReasonSuccessful, pipelineV1.PipelineRunReasonCompleted:<span class="cov0" title="0">
                return rpb.RecordSummary_SUCCESS</span>
        case pipelineV1.PipelineRunReasonFailed:<span class="cov0" title="0">
                return rpb.RecordSummary_FAILURE</span>
        case pipelineV1.PipelineRunReasonTimedOut:<span class="cov8" title="1">
                return rpb.RecordSummary_TIMEOUT</span>
        case pipelineV1.PipelineRunReasonCancelled:<span class="cov0" title="0">
                return rpb.RecordSummary_CANCELLED</span>
        case pipelineV1.PipelineRunReasonRunning, pipelineV1.PipelineRunReasonStarted, pipelineV1.PipelineRunReasonPending, pipelineV1.PipelineRunReasonStopping, pipelineV1.PipelineRunReasonCancelledRunningFinally, pipelineV1.PipelineRunReasonStoppedRunningFinally:<span class="cov0" title="0">
                return rpb.RecordSummary_UNKNOWN</span>
        }

        <span class="cov8" title="1">switch c.Reason </span>{
        case pod.ReasonFailedResolution, pod.ReasonFailedValidation, pod.ReasonTaskFailedValidation, pod.ReasonResourceVerificationFailed, pod.ReasonExceededResourceQuota, pod.ReasonExceededNodeResources, pod.ReasonPullImageFailed, pod.ReasonCreateContainerConfigError, pod.ReasonPodCreationFailed, pod.ReasonPodAdmissionFailed:<span class="cov8" title="1">
                return rpb.RecordSummary_FAILURE</span>
        case pod.ReasonPodPending:<span class="cov0" title="0">
                return rpb.RecordSummary_UNKNOWN</span>
        }
        <span class="cov8" title="1">return rpb.RecordSummary_UNKNOWN</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package grpc

import (
        "context"
        "fmt"

        "google.golang.org/api/idtoken"
        "google.golang.org/grpc/credentials"
)

// Google provides an authenticated transport for use against Google APIs
// (e.g. Cloud Run, Identity Aware Proxy, API Gateway, etc.) using the
// incoming gRPC server URI as the token audience.
// See https://pkg.go.dev/google.golang.org/api/idtoken for more details.
func Google(opts ...idtoken.ClientOption) credentials.PerRPCCredentials <span class="cov0" title="0">{
        return &amp;googleCreds{
                opts: opts,
        }
}</span>

type googleCreds struct {
        opts []idtoken.ClientOption
}

// GetRequestMetadata gets the current request metadata, refreshing
// tokens if required. This should be called by the transport layer on
// each request, and the data should be populated in headers or other
// context. If a status code is returned, it will be used as the status
// for the RPC. uri is the URI of the entry point for the request.
// When supported by the underlying implementation, ctx can be used for
// timeout and cancellation. Additionally, RequestInfo data will be
// available via ctx to this call.
func (c *googleCreds) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) <span class="cov0" title="0">{
        out := map[string]string{}
        for _, u := range uri </span><span class="cov0" title="0">{
                tokenSource, err := idtoken.NewTokenSource(ctx, u, c.opts...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("idtoken.NewTokenSource(%s): %v", u, err)
                }</span>
                <span class="cov0" title="0">token, err := tokenSource.Token()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("TokenSource.Token(%s): %v", u, err)
                }</span>
                <span class="cov0" title="0">out["authorization"] = "Bearer " + token.AccessToken</span>
        }
        <span class="cov0" title="0">return out, nil</span>
}

// RequireTransportSecurity indicates whether the credentials requires
// transport security.
func (googleCreds) RequireTransportSecurity() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package logs

import (
        "context"
        "errors"

        v1alpha2pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc"
        reflectionv1 "google.golang.org/grpc/reflection/grpc_reflection_v1"
        "knative.dev/pkg/logging"
)

// Key is key to store LogsClient in the context
type Key struct{}

const (
        logsServiceName = "tekton.results.v1alpha2.Logs"
)

// WithContext includes the Logs client to the context.
func WithContext(ctx context.Context, conn *grpc.ClientConn) (context.Context, error) <span class="cov0" title="0">{
        reflectionInfo, err := reflectionv1.NewServerReflectionClient(conn).ServerReflectionInfo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, err
        }</span>

        <span class="cov0" title="0">err = reflectionInfo.Send(&amp;reflectionv1.ServerReflectionRequest{
                MessageRequest: &amp;reflectionv1.ServerReflectionRequest_ListServices{
                        ListServices: "*",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return ctx, err
        }</span>

        <span class="cov0" title="0">response, err := reflectionInfo.Recv()
        if err != nil </span><span class="cov0" title="0">{
                return ctx, err
        }</span>
        <span class="cov0" title="0">for _, service := range response.GetListServicesResponse().GetService() </span><span class="cov0" title="0">{
                if service.Name == logsServiceName </span><span class="cov0" title="0">{
                        return context.WithValue(ctx, Key{}, v1alpha2pb.NewLogsClient(conn)), nil
                }</span>
        }
        <span class="cov0" title="0">return ctx, errors.New("logs service not enabled in server")</span>
}

// Get extracts the Logs client from the context.
func Get(ctx context.Context) v1alpha2pb.LogsClient <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Info(
                        "Unable to fetch Logs Client from context, either disabled from config or disabled from server side")
                return nil
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha2pb.LogsClient)</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package annotation

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/tektoncd/results/pkg/watcher/reconciler/client"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "knative.dev/pkg/logging"
)

const (
        // annotationPrefix - all annotations managed by watcher should have this prefix
        annotationPrefix = "results.tekton.dev/"

        // Result identifier.
        Result = annotationPrefix + "result"

        // Record identifier.
        Record = annotationPrefix + "record"

        // Log identifier.
        Log = annotationPrefix + "log"

        // EventList identifier.
        EventList = annotationPrefix + "eventlist"

        // Stored is an annotation that signals to the controller that a given object
        // has been stored by the Results API.
        Stored = annotationPrefix + "stored"

        // ResultAnnotations is an annotation that integrators should add to objects in order to store
        // arbitrary keys/values into the Result.Annotations field.
        ResultAnnotations = annotationPrefix + "resultAnnotations"

        // RecordSummaryAnnotations is an annotation that integrators should add to objects
        // in order to store arbitrary keys/values into the Result.Summary.Annotations field.
        // This allows for additional information to be associated with the summary of a record.
        RecordSummaryAnnotations = annotationPrefix + "recordSummaryAnnotations"

        // ChildReadyForDeletion is an annotation that signals to the controller that a given child object
        // (e.g. TaskRun owned by a PipelineRun) is done and up to date in the
        // API server and therefore, ready to be garbage collected.
        ChildReadyForDeletion = annotationPrefix + "childReadyForDeletion"

        // FieldManager identifier to be used with Server-Side Apply patches
        fieldManager = "tekton-results-watcher"
)

// Annotation is wrapper for Kubernetes resource annotations stored in the metadata.
type Annotation struct {
        Name  string
        Value string
}

// Server-side apply patch structure
type applyPatch struct {
        APIVersion string   `json:"apiVersion"`
        Kind       string   `json:"kind"`
        Metadata   metadata `json:"metadata"`
}

type metadata struct {
        Name        string            `json:"name"`
        Namespace   string            `json:"namespace"`
        Annotations map[string]string `json:"annotations"`
}

// Patch builds and applies a patch with the given annotations to the object using the provided object client.
func Patch(
        ctx context.Context,
        object metav1.Object,
        objectClient client.ObjectClient,
        annotations ...Annotation,
) error <span class="cov8" title="1">{

        logger := logging.FromContext(ctx)

        // Get the API version and kind from the object
        var apiVersion, kind string
        if runtimeObj, ok := object.(runtime.Object); ok </span><span class="cov8" title="1">{
                if gvk := runtimeObj.GetObjectKind().GroupVersionKind(); !gvk.Empty() </span><span class="cov8" title="1">{
                        kind = gvk.Kind
                        apiVersion = gvk.GroupVersion().String()
                }</span>
        }
        // If we couldn't determine the kind or apiVersion, fail
        <span class="cov8" title="1">if kind == "" || apiVersion == "" </span><span class="cov8" title="1">{
                logger.Errorf("could not determine apiVersion and kind from object %s/%s", object.GetNamespace(), object.GetName())
                return fmt.Errorf("could not determine apiVersion and kind from object %s/%s", object.GetNamespace(), object.GetName())
        }</span>

        <span class="cov8" title="1">if IsPatched(object, annotations...) </span><span class="cov8" title="1">{
                logger.Debugf("Skipping CRD annotation patch: annotations are already set ObjectName: %s", object.GetName())
                return nil
        }</span>

        <span class="cov8" title="1">data := applyPatch{
                APIVersion: apiVersion,
                Kind:       kind,
                Metadata: metadata{
                        Name:        object.GetName(),
                        Namespace:   object.GetNamespace(),
                        Annotations: map[string]string{},
                },
        }

        // Copy existing managed annotations from the object
        // Only include annotations that we manage (results.tekton.dev/* annotations)
        // to avoid conflicts with other controllers using server-side apply
        currentAnnotations := object.GetAnnotations()
        for key, value := range currentAnnotations </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, annotationPrefix) </span><span class="cov8" title="1">{
                        data.Metadata.Annotations[key] = value
                }</span>
        }

        // Add/overwrite with new annotations
        <span class="cov8" title="1">for _, annotation := range annotations </span><span class="cov8" title="1">{
                if len(annotation.Value) != 0 </span><span class="cov8" title="1">{
                        data.Metadata.Annotations[annotation.Name] = annotation.Value
                }</span>
        }
        <span class="cov8" title="1">patch, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">force := false
        patchOptions := metav1.PatchOptions{
                FieldManager: fieldManager,
                Force:        &amp;force,
        }
        err = objectClient.Patch(ctx, object.GetName(), types.ApplyPatchType, patch, patchOptions)
        if apierrors.IsConflict(err) </span><span class="cov8" title="1">{
                // Since we only update the list of annotations we manage, there shouldn't be any conflicts unless
                // another controller/client is updating our annotations. We log the issue and force patch.
                // TODO: We can expose the error as a metric
                logger.Warnf("failed to patch object %s with annotations %v due to Server-Side Apply patch conflict, using force patch.", object.GetName(), data.Metadata.Annotations)
                force = true
                err = objectClient.Patch(ctx, object.GetName(), types.ApplyPatchType, patch, patchOptions)
        }</span>

        // After successful patch, update in-memory object
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                currentAnnotations := object.GetAnnotations()
                if currentAnnotations == nil </span><span class="cov8" title="1">{
                        currentAnnotations = make(map[string]string)
                }</span>
                <span class="cov8" title="1">for _, ann := range annotations </span><span class="cov8" title="1">{
                        currentAnnotations[ann.Name] = ann.Value
                }</span>
                <span class="cov8" title="1">object.SetAnnotations(currentAnnotations)</span>
        }

        <span class="cov8" title="1">return err</span>
}

// IsPatched returns true if the object in question contains all relevant
// annotations or false otherwise.
func IsPatched(object metav1.Object, annotations ...Annotation) bool <span class="cov8" title="1">{
        objAnnotations := object.GetAnnotations()
        for _, annotation := range annotations </span><span class="cov8" title="1">{
                if objAnnotations[annotation.Name] != annotation.Value </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Copyright 2024 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package client provides utilities for interacting with watcher reconciler clients.
package client

import (
        "context"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/client/clientset/versioned/typed/pipeline/v1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
)

// ObjectClient is a shim around generated k8s clients to handle objects in
// type agnostic ways.
// This might be able to be replaced with generics later?
type ObjectClient interface {
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) error
}

// TaskRunClient implements the dynamic ObjectClient for TaskRuns.
type TaskRunClient struct {
        pipelinev1.TaskRunInterface
}

// Patch patches TaskRun k8s resource
func (c *TaskRunClient) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) error <span class="cov0" title="0">{
        _, err := c.TaskRunInterface.Patch(ctx, name, pt, data, opts, subresources...)
        return err
}</span>

// PipelineRunClient implements the dynamic ObjectClient for PipelineRuns.
type PipelineRunClient struct {
        pipelinev1.PipelineRunInterface
}

// Patch patches pipelineRun Kubernetes resource.
func (c *PipelineRunClient) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) error <span class="cov0" title="0">{
        _, err := c.PipelineRunInterface.Patch(ctx, name, pt, data, opts, subresources...)
        return err
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">// Copyright 2021 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package reconciler

import (
        "time"

        "k8s.io/apimachinery/pkg/labels"
)

// Config defines shared reconciler configuration options.
type Config struct {
        // Configures whether Tekton CRD objects should be updated with Result
        // annotations during reconcile. Useful to enable for dry run modes.
        DisableAnnotationUpdate bool

        // CompletedResourceGracePeriod is the time to wait before deleting completed resources.
        // 0 implies the duration
        CompletedResourceGracePeriod time.Duration

        // Label selector to match resources against in order to determine
        // whether completed resources are eligible for deletion. The default
        // value is labels.Everything() which matches any resource.
        labelSelector labels.Selector

        // How long the controller waits to reprocess keys on certain events
        // (e.g. an object doesn't match the provided label selectors).
        RequeueInterval time.Duration

        // Check owner reference when deleting objects. By default, objects having owner references set won't be deleted.
        CheckOwner bool

        // UpdateLogTimeout is the time we provide for storing logs before aborting
        UpdateLogTimeout *time.Duration

        // DynamicReconcileTimeout is the time we provide for the dynamic reconciler to process an event
        DynamicReconcileTimeout *time.Duration

        // Whether to Store Events related to Taskrun and Pipelineruns
        StoreEvent bool

        // StoreDeadline is the time we provide for the PipelineRun and TaskRun resources
        // to be stored before aborting and clearing the finalizer in case of delete event
        StoreDeadline *time.Duration

        // FinalizerRequeueInterval is the duration after which finalizer reconciler
        // is scheduled to run for processing Runs not yet stored.
        FinalizerRequeueInterval time.Duration

        // ForwardBuffer is the time we provide for the TaskRun Logs to finish streaming
        // by a forwarder. Since there's no way to check if log has been streamed, we
        // always wait for this much amount of duration
        ForwardBuffer *time.Duration

        // Collect logs with timestamps
        LogsTimestamps bool

        // SummaryLabels are labels which should be part of the summary of the result
        SummaryLabels string

        // SummaryAnnotations are annotations which should be part of the summary of the result
        SummaryAnnotations string

        // DisableStoringIncompleteRuns disables the collection of incomplete Runs data
        DisableStoringIncompleteRuns bool
}

// GetDisableAnnotationUpdate returns whether annotation updates should be
// disabled. This is safe to call for missing configs.
func (c *Config) GetDisableAnnotationUpdate() bool <span class="cov8" title="1">{
        if c == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return c.DisableAnnotationUpdate</span>
}

// GetCompletedResourceGracePeriod returns the grace period to wait for
// deleting Run objects.
// If value &lt; 0, objects will be deleted immediately.
// If value = 0 (or not explicitly set), then objects will not be deleted.
// If value &gt; 0, objects will be deleted with a grace period option of the
// duration.
func (c *Config) GetCompletedResourceGracePeriod() time.Duration <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return c.CompletedResourceGracePeriod</span>
}

// GetLabelSelector returns the label selector to match resources against in
// order to determine whether they're eligible for deletion. If no selector was
// configured via the SetLabelSelector method, returns a selector that always
// matches any resource.
func (c *Config) GetLabelSelector() labels.Selector <span class="cov0" title="0">{
        if c.labelSelector == nil </span><span class="cov0" title="0">{
                return labels.Everything()
        }</span>
        <span class="cov0" title="0">return c.labelSelector</span>
}

// SetLabelSelector sets a label selector to match resources against in order to
// determine whether they're eligible for deletion. The syntax obeys the same
// format accepted by list operations performed on the Kubernetes API server.
func (c *Config) SetLabelSelector(selector string) error <span class="cov0" title="0">{
        parsedSelector, err := labels.Parse(selector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.labelSelector = parsedSelector
        return nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dynamic

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/fatih/color"
        "github.com/jonboulle/clockwork"
        "github.com/tektoncd/cli/pkg/cli"
        tknlog "github.com/tektoncd/cli/pkg/log"
        tknopts "github.com/tektoncd/cli/pkg/options"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/log"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/result"
        "github.com/tektoncd/results/pkg/logs"
        "github.com/tektoncd/results/pkg/watcher/convert"
        "github.com/tektoncd/results/pkg/watcher/reconciler"
        "github.com/tektoncd/results/pkg/watcher/reconciler/annotation"
        "github.com/tektoncd/results/pkg/watcher/reconciler/client"
        "github.com/tektoncd/results/pkg/watcher/results"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "go.uber.org/zap"
        v1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

var (
        clock = clockwork.NewRealClock()
)

// Reconciler implements common reconciler behavior across different Tekton Run
// Object types.
type Reconciler struct {
        // KubeClientSet allows us to talk to the k8s for core APIs
        KubeClientSet kubernetes.Interface

        resultsClient          *results.Client
        objectClient           client.ObjectClient
        cfg                    *reconciler.Config
        IsReadyForDeletionFunc IsReadyForDeletion
        AfterDeletion          AfterDeletion
}

func init() <span class="cov8" title="1">{
        // Disable colorized output from the tkn CLI.
        color.NoColor = true
}</span>

// IsReadyForDeletion is a predicate function which indicates whether the object
// being reconciled is ready to be garbage collected. Besides the reqirements
// that are already enforced by this reconciler, callers may define more
// specific constraints by providing a function that has the below signature to
// the Reconciler instance. For instance, the controller that reconciles
// PipelineRuns can verify whether all dependent TaskRuns are up to date in the
// API server before deleting all objects in cascade.
type IsReadyForDeletion func(ctx context.Context, object results.Object) (bool, error)

// AfterDeletion is the function called after object is deleted
type AfterDeletion func(ctx context.Context, object results.Object) error

// NewDynamicReconciler creates a new dynamic Reconciler.
func NewDynamicReconciler(kubeClientSet kubernetes.Interface, rc pb.ResultsClient, lc pb.LogsClient, oc client.ObjectClient, cfg *reconciler.Config) *Reconciler <span class="cov8" title="1">{
        return &amp;Reconciler{
                resultsClient: results.NewClient(rc, lc, cfg),
                KubeClientSet: kubeClientSet,
                objectClient:  oc,
                cfg:           cfg,
                // Always true predicate.
                IsReadyForDeletionFunc: func(_ context.Context, _ results.Object) (bool, error) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>,
        }
}

// Reconcile handles result/record uploading for the given Run object.
// If enabled, the object may be deleted upon successful result upload.
func (r *Reconciler) Reconcile(ctx context.Context, o results.Object) error <span class="cov8" title="1">{
        var ctxCancel context.CancelFunc
        // context with timeout does not work with the partial end to end flow that exists with unit tests;
        // this field will always be set for real
        if r.cfg != nil &amp;&amp; r.cfg.UpdateLogTimeout != nil </span><span class="cov0" title="0">{
                ctx, ctxCancel = context.WithTimeout(ctx, *r.cfg.UpdateLogTimeout)
        }</span>
        // we dont defer the dynamicCancle because golang defers follow a LIFO pattern
        // and we want to have our context analysis defer function be able to distinguish between
        // the context channel being closed because of Canceled or DeadlineExceeded
        <span class="cov8" title="1">logger := logging.FromContext(ctx)
        defer func() </span><span class="cov8" title="1">{
                if ctx == nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">ctxErr := ctx.Err()
                if ctxErr == nil </span><span class="cov8" title="1">{
                        logger.Warn("Leaving dynamic Reconciler somehow but the context channel is not closed")
                        return
                }</span>
                <span class="cov0" title="0">if ctxErr == context.Canceled </span><span class="cov0" title="0">{
                        logger.Debug("Leaving dynamic Reconciler normally with context properly canceled")
                        return
                }</span>
                <span class="cov0" title="0">if ctxErr == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        logger.Warn("Leaving dynamic Reconciler only after context timeout")
                        return
                }</span>
                <span class="cov0" title="0">logger.Warnw("Leaving dynamic Reconciler with unexpected error", zap.String("error", ctxErr.Error()))</span>
        }()

        <span class="cov8" title="1">if o.GetObjectKind().GroupVersionKind().Empty() </span><span class="cov0" title="0">{
                gvk, err := convert.InferGVK(o)
                if err != nil </span><span class="cov0" title="0">{
                        if ctxCancel != nil </span><span class="cov0" title="0">{
                                ctxCancel()
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">o.GetObjectKind().SetGroupVersionKind(gvk)
                logger.Debugf("Post SetGroupVersionKind: %s", o.GetObjectKind().GroupVersionKind().String())</span>
        }

        // Upsert record.
        <span class="cov8" title="1">startTime := time.Now()
        res, rec, err := r.resultsClient.Put(ctx, o)
        timeTakenField := zap.Int64("results.tekton.dev/time-taken-ms", time.Since(startTime).Milliseconds())

        if err != nil </span><span class="cov0" title="0">{
                logger.Debugw("Error upserting record to API server", zap.Error(err), timeTakenField)
                if ctxCancel != nil </span><span class="cov0" title="0">{
                        ctxCancel()
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("error upserting record: %w", err)</span>
        }

        // Update logs if enabled.
        <span class="cov8" title="1">if r.resultsClient.LogsClient != nil </span><span class="cov8" title="1">{
                if r.cfg == nil || r.cfg.UpdateLogTimeout == nil </span><span class="cov8" title="1">{
                        // single threaded for unit tests given fragility of fake k8s client
                        if err = r.sendLog(ctx, o); err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Error sending log", zap.Error(err))
                        }</span>

                } else<span class="cov0" title="0"> {
                        // so while performance was acceptable with development level storage mechanisms like minio, latency proved
                        // intolerable for even basic amounts of log storage; moving off of the reconciler thread again, and
                        // completely divesting from its context, now using the background context and a separate timer to provide
                        // for timeout capability
                        go func() </span><span class="cov0" title="0">{
                                // TODO need to leverage the log status API noting log storage completion to coordinate with pruning
                                backgroundCtx, cancel := context.WithCancel(context.Background())
                                // need this to get grpc to clean up its threads
                                defer cancel()
                                timeout := 30 * time.Second
                                // context with timeout does not work with the partial end to end flow that exists with unit tests;
                                // this field will always be set for real
                                if r.cfg != nil &amp;&amp; r.cfg.DynamicReconcileTimeout != nil </span><span class="cov0" title="0">{
                                        // given what we have seen in stress testing, we track this timeout separately from the reconciler's timeout
                                        timeout = *r.cfg.DynamicReconcileTimeout
                                }</span>
                                <span class="cov0" title="0">eventTicker := time.NewTicker(timeout)
                                // make buffered for golang GC
                                stopCh := make(chan bool, 1)
                                once := sync.Once{}

                                go func() </span><span class="cov0" title="0">{
                                        if err = r.sendLog(backgroundCtx, o); err != nil </span><span class="cov0" title="0">{
                                                logger.Errorw("Error sending log", zap.Error(err))
                                        }</span>
                                        <span class="cov0" title="0">once.Do(func() </span><span class="cov0" title="0">{ close(stopCh) }</span>)
                                        // TODO once we have the log status available, report the error there for retry if needed
                                }()

                                <span class="cov0" title="0">select </span>{
                                case &lt;-eventTicker.C:<span class="cov0" title="0">
                                        once.Do(func() </span><span class="cov0" title="0">{ close(stopCh) }</span>)
                                        <span class="cov0" title="0">logger.Warn("Leaving sendLogs thread only after timeout")</span>

                                case &lt;-stopCh:<span class="cov0" title="0">
                                        // this is safe to call twice, as it does not need to close its buffered channel
                                        eventTicker.Stop()</span>
                                }
                        }()

                }
        }

        // CreateEvents if enabled
        <span class="cov8" title="1">if r.cfg.StoreEvent </span><span class="cov8" title="1">{
                if err := r.storeEvents(ctx, o); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Error storing eventlist", zap.Error(err))
                        if ctxCancel != nil </span><span class="cov0" title="0">{
                                ctxCancel()
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">logger.Debug("Successfully store eventlist")</span>
        }
        <span class="cov8" title="1">logger = logger.With(zap.String("results.tekton.dev/result", res.Name),
                zap.String("results.tekton.dev/record", rec.Name))
        logger.Debugw("Record has been successfully upserted into API server", timeTakenField)

        recordAnnotation := annotation.Annotation{Name: annotation.Record, Value: rec.GetName()}
        resultAnnotation := annotation.Annotation{Name: annotation.Result, Value: res.GetName()}
        if err = r.addResultsAnnotations(ctx, o, recordAnnotation, resultAnnotation); err != nil </span><span class="cov0" title="0">{
                // no grpc calls from addResultsAnnotation
                if ctxCancel != nil </span><span class="cov0" title="0">{
                        ctxCancel()
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if err = r.addChildReadyForDeletionAnnotations(ctx, o); err != nil </span><span class="cov0" title="0">{
                if ctxCancel != nil </span><span class="cov0" title="0">{
                        ctxCancel()
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">if err = r.deleteUponCompletion(ctx, o); err != nil </span><span class="cov8" title="1">{
                // no grpc calls from deleteUponCompletion
                if ctxCancel != nil </span><span class="cov0" title="0">{
                        ctxCancel()
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">if ctxCancel != nil </span><span class="cov0" title="0">{
                defer ctxCancel()
        }</span>
        <span class="cov8" title="1">return r.addStoredAnnotations(ctx, o)</span>
}

// addResultsAnnotations adds Results annotations to the object in question if
// annotation patching is enabled.
func (r *Reconciler) addResultsAnnotations(ctx context.Context, o results.Object, annotations ...annotation.Annotation) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if r.cfg.GetDisableAnnotationUpdate() </span><span class="cov8" title="1">{ //nolint:gocritic
                logger.Debug("Skipping CRD annotation patch: annotation update is disabled")
        }</span> else<span class="cov8" title="1"> {
                err := annotation.Patch(ctx, o, r.objectClient, annotations...)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error patching object: %w", err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// deleteUponCompletion deletes the object in question when the following
// conditions are met:
// * The resource deletion is enabled in the config (the grace period is greater
// than 0).
// * The object is done, and it isn't owned by other object.
// * The configured grace period has elapsed since the object's completion.
// * The object satisfies all label requirements defined in the supplied config.
// * The assigned IsReadyForDeletionFunc returns true.
func (r *Reconciler) deleteUponCompletion(ctx context.Context, o results.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        gracePeriod := r.cfg.GetCompletedResourceGracePeriod()
        logger = logger.With(zap.Duration("results.tekton.dev/gracePeriod", gracePeriod))
        if gracePeriod == 0 </span><span class="cov8" title="1">{
                logger.Info("Skipping resource deletion: deletion is disabled")
                return nil
        }</span>

        <span class="cov8" title="1">if !isDone(o) </span><span class="cov0" title="0">{
                logger.Debug("Skipping resource deletion: object is not done yet")
                return nil
        }</span>

        <span class="cov8" title="1">if ownerReferences := o.GetOwnerReferences(); len(ownerReferences) &gt; 0 </span><span class="cov8" title="1">{
                // do not delete if the object is owned by a PipelineRun object
                // This can be removed once the PipelineRun controller is patched to stop updating the PipelineRun object
                // when child TaskRuns are deleted
                for _, or := range ownerReferences </span><span class="cov8" title="1">{
                        if or.Kind == "PipelineRun" </span><span class="cov8" title="1">{
                                logger.Debugw("Resource is owned by a PipelineRun, deferring deletion to parent PipelineRun", zap.Any("tekton.dev/PipelineRun", or.Name))
                                return nil
                        }</span>
                }
                // do not delete if CheckOwner flag is enabled and the object has some owner references
                <span class="cov8" title="1">if r.cfg.CheckOwner </span><span class="cov8" title="1">{
                        logger.Debugw("Resource is owned by another object, deferring deletion to parent resource(s)", zap.Any("results.tekton.dev/ownerReferences", ownerReferences))
                        return nil
                }</span>
        }

        <span class="cov8" title="1">completionTime, err := getCompletionTime(o)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // This isn't probable since the object is done, but defensive
        // programming never hurts.
        <span class="cov8" title="1">if completionTime == nil </span><span class="cov0" title="0">{
                logger.Debug("Object's completion time isn't set yet - requeuing to process later")
                return controller.NewRequeueAfter(gracePeriod)
        }</span>

        <span class="cov8" title="1">if timeSinceCompletion := clock.Since(*completionTime); timeSinceCompletion &lt; gracePeriod </span><span class="cov8" title="1">{
                requeueAfter := gracePeriod - timeSinceCompletion
                logger.Debugw("Object is not ready for deletion yet - requeuing to process later", zap.Duration("results.tekton.dev/requeueAfter", requeueAfter))
                return controller.NewRequeueAfter(requeueAfter)
        }</span>

        // Verify whether this object matches the provided label selectors
        <span class="cov8" title="1">if selectors := r.cfg.GetLabelSelector(); !selectors.Matches(labels.Set(o.GetLabels())) </span><span class="cov8" title="1">{
                logger.Debugw("Object doesn't match the required label selectors - requeuing to process later", zap.String("results.tekton.dev/label-selectors", selectors.String()))
                return controller.NewRequeueAfter(r.cfg.RequeueInterval)
        }</span>

        <span class="cov8" title="1">if isReady, err := r.IsReadyForDeletionFunc(ctx, o); err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if !isReady </span><span class="cov8" title="1">{
                return controller.NewRequeueAfter(r.cfg.RequeueInterval)
        }</span>

        <span class="cov8" title="1">logger.Infow("Deleting object", zap.String("results.tekton.dev/uid", string(o.GetUID())),
                zap.Int64("results.tekton.dev/time-taken-seconds", int64(time.Since(*completionTime).Seconds())))

        if err := r.objectClient.Delete(ctx, o.GetName(), metav1.DeleteOptions{
                Preconditions: metav1.NewUIDPreconditions(string(o.GetUID())),
        }); err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                logger.Debugw("Error deleting object", zap.Error(err))
                return fmt.Errorf("error deleting object: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Debugw("Object has been successfully deleted", zap.Int64("results.tekton.dev/time-taken-seconds", int64(time.Since(*completionTime).Seconds())))
        if r.AfterDeletion != nil </span><span class="cov0" title="0">{
                err = r.AfterDeletion(ctx, o)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to record deletion metrics", zap.Error(err))
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func isDone(o results.Object) bool <span class="cov8" title="1">{
        return !o.GetStatusCondition().GetCondition(apis.ConditionSucceeded).IsUnknown()
}</span>

// getCompletionTime returns the completion time of the object (PipelineRun or
// TaskRun) in question.
func getCompletionTime(object results.Object) (*time.Time, error) <span class="cov8" title="1">{
        var completionTime *time.Time

        switch o := object.(type) </span>{

        case *pipelinev1.PipelineRun:<span class="cov0" title="0">
                if o.Status.CompletionTime != nil </span><span class="cov0" title="0">{
                        completionTime = &amp;o.Status.CompletionTime.Time
                }</span>

        case *pipelinev1.TaskRun:<span class="cov8" title="1">
                if o.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                        completionTime = &amp;o.Status.CompletionTime.Time
                }</span>

        default:<span class="cov0" title="0">
                return nil, controller.NewPermanentError(fmt.Errorf("error getting completion time from incoming object: unrecognized type %T", o))</span>
        }
        <span class="cov8" title="1">return completionTime, nil</span>
}

// sendLog streams logs to the API server
func (r *Reconciler) sendLog(ctx context.Context, o results.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        condition := o.GetStatusCondition().GetCondition(apis.ConditionSucceeded)
        GVK := o.GetObjectKind().GroupVersionKind()
        if !GVK.Empty() &amp;&amp;
                (GVK.Kind == "TaskRun" || GVK.Kind == "PipelineRun") &amp;&amp;
                condition != nil &amp;&amp;
                condition.Type == "Succeeded" &amp;&amp;
                !condition.IsUnknown() </span><span class="cov8" title="1">{

                rec, err := r.resultsClient.GetLogRecord(ctx, o)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if rec != nil </span><span class="cov8" title="1">{
                        // we had already started logs streaming
                        parent, resName, recName, err := record.ParseName(rec.GetName())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">logName := log.FormatName(result.FormatName(parent, resName), recName)
                        // Update log annotation if it doesn't exist
                        return r.addResultsAnnotations(ctx, o, annotation.Annotation{Name: annotation.Log, Value: logName})</span>
                }

                // Create a log record if the object has/supports logs.
                <span class="cov8" title="1">rec, err = r.resultsClient.PutLog(ctx, o)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">parent, resName, recName, err := record.ParseName(rec.GetName())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">logName := log.FormatName(result.FormatName(parent, resName), recName)

                var logType string
                switch o.GetObjectKind().GroupVersionKind().Kind </span>{
                case "TaskRun":<span class="cov8" title="1">
                        logType = tknlog.LogTypeTask</span>
                case "PipelineRun":<span class="cov8" title="1">
                        logType = tknlog.LogTypePipeline</span>
                }

                <span class="cov8" title="1">if err := r.addResultsAnnotations(ctx, o, annotation.Annotation{Name: annotation.Log, Value: logName}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">logger.Debug("Streaming log started")

                err = r.streamLogs(ctx, o, logType, logName)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Errorw("Error streaming log", zap.Error(err))
                        // TODO once we have the log status available, report the error there for retry if needed
                }</span>
                <span class="cov8" title="1">logger.Info("Streaming log completed")</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) streamLogs(ctx context.Context, o results.Object, logType, logName string) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logsClient, err := r.resultsClient.UpdateLog(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create UpdateLog client: %w", err)
        }</span>

        <span class="cov8" title="1">writer := logs.NewBufferedWriter(logsClient, logName, logs.DefaultBufferSize)

        inMemWriteBufferStdout := bytes.NewBuffer(make([]byte, 0))
        inMemWriteBufferStderr := bytes.NewBuffer(make([]byte, 0))
        tknParams := &amp;cli.TektonParams{}
        tknParams.SetNamespace(o.GetNamespace())
        // KLUGE: tkn reader.Read() will raise an error if a step in the TaskRun failed and there is no
        // Err writer in the Stream object. This will result in some "error" messages being written to
        // the log.  That, coupled with the fact that the tkn client wrappers and oftent masks errors
        // makes it impossible to differentiate between retryable and permanent k8s errors wrt retrying
        // reconciliation in this controller

        reader, err := tknlog.NewReader(logType, &amp;tknopts.LogOptions{
                AllSteps:        true,
                Params:          tknParams,
                PipelineRunName: o.GetName(),
                TaskrunName:     o.GetName(),
                Timestamps:      r.cfg.LogsTimestamps,
                Stream: &amp;cli.Stream{
                        Out: inMemWriteBufferStdout,
                        Err: inMemWriteBufferStderr,
                },
        })
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create tkn reader: %w", err)
        }</span>
        <span class="cov0" title="0">logChan, errChan, err := reader.Read()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading from tkn reader: %w", err)
        }</span>

        <span class="cov0" title="0">tknlog.NewWriter(logType, true).Write(&amp;cli.Stream{
                Out: inMemWriteBufferStdout,
                Err: inMemWriteBufferStderr,
        }, logChan, errChan)

        // pull the first error that occurred and return on that; reminder - per https://golang.org/ref/spec#Channel_types
        // channels act as FIFO queues
        chanErr, ok := &lt;-errChan
        if ok &amp;&amp; chanErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error occurred while calling tkn client write: %w", chanErr)
        }</span>

        <span class="cov0" title="0">bufStdout := inMemWriteBufferStdout.Bytes()
        cntStdout, writeStdOutErr := writer.Write(bufStdout)
        if writeStdOutErr != nil </span><span class="cov0" title="0">{
                logger.Warnw("streamLogs in mem bufStdout write err", zap.String("error", writeStdOutErr.Error()))
        }</span>
        <span class="cov0" title="0">if cntStdout != len(bufStdout) </span><span class="cov0" title="0">{
                logger.Warnw("streamLogs bufStdout write len inconsistent",
                        zap.Int("in", len(bufStdout)),
                        zap.Int("out", cntStdout),
                )

        }</span>
        <span class="cov0" title="0">bufStderr := inMemWriteBufferStderr.Bytes()
        // we do not write these errors to the results api server

        // TODO we may need somehow discern the precise nature of the errors here and adjust how
        // we return accordingly
        if len(bufStderr) &gt; 0 </span><span class="cov0" title="0">{
                errStr := string(bufStderr)
                logger.Warnw("tkn client std error output",
                        zap.String("name", o.GetName()),
                        zap.String("errStr", errStr))
        }</span>

        <span class="cov0" title="0">_, flushErr := writer.Flush()
        if flushErr != nil </span><span class="cov0" title="0">{
                logger.Warnw("flush ret err", zap.String("error", flushErr.Error()))
                logger.Error(flushErr)
                return flushErr
        }</span>
        // so we use CloseAndRecv vs. just CloseSent to achieve a few things:
        // 1) CloseAndRecv calls CloseSend under the covers, followed by a Recv call to obtain a LogSummary
        // 2) LogSummary appears to have some stats on the state of operations
        // 3) It also appears to be the best form of "confirmation" that the asynchronous operation of UpdateLog on the api
        // server side has reached a terminal state
        // 4) Hence, creating a child context which we cancel hopefully does not interrupt the UpdateLog call when this method exits,
        // 5) However, we need the context cancel to close out the last goroutine launched in newClientStreamWithParams that does
        // the final clean, otherwise we end up with our now familiar goroutine leak, which in the end is a memory leak

        // comparing closeErr with io.EOF does not work; and I could not find code / desc etc. constants in the grpc code that handled
        // the wrapped EOF error we expect to get from grpc when things are "OK"
        <span class="cov0" title="0">if logSummary, closeErr := logsClient.CloseAndRecv(); closeErr != nil &amp;&amp; !strings.Contains(closeErr.Error(), "EOF") </span><span class="cov0" title="0">{
                logger.Warnw("CloseAndRecv ret err",
                        zap.String("name", o.GetName()),
                        zap.String("error", closeErr.Error()))
                if logSummary != nil </span><span class="cov0" title="0">{
                        logger.Errorw("CloseAndRecv", zap.String("logSummary", logSummary.String()))
                }</span>
                <span class="cov0" title="0">logger.Error(closeErr)
                return closeErr</span>
        }

        <span class="cov0" title="0">logger.Debug("Exiting streamLogs")

        return nil</span>
}

// storeEvents streams logs to the API server
func (r *Reconciler) storeEvents(ctx context.Context, o results.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        condition := o.GetStatusCondition().GetCondition(apis.ConditionSucceeded)
        GVK := o.GetObjectKind().GroupVersionKind()
        if !GVK.Empty() &amp;&amp;
                (GVK.Kind == "TaskRun" || GVK.Kind == "PipelineRun") &amp;&amp;
                condition != nil &amp;&amp;
                !condition.IsUnknown() </span><span class="cov8" title="1">{

                rec, err := r.resultsClient.GetEventListRecord(ctx, o)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if rec != nil </span><span class="cov8" title="1">{
                        // It means we have already stored events
                        eventListName := rec.GetName()
                        // Update Events annotation if it doesn't exist
                        return r.addResultsAnnotations(ctx, o, annotation.Annotation{Name: annotation.EventList, Value: eventListName})
                }</span>

                <span class="cov8" title="1">events, err := r.KubeClientSet.CoreV1().Events(o.GetNamespace()).List(ctx, metav1.ListOptions{
                        FieldSelector: "involvedObject.uid=" + string(o.GetUID()),
                })
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to store events - retrieve", zap.String("err", err.Error()))
                        return err
                }</span>

                <span class="cov8" title="1">tr, ok := o.(*pipelinev1.TaskRun)

                if ok </span><span class="cov8" title="1">{
                        podName := tr.Status.PodName
                        podEvents, err := r.KubeClientSet.CoreV1().Events(o.GetNamespace()).List(ctx, metav1.ListOptions{
                                FieldSelector: "involvedObject.name=" + podName,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("Failed to fetch taskrun pod events",
                                        zap.String("podname", podName),
                                        zap.String("err", err.Error()),
                                )
                        }</span>
                        <span class="cov8" title="1">if podEvents != nil &amp;&amp; len(podEvents.Items) &gt; 0 </span><span class="cov0" title="0">{
                                events.Items = append(events.Items, podEvents.Items...)
                        }</span>

                }

                <span class="cov8" title="1">data := filterEventList(events)
                eventList, err := json.Marshal(data)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Failed to store events - marshal", zap.String("err", err.Error()))
                        return err
                }</span>

                <span class="cov8" title="1">rec, err = r.resultsClient.PutEventList(ctx, o, eventList)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := r.addResultsAnnotations(ctx, o, annotation.Annotation{Name: annotation.EventList, Value: rec.GetName()}); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func filterEventList(events *v1.EventList) *v1.EventList <span class="cov8" title="1">{
        if events == nil || len(events.Items) == 0 </span><span class="cov8" title="1">{
                return events
        }</span>

        <span class="cov0" title="0">for i, event := range events.Items </span><span class="cov0" title="0">{
                // Only taking Name, Namespace and CreationTimeStamp for ObjectMeta
                events.Items[i].ObjectMeta = metav1.ObjectMeta{
                        Name:              event.Name,
                        Namespace:         event.Namespace,
                        CreationTimestamp: event.CreationTimestamp,
                }
        }</span>

        <span class="cov0" title="0">return events</span>
}

// addStoreAnnotations adds store annotations to the object in question if
// annotation patching is enabled.
func (r *Reconciler) addStoredAnnotations(ctx context.Context, o results.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        if r.resultsClient.LogsClient != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">if r.cfg.GetDisableAnnotationUpdate() </span><span class="cov0" title="0">{ //nolint:gocritic
                logger.Debug("Skipping CRD annotation patch: annotation update is disabled")
                return nil
        }</span>

        <span class="cov0" title="0">stored := annotation.Annotation{Name: annotation.Stored, Value: "false"}
        GVK := o.GetObjectKind().GroupVersionKind()

        if GVK.Empty() </span><span class="cov0" title="0">{
                logger.Debugf("Skipping CRD annotation patch: ObjectKind is empty ObjectName: %s", o.GetName())
                return nil
        }</span>

        // Checking if the object operation by other controllers is done
        <span class="cov0" title="0">switch GVK.Kind </span>{
        case "TaskRun":<span class="cov0" title="0">
                taskRun, ok := o.(*pipelinev1.TaskRun)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to cast object to TaskRun")
                }</span>
                <span class="cov0" title="0">if taskRun.IsDone() </span><span class="cov0" title="0">{
                        stored = annotation.Annotation{Name: annotation.Stored, Value: "true"}
                }</span>
        case "PipelineRun":<span class="cov0" title="0">
                pipelineRun, ok := o.(*pipelinev1.PipelineRun)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to cast object to PipelineRun")
                }</span>
                <span class="cov0" title="0">if pipelineRun.IsDone() </span><span class="cov0" title="0">{
                        stored = annotation.Annotation{Name: annotation.Stored, Value: "true"}
                }</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }

        <span class="cov0" title="0">err := annotation.Patch(ctx, o, r.objectClient, stored)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error patching object with stored annotation: %w ObjectName: %s", err, o.GetName())
                return fmt.Errorf("error patching object with stored annotation: %w ObjectName: %s", err, o.GetName())
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// addChildReadyForDeletionAnnotations set the ChildReadyForDeletion annotation
// on objects which have an owner and are done.
func (r *Reconciler) addChildReadyForDeletionAnnotations(ctx context.Context, o results.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if r.cfg.GetDisableAnnotationUpdate() </span><span class="cov8" title="1">{ //nolint:gocritic
                logger.Debug("Skipping CRD ChildReadyForDeletion annotation patch: annotation update is disabled")
                return nil
        }</span>

        <span class="cov8" title="1">if len(o.GetOwnerReferences()) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">doneObj, ok := o.(interface{ IsDone() bool })
        if !ok </span><span class="cov0" title="0">{
                logger.Errorf("Object %s does not have IsDone() method", o.GetName())
                return fmt.Errorf("object does not have IsDone() method")
        }</span>
        <span class="cov8" title="1">if !doneObj.IsDone() </span><span class="cov0" title="0">{
                logger.Debug("Skipping ChildReadyForDeletion annotation patch: object is not done yet")
                return nil
        }</span>

        <span class="cov8" title="1">childReadyForDeletion := annotation.Annotation{Name: annotation.ChildReadyForDeletion, Value: "true"}
        err := annotation.Patch(ctx, o, r.objectClient, childReadyForDeletion)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error patching object with ChildReadyForDeletion annotation: %w ObjectName: %s", err, o.GetName())
                return fmt.Errorf("error patching object with ChildReadyForDeletion annotation: %w ObjectName: %s", err, o.GetName())
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Copyright 2022 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package leaderelection provides a few utilities to help us to enable leader
// election support in the Watcher controllers.
package leaderelection

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/types"
        "knative.dev/pkg/reconciler"
)

// Lister is a generic signature of Lister.List functions, by allowing us to
// support various listers in the NewLeaderAwareFuncs function below.
type Lister[O metav1.Object] func(labels.Selector) ([]O, error)

// NewLeaderAwareFuncs returns a new reconciler.LeaderAwareFuncs object to be
// used in our controllers.
func NewLeaderAwareFuncs[O metav1.Object](lister Lister[O]) reconciler.LeaderAwareFuncs <span class="cov0" title="0">{
        return reconciler.LeaderAwareFuncs{
                PromoteFunc: func(bucket reconciler.Bucket, enqueue func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                        objects, err := lister(labels.Everything())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for _, object := range objects </span><span class="cov0" title="0">{
                                enqueue(bucket, types.NamespacedName{
                                        Namespace: object.GetNamespace(),
                                        Name:      object.GetName(),
                                })
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipelinerun

import (
        "context"

        "github.com/tektoncd/results/pkg/apis/config"
        "github.com/tektoncd/results/pkg/pipelinerunmetrics"
        "knative.dev/pkg/configmap"

        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipelineruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        "github.com/tektoncd/results/pkg/watcher/logs"
        "github.com/tektoncd/results/pkg/watcher/reconciler"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController creates a Controller for watching PipelineRuns.
func NewController(ctx context.Context, resultsClient pb.ResultsClient, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewControllerWithConfig(ctx, resultsClient, &amp;reconciler.Config{}, cmw)
}</span>

// NewControllerWithConfig creates a Controller for watching PipelineRuns by config.
func NewControllerWithConfig(ctx context.Context, resultsClient pb.ResultsClient, cfg *reconciler.Config, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        pipelineRunInformer := pipelineruninformer.Get(ctx)
        pipelineRunLister := pipelineRunInformer.Lister()
        logger := logging.FromContext(ctx)
        configStore := config.NewStore(logger.Named("config-store"), pipelinerunmetrics.MetricsOnStore(logger))
        configStore.WatchConfigs(cmw)

        c := &amp;Reconciler{
                kubeClientSet:     kubeclient.Get(ctx),
                resultsClient:     resultsClient,
                logsClient:        logs.Get(ctx),
                pipelineRunLister: pipelineRunLister,
                taskRunLister:     taskruninformer.Get(ctx).Lister(),
                pipelineClient:    pipelineclient.Get(ctx),
                cfg:               cfg,
                configStore:       configStore,
                metrics:           pipelinerunmetrics.NewRecorder(),
        }

        impl := pipelinerunreconciler.NewImpl(ctx, c, func(_ *controller.Impl) controller.Options </span><span class="cov0" title="0">{
                return controller.Options{
                        // This results pipelinerun reconciler shouldn't mutate the pipelinerun's status.
                        SkipStatusUpdates: true,
                        ConfigStore:       configStore,
                        FinalizerName:     "results.tekton.dev/pipelinerun",
                }
        }</span>)

        <span class="cov0" title="0">_, err := pipelineRunInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue))
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register PipelineRun informer event handler: %w", err)
        }</span>

        <span class="cov0" title="0">return impl</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pipelinerun

import (
        "context"
        "fmt"
        "time"

        "github.com/tektoncd/results/pkg/apis/config"
        "github.com/tektoncd/results/pkg/pipelinerunmetrics"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        pipelinev1listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "github.com/tektoncd/results/pkg/watcher/reconciler"
        resultsannotation "github.com/tektoncd/results/pkg/watcher/reconciler/annotation"
        "github.com/tektoncd/results/pkg/watcher/reconciler/client"
        "github.com/tektoncd/results/pkg/watcher/reconciler/dynamic"
        "github.com/tektoncd/results/pkg/watcher/results"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        knativereconciler "knative.dev/pkg/reconciler"
)

// Reconciler represents pipelineRun watcher logic
type Reconciler struct {

        // kubeClientSet allows us to talk to the k8s for core APIs
        kubeClientSet kubernetes.Interface

        resultsClient     pb.ResultsClient
        logsClient        pb.LogsClient
        pipelineRunLister pipelinev1listers.PipelineRunLister
        taskRunLister     pipelinev1listers.TaskRunLister
        pipelineClient    versioned.Interface
        cfg               *reconciler.Config
        metrics           *pipelinerunmetrics.Recorder
        configStore       *config.Store
}

// Check that our Reconciler implements pipelinerunreconciler.Interface and pipelinerunreconciler.Finalizer
var _ pipelinerunreconciler.Interface = (*Reconciler)(nil)
var _ pipelinerunreconciler.Finalizer = (*Reconciler)(nil)

// ReconcileKind makes new watcher reconcile cycle to handle PipelineRun.
func (r *Reconciler) ReconcileKind(ctx context.Context, pr *pipelinev1.PipelineRun) knativereconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx).With(zap.String("results.tekton.dev/kind", "PipelineRun"))

        logger.Infof("Initiating reconciliation for PipelineRun '%s/%s'", pr.Namespace, pr.Name)

        if r.cfg.DisableStoringIncompleteRuns </span><span class="cov8" title="1">{
                // Skip if pipelinerun is not done
                if !pr.IsDone() </span><span class="cov8" title="1">{
                        logger.Debugf("pipelinerun %s/%s is not done and incomplete runs are disabled, skipping storing", pr.Namespace, pr.Name)
                        return nil
                }</span>

                // Skip if pipelinerun is already stored
                <span class="cov8" title="1">if pr.Annotations != nil &amp;&amp; pr.Annotations[resultsannotation.Stored] == "true" </span><span class="cov8" title="1">{
                        logger.Debugf("pipelinerun %s/%s is already stored, skipping", pr.Namespace, pr.Name)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">pipelineRunClient := &amp;client.PipelineRunClient{
                PipelineRunInterface: r.pipelineClient.TektonV1().PipelineRuns(pr.Namespace),
        }

        dyn := dynamic.NewDynamicReconciler(r.kubeClientSet, r.resultsClient, r.logsClient, pipelineRunClient, r.cfg)
        // Tell the dynamic reconciler to wait until all underlying TaskRuns are
        // ready for deletion before deleting the PipelineRun. This guarantees
        // that the TaskRuns will not be deleted before their final state being
        // properly archived into the API server.
        dyn.IsReadyForDeletionFunc = r.areAllUnderlyingTaskRunsReadyForDeletion
        dyn.AfterDeletion = func(ctx context.Context, object results.Object) error </span><span class="cov0" title="0">{
                pr := object.(*pipelinev1.PipelineRun)
                return r.metrics.DurationAndCountDeleted(ctx, r.configStore.Load().Metrics, pr)
        }</span>

        <span class="cov0" title="0">return dyn.Reconcile(logging.WithLogger(ctx, logger), pr)</span>
}

func (r *Reconciler) areAllUnderlyingTaskRunsReadyForDeletion(ctx context.Context, object results.Object) (bool, error) <span class="cov8" title="1">{
        pipelineRun, ok := object.(*pipelinev1.PipelineRun)
        if !ok </span><span class="cov0" title="0">{
                return false, fmt.Errorf("unexpected object (must not happen): want %T, but got %T", &amp;pipelinev1.PipelineRun{}, object)
        }</span>

        <span class="cov8" title="1">logger := logging.FromContext(ctx)

        if len(pipelineRun.Status.ChildReferences) &gt; 0 </span><span class="cov8" title="1">{
                for _, reference := range pipelineRun.Status.ChildReferences </span><span class="cov8" title="1">{
                        taskRun, err := r.taskRunLister.TaskRuns(pipelineRun.Namespace).Get(reference.Name)
                        if err != nil </span><span class="cov8" title="1">{
                                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                                        // Let's assume that the TaskRun in
                                        // question is gone and therefore, we
                                        // can safely ignore it.
                                        logger.Debugf("TaskRun %s/%s associated with PipelineRun %s is no longer available. Skipping.", pipelineRun.Namespace, reference.Name, pipelineRun.Name)
                                        continue</span>
                                }
                                <span class="cov0" title="0">return false, fmt.Errorf("error reading TaskRun from the indexer: %w", err)</span>
                        }
                        <span class="cov8" title="1">if !isMarkedAsReadyForDeletion(taskRun) </span><span class="cov8" title="1">{
                                logger.Debugf("TaskRun %s/%s associated with PipelineRun %s isn't yet ready to be deleted - the annotation %s is missing", taskRun.Namespace, taskRun.Name, pipelineRun.Name, resultsannotation.ChildReadyForDeletion)
                                return false, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return true, nil</span>
}

func isMarkedAsReadyForDeletion(taskRun *pipelinev1.TaskRun) bool <span class="cov8" title="1">{
        if taskRun.Annotations == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if _, found := taskRun.Annotations[resultsannotation.ChildReadyForDeletion]; found </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// FinalizeKind implements pipelinerunreconciler.Finalizer
// We utilize finalizers to ensure that we get a crack at storing every pipelinerun
// that we see flowing through the system.  If we don't add a finalizer, it could
// get cleaned up before we see the final state and store it.
func (r *Reconciler) FinalizeKind(ctx context.Context, pr *pipelinev1.PipelineRun) knativereconciler.Event <span class="cov0" title="0">{
        // Reconcile the pipelinerun to ensure that it is stored in the database
        rerr := r.ReconcileKind(ctx, pr)

        return r.finalize(ctx, pr, rerr)
}</span>

func (r *Reconciler) finalize(ctx context.Context, pr *pipelinev1.PipelineRun, rerr error) knativereconciler.Event <span class="cov8" title="1">{
        // If logsClient isn't nil, it means we have logging storage enabled
        // and we can't use finalizers to coordinate deletion.
        if r.logsClient != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If annotation update is disabled, we can't use finalizers to coordinate deletion.
        <span class="cov8" title="1">if r.cfg.DisableAnnotationUpdate </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check to make sure the PipelineRun is finished.
        <span class="cov8" title="1">if !pr.IsDone() </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("pipelinerun %s/%s is still running", pr.Namespace, pr.Name)
                return nil
        }</span>

        <span class="cov8" title="1">var storeDeadline, now time.Time

        // Check if the store deadline is configured
        if r.cfg.StoreDeadline != nil </span><span class="cov8" title="1">{
                if pr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Infof("removing finalizer without wait, no completion time set for pipelinerun %s/%s",
                                pr.Namespace, pr.Name)
                        return nil
                }</span>
                <span class="cov8" title="1">now = time.Now().UTC()
                storeDeadline = pr.Status.CompletionTime.UTC().Add(*r.cfg.StoreDeadline)
                if now.After(storeDeadline) </span><span class="cov8" title="1">{
                        logging.FromContext(ctx).Debugf("store deadline: %s now: %s, completion time: %s", storeDeadline.String(), now.String(),
                                pr.Status.CompletionTime.UTC().String())
                        logging.FromContext(ctx).Debugf("store deadline has passed for pipelinerun %s/%s", pr.Namespace, pr.Name)
                        _, ok := pr.Annotations[resultsannotation.Stored]
                        if !ok </span><span class="cov8" title="1">{
                                logging.FromContext(ctx).Errorf("pipelinerun not stored: %s/%s, uid: %s,",
                                        pr.Namespace, pr.Name, pr.UID)
                        }</span>
                        <span class="cov8" title="1">return nil</span> // Proceed with deletion
                }
        }

        <span class="cov8" title="1">if pr.Annotations == nil </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("pipelinerun %s/%s annotations are missing, now: %s, storeDeadline: %s",
                        pr.Namespace, pr.Name, now.String(), storeDeadline.String())
                return controller.NewRequeueAfter(r.cfg.FinalizerRequeueInterval)
        }</span>

        <span class="cov8" title="1">stored, ok := pr.Annotations[resultsannotation.Stored]
        if !ok </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("stored annotation is missing on pipelinerun %s/%s, now: %s, storeDeadline: %s",
                        pr.Namespace, pr.Name, now.String(), storeDeadline.String())
                return controller.NewRequeueAfter(r.cfg.FinalizerRequeueInterval)
        }</span>
        <span class="cov8" title="1">if rerr != nil || stored != "true" </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("stored annotation is not true on pipelinerun %s/%s, now: %s, storeDeadline: %s",
                        pr.Namespace, pr.Name, now.String(), storeDeadline.String())
                return controller.NewRequeueAfter(r.cfg.FinalizerRequeueInterval)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">// Copyright 2020 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package taskrun

import (
        "context"

        "github.com/tektoncd/results/pkg/apis/config"
        "github.com/tektoncd/results/pkg/taskrunmetrics"
        "github.com/tektoncd/results/pkg/watcher/logs"
        "knative.dev/pkg/configmap"

        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        "github.com/tektoncd/results/pkg/watcher/reconciler"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController creates a Controller for watching TaskRuns.
func NewController(ctx context.Context, resultsClient pb.ResultsClient, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return NewControllerWithConfig(ctx, resultsClient, &amp;reconciler.Config{}, cmw)
}</span>

// NewControllerWithConfig creates a Controller for watching TaskRuns by config.
func NewControllerWithConfig(ctx context.Context, resultsClient pb.ResultsClient, cfg *reconciler.Config, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        informer := taskruninformer.Get(ctx)
        lister := informer.Lister()
        logger := logging.FromContext(ctx)
        configStore := config.NewStore(logger.Named("config-store"), taskrunmetrics.MetricsOnStore(logger))
        configStore.WatchConfigs(cmw)

        c := &amp;Reconciler{
                kubeClientSet:  kubeclient.Get(ctx),
                resultsClient:  resultsClient,
                logsClient:     logs.Get(ctx),
                lister:         lister,
                pipelineClient: pipelineclient.Get(ctx),
                cfg:            cfg,
                configStore:    configStore,
                metrics:        taskrunmetrics.NewRecorder(),
        }

        impl := taskrunreconciler.NewImpl(ctx, c, func(_ *controller.Impl) controller.Options </span><span class="cov0" title="0">{
                return controller.Options{
                        // This results pipelinerun reconciler shouldn't mutate the pipelinerun's status.
                        SkipStatusUpdates: true,
                        ConfigStore:       configStore,
                        FinalizerName:     "results.tekton.dev/taskrun",
                }
        }</span>)

        <span class="cov0" title="0">_, err := informer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue))
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Couldn't register TaskRun informer event handler: %w", err)
        }</span>

        <span class="cov0" title="0">return impl</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package taskrun

import (
        "context"
        "time"

        "github.com/tektoncd/results/pkg/apis/config"
        "github.com/tektoncd/results/pkg/taskrunmetrics"
        "github.com/tektoncd/results/pkg/watcher/results"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"

        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        v1 "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "github.com/tektoncd/results/pkg/watcher/reconciler"
        resultsannotation "github.com/tektoncd/results/pkg/watcher/reconciler/annotation"
        "github.com/tektoncd/results/pkg/watcher/reconciler/client"
        "github.com/tektoncd/results/pkg/watcher/reconciler/dynamic"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "go.uber.org/zap"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        knativereconciler "knative.dev/pkg/reconciler"
)

// Reconciler represents taskRun watcher logic
type Reconciler struct {

        // kubeClientSet allows us to talk to the k8s for core APIs
        kubeClientSet kubernetes.Interface

        resultsClient  pb.ResultsClient
        logsClient     pb.LogsClient
        lister         v1.TaskRunLister
        pipelineClient versioned.Interface
        cfg            *reconciler.Config
        metrics        *taskrunmetrics.Recorder
        configStore    *config.Store
}

// Check that our Reconciler implements taskrunreconciler.Interface and taskrunreconciler.Finalizer
var _ taskrunreconciler.Interface = (*Reconciler)(nil)
var _ taskrunreconciler.Finalizer = (*Reconciler)(nil)

// ReconcileKind makes new watcher reconcile cycle to handle TaskRun.
func (r *Reconciler) ReconcileKind(ctx context.Context, tr *pipelinev1.TaskRun) knativereconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx).With(zap.String("results.tekton.dev/kind", "TaskRun"))

        if r.cfg.DisableStoringIncompleteRuns </span><span class="cov8" title="1">{
                // Skip if taskrun is not done
                if !tr.IsDone() </span><span class="cov8" title="1">{
                        logger.Debugf("taskrun %s/%s is not done and incomplete runs are disabled, skipping storing", tr.Namespace, tr.Name)
                        return nil
                }</span>

                // Skip if taskrun is already stored
                <span class="cov8" title="1">if tr.Annotations != nil &amp;&amp; tr.Annotations[resultsannotation.Stored] == "true" </span><span class="cov8" title="1">{
                        logger.Debugf("taskrun %s/%s is already stored, skipping", tr.Namespace, tr.Name)
                        return nil
                }</span>
        }

        <span class="cov0" title="0">taskRunClient := &amp;client.TaskRunClient{
                TaskRunInterface: r.pipelineClient.TektonV1().TaskRuns(tr.Namespace),
        }

        dyn := dynamic.NewDynamicReconciler(r.kubeClientSet, r.resultsClient, r.logsClient, taskRunClient, r.cfg)
        dyn.AfterDeletion = func(ctx context.Context, o results.Object) error </span><span class="cov0" title="0">{
                tr := o.(*pipelinev1.TaskRun)
                return r.metrics.DurationAndCountDeleted(ctx, r.configStore.Load().Metrics, tr)
        }</span>
        <span class="cov0" title="0">return dyn.Reconcile(logging.WithLogger(ctx, logger), tr)</span>
}

// FinalizeKind implements pipelinerunreconciler.Finalizer
// We utilize finalizers to ensure that we get a crack at storing every taskrun
// that we see flowing through the system.  If we don't add a finalizer, it could
// get cleaned up before we see the final state and store it.
func (r *Reconciler) FinalizeKind(ctx context.Context, tr *pipelinev1.TaskRun) knativereconciler.Event <span class="cov0" title="0">{
        // Reconcile the taskrun to ensure that it is stored in the database
        rerr := r.ReconcileKind(ctx, tr)

        return r.finalize(ctx, tr, rerr)
}</span>

func (r *Reconciler) finalize(ctx context.Context, tr *pipelinev1.TaskRun, rerr error) knativereconciler.Event <span class="cov8" title="1">{
        // If logsClient isn't nil, it means we have logging storage enabled
        // and we can't use finalizers to coordinate deletion.
        if r.logsClient != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // If annotation update is disabled, we can't use finalizers to coordinate deletion.
        <span class="cov8" title="1">if r.cfg.DisableAnnotationUpdate </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check the TaskRun has finished.
        <span class="cov8" title="1">if !tr.IsDone() </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("taskrun %s/%s is still running", tr.Namespace, tr.Name)
                return nil
        }</span>

        <span class="cov8" title="1">now := time.Now().UTC()

        // Check if the forwarding buffer is configured and passed
        if r.cfg.ForwardBuffer != nil </span><span class="cov0" title="0">{
                if tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Infof("removing finalizer without wait, no completion time set for taskrun %s/%s",
                                tr.Namespace, tr.Name)
                        return nil
                }</span>
                <span class="cov0" title="0">buffer := tr.Status.CompletionTime.UTC().Add(*r.cfg.ForwardBuffer)
                if !now.After(buffer) </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Debugf("log forwarding buffer wait for taskrun %s/%s", tr.Namespace, tr.Name)
                        return controller.NewRequeueAfter(r.cfg.FinalizerRequeueInterval)
                }</span>
        }

        <span class="cov8" title="1">var storeDeadline time.Time

        // Check if the store deadline is configured
        if r.cfg.StoreDeadline != nil </span><span class="cov8" title="1">{
                if tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Infof("removing finalizer without wait, no completion time set for taskrun %s/%s",
                                tr.Namespace, tr.Name)
                        return nil
                }</span>
                <span class="cov8" title="1">storeDeadline = tr.Status.CompletionTime.UTC().Add(*r.cfg.StoreDeadline)
                if now.After(storeDeadline) </span><span class="cov8" title="1">{
                        logging.FromContext(ctx).Debugf("store deadline: %s now: %s, completion time: %s", storeDeadline.String(), now.String(),
                                tr.Status.CompletionTime.UTC().String())
                        logging.FromContext(ctx).Debugf("store deadline has passed for taskrun %s/%s", tr.Namespace, tr.Name)
                        _, ok := tr.Annotations[resultsannotation.Stored]
                        if !ok </span><span class="cov8" title="1">{
                                logging.FromContext(ctx).Errorf("taskrun not stored: %s/%s, uid: %s,",
                                        tr.Namespace, tr.Name, tr.UID)
                        }</span>
                        <span class="cov8" title="1">return nil</span> // Proceed with deletion
                }
        }

        <span class="cov8" title="1">if tr.Annotations == nil </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("taskrun %s/%s annotations are missing, now: %s, storeDeadline: %s",
                        tr.Namespace, tr.Name, now.String(), storeDeadline.String())
                return controller.NewRequeueAfter(r.cfg.FinalizerRequeueInterval)
        }</span>

        <span class="cov8" title="1">stored, ok := tr.Annotations[resultsannotation.Stored]
        if !ok </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("stored annotation is missing on taskrun %s/%s, now: %s, storeDeadline: %s",
                        tr.Namespace, tr.Name, now.String(), storeDeadline.String())
                return controller.NewRequeueAfter(r.cfg.FinalizerRequeueInterval)
        }</span>
        <span class="cov8" title="1">if rerr != nil || stored != "true" </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Debugf("stored annotation is not true on taskrun %s/%s, now: %s, storeDeadline: %s",
                        tr.Namespace, tr.Name, now.String(), storeDeadline.String())
                return controller.NewRequeueAfter(r.cfg.FinalizerRequeueInterval)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package results

import (
        "context"

        "github.com/google/uuid"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/apis/v1alpha3"
        "github.com/tektoncd/results/pkg/watcher/reconciler/annotation"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// PutEventList adds the given Object to the Results API.
// If the parent result is missing or the object is not yet associated with a
// result, one is created automatically.
func (c *Client) PutEventList(ctx context.Context, o Object, eventList []byte, opts ...grpc.CallOption) (*pb.Record, error) <span class="cov0" title="0">{
        res, err := c.ensureResult(ctx, o, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c.createEventListRecord(ctx, res, o, eventList, opts...)</span>
}

// createEventListRecord creates a record for eventlist.
func (c *Client) createEventListRecord(ctx context.Context, result *pb.Result, o Object, eventList []byte, opts ...grpc.CallOption) (*pb.Record, error) <span class="cov0" title="0">{
        name, err := getEventListRecordName(result, o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rec, err := c.GetRecord(ctx, &amp;pb.GetRecordRequest{Name: name}, opts...)
        if err != nil &amp;&amp; status.Code(err) != codes.NotFound </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if rec != nil </span><span class="cov0" title="0">{
                return rec, nil
        }</span>
        <span class="cov0" title="0">return c.CreateRecord(ctx, &amp;pb.CreateRecordRequest{
                Parent: result.GetName(),
                Record: &amp;pb.Record{
                        Name: name,
                        Data: &amp;pb.Any{
                                Type:  v1alpha3.EventListRecordType,
                                Value: eventList,
                        },
                },
        })</span>
}

// getEventListRecordName gets the eventlist name to use for the given object.
// The name is derived from a known Tekton annotation if available, else
// the object's UID is used to create MD5 UUID.
func getEventListRecordName(result *pb.Result, o Object) (string, error) <span class="cov0" title="0">{
        name, ok := o.GetAnnotations()[annotation.EventList]
        if ok </span><span class="cov0" title="0">{
                return name, nil
        }</span>
        <span class="cov0" title="0">uid, err := uuid.Parse(result.GetUid())
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return FormatEventListName(result.GetName(), uid, o), nil</span>
}

// FormatEventListName generates record name for EventList given resultName,
// result UUID and object - taskrun/pipelinerun.
func FormatEventListName(resultName string, resultUID uuid.UUID, o Object) string <span class="cov0" title="0">{
        return record.FormatName(resultName,
                uuid.NewMD5(resultUID, []byte(o.GetUID()+"eventlist")).String())
}</span>

// GetEventListRecord returns eventlist record using gRPC clients.
func (c *Client) GetEventListRecord(ctx context.Context, o Object) (*pb.Record, error) <span class="cov0" title="0">{
        res, err := c.ensureResult(ctx, o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">name, err := getEventListRecordName(res, o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rec, err := c.GetRecord(ctx, &amp;pb.GetRecordRequest{Name: name})
        if err != nil &amp;&amp; status.Code(err) == codes.NotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return rec, err</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package results

import (
        "context"

        "github.com/google/uuid"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/log"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/watcher/convert"
        "github.com/tektoncd/results/pkg/watcher/reconciler/annotation"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// PutLog adds the given Object to the Results API.
// If the parent result is missing or the object is not yet associated with a
// result, one is created automatically.
func (c *Client) PutLog(ctx context.Context, o Object, opts ...grpc.CallOption) (*pb.Record, error) <span class="cov8" title="1">{
        res, err := c.ensureResult(ctx, o, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.createLogRecord(ctx, res, o, opts...)</span>
}

// createLogRecord creates a record for logs.
func (c *Client) createLogRecord(ctx context.Context, result *pb.Result, o Object, opts ...grpc.CallOption) (*pb.Record, error) <span class="cov8" title="1">{
        name, err := getLogRecordName(result, o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">kind := o.GetObjectKind().GroupVersionKind().Kind
        rec, err := c.GetRecord(ctx, &amp;pb.GetRecordRequest{Name: name}, opts...)
        if err != nil &amp;&amp; status.Code(err) != codes.NotFound </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if rec != nil </span><span class="cov8" title="1">{
                return rec, nil
        }</span>
        <span class="cov8" title="1">data, err := convert.ToLogProto(o, kind, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return c.CreateRecord(ctx, &amp;pb.CreateRecordRequest{
                Parent: result.GetName(),
                Record: &amp;pb.Record{
                        Name: name,
                        Data: data,
                },
        })</span>
}

// getLogRecordName gets the log name to use for the given object.
// The name is derived from a known Tekton annotation if available, else
// the object's UID is used to create MD5 UUID.
func getLogRecordName(result *pb.Result, o Object) (string, error) <span class="cov8" title="1">{
        name, ok := o.GetAnnotations()[annotation.Log]
        if ok </span><span class="cov0" title="0">{
                _, _, name, err := log.ParseName(name)
                if err == nil </span><span class="cov0" title="0">{
                        return record.FormatName(result.GetName(), name), nil
                }</span>
        }
        <span class="cov8" title="1">uid, err := uuid.Parse(result.GetUid())
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return record.FormatName(result.GetName(), uuid.NewMD5(uid, []byte(o.GetUID())).String()), nil</span>
}

// GetLogRecord returns log record using gRPC clients.
func (c *Client) GetLogRecord(ctx context.Context, o Object) (*pb.Record, error) <span class="cov0" title="0">{
        res, err := c.ensureResult(ctx, o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">name, err := getLogRecordName(res, o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">rec, err := c.GetRecord(ctx, &amp;pb.GetRecordRequest{Name: name})
        if err != nil &amp;&amp; status.Code(err) == codes.NotFound </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return rec, err</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright 2021 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package results

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "go.uber.org/zap"

        "github.com/google/go-cmp/cmp"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/record"
        "github.com/tektoncd/results/pkg/api/server/v1alpha2/result"
        "github.com/tektoncd/results/pkg/watcher/convert"
        "github.com/tektoncd/results/pkg/watcher/reconciler"
        "github.com/tektoncd/results/pkg/watcher/reconciler/annotation"
        pb "github.com/tektoncd/results/proto/v1alpha2/results_go_proto"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/testing/protocmp"
        "google.golang.org/protobuf/types/known/timestamppb"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

const (
        // objectName is used to store the name of the object in the result summary
        objectName = "object.metadata.name"
)

// Client is a wrapper around a Results client that provides helpful utilities
// for performing result operations that require multiple RPCs or data specific
// operations.
type Client struct {
        pb.ResultsClient
        pb.LogsClient
        reconciler.Config
}

// NewClient returns a new results client for the particular kind.
func NewClient(resultsClient pb.ResultsClient, logsClient pb.LogsClient, reconcilerConfig *reconciler.Config) *Client <span class="cov0" title="0">{
        return &amp;Client{
                ResultsClient: resultsClient,
                LogsClient:    logsClient,
                Config:        *reconcilerConfig,
        }
}</span>

// Object is a union type of different base k8s Object interfaces.
// This is similar in spirit to
// https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.9.4/pkg/client#Object,
// but is defined as its own type to avoid an extra dependency.
type Object interface {
        metav1.Object
        runtime.Object
        StatusConditionGetter
}

// StatusConditionGetter defines status for Object interface
type StatusConditionGetter interface {
        GetStatusCondition() apis.ConditionAccessor
}

// Put adds the given Object to the Results API.
// If the parent result is missing or the object is not yet associated with a
// result, one is created automatically.
// If the Object is already associated with a Record, the existing Record is
// updated - otherwise a new Record is created.
func (c *Client) Put(ctx context.Context, o Object, opts ...grpc.CallOption) (*pb.Result, *pb.Record, error) <span class="cov8" title="1">{
        // Make sure parent Result exists (or create one)
        res, err := c.ensureResult(ctx, o, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Create or update the rec.
        <span class="cov8" title="1">rec, err := c.upsertRecord(ctx, res.GetName(), o, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return res, rec, nil</span>
}

// ensureResult gets the Result corresponding to the Object, creates a new
// one, or updates the existing Result with new Object details if necessary.
func (c *Client) ensureResult(ctx context.Context, o Object, opts ...grpc.CallOption) (*pb.Result, error) <span class="cov8" title="1">{
        resName := resultName(o)
        curr, err := c.ResultsClient.GetResult(ctx, &amp;pb.GetResultRequest{Name: resName}, opts...)
        if err != nil &amp;&amp; status.Code(err) != codes.NotFound </span><span class="cov0" title="0">{
                return nil, status.Errorf(status.Code(err), "GetResult(%s): %v", resName, err)
        }</span>

        <span class="cov8" title="1">res := &amp;pb.Result{
                Name: resName,
        }
        recName := recordName(resName, o)
        topLevel := isTopLevelRecord(o)
        logger := logging.FromContext(ctx).With(zap.String(annotation.Result, resName),
                zap.String(annotation.Record, recName),
                zap.Bool("results.tekton.dev/top-level-record", topLevel))

        if topLevel </span><span class="cov8" title="1">{
                // If the object corresponds to a top level record  - include a RecordSummary.
                res.Summary = &amp;pb.RecordSummary{
                        Record:    recName,
                        Type:      convert.TypeName(o),
                        Status:    convert.Status(o.GetStatusCondition()),
                        StartTime: getTimestamp(o.GetStatusCondition().GetCondition(apis.ConditionReady)),
                        EndTime:   getTimestamp(o.GetStatusCondition().GetCondition(apis.ConditionSucceeded)),
                }
        }</span>

        // Set the Result.Annotations and Result.Summary.Annotations fields if
        // the object in question contains the required annotations.
        <span class="cov8" title="1">res.Annotations = map[string]string{}
        if value, found := o.GetAnnotations()[annotation.ResultAnnotations]; found </span><span class="cov8" title="1">{
                resultAnnotations, err := parseAnnotations(annotation.ResultAnnotations, value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">var annotations map[string]string
                if curr != nil &amp;&amp; len(curr.Annotations) != 0 </span><span class="cov0" title="0">{
                        copyKeys(resultAnnotations, curr.Annotations)
                        annotations = curr.Annotations
                }</span> else<span class="cov8" title="1"> {
                        annotations = resultAnnotations
                }</span>
                <span class="cov8" title="1">res.Annotations = annotations</span>
        }

        <span class="cov8" title="1">if topLevel </span><span class="cov8" title="1">{
                if value, found := o.GetAnnotations()[annotation.RecordSummaryAnnotations]; found </span><span class="cov8" title="1">{
                        recordSummaryAnnotations, err := parseAnnotations(annotation.RecordSummaryAnnotations, value)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">var annotations map[string]string
                        if curr != nil &amp;&amp; curr.Summary != nil &amp;&amp; len(curr.Summary.Annotations) != 0 </span><span class="cov0" title="0">{
                                copyKeys(recordSummaryAnnotations, curr.Summary.Annotations)
                                annotations = curr.Summary.Annotations
                        }</span> else<span class="cov8" title="1"> {
                                annotations = recordSummaryAnnotations
                        }</span>
                        <span class="cov8" title="1">res.Summary.Annotations = annotations</span>
                }
                // Set the Result.Summary.Labels fields if the object in question contains the required labels.
                <span class="cov8" title="1">summaryLabels := strings.Split(c.Config.SummaryLabels, ",")
                if len(summaryLabels) &gt; 0 &amp;&amp; summaryLabels[0] != "" </span><span class="cov0" title="0">{
                        for _, v := range summaryLabels </span><span class="cov0" title="0">{
                                if value, found := o.GetLabels()[v]; found </span><span class="cov0" title="0">{
                                        res.Annotations[v] = value
                                }</span>
                        }
                }
                <span class="cov8" title="1">summaryAnnotations := strings.Split(c.Config.SummaryAnnotations, ",")
                if len(summaryAnnotations) &gt; 0 &amp;&amp; summaryAnnotations[0] != "" </span><span class="cov0" title="0">{
                        for _, v := range summaryAnnotations </span><span class="cov0" title="0">{
                                if value, found := o.GetLabels()[v]; found </span><span class="cov0" title="0">{
                                        res.Annotations[v] = value
                                }</span>
                        }
                }
                <span class="cov8" title="1">res.Annotations[objectName] = o.GetName()</span>
        }

        // Regardless of whether the object is a top level record or not,
        // if the Result doesn't exist yet just create it and return.
        <span class="cov8" title="1">if status.Code(err) == codes.NotFound </span><span class="cov8" title="1">{
                logger.Debug("Result doesn't exist yet - creating")
                req := &amp;pb.CreateResultRequest{
                        Parent: parentName(o),
                        Result: res,
                }
                return c.ResultsClient.CreateResult(ctx, req, opts...)
        }</span>

        // From here on, we're checking to see if there are any updates that need
        // to be made to the Record.

        <span class="cov8" title="1">if !topLevel </span><span class="cov0" title="0">{
                // If the object isn't top level there's nothing else to do because we
                // won't be modifying the RecordSummary.
                logger.Debug("No further actions to be done on the Result: the object is not a top level record")
                return curr, nil
        }</span>

        // If this object is a top level record, only update if there's been a
        // change to the RecordSummary (only looking at the summary also helps us
        // avoid OUTPUT_ONLY fields in the Result)
        <span class="cov8" title="1">if cmp.Equal(curr.GetSummary(), res.GetSummary(), protocmp.Transform()) </span><span class="cov8" title="1">{
                logger.Debug("No further actions to be done on the Result: no differences found")
                return curr, nil
        }</span>
        <span class="cov8" title="1">req := &amp;pb.UpdateResultRequest{
                Name:   resName,
                Result: res,
        }
        return c.ResultsClient.UpdateResult(ctx, req, opts...)</span>
}

// parseAnnotations attempts to return the provided value as a map of strings.
func parseAnnotations(annotationKey, value string) (map[string]string, error) <span class="cov8" title="1">{
        var data map[string]interface{}
        if err := json.Unmarshal([]byte(value), &amp;data); err != nil </span><span class="cov0" title="0">{
                return nil, controller.NewPermanentError(fmt.Errorf("error parsing annotation %s: %w", annotationKey, err))
        }</span>
        <span class="cov8" title="1">annotations := map[string]string{}
        for i, v := range data </span><span class="cov8" title="1">{
                annotations[i] = fmt.Sprint(v)
        }</span>
        <span class="cov8" title="1">return annotations, nil</span>
}

func copyKeys(in, out map[string]string) <span class="cov0" title="0">{
        for key, value := range in </span><span class="cov0" title="0">{
                out[key] = value
        }</span>
}

func getTimestamp(c *apis.Condition) *timestamppb.Timestamp <span class="cov8" title="1">{
        if c == nil || c.IsFalse() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return timestamppb.New(c.LastTransitionTime.Inner.Time)</span>
}

// resultName gets the result name to use for the given object.
// The name is derived from a known Tekton annotation if available, else
// the object's name is used.
func resultName(o metav1.Object) string <span class="cov8" title="1">{
        // Special case result annotations, since this should already be the
        // full result identifier.
        if v, ok := o.GetAnnotations()[annotation.Result]; ok </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">var part string
        if v, ok := o.GetLabels()["triggers.tekton.dev/triggers-eventid"]; ok </span><span class="cov8" title="1">{
                // Don't prefix trigger events. These are 1) not CRD types, 2) are
                // intended to be unique identifiers already, and 3) should be applied
                // to all objects created via trigger templates, so there's no need to
                // prefix these to avoid collision.
                part = v
        }</span> else<span class="cov8" title="1"> if len(o.GetOwnerReferences()) &gt; 0 </span><span class="cov8" title="1">{
                for _, owner := range o.GetOwnerReferences() </span><span class="cov8" title="1">{
                        if strings.EqualFold(owner.Kind, "pipelinerun") </span><span class="cov8" title="1">{
                                part = string(owner.UID)
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if part == "" </span><span class="cov8" title="1">{
                part = defaultName(o)
        }</span>
        <span class="cov8" title="1">return result.FormatName(o.GetNamespace(), part)</span>
}

func recordName(parent string, o Object) string <span class="cov8" title="1">{
        // Attempt to read the record name from annotations only if the object
        // in question is a top-level record (i.e. it isn't owned by another
        // object). Otherwise, the annotation containing the record name maybe
        // was propagated by the owner what causes conflicts while upserting the
        // object into the API. For further details, please see
        // https://github.com/tektoncd/results/issues/296.
        if isTopLevelRecord(o) </span><span class="cov8" title="1">{
                if name, ok := o.GetAnnotations()[annotation.Record]; ok </span><span class="cov8" title="1">{
                        return name
                }</span>
        }
        <span class="cov8" title="1">return record.FormatName(parent, defaultName(o))</span>
}

// parentName returns the parent's name of the result in question. If the
// results annotation is set, returns the first segment of the result
// name. Otherwise, returns the object's namespace.
func parentName(o metav1.Object) string <span class="cov8" title="1">{
        if value, found := o.GetAnnotations()[annotation.Result]; found </span><span class="cov8" title="1">{
                if parts := strings.Split(value, "/"); len(parts) != 0 </span><span class="cov8" title="1">{
                        return parts[0]
                }</span>
        }
        <span class="cov8" title="1">return o.GetNamespace()</span>
}

// upsertRecord updates or creates a record for the object. If there has been
// no change in the Record data, the existing Record is returned.
func (c *Client) upsertRecord(ctx context.Context, parent string, o Object, opts ...grpc.CallOption) (*pb.Record, error) <span class="cov8" title="1">{
        recName := recordName(parent, o)
        logger := logging.FromContext(ctx).With(zap.String(annotation.Record, recName))
        data, err := convert.ToProto(o)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">curr, err := c.GetRecord(ctx, &amp;pb.GetRecordRequest{Name: recName}, opts...)
        if err != nil &amp;&amp; status.Code(err) != codes.NotFound </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if curr != nil </span><span class="cov8" title="1">{
                // Data already exists for the Record - update it iff there is a diff of Data.
                if cmp.Equal(data, curr.GetData(), protocmp.Transform()) </span><span class="cov8" title="1">{
                        logger.Debug("No further actions to be done on the Record: no changes found")
                        return curr, nil
                }</span>

                <span class="cov8" title="1">logger.Debug("Updating Record")
                curr.Data = data
                return c.UpdateRecord(ctx, &amp;pb.UpdateRecordRequest{
                        Record: curr,
                        Etag:   curr.GetEtag(),
                }, opts...)</span>
        }

        <span class="cov8" title="1">logger.Debug("Record doesn't exist yet - creating")
        return c.CreateRecord(ctx, &amp;pb.CreateRecordRequest{
                Parent: parent,
                Record: &amp;pb.Record{
                        Name: recName,
                        Data: data,
                },
        }, opts...)</span>
}

// defaultName is the default Result/Record name that should be used if one is
// not already associated to the Object.
func defaultName(o metav1.Object) string <span class="cov8" title="1">{
        return string(o.GetUID())
}</span>

// isTopLevelRecord determines whether an Object is a top level Record - e.g. a
// Record that should be considered the primary record for the result for purposes
// of timing, status, etc. For example, if a Result contains records for a PipelineRun
// and TaskRun, the PipelineRun should take precedence.
// We define an Object to be top level if it does not have any OwnerReferences.
func isTopLevelRecord(o Object) bool <span class="cov8" title="1">{
        return len(o.GetOwnerReferences()) == 0
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
