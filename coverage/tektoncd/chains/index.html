
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controller: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/chains/cmd/controller/main.go (0.0%)</option>
				
				<option value="file1">github.com/tektoncd/chains/pkg/artifacts/signable.go (70.4%)</option>
				
				<option value="file2">github.com/tektoncd/chains/pkg/artifacts/structured.go (96.3%)</option>
				
				<option value="file3">github.com/tektoncd/chains/pkg/chains/annotations.go (83.0%)</option>
				
				<option value="file4">github.com/tektoncd/chains/pkg/chains/formats/format.go (0.0%)</option>
				
				<option value="file5">github.com/tektoncd/chains/pkg/chains/formats/simple/simple.go (66.7%)</option>
				
				<option value="file6">github.com/tektoncd/chains/pkg/chains/formats/slsa/attest/attest.go (0.0%)</option>
				
				<option value="file7">github.com/tektoncd/chains/pkg/chains/formats/slsa/extract/extract.go (76.4%)</option>
				
				<option value="file8">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/artifact/append.go (100.0%)</option>
				
				<option value="file9">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_definition/build_definition.go (77.8%)</option>
				
				<option value="file10">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/compare/slsacompare.go (0.0%)</option>
				
				<option value="file11">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/external_parameters/external_parameters.go (100.0%)</option>
				
				<option value="file12">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/internal_parameters/internal_parameters.go (100.0%)</option>
				
				<option value="file13">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/material/material.go (90.1%)</option>
				
				<option value="file14">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/metadata/metadata.go (100.0%)</option>
				
				<option value="file15">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/provenance/provenance.go (0.0%)</option>
				
				<option value="file16">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/resolved_dependencies/resolved_dependencies.go (83.3%)</option>
				
				<option value="file17">github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/results/results.go (80.0%)</option>
				
				<option value="file18">github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/internal/protos/protos.go (0.0%)</option>
				
				<option value="file19">github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/intotoite6.go (61.5%)</option>
				
				<option value="file20">github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/pipelinerun/pipelinerun.go (74.4%)</option>
				
				<option value="file21">github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/taskrun/buildconfig.go (100.0%)</option>
				
				<option value="file22">github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/taskrun/taskrun.go (54.2%)</option>
				
				<option value="file23">github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha3/internal/pipelinerun/pipelinerun.go (81.2%)</option>
				
				<option value="file24">github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha3/internal/taskrun/taskrun.go (81.2%)</option>
				
				<option value="file25">github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha3/slsav2.go (58.3%)</option>
				
				<option value="file26">github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha4/internal/pipelinerun/pipelinerun.go (84.6%)</option>
				
				<option value="file27">github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha4/internal/taskrun/taskrun.go (86.7%)</option>
				
				<option value="file28">github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha4/slsav2.go (33.3%)</option>
				
				<option value="file29">github.com/tektoncd/chains/pkg/chains/objects/objects.go (38.5%)</option>
				
				<option value="file30">github.com/tektoncd/chains/pkg/chains/rekor.go (26.7%)</option>
				
				<option value="file31">github.com/tektoncd/chains/pkg/chains/signing.go (70.4%)</option>
				
				<option value="file32">github.com/tektoncd/chains/pkg/chains/signing/kms/kms.go (53.8%)</option>
				
				<option value="file33">github.com/tektoncd/chains/pkg/chains/signing/wrap.go (0.0%)</option>
				
				<option value="file34">github.com/tektoncd/chains/pkg/chains/signing/x509/fsprovider.go (85.7%)</option>
				
				<option value="file35">github.com/tektoncd/chains/pkg/chains/signing/x509/x509.go (46.2%)</option>
				
				<option value="file36">github.com/tektoncd/chains/pkg/chains/storage/archivista/archivista.go (63.6%)</option>
				
				<option value="file37">github.com/tektoncd/chains/pkg/chains/storage/docdb/docdb.go (41.8%)</option>
				
				<option value="file38">github.com/tektoncd/chains/pkg/chains/storage/gcs/gcs.go (70.1%)</option>
				
				<option value="file39">github.com/tektoncd/chains/pkg/chains/storage/grafeas/grafeas.go (78.2%)</option>
				
				<option value="file40">github.com/tektoncd/chains/pkg/chains/storage/oci/attestation.go (82.1%)</option>
				
				<option value="file41">github.com/tektoncd/chains/pkg/chains/storage/oci/legacy.go (40.0%)</option>
				
				<option value="file42">github.com/tektoncd/chains/pkg/chains/storage/oci/options.go (100.0%)</option>
				
				<option value="file43">github.com/tektoncd/chains/pkg/chains/storage/oci/simple.go (83.3%)</option>
				
				<option value="file44">github.com/tektoncd/chains/pkg/chains/storage/pubsub/pubsub.go (58.6%)</option>
				
				<option value="file45">github.com/tektoncd/chains/pkg/chains/storage/storage.go (31.7%)</option>
				
				<option value="file46">github.com/tektoncd/chains/pkg/chains/storage/tekton/tekton.go (80.6%)</option>
				
				<option value="file47">github.com/tektoncd/chains/pkg/chains/verifier.go (0.0%)</option>
				
				<option value="file48">github.com/tektoncd/chains/pkg/config/config.go (91.8%)</option>
				
				<option value="file49">github.com/tektoncd/chains/pkg/config/store.go (40.0%)</option>
				
				<option value="file50">github.com/tektoncd/chains/pkg/internal/mocksigner/mocksigner.go (0.0%)</option>
				
				<option value="file51">github.com/tektoncd/chains/pkg/internal/objectloader/objectloader.go (0.0%)</option>
				
				<option value="file52">github.com/tektoncd/chains/pkg/patch/patch.go (80.0%)</option>
				
				<option value="file53">github.com/tektoncd/chains/pkg/pipelinerunmetrics/fake/fake.go (0.0%)</option>
				
				<option value="file54">github.com/tektoncd/chains/pkg/pipelinerunmetrics/injection.go (70.0%)</option>
				
				<option value="file55">github.com/tektoncd/chains/pkg/pipelinerunmetrics/metrics.go (86.2%)</option>
				
				<option value="file56">github.com/tektoncd/chains/pkg/reconciler/filter.go (100.0%)</option>
				
				<option value="file57">github.com/tektoncd/chains/pkg/reconciler/pipelinerun/controller.go (82.8%)</option>
				
				<option value="file58">github.com/tektoncd/chains/pkg/reconciler/pipelinerun/pipelinerun.go (82.9%)</option>
				
				<option value="file59">github.com/tektoncd/chains/pkg/reconciler/taskrun/controller.go (84.0%)</option>
				
				<option value="file60">github.com/tektoncd/chains/pkg/reconciler/taskrun/taskrun.go (77.8%)</option>
				
				<option value="file61">github.com/tektoncd/chains/pkg/taskrunmetrics/fake/fake.go (0.0%)</option>
				
				<option value="file62">github.com/tektoncd/chains/pkg/taskrunmetrics/injection.go (70.0%)</option>
				
				<option value="file63">github.com/tektoncd/chains/pkg/taskrunmetrics/metrics.go (85.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "flag"
        "strings"

        "github.com/tektoncd/chains/pkg/reconciler/pipelinerun"
        "github.com/tektoncd/chains/pkg/reconciler/taskrun"

        "k8s.io/client-go/rest"

        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/injection/sharedmain"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/signals"

        // Run with all of the upstream providers.
        // We link this here to give downstreams greater choice/control over
        // which providers they pull in, by linking their own variants in their
        // own binary entrypoint.
        _ "github.com/sigstore/cosign/v2/pkg/providers/all"

        // Register the provider-specific plugins
        _ "github.com/sigstore/sigstore/pkg/signature/kms/aws"
        _ "github.com/sigstore/sigstore/pkg/signature/kms/azure"
        _ "github.com/sigstore/sigstore/pkg/signature/kms/gcp"
        _ "github.com/sigstore/sigstore/pkg/signature/kms/hashivault"
)

func main() <span class="cov0" title="0">{
        flag.IntVar(&amp;controller.DefaultThreadsPerController, "threads-per-controller", controller.DefaultThreadsPerController, "Threads (goroutines) to create per controller")
        namespaceList := flag.String("namespace", "", "Comma-separated list of namespaces to restrict informer to. Optional, if empty defaults to all namespaces.")

        // This also calls flag.Parse().
        cfg := injection.ParseAndGetRESTConfigOrDie()

        ctx := signals.NewContext()
        logger := logging.FromContext(ctx)

        var namespaces []string
        if *namespaceList != "" </span><span class="cov0" title="0">{
                // Remove any whitespace from the namespaces string and split it
                namespaces = strings.Split(strings.ReplaceAll(*namespaceList, " ", ""), ",")
                logger.Infof("controller is scoped to the following namespaces: %s\n", namespaces)
        }</span>

        <span class="cov0" title="0">if cfg.QPS == 0 </span><span class="cov0" title="0">{
                cfg.QPS = 2 * rest.DefaultQPS
        }</span>
        <span class="cov0" title="0">if cfg.Burst == 0 </span><span class="cov0" title="0">{
                cfg.Burst = rest.DefaultBurst
        }</span>

        // Multiply by number of controllers
        <span class="cov0" title="0">cfg.QPS = 2 * cfg.QPS
        cfg.Burst = 2 * cfg.Burst

        sharedmain.MainWithConfig(ctx, "watcher", cfg, taskrun.NewNamespacesScopedController(namespaces), pipelinerun.NewNamespacesScopedController(namespaces))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package artifacts

import (
        "context"
        _ "crypto/sha256" // Recommended by go-digest.
        _ "crypto/sha512" // Recommended by go-digest.
        "fmt"
        "regexp"
        "strings"

        "github.com/google/go-containerregistry/pkg/name"
        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
        "github.com/opencontainers/go-digest"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/logging"
)

const (
        ArtifactsInputsResultName  = "ARTIFACT_INPUTS"
        ArtifactsOutputsResultName = "ARTIFACT_OUTPUTS"
        OCIScheme                  = "oci://"
        GitSchemePrefix            = "git+"
        isBuildArtifactField       = "isBuildArtifact"
        OCIImageURLResultName      = "IMAGE_URL"
        OCIImageDigestResultName   = "IMAGE_DIGEST"
        OCIImagesResultName        = "IMAGES"
)

var (
        Sha1Regexp *regexp.Regexp = regexp.MustCompile(`^[a-f0-9]{40}$`)
)

type Signable interface {
        ExtractObjects(ctx context.Context, obj objects.TektonObject) []interface{}
        StorageBackend(cfg config.Config) sets.Set[string]
        Signer(cfg config.Config) string
        PayloadFormat(cfg config.Config) config.PayloadType
        // FullKey returns the full identifier for a signable artifact.
        // - For OCI artifact, it is the full representation in the format of `&lt;NAME&gt;@sha256:&lt;DIGEST&gt;`.
        // - For TaskRun/PipelineRun artifact, it is `&lt;GROUP&gt;-&lt;VERSION&gt;-&lt;KIND&gt;-&lt;UID&gt;`
        FullKey(interface{}) string
        // ShortKey returns the short version  of an artifact identifier.
        // - For OCI artifact, it is first 12 chars of the image digest.
        // - For TaskRun/PipelineRun artifact, it is `&lt;KIND&gt;-&lt;UID&gt;`.
        ShortKey(interface{}) string
        Type() string
        Enabled(cfg config.Config) bool
}

type TaskRunArtifact struct{}

var _ Signable = &amp;TaskRunArtifact{}

func (ta *TaskRunArtifact) ShortKey(obj interface{}) string <span class="cov0" title="0">{
        tro := obj.(*objects.TaskRunObjectV1)
        return "taskrun-" + string(tro.UID)
}</span>

func (ta *TaskRunArtifact) FullKey(obj interface{}) string <span class="cov0" title="0">{
        tro := obj.(*objects.TaskRunObjectV1)
        gvk := tro.GetGroupVersionKind()
        return fmt.Sprintf("%s-%s-%s-%s", gvk.Group, gvk.Version, gvk.Kind, tro.UID)
}</span>

func (ta *TaskRunArtifact) ExtractObjects(ctx context.Context, obj objects.TektonObject) []interface{} <span class="cov0" title="0">{
        return []interface{}{obj}
}</span>

func (ta *TaskRunArtifact) Type() string <span class="cov0" title="0">{
        return "tekton"
}</span>

func (ta *TaskRunArtifact) StorageBackend(cfg config.Config) sets.Set[string] <span class="cov0" title="0">{
        return cfg.Artifacts.TaskRuns.StorageBackend
}</span>

func (ta *TaskRunArtifact) PayloadFormat(cfg config.Config) config.PayloadType <span class="cov0" title="0">{
        return config.PayloadType(cfg.Artifacts.TaskRuns.Format)
}</span>

func (ta *TaskRunArtifact) Signer(cfg config.Config) string <span class="cov0" title="0">{
        return cfg.Artifacts.TaskRuns.Signer
}</span>

func (ta *TaskRunArtifact) Enabled(cfg config.Config) bool <span class="cov0" title="0">{
        return cfg.Artifacts.TaskRuns.Enabled()
}</span>

type PipelineRunArtifact struct{}

var _ Signable = &amp;PipelineRunArtifact{}

func (pa *PipelineRunArtifact) ShortKey(obj interface{}) string <span class="cov0" title="0">{
        pro := obj.(*objects.PipelineRunObjectV1)
        return "pipelinerun-" + string(pro.UID)
}</span>

func (pa *PipelineRunArtifact) FullKey(obj interface{}) string <span class="cov0" title="0">{
        pro := obj.(*objects.PipelineRunObjectV1)
        gvk := pro.GetGroupVersionKind()
        return fmt.Sprintf("%s-%s-%s-%s", gvk.Group, gvk.Version, gvk.Kind, pro.UID)
}</span>

func (pa *PipelineRunArtifact) ExtractObjects(ctx context.Context, obj objects.TektonObject) []interface{} <span class="cov0" title="0">{
        return []interface{}{obj}
}</span>

func (pa *PipelineRunArtifact) Type() string <span class="cov0" title="0">{
        // TODO: Is this right?
        return "tekton-pipeline-run"
}</span>

func (pa *PipelineRunArtifact) StorageBackend(cfg config.Config) sets.Set[string] <span class="cov0" title="0">{
        return cfg.Artifacts.PipelineRuns.StorageBackend
}</span>

func (pa *PipelineRunArtifact) PayloadFormat(cfg config.Config) config.PayloadType <span class="cov0" title="0">{
        return config.PayloadType(cfg.Artifacts.PipelineRuns.Format)
}</span>

func (pa *PipelineRunArtifact) Signer(cfg config.Config) string <span class="cov0" title="0">{
        return cfg.Artifacts.PipelineRuns.Signer
}</span>

func (pa *PipelineRunArtifact) Enabled(cfg config.Config) bool <span class="cov0" title="0">{
        return cfg.Artifacts.PipelineRuns.Enabled()
}</span>

type OCIArtifact struct{}

var _ Signable = &amp;OCIArtifact{}

type image struct {
        url    string
        digest string
}

func (oa *OCIArtifact) ExtractObjects(ctx context.Context, obj objects.TektonObject) []interface{} <span class="cov8" title="1">{
        objs := []interface{}{}

        // Now check TaskResults
        resultImages := ExtractOCIImagesFromResults(ctx, obj.GetResults())
        objs = append(objs, resultImages...)

        return objs
}</span>

// ExtractOCIImagesFromResults returns all the results marked as OCIImage type-hint result.
func ExtractOCIImagesFromResults(ctx context.Context, results []objects.Result) []interface{} <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        objs := []interface{}{}

        extractor := structuredSignableExtractor{
                uriSuffix:    OCIImageURLResultName,
                digestSuffix: OCIImageDigestResultName,
                isValid:      hasImageRequirements,
        }
        for _, s := range extractor.extract(ctx, results) </span><span class="cov8" title="1">{
                dgst, err := name.NewDigest(fmt.Sprintf("%s@%s", s.URI, s.Digest))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error getting digest: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">objs = append(objs, dgst)</span>
        }

        // look for a comma separated list of images
        <span class="cov8" title="1">for _, key := range results </span><span class="cov8" title="1">{
                if key.Name != OCIImagesResultName </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">imgs := strings.FieldsFunc(key.Value.StringVal, split)

                for _, img := range imgs </span><span class="cov8" title="1">{
                        trimmed := strings.TrimSpace(img)
                        if trimmed == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">dgst, err := name.NewDigest(trimmed)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("error getting digest for img %s: %v", trimmed, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">objs = append(objs, dgst)</span>
                }
        }

        <span class="cov8" title="1">return objs</span>
}

// ExtractSignableTargetFromResults extracts signable targets that aim to generate intoto provenance as materials within TaskRun results and store them as StructuredSignable.
func ExtractSignableTargetFromResults(ctx context.Context, obj objects.TektonObject) []StructuredSignable <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        extractor := structuredSignableExtractor{
                uriSuffix:    "ARTIFACT_URI",
                digestSuffix: "ARTIFACT_DIGEST",
                isValid: func(s StructuredSignable) bool </span><span class="cov8" title="1">{
                        if !hasImageRequirements(s) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">if _, _, err := ParseDigest(s.Digest); err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("error getting digest %s: %v", s.Digest, err)
                                return false
                        }</span>
                        <span class="cov8" title="1">return true</span>
                },
        }
        <span class="cov8" title="1">return extractor.extract(ctx, obj.GetResults())</span>
}

// FullRef returns the full reference of the signable artifact in the format of URI@DIGEST
func (s *StructuredSignable) FullRef() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s@%s", s.URI, s.Digest)
}</span>

// RetrieveMaterialsFromStructuredResults retrieves structured results from Object Results, and convert them into materials.
func RetrieveMaterialsFromStructuredResults(ctx context.Context, objResults []objects.Result) []common.ProvenanceMaterial <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        // Retrieve structured provenance for inputs.
        mats := []common.ProvenanceMaterial{}
        ssts := ExtractStructuredTargetFromResults(ctx, objResults, ArtifactsInputsResultName)
        for _, s := range ssts </span><span class="cov8" title="1">{
                alg, digest, err := ParseDigest(s.Digest)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Debugf("Digest for %s not in the right format: %s, %v", s.URI, s.Digest, err)
                        continue</span>
                }
                <span class="cov8" title="1">mats = append(mats, common.ProvenanceMaterial{
                        URI:    s.URI,
                        Digest: map[string]string{alg: digest},
                })</span>
        }
        <span class="cov8" title="1">return mats</span>
}

// ExtractStructuredTargetFromResults extracts structured signable targets aim to generate intoto provenance as materials within TaskRun results and store them as StructuredSignable.
// categoryMarker categorizes signable targets into inputs and outputs.
func ExtractStructuredTargetFromResults(ctx context.Context, objResults []objects.Result, categoryMarker string) []*StructuredSignable <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        objs := []*StructuredSignable{}
        if categoryMarker != ArtifactsInputsResultName &amp;&amp; categoryMarker != ArtifactsOutputsResultName </span><span class="cov0" title="0">{
                return objs
        }</span>

        // TODO(#592): support structured results using Run
        <span class="cov8" title="1">for _, res := range objResults </span><span class="cov8" title="1">{
                if strings.HasSuffix(res.Name, categoryMarker) </span><span class="cov8" title="1">{
                        valid, err := isStructuredResult(res, categoryMarker)
                        if err != nil </span><span class="cov8" title="1">{
                                logger.Debugf("ExtractStructuredTargetFromResults: %v", err)
                        }</span>
                        <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                                logger.Debugf("Extracted Structured data from Result %s, %s", res.Value.ObjectVal["uri"], res.Value.ObjectVal["digest"])
                                objs = append(objs, &amp;StructuredSignable{URI: res.Value.ObjectVal["uri"], Digest: res.Value.ObjectVal["digest"]})
                        }</span>
                }
        }
        <span class="cov8" title="1">return objs</span>
}

// ExtractBuildArtifactsFromResults extracts all the structured signable targets from the given results, only processing the ones marked as build artifacts.
func ExtractBuildArtifactsFromResults(ctx context.Context, results []objects.Result) (objs []*StructuredSignable) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        for _, res := range results </span><span class="cov8" title="1">{
                valid, err := IsBuildArtifact(res)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Debugf("ExtractBuildArtifactsFromResults failed validatin artifact %v, ignoring artifact, err: %v", res.Name, err)
                        continue</span>
                }
                <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                        logger.Debugf("Extracted Build artifact data from Result %s, %s", res.Value.ObjectVal["uri"], res.Value.ObjectVal["digest"])
                        objs = append(objs, &amp;StructuredSignable{URI: res.Value.ObjectVal["uri"], Digest: res.Value.ObjectVal["digest"]})
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// IsBuildArtifact indicates if a given result was marked as a Build Artifact.
func IsBuildArtifact(res objects.Result) (bool, error) <span class="cov8" title="1">{
        if !strings.HasSuffix(res.Name, ArtifactsOutputsResultName) </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if res.Value.ObjectVal == nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("%s should be an object: %v", res.Name, res.Value.ObjectVal)
        }</span>

        <span class="cov8" title="1">if res.Value.ObjectVal[isBuildArtifactField] != "true" </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">return isValidArtifactOutput(res)</span>
}

func isStructuredResult(res objects.Result, categoryMarker string) (bool, error) <span class="cov8" title="1">{
        if !strings.HasSuffix(res.Name, categoryMarker) </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">if res.Value.ObjectVal == nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("%s should be an object: %v", res.Name, res.Value.ObjectVal)
        }</span>
        <span class="cov8" title="1">return isValidArtifactOutput(res)</span>
}

func isValidArtifactOutput(res objects.Result) (bool, error) <span class="cov8" title="1">{
        if res.Value.ObjectVal["uri"] == "" </span><span class="cov8" title="1">{
                return false, fmt.Errorf("%s should have uri field: %v", res.Name, res.Value.ObjectVal)
        }</span>
        <span class="cov8" title="1">if res.Value.ObjectVal["digest"] == "" </span><span class="cov8" title="1">{
                return false, fmt.Errorf("%s should have digest field: %v", res.Name, res.Value.ObjectVal)
        }</span>
        <span class="cov8" title="1">if _, _, err := ParseDigest(res.Value.ObjectVal["digest"]); err != nil </span><span class="cov8" title="1">{
                return false, fmt.Errorf("error getting digest %s: %v", res.Value.ObjectVal["digest"], err)
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

// ParseDigest parses the digest string and returns the algorithm and hex section of the digest.
func ParseDigest(dig string) (algo_string string, hex string, err error) <span class="cov8" title="1">{
        parts := strings.Split(dig, ":")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("digest string %s, not in the format of &lt;algorithm&gt;:&lt;digest&gt;", dig)
        }</span>
        <span class="cov8" title="1">algo_string = strings.ToLower(strings.TrimSpace(parts[0]))
        algo := digest.Algorithm(algo_string)
        hex = strings.TrimSpace(parts[1])

        switch </span>{
        case algo.Available():<span class="cov8" title="1">
                if err := algo.Validate(hex); err != nil </span><span class="cov8" title="1">{
                        return "", "", err
                }</span>
        case algo_string == "sha1":<span class="cov8" title="1">
                // Version 1.0.0, which is the released version, of go_digest does not support SHA1,
                // hence this has to be handled differently.
                if !Sha1Regexp.MatchString(hex) </span><span class="cov8" title="1">{
                        return "", "", fmt.Errorf("sha1 digest %s does not match regexp %s", dig, Sha1Regexp.String())
                }</span>
        default:<span class="cov8" title="1">
                return "", "", fmt.Errorf("unsupported digest algorithm: %s", dig)</span>

        }
        <span class="cov8" title="1">return algo_string, hex, nil</span>
}

// split allows IMAGES to be separated either by commas (for backwards compatibility)
// or by newlines
func split(r rune) bool <span class="cov8" title="1">{
        return r == '\n' || r == ','
}</span>

func (oa *OCIArtifact) Type() string <span class="cov0" title="0">{
        return "oci"
}</span>

func (oa *OCIArtifact) StorageBackend(cfg config.Config) sets.Set[string] <span class="cov0" title="0">{
        return cfg.Artifacts.OCI.StorageBackend
}</span>

func (oa *OCIArtifact) PayloadFormat(cfg config.Config) config.PayloadType <span class="cov0" title="0">{
        return config.PayloadType(cfg.Artifacts.OCI.Format)
}</span>

func (oa *OCIArtifact) Signer(cfg config.Config) string <span class="cov0" title="0">{
        return cfg.Artifacts.OCI.Signer
}</span>

func (oa *OCIArtifact) ShortKey(obj interface{}) string <span class="cov0" title="0">{
        v := obj.(name.Digest)
        return strings.TrimPrefix(v.DigestStr(), "sha256:")[:12]
}</span>

func (oa *OCIArtifact) FullKey(obj interface{}) string <span class="cov0" title="0">{
        v := obj.(name.Digest)
        return v.Name()
}</span>

func (oa *OCIArtifact) Enabled(cfg config.Config) bool <span class="cov0" title="0">{
        return cfg.Artifacts.OCI.Enabled()
}</span>

func hasImageRequirements(s StructuredSignable) bool <span class="cov8" title="1">{
        return s.URI != "" &amp;&amp; s.Digest != ""
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package artifacts

import (
        "context"
        "strings"

        "github.com/tektoncd/chains/pkg/chains/objects"
        "knative.dev/pkg/logging"
)

// StructuredSignable contains info for signable targets to become either subjects or materials in
// intoto Statements.
// URI is the resource uri for the target needed iff the target is a material.
// Digest is the target's SHA digest.
type StructuredSignable struct {
        URI    string
        Digest string
}

type structuredSignableExtractor struct {
        uriSuffix    string
        digestSuffix string
        isValid      func(StructuredSignable) bool
}

func (b *structuredSignableExtractor) extract(ctx context.Context, results []objects.Result) []StructuredSignable <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        partials := map[string]StructuredSignable{}

        suffixes := map[string]func(StructuredSignable, string) StructuredSignable{
                b.uriSuffix: func(s StructuredSignable, value string) StructuredSignable </span><span class="cov8" title="1">{
                        s.URI = value
                        return s
                }</span>,
                b.digestSuffix: func(s StructuredSignable, value string) StructuredSignable <span class="cov8" title="1">{
                        s.Digest = value
                        return s
                }</span>,
        }

        <span class="cov8" title="1">for _, res := range results </span><span class="cov8" title="1">{
                for suffix, setFn := range suffixes </span><span class="cov8" title="1">{
                        if suffix == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if !strings.HasSuffix(res.Name, suffix) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">value := strings.TrimSpace(res.Value.StringVal)
                        if value == "" </span><span class="cov8" title="1">{
                                logger.Debugf("error getting string value for %s", res.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">marker := strings.TrimSuffix(res.Name, suffix)
                        if _, ok := partials[marker]; !ok </span><span class="cov8" title="1">{
                                partials[marker] = StructuredSignable{}
                        }</span>
                        <span class="cov8" title="1">partials[marker] = setFn(partials[marker], value)</span>
                }
        }

        <span class="cov8" title="1">var signables []StructuredSignable
        for _, s := range partials </span><span class="cov8" title="1">{
                if !b.isValid(s) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">signables = append(signables, s)</span>
        }

        <span class="cov8" title="1">return signables</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package chains

import (
        "context"
        "fmt"
        "strconv"
        "strings"

        "github.com/pkg/errors"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/patch"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "knative.dev/pkg/logging"
)

const (
        // ChainsAnnotationPrefix is the prefix for all Chains annotations
        ChainsAnnotationPrefix = "chains.tekton.dev/"
        // ChainsAnnotation is the standard annotation to indicate a TR has been signed.
        ChainsAnnotation             = "chains.tekton.dev/signed"
        RetryAnnotation              = "chains.tekton.dev/retries"
        ChainsTransparencyAnnotation = "chains.tekton.dev/transparency"
        MaxRetries                   = 3
)

// Reconciled determines whether a Tekton object has already been reconciled.
// It first inspects the state of the given TektonObject. If that indicates it
// has not been reconciled, then Reconciled fetches the latest version of the
// TektonObject from the cluster and inspects that version as well. This aims
// to avoid creating multiple attestations due to a stale cached TektonObject.
func Reconciled(ctx context.Context, client versioned.Interface, obj objects.TektonObject) bool <span class="cov8" title="1">{
        if reconciledFromAnnotations(obj.GetAnnotations()) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">logger := logging.FromContext(ctx)
        annotations, err := obj.GetLatestAnnotations(ctx, client)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("Ignoring error when fetching latest annotations: %s", err)
                return false
        }</span>
        <span class="cov8" title="1">return reconciledFromAnnotations(annotations)</span>
}

func reconciledFromAnnotations(annotations map[string]string) bool <span class="cov8" title="1">{
        val, ok := annotations[ChainsAnnotation]
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return val == "true" || val == "failed"</span>
}

// MarkSigned marks a Tekton object as signed.
func MarkSigned(ctx context.Context, obj objects.TektonObject, ps versioned.Interface, annotations map[string]string) error <span class="cov8" title="1">{
        if _, ok := obj.GetAnnotations()[ChainsAnnotation]; ok </span><span class="cov0" title="0">{
                // Object is already signed, but we may still need to apply additional annotations
                if len(annotations) &gt; 0 </span><span class="cov0" title="0">{
                        return AddAnnotation(ctx, obj, ps, ChainsAnnotation, "true", annotations)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov8" title="1">return AddAnnotation(ctx, obj, ps, ChainsAnnotation, "true", annotations)</span>
}

func MarkFailed(ctx context.Context, obj objects.TektonObject, ps versioned.Interface, annotations map[string]string) error <span class="cov8" title="1">{
        return AddAnnotation(ctx, obj, ps, ChainsAnnotation, "failed", annotations)
}</span>

func RetryAvailable(obj objects.TektonObject) bool <span class="cov8" title="1">{
        ann, ok := obj.GetAnnotations()[RetryAnnotation]
        if !ok </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">val, err := strconv.Atoi(ann)
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return val &lt; MaxRetries</span>
}

func AddRetry(ctx context.Context, obj objects.TektonObject, ps versioned.Interface, annotations map[string]string) error <span class="cov8" title="1">{
        ann := obj.GetAnnotations()[RetryAnnotation]
        if ann == "" </span><span class="cov8" title="1">{
                return AddAnnotation(ctx, obj, ps, RetryAnnotation, "0", annotations)
        }</span>
        <span class="cov8" title="1">val, err := strconv.Atoi(ann)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "adding retry")
        }</span>
        <span class="cov8" title="1">return AddAnnotation(ctx, obj, ps, RetryAnnotation, fmt.Sprintf("%d", val+1), annotations)</span>
}

func AddAnnotation(ctx context.Context, obj objects.TektonObject, ps versioned.Interface, key, value string, annotations map[string]string) error <span class="cov8" title="1">{
        // Get current annotations from API server to ensure we have the latest state
        currentAnnotations, err := obj.GetLatestAnnotations(ctx, ps)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Start with existing chains annotations, ignore annotations from other controllers,
        // so we do not take ownership of them.
        <span class="cov8" title="1">mergedAnnotations := make(map[string]string)
        for k, v := range currentAnnotations </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, ChainsAnnotationPrefix) </span><span class="cov8" title="1">{
                        mergedAnnotations[k] = v
                }</span>
        }

        // Add the new chains annotations, they all must be chains annotations
        <span class="cov8" title="1">for k, v := range annotations </span><span class="cov8" title="1">{
                if !strings.HasPrefix(k, ChainsAnnotationPrefix) </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid annotation key %q: all annotations must have prefix %q", k, ChainsAnnotationPrefix)
                }</span>
                <span class="cov8" title="1">mergedAnnotations[k] = v</span>
        }

        // Add the specific key-value pair, again it must be chains annotation
        <span class="cov8" title="1">if !strings.HasPrefix(key, ChainsAnnotationPrefix) </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid annotation key %q: all annotations must have prefix %q", key, ChainsAnnotationPrefix)
        }</span>
        <span class="cov8" title="1">mergedAnnotations[key] = value

        patchBytes, err := patch.GetAnnotationsPatch(mergedAnnotations, obj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = obj.Patch(ctx, ps, patchBytes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Note: Ideally here we'll update the in-memory object to keep it consistent through
        // the reconciliation loop. It hasn't been done to preserve the existing controller behavior
        // and maintain compatibility with existing tests. This could be revisited in the future.

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package formats

import (
        "context"
        "fmt"

        "github.com/tektoncd/chains/pkg/config"
)

// Payloader is an interface to generate a chains Payload from a TaskRun
type Payloader interface {
        CreatePayload(ctx context.Context, obj interface{}) (interface{}, error)
        Type() config.PayloadType
        Wrap() bool
        RetrieveAllArtifactURIs(ctx context.Context, obj interface{}) ([]string, error)
}

const (
        PayloadTypeTekton        config.PayloadType = "tekton"
        PayloadTypeSimpleSigning config.PayloadType = "simplesigning"
        PayloadTypeInTotoIte6    config.PayloadType = "in-toto"
        PayloadTypeSlsav1        config.PayloadType = "slsa/v1"
        PayloadTypeSlsav2alpha3  config.PayloadType = "slsa/v2alpha3"
        PayloadTypeSlsav2alpha4  config.PayloadType = "slsa/v2alpha4"
)

var (
        IntotoAttestationSet = map[config.PayloadType]struct{}{
                PayloadTypeInTotoIte6:   {},
                PayloadTypeSlsav1:       {},
                PayloadTypeSlsav2alpha3: {},
                PayloadTypeSlsav2alpha4: {},
        }
        payloaderMap = map[config.PayloadType]PayloaderInit{}
)

// PayloaderInit initializes a new Payloader instance for the given config.
type PayloaderInit func(config.Config) (Payloader, error)

// RegisterPayloader registers the PayloaderInit func for the given type.
// This is suitable to be calling during init() to register Payloader types.
func RegisterPayloader(key config.PayloadType, init PayloaderInit) <span class="cov0" title="0">{
        payloaderMap[key] = init
}</span>

// GetPayloader returns a new Payloader of the given type.
// If no Payloader is registered for the type, an error is returned.
func GetPayloader(key config.PayloadType, cfg config.Config) (Payloader, error) <span class="cov0" title="0">{
        fn, ok := payloaderMap[key]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("payloader %q not found", key)
        }</span>
        <span class="cov0" title="0">return fn(cfg)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package simple

import (
        "context"
        "fmt"

        "github.com/sigstore/sigstore/pkg/signature/payload"
        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/config"

        "github.com/google/go-containerregistry/pkg/name"
)

const (
        PayloadTypeSimpleSigning = formats.PayloadTypeSimpleSigning
)

func init() <span class="cov8" title="1">{
        formats.RegisterPayloader(PayloadTypeSimpleSigning, NewFormatter)
}</span>

// SimpleSigning is a formatter that uses the RedHat simple signing format
// https://www.redhat.com/en/blog/container-image-signing
type SimpleSigning struct{}

type SimpleContainerImage payload.SimpleContainerImage

// CreatePayload implements the Payloader interface.
func (i *SimpleSigning) CreatePayload(ctx context.Context, obj interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case name.Digest:<span class="cov8" title="1">
                format := NewSimpleStruct(v)
                return format, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported type %s", v)</span>
        }
}

func (i *SimpleSigning) Wrap() bool <span class="cov0" title="0">{
        return false
}</span>

func NewFormatter(config.Config) (formats.Payloader, error) <span class="cov0" title="0">{
        return &amp;SimpleSigning{}, nil
}</span>

func NewSimpleStruct(img name.Digest) SimpleContainerImage <span class="cov8" title="1">{
        cosign := payload.Cosign{Image: img}
        return SimpleContainerImage(cosign.SimpleContainerImage())
}</span>

func (i SimpleContainerImage) ImageName() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s@%s", i.Critical.Identity.DockerReference, i.Critical.Image.DockerManifestDigest)
}</span>

func (i *SimpleSigning) Type() config.PayloadType <span class="cov0" title="0">{
        return formats.PayloadTypeSimpleSigning
}</span>

// RetrieveAllArtifactURIs returns always an error, feature not available for simplesigning formatter.
func (i *SimpleSigning) RetrieveAllArtifactURIs(_ context.Context, _ interface{}) ([]string, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("RetrieveAllArtifactURIs not supported for simeplesining formatter")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package attest

import (
        "fmt"
        "strings"

        slsa "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2"
        "github.com/tektoncd/chains/pkg/artifacts"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
)

const (
        CommitParam                  = "CHAINS-GIT_COMMIT"
        URLParam                     = "CHAINS-GIT_URL"
        ChainsReproducibleAnnotation = "chains.tekton.dev/reproducible"
)

type StepAttestation struct {
        EntryPoint  string            `json:"entryPoint"`
        Arguments   interface{}       `json:"arguments,omitempty"`
        Environment interface{}       `json:"environment,omitempty"`
        Annotations map[string]string `json:"annotations"`
}

func Step(step *v1.Step, stepState *v1.StepState) StepAttestation <span class="cov0" title="0">{
        attestation := StepAttestation{}

        entrypoint := strings.Join(step.Command, " ")
        if step.Script != "" </span><span class="cov0" title="0">{
                entrypoint = step.Script
        }</span>
        <span class="cov0" title="0">attestation.EntryPoint = entrypoint
        attestation.Arguments = step.Args

        env := map[string]interface{}{}
        env["image"] = artifacts.OCIScheme + strings.TrimPrefix(stepState.ImageID, "docker-pullable://")
        env["container"] = stepState.Name
        attestation.Environment = env

        return attestation</span>
}

func Invocation(obj objects.TektonObject, params []v1.Param, paramSpecs []v1.ParamSpec) slsa.ProvenanceInvocation <span class="cov0" title="0">{
        var source *v1.RefSource
        if p := obj.GetProvenance(); p != nil </span><span class="cov0" title="0">{
                source = p.RefSource
        }</span>
        <span class="cov0" title="0">i := slsa.ProvenanceInvocation{
                ConfigSource: convertConfigSource(source),
        }

        iParams := make(map[string]v1.ParamValue)

        // get implicit parameters from defaults
        for _, p := range paramSpecs </span><span class="cov0" title="0">{
                if p.Default != nil </span><span class="cov0" title="0">{
                        iParams[p.Name] = *p.Default
                }</span>
        }

        // get explicit parameters
        <span class="cov0" title="0">for _, p := range params </span><span class="cov0" title="0">{
                iParams[p.Name] = p.Value
        }</span>

        <span class="cov0" title="0">i.Parameters = iParams
        environment := map[string]map[string]string{}

        annotations := map[string]string{}
        for name, value := range obj.GetAnnotations() </span><span class="cov0" title="0">{
                // Ignore annotations that are not relevant to provenance information
                if name == corev1.LastAppliedConfigAnnotation || strings.HasPrefix(name, "chains.tekton.dev/") </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">annotations[name] = value</span>
        }
        <span class="cov0" title="0">if len(annotations) &gt; 0 </span><span class="cov0" title="0">{
                environment["annotations"] = annotations
        }</span>

        <span class="cov0" title="0">labels := obj.GetLabels()
        if len(labels) &gt; 0 </span><span class="cov0" title="0">{
                environment["labels"] = labels
        }</span>

        <span class="cov0" title="0">if len(environment) &gt; 0 </span><span class="cov0" title="0">{
                i.Environment = environment
        }</span>

        <span class="cov0" title="0">return i</span>
}

func convertConfigSource(source *v1.RefSource) slsa.ConfigSource <span class="cov0" title="0">{
        if source == nil </span><span class="cov0" title="0">{
                return slsa.ConfigSource{}
        }</span>
        <span class="cov0" title="0">return slsa.ConfigSource{
                URI:        source.URI,
                Digest:     source.Digest,
                EntryPoint: source.EntryPoint,
        }</span>
}

// supports the SPDX format which is recommended by in-toto
// ref: https://spdx.github.io/spdx-spec/v2-draft/package-information/#773-examples
// ref: https://github.com/in-toto/attestation/blob/849867bee97e33678f61cc6bd5da293097f84c25/spec/field_types.md
func SPDXGit(url, revision string) string <span class="cov0" title="0">{
        if !strings.HasPrefix(url, artifacts.GitSchemePrefix) </span><span class="cov0" title="0">{
                url = artifacts.GitSchemePrefix + url
        }</span>
        <span class="cov0" title="0">if !strings.HasSuffix(url, ".git") </span><span class="cov0" title="0">{
                url = url + ".git"
        }</span>
        <span class="cov0" title="0">if revision == "" </span><span class="cov0" title="0">{
                return url
        }</span>
        <span class="cov0" title="0">return url + fmt.Sprintf("@%s", revision)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package extract

import (
        "context"
        "fmt"
        "strings"

        "github.com/google/go-containerregistry/pkg/name"
        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
        "github.com/tektoncd/chains/pkg/artifacts"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/artifact"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "knative.dev/pkg/logging"
)

// SubjectDigests returns software artifacts produced from the TaskRun/PipelineRun object
// in the form of standard subject field of intoto statement.
// The type hinting fields expected in results help identify the generated software artifacts.
// Valid type hinting fields must:
//   - have suffix `IMAGE_URL` &amp; `IMAGE_DIGEST` or `ARTIFACT_URI` &amp; `ARTIFACT_DIGEST` pair.
//   - the `*_DIGEST` field must be in the format of "&lt;algorithm&gt;:&lt;actual-sha&gt;" where the algorithm must be "sha256" and actual sha must be valid per https://github.com/opencontainers/image-spec/blob/main/descriptor.md#sha-256.
//   - the `*_URL` or `*_URI` fields cannot be empty.
//
//nolint:all
func SubjectDigests(ctx context.Context, obj objects.TektonObject, slsaconfig *slsaconfig.SlsaConfig) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        var subjects []*intoto.ResourceDescriptor

        switch obj.GetObject().(type) </span>{
        case *v1.PipelineRun:<span class="cov8" title="1">
                subjects = subjectsFromPipelineRun(ctx, obj, slsaconfig)</span>
        case *v1.TaskRun:<span class="cov8" title="1">
                subjects = subjectsFromTektonObject(ctx, obj)</span>
        default:<span class="cov0" title="0">
                logger := logging.FromContext(ctx)
                logger.Warnf("object type %T not supported", obj.GetObject())</span>
        }

        <span class="cov8" title="1">return subjects</span>
}

func subjectsFromPipelineRun(ctx context.Context, obj objects.TektonObject, slsaconfig *slsaconfig.SlsaConfig) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        prSubjects := subjectsFromTektonObject(ctx, obj)

        // If deep inspection is not enabled, just return subjects observed on the pipelinerun level
        if !slsaconfig.DeepInspectionEnabled </span><span class="cov8" title="1">{
                return prSubjects
        }</span>

        <span class="cov8" title="1">logger := logging.FromContext(ctx)
        // If deep inspection is enabled, collect subjects from child taskruns
        var result []*intoto.ResourceDescriptor

        pro := obj.(*objects.PipelineRunObjectV1)

        pSpec := pro.Status.PipelineSpec
        if pSpec != nil </span><span class="cov8" title="1">{
                pipelineTasks := pSpec.Tasks
                pipelineTasks = append(pipelineTasks, pSpec.Finally...)
                for _, t := range pipelineTasks </span><span class="cov8" title="1">{
                        taskRuns := pro.GetTaskRunsFromTask(t.Name)
                        if len(taskRuns) == 0 </span><span class="cov0" title="0">{
                                logger.Infof("no taskruns found for task %s", t.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, tr := range taskRuns </span><span class="cov8" title="1">{
                                // Ignore Tasks that did not execute during the PipelineRun.
                                if tr == nil || tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                                        logger.Infof("taskrun status not found for task %s", t.Name)
                                        continue</span>
                                }
                                <span class="cov8" title="1">trSubjects := subjectsFromTektonObject(ctx, tr)
                                result = artifact.AppendSubjects(result, trSubjects...)</span>
                        }
                }
        }

        // also add subjects observed from pipelinerun level with duplication removed
        <span class="cov8" title="1">result = artifact.AppendSubjects(result, prSubjects...)

        return result</span>
}

func subjectsFromTektonObject(ctx context.Context, obj objects.TektonObject) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        var subjects []*intoto.ResourceDescriptor

        imgs := artifacts.ExtractOCIImagesFromResults(ctx, obj.GetResults())
        for _, i := range imgs </span><span class="cov8" title="1">{
                if d, ok := i.(name.Digest); ok </span><span class="cov8" title="1">{
                        subjects = artifact.AppendSubjects(subjects, &amp;intoto.ResourceDescriptor{
                                Name: d.Repository.Name(),
                                Digest: common.DigestSet{
                                        "sha256": strings.TrimPrefix(d.DigestStr(), "sha256:"),
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">sts := artifacts.ExtractSignableTargetFromResults(ctx, obj)
        for _, obj := range sts </span><span class="cov0" title="0">{
                splits := strings.Split(obj.Digest, ":")
                if len(splits) != 2 </span><span class="cov0" title="0">{
                        logger.Errorf("Digest %s should be in the format of: algorthm:abc", obj.Digest)
                        continue</span>
                }
                <span class="cov0" title="0">subjects = artifact.AppendSubjects(subjects, &amp;intoto.ResourceDescriptor{
                        Name: obj.URI,
                        Digest: common.DigestSet{
                                splits[0]: splits[1],
                        },
                })</span>
        }

        <span class="cov8" title="1">ssts := artifacts.ExtractStructuredTargetFromResults(ctx, obj.GetResults(), artifacts.ArtifactsOutputsResultName)
        for _, s := range ssts </span><span class="cov0" title="0">{
                splits := strings.Split(s.Digest, ":")
                alg := splits[0]
                digest := splits[1]
                subjects = artifact.AppendSubjects(subjects, &amp;intoto.ResourceDescriptor{
                        Name: s.URI,
                        Digest: common.DigestSet{
                                alg: digest,
                        },
                })
        }</span>

        <span class="cov8" title="1">return subjects</span>
}

// RetrieveAllArtifactURIs returns all the URIs of the software artifacts produced from the run object.
// - It first extracts intoto subjects from run object results and converts the subjects
// to a slice of string URIs in the format of "NAME" + "@" + "ALGORITHM" + ":" + "DIGEST".
// - If no subjects could be extracted from results, then an empty slice is returned.
func RetrieveAllArtifactURIs(ctx context.Context, obj objects.TektonObject, deepInspectionEnabled bool) []string <span class="cov8" title="1">{
        result := []string{}
        subjects := SubjectDigests(ctx, obj, &amp;slsaconfig.SlsaConfig{DeepInspectionEnabled: deepInspectionEnabled})

        for _, s := range subjects </span><span class="cov8" title="1">{
                for algo, digest := range s.Digest </span><span class="cov8" title="1">{
                        result = append(result, fmt.Sprintf("%s@%s:%s", s.Name, algo, digest))
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// SubjectsFromBuildArtifact returns the software artifacts/images produced by the TaskRun/PipelineRun in the form of standard
// subject field of intoto statement. The detection is based on type hinting. To be read as a software artifact the
// type hintint should:
// - use one of the following type-hints:
//   - Use the *ARTIFACT_OUTPUTS object type-hinting suffix. The value associated with the result should be an object
//     with the fields `uri`, `digest`, and `isBuildArtifact` set to true.
//   - Use the IMAGES type-hint
//   - Use the *IMAGE_URL / *IMAGE_DIGEST type-hint suffix
func SubjectsFromBuildArtifact(ctx context.Context, results []objects.Result) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        var subjects []*intoto.ResourceDescriptor
        logger := logging.FromContext(ctx)
        buildArtifacts := artifacts.ExtractBuildArtifactsFromResults(ctx, results)
        for _, ba := range buildArtifacts </span><span class="cov8" title="1">{
                splits := strings.Split(ba.Digest, ":")
                if len(splits) != 2 </span><span class="cov0" title="0">{
                        logger.Errorf("Error procesing build artifact %v, digest %v malformed. Build artifact skipped", ba.FullRef(), ba.Digest)
                        continue</span>
                }

                <span class="cov8" title="1">alg := splits[0]
                digest := splits[1]
                subjects = artifact.AppendSubjects(subjects, &amp;intoto.ResourceDescriptor{
                        Name: ba.URI,
                        Digest: common.DigestSet{
                                alg: digest,
                        },
                })</span>
        }

        <span class="cov8" title="1">imgs := artifacts.ExtractOCIImagesFromResults(ctx, results)
        for _, i := range imgs </span><span class="cov8" title="1">{
                if d, ok := i.(name.Digest); ok </span><span class="cov8" title="1">{
                        subjects = artifact.AppendSubjects(subjects, &amp;intoto.ResourceDescriptor{
                                Name: d.Repository.Name(),
                                Digest: common.DigestSet{
                                        "sha256": strings.TrimPrefix(d.DigestStr(), "sha256:"),
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">return subjects</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package artifact

import (
        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
)

// AppendSubjects adds new subject(s) to the original slice.
// It merges the new item with an existing entry if they are duplicate instead of append.
func AppendSubjects(original []*intoto.ResourceDescriptor, items ...*intoto.ResourceDescriptor) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        var artifacts []artifact
        for _, s := range original </span><span class="cov8" title="1">{
                artifacts = append(artifacts, subjectToArtifact(s))
        }</span>

        <span class="cov8" title="1">for _, s := range items </span><span class="cov8" title="1">{
                artifacts = addArtifact(artifacts, subjectToArtifact(s))
        }</span>

        <span class="cov8" title="1">var result []*intoto.ResourceDescriptor
        for _, a := range artifacts </span><span class="cov8" title="1">{
                result = append(result, artifactToSubject(a))
        }</span>
        <span class="cov8" title="1">return result</span>
}

// AppendMaterials adds new material(s) to the original slice.
// It merges the new item with an existing entry if they are duplicate instead of append.
func AppendMaterials(original []common.ProvenanceMaterial, items ...common.ProvenanceMaterial) []common.ProvenanceMaterial <span class="cov8" title="1">{
        var artifacts []artifact
        for _, m := range original </span><span class="cov8" title="1">{
                artifacts = append(artifacts, materialToArtifact(m))
        }</span>

        <span class="cov8" title="1">for _, m := range items </span><span class="cov8" title="1">{
                artifacts = addArtifact(artifacts, materialToArtifact(m))
        }</span>

        <span class="cov8" title="1">var result []common.ProvenanceMaterial
        for _, a := range artifacts </span><span class="cov8" title="1">{
                result = append(result, artifactToMaterial(a))
        }</span>
        <span class="cov8" title="1">return result</span>
}

type artifact struct {
        name      string
        digestSet map[string]string
}

// AddArtifact adds a new artifact item to the original slice.
func addArtifact(original []artifact, item artifact) []artifact <span class="cov8" title="1">{

        for i, a := range original </span><span class="cov8" title="1">{
                // if there is an equivalent entry in the original slice, merge the
                // artifact's DigestSet into the existing entry's DigestSet.
                if artifactEqual(a, item) </span><span class="cov8" title="1">{
                        mergeMaps(original[i].digestSet, item.digestSet)
                        return original
                }</span>
        }

        <span class="cov8" title="1">original = append(original, item)
        return original</span>
}

// two artifacts are equal if and only if they have same name and have at least
// one common algorithm and hex value.
func artifactEqual(x, y artifact) bool <span class="cov8" title="1">{
        if x.name != y.name </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for algo, hex := range x.digestSet </span><span class="cov8" title="1">{
                if y.digestSet[algo] == hex </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func mergeMaps(m1 map[string]string, m2 map[string]string) <span class="cov8" title="1">{
        for k, v := range m2 </span><span class="cov8" title="1">{
                m1[k] = v
        }</span>
}

func subjectToArtifact(s *intoto.ResourceDescriptor) artifact <span class="cov8" title="1">{
        return artifact{
                name:      s.Name,
                digestSet: s.Digest,
        }
}</span>

func artifactToSubject(a artifact) *intoto.ResourceDescriptor <span class="cov8" title="1">{
        return &amp;intoto.ResourceDescriptor{
                Name:   a.name,
                Digest: a.digestSet,
        }
}</span>

func materialToArtifact(m common.ProvenanceMaterial) artifact <span class="cov8" title="1">{
        return artifact{
                name:      m.URI,
                digestSet: m.Digest,
        }
}</span>

func artifactToMaterial(a artifact) common.ProvenanceMaterial <span class="cov8" title="1">{
        return common.ProvenanceMaterial{
                URI:    a.name,
                Digest: a.digestSet,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package builddefinition

import (
        "context"
        "encoding/json"

        slsa "github.com/in-toto/attestation/go/predicates/provenance/v1"
        buildtypes "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_types"
        externalparameters "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/external_parameters"
        internalparameters "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/internal_parameters"
        resolveddependencies "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/resolved_dependencies"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/types/known/structpb"
)

// GetTaskRunBuildDefinition returns the buildDefinition for the given TaskRun based on the configured buildType. This will default to the slsa buildType
func GetTaskRunBuildDefinition(ctx context.Context, tro *objects.TaskRunObjectV1, buildType string, resolveOpts resolveddependencies.ResolveOptions) (slsa.BuildDefinition, error) <span class="cov8" title="1">{
        rd, err := resolveddependencies.TaskRun(ctx, resolveOpts, tro)
        if err != nil </span><span class="cov0" title="0">{
                return slsa.BuildDefinition{}, err
        }</span>

        <span class="cov8" title="1">externalParams := externalparameters.TaskRun(tro)
        structExternalParams, err := getStruct(externalParams)
        if err != nil </span><span class="cov0" title="0">{
                return slsa.BuildDefinition{}, err
        }</span>

        <span class="cov8" title="1">buildDefinitionType := buildType
        if buildDefinitionType == "" </span><span class="cov8" title="1">{
                buildDefinitionType = buildtypes.SlsaBuildType
        }</span>

        <span class="cov8" title="1">internalParams, err := internalparameters.GetInternalParamters(tro, buildDefinitionType)
        if err != nil </span><span class="cov8" title="1">{
                return slsa.BuildDefinition{}, err
        }</span>
        <span class="cov8" title="1">structInternalParams, err := getStruct(internalParams)
        if err != nil </span><span class="cov0" title="0">{
                return slsa.BuildDefinition{}, err
        }</span>

        <span class="cov8" title="1">return slsa.BuildDefinition{
                BuildType:            buildDefinitionType,
                ExternalParameters:   structExternalParams,
                InternalParameters:   structInternalParams,
                ResolvedDependencies: rd,
        }, nil</span>
}

// GetPipelineRunBuildDefinition returns the buildDefinition for the given PipelineRun based on the configured buildType. This will default to the slsa buildType
func GetPipelineRunBuildDefinition(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig, resolveOpts resolveddependencies.ResolveOptions) (slsa.BuildDefinition, error) <span class="cov8" title="1">{
        buildDefinitionType := slsaconfig.BuildType
        if slsaconfig.BuildType == "" </span><span class="cov0" title="0">{
                buildDefinitionType = buildtypes.SlsaBuildType
        }</span>

        <span class="cov8" title="1">td, err := resolveddependencies.GetTaskDescriptor(buildDefinitionType)
        if err != nil </span><span class="cov8" title="1">{
                return slsa.BuildDefinition{}, err
        }</span>

        <span class="cov8" title="1">rd, err := resolveddependencies.PipelineRun(ctx, pro, slsaconfig, resolveOpts, td)
        if err != nil </span><span class="cov0" title="0">{
                return slsa.BuildDefinition{}, err
        }</span>

        <span class="cov8" title="1">externalParams := externalparameters.PipelineRun(pro)
        structExternalParams, err := getStruct(externalParams)
        if err != nil </span><span class="cov0" title="0">{
                return slsa.BuildDefinition{}, err
        }</span>

        <span class="cov8" title="1">internalParams, err := internalparameters.GetInternalParamters(pro, buildDefinitionType)
        if err != nil </span><span class="cov0" title="0">{
                return slsa.BuildDefinition{}, err
        }</span>
        <span class="cov8" title="1">structInternalParams, err := getStruct(internalParams)
        if err != nil </span><span class="cov0" title="0">{
                return slsa.BuildDefinition{}, err
        }</span>

        <span class="cov8" title="1">return slsa.BuildDefinition{
                BuildType:            buildDefinitionType,
                ExternalParameters:   structExternalParams,
                InternalParameters:   structInternalParams,
                ResolvedDependencies: rd,
        }, nil</span>
}

func getStruct(data map[string]any) (*structpb.Struct, error) <span class="cov8" title="1">{
        bytes, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">protoStruct := &amp;structpb.Struct{}
        err = protojson.Unmarshal(bytes, protoStruct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return protoStruct, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package compare

import (
        "github.com/google/go-cmp/cmp"
        "github.com/google/go-cmp/cmp/cmpopts"
        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
)

// SLSAV1CompareOptions returns the comparison options for sorting some slice fields in
// SLSA v1 statement including ResourceDescriptor and Subject.
func SLSAV1CompareOptions() []cmp.Option <span class="cov0" title="0">{
        // checking content + uri + digest should be sufficient here based on the fact that
        // a ResourceDescriptor MUST specify one of uri, digest or content at a minimum.
        // Source: https://github.com/in-toto/attestation/blob/main/spec/v1/resource_descriptor.md#fields
        resourceDescriptorSort := func(x, y *intoto.ResourceDescriptor) bool </span><span class="cov0" title="0">{
                if string(x.Content) != string(y.Content) </span><span class="cov0" title="0">{
                        return string(x.Content) &lt; string(y.Content)
                }</span>
                <span class="cov0" title="0">if x.Uri != y.Uri </span><span class="cov0" title="0">{
                        return x.Uri &lt; y.Uri
                }</span>
                <span class="cov0" title="0">return lessDigestSet(x.Digest, y.Digest)</span>
        }

        <span class="cov0" title="0">return []cmp.Option{
                cmpopts.SortSlices(resourceDescriptorSort),
                SubjectCompareOption(),
        }</span>
}

// SubjectCompareOption returns the comparison option to sort and compare a
// list of Subjects.
func SubjectCompareOption() cmp.Option <span class="cov0" title="0">{
        subjectSort := func(x, y *intoto.ResourceDescriptor) bool </span><span class="cov0" title="0">{
                if x.Name != y.Name </span><span class="cov0" title="0">{
                        return x.Name &lt; y.Name
                }</span>
                <span class="cov0" title="0">return lessDigestSet(x.Digest, y.Digest)</span>
        }
        <span class="cov0" title="0">return cmpopts.SortSlices(subjectSort)</span>
}

// MaterialsCompareOption returns the comparison option to sort and compare a
// list of Materials.
func MaterialsCompareOption() cmp.Option <span class="cov0" title="0">{
        materialsSort := func(x, y common.ProvenanceMaterial) bool </span><span class="cov0" title="0">{
                if x.URI != y.URI </span><span class="cov0" title="0">{
                        return x.URI &lt; y.URI
                }</span>
                <span class="cov0" title="0">return lessDigestSet(x.Digest, y.Digest)</span>
        }
        <span class="cov0" title="0">return cmpopts.SortSlices(materialsSort)</span>
}

func lessDigestSet(x, y common.DigestSet) bool <span class="cov0" title="0">{
        for algo, digestX := range x </span><span class="cov0" title="0">{
                digestY, ok := y[algo]
                if !ok </span><span class="cov0" title="0">{
                        // Algorithm not present in y, x is considered greater.
                        return false
                }</span>
                // Compare the digests lexicographically.
                <span class="cov0" title="0">if digestX != digestY </span><span class="cov0" title="0">{
                        return digestX &lt; digestY
                }</span>
                // The digests are equal, check the next algorithm.
        }

        // All algorithms in x have corresponding entries in y, so check if y has more algorithms.
        <span class="cov0" title="0">return len(x) &lt; len(y)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package externalparameters

import (
        "fmt"

        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func BuildConfigSource(provenance *v1.Provenance) map[string]string <span class="cov8" title="1">{
        ref := ""
        for alg, hex := range provenance.RefSource.Digest </span><span class="cov8" title="1">{
                ref = fmt.Sprintf("%s:%s", alg, hex)
                break</span>
        }
        <span class="cov8" title="1">buildConfigSource := map[string]string{
                "ref":        ref,
                "repository": provenance.RefSource.URI,
                "path":       provenance.RefSource.EntryPoint,
        }
        return buildConfigSource</span>
}

// PipelineRun adds the pipeline run spec and provenance if available
func PipelineRun(pro *objects.PipelineRunObjectV1) map[string]any <span class="cov8" title="1">{
        externalParams := make(map[string]any)

        if provenance := pro.GetRemoteProvenance(); provenance != nil </span><span class="cov8" title="1">{
                externalParams["buildConfigSource"] = BuildConfigSource(provenance)
        }</span>
        <span class="cov8" title="1">externalParams["runSpec"] = pro.Spec
        return externalParams</span>
}

// TaskRun adds the task run spec and provenance if available
func TaskRun(tro *objects.TaskRunObjectV1) map[string]any <span class="cov8" title="1">{
        externalParams := make(map[string]any)

        if provenance := tro.GetRemoteProvenance(); provenance != nil </span><span class="cov8" title="1">{
                externalParams["buildConfigSource"] = BuildConfigSource(provenance)
        }</span>
        <span class="cov8" title="1">externalParams["runSpec"] = tro.Spec
        return externalParams</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package internalparameters

import (
        "fmt"

        buildtypes "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_types"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

// SLSAInternalParameters provides the chains config as internalparameters
func SLSAInternalParameters(tko objects.TektonObject) map[string]any <span class="cov8" title="1">{
        internalParams := make(map[string]any)
        if provenance := tko.GetProvenance(); provenance != (*v1.Provenance)(nil) &amp;&amp; provenance.FeatureFlags != nil </span><span class="cov8" title="1">{
                internalParams["tekton-pipelines-feature-flags"] = *provenance.FeatureFlags
        }</span>
        <span class="cov8" title="1">return internalParams</span>
}

// TektonInternalParameters provides the chains config as well as annotations and labels
func TektonInternalParameters(tko objects.TektonObject) map[string]any <span class="cov8" title="1">{
        internalParams := make(map[string]any)
        if provenance := tko.GetProvenance(); provenance != (*v1.Provenance)(nil) &amp;&amp; provenance.FeatureFlags != nil </span><span class="cov8" title="1">{
                internalParams["tekton-pipelines-feature-flags"] = *provenance.FeatureFlags
        }</span>
        <span class="cov8" title="1">internalParams["labels"] = tko.GetLabels()
        internalParams["annotations"] = tko.GetAnnotations()
        return internalParams</span>
}

// GetInternalParamters returns the internal parameters for the given tekton object based on the build type.
func GetInternalParamters(obj objects.TektonObject, buildDefinitionType string) (map[string]any, error) <span class="cov8" title="1">{
        var internalParameters map[string]any

        switch buildDefinitionType </span>{
        case buildtypes.SlsaBuildType:<span class="cov8" title="1">
                internalParameters = SLSAInternalParameters(obj)</span>
        case buildtypes.TektonBuildType:<span class="cov8" title="1">
                internalParameters = TektonInternalParameters(obj)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported buildType %v", buildDefinitionType)</span>
        }

        <span class="cov8" title="1">return internalParameters, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package material

import (
        "context"
        "fmt"
        "strings"

        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
        "github.com/tektoncd/chains/pkg/artifacts"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/attest"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/artifact"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "knative.dev/pkg/logging"
)

const (
        uriSeparator    = "@"
        digestSeparator = ":"
)

// TaskMaterials constructs `predicate.materials` section by collecting all the artifacts that influence a taskrun such as source code repo and step&amp;sidecar base images.
func TaskMaterials(ctx context.Context, tro *objects.TaskRunObjectV1) ([]common.ProvenanceMaterial, error) <span class="cov8" title="1">{
        var mats []common.ProvenanceMaterial

        // add step images
        stepMaterials, err := FromStepImages(tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">mats = artifact.AppendMaterials(mats, stepMaterials...)

        // add sidecar images
        sidecarMaterials, err := FromSidecarImages(tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">mats = artifact.AppendMaterials(mats, sidecarMaterials...)

        mats = artifact.AppendMaterials(mats, FromTaskParamsAndResults(ctx, tro)...)

        return mats, nil</span>
}

func PipelineMaterials(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig) ([]common.ProvenanceMaterial, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        var mats []common.ProvenanceMaterial
        if p := pro.Status.Provenance; p != nil &amp;&amp; p.RefSource != nil </span><span class="cov8" title="1">{
                m := common.ProvenanceMaterial{
                        URI:    p.RefSource.URI,
                        Digest: p.RefSource.Digest,
                }
                mats = artifact.AppendMaterials(mats, m)
        }</span>
        <span class="cov8" title="1">pSpec := pro.Status.PipelineSpec
        if pSpec != nil </span><span class="cov8" title="1">{
                pipelineTasks := append(pSpec.Tasks, pSpec.Finally...)
                for _, t := range pipelineTasks </span><span class="cov8" title="1">{
                        taskRuns := pro.GetTaskRunsFromTask(t.Name)
                        if len(taskRuns) == 0 </span><span class="cov0" title="0">{
                                logger.Infof("no taskruns found for task %s", t.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, tr := range taskRuns </span><span class="cov8" title="1">{
                                // Ignore Tasks that did not execute during the PipelineRun.
                                if tr == nil || tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                                        logger.Infof("taskrun status not found for task %s", t.Name)
                                        continue</span>
                                }
                                <span class="cov8" title="1">stepMaterials, err := FromStepImages(tr)
                                if err != nil </span><span class="cov0" title="0">{
                                        return mats, err
                                }</span>
                                <span class="cov8" title="1">mats = artifact.AppendMaterials(mats, stepMaterials...)
                                // add sidecar images
                                sidecarMaterials, err := FromSidecarImages(tr)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">mats = artifact.AppendMaterials(mats, sidecarMaterials...)

                                // add remote task configsource information in materials
                                if tr.Status.Provenance != nil &amp;&amp; tr.Status.Provenance.RefSource != nil </span><span class="cov8" title="1">{
                                        m := common.ProvenanceMaterial{
                                                URI:    tr.Status.Provenance.RefSource.URI,
                                                Digest: tr.Status.Provenance.RefSource.Digest,
                                        }
                                        mats = artifact.AppendMaterials(mats, m)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">mats = artifact.AppendMaterials(mats, FromPipelineParamsAndResults(ctx, pro, slsaconfig)...)

        return mats, nil</span>
}

// FromStepImages gets predicate.materials from step images
func FromStepImages(tro *objects.TaskRunObjectV1) ([]common.ProvenanceMaterial, error) <span class="cov8" title="1">{
        mats := []common.ProvenanceMaterial{}
        for _, image := range tro.GetStepImages() </span><span class="cov8" title="1">{
                m, err := fromImageID(image)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">mats = artifact.AppendMaterials(mats, m)</span>
        }
        <span class="cov8" title="1">return mats, nil</span>
}

// FromSidecarImages gets predicate.materials from sidecar images
func FromSidecarImages(tro *objects.TaskRunObjectV1) ([]common.ProvenanceMaterial, error) <span class="cov8" title="1">{
        mats := []common.ProvenanceMaterial{}
        for _, image := range tro.GetSidecarImages() </span><span class="cov8" title="1">{
                m, err := fromImageID(image)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">mats = artifact.AppendMaterials(mats, m)</span>
        }
        <span class="cov8" title="1">return mats, nil</span>
}

// fromImageID converts an imageId with format &lt;uri&gt;@sha256:&lt;digest&gt; and generates a provenance materials.
func fromImageID(imageID string) (common.ProvenanceMaterial, error) <span class="cov8" title="1">{
        uriDigest := strings.Split(imageID, uriSeparator)
        if len(uriDigest) != 2 </span><span class="cov8" title="1">{
                return common.ProvenanceMaterial{}, fmt.Errorf("expected imageID %s to be separable by @", imageID)
        }</span>
        <span class="cov8" title="1">digest := strings.Split(uriDigest[1], digestSeparator)
        if len(digest) != 2 </span><span class="cov0" title="0">{
                return common.ProvenanceMaterial{}, fmt.Errorf("expected imageID %s to be separable by @ and :", imageID)
        }</span>
        <span class="cov8" title="1">uri := strings.TrimPrefix(uriDigest[0], "docker-pullable://")
        m := common.ProvenanceMaterial{
                Digest: common.DigestSet{},
        }
        m.URI = artifacts.OCIScheme + uri
        m.Digest[digest[0]] = digest[1]
        return m, nil</span>
}

// FromTaskParamsAndResults scans over the taskrun, taskspec params and taskrun results
// and looks for unstructured type hinted names matching CHAINS-GIT_COMMIT and CHAINS-GIT_URL
// to extract the commit and url value for input artifact materials.
func FromTaskParamsAndResults(ctx context.Context, tro *objects.TaskRunObjectV1) []common.ProvenanceMaterial <span class="cov8" title="1">{
        var commit, url string
        // Scan for git params to use for materials
        if tro.Status.TaskSpec != nil </span><span class="cov8" title="1">{
                for _, p := range tro.Status.TaskSpec.Params </span><span class="cov8" title="1">{
                        if p.Default == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if p.Name == attest.CommitParam </span><span class="cov8" title="1">{
                                commit = p.Default.StringVal
                                continue</span>
                        }
                        <span class="cov8" title="1">if p.Name == attest.URLParam </span><span class="cov8" title="1">{
                                url = p.Default.StringVal
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, p := range tro.Spec.Params </span><span class="cov8" title="1">{
                if p.Name == attest.CommitParam </span><span class="cov8" title="1">{
                        commit = p.Value.StringVal
                        continue</span>
                }
                <span class="cov8" title="1">if p.Name == attest.URLParam </span><span class="cov8" title="1">{
                        url = p.Value.StringVal
                }</span>
        }

        <span class="cov8" title="1">for _, r := range tro.Status.Results </span><span class="cov8" title="1">{
                if r.Name == attest.CommitParam </span><span class="cov8" title="1">{
                        commit = r.Value.StringVal
                }</span>
                <span class="cov8" title="1">if r.Name == attest.URLParam </span><span class="cov8" title="1">{
                        url = r.Value.StringVal
                }</span>
        }

        <span class="cov8" title="1">url = attest.SPDXGit(url, "")

        var mats []common.ProvenanceMaterial
        if commit != "" &amp;&amp; url != "" </span><span class="cov8" title="1">{
                mats = artifact.AppendMaterials(mats, common.ProvenanceMaterial{
                        URI: url,
                        // TODO. this could be sha256 as well. Fix in another PR.
                        Digest: map[string]string{"sha1": commit},
                })
        }</span>

        <span class="cov8" title="1">sms := artifacts.RetrieveMaterialsFromStructuredResults(ctx, tro.GetResults())
        mats = artifact.AppendMaterials(mats, sms...)

        return mats</span>
}

// FromStepActionsResults extracts type hinted results from StepActions associated with the TaskRun and adds the url and digest to materials.
func FromStepActionsResults(ctx context.Context, tro *objects.TaskRunObjectV1) (mats []common.ProvenanceMaterial) <span class="cov8" title="1">{
        for _, s := range tro.Status.Steps </span><span class="cov8" title="1">{
                var sCommit, sURL string
                for _, r := range s.Results </span><span class="cov8" title="1">{
                        if r.Name == attest.CommitParam </span><span class="cov8" title="1">{
                                sCommit = r.Value.StringVal
                                continue</span>
                        }

                        <span class="cov8" title="1">if r.Name == attest.URLParam </span><span class="cov8" title="1">{
                                sURL = r.Value.StringVal
                        }</span>
                }

                <span class="cov8" title="1">sURL = attest.SPDXGit(sURL, "")
                if sCommit != "" &amp;&amp; sURL != "" </span><span class="cov8" title="1">{
                        mats = artifact.AppendMaterials(mats, common.ProvenanceMaterial{
                                URI:    sURL,
                                Digest: map[string]string{"sha1": sCommit},
                        })
                }</span>
        }
        <span class="cov8" title="1">sms := artifacts.RetrieveMaterialsFromStructuredResults(ctx, tro.GetStepResults())
        mats = artifact.AppendMaterials(mats, sms...)
        return</span>
}

// FromPipelineParamsAndResults extracts type hinted params and results and adds the url and digest to materials.
func FromPipelineParamsAndResults(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig) []common.ProvenanceMaterial <span class="cov8" title="1">{
        mats := []common.ProvenanceMaterial{}
        sms := artifacts.RetrieveMaterialsFromStructuredResults(ctx, pro.GetResults())
        mats = artifact.AppendMaterials(mats, sms...)

        var commit, url string

        pSpec := pro.Status.PipelineSpec
        if pSpec != nil </span><span class="cov8" title="1">{
                // search type hinting param/results from each individual taskruns
                if slsaconfig.DeepInspectionEnabled </span><span class="cov8" title="1">{
                        logger := logging.FromContext(ctx)
                        pipelineTasks := append(pSpec.Tasks, pSpec.Finally...)
                        for _, t := range pipelineTasks </span><span class="cov8" title="1">{
                                taskRuns := pro.GetTaskRunsFromTask(t.Name)
                                if len(taskRuns) == 0 </span><span class="cov0" title="0">{
                                        logger.Infof("no taskruns found for task %s", t.Name)
                                        continue</span>
                                }
                                <span class="cov8" title="1">for _, tr := range taskRuns </span><span class="cov8" title="1">{
                                        // Ignore Tasks that did not execute during the PipelineRun.
                                        if tr == nil || tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                                                logger.Infof("taskrun is not found or not completed for the task %s", t.Name)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">materialsFromTasks := FromTaskParamsAndResults(ctx, tr)
                                        mats = artifact.AppendMaterials(mats, materialsFromTasks...)</span>
                                }
                        }
                }

                // search status.PipelineSpec.params
                <span class="cov8" title="1">for _, p := range pSpec.Params </span><span class="cov8" title="1">{
                        if p.Default == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if p.Name == attest.CommitParam </span><span class="cov8" title="1">{
                                commit = p.Default.StringVal
                                continue</span>
                        }
                        <span class="cov8" title="1">if p.Name == attest.URLParam </span><span class="cov8" title="1">{
                                url = p.Default.StringVal
                        }</span>
                }
        }

        // search pipelineRunSpec.params
        <span class="cov8" title="1">for _, p := range pro.Spec.Params </span><span class="cov8" title="1">{
                if p.Name == attest.CommitParam </span><span class="cov8" title="1">{
                        commit = p.Value.StringVal
                        continue</span>
                }
                <span class="cov8" title="1">if p.Name == attest.URLParam </span><span class="cov8" title="1">{
                        url = p.Value.StringVal
                }</span>
        }

        // search status.Results
        <span class="cov8" title="1">for _, r := range pro.Status.Results </span><span class="cov8" title="1">{
                if r.Name == attest.CommitParam </span><span class="cov8" title="1">{
                        commit = r.Value.StringVal
                }</span>
                <span class="cov8" title="1">if r.Name == attest.URLParam </span><span class="cov8" title="1">{
                        url = r.Value.StringVal
                }</span>
        }
        <span class="cov8" title="1">if len(commit) &gt; 0 &amp;&amp; len(url) &gt; 0 </span><span class="cov8" title="1">{
                url = attest.SPDXGit(url, "")
                mats = artifact.AppendMaterials(mats, common.ProvenanceMaterial{
                        URI:    url,
                        Digest: map[string]string{"sha1": commit},
                })
        }</span>
        <span class="cov8" title="1">return mats</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metadata

import (
        slsa "github.com/in-toto/attestation/go/predicates/provenance/v1"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "google.golang.org/protobuf/types/known/timestamppb"
)

// GetBuildMetadata returns SLSA metadata.
func GetBuildMetadata(obj objects.TektonObject) *slsa.BuildMetadata <span class="cov8" title="1">{
        var startedOn *timestamppb.Timestamp
        var finishedOn *timestamppb.Timestamp
        objStartTime := obj.GetStartTime()
        objCompletitionTime := obj.GetCompletitionTime()

        if objStartTime != nil </span><span class="cov8" title="1">{
                startedOn = timestamppb.New(*objStartTime)
        }</span>

        <span class="cov8" title="1">if objCompletitionTime != nil </span><span class="cov8" title="1">{
                finishedOn = timestamppb.New(*objCompletitionTime)
        }</span>

        <span class="cov8" title="1">return &amp;slsa.BuildMetadata{
                InvocationId: string(obj.GetUID()),
                StartedOn:    startedOn,
                FinishedOn:   finishedOn,
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package provenance

import (
        slsa "github.com/in-toto/attestation/go/predicates/provenance/v1"
        intoto "github.com/in-toto/attestation/go/v1"
        slsaprov "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v1"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/metadata"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/types/known/structpb"
)

// GetSLSA1Statement returns a predicate in SLSA v1.0 format using the given data.
func GetSLSA1Statement(obj objects.TektonObject, sub []*intoto.ResourceDescriptor, bd *slsa.BuildDefinition, bp []*intoto.ResourceDescriptor, slsaConfig *slsaconfig.SlsaConfig) (intoto.Statement, error) <span class="cov0" title="0">{
        predicate := slsa.Provenance{
                BuildDefinition: bd,
                RunDetails: &amp;slsa.RunDetails{
                        Builder: &amp;slsa.Builder{
                                Id: slsaConfig.BuilderID,
                        },
                        Metadata:   metadata.GetBuildMetadata(obj),
                        Byproducts: bp,
                },
        }

        predicateStruct, err := getProtoStruct(&amp;predicate)
        if err != nil </span><span class="cov0" title="0">{
                return intoto.Statement{}, err
        }</span>

        <span class="cov0" title="0">return intoto.Statement{
                Type:          intoto.StatementTypeUri,
                PredicateType: slsaprov.PredicateSLSAProvenance,
                Subject:       sub,
                Predicate:     predicateStruct,
        }, nil</span>
}

func getProtoStruct(predicate *slsa.Provenance) (*structpb.Struct, error) <span class="cov0" title="0">{
        protoStruct := &amp;structpb.Struct{}
        predicateJSON, err := protojson.Marshal(predicate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = protojson.Unmarshal(predicateJSON, protoStruct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return protoStruct, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
Copyright 2023 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resolveddependencies

import (
        "context"
        "encoding/json"
        "fmt"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
        buildtypes "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_types"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/material"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "go.uber.org/zap"
        "google.golang.org/protobuf/encoding/protojson"
        "knative.dev/pkg/logging"
)

const (
        // PipelineConfigName is the name of the resolved dependency of the pipelineRef.
        PipelineConfigName = "pipeline"
        // TaskConfigName is the name of the resolved dependency of the top level taskRef.
        TaskConfigName = "task"
        // PipelineTaskConfigName is the name of the resolved dependency of the pipeline task.
        PipelineTaskConfigName = "pipelineTask"
        // InputResultName is the name of the resolved dependency generated from Type hinted parameters or results.
        InputResultName = "inputs/result"
        // PipelineResourceName is the name of the resolved dependency of pipeline resource.
        PipelineResourceName = "pipelineResource"
)

// AddTaskDescriptorContent is used to toggle the fields in  see AddTektonTaskDescriptor and AddSLSATaskDescriptor
type AddTaskDescriptorContent func(*objects.TaskRunObjectV1) (*intoto.ResourceDescriptor, error)

// ResolveOptions represents the configuration to be use to resolve dependencies.
type ResolveOptions struct {
        // Indicates if StepActions type-hinted results should be read to resolve dependecies.
        WithStepActionsResults bool
}

// ConvertMaterialsToResolvedDependencies converts a SLSAv0.2 Material to a resolved dependency
func ConvertMaterialsToResolvedDependencies(mats []common.ProvenanceMaterial, name string) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        rds := []*intoto.ResourceDescriptor{}
        for _, mat := range mats </span><span class="cov8" title="1">{
                rd := intoto.ResourceDescriptor{}
                rd.Uri = mat.URI
                rd.Digest = mat.Digest
                if len(name) &gt; 0 </span><span class="cov8" title="1">{
                        rd.Name = name
                }</span>
                <span class="cov8" title="1">rds = append(rds, &amp;rd)</span>
        }
        <span class="cov8" title="1">return rds</span>
}

// RemoveDuplicateResolvedDependencies removes duplicate resolved dependencies from the slice of resolved dependencies.
// Original order of resolved dependencies is retained.
func RemoveDuplicateResolvedDependencies(resolvedDependencies []*intoto.ResourceDescriptor) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        out := make([]*intoto.ResourceDescriptor, 0, len(resolvedDependencies))

        // make map to store seen resolved dependencies
        seen := map[string]bool{}
        for _, resolvedDependency := range resolvedDependencies </span><span class="cov8" title="1">{
                // Since resolvedDependencies contain names, we want to ignore those while checking for duplicates.
                // Therefore, make a copy of the resolved dependency that only contains the uri and digest fields.
                rDep := intoto.ResourceDescriptor{}
                rDep.Uri = resolvedDependency.Uri
                rDep.Digest = resolvedDependency.Digest
                // pipelinTasks store content with the slsa-tekton buildType
                rDep.Content = resolvedDependency.Content
                // This allows us to ignore dependencies that have the same uri and digest.
                rd, err := protojson.Marshal(&amp;rDep)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if seen[string(rd)] </span><span class="cov8" title="1">{
                        // We dont want to remove the top level pipeline/task config from the resolved dependencies
                        // because its critical to provide that information in the provenance. In SLSAv0.2 spec,
                        // we would put this in invocation.ConfigSource. In order to ensure that it is present in
                        // the resolved dependencies, we dont want to skip it if another resolved dependency from the same
                        // uri+digest pair was already included before.
                        if !(resolvedDependency.Name == TaskConfigName || resolvedDependency.Name == PipelineConfigName) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">seen[string(rd)] = true
                out = append(out, resolvedDependency)</span>
        }
        <span class="cov8" title="1">return out, nil</span>
}

// AddTektonTaskDescriptor returns the more verbose resolved dependency content. this adds the name, uri, digest
// and content if possible.
func AddTektonTaskDescriptor(tr *objects.TaskRunObjectV1) (*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        rd := intoto.ResourceDescriptor{}
        storedTr, err := json.Marshal(tr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rd.Name = PipelineTaskConfigName
        rd.Content = storedTr
        if tr.Status.Provenance != nil &amp;&amp; tr.Status.Provenance.RefSource != nil </span><span class="cov8" title="1">{
                rd.Uri = tr.Status.Provenance.RefSource.URI
                rd.Digest = tr.Status.Provenance.RefSource.Digest
        }</span>

        <span class="cov8" title="1">return &amp;rd, nil</span>
}

// AddSLSATaskDescriptor resolves dependency content for the more generic slsa verifiers. just logs
// the name, uri and digest.
func AddSLSATaskDescriptor(tr *objects.TaskRunObjectV1) (*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        if tr.Status.Provenance != nil &amp;&amp; tr.Status.Provenance.RefSource != nil </span><span class="cov8" title="1">{
                return &amp;intoto.ResourceDescriptor{
                        Name:   PipelineTaskConfigName,
                        Uri:    tr.Status.Provenance.RefSource.URI,
                        Digest: tr.Status.Provenance.RefSource.Digest,
                }, nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// fromPipelineTask adds the resolved dependencies from pipeline tasks
// such as pipeline task uri/digest for remote pipeline tasks and step and sidecar images.
func fromPipelineTask(logger *zap.SugaredLogger, pro *objects.PipelineRunObjectV1, addTasks AddTaskDescriptorContent) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        pSpec := pro.Status.PipelineSpec
        resolvedDependencies := []*intoto.ResourceDescriptor{}
        if pSpec != nil </span><span class="cov8" title="1">{
                pipelineTasks := pSpec.Tasks
                pipelineTasks = append(pipelineTasks, pSpec.Finally...)
                for _, t := range pipelineTasks </span><span class="cov8" title="1">{
                        taskRuns := pro.GetTaskRunsFromTask(t.Name)
                        if len(taskRuns) == 0 </span><span class="cov0" title="0">{
                                logger.Infof("no taskruns found for task %s", t.Name)
                                continue</span>
                        }
                        <span class="cov8" title="1">for _, tr := range taskRuns </span><span class="cov8" title="1">{
                                // Ignore Tasks that did not execute during the PipelineRun.
                                if tr == nil || tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                                        logger.Infof("taskrun status not found for task %s", t.Name)
                                        continue</span>
                                }
                                <span class="cov8" title="1">rd, err := addTasks(tr)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("error storing taskRun %s, error: %s", t.Name, err)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if rd != nil </span><span class="cov8" title="1">{
                                        resolvedDependencies = append(resolvedDependencies, rd)
                                }</span>

                                <span class="cov8" title="1">mats := []common.ProvenanceMaterial{}

                                // add step images
                                stepMaterials, err := material.FromStepImages(tr)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">mats = append(mats, stepMaterials...)

                                // add sidecar images
                                sidecarMaterials, err := material.FromSidecarImages(tr)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">mats = append(mats, sidecarMaterials...)

                                // convert materials to resolved dependencies
                                resolvedDependencies = append(resolvedDependencies, ConvertMaterialsToResolvedDependencies(mats, "")...)</span>

                        }
                }
        }
        <span class="cov8" title="1">return resolvedDependencies, nil</span>
}

// taskDependencies gather all dependencies in a task and adds them to resolvedDependencies
func taskDependencies(ctx context.Context, opts ResolveOptions, tro *objects.TaskRunObjectV1) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        var resolvedDependencies []*intoto.ResourceDescriptor
        var err error
        mats := []common.ProvenanceMaterial{}

        // add step and sidecar images
        stepMaterials, err := material.FromStepImages(tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">mats = append(mats, stepMaterials...)

        sidecarMaterials, err := material.FromSidecarImages(tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">mats = append(mats, sidecarMaterials...)
        resolvedDependencies = append(resolvedDependencies, ConvertMaterialsToResolvedDependencies(mats, "")...)

        if opts.WithStepActionsResults </span><span class="cov8" title="1">{
                mats = material.FromStepActionsResults(ctx, tro)
                resolvedDependencies = append(resolvedDependencies, ConvertMaterialsToResolvedDependencies(mats, InputResultName)...)
        }</span>

        <span class="cov8" title="1">mats = material.FromTaskParamsAndResults(ctx, tro)
        // convert materials to resolved dependencies
        resolvedDependencies = append(resolvedDependencies, ConvertMaterialsToResolvedDependencies(mats, InputResultName)...)

        // convert materials to resolved dependencies
        resolvedDependencies = append(resolvedDependencies,
                ConvertMaterialsToResolvedDependencies(mats, PipelineResourceName)...)

        // remove duplicate resolved dependencies
        resolvedDependencies, err = RemoveDuplicateResolvedDependencies(resolvedDependencies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resolvedDependencies, nil</span>
}

// TaskRun constructs `predicate.resolvedDependencies` section by collecting all the artifacts that influence a taskrun such as source code repo and step&amp;sidecar base images.
func TaskRun(ctx context.Context, opts ResolveOptions, tro *objects.TaskRunObjectV1) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        var resolvedDependencies []*intoto.ResourceDescriptor
        var err error

        // add top level task config
        if p := tro.Status.Provenance; p != nil &amp;&amp; p.RefSource != nil </span><span class="cov8" title="1">{
                rd := intoto.ResourceDescriptor{
                        Name:   TaskConfigName,
                        Uri:    p.RefSource.URI,
                        Digest: p.RefSource.Digest,
                }
                resolvedDependencies = append(resolvedDependencies, &amp;rd)
        }</span>

        <span class="cov8" title="1">rds, err := taskDependencies(ctx, opts, tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resolvedDependencies = append(resolvedDependencies, rds...)

        return resolvedDependencies, nil</span>
}

// PipelineRun constructs `predicate.resolvedDependencies` section by collecting all the artifacts that influence a pipeline run such as source code repo and step&amp;sidecar base images.
func PipelineRun(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig, opts ResolveOptions, addTasks AddTaskDescriptorContent) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        var err error
        var resolvedDependencies []*intoto.ResourceDescriptor
        logger := logging.FromContext(ctx)

        // add pipeline config to resolved dependencies
        if p := pro.Status.Provenance; p != nil &amp;&amp; p.RefSource != nil </span><span class="cov8" title="1">{
                rd := intoto.ResourceDescriptor{
                        Name:   PipelineConfigName,
                        Uri:    p.RefSource.URI,
                        Digest: p.RefSource.Digest,
                }
                resolvedDependencies = append(resolvedDependencies, &amp;rd)
        }</span>

        // add resolved dependencies from pipeline tasks
        <span class="cov8" title="1">rds, err := fromPipelineTask(logger, pro, addTasks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">resolvedDependencies = append(resolvedDependencies, rds...)

        if slsaconfig.DeepInspectionEnabled &amp;&amp; opts.WithStepActionsResults </span><span class="cov0" title="0">{
                execTasks := pro.GetExecutedTasks()
                for _, task := range execTasks </span><span class="cov0" title="0">{
                        stepActionMat := material.FromStepActionsResults(ctx, task)
                        resolvedDependencies = append(resolvedDependencies, ConvertMaterialsToResolvedDependencies(stepActionMat, InputResultName)...)
                }</span>
        }

        // add resolved dependencies from pipeline results
        <span class="cov8" title="1">mats := material.FromPipelineParamsAndResults(ctx, pro, slsaconfig)
        // convert materials to resolved dependencies
        resolvedDependencies = append(resolvedDependencies, ConvertMaterialsToResolvedDependencies(mats, InputResultName)...)

        // remove duplicate resolved dependencies
        resolvedDependencies, err = RemoveDuplicateResolvedDependencies(resolvedDependencies)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return resolvedDependencies, nil</span>
}

// GetTaskDescriptor returns the conrresponding addTaskDescriptor function according to the given build type.
func GetTaskDescriptor(buildDefinition string) (AddTaskDescriptorContent, error) <span class="cov8" title="1">{
        switch buildDefinition </span>{
        case buildtypes.SlsaBuildType:<span class="cov8" title="1">
                return AddSLSATaskDescriptor, nil</span>
        case buildtypes.TektonBuildType:<span class="cov8" title="1">
                return AddTektonTaskDescriptor, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported buildType %v", buildDefinition)</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package results

import (
        "encoding/json"
        "fmt"
        "strings"

        "github.com/tektoncd/chains/pkg/artifacts"
        "github.com/tektoncd/chains/pkg/chains/objects"

        slsa "github.com/in-toto/attestation/go/v1"
)

var imageResultsNamesSuffixs = []string{
        artifacts.OCIImageURLResultName,
        artifacts.OCIImageDigestResultName,
}

// GetResultsWithoutBuildArtifacts returns all the results without those that are build artifacts.
func GetResultsWithoutBuildArtifacts(results []objects.Result, resultTypePrefix string) ([]*slsa.ResourceDescriptor, error) <span class="cov8" title="1">{
        byProd := []*slsa.ResourceDescriptor{}
        for _, r := range results </span><span class="cov8" title="1">{
                if isBuildArtifact, err := artifacts.IsBuildArtifact(r); err != nil || isBuildArtifact </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if isOCIImage(r.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">content, err := json.Marshal(r.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">byProd = append(byProd, &amp;slsa.ResourceDescriptor{
                        Name:      fmt.Sprintf(resultTypePrefix, r.Name),
                        Content:   content,
                        MediaType: "application/json",
                })</span>
        }

        <span class="cov8" title="1">return byProd, nil</span>
}

func isOCIImage(resName string) bool <span class="cov8" title="1">{
        for _, suffix := range imageResultsNamesSuffixs </span><span class="cov8" title="1">{
                if strings.HasSuffix(resName, suffix) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return resName == artifacts.OCIImagesResultName</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package protos

import (
        "encoding/json"

        slsa "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/types/known/structpb"
)

// GetPredicateStruct returns a protobuf struct from the given SLSAv0.2 predicate.
func GetPredicateStruct(predicate *slsa.ProvenancePredicate) (*structpb.Struct, error) <span class="cov0" title="0">{
        predicateJSON, err := json.Marshal(predicate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">predicateStruct := &amp;structpb.Struct{}
        err = protojson.Unmarshal(predicateJSON, predicateStruct)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return predicateStruct, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        "context"
        "fmt"

        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/pipelinerun"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/taskrun"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
)

const (
        PayloadTypeInTotoIte6 = formats.PayloadTypeInTotoIte6
        PayloadTypeSlsav1     = formats.PayloadTypeSlsav1
)

func init() <span class="cov8" title="1">{
        formats.RegisterPayloader(PayloadTypeInTotoIte6, NewFormatter)
        formats.RegisterPayloader(PayloadTypeSlsav1, NewFormatter)
}</span>

type InTotoIte6 struct {
        slsaConfig *slsaconfig.SlsaConfig
}

func NewFormatter(cfg config.Config) (formats.Payloader, error) <span class="cov8" title="1">{
        return &amp;InTotoIte6{
                slsaConfig: &amp;slsaconfig.SlsaConfig{
                        BuilderID:             cfg.Builder.ID,
                        DeepInspectionEnabled: cfg.Artifacts.PipelineRuns.DeepInspectionEnabled,
                },
        }, nil
}</span>

func (i *InTotoIte6) Wrap() bool <span class="cov0" title="0">{
        return true
}</span>

func (i *InTotoIte6) CreatePayload(ctx context.Context, obj interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case *objects.TaskRunObjectV1:<span class="cov8" title="1">
                return taskrun.GenerateAttestation(ctx, v, i.slsaConfig)</span>
        case *objects.PipelineRunObjectV1:<span class="cov8" title="1">
                return pipelinerun.GenerateAttestation(ctx, v, i.slsaConfig)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("intoto does not support type: %s", v)</span>
        }
}

func (i *InTotoIte6) Type() config.PayloadType <span class="cov8" title="1">{
        return formats.PayloadTypeSlsav1
}</span>

// RetrieveAllArtifactURIs returns the full URI of all artifacts detected as subjects.
func (i *InTotoIte6) RetrieveAllArtifactURIs(ctx context.Context, obj interface{}) ([]string, error) <span class="cov0" title="0">{
        tkObj, ok := obj.(objects.TektonObject)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("intoto does not support type")
        }</span>
        <span class="cov0" title="0">return extract.RetrieveAllArtifactURIs(ctx, tkObj, i.slsaConfig.DeepInspectionEnabled), nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "strings"
        "time"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
        slsa "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/attest"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/material"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/internal/protos"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        corev1 "k8s.io/api/core/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
)

type BuildConfig struct {
        Tasks []TaskAttestation `json:"tasks"`
}

type TaskAttestation struct {
        Name               string                    `json:"name,omitempty"`
        After              []string                  `json:"after,omitempty"`
        Ref                v1.TaskRef                `json:"ref,omitempty"`
        StartedOn          time.Time                 `json:"startedOn,omitempty"`
        FinishedOn         time.Time                 `json:"finishedOn,omitempty"`
        ServiceAccountName string                    `json:"serviceAccountName,omitempty"`
        Status             string                    `json:"status,omitempty"`
        Steps              []attest.StepAttestation  `json:"steps,omitempty"`
        Invocation         slsa.ProvenanceInvocation `json:"invocation,omitempty"`
        Results            []v1.TaskRunResult        `json:"results,omitempty"`
}

const statementInTotoV01 = "https://in-toto.io/Statement/v0.1"

func GenerateAttestation(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaConfig *slsaconfig.SlsaConfig) (interface{}, error) <span class="cov0" title="0">{
        subjects := extract.SubjectDigests(ctx, pro, slsaConfig)

        mat, err := material.PipelineMaterials(ctx, pro, slsaConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">predicate := &amp;slsa.ProvenancePredicate{
                Builder: common.ProvenanceBuilder{
                        ID: slsaConfig.BuilderID,
                },
                BuildType:   pro.GetGVK(),
                Invocation:  invocation(pro),
                BuildConfig: buildConfig(ctx, pro),
                Metadata:    metadata(pro),
                Materials:   mat,
        }

        predicateStruct, err := protos.GetPredicateStruct(predicate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">att := &amp;intoto.Statement{
                Type:          statementInTotoV01,
                PredicateType: slsa.PredicateSLSAProvenance,
                Subject:       subjects,
                Predicate:     predicateStruct,
        }
        return att, nil</span>
}

func invocation(pro *objects.PipelineRunObjectV1) slsa.ProvenanceInvocation <span class="cov8" title="1">{
        var paramSpecs []v1.ParamSpec
        if ps := pro.Status.PipelineSpec; ps != nil </span><span class="cov8" title="1">{
                paramSpecs = ps.Params
        }</span>
        <span class="cov8" title="1">return attest.Invocation(pro, pro.Spec.Params, paramSpecs)</span>
}

func buildConfig(ctx context.Context, pro *objects.PipelineRunObjectV1) BuildConfig <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        tasks := []TaskAttestation{}

        pSpec := pro.Status.PipelineSpec
        if pSpec == nil </span><span class="cov0" title="0">{
                return BuildConfig{}
        }</span>
        <span class="cov8" title="1">pipelineTasks := append(pSpec.Tasks, pSpec.Finally...)

        var last string
        for i, t := range pipelineTasks </span><span class="cov8" title="1">{
                taskRuns := pro.GetTaskRunsFromTask(t.Name)
                if len(taskRuns) == 0 </span><span class="cov0" title="0">{
                        logger.Infof("no taskruns found for task %s", t.Name)
                        continue</span>
                }
                <span class="cov8" title="1">for _, tr := range taskRuns </span><span class="cov8" title="1">{
                        // Ignore Tasks that did not execute during the PipelineRun.
                        if tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                                logger.Warnf("taskrun status not complete for task %s", tr.Name)
                                continue</span>
                        }

                        <span class="cov8" title="1">steps := []attest.StepAttestation{}
                        // tr.Status.TaskSpec.Steps and tr.Status.Steps should be sime size
                        if tr.Status.TaskSpec == nil </span><span class="cov0" title="0">{
                                logger.Errorf("TaskSpec is nil for task run %s. Skipping this task run.", tr.Name)
                                continue</span>
                        }

                        <span class="cov8" title="1">if len(tr.Status.TaskSpec.Steps) != len(tr.Status.Steps) </span><span class="cov8" title="1">{
                                logger.Errorf("Mismatch in number of steps for task run %s. TaskSpec steps: %d, Status steps: %d",
                                        tr.Name, len(tr.Status.TaskSpec.Steps), len(tr.Status.Steps))
                                continue</span>
                        }
                        // Validate and process steps
                        <span class="cov8" title="1">valid := true
                        for i, step := range tr.Status.TaskSpec.Steps </span><span class="cov8" title="1">{
                                stepState := tr.Status.Steps[i]

                                // Check if unnamed step matches empty name in the other list
                                if strings.HasPrefix(stepState.Name, "unnamed-") &amp;&amp; step.Name != "" </span><span class="cov8" title="1">{
                                        logger.Errorf("Mismatch in step names for task run %s. Step %d: %s, StepState %d: %s",
                                                tr.Name, i, step.Name, i, stepState.Name)
                                        valid = false
                                        break</span>
                                }

                                <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                                        steps = append(steps, attest.Step(&amp;step, &amp;stepState))
                                }</span>
                        }

                        <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                                logger.Errorf("Skipping task run %s due to step name mismatch", tr.Name)
                                continue</span>
                        }

                        <span class="cov8" title="1">after := t.RunAfter
                        // Establish task order by retrieving all task's referenced
                        // in the "when" and "params" fields
                        refs := v1.PipelineTaskResultRefs(&amp;t)
                        for _, ref := range refs </span><span class="cov8" title="1">{
                                // Ensure task doesn't already exist in after
                                found := false
                                for _, at := range after </span><span class="cov8" title="1">{
                                        if at == ref.PipelineTask </span><span class="cov8" title="1">{
                                                found = true
                                        }</span>
                                }
                                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                        after = append(after, ref.PipelineTask)
                                }</span>
                        }

                        // tr is a finally task without an explicit runAfter value. It must have executed
                        // after the last non-finally task, if any non-finally tasks were executed.
                        <span class="cov8" title="1">if len(after) == 0 &amp;&amp; i &gt;= len(pSpec.Tasks) &amp;&amp; last != "" </span><span class="cov0" title="0">{
                                after = append(after, last)
                        }</span>

                        <span class="cov8" title="1">params := tr.Spec.Params
                        var paramSpecs []v1.ParamSpec
                        if tr.Status.TaskSpec != nil </span><span class="cov8" title="1">{
                                paramSpecs = tr.Status.TaskSpec.Params
                        }</span> else<span class="cov0" title="0"> {
                                paramSpecs = []v1.ParamSpec{}
                        }</span>

                        <span class="cov8" title="1">task := TaskAttestation{
                                Name:               t.Name,
                                After:              after,
                                StartedOn:          tr.Status.StartTime.Time.UTC(),
                                FinishedOn:         tr.Status.CompletionTime.Time.UTC(),
                                ServiceAccountName: pro.Spec.TaskRunTemplate.ServiceAccountName,
                                Status:             getStatus(tr.Status.Conditions),
                                Steps:              steps,
                                Invocation:         attest.Invocation(tr, params, paramSpecs),
                                Results:            tr.Status.Results,
                        }
                        if t.TaskRef != nil </span><span class="cov8" title="1">{
                                task.Ref = *t.TaskRef
                        }</span>
                        <span class="cov8" title="1">tasks = append(tasks, task)</span>
                }

                <span class="cov8" title="1">if i &lt; len(pSpec.Tasks) </span><span class="cov8" title="1">{
                        last = t.Name
                }</span>
        }
        <span class="cov8" title="1">return BuildConfig{Tasks: tasks}</span>
}

func metadata(pro *objects.PipelineRunObjectV1) *slsa.ProvenanceMetadata <span class="cov8" title="1">{
        m := &amp;slsa.ProvenanceMetadata{}
        if pro.Status.StartTime != nil </span><span class="cov8" title="1">{
                utc := pro.Status.StartTime.Time.UTC()
                m.BuildStartedOn = &amp;utc
        }</span>
        <span class="cov8" title="1">if pro.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                utc := pro.Status.CompletionTime.Time.UTC()
                m.BuildFinishedOn = &amp;utc
        }</span>
        <span class="cov8" title="1">for label, value := range pro.Labels </span><span class="cov0" title="0">{
                if label == attest.ChainsReproducibleAnnotation &amp;&amp; value == "true" </span><span class="cov0" title="0">{
                        m.Reproducible = true
                }</span>
        }
        <span class="cov8" title="1">return m</span>
}

// Following tkn cli's behavior
// https://github.com/tektoncd/cli/blob/6afbb0f0dbc7186898568f0d4a0436b8b2994d99/pkg/formatted/k8s.go#L55
func getStatus(conditions []apis.Condition) string <span class="cov8" title="1">{
        var status string
        if len(conditions) &gt; 0 </span><span class="cov8" title="1">{
                switch conditions[0].Status </span>{
                case corev1.ConditionFalse:<span class="cov0" title="0">
                        status = "Failed"</span>
                case corev1.ConditionTrue:<span class="cov8" title="1">
                        status = "Succeeded"</span>
                case corev1.ConditionUnknown:<span class="cov0" title="0">
                        status = "Running"</span> // Should never happen
                }
        }
        <span class="cov8" title="1">return status</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/attest"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

// BuildConfig is the custom Chains format to fill out the
// "buildConfig" section of the slsa-provenance predicate
type BuildConfig struct {
        Steps []attest.StepAttestation `json:"steps"`
}

// Step corresponds to one step in the TaskRun
type Step struct {
        EntryPoint  string            `json:"entryPoint"`
        Arguments   interface{}       `json:"arguments,omitempty"`
        Environment interface{}       `json:"environment,omitempty"`
        Annotations map[string]string `json:"annotations"`
}

func buildConfig(tro *objects.TaskRunObjectV1) BuildConfig <span class="cov8" title="1">{
        attestations := []attest.StepAttestation{}
        for _, stepState := range tro.Status.Steps </span><span class="cov8" title="1">{
                step := stepFromTaskRun(stepState.Name, tro)
                attestations = append(attestations, attest.Step(step, &amp;stepState))
        }</span>
        <span class="cov8" title="1">return BuildConfig{Steps: attestations}</span>
}

func stepFromTaskRun(name string, tro *objects.TaskRunObjectV1) *v1.Step <span class="cov8" title="1">{
        if tro.Status.TaskSpec != nil </span><span class="cov8" title="1">{
                for _, s := range tro.Status.TaskSpec.Steps </span><span class="cov8" title="1">{
                        if s.Name == name </span><span class="cov8" title="1">{
                                return &amp;s
                        }</span>
                }
        }
        <span class="cov8" title="1">return &amp;v1.Step{}</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/common"
        slsa "github.com/in-toto/in-toto-golang/in_toto/slsa_provenance/v0.2"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/attest"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/material"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v1/internal/protos"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

const statementInTotoV01 = "https://in-toto.io/Statement/v0.1"

func GenerateAttestation(ctx context.Context, tro *objects.TaskRunObjectV1, slsaConfig *slsaconfig.SlsaConfig) (interface{}, error) <span class="cov0" title="0">{
        subjects := extract.SubjectDigests(ctx, tro, slsaConfig)

        mat, err := material.TaskMaterials(ctx, tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">predicate := &amp;slsa.ProvenancePredicate{
                Builder: common.ProvenanceBuilder{
                        ID: slsaConfig.BuilderID,
                },
                BuildType:   tro.GetGVK(),
                Invocation:  invocation(tro),
                BuildConfig: buildConfig(tro),
                Metadata:    Metadata(tro),
                Materials:   mat,
        }

        predicateStruct, err := protos.GetPredicateStruct(predicate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;intoto.Statement{
                Type:          statementInTotoV01,
                PredicateType: slsa.PredicateSLSAProvenance,
                Subject:       subjects,
                Predicate:     predicateStruct,
        }, nil</span>
}

// invocation describes the event that kicked off the build
// we currently don't set ConfigSource because we don't know
// which material the Task definition came from
func invocation(tro *objects.TaskRunObjectV1) slsa.ProvenanceInvocation <span class="cov8" title="1">{
        var paramSpecs []v1.ParamSpec
        if ts := tro.Status.TaskSpec; ts != nil </span><span class="cov8" title="1">{
                paramSpecs = ts.Params
        }</span>
        <span class="cov8" title="1">return attest.Invocation(tro, tro.Spec.Params, paramSpecs)</span>
}

// Metadata adds taskrun's start time, completion time and reproducibility labels
// to the metadata section of the generated provenance.
func Metadata(tro *objects.TaskRunObjectV1) *slsa.ProvenanceMetadata <span class="cov8" title="1">{
        m := &amp;slsa.ProvenanceMetadata{}
        if tro.Status.StartTime != nil </span><span class="cov8" title="1">{
                utc := tro.Status.StartTime.Time.UTC()
                m.BuildStartedOn = &amp;utc
        }</span>
        <span class="cov8" title="1">if tro.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                utc := tro.Status.CompletionTime.Time.UTC()
                m.BuildFinishedOn = &amp;utc
        }</span>
        <span class="cov8" title="1">for label, value := range tro.Labels </span><span class="cov0" title="0">{
                if label == attest.ChainsReproducibleAnnotation &amp;&amp; value == "true" </span><span class="cov0" title="0">{
                        m.Reproducible = true
                }</span>
        }
        <span class="cov8" title="1">return m</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "encoding/json"
        "fmt"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        builddefinition "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_definition"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/provenance"
        resolveddependencies "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/resolved_dependencies"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
)

const (
        pipelineRunResults = "pipelineRunResults/%s"
        // JsonMediaType is the media type of json encoded content used in resource descriptors
        JsonMediaType = "application/json"
)

// GenerateAttestation generates a provenance statement with SLSA v1.0 predicate for a pipeline run.
func GenerateAttestation(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig) (interface{}, error) <span class="cov8" title="1">{
        bp, err := byproducts(pro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">bd, err := builddefinition.GetPipelineRunBuildDefinition(ctx, pro, slsaconfig, resolveddependencies.ResolveOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sub := extract.SubjectDigests(ctx, pro, slsaconfig)

        return provenance.GetSLSA1Statement(pro, sub, &amp;bd, bp, slsaconfig)</span>
}

// byproducts contains the pipelineRunResults
func byproducts(pro *objects.PipelineRunObjectV1) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        byProd := []*intoto.ResourceDescriptor{}
        for _, key := range pro.Status.Results </span><span class="cov8" title="1">{
                content, err := json.Marshal(key.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">bp := &amp;intoto.ResourceDescriptor{
                        Name:      fmt.Sprintf(pipelineRunResults, key.Name),
                        Content:   content,
                        MediaType: JsonMediaType,
                }
                byProd = append(byProd, bp)</span>
        }
        <span class="cov8" title="1">return byProd, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"
        "encoding/json"
        "fmt"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        builddefinition "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_definition"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/provenance"
        resolveddependencies "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/resolved_dependencies"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
)

const taskRunResults = "taskRunResults/%s"

// GenerateAttestation generates a provenance statement with SLSA v1.0 predicate for a task run.
func GenerateAttestation(ctx context.Context, tro *objects.TaskRunObjectV1, slsaConfig *slsaconfig.SlsaConfig) (interface{}, error) <span class="cov8" title="1">{
        bp, err := byproducts(tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">bd, err := builddefinition.GetTaskRunBuildDefinition(ctx, tro, slsaConfig.BuildType, resolveddependencies.ResolveOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sub := extract.SubjectDigests(ctx, tro, slsaConfig)

        return provenance.GetSLSA1Statement(tro, sub, &amp;bd, bp, slsaConfig)</span>
}

// byproducts contains the taskRunResults
func byproducts(tro *objects.TaskRunObjectV1) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        byProd := []*intoto.ResourceDescriptor{}
        for _, key := range tro.Status.Results </span><span class="cov8" title="1">{
                content, err := json.Marshal(key.Value)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">bp := intoto.ResourceDescriptor{
                        Name:      fmt.Sprintf(taskRunResults, key.Name),
                        Content:   content,
                        MediaType: "application/json",
                }
                byProd = append(byProd, &amp;bp)</span>
        }
        <span class="cov8" title="1">return byProd, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v2alpha3

import (
        "context"
        "fmt"

        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha3/internal/pipelinerun"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha3/internal/taskrun"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
)

const (
        PayloadTypeSlsav2alpha3 = formats.PayloadTypeSlsav2alpha3
)

func init() <span class="cov8" title="1">{
        formats.RegisterPayloader(PayloadTypeSlsav2alpha3, NewFormatter)
}</span>

type Slsa struct {
        slsaConfig *slsaconfig.SlsaConfig
}

func NewFormatter(cfg config.Config) (formats.Payloader, error) <span class="cov8" title="1">{
        return &amp;Slsa{
                slsaConfig: &amp;slsaconfig.SlsaConfig{
                        BuilderID:             cfg.Builder.ID,
                        DeepInspectionEnabled: cfg.Artifacts.PipelineRuns.DeepInspectionEnabled,
                        BuildType:             cfg.BuildDefinition.BuildType,
                },
        }, nil
}</span>

func (s *Slsa) Wrap() bool <span class="cov0" title="0">{
        return true
}</span>

func (s *Slsa) CreatePayload(ctx context.Context, obj interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case *objects.TaskRunObjectV1:<span class="cov8" title="1">
                return taskrun.GenerateAttestation(ctx, v, s.slsaConfig)</span>
        case *objects.PipelineRunObjectV1:<span class="cov8" title="1">
                return pipelinerun.GenerateAttestation(ctx, v, s.slsaConfig)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("intoto does not support type: %s", v)</span>
        }
}

func (s *Slsa) Type() config.PayloadType <span class="cov8" title="1">{
        return formats.PayloadTypeSlsav2alpha3
}</span>

// RetrieveAllArtifactURIs returns the full URI of all artifacts detected as subjects.
func (s *Slsa) RetrieveAllArtifactURIs(ctx context.Context, obj interface{}) ([]string, error) <span class="cov0" title="0">{
        tkObj, ok := obj.(objects.TektonObject)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("intoto does not support type")
        }</span>
        <span class="cov0" title="0">return extract.RetrieveAllArtifactURIs(ctx, tkObj, s.slsaConfig.DeepInspectionEnabled), nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2023 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/artifact"
        builddefinition "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_definition"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/provenance"
        resolveddependencies "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/resolved_dependencies"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/results"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha4/internal/taskrun"
        "github.com/tektoncd/chains/pkg/chains/objects"
)

const (
        pipelineRunResults = "pipelineRunResults/%s"
        // JSONMediaType is the media type of json encoded content used in resource descriptors
        JSONMediaType = "application/json"
)

// GenerateAttestation generates a provenance statement with SLSA v1.0 predicate for a pipeline run.
func GenerateAttestation(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig) (interface{}, error) <span class="cov8" title="1">{
        bp, err := byproducts(pro, slsaconfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">opts := resolveddependencies.ResolveOptions{WithStepActionsResults: true}
        bd, err := builddefinition.GetPipelineRunBuildDefinition(ctx, pro, slsaconfig, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sub := SubjectDigests(ctx, pro, slsaconfig)

        return provenance.GetSLSA1Statement(pro, sub, &amp;bd, bp, slsaconfig)</span>
}

// byproducts contains the pipelineRunResults that are not subjects.
func byproducts(pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        byProd, err := results.GetResultsWithoutBuildArtifacts(pro.GetResults(), pipelineRunResults)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !slsaconfig.DeepInspectionEnabled </span><span class="cov8" title="1">{
                return byProd, nil
        }</span>

        <span class="cov8" title="1">for _, tro := range pro.GetExecutedTasks() </span><span class="cov8" title="1">{
                taskProds, err := taskrun.ByProducts(tro)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">byProd = append(byProd, taskProds...)</span>
        }

        <span class="cov8" title="1">return byProd, nil</span>
}

// SubjectDigests calculates the subjects associated with the given PipelineRun.
func SubjectDigests(ctx context.Context, pro *objects.PipelineRunObjectV1, slsaconfig *slsaconfig.SlsaConfig) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        subjects := extract.SubjectsFromBuildArtifact(ctx, pro.GetResults())

        if !slsaconfig.DeepInspectionEnabled </span><span class="cov8" title="1">{
                return subjects
        }</span>

        <span class="cov8" title="1">for _, task := range pro.GetExecutedTasks() </span><span class="cov8" title="1">{
                subjects = artifact.AppendSubjects(subjects, taskrun.SubjectDigests(ctx, task)...)
        }</span>

        <span class="cov8" title="1">return subjects</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/artifact"
        builddefinition "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/build_definition"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/provenance"
        resolveddependencies "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/resolved_dependencies"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/results"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

const (
        taskRunResults     = "taskRunResults/%s"
        taskRunStepResults = "stepResults/%s"
)

// GenerateAttestation returns the provenance for the given taskrun in SALSA 1.0 format.
func GenerateAttestation(ctx context.Context, tro *objects.TaskRunObjectV1, slsaConfig *slsaconfig.SlsaConfig) (interface{}, error) <span class="cov8" title="1">{
        bp, err := ByProducts(tro)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">resOpts := resolveddependencies.ResolveOptions{WithStepActionsResults: true}
        bd, err := builddefinition.GetTaskRunBuildDefinition(ctx, tro, slsaConfig.BuildType, resOpts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sub := SubjectDigests(ctx, tro)

        return provenance.GetSLSA1Statement(tro, sub, &amp;bd, bp, slsaConfig)</span>
}

// ByProducts returns the results categorized as byproduct from the given TaskRun.
func ByProducts(tro *objects.TaskRunObjectV1) ([]*intoto.ResourceDescriptor, error) <span class="cov8" title="1">{
        byProd := []*intoto.ResourceDescriptor{}

        res, err := results.GetResultsWithoutBuildArtifacts(tro.GetResults(), taskRunResults)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">byProd = append(byProd, res...)

        res, err = results.GetResultsWithoutBuildArtifacts(tro.GetStepResults(), taskRunStepResults)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">byProd = append(byProd, res...)

        return byProd, nil</span>
}

// SubjectDigests returns the subjects detected in the given TaskRun. It takes into account taskrun and step results.
func SubjectDigests(ctx context.Context, tro *objects.TaskRunObjectV1) []*intoto.ResourceDescriptor <span class="cov8" title="1">{
        var subjects []*intoto.ResourceDescriptor
        for _, step := range tro.Status.Steps </span><span class="cov8" title="1">{
                res := getObjectResults(step.Results)
                stepSubjects := extract.SubjectsFromBuildArtifact(ctx, res)
                subjects = artifact.AppendSubjects(subjects, stepSubjects...)
        }</span>

        <span class="cov8" title="1">taskSubjects := extract.SubjectsFromBuildArtifact(ctx, tro.GetResults())
        subjects = artifact.AppendSubjects(subjects, taskSubjects...)

        return subjects</span>
}

func getObjectResults(tresults []v1.TaskRunResult) (res []objects.Result) <span class="cov8" title="1">{
        for _, r := range tresults </span><span class="cov8" title="1">{
                res = append(res, objects.Result{
                        Name:  r.Name,
                        Value: r.Value,
                })
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v2alpha4

import (
        "context"
        "fmt"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/internal/slsaconfig"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha4/internal/pipelinerun"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/v2alpha4/internal/taskrun"

        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
)

const (
        payloadTypeSlsav2alpha4 = formats.PayloadTypeSlsav2alpha4
)

func init() <span class="cov8" title="1">{
        formats.RegisterPayloader(payloadTypeSlsav2alpha4, NewFormatter)
}</span>

// Slsa is a v2alpha4 payloader implementation.
type Slsa struct {
        slsaConfig *slsaconfig.SlsaConfig
}

// NewFormatter returns a new v2alpha4 payloader.
func NewFormatter(cfg config.Config) (formats.Payloader, error) <span class="cov8" title="1">{ //nolint:ireturn
        return &amp;Slsa{
                slsaConfig: &amp;slsaconfig.SlsaConfig{
                        BuilderID:             cfg.Builder.ID,
                        DeepInspectionEnabled: cfg.Artifacts.PipelineRuns.DeepInspectionEnabled,
                        BuildType:             cfg.BuildDefinition.BuildType,
                },
        }, nil
}</span>

// Wrap indicates if the resulting payload should be wrapped.
func (s *Slsa) Wrap() bool <span class="cov0" title="0">{
        return true
}</span>

// CreatePayload returns the payload for the given object using the v2alpha4 formatter logic.
func (s *Slsa) CreatePayload(ctx context.Context, obj interface{}) (interface{}, error) <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case *objects.TaskRunObjectV1:<span class="cov8" title="1">
                return taskrun.GenerateAttestation(ctx, v, s.slsaConfig)</span>
        case *objects.PipelineRunObjectV1:<span class="cov0" title="0">
                return pipelinerun.GenerateAttestation(ctx, v, s.slsaConfig)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("intoto does not support type: %s", v)</span>
        }
}

// Type returns the version of this payloader.
func (s *Slsa) Type() config.PayloadType <span class="cov8" title="1">{
        return payloadTypeSlsav2alpha4
}</span>

// RetrieveAllArtifactURIs returns the full URI of all artifacts detected as subjects.
func (s *Slsa) RetrieveAllArtifactURIs(ctx context.Context, obj interface{}) ([]string, error) <span class="cov0" title="0">{
        var subjects []*intoto.ResourceDescriptor
        var fullURIs []string

        switch v := obj.(type) </span>{
        case *objects.TaskRunObjectV1:<span class="cov0" title="0">
                subjects = taskrun.SubjectDigests(ctx, v)</span>
        case *objects.PipelineRunObjectV1:<span class="cov0" title="0">
                subjects = pipelinerun.SubjectDigests(ctx, v, s.slsaConfig)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("intoto does not support type: %s", v)</span>
        }

        <span class="cov0" title="0">for _, s := range subjects </span><span class="cov0" title="0">{
                for algo, digest := range s.Digest </span><span class="cov0" title="0">{
                        fullURIs = append(fullURIs, fmt.Sprintf("%s@%s:%s", s.Name, algo, digest))
                }</span>
        }
        <span class="cov0" title="0">return fullURIs, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package objects

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "time"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

// Label added to TaskRuns identifying the associated pipeline Task
const PipelineTaskLabel = "tekton.dev/pipelineTask"

// patchOptions contains the default patch options
var patchOptions = metav1.PatchOptions{
        FieldManager: "tekton-chains-controller",
        Force:        ptr.Bool(false),
}

// Object is used as a base object of all Kubernetes objects
// ref: https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.9.4/pkg/client#Object
type Object interface {
        // Metadata associated to all Kubernetes objects
        metav1.Object
        // Runtime identifying data
        runtime.Object
}

// Result is a generic key value store containing the results
// of Tekton operations. (eg. PipelineRun and TaskRun results)
type Result struct {
        Name  string
        Type  v1.ResultsType
        Value v1.ParamValue
}

// Tekton object is an extended Kubernetes object with operations specific
// to Tekton objects.
type TektonObject interface {
        Object
        GetGVK() string
        GetKindName() string
        GetObject() interface{}
        GetLatestAnnotations(ctx context.Context, clientSet versioned.Interface) (map[string]string, error)
        Patch(ctx context.Context, clientSet versioned.Interface, patchBytes []byte) error
        GetResults() []Result
        GetProvenance() *v1.Provenance
        GetServiceAccountName() string
        IsDone() bool
        IsSuccessful() bool
        SupportsTaskRunArtifact() bool
        SupportsPipelineRunArtifact() bool
        SupportsOCIArtifact() bool
        GetRemoteProvenance() *v1.Provenance
        IsRemote() bool
        GetStartTime() *time.Time
        GetCompletitionTime() *time.Time
}

func NewTektonObject(i interface{}) (TektonObject, error) <span class="cov8" title="1">{
        switch o := i.(type) </span>{
        case *v1.PipelineRun:<span class="cov8" title="1">
                return NewPipelineRunObjectV1(o), nil</span>
        case *v1.TaskRun:<span class="cov8" title="1">
                return NewTaskRunObjectV1(o), nil</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("unrecognized type when attempting to create tekton object")</span>
        }
}

// TaskRunObjectV1 extends v1.TaskRun with additional functions.
type TaskRunObjectV1 struct {
        *v1.TaskRun
}

var _ TektonObject = &amp;TaskRunObjectV1{}

func NewTaskRunObjectV1(tr *v1.TaskRun) *TaskRunObjectV1 <span class="cov8" title="1">{
        return &amp;TaskRunObjectV1{
                tr,
        }
}</span>

// Get the TaskRun GroupVersionKind
func (tro *TaskRunObjectV1) GetGVK() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", tro.GetGroupVersionKind().GroupVersion().String(), tro.GetGroupVersionKind().Kind)
}</span>

func (tro *TaskRunObjectV1) GetKindName() string <span class="cov8" title="1">{
        return strings.ToLower(tro.GetGroupVersionKind().Kind)
}</span>

func (tro *TaskRunObjectV1) GetProvenance() *v1.Provenance <span class="cov8" title="1">{
        return tro.Status.Provenance
}</span>

// Get the latest annotations on the TaskRun
func (tro *TaskRunObjectV1) GetLatestAnnotations(ctx context.Context, clientSet versioned.Interface) (map[string]string, error) <span class="cov0" title="0">{
        tr, err := clientSet.TektonV1().TaskRuns(tro.Namespace).Get(ctx, tro.Name, metav1.GetOptions{})
        return tr.Annotations, err
}</span>

// Get the base TaskRun object
func (tro *TaskRunObjectV1) GetObject() interface{} <span class="cov0" title="0">{
        return tro.TaskRun
}</span>

// Patch the original TaskRun object
func (tro *TaskRunObjectV1) Patch(ctx context.Context, clientSet versioned.Interface, patchBytes []byte) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        _, err := clientSet.TektonV1().TaskRuns(tro.Namespace).Patch(
                ctx, tro.Name, types.ApplyPatchType, patchBytes, patchOptions)
        if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                // Since we only update the list of annotations we manage, there shouldn't be any conflicts unless
                // another controller/client is updating our annotations. We log the issue and force patch.
                logger.Warnf("failed to patch object %s/%s due to Server-Side Apply patch conflict, using force patch.", tro.Namespace, tro.Name)
                // use a copy to avoid changing the global var
                patchOptionsForce := patchOptions
                patchOptionsForce.Force = ptr.Bool(true)
                _, err = clientSet.TektonV1().TaskRuns(tro.Namespace).Patch(
                        ctx, tro.Name, types.ApplyPatchType, patchBytes, patchOptionsForce)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Get the TaskRun results
func (tro *TaskRunObjectV1) GetResults() []Result <span class="cov8" title="1">{
        res := []Result{}
        for _, key := range tro.Status.Results </span><span class="cov8" title="1">{
                res = append(res, Result{
                        Name:  key.Name,
                        Value: key.Value,
                })
        }</span>
        <span class="cov8" title="1">return res</span>
}

// GetStepResults returns all the results from associated StepActions.
func (tro *TaskRunObjectV1) GetStepResults() []Result <span class="cov0" title="0">{
        res := []Result{}
        for _, s := range tro.Status.Steps </span><span class="cov0" title="0">{
                for _, r := range s.Results </span><span class="cov0" title="0">{
                        res = append(res, Result{
                                Name:  r.Name,
                                Value: r.Value,
                        })
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}

func (tro *TaskRunObjectV1) GetStepImages() []string <span class="cov8" title="1">{
        images := []string{}
        for _, stepState := range tro.Status.Steps </span><span class="cov8" title="1">{
                images = append(images, stepState.ImageID)
        }</span>
        <span class="cov8" title="1">return images</span>
}

func (tro *TaskRunObjectV1) GetSidecarImages() []string <span class="cov8" title="1">{
        images := []string{}
        for _, sidecarState := range tro.Status.Sidecars </span><span class="cov8" title="1">{
                images = append(images, sidecarState.ImageID)
        }</span>
        <span class="cov8" title="1">return images</span>
}

// Get the ServiceAccount declared in the TaskRun
func (tro *TaskRunObjectV1) GetServiceAccountName() string <span class="cov8" title="1">{
        return tro.Spec.ServiceAccountName
}</span>

func (tro *TaskRunObjectV1) SupportsTaskRunArtifact() bool <span class="cov0" title="0">{
        return true
}</span>

func (tro *TaskRunObjectV1) SupportsPipelineRunArtifact() bool <span class="cov0" title="0">{
        return false
}</span>

func (tro *TaskRunObjectV1) SupportsOCIArtifact() bool <span class="cov0" title="0">{
        return true
}</span>

func (tro *TaskRunObjectV1) GetRemoteProvenance() *v1.Provenance <span class="cov0" title="0">{
        if t := tro.Status.Provenance; t != nil &amp;&amp; t.RefSource != nil &amp;&amp; tro.IsRemote() </span><span class="cov0" title="0">{
                return tro.Status.Provenance
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (tro *TaskRunObjectV1) IsRemote() bool <span class="cov8" title="1">{
        isRemoteTask := false
        if tro.Spec.TaskRef != nil </span><span class="cov8" title="1">{
                if tro.Spec.TaskRef.Resolver != "" &amp;&amp; tro.Spec.TaskRef.Resolver != "Cluster" </span><span class="cov8" title="1">{
                        isRemoteTask = true
                }</span>
        }
        <span class="cov8" title="1">return isRemoteTask</span>
}

// GetStartTime returns the time when the TaskRun started.
func (tro *TaskRunObjectV1) GetStartTime() *time.Time <span class="cov0" title="0">{
        var utc *time.Time
        if tro.Status.StartTime != nil </span><span class="cov0" title="0">{
                val := tro.Status.StartTime.Time.UTC()
                utc = &amp;val
        }</span>
        <span class="cov0" title="0">return utc</span>
}

// GetCompletitionTime returns the time when the TaskRun finished.
func (tro *TaskRunObjectV1) GetCompletitionTime() *time.Time <span class="cov0" title="0">{
        var utc *time.Time
        if tro.Status.CompletionTime != nil </span><span class="cov0" title="0">{
                val := tro.Status.CompletionTime.Time.UTC()
                utc = &amp;val
        }</span>
        <span class="cov0" title="0">return utc</span>
}

// PipelineRunObjectV1 extends v1.PipelineRun with additional functions.
type PipelineRunObjectV1 struct {
        // The base PipelineRun
        *v1.PipelineRun
        // taskRuns that were apart of this PipelineRun
        taskRuns []*v1.TaskRun
}

var _ TektonObject = &amp;PipelineRunObjectV1{}

func NewPipelineRunObjectV1(pr *v1.PipelineRun) *PipelineRunObjectV1 <span class="cov8" title="1">{
        return &amp;PipelineRunObjectV1{
                PipelineRun: pr,
        }
}</span>

// Get the PipelineRun GroupVersionKind
func (pro *PipelineRunObjectV1) GetGVK() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s/%s", pro.GetGroupVersionKind().GroupVersion().String(), pro.GetGroupVersionKind().Kind)
}</span>

func (pro *PipelineRunObjectV1) GetKindName() string <span class="cov8" title="1">{
        return strings.ToLower(pro.GetGroupVersionKind().Kind)
}</span>

// Request the current annotations on the PipelineRun object
func (pro *PipelineRunObjectV1) GetLatestAnnotations(ctx context.Context, clientSet versioned.Interface) (map[string]string, error) <span class="cov0" title="0">{
        pr, err := clientSet.TektonV1().PipelineRuns(pro.Namespace).Get(ctx, pro.Name, metav1.GetOptions{})
        return pr.Annotations, err
}</span>

// Get the base PipelineRun
func (pro *PipelineRunObjectV1) GetObject() interface{} <span class="cov0" title="0">{
        return pro.PipelineRun
}</span>

// Patch the original PipelineRun object
func (pro *PipelineRunObjectV1) Patch(ctx context.Context, clientSet versioned.Interface, patchBytes []byte) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        _, err := clientSet.TektonV1().PipelineRuns(pro.Namespace).Patch(
                ctx, pro.Name, types.ApplyPatchType, patchBytes, patchOptions)
        if apierrors.IsConflict(err) </span><span class="cov0" title="0">{
                // Since we only update the list of annotations we manage, there shouldn't be any conflicts unless
                // another controller/client is updating our annotations. We log the issue and force patch.
                logger.Warnf("failed to patch object %s/%s due to Server-Side Apply patch conflict, using force patch.", pro.Namespace, pro.Name)
                // use a copy to avoid changing the global var
                patchOptionsForce := patchOptions
                patchOptionsForce.Force = ptr.Bool(true)
                _, err = clientSet.TektonV1().PipelineRuns(pro.Namespace).Patch(
                        ctx, pro.Name, types.ApplyPatchType, patchBytes, patchOptionsForce)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (pro *PipelineRunObjectV1) GetProvenance() *v1.Provenance <span class="cov8" title="1">{
        return pro.Status.Provenance
}</span>

// Get the resolved Pipelinerun results
func (pro *PipelineRunObjectV1) GetResults() []Result <span class="cov8" title="1">{
        res := []Result{}
        for _, key := range pro.Status.Results </span><span class="cov8" title="1">{
                res = append(res, Result{
                        Name:  key.Name,
                        Value: key.Value,
                })
        }</span>
        <span class="cov8" title="1">return res</span>
}

// Get the ServiceAccount declared in the PipelineRun
func (pro *PipelineRunObjectV1) GetServiceAccountName() string <span class="cov8" title="1">{
        return pro.Spec.TaskRunTemplate.ServiceAccountName
}</span>

// Get the ServiceAccount declared in the PipelineRun
func (pro *PipelineRunObjectV1) IsSuccessful() bool <span class="cov0" title="0">{
        return pro.Status.GetCondition(apis.ConditionSucceeded).IsTrue()
}</span>

// Append TaskRuns to this PipelineRun
func (pro *PipelineRunObjectV1) AppendTaskRun(tr *v1.TaskRun) <span class="cov8" title="1">{
        pro.taskRuns = append(pro.taskRuns, tr)
}</span>

// Append TaskRuns to this PipelineRun
func (pro *PipelineRunObjectV1) GetTaskRuns() []*v1.TaskRun <span class="cov0" title="0">{
        return pro.taskRuns
}</span>

// Get the associated TaskRun via the Task name
func (pro *PipelineRunObjectV1) GetTaskRunsFromTask(taskName string) []*TaskRunObjectV1 <span class="cov8" title="1">{
        var taskRuns []*TaskRunObjectV1
        for _, tr := range pro.taskRuns </span><span class="cov8" title="1">{
                val, ok := tr.Labels[PipelineTaskLabel]
                if ok &amp;&amp; val == taskName </span><span class="cov8" title="1">{
                        taskRuns = append(taskRuns, NewTaskRunObjectV1(tr))
                }</span>
        }
        <span class="cov8" title="1">return taskRuns</span>
}

func (pro *PipelineRunObjectV1) SupportsTaskRunArtifact() bool <span class="cov0" title="0">{
        return false
}</span>

func (pro *PipelineRunObjectV1) SupportsPipelineRunArtifact() bool <span class="cov0" title="0">{
        return true
}</span>

func (pro *PipelineRunObjectV1) SupportsOCIArtifact() bool <span class="cov0" title="0">{
        return false
}</span>

func (pro *PipelineRunObjectV1) GetRemoteProvenance() *v1.Provenance <span class="cov0" title="0">{
        if p := pro.Status.Provenance; p != nil &amp;&amp; p.RefSource != nil &amp;&amp; pro.IsRemote() </span><span class="cov0" title="0">{
                return pro.Status.Provenance
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (pro *PipelineRunObjectV1) IsRemote() bool <span class="cov8" title="1">{
        isRemotePipeline := false
        if pro.Spec.PipelineRef != nil </span><span class="cov8" title="1">{
                if pro.Spec.PipelineRef.Resolver != "" &amp;&amp; pro.Spec.PipelineRef.Resolver != "Cluster" </span><span class="cov8" title="1">{
                        isRemotePipeline = true
                }</span>
        }
        <span class="cov8" title="1">return isRemotePipeline</span>
}

// GetStartTime returns the time when the PipelineRun started.
func (pro *PipelineRunObjectV1) GetStartTime() *time.Time <span class="cov0" title="0">{
        var utc *time.Time
        if pro.Status.StartTime != nil </span><span class="cov0" title="0">{
                val := pro.Status.StartTime.Time.UTC()
                utc = &amp;val
        }</span>
        <span class="cov0" title="0">return utc</span>
}

// GetCompletitionTime returns the time when the PipelineRun finished.
func (pro *PipelineRunObjectV1) GetCompletitionTime() *time.Time <span class="cov0" title="0">{
        var utc *time.Time
        if pro.Status.CompletionTime != nil </span><span class="cov0" title="0">{
                val := pro.Status.CompletionTime.Time.UTC()
                utc = &amp;val
        }</span>
        <span class="cov0" title="0">return utc</span>
}

// GetExecutedTasks returns the tasks that were executed during the pipeline run.
func (pro *PipelineRunObjectV1) GetExecutedTasks() (tro []*TaskRunObjectV1) <span class="cov0" title="0">{
        pSpec := pro.Status.PipelineSpec
        if pSpec == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">tasks := pSpec.Tasks
        tasks = append(tasks, pSpec.Finally...)
        for _, task := range tasks </span><span class="cov0" title="0">{
                taskRuns := pro.GetTaskRunsFromTask(task.Name)
                if len(taskRuns) == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, tr := range taskRuns </span><span class="cov0" title="0">{
                        if tr == nil || tr.Status.CompletionTime == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">tro = append(tro, tr)</span>
                }
        }

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package chains

import (
        "context"
        "crypto/sha256"

        "github.com/pkg/errors"
        "github.com/sigstore/cosign/v2/pkg/cosign"
        rc "github.com/sigstore/rekor/pkg/client"
        "github.com/sigstore/rekor/pkg/generated/client"
        "github.com/sigstore/rekor/pkg/generated/models"
        "github.com/sigstore/sigstore/pkg/cryptoutils"
        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/chains/signing"
        "github.com/tektoncd/chains/pkg/config"
)

const (
        RekorAnnotation = "chains.tekton.dev/transparency-upload"
)

type rekor struct {
        c *client.Rekor
}

type rekorClient interface {
        UploadTlog(ctx context.Context, signer signing.Signer, signature, rawPayload []byte, cert, payloadFormat string) (*models.LogEntryAnon, error)
}

func (r *rekor) UploadTlog(ctx context.Context, signer signing.Signer, signature, rawPayload []byte, cert, payloadFormat string) (*models.LogEntryAnon, error) <span class="cov0" title="0">{
        pkoc, err := publicKeyOrCert(signer, cert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "public key or cert")
        }</span>
        <span class="cov0" title="0">if _, ok := formats.IntotoAttestationSet[config.PayloadType(payloadFormat)]; ok </span><span class="cov0" title="0">{
                return cosign.TLogUploadInTotoAttestation(ctx, r.c, signature, pkoc)
        }</span>

        <span class="cov0" title="0">h := sha256.New()
        if _, err := h.Write(rawPayload); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "error checksuming payload")
        }</span>
        <span class="cov0" title="0">return cosign.TLogUpload(ctx, r.c, signature, h, pkoc)</span>
}

// return the cert if we have it, otherwise return public key
func publicKeyOrCert(signer signing.Signer, cert string) ([]byte, error) <span class="cov0" title="0">{
        if cert != "" </span><span class="cov0" title="0">{
                return []byte(cert), nil
        }</span>
        <span class="cov0" title="0">pub, err := signer.PublicKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "getting public key")
        }</span>
        <span class="cov0" title="0">pem, err := cryptoutils.MarshalPublicKeyToPEM(pub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "key to pem")
        }</span>
        <span class="cov0" title="0">return pem, nil</span>
}

var getRekor = func(url string) (rekorClient, error) <span class="cov0" title="0">{
        rekorClient, err := rc.GetRekorClient(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;rekor{
                c: rekorClient,
        }, nil</span>
}

func shouldUploadTlog(cfg config.Config, obj objects.TektonObject) bool <span class="cov8" title="1">{
        // if transparency isn't enabled, return false
        if !cfg.Transparency.Enabled </span><span class="cov8" title="1">{
                return false
        }</span>
        // if transparency is enabled and verification is disabled, return true
        <span class="cov8" title="1">if !cfg.Transparency.VerifyAnnotation </span><span class="cov8" title="1">{
                return true
        }</span>

        // Already uploaded, don't do it again
        <span class="cov8" title="1">if _, ok := obj.GetAnnotations()[ChainsTransparencyAnnotation]; ok </span><span class="cov8" title="1">{
                return false
        }</span>

        // verify the annotation
        <span class="cov8" title="1">ann := obj.GetAnnotations()[RekorAnnotation]
        return ann == "true"</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package chains

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"

        "github.com/hashicorp/go-multierror"
        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/tektoncd/chains/pkg/artifacts"
        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/chains/signing"
        "github.com/tektoncd/chains/pkg/chains/signing/kms"
        "github.com/tektoncd/chains/pkg/chains/signing/x509"
        "github.com/tektoncd/chains/pkg/chains/storage"
        "github.com/tektoncd/chains/pkg/config"
        "github.com/tektoncd/chains/pkg/metrics"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "golang.org/x/exp/maps"
        "google.golang.org/protobuf/encoding/protojson"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/logging"
)

type Signer interface {
        Sign(ctx context.Context, obj objects.TektonObject) error
}

type ObjectSigner struct {
        // Backends: store payload and signature
        // The keys are different storage option's name. {docdb, gcs, grafeas, oci, tekton}
        // The values are the actual storage backends that will be used to store and retrieve provenance.
        Backends          map[string]storage.Backend
        SecretPath        string
        Pipelineclientset versioned.Interface

        Recorder metrics.Recorder
}

func allSigners(ctx context.Context, sp string, cfg config.Config) map[string]signing.Signer <span class="cov8" title="1">{
        l := logging.FromContext(ctx)
        all := map[string]signing.Signer{}
        neededSigners := map[string]struct{}{
                cfg.Artifacts.OCI.Signer:          {},
                cfg.Artifacts.TaskRuns.Signer:     {},
                cfg.Artifacts.PipelineRuns.Signer: {},
        }

        for _, s := range signing.AllSigners </span><span class="cov8" title="1">{
                if _, ok := neededSigners[s]; !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">switch s </span>{
                case signing.TypeX509:<span class="cov8" title="1">
                        signer, err := x509.NewSigner(ctx, sp, cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Warnf("error configuring x509 signer: %s", err)
                                continue</span>
                        }
                        <span class="cov8" title="1">all[s] = signer</span>
                case signing.TypeKMS:<span class="cov0" title="0">
                        signer, err := kms.NewSigner(ctx, cfg.Signers.KMS)
                        if err != nil </span><span class="cov0" title="0">{
                                l.Warnf("error configuring kms signer with config %v: %s", cfg.Signers.KMS, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">all[s] = signer</span>
                default:<span class="cov0" title="0">
                        // This should never happen, so panic
                        l.Panicf("unsupported signer: %s", s)</span>
                }
        }
        <span class="cov8" title="1">return all</span>
}

// TODO: Hook this up to config.
func getSignableTypes(ctx context.Context, obj objects.TektonObject) ([]artifacts.Signable, error) <span class="cov8" title="1">{
        var types []artifacts.Signable

        if obj.SupportsTaskRunArtifact() </span><span class="cov8" title="1">{
                types = append(types, &amp;artifacts.TaskRunArtifact{})
        }</span>

        <span class="cov8" title="1">if obj.SupportsPipelineRunArtifact() </span><span class="cov8" title="1">{
                types = append(types, &amp;artifacts.PipelineRunArtifact{})
        }</span>

        <span class="cov8" title="1">if obj.SupportsOCIArtifact() </span><span class="cov8" title="1">{
                types = append(types, &amp;artifacts.OCIArtifact{})
        }</span>

        <span class="cov8" title="1">if len(types) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no signable artifacts found for %v", obj)
        }</span>

        <span class="cov8" title="1">return types, nil</span>
}

// Sign TaskRun and PipelineRun objects, as well as generates attestations for each.
// Follows process of extract payload, sign payload, store payload and signature.
func (o *ObjectSigner) Sign(ctx context.Context, tektonObj objects.TektonObject) error <span class="cov8" title="1">{
        cfg := *config.FromContext(ctx)
        logger := logging.FromContext(ctx)

        signableTypes, err := getSignableTypes(ctx, tektonObj)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">signers := allSigners(ctx, o.SecretPath, cfg)

        var merr *multierror.Error
        extraAnnotations := map[string]string{}
        for _, signableType := range signableTypes </span><span class="cov8" title="1">{
                if !signableType.Enabled(cfg) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">payloadFormat := signableType.PayloadFormat(cfg)
                // Find the right payload format and format the object
                payloader, err := formats.GetPayloader(payloadFormat, cfg)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Warnf("Format %s configured for %s: %v was not found", payloadFormat, tektonObj.GetGVK(), signableType.Type())
                        continue</span>
                }

                // Extract all the "things" to be signed.
                // We might have a few of each type (several binaries, or images)
                <span class="cov8" title="1">objects := signableType.ExtractObjects(ctx, tektonObj)
                // Go through each object one at a time.
                for _, obj := range objects </span><span class="cov8" title="1">{

                        payload, err := payloader.CreatePayload(ctx, obj)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err)
                                o.recordError(ctx, signableType.Type(), metrics.PayloadCreationError)
                                continue</span>
                        }
                        <span class="cov8" title="1">logger.Infof("Created payload of type %s for %s %s/%s", string(payloadFormat), tektonObj.GetGVK(), tektonObj.GetNamespace(), tektonObj.GetName())

                        // Sign it!
                        signerType := signableType.Signer(cfg)
                        signer, ok := signers[signerType]
                        if !ok </span><span class="cov0" title="0">{
                                logger.Warnf("No signer %s configured for %s", signerType, signableType.Type())
                                continue</span>
                        }

                        <span class="cov8" title="1">if payloader.Wrap() </span><span class="cov8" title="1">{
                                wrapped, err := signing.Wrap(signer)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">logger.Infof("Using wrapped envelope signer for %s", payloader.Type())
                                signer = wrapped</span>
                        }

                        <span class="cov8" title="1">logger.Infof("Signing object with %s", signerType)
                        rawPayload, err := getRawPayload(payload)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warnf("Unable to marshal payload for %s: %v", signerType, err)
                                o.recordError(ctx, signableType.Type(), metrics.MarshalPayloadError)
                                continue</span>
                        }

                        <span class="cov8" title="1">signature, err := signer.SignMessage(bytes.NewReader(rawPayload))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error(err)
                                o.recordError(ctx, signableType.Type(), metrics.SigningError)
                                continue</span>
                        }
                        <span class="cov8" title="1">measureMetrics(ctx, metrics.SignedMessagesCount, o.Recorder)

                        // Now store those!
                        for _, backend := range sets.List[string](signableType.StorageBackend(cfg)) </span><span class="cov8" title="1">{
                                b, ok := o.Backends[backend]
                                if !ok </span><span class="cov0" title="0">{
                                        backendErr := fmt.Errorf("could not find backend '%s' in configured backends (%v) while trying sign: %s/%s", backend, maps.Keys(o.Backends), tektonObj.GetKindName(), tektonObj.GetName())
                                        logger.Error(backendErr)
                                        o.recordError(ctx, signableType.Type(), metrics.StorageError)
                                        merr = multierror.Append(merr, backendErr)
                                        continue</span>
                                }

                                <span class="cov8" title="1">storageOpts := config.StorageOpts{
                                        ShortKey:      signableType.ShortKey(obj),
                                        FullKey:       signableType.FullKey(obj),
                                        Cert:          signer.Cert(),
                                        Chain:         signer.Chain(),
                                        PayloadFormat: payloadFormat,
                                }
                                if err := b.StorePayload(ctx, tektonObj, rawPayload, string(signature), storageOpts); err != nil </span><span class="cov8" title="1">{
                                        logger.Error(err)
                                        o.recordError(ctx, signableType.Type(), metrics.StorageError)
                                        merr = multierror.Append(merr, err)
                                }</span> else<span class="cov8" title="1"> {
                                        measureMetrics(ctx, metrics.SignsStoredCount, o.Recorder)
                                }</span>
                        }

                        <span class="cov8" title="1">if shouldUploadTlog(cfg, tektonObj) </span><span class="cov8" title="1">{
                                rekorClient, err := getRekor(cfg.Transparency.URL)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">entry, err := rekorClient.UploadTlog(ctx, signer, signature, rawPayload, signer.Cert(), string(payloadFormat))
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Warnf("error uploading entry to tlog: %v", err)
                                        o.recordError(ctx, signableType.Type(), metrics.TlogError)
                                        merr = multierror.Append(merr, err)
                                }</span> else<span class="cov8" title="1"> {
                                        logger.Infof("Uploaded entry to %s with index %d", cfg.Transparency.URL, *entry.LogIndex)
                                        extraAnnotations[ChainsTransparencyAnnotation] = fmt.Sprintf("%s/api/v1/log/entries?logIndex=%d", cfg.Transparency.URL, *entry.LogIndex)
                                        measureMetrics(ctx, metrics.PayloadUploadeCount, o.Recorder)
                                }</span>
                        }

                }
                <span class="cov8" title="1">if merr.ErrorOrNil() != nil </span><span class="cov8" title="1">{
                        if retryErr := HandleRetry(ctx, tektonObj, o.Pipelineclientset, extraAnnotations); retryErr != nil </span><span class="cov0" title="0">{
                                logger.Warnf("error handling retry: %v", retryErr)
                                merr = multierror.Append(merr, retryErr)
                        }</span>
                        <span class="cov8" title="1">return merr</span>
                }
        }

        // Now mark the TektonObject as signed
        <span class="cov8" title="1">if err := MarkSigned(ctx, tektonObj, o.Pipelineclientset, extraAnnotations); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">measureMetrics(ctx, metrics.MarkedAsSignedCount, o.Recorder)
        return nil</span>
}

func measureMetrics(ctx context.Context, metrictype metrics.Metric, mtr metrics.Recorder) <span class="cov8" title="1">{
        if mtr != nil </span><span class="cov0" title="0">{
                mtr.RecordCountMetrics(ctx, metrictype)
        }</span>
}

// recordError abstracts the check and calls RecordErrorMetric if appropriate.
func (o *ObjectSigner) recordError(ctx context.Context, kind string, errType metrics.MetricErrorType) <span class="cov8" title="1">{
        shouldRecordError := kind == "TaskRunArtifact" || kind == "PipelineRunArtifact"
        if shouldRecordError &amp;&amp; o.Recorder != nil </span><span class="cov0" title="0">{
                o.Recorder.RecordErrorMetric(ctx, errType)
        }</span>
}

func HandleRetry(ctx context.Context, obj objects.TektonObject, ps versioned.Interface, annotations map[string]string) error <span class="cov8" title="1">{
        if RetryAvailable(obj) </span><span class="cov8" title="1">{
                return AddRetry(ctx, obj, ps, annotations)
        }</span>
        <span class="cov8" title="1">return MarkFailed(ctx, obj, ps, annotations)</span>
}

// getRawPayload returns the payload as a json string. If the given payload is a intoto.Statement type, protojson.Marshal
// is used to get the proper labels/field names in the resulting json.
func getRawPayload(payload interface{}) ([]byte, error) <span class="cov8" title="1">{
        switch payloadObj := payload.(type) </span>{
        case intoto.Statement:<span class="cov8" title="1">
                return protojson.Marshal(&amp;payloadObj)</span>
        case *intoto.Statement:<span class="cov8" title="1">
                if payloadObj == nil </span><span class="cov8" title="1">{
                        return json.Marshal(payload)
                }</span>
                <span class="cov8" title="1">return protojson.Marshal(payloadObj)</span>
        default:<span class="cov8" title="1">
                return json.Marshal(payload)</span>
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Package kms creates a signer using a key management server
package kms

import (
        "context"
        "crypto"
        "fmt"
        "net"
        "net/url"
        "os"
        "strings"
        "time"

        "github.com/sigstore/sigstore/pkg/signature"
        "github.com/sigstore/sigstore/pkg/signature/kms"
        _ "github.com/sigstore/sigstore/pkg/signature/kms/aws"
        _ "github.com/sigstore/sigstore/pkg/signature/kms/azure"
        _ "github.com/sigstore/sigstore/pkg/signature/kms/gcp"
        _ "github.com/sigstore/sigstore/pkg/signature/kms/hashivault"
        "github.com/sigstore/sigstore/pkg/signature/options"
        "github.com/tektoncd/chains/pkg/config"

        "github.com/spiffe/go-spiffe/v2/svid/jwtsvid"
        "github.com/spiffe/go-spiffe/v2/workloadapi"
        "github.com/tektoncd/chains/pkg/chains/signing"
)

// Signer exposes methods to sign payloads using a KMS
type Signer struct {
        signature.SignerVerifier
}

// NewSigner returns a configured Signer
func NewSigner(ctx context.Context, cfg config.KMSSigner) (*Signer, error) <span class="cov8" title="1">{
        kmsOpts := []signature.RPCOption{}

        // Checks if the vault address provide by the user is a valid address or not
        if cfg.Auth.Address != "" </span><span class="cov8" title="1">{
                vaultAddress, err := url.Parse(cfg.Auth.Address)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var vaultUrl *url.URL
                switch </span>{
                case vaultAddress.Port() != "":<span class="cov8" title="1">
                        vaultUrl = vaultAddress</span>
                case vaultAddress.Scheme == "http":<span class="cov0" title="0">
                        vaultUrl = &amp;url.URL{
                                Scheme: vaultAddress.Scheme,
                                Host:   vaultAddress.Host + ":80",
                        }</span>
                case vaultAddress.Scheme == "https":<span class="cov0" title="0">
                        vaultUrl = &amp;url.URL{
                                Scheme: vaultAddress.Scheme,
                                Host:   vaultAddress.Host + ":443",
                        }</span>
                case vaultAddress.Scheme == "":<span class="cov8" title="1">
                        vaultUrl = &amp;url.URL{
                                Scheme: "http",
                                Host:   cfg.Auth.Address + ":80",
                        }</span>
                case vaultAddress.Scheme != "" &amp;&amp; vaultAddress.Scheme != "http" &amp;&amp; vaultAddress.Scheme != "https":<span class="cov8" title="1">
                        vaultUrl = &amp;url.URL{
                                Scheme: "http",
                                Host:   cfg.Auth.Address,
                        }
                        if vaultUrl.Port() == "" </span><span class="cov0" title="0">{
                                vaultUrl.Host = cfg.Auth.Address + ":80"
                        }</span>
                }

                <span class="cov8" title="1">if vaultUrl != nil </span><span class="cov8" title="1">{
                        conn, err := net.DialTimeout("tcp", vaultUrl.Host, 5*time.Second)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">defer conn.Close()</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("Error connecting to URL %s\n", cfg.Auth.Address)
                }</span>
        }

        // pass through configuration options to RPCAuth used by KMS in sigstore
        <span class="cov8" title="1">rpcAuth := options.RPCAuth{
                Address: cfg.Auth.Address,
                OIDC: options.RPCAuthOIDC{
                        Role: cfg.Auth.OIDC.Role,
                        Path: cfg.Auth.OIDC.Path,
                },
        }

        // get token from file KMS_AUTH_TOKEN, a mounted secret at signers.kms.auth.token-dir or
        // as direct value set from signers.kms.auth.token.
        // If both values are set, priority will be given to token-dir.

        if cfg.Auth.TokenPath != "" </span><span class="cov0" title="0">{
                rpcAuthToken, err := getKMSAuthToken(cfg.Auth.TokenPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rpcAuth.Token = rpcAuthToken</span>
        } else<span class="cov8" title="1"> {
                rpcAuth.Token = cfg.Auth.Token
        }</span>

        // get token from spire
        <span class="cov8" title="1">if cfg.Auth.Spire.Sock != "" </span><span class="cov0" title="0">{
                token, err := newSpireToken(ctx, cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">rpcAuth.OIDC.Token = token</span>
        }
        <span class="cov8" title="1">kmsOpts = append(kmsOpts, options.WithRPCAuthOpts(rpcAuth))
        // get the signer/verifier from sigstore
        k, err := kms.Get(ctx, cfg.KMSRef, crypto.SHA256, kmsOpts...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Signer{
                SignerVerifier: k,
        }, nil</span>
}

// getKMSAuthToken retreives token from the given mount path
func getKMSAuthToken(path string) (string, error) <span class="cov8" title="1">{
        fileData, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("reading file in %q: %w", path, err)
        }</span>

        // A trailing newline is fairly common in mounted files, so remove it.
        <span class="cov8" title="1">fileDataNormalized := strings.TrimSuffix(string(fileData), "\n")
        return fileDataNormalized, nil</span>
}

// newSpireToken retrieves an SVID token from Spire
func newSpireToken(ctx context.Context, cfg config.KMSSigner) (string, error) <span class="cov0" title="0">{
        jwtSource, err := workloadapi.NewJWTSource(
                ctx,
                workloadapi.WithClientOptions(workloadapi.WithAddr(cfg.Auth.Spire.Sock)),
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">svid, err := jwtSource.FetchJWTSVID(ctx, jwtsvid.Params{Audience: cfg.Auth.Spire.Audience})
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return svid.Marshal(), nil</span>
}

// Type returns the type of the signer
func (s *Signer) Type() string <span class="cov0" title="0">{
        return signing.TypeKMS
}</span>

// Cert there is no cert, return nothing
func (s *Signer) Cert() string <span class="cov0" title="0">{
        return ""
}</span>

// Chain there is no chain, return nothing
func (s *Signer) Chain() string <span class="cov0" title="0">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2021 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package signing

import (
        "bytes"
        "context"
        "crypto"
        "encoding/json"
        "fmt"
        "io"

        "github.com/in-toto/in-toto-golang/in_toto"
        "github.com/secure-systems-lab/go-securesystemslib/dsse"
        "github.com/sigstore/sigstore/pkg/signature"

        "golang.org/x/crypto/ssh"
)

func Wrap(s Signer) (Signer, error) <span class="cov0" title="0">{
        pub, err := s.PublicKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Generate public key fingerprint
        <span class="cov0" title="0">sshpk, err := ssh.NewPublicKey(pub)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">fingerprint := ssh.FingerprintSHA256(sshpk)

        adapter := sslAdapter{
                wrapped: s,
                keyID:   fingerprint,
                pk:      sshpk,
        }

        envelope, err := dsse.NewEnvelopeSigner(&amp;adapter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sslSigner{
                wrapper: envelope,
                typ:     s.Type(),
                pub:     pub,
                cert:    s.Cert(),
                chain:   s.Chain(),
        }, nil</span>
}

// sslAdapter converts our signing objects into the type expected by the Envelope signer for wrapping.
type sslAdapter struct {
        wrapped Signer
        keyID   string
        pk      crypto.PublicKey
}

func (w *sslAdapter) Sign(ctx context.Context, data []byte) ([]byte, error) <span class="cov0" title="0">{
        sig, err := w.wrapped.SignMessage(bytes.NewReader(data))
        return sig, err
}</span>

func (w *sslAdapter) KeyID() (string, error) <span class="cov0" title="0">{
        return w.keyID, nil
}</span>

func (w *sslAdapter) Public() crypto.PublicKey <span class="cov0" title="0">{
        return w.pk
}</span>

func (w *sslAdapter) Verify(_ context.Context, data, sig []byte) error <span class="cov0" title="0">{
        panic("unimplemented")</span>
}

// sslSigner converts the EnvelopeSigners back into our types, after wrapping.
type sslSigner struct {
        wrapper *dsse.EnvelopeSigner
        typ     string
        pub     crypto.PublicKey
        cert    string
        chain   string
}

func (w *sslSigner) Type() string <span class="cov0" title="0">{
        return w.typ
}</span>
func (w *sslSigner) PublicKey(opts ...signature.PublicKeyOption) (crypto.PublicKey, error) <span class="cov0" title="0">{
        return w.pub, nil
}</span>

func (w *sslSigner) Sign(ctx context.Context, payload []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        env, err := w.wrapper.SignPayload(ctx, in_toto.PayloadType, payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">b, err := json.Marshal(env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">return b, []byte(env.Payload), nil</span>
}

func (w *sslSigner) SignMessage(payload io.Reader, opts ...signature.SignOption) ([]byte, error) <span class="cov0" title="0">{
        m, err := io.ReadAll(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">env, err := w.wrapper.SignPayload(context.TODO(), in_toto.PayloadType, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b, err := json.Marshal(env)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return b, nil</span>
}

func (w *sslSigner) Cert() string <span class="cov0" title="0">{
        return w.cert
}</span>

func (w *sslSigner) Chain() string <span class="cov0" title="0">{
        return w.chain
}</span>

func (w *sslSigner) VerifySignature(signature, message io.Reader, opts ...signature.VerifyOption) error <span class="cov0" title="0">{
        return fmt.Errorf("not implemented")
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">//
// Copyright 2023 The Sigstore Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package x509

import (
        "context"
        "os"

        "github.com/sigstore/cosign/v2/pkg/providers"
        "github.com/sigstore/cosign/v2/pkg/providers/filesystem"
)

const (
        fsCustomTokenPathProvider        = "filesystem-custom-path"
        fsDefaultCosignTokenPathProvider = "filesystem"
)

func init() <span class="cov8" title="1">{
        providers.Register(fsCustomTokenPathProvider, &amp;filesystemCustomPath{})
}</span>

type filesystemCustomPath struct{}

var _ providers.Interface = (*filesystemCustomPath)(nil)

var (
        // FilesystemTokenPath is the path to where we read an OIDC
        // token from the filesystem. This is the hard-coded value from cosign.
        // If identity.token.file is configured, this variable will be updated to match.
        // nolint
        FilesystemTokenPath = filesystem.FilesystemTokenPath
)

// Enabled implements providers.Interface
func (ga *filesystemCustomPath) Enabled(ctx context.Context) bool <span class="cov8" title="1">{
        // If we can stat the file without error then this is enabled.
        _, err := os.Stat(FilesystemTokenPath)
        return err == nil
}</span>

// Provide implements providers.Interface
func (ga *filesystemCustomPath) Provide(ctx context.Context, audience string) (string, error) <span class="cov8" title="1">{
        b, err := os.ReadFile(FilesystemTokenPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(b), nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package x509

import (
        "context"
        "crypto"
        "crypto/ecdsa"
        cx509 "crypto/x509"
        "encoding/json"
        "encoding/pem"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "os"
        "path/filepath"

        "github.com/pkg/errors"
        "github.com/sigstore/cosign/v2/cmd/cosign/cli/fulcio"
        "github.com/sigstore/cosign/v2/cmd/cosign/cli/options"
        "github.com/sigstore/cosign/v2/pkg/cosign"
        "github.com/sigstore/cosign/v2/pkg/providers"
        "knative.dev/pkg/logging"

        "github.com/sigstore/sigstore/pkg/signature"
        "github.com/sigstore/sigstore/pkg/tuf"
        "github.com/tektoncd/chains/pkg/chains/signing"
        "github.com/tektoncd/chains/pkg/config"
)

const (
        defaultOIDCClientID = "sigstore"
)

// Signer exposes methods to sign payloads.
type Signer struct {
        cert  string
        chain string
        signature.SignerVerifier
}

// NewSigner returns a configured Signer
func NewSigner(ctx context.Context, secretPath string, cfg config.Config) (*Signer, error) <span class="cov8" title="1">{
        x509PrivateKeyPath := filepath.Join(secretPath, "x509.pem")
        cosignPrivateKeypath := filepath.Join(secretPath, "cosign.key")

        if cfg.Signers.X509.FulcioEnabled </span><span class="cov8" title="1">{
                return fulcioSigner(ctx, cfg.Signers.X509)
        }</span> else<span class="cov8" title="1"> if contents, err := os.ReadFile(x509PrivateKeyPath); err == nil </span><span class="cov8" title="1">{
                return x509Signer(ctx, contents)
        }</span> else<span class="cov0" title="0"> if contents, err := os.ReadFile(cosignPrivateKeypath); err == nil </span><span class="cov0" title="0">{
                return cosignSigner(ctx, secretPath, contents)
        }</span>
        <span class="cov0" title="0">return nil, errors.New("no valid private key found, looked for: [x509.pem, cosign.key]")</span>
}

func fulcioSigner(ctx context.Context, cfg config.X509Signer) (*Signer, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        providersEnabled := providers.Enabled(ctx)

        if cfg.IdentityTokenFile != "" </span><span class="cov8" title="1">{
                FilesystemTokenPath = cfg.IdentityTokenFile
                providersEnabled = true
        }</span>
        <span class="cov8" title="1">if !providersEnabled </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no auth provider for fulcio is enabled")
        }</span>
        <span class="cov8" title="1">var tok string
        var err error
        if cfg.TUFMirrorURL != tuf.DefaultRemoteRoot </span><span class="cov0" title="0">{
                if err = initializeTUF(ctx, cfg.TUFMirrorURL); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "initialize tuf")
                }</span>
        }

        <span class="cov8" title="1">if cfg.IdentityTokenFile != "" </span><span class="cov8" title="1">{
                switch cfg.FulcioProvider </span>{
                // cosign providers package hardcodes the token path value
                // "filesystem-custom-path" accepts a variable for the token path
                case fsDefaultCosignTokenPathProvider, "", fsCustomTokenPathProvider:<span class="cov8" title="1">
                        cfg.FulcioProvider = fsCustomTokenPathProvider</span>
                }
        }

        <span class="cov8" title="1">if cfg.FulcioProvider != "" </span><span class="cov8" title="1">{
                logger.Infof("Attempting to get id token from provider %s", cfg.FulcioProvider)
                p, err := providers.ProvideFrom(ctx, cfg.FulcioProvider)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "provide from")
                }</span>
                <span class="cov8" title="1">tok, err = p.Provide(ctx, defaultOIDCClientID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "getting token from provider %s", cfg.FulcioProvider)
                }</span>
        } else<span class="cov0" title="0"> {
                // if FulcioProvider is not set, all will be tried
                tok, err = providers.Provide(ctx, defaultOIDCClientID)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "getting provider")
        }</span>

        <span class="cov8" title="1">logger.Info("Signing with fulcio ...")
        priv, err := cosign.GeneratePrivateKey()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error generating keypair: %w", err)
        }</span>
        <span class="cov8" title="1">signer, err := signature.LoadECDSASignerVerifier(priv, crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error loading sigstore signer: %w", err)
        }</span>
        <span class="cov8" title="1">k, err := fulcio.NewSigner(ctx, options.KeyOpts{
                FulcioURL:    cfg.FulcioAddr,
                IDToken:      tok,
                OIDCIssuer:   cfg.FulcioOIDCIssuer,
                OIDCClientID: defaultOIDCClientID,
        }, signer)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "new signer")
        }</span>
        <span class="cov0" title="0">return &amp;Signer{
                SignerVerifier: signer,
                cert:           string(k.Cert),
                chain:          string(k.Chain),
        }, nil</span>
}

// root: TUF_URL/root.json
// mirror: TUF_URL
func initializeTUF(ctx context.Context, mirror string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        // Get the initial trusted root contents.
        root, err := url.JoinPath(mirror, "root.json")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rootFileBytes, err := loadRootFromURL(root)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if err = tuf.Initialize(ctx, mirror, rootFileBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">status, err := tuf.GetRootStatus(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b, err := json.MarshalIndent(status, "", "\t")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Infof("Root status: %s", string(b))
        return nil</span>
}

func loadRootFromURL(root string) ([]byte, error) <span class="cov0" title="0">{
        resp, err := http.Get(root)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        return io.ReadAll(resp.Body)</span>
}

func x509Signer(ctx context.Context, privateKey []byte) (*Signer, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Info("Found x509 key...")

        p, _ := pem.Decode(privateKey)
        if p.Type != "PRIVATE KEY" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expected private key, found object of type %s", p.Type)
        }</span>
        <span class="cov8" title="1">pk, err := cx509.ParsePKCS8PrivateKey(p.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">signer, err := signature.LoadECDSASignerVerifier(pk.(*ecdsa.PrivateKey), crypto.SHA256)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Signer{SignerVerifier: signer}, nil</span>
}

func cosignSigner(ctx context.Context, secretPath string, privateKey []byte) (*Signer, error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        logger.Info("Found cosign key...")
        cosignPasswordPath := filepath.Join(secretPath, "cosign.password")
        password, err := os.ReadFile(cosignPasswordPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "reading cosign.password file")
        }</span>
        <span class="cov0" title="0">signer, err := cosign.LoadPrivateKey(privateKey, password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Signer{SignerVerifier: signer}, nil</span>
}

func (s *Signer) Type() string <span class="cov0" title="0">{
        return signing.TypeX509
}</span>

func (s *Signer) Cert() string <span class="cov0" title="0">{
        return s.cert
}</span>

// there is no cert or chain, return nothing
func (s *Signer) Chain() string <span class="cov0" title="0">{
        return s.chain
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2025 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package archivista

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strings"

        archivistaClient "github.com/in-toto/archivista/pkg/http-client"
        "github.com/in-toto/go-witness/dsse"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
        "knative.dev/pkg/logging"
)

const (
        // StorageBackendArchivista is the name of the Archivista storage backend
        StorageBackendArchivista = "archivista"
)

// Backend is a storage backend that is capable of storing Payloaders that are signed and wrapped
// with a DSSE envelope. Archivista is an in-toto attestation storage service.
type Backend struct {
        client *archivistaClient.ArchivistaClient
        url    string
        cfg    config.ArchivistaStorageConfig
}

// NewStorageBackend returns a new Archivista StorageBackend that can store Payloaders that are signed
// and wrapped in a DSSE envelope
func NewStorageBackend(cfg config.Config) (*Backend, error) <span class="cov8" title="1">{
        archCfg := cfg.Storage.Archivista
        if strings.TrimSpace(archCfg.URL) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing archivista URL in storage configuration")
        }</span>

        <span class="cov8" title="1">client, err := archivistaClient.CreateArchivistaClient(&amp;http.Client{}, archCfg.URL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Archivista client: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Backend{
                client: client,
                url:    archCfg.URL,
                cfg:    archCfg,
        }, nil</span>
}

// StorePayload attempts to parse `signature` as a DSSE envelope, and if successful
// sends it to an Archivista server for storage.
func (b *Backend) StorePayload(ctx context.Context, _ objects.TektonObject, _ []byte, signature string, _ config.StorageOpts) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        var env dsse.Envelope
        if err := json.Unmarshal([]byte(signature), &amp;env); err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Failed to parse DSSE envelope: %w", err)
                return errors.Join(errors.New("Failed to parse DSSE envelope"), err)
        }</span>

        <span class="cov8" title="1">uploadResp, err := b.client.Store(ctx, env)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to upload DSSE envelope to Archivista", "error", err)
                return err
        }</span>
        <span class="cov8" title="1">logger.Infof("Successfully uploaded DSSE envelope to Archivista, response: %+v", uploadResp)
        return nil</span>
}

// RetrievePayload is not implemented for Archivista.
func (b *Backend) RetrievePayload(_ context.Context, _ string) ([]byte, []byte, error) <span class="cov0" title="0">{
        return nil, nil, fmt.Errorf("RetrievePayload not implemented for Archivista")
}</span>

// RetrievePayloads is not implemented for Archivista.
func (b *Backend) RetrievePayloads(_ context.Context, _ objects.TektonObject, _ config.StorageOpts) (map[string]string, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("RetrievePayloads not implemented for Archivista")
}</span>

// RetrieveSignatures is not implemented for Archivista.
func (b *Backend) RetrieveSignatures(_ context.Context, _ objects.TektonObject, _ config.StorageOpts) (map[string][]string, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("RetrieveSignatures not implemented for Archivista")
}</span>

// Type returns the name of the storage backend
func (b *Backend) Type() string <span class="cov0" title="0">{
        return StorageBackendArchivista
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright 2021 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package docdb

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/url"
        "os"
        "path/filepath"
        "slices"
        "strings"

        "github.com/fsnotify/fsnotify"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
        "gocloud.dev/docstore"
        _ "gocloud.dev/docstore/awsdynamodb"
        _ "gocloud.dev/docstore/gcpfirestore"
        "gocloud.dev/docstore/mongodocstore"
        _ "gocloud.dev/docstore/mongodocstore"
        "knative.dev/pkg/logging"
)

const (
        StorageTypeDocDB = "docdb"
        mongoEnv         = "MONGO_SERVER_URL"
)

// ErrNothingToWatch is an error that's returned when the backend doesn't have anything to "watch"
var ErrNothingToWatch = fmt.Errorf("backend has nothing to watch")

// Backend is a storage backend that stores signed payloads in the TaskRun metadata as an annotation.
// It is stored as base64 encoded JSON.
type Backend struct {
        coll *docstore.Collection
}

type SignedDocument struct {
        Signed    []byte
        Signature string
        Cert      string
        Chain     string
        Object    interface{}
        Name      string
}

// NewStorageBackend returns a new Tekton StorageBackend that stores signatures on a TaskRun
func NewStorageBackend(ctx context.Context, cfg config.Config) (*Backend, error) <span class="cov0" title="0">{
        docdbURL := cfg.Storage.DocDB.URL

        u, err := url.Parse(docdbURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if u.Scheme == mongodocstore.Scheme </span><span class="cov0" title="0">{
                // MONGO_SERVER_URL can be passed in as an environment variable or via config fields
                if err := populateMongoServerURL(ctx, cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">coll, err := docstore.OpenCollection(ctx, docdbURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Backend{
                coll: coll,
        }, nil</span>
}

// WatchBackend returns a channel that receives a new Backend each time it needs to be updated
func WatchBackend(ctx context.Context, cfg config.Config, watcherStop chan bool) (chan *Backend, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        docDBURL := cfg.Storage.DocDB.URL

        u, err := url.Parse(docDBURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set up the watcher only for mongo backends
        <span class="cov8" title="1">if u.Scheme != mongodocstore.Scheme </span><span class="cov8" title="1">{
                return nil, ErrNothingToWatch
        }</span>

        <span class="cov8" title="1">pathsToWatch := getPathsToWatch(ctx, cfg)
        if len(pathsToWatch) == 0 </span><span class="cov8" title="1">{
                return nil, ErrNothingToWatch
        }</span>

        <span class="cov0" title="0">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">backendChan := make(chan *Backend)
        // Start listening for events.
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case event, ok := &lt;-watcher.Events:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">logger.Infof("received event: %s, path: %s", event.Op.String(), event.Name)
                                // Only respond to create/write/remove events in the directory
                                if !(event.Has(fsnotify.Create) || event.Has(fsnotify.Write) || event.Has(fsnotify.Remove)) </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">if !slices.Contains(pathsToWatch, event.Name) </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">var updatedEnv string
                                if cfg.Storage.DocDB.MongoServerURLPath != "" </span><span class="cov0" title="0">{
                                        updatedEnv, err = getMongoServerURLFromPath(cfg.Storage.DocDB.MongoServerURLPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Error(err)
                                                backendChan &lt;- nil
                                        }</span>
                                } else<span class="cov0" title="0"> if cfg.Storage.DocDB.MongoServerURLDir != "" </span><span class="cov0" title="0">{
                                        updatedEnv, err = getMongoServerURLFromDir(cfg.Storage.DocDB.MongoServerURLDir)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Error(err)
                                                backendChan &lt;- nil
                                        }</span>
                                }

                                <span class="cov0" title="0">if updatedEnv != os.Getenv("MONGO_SERVER_URL") </span><span class="cov0" title="0">{
                                        logger.Info("Mongo server url has been updated, reconfiguring backend...")

                                        // Now that MONGO_SERVER_URL has been updated, we should update docdb backend again
                                        newDocDBBackend, err := NewStorageBackend(ctx, cfg)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Error(err)
                                                backendChan &lt;- nil
                                        }</span> else<span class="cov0" title="0"> {
                                                // Storing the backend in the signer so everyone has access to the up-to-date backend
                                                backendChan &lt;- newDocDBBackend
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        logger.Infof("MONGO_SERVER_URL has not changed in path: %s, backend will not be reconfigured", cfg.Storage.DocDB.MongoServerURLDir)
                                }</span>

                        case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">logger.Error(err)</span>

                        case &lt;-watcherStop:<span class="cov0" title="0">
                                logger.Info("stopping fsnotify context...")
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">if cfg.Storage.DocDB.MongoServerURLPath != "" </span><span class="cov0" title="0">{
                dirPath := filepath.Dir(cfg.Storage.DocDB.MongoServerURLPath)
                // Add a path.
                err = watcher.Add(dirPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if cfg.Storage.DocDB.MongoServerURLDir != "" </span><span class="cov0" title="0">{
                // Add a path.
                err = watcher.Add(cfg.Storage.DocDB.MongoServerURLDir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return backendChan, nil</span>
}

// StorePayload implements the Payloader interface.
func (b *Backend) StorePayload(ctx context.Context, _ objects.TektonObject, rawPayload []byte, signature string, opts config.StorageOpts) error <span class="cov8" title="1">{
        var obj interface{}
        if err := json.Unmarshal(rawPayload, &amp;obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">entry := SignedDocument{
                Signed:    rawPayload,
                Signature: base64.StdEncoding.EncodeToString([]byte(signature)),
                Object:    obj,
                Name:      opts.ShortKey,
                Cert:      opts.Cert,
                Chain:     opts.Chain,
        }

        if err := b.coll.Put(ctx, &amp;entry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *Backend) Type() string <span class="cov0" title="0">{
        return StorageTypeDocDB
}</span>

func (b *Backend) RetrieveSignatures(ctx context.Context, _ objects.TektonObject, opts config.StorageOpts) (map[string][]string, error) <span class="cov8" title="1">{
        // Retrieve the document.
        documents, err := b.retrieveDocuments(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">m := make(map[string][]string)
        for _, d := range documents </span><span class="cov8" title="1">{
                // Extract and decode the signature.
                sig, err := base64.StdEncoding.DecodeString(d.Signature)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">m[d.Name] = []string{string(sig)}</span>
        }
        <span class="cov8" title="1">return m, nil</span>
}

func (b *Backend) RetrievePayloads(ctx context.Context, _ objects.TektonObject, opts config.StorageOpts) (map[string]string, error) <span class="cov8" title="1">{
        documents, err := b.retrieveDocuments(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">m := make(map[string]string)
        for _, d := range documents </span><span class="cov8" title="1">{
                m[d.Name] = string(d.Signed)
        }</span>

        <span class="cov8" title="1">return m, nil</span>
}

func (b *Backend) retrieveDocuments(ctx context.Context, opts config.StorageOpts) ([]SignedDocument, error) <span class="cov8" title="1">{
        d := SignedDocument{Name: opts.ShortKey}
        if err := b.coll.Get(ctx, &amp;d); err != nil </span><span class="cov0" title="0">{
                return []SignedDocument{}, err
        }</span>
        <span class="cov8" title="1">return []SignedDocument{d}, nil</span>
}

func populateMongoServerURL(ctx context.Context, cfg config.Config) error <span class="cov8" title="1">{
        // First preference is given to the key `storage.docdb.mongo-server-url-path`.
        // If that doesn't exist, then we move on to `storage.docdb.mongo-server-url-dir`.
        // If that doesn't exist, then we move on to `storage.docdb.mongo-server-url`.
        // If that doesn't exist, then we check if `MONGO_SERVER_URL` env var is set.
        logger := logging.FromContext(ctx)

        if cfg.Storage.DocDB.MongoServerURLPath != "" </span><span class="cov0" title="0">{
                logger.Infof("setting %s from storage.docdb.mongo-server-url-path: %s", mongoEnv, cfg.Storage.DocDB.MongoServerURLPath)
                mongoServerURL, err := getMongoServerURLFromPath(cfg.Storage.DocDB.MongoServerURLPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := os.Setenv(mongoEnv, mongoServerURL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">if cfg.Storage.DocDB.MongoServerURLDir != "" </span><span class="cov8" title="1">{
                logger.Infof("setting %s from storage.docdb.mongo-server-url-dir: %s", mongoEnv, cfg.Storage.DocDB.MongoServerURLDir)
                if err := setMongoServerURLFromDir(cfg.Storage.DocDB.MongoServerURLDir); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if cfg.Storage.DocDB.MongoServerURL != "" </span><span class="cov8" title="1">{
                logger.Infof("setting %s from storage.docdb.mongo-server-url", mongoEnv)
                if err := os.Setenv(mongoEnv, cfg.Storage.DocDB.MongoServerURL); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if _, envExists := os.LookupEnv(mongoEnv); !envExists </span><span class="cov8" title="1">{
                return fmt.Errorf("mongo docstore configured but %s environment variable not set, "+
                        "supply one of storage.docdb.mongo-server-url-path, storage.docdb.mongo-server-url-dir, storage.docdb.mongo-server-url or set %s", mongoEnv, mongoEnv)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func setMongoServerURLFromDir(dir string) error <span class="cov8" title="1">{
        fileDataNormalized, err := getMongoServerURLFromDir(dir)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err = os.Setenv(mongoEnv, fileDataNormalized); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func getMongoServerURLFromDir(dir string) (string, error) <span class="cov8" title="1">{
        stat, err := os.Stat(dir)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        // If directory does not exist, then create it. This is needed for
                        // the fsnotify watcher.
                        // fsnotify does not receive events if the path that it's watching
                        // is created later.
                        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return "", nil</span>
                }
                <span class="cov0" title="0">return "", err</span>
        }
        // If the path exists but is not a directory, then throw an error
        <span class="cov8" title="1">if !stat.IsDir() </span><span class="cov8" title="1">{
                return "", fmt.Errorf("path specified at storage.docdb.mongo-server-url-dir: %s is not a directory", dir)
        }</span>

        <span class="cov8" title="1">filePath := filepath.Join(dir, mongoEnv)
        fileData, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        // A trailing newline is fairly common in mounted files, let's remove it.
        <span class="cov8" title="1">fileDataNormalized := strings.TrimSuffix(string(fileData), "\n")

        return fileDataNormalized, nil</span>
}

// getMongoServerURLFromPath retreives token from the given mount path
func getMongoServerURLFromPath(path string) (string, error) <span class="cov0" title="0">{
        fileData, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("reading file in %q: %w", path, err)
        }</span>

        // A trailing newline is fairly common in mounted files, so remove it.
        <span class="cov0" title="0">fileDataNormalized := strings.TrimSuffix(string(fileData), "\n")
        return fileDataNormalized, nil</span>
}

func getPathsToWatch(ctx context.Context, cfg config.Config) []string <span class="cov8" title="1">{
        var pathsToWatch = []string{}
        logger := logging.FromContext(ctx)

        if cfg.Storage.DocDB.MongoServerURLPath != "" </span><span class="cov0" title="0">{
                logger.Infof("setting up fsnotify watcher for mongo server url path: %s", cfg.Storage.DocDB.MongoServerURLPath)
                dirPath := filepath.Dir(cfg.Storage.DocDB.MongoServerURLPath)
                pathsToWatch = []string{
                        // mongo-server-url-path/&lt;path&gt; is where the mongo server url token
                        // When a Kubernetes secret is mounted on a path, the `data` in that secret is mounted
                        // under path/..data that is then `symlink`ed to the key of the data. In this instance,
                        // the mounted path is going to look like:
                        // file 1 - ..2024_05_03_11_23_23.1253599725
                        // file 2 - ..data -&gt; ..2024_05_03_11_23_23.1253599725
                        // file 3 - ..data/&lt;path&gt;
                        // So each time the secret is updated, the file is not updated,
                        // instead the underlying symlink at `..data` is updated and that's what we want to
                        // capture via the fsnotify event watcher
                        // filepath.Join(cfg.Storage.DocDB.MongoServerURLPath, "..data"),
                        filepath.Join(dirPath, "..data"),
                }
                return pathsToWatch
        }</span>

        <span class="cov8" title="1">if cfg.Storage.DocDB.MongoServerURLDir != "" </span><span class="cov0" title="0">{
                logger.Infof("setting up fsnotify watcher for directory: %s", cfg.Storage.DocDB.MongoServerURLDir)
                pathsToWatch = []string{
                        // mongo-server-url-dir/MONGO_SERVER_URL is where the MONGO_SERVER_URL environment
                        // variable is expected to be mounted, either manually or via a Kubernetes secret, etc.
                        filepath.Join(cfg.Storage.DocDB.MongoServerURLDir, "MONGO_SERVER_URL"),
                        // When a Kubernetes secret is mounted on a path, the `data` in that secret is mounted
                        // under path/..data that is then `symlink`ed to the key of the data. In this instance,
                        // the mounted path is going to look like:
                        // file 1 - ..2024_05_03_11_23_23.1253599725
                        // file 2 - ..data -&gt; ..2024_05_03_11_23_23.1253599725
                        // file 3 - MONGO_SERVER_URL -&gt; ..data/MONGO_SERVER_URL
                        // So each time the secret is updated, the file `MONGO_SERVER_URL` is not updated,
                        // instead the underlying symlink at `..data` is updated and that's what we want to
                        // capture via the fsnotify event watcher
                        filepath.Join(cfg.Storage.DocDB.MongoServerURLDir, "..data"),
                }
                return pathsToWatch
        }</span>

        <span class="cov8" title="1">return pathsToWatch</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gcs

import (
        "context"
        "fmt"
        "io"

        "cloud.google.com/go/storage"
        "knative.dev/pkg/logging"

        "github.com/in-toto/in-toto-golang/in_toto"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/chains/signing"
        "github.com/tektoncd/chains/pkg/chains/storage/api"
        "github.com/tektoncd/chains/pkg/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

const (
        StorageBackendGCS = "gcs"
        // taskrun-$namespace-$name/$key.&lt;type&gt;
        SignatureNameFormatTaskRun = "taskrun-%s-%s/%s.signature"
        PayloadNameFormatTaskRun   = "taskrun-%s-%s/%s.payload"
        // pipelinerun-$namespace-$name/$key.&lt;type&gt;
        SignatureNameFormatPipelineRun = "pipelinerun-%s-%s/%s.signature"
        PayloadNameFormatPipelineRun   = "pipelinerun-%s-%s/%s.payload"
)

// Backend is a storage backend that stores signed payloads in the TaskRun metadata as an annotation.
// It is stored as base64 encoded JSON.
// Deprecated: Use TaskRunStorer instead.
type Backend struct {
        writer gcsWriter
        reader gcsReader
        cfg    config.Config
}

// NewStorageBackend returns a new Tekton StorageBackend that stores signatures on a TaskRun
func NewStorageBackend(ctx context.Context, cfg config.Config) (*Backend, error) <span class="cov0" title="0">{
        client, err := storage.NewClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">bucket := cfg.Storage.GCS.Bucket
        return &amp;Backend{
                writer: &amp;writer{client: client, bucket: bucket},
                reader: &amp;reader{client: client, bucket: bucket},
                cfg:    cfg,
        }, nil</span>
}

// StorePayload implements the storage.Backend interface.
func (b *Backend) StorePayload(ctx context.Context, obj objects.TektonObject, rawPayload []byte, signature string, opts config.StorageOpts) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        if tr, isTaskRun := obj.GetObject().(*v1.TaskRun); isTaskRun </span><span class="cov8" title="1">{
                store := &amp;TaskRunStorer{
                        writer: b.writer,
                        key:    opts.ShortKey,
                }
                if _, err := store.Store(ctx, &amp;api.StoreRequest[*v1.TaskRun, *in_toto.Statement]{
                        Object:   obj,
                        Artifact: tr,
                        // We don't actually use payload - we store the raw bundle values directly.
                        Payload: nil,
                        Bundle: &amp;signing.Bundle{
                                Content:   rawPayload,
                                Signature: []byte(signature),
                                Cert:      []byte(opts.Cert),
                                Chain:     []byte(opts.Chain),
                        },
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error writing to GCS: %w", err)
                        return err
                }</span>
        } else<span class="cov8" title="1"> if pr, isPipelineRun := obj.GetObject().(*v1.PipelineRun); isPipelineRun </span><span class="cov8" title="1">{
                store := &amp;PipelineRunStorer{
                        writer: b.writer,
                        key:    opts.ShortKey,
                }
                if _, err := store.Store(ctx, &amp;api.StoreRequest[*v1.PipelineRun, *in_toto.Statement]{ //nolint:staticcheck
                        Object:   obj,
                        Artifact: pr,
                        // We don't actually use payload - we store the raw bundle values directly.
                        Payload: nil,
                        Bundle: &amp;signing.Bundle{
                                Content:   rawPayload,
                                Signature: []byte(signature),
                                Cert:      []byte(opts.Cert),
                                Chain:     []byte(opts.Chain),
                        },
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error writing to GCS: %w", err)
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                return fmt.Errorf("type %T not supported - supported types: [*v1.TaskRun, *v1.PipelineRun]", obj.GetObject())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (b *Backend) Type() string <span class="cov0" title="0">{
        return StorageBackendGCS
}</span>

type gcsWriter interface {
        GetWriter(ctx context.Context, object string) io.WriteCloser
}

type writer struct {
        client *storage.Client
        bucket string
}

type gcsReader interface {
        GetReader(ctx context.Context, object string) (io.ReadCloser, error)
}

type reader struct {
        client *storage.Client
        bucket string
}

func (r *writer) GetWriter(ctx context.Context, object string) io.WriteCloser <span class="cov0" title="0">{
        return r.client.Bucket(r.bucket).Object(object).NewWriter(ctx)
}</span>

func (r *reader) GetReader(ctx context.Context, object string) (io.ReadCloser, error) <span class="cov0" title="0">{
        return r.client.Bucket(r.bucket).Object(object).NewReader(ctx)
}</span>

func (b *Backend) RetrieveSignatures(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string][]string, error) <span class="cov8" title="1">{
        var object string

        switch t := obj.GetObject().(type) </span>{
        case *v1.TaskRun:<span class="cov8" title="1">
                object = taskRunSigNameV1(t, opts)</span>
        case *v1.PipelineRun:<span class="cov8" title="1">
                object = pipelineRunSignameV1(t, opts)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported TektonObject type: %T", t)</span>
        }

        <span class="cov8" title="1">signature, err := b.retrieveObject(ctx, object)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">m := make(map[string][]string)
        m[object] = []string{signature}
        return m, nil</span>
}

func (b *Backend) RetrievePayloads(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string]string, error) <span class="cov8" title="1">{
        var object string

        switch t := obj.GetObject().(type) </span>{
        case *v1.TaskRun:<span class="cov8" title="1">
                object = taskRunPayloadNameV1(t, opts)</span>
        case *v1.PipelineRun:<span class="cov8" title="1">
                object = pipelineRunPayloadNameV1(t, opts)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported TektonObject type: %T", t)</span>
        }

        <span class="cov8" title="1">payload, err := b.retrieveObject(ctx, object)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">m := make(map[string]string)
        m[object] = payload
        return m, nil</span>
}

func (b *Backend) retrieveObject(ctx context.Context, object string) (string, error) <span class="cov8" title="1">{
        reader, err := b.reader.GetReader(ctx, object)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">defer reader.Close()
        payload, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(payload), nil</span>
}

func taskRunSigNameV1(tr *v1.TaskRun, opts config.StorageOpts) string <span class="cov8" title="1">{
        return fmt.Sprintf(SignatureNameFormatTaskRun, tr.Namespace, tr.Name, opts.ShortKey)
}</span>

func taskRunPayloadNameV1(tr *v1.TaskRun, opts config.StorageOpts) string <span class="cov8" title="1">{
        return fmt.Sprintf(PayloadNameFormatTaskRun, tr.Namespace, tr.Name, opts.ShortKey)
}</span>

func pipelineRunSignameV1(pr *v1.PipelineRun, opts config.StorageOpts) string <span class="cov8" title="1">{
        return fmt.Sprintf(SignatureNameFormatPipelineRun, pr.Namespace, pr.Name, opts.ShortKey)
}</span>

func pipelineRunPayloadNameV1(pr *v1.PipelineRun, opts config.StorageOpts) string <span class="cov8" title="1">{
        return fmt.Sprintf(PayloadNameFormatPipelineRun, pr.Namespace, pr.Name, opts.ShortKey)
}</span>

//nolint:staticcheck
var (
        _ api.Storer[*v1.TaskRun, *in_toto.Statement]     = &amp;TaskRunStorer{}
        _ api.Storer[*v1.PipelineRun, *in_toto.Statement] = &amp;PipelineRunStorer{}
)

// TaskRunStorer stores TaskRuns in GCS.
type TaskRunStorer struct {
        writer gcsWriter

        // Optional key to store objects as. If not set, the object UID will be used.
        // The resulting name will look like: $bucket/taskrun-$namespace-$name/$key.signature
        key string
}

// Store stores the TaskRun chains information in GCS
//
//nolint:staticcheck
func (s *TaskRunStorer) Store(ctx context.Context, req *api.StoreRequest[*v1.TaskRun, *in_toto.Statement]) (*api.StoreResponse, error) <span class="cov8" title="1">{
        tr := req.Artifact
        key := s.key
        if key == "" </span><span class="cov0" title="0">{
                key = string(tr.GetUID())
        }</span>
        <span class="cov8" title="1">prefix := fmt.Sprintf("%s-%s-%s/%s", "taskrun", tr.GetNamespace(), tr.GetName(), key)

        return store(ctx, s.writer, prefix,
                req.Bundle.Signature, req.Bundle.Content, req.Bundle.Cert, req.Bundle.Chain)</span>
}

// PipelineRunStorer stores PipelineRuns in GCS.
type PipelineRunStorer struct {
        writer gcsWriter

        // Optional key to store objects as. If not set, the object UID will be used.
        // The resulting name will look like: $bucket/pipelinerun-$namespace-$name/$key.signature
        key string
}

// Store stores the PipelineRun chains information in GCS
//
//nolint:staticcheck
func (s *PipelineRunStorer) Store(ctx context.Context, req *api.StoreRequest[*v1.PipelineRun, *in_toto.Statement]) (*api.StoreResponse, error) <span class="cov8" title="1">{
        pr := req.Artifact
        key := s.key
        if key == "" </span><span class="cov0" title="0">{
                key = string(pr.GetUID())
        }</span>
        <span class="cov8" title="1">prefix := fmt.Sprintf("%s-%s-%s/%s", "pipelinerun", pr.GetNamespace(), pr.GetName(), key)

        return store(ctx, s.writer, prefix,
                req.Bundle.Signature, req.Bundle.Content, req.Bundle.Cert, req.Bundle.Chain)</span>
}

func store(ctx context.Context, writer gcsWriter, prefix string,
        signature, content, cert, chain []byte) (*api.StoreResponse, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // Write signature
        sigName := prefix + ".signature"
        logger.Infof("Storing signature at %s", sigName)
        if _, err := write(ctx, writer, sigName, signature); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Write payload
        <span class="cov8" title="1">payloadName := prefix + ".payload"
        if _, err := write(ctx, writer, payloadName, content); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Only write cert+chain if it is present.
        <span class="cov8" title="1">if cert == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">certName := prefix + ".cert"
        if _, err := write(ctx, writer, certName, cert); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">chainName := prefix + ".chain"
        if _, err := write(ctx, writer, chainName, chain); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;api.StoreResponse{}, nil</span>
}

func write(ctx context.Context, client gcsWriter, name string, content []byte) (int, error) <span class="cov8" title="1">{
        w := client.GetWriter(ctx, name)
        defer w.Close()
        return w.Write(content)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package grafeas

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "strings"

        grafeasutil "github.com/grafeas/grafeas/go/utils/intoto"
        pb "github.com/grafeas/grafeas/proto/v1/grafeas_go_proto"
        intoto "github.com/in-toto/in-toto-golang/in_toto"
        "github.com/pkg/errors"
        "github.com/sigstore/cosign/v2/pkg/types"
        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/chains/formats/slsa/extract"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/credentials"
        "google.golang.org/grpc/credentials/oauth"
        "google.golang.org/grpc/status"
        "knative.dev/pkg/logging"
)

const (
        StorageBackendGrafeas     = "grafeas"
        projectPathFormat         = "projects/%s"
        notePathFormat            = "projects/%s/notes/%s"
        attestationNoteNameFormat = "%s-simplesigning"
        buildNoteNameFormat       = "%s-%s-intoto"
)

// Backend is a storage backend that stores signed payloads in the storage that
// is built on the top of grafeas i.e. container analysis.
type Backend struct {
        client pb.GrafeasClient
        cfg    config.Config
}

// NewStorageBackend returns a new Grafeas StorageBackend that stores signatures in a Grafeas server
func NewStorageBackend(ctx context.Context, cfg config.Config) (*Backend, error) <span class="cov0" title="0">{
        // build connection through grpc
        // implicit uses Application Default Credentials to authenticate.
        // Requires `gcloud auth application-default login` to work locally
        creds, err := oauth.NewApplicationDefault(ctx, "https://www.googleapis.com/auth/cloud-platform")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO: make grafeas server configurable including checking if hostname is trusted
        <span class="cov0" title="0">server := "dns:///containeranalysis.googleapis.com"

        conn, err := grpc.Dial(server,
                grpc.WithTransportCredentials(credentials.NewTLS(&amp;tls.Config{})),
                grpc.WithDefaultCallOptions(grpc.PerRPCCredentials(creds)),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // connection client
        <span class="cov0" title="0">client := pb.NewGrafeasClient(conn)

        // create backend instance
        return &amp;Backend{
                client: client,
                cfg:    cfg,
        }, nil</span>
}

// StorePayload implements the storage.Backend interface.
func (b *Backend) StorePayload(ctx context.Context, obj objects.TektonObject, rawPayload []byte, signature string, opts config.StorageOpts) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        // We only support simplesigning for OCI images, and in-toto for taskrun &amp; pipelinerun.
        if _, ok := formats.IntotoAttestationSet[opts.PayloadFormat]; !ok &amp;&amp; opts.PayloadFormat != formats.PayloadTypeSimpleSigning </span><span class="cov8" title="1">{
                return errors.New("Grafeas storage backend only supports simplesigning and intoto payload format.")
        }</span>

        // Check if projectID is configured. If not, stop and return an error
        <span class="cov8" title="1">if b.cfg.Storage.Grafeas.ProjectID == "" </span><span class="cov0" title="0">{
                return errors.New("Project ID must be configured!")
        }</span>

        // check if noteID is configured. If not, we give it a name as `tekton-&lt;namespace&gt;`
        <span class="cov8" title="1">if b.cfg.Storage.Grafeas.NoteID == "" </span><span class="cov0" title="0">{
                generatedNoteID := fmt.Sprintf("tekton-%s", obj.GetNamespace())
                b.cfg.Storage.Grafeas.NoteID = generatedNoteID
        }</span>

        // step1: create note
        // If the note already exists, just move to the next step of creating occurrence.
        <span class="cov8" title="1">if _, err := b.createNote(ctx, obj, opts); err != nil &amp;&amp; status.Code(err) != codes.AlreadyExists </span><span class="cov0" title="0">{
                return err
        }</span>

        // step2: create occurrences
        <span class="cov8" title="1">occurrences, err := b.createOccurrence(ctx, obj, rawPayload, signature, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">occNames := []string{}
        for _, occ := range occurrences </span><span class="cov8" title="1">{
                occNames = append(occNames, occ.GetName())
        }</span>

        <span class="cov8" title="1">if len(occNames) == 0 </span><span class="cov8" title="1">{
                logger.Infof("No occurrences created for payload of type %s for %s %s/%s", string(opts.PayloadFormat), obj.GetGVK(), obj.GetNamespace(), obj.GetName())
        }</span> else<span class="cov8" title="1"> {
                logger.Infof("Successfully created grafeas occurrences %v for %s %s/%s", occNames, obj.GetGVK(), obj.GetNamespace(), obj.GetName())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Retrieve payloads from grafeas server and store it in a map
func (b *Backend) RetrievePayloads(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string]string, error) <span class="cov8" title="1">{
        // initialize an empty map for result
        result := make(map[string]string)

        // get all occurrences created using this backend
        occurrences, err := b.getAllOccurrences(ctx, obj, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, occ := range occurrences </span><span class="cov8" title="1">{
                // get payload identifier
                name := occ.GetResourceUri()

                // get "Payload" field from the occurrence
                payload := occ.GetEnvelope().GetPayload()

                result[name] = string(payload)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// Retrieve signatures from grafeas server and store it in a map
func (b *Backend) RetrieveSignatures(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string][]string, error) <span class="cov8" title="1">{
        // initialize an empty map for result
        result := make(map[string][]string)

        // get all occurrences created using this backend
        occurrences, err := b.getAllOccurrences(ctx, obj, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, occ := range occurrences </span><span class="cov8" title="1">{
                // get the Signature identifier
                name := occ.GetResourceUri()

                // get "Signatures" field from the occurrence
                signatures := occ.GetEnvelope().GetSignatures()
                // signature string
                sigStrings := []string{}
                for _, sig := range signatures </span><span class="cov8" title="1">{
                        sigStrings = append(sigStrings, string(sig.GetSig()))
                }</span>

                <span class="cov8" title="1">result[name] = sigStrings</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (b *Backend) Type() string <span class="cov0" title="0">{
        return StorageBackendGrafeas
}</span>

// ----------------------------- Helper Functions ----------------------------
// createNote creates grafeas note that will be linked to grafeas occurrences
func (b *Backend) createNote(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (*pb.Note, error) <span class="cov8" title="1">{
        notePrefix := b.cfg.Storage.Grafeas.NoteID

        // for oci image: AttestationNote
        if opts.PayloadFormat == formats.PayloadTypeSimpleSigning </span><span class="cov8" title="1">{
                return b.client.CreateNote(ctx,
                        &amp;pb.CreateNoteRequest{
                                Parent: b.getProjectPath(),
                                NoteId: fmt.Sprintf(attestationNoteNameFormat, b.cfg.Storage.Grafeas.NoteID),
                                Note: &amp;pb.Note{
                                        ShortDescription: "OCI Artifact Attestation Note",
                                        Type: &amp;pb.Note_Attestation{
                                                Attestation: &amp;pb.AttestationNote{
                                                        Hint: &amp;pb.AttestationNote_Hint{
                                                                HumanReadableName: b.cfg.Storage.Grafeas.NoteHint,
                                                        },
                                                },
                                        },
                                },
                        },
                )
        }</span>

        <span class="cov8" title="1">return b.createBuildNote(ctx, fmt.Sprintf(buildNoteNameFormat, notePrefix, obj.GetKindName()), obj)</span>
}

func (b *Backend) createBuildNote(ctx context.Context, noteid string, obj objects.TektonObject) (*pb.Note, error) <span class="cov8" title="1">{
        return b.client.CreateNote(ctx,
                &amp;pb.CreateNoteRequest{
                        Parent: b.getProjectPath(),
                        NoteId: noteid,
                        Note: &amp;pb.Note{
                                ShortDescription: "Build Provenance Note for TaskRun",
                                Type: &amp;pb.Note_Build{
                                        Build: &amp;pb.BuildNote{
                                                BuilderVersion: obj.GetGVK(),
                                        },
                                },
                        },
                },
        )
}</span>

// createOccurrence creates grafeas occurrences in the grafeas server that stores the original payload and its signature
// for a single oci artifact
//   - its simplesigning payload and signature will be stored in ATTESTATION occurrence
//   - the identifier/ResourceUri is IMAGE_URL@IMAGE_DIGEST
//
// for a taskrun/pipelinerun object
//   - its intoto payload and signature will be stored in a BUILD occurrences for each image artifact generated from the taskrun/pipelinerun
//   - each BUILD occurrence will have the same data but differ in the ResourceUri field
//   - the identifier/ResourceUri is IMAGE_URL@IMAGE_DIGEST
func (b *Backend) createOccurrence(ctx context.Context, obj objects.TektonObject, payload []byte, signature string, opts config.StorageOpts) ([]*pb.Occurrence, error) <span class="cov8" title="1">{
        occs := []*pb.Occurrence{}

        // create Occurrence_Attestation for OCI
        if opts.PayloadFormat == formats.PayloadTypeSimpleSigning </span><span class="cov8" title="1">{
                occ, err := b.createAttestationOccurrence(ctx, payload, signature, opts.FullKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">occs = append(occs, occ)
                return occs, nil</span>
        }

        // create Occurrence_Build for TaskRun
        <span class="cov8" title="1">allURIs := b.getAllArtifactURIs(ctx, opts.PayloadFormat, obj)
        for _, uri := range allURIs </span><span class="cov8" title="1">{
                occ, err := b.createBuildOccurrence(ctx, obj, payload, signature, uri)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">occs = append(occs, occ)</span>
        }
        <span class="cov8" title="1">return occs, nil</span>
}

func (b *Backend) getAllArtifactURIs(ctx context.Context, payloadFormat config.PayloadType, obj objects.TektonObject) []string <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        payloader, err := formats.GetPayloader(payloadFormat, b.cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Infof("couldn't get payloader for %v format, will use extract.RetrieveAllArtifactURIs method instead", payloadFormat)
                return extract.RetrieveAllArtifactURIs(ctx, obj, b.cfg.Artifacts.PipelineRuns.DeepInspectionEnabled)
        }</span>

        <span class="cov8" title="1">if uris, err := payloader.RetrieveAllArtifactURIs(ctx, obj); err == nil </span><span class="cov8" title="1">{
                return uris
        }</span>

        <span class="cov8" title="1">logger.Infof("couldn't get URIs from payloader %v, will use extract.RetrieveAllArtifactURIs method instead", payloadFormat)
        return extract.RetrieveAllArtifactURIs(ctx, obj, b.cfg.Artifacts.PipelineRuns.DeepInspectionEnabled)</span>
}

func (b *Backend) createAttestationOccurrence(ctx context.Context, payload []byte, signature string, uri string) (*pb.Occurrence, error) <span class="cov8" title="1">{
        occurrenceDetails := &amp;pb.Occurrence_Attestation{
                Attestation: &amp;pb.AttestationOccurrence{
                        SerializedPayload: payload,
                        Signatures: []*pb.Signature{
                                {
                                        Signature: []byte(signature),
                                        // TODO (#471): currently we only support storing KMS keyID, may add other keys' ids later i.e. k8s secret, fulcio
                                        PublicKeyId: b.cfg.Signers.KMS.KMSRef,
                                },
                        },
                },
        }
        envelope := &amp;pb.Envelope{
                Payload:     payload,
                PayloadType: types.SimpleSigningMediaType,
                Signatures: []*pb.EnvelopeSignature{
                        {
                                Sig: []byte(signature),
                                // TODO (#471): currently we only support storing KMS keyID, may add other keys' ids later i.e. k8s secret, fulcio
                                Keyid: b.cfg.Signers.KMS.KMSRef,
                        },
                },
        }

        return b.client.CreateOccurrence(ctx,
                &amp;pb.CreateOccurrenceRequest{
                        Parent: b.getProjectPath(),
                        Occurrence: &amp;pb.Occurrence{
                                ResourceUri: uri,
                                NoteName:    b.getAttestationNotePath(),
                                Details:     occurrenceDetails,
                                Envelope:    envelope,
                        },
                },
        )
}</span>

func (b *Backend) createBuildOccurrence(ctx context.Context, obj objects.TektonObject, payload []byte, signature string, uri string) (*pb.Occurrence, error) <span class="cov8" title="1">{
        in := intoto.ProvenanceStatement{}
        if err := json.Unmarshal(payload, &amp;in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">pbf, err := grafeasutil.ToProto(&amp;in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Unable to convert to Grafeas proto: %w", err)
        }</span>

        <span class="cov8" title="1">occurrenceDetails := &amp;pb.Occurrence_Build{
                Build: &amp;pb.BuildOccurrence{
                        IntotoStatement: pbf,
                },
        }

        envelope := &amp;pb.Envelope{
                Payload:     payload,
                PayloadType: types.IntotoPayloadType,
                Signatures: []*pb.EnvelopeSignature{
                        {
                                Sig:   []byte(signature),
                                Keyid: b.cfg.Signers.KMS.KMSRef,
                        },
                },
        }

        return b.client.CreateOccurrence(ctx,
                &amp;pb.CreateOccurrenceRequest{
                        Parent: b.getProjectPath(),
                        Occurrence: &amp;pb.Occurrence{
                                ResourceUri: uri,
                                NoteName:    b.getBuildNotePath(obj),
                                Details:     occurrenceDetails,
                                Envelope:    envelope,
                        },
                },
        )</span>
}

func (b *Backend) getProjectPath() string <span class="cov8" title="1">{
        projectID := b.cfg.Storage.Grafeas.ProjectID
        return fmt.Sprintf(projectPathFormat, projectID)
}</span>

func (b *Backend) getAttestationNotePath() string <span class="cov8" title="1">{
        projectID := b.cfg.Storage.Grafeas.ProjectID
        noteID := b.cfg.Storage.Grafeas.NoteID
        return fmt.Sprintf(notePathFormat, projectID, fmt.Sprintf(attestationNoteNameFormat, noteID))
}</span>

func (b *Backend) getBuildNotePath(obj objects.TektonObject) string <span class="cov8" title="1">{
        projectID := b.cfg.Storage.Grafeas.ProjectID
        noteID := b.cfg.Storage.Grafeas.NoteID
        return fmt.Sprintf(notePathFormat, projectID, fmt.Sprintf(buildNoteNameFormat, noteID, obj.GetKindName()))
}</span>

// getAllOccurrences retrieves back all occurrences created for a taskrun
func (b *Backend) getAllOccurrences(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) ([]*pb.Occurrence, error) <span class="cov8" title="1">{
        result := []*pb.Occurrence{}
        // step 1: get all resource URIs created under the taskrun
        uriFilters := b.getAllArtifactURIs(ctx, opts.PayloadFormat, obj)

        // step 2: find all build occurrences
        if _, ok := formats.IntotoAttestationSet[opts.PayloadFormat]; ok </span><span class="cov8" title="1">{
                occs, err := b.findOccurrencesForCriteria(ctx, b.getBuildNotePath(obj), uriFilters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = append(result, occs...)</span>
        }

        // step 3: find all attestation occurrences
        <span class="cov8" title="1">if opts.PayloadFormat == formats.PayloadTypeSimpleSigning </span><span class="cov8" title="1">{
                occs, err := b.findOccurrencesForCriteria(ctx, b.getAttestationNotePath(), uriFilters)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">result = append(result, occs...)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// findOccurrencesForCriteria lookups a project's occurrences by the resource uri
func (b *Backend) findOccurrencesForCriteria(ctx context.Context, noteName string, resourceURIs []string) ([]*pb.Occurrence, error) <span class="cov8" title="1">{

        var uriFilters []string
        for _, url := range resourceURIs </span><span class="cov8" title="1">{
                uriFilters = append(uriFilters, fmt.Sprintf("resourceUrl=%q", url))
        }</span>

        <span class="cov8" title="1">occurences, err := b.client.ListNoteOccurrences(ctx,
                &amp;pb.ListNoteOccurrencesRequest{
                        Name:   noteName,
                        Filter: strings.Join(uriFilters, " OR "),
                },
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return occurences.GetOccurrences(), nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package oci

import (
        "context"

        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/pkg/errors"
        "github.com/sigstore/cosign/v2/pkg/oci/mutate"
        ociremote "github.com/sigstore/cosign/v2/pkg/oci/remote"
        "github.com/sigstore/cosign/v2/pkg/oci/static"
        "github.com/sigstore/cosign/v2/pkg/types"
        "github.com/tektoncd/chains/pkg/chains/storage/api"
        "knative.dev/pkg/logging"
)

var (
        _ api.Storer[name.Digest, *intoto.Statement] = &amp;AttestationStorer{}
)

// AttestationStorer stores in-toto Attestation payloads in OCI registries.
type AttestationStorer struct {
        // repo configures the repo where data should be stored.
        // If empty, the repo is inferred from the Artifact.
        repo *name.Repository
        // remoteOpts are additional remote options (i.e. auth) to use for client operations.
        remoteOpts []remote.Option
}

func NewAttestationStorer(opts ...AttestationStorerOption) (*AttestationStorer, error) <span class="cov8" title="1">{
        s := &amp;AttestationStorer{}
        for _, o := range opts </span><span class="cov8" title="1">{
                if err := o.applyAttestationStorer(s); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return s, nil</span>
}

// Store saves the given statement.
func (s *AttestationStorer) Store(ctx context.Context, req *api.StoreRequest[name.Digest, *intoto.Statement]) (*api.StoreResponse, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        repo := req.Artifact.Repository
        if s.repo != nil </span><span class="cov8" title="1">{
                repo = *s.repo
        }</span>
        <span class="cov8" title="1">se, err := ociremote.SignedEntity(req.Artifact, ociremote.WithRemoteOptions(s.remoteOpts...))
        var entityNotFoundError *ociremote.EntityNotFoundError
        if errors.As(err, &amp;entityNotFoundError) </span><span class="cov8" title="1">{
                se = ociremote.SignedUnknown(req.Artifact)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "getting signed image")
        }</span>

        // Create the new attestation for this entity.
        <span class="cov8" title="1">attOpts := []static.Option{static.WithLayerMediaType(types.DssePayloadType)}
        if req.Bundle.Cert != nil </span><span class="cov8" title="1">{
                attOpts = append(attOpts, static.WithCertChain(req.Bundle.Cert, req.Bundle.Chain))
        }</span>
        <span class="cov8" title="1">att, err := static.NewAttestation(req.Bundle.Signature, attOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">newImage, err := mutate.AttachAttestationToEntity(se, att)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Publish the signatures associated with this entity
        <span class="cov8" title="1">if err := ociremote.WriteAttestations(repo, newImage, ociremote.WithRemoteOptions(s.remoteOpts...)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.Infof("Successfully uploaded attestation for %s", req.Artifact.String())

        return &amp;api.StoreResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package oci

import (
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"

        "github.com/tektoncd/chains/pkg/chains/formats"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/chains/signing"
        "github.com/tektoncd/chains/pkg/chains/storage/api"

        "knative.dev/pkg/logging"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/secure-systems-lab/go-securesystemslib/dsse"

        "github.com/google/go-containerregistry/pkg/authn/k8schain"
        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/pkg/errors"
        "github.com/sigstore/cosign/v2/pkg/oci"
        ociremote "github.com/sigstore/cosign/v2/pkg/oci/remote"
        "github.com/tektoncd/chains/pkg/artifacts"
        "github.com/tektoncd/chains/pkg/chains/formats/simple"
        "github.com/tektoncd/chains/pkg/config"
        "k8s.io/client-go/kubernetes"
)

const StorageBackendOCI = "oci"

// Backend implements a storage backend for OCI artifacts.
// Deprecated: Use SimpleStorer and AttestationStorer instead.
type Backend struct {
        cfg              config.Config
        client           kubernetes.Interface
        getAuthenticator func(ctx context.Context, obj objects.TektonObject, client kubernetes.Interface) (remote.Option, error)
}

// NewStorageBackend returns a new OCI StorageBackend that stores signatures in an OCI registry
func NewStorageBackend(ctx context.Context, client kubernetes.Interface, cfg config.Config) *Backend <span class="cov0" title="0">{
        return &amp;Backend{
                cfg: cfg,

                client: client,
                getAuthenticator: func(ctx context.Context, obj objects.TektonObject, client kubernetes.Interface) (remote.Option, error) </span><span class="cov0" title="0">{
                        kc, err := k8schain.New(ctx, client,
                                k8schain.Options{
                                        Namespace:          obj.GetNamespace(),
                                        ServiceAccountName: obj.GetServiceAccountName(),
                                        UseMountSecrets:    true,
                                })
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrapf(err, "creating new keychain from serviceaccount %s/%s", obj.GetNamespace(), obj.GetServiceAccountName())
                        }</span>
                        <span class="cov0" title="0">return remote.WithAuthFromKeychain(kc), nil</span>
                },
        }
}

// StorePayload implements the storage.Backend interface.
func (b *Backend) StorePayload(ctx context.Context, obj objects.TektonObject, rawPayload []byte, signature string, storageOpts config.StorageOpts) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        auth, err := b.getAuthenticator(ctx, obj, b.client)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "getting oci authenticator")
        }</span>

        <span class="cov8" title="1">logger.Infof("Storing payload on %s/%s/%s", obj.GetGVK(), obj.GetNamespace(), obj.GetName())

        if storageOpts.PayloadFormat == formats.PayloadTypeSimpleSigning </span><span class="cov8" title="1">{
                format := simple.SimpleContainerImage{}
                if err := json.Unmarshal(rawPayload, &amp;format); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "unmarshal simplesigning")
                }</span>
                <span class="cov8" title="1">return b.uploadSignature(ctx, format, rawPayload, signature, storageOpts, auth)</span>
        }

        <span class="cov8" title="1">if _, ok := formats.IntotoAttestationSet[storageOpts.PayloadFormat]; ok </span><span class="cov8" title="1">{
                attestation := intoto.Statement{}
                if err := json.Unmarshal(rawPayload, &amp;attestation); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "unmarshal attestation")
                }</span>

                // This can happen if the Task/TaskRun does not adhere to specific naming conventions
                // like *IMAGE_URL that would serve as hints. This may be intentional for a Task/TaskRun
                // that is not intended to produce an image, e.g. git-clone.
                <span class="cov8" title="1">if len(attestation.Subject) == 0 </span><span class="cov8" title="1">{
                        logger.Infof(
                                "No image subject to attest for %s/%s/%s. Skipping upload to registry", obj.GetGVK(), obj.GetNamespace(), obj.GetName())
                        return nil
                }</span>

                <span class="cov8" title="1">return b.uploadAttestation(ctx, &amp;attestation, signature, storageOpts, auth)</span>
        }

        // Fallback in case unsupported payload format is used or the deprecated "tekton" format
        <span class="cov8" title="1">logger.Info("Skipping upload to OCI registry, OCI storage backend is only supported for OCI images and in-toto attestations")
        return nil</span>
}

func (b *Backend) uploadSignature(ctx context.Context, format simple.SimpleContainerImage, rawPayload []byte, signature string, storageOpts config.StorageOpts, remoteOpts ...remote.Option) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        imageName := format.ImageName()
        logger.Infof("Uploading %s signature", imageName)

        ref, err := name.NewDigest(imageName)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "getting digest")
        }</span>

        <span class="cov8" title="1">repo, err := newRepo(b.cfg, ref)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "getting storage repo for sub %s", imageName)
        }</span>

        <span class="cov8" title="1">store, err := NewSimpleStorerFromConfig(WithTargetRepository(repo))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // TODO: make these creation opts.
        <span class="cov8" title="1">store.remoteOpts = remoteOpts
        if _, err := store.Store(ctx, &amp;api.StoreRequest[name.Digest, simple.SimpleContainerImage]{
                Object:   nil,
                Artifact: ref,
                Payload:  format,
                Bundle: &amp;signing.Bundle{
                        Content:   rawPayload,
                        Signature: []byte(signature),
                        Cert:      []byte(storageOpts.Cert),
                        Chain:     []byte(storageOpts.Chain),
                },
        }); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (b *Backend) uploadAttestation(ctx context.Context, attestation *intoto.Statement, signature string, storageOpts config.StorageOpts, remoteOpts ...remote.Option) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        // upload an attestation for each subject
        logger.Info("Starting to upload attestations to OCI ...")
        for _, subj := range attestation.Subject </span><span class="cov8" title="1">{
                imageName := fmt.Sprintf("%s@sha256:%s", subj.Name, subj.Digest["sha256"])
                logger.Infof("Starting attestation upload to OCI for %s...", imageName)

                ref, err := name.NewDigest(imageName)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "getting digest for subj %s", imageName)
                }</span>

                <span class="cov8" title="1">repo, err := newRepo(b.cfg, ref)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "getting storage repo for sub %s", imageName)
                }</span>

                <span class="cov8" title="1">store, err := NewAttestationStorer(WithTargetRepository(repo))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // TODO: make these creation opts.
                <span class="cov8" title="1">store.remoteOpts = remoteOpts
                if _, err := store.Store(ctx, &amp;api.StoreRequest[name.Digest, *intoto.Statement]{
                        Object:   nil,
                        Artifact: ref,
                        Payload:  attestation,
                        Bundle: &amp;signing.Bundle{
                                Content:   nil,
                                Signature: []byte(signature),
                                Cert:      []byte(storageOpts.Cert),
                                Chain:     []byte(storageOpts.Chain),
                        },
                }); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (b *Backend) Type() string <span class="cov0" title="0">{
        return StorageBackendOCI
}</span>

func (b *Backend) RetrieveSignatures(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string][]string, error) <span class="cov0" title="0">{
        images, err := b.RetrieveArtifact(ctx, obj, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">m := make(map[string][]string)
        for ref, img := range images </span><span class="cov0" title="0">{
                sigImage, err := img.Signatures()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">sigs, err := sigImage.Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">signatures := []string{}
                for _, s := range sigs </span><span class="cov0" title="0">{
                        if sig, err := s.Base64Signature(); err == nil </span><span class="cov0" title="0">{
                                signatures = append(signatures, sig)
                        }</span>
                }
                <span class="cov0" title="0">m[ref] = signatures</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (b *Backend) RetrievePayloads(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string]string, error) <span class="cov0" title="0">{
        var err error
        images, err := b.RetrieveArtifact(ctx, obj, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">m := make(map[string]string)
        var attImage oci.Signatures
        for ref, img := range images </span><span class="cov0" title="0">{
                if opts.PayloadFormat == formats.PayloadTypeSimpleSigning </span><span class="cov0" title="0">{
                        attImage, err = img.Signatures()
                }</span> else<span class="cov0" title="0"> {
                        attImage, err = img.Attestations()
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">atts, err := attImage.Get()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">for _, s := range atts </span><span class="cov0" title="0">{
                        if payload, err := s.Payload(); err == nil </span><span class="cov0" title="0">{
                                envelope := dsse.Envelope{}
                                if err := json.Unmarshal(payload, &amp;envelope); err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("cannot decode the envelope: %s", err)
                                }</span>

                                <span class="cov0" title="0">var decodedPayload []byte
                                decodedPayload, err = base64.StdEncoding.DecodeString(envelope.Payload)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("error decoding the payload: %s", err)
                                }</span>

                                <span class="cov0" title="0">m[ref] = string(decodedPayload)</span>
                        }

                }
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (b *Backend) RetrieveArtifact(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string]oci.SignedImage, error) <span class="cov0" title="0">{
        // Given the TaskRun, retrieve the OCI images.
        images := artifacts.ExtractOCIImagesFromResults(ctx, obj.GetResults())
        m := make(map[string]oci.SignedImage)

        for _, image := range images </span><span class="cov0" title="0">{
                ref, ok := image.(name.Digest)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("error parsing image")
                }</span>
                <span class="cov0" title="0">img, err := ociremote.SignedImage(ref)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">m[ref.DigestStr()] = img</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

func newRepo(cfg config.Config, imageName name.Digest) (name.Repository, error) <span class="cov8" title="1">{
        var opts []name.Option
        if cfg.Storage.OCI.Insecure </span><span class="cov0" title="0">{
                opts = append(opts, name.Insecure)
        }</span>

        <span class="cov8" title="1">if storageOCIRepository := cfg.Storage.OCI.Repository; storageOCIRepository != "" </span><span class="cov8" title="1">{
                return name.NewRepository(storageOCIRepository, opts...)
        }</span>
        <span class="cov8" title="1">return name.NewRepository(imageName.Repository.Name(), opts...)</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package oci

import "github.com/google/go-containerregistry/pkg/name"

// Option provides a config option compatible with all OCI storers.
type Option interface {
        AttestationStorerOption
        SimpleStorerOption
}

// AttestationStorerOption provides a config option compatible with AttestationStorer.
type AttestationStorerOption interface {
        applyAttestationStorer(s *AttestationStorer) error
}

// SimpleStorerOption provides a config option compatible with SimpleStorer.
type SimpleStorerOption interface {
        applySimpleStorer(s *SimpleStorer) error
}

// WithTargetRepository configures the target repository where objects will be stored.
func WithTargetRepository(repo name.Repository) Option <span class="cov8" title="1">{
        return &amp;targetRepoOption{
                repo: repo,
        }
}</span>

type targetRepoOption struct {
        repo name.Repository
}

func (o *targetRepoOption) applyAttestationStorer(s *AttestationStorer) error <span class="cov8" title="1">{
        s.repo = &amp;o.repo
        return nil
}</span>

func (o *targetRepoOption) applySimpleStorer(s *SimpleStorer) error <span class="cov8" title="1">{
        s.repo = &amp;o.repo
        return nil
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2023 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package oci

import (
        "context"
        "encoding/base64"

        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1/remote"
        "github.com/pkg/errors"
        "github.com/sigstore/cosign/v2/pkg/oci/mutate"
        ociremote "github.com/sigstore/cosign/v2/pkg/oci/remote"
        "github.com/sigstore/cosign/v2/pkg/oci/static"
        "github.com/tektoncd/chains/pkg/chains/formats/simple"
        "github.com/tektoncd/chains/pkg/chains/storage/api"
        "knative.dev/pkg/logging"
)

// SimpleStorer stores SimpleSigning payloads in OCI registries.
type SimpleStorer struct {
        // repo configures the repo where data should be stored.
        // If empty, the repo is inferred from the Artifact.
        repo *name.Repository
        // remoteOpts are additional remote options (i.e. auth) to use for client operations.
        remoteOpts []remote.Option
}

var (
        _ api.Storer[name.Digest, simple.SimpleContainerImage] = &amp;SimpleStorer{}
)

func NewSimpleStorerFromConfig(opts ...SimpleStorerOption) (*SimpleStorer, error) <span class="cov8" title="1">{
        s := &amp;SimpleStorer{}
        for _, o := range opts </span><span class="cov8" title="1">{
                if err := o.applySimpleStorer(s); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return s, nil</span>
}

func (s *SimpleStorer) Store(ctx context.Context, req *api.StoreRequest[name.Digest, simple.SimpleContainerImage]) (*api.StoreResponse, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx).With("image", req.Artifact.String())
        logger.Info("Uploading signature")

        se, err := ociremote.SignedEntity(req.Artifact, ociremote.WithRemoteOptions(s.remoteOpts...))
        var entityNotFoundError *ociremote.EntityNotFoundError
        if errors.As(err, &amp;entityNotFoundError) </span><span class="cov8" title="1">{
                se = ociremote.SignedUnknown(req.Artifact)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "getting signed image")
        }</span>

        <span class="cov8" title="1">sigOpts := []static.Option{}
        if req.Bundle.Cert != nil </span><span class="cov8" title="1">{
                sigOpts = append(sigOpts, static.WithCertChain(req.Bundle.Cert, req.Bundle.Chain))
        }</span>
        // Create the new signature for this entity.
        <span class="cov8" title="1">b64sig := base64.StdEncoding.EncodeToString(req.Bundle.Signature)
        sig, err := static.NewSignature(req.Bundle.Content, b64sig, sigOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Attach the signature to the entity.
        <span class="cov8" title="1">newSE, err := mutate.AttachSignatureToEntity(se, sig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">repo := req.Artifact.Repository
        if s.repo != nil </span><span class="cov8" title="1">{
                repo = *s.repo
        }</span>
        // Publish the signatures associated with this entity
        <span class="cov8" title="1">if err := ociremote.WriteSignatures(repo, newSE, ociremote.WithRemoteOptions(s.remoteOpts...)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.Info("Successfully uploaded signature")
        return &amp;api.StoreResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright 2022 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pubsub

import (
        "context"
        "encoding/base64"
        "fmt"

        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/config"
        "gocloud.dev/pubsub/kafkapubsub"
        "knative.dev/pkg/logging"

        "gocloud.dev/pubsub"
        _ "gocloud.dev/pubsub/mempubsub"
)

const (
        StorageBackendPubSub   = "pubsub"
        PubSubProviderInMemory = "inmemory"
        PubSubProviderKafka    = "kafka"
)

// Backend is a storage backend that stores signed payloads in the TaskRun metadata as an annotation.
// It is stored as base64 encoded JSON.
type Backend struct {
        cfg config.Config
}

// NewStorageBackend returns a new Tekton StorageBackend that stores signatures on a TaskRun
func NewStorageBackend(ctx context.Context, cfg config.Config) (*Backend, error) <span class="cov0" title="0">{
        return &amp;Backend{
                cfg: cfg,
        }, nil
}</span>

func (b *Backend) Type() string <span class="cov0" title="0">{
        return StorageBackendPubSub
}</span>

func (b *Backend) StorePayload(ctx context.Context, obj objects.TektonObject, rawPayload []byte, signature string, opts config.StorageOpts) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Infof("Storing payload on Object %s/%s", obj.GetNamespace(), obj.GetName())

        // Construct a *pubsub.Topic.
        topic, err := b.NewTopic(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := topic.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        logger.Error(err)
                }</span>
        }()

        // Send the message with the DSSE signature.
        <span class="cov8" title="1">err = topic.Send(ctx, &amp;pubsub.Message{
                Body: []byte(signature),
                Metadata: map[string]string{
                        "payload":   base64.StdEncoding.EncodeToString(rawPayload),
                        "signature": signature,
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *Backend) RetrievePayloads(ctx context.Context, _ objects.TektonObject, opts config.StorageOpts) (map[string]string, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented for this storage backend: %s", b.Type())
}</span>

func (b *Backend) RetrieveSignatures(ctx context.Context, _ objects.TektonObject, opts config.StorageOpts) (map[string][]string, error) <span class="cov0" title="0">{
        return nil, fmt.Errorf("not implemented for this storage backend: %s", b.Type())
}</span>

func (b *Backend) NewTopic(ctx context.Context) (*pubsub.Topic, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        provider := b.cfg.Storage.PubSub.Provider
        topic := b.cfg.Storage.PubSub.Topic
        logger.Infof("Creating new %q pubsub producer for %q topic", provider, topic)
        switch provider </span>{
        case PubSubProviderKafka:<span class="cov0" title="0">
                // The set of brokers in the Kafka cluster.
                addrs := []string{b.cfg.Storage.PubSub.Kafka.BootstrapServers}
                logger.Infof("Configuring Kafka brokers: %s", addrs)
                // The Kafka client configuration to use.
                config := kafkapubsub.MinimalConfig()
                return kafkapubsub.OpenTopic(addrs, config, topic, nil)</span>
        case PubSubProviderInMemory:<span class="cov8" title="1">
                addr := fmt.Sprintf("mem://%s", b.cfg.Storage.PubSub.Topic)
                logger.Infof("Configuring in-memory producer: %s", addr)
                return pubsub.OpenTopic(context.TODO(), addr)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid provider: %q", provider)</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package storage

import (
        "context"
        "errors"

        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/chains/storage/archivista"
        "github.com/tektoncd/chains/pkg/chains/storage/docdb"
        "github.com/tektoncd/chains/pkg/chains/storage/gcs"
        "github.com/tektoncd/chains/pkg/chains/storage/grafeas"
        "github.com/tektoncd/chains/pkg/chains/storage/oci"
        "github.com/tektoncd/chains/pkg/chains/storage/pubsub"
        "github.com/tektoncd/chains/pkg/chains/storage/tekton"
        "github.com/tektoncd/chains/pkg/config"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "golang.org/x/exp/maps"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/logging"
)

// Backend is an interface to store a chains Payload
type Backend interface {
        StorePayload(ctx context.Context, obj objects.TektonObject, rawPayload []byte, signature string, opts config.StorageOpts) error
        // RetrievePayloads maps [ref]:[payload] for a TaskRun
        RetrievePayloads(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string]string, error)
        // RetrieveSignatures maps [ref]:[list of signatures] for a TaskRun
        RetrieveSignatures(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string][]string, error)
        // Type is the string representation of the backend
        Type() string
}

// InitializeBackends creates and initializes every configured storage backend.
func InitializeBackends(ctx context.Context, ps versioned.Interface, kc kubernetes.Interface, cfg config.Config) (map[string]Backend, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // Add an entry here for every configured backend
        configuredBackends := []string{}
        if cfg.Artifacts.TaskRuns.Enabled() </span><span class="cov8" title="1">{
                configuredBackends = append(configuredBackends, sets.List[string](cfg.Artifacts.TaskRuns.StorageBackend)...)
        }</span>
        <span class="cov8" title="1">if cfg.Artifacts.OCI.Enabled() </span><span class="cov8" title="1">{
                configuredBackends = append(configuredBackends, sets.List[string](cfg.Artifacts.OCI.StorageBackend)...)
        }</span>
        <span class="cov8" title="1">if cfg.Artifacts.PipelineRuns.Enabled() </span><span class="cov8" title="1">{
                configuredBackends = append(configuredBackends, sets.List[string](cfg.Artifacts.PipelineRuns.StorageBackend)...)
        }</span>
        <span class="cov8" title="1">logger.Infof("configured backends from config: %v", configuredBackends)

        // Now only initialize and return the configured ones.
        backends := map[string]Backend{}
        for _, backendType := range configuredBackends </span><span class="cov8" title="1">{
                switch backendType </span>{
                case gcs.StorageBackendGCS:<span class="cov0" title="0">
                        gcsBackend, err := gcs.NewStorageBackend(ctx, cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">backends[backendType] = gcsBackend</span>
                case tekton.StorageBackendTekton:<span class="cov8" title="1">
                        backends[backendType] = tekton.NewStorageBackend(ps)</span>
                case oci.StorageBackendOCI:<span class="cov8" title="1">
                        ociBackend := oci.NewStorageBackend(ctx, kc, cfg)
                        backends[backendType] = ociBackend</span>
                case docdb.StorageTypeDocDB:<span class="cov0" title="0">
                        docdbBackend, err := docdb.NewStorageBackend(ctx, cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">backends[backendType] = docdbBackend</span>
                case grafeas.StorageBackendGrafeas:<span class="cov0" title="0">
                        grafeasBackend, err := grafeas.NewStorageBackend(ctx, cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">backends[backendType] = grafeasBackend</span>
                case pubsub.StorageBackendPubSub:<span class="cov8" title="1">
                        pubsubBackend, err := pubsub.NewStorageBackend(ctx, cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">backends[backendType] = pubsubBackend</span>
                case archivista.StorageBackendArchivista:<span class="cov0" title="0">
                        archivistaBackend, err := archivista.NewStorageBackend(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">backends[backendType] = archivistaBackend</span>
                }
        }

        <span class="cov8" title="1">logger.Infof("successfully initialized backends: %v", maps.Keys(backends))
        return backends, nil</span>
}

// WatchBackends watches backends for any update and keeps them up to date.
func WatchBackends(ctx context.Context, watcherStop chan bool, backends map[string]Backend, cfg config.Config) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        for backend := range backends </span><span class="cov0" title="0">{
                switch backend </span>{
                case docdb.StorageTypeDocDB:<span class="cov0" title="0">
                        docdbWatcherStop := make(chan bool)
                        backendChan, err := docdb.WatchBackend(ctx, cfg, docdbWatcherStop)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, docdb.ErrNothingToWatch) </span><span class="cov0" title="0">{
                                        logger.Info(err)
                                        continue</span>
                                }
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                                for </span><span class="cov0" title="0">{
                                        select </span>{
                                        case newBackend := &lt;-backendChan:<span class="cov0" title="0">
                                                if newBackend == nil </span><span class="cov0" title="0">{
                                                        logger.Errorf("removing backend %s from backends", docdb.StorageTypeDocDB)
                                                        delete(backends, docdb.StorageTypeDocDB)
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">logger.Infof("adding to backends: %s", docdb.StorageTypeDocDB)
                                                backends[docdb.StorageTypeDocDB] = newBackend</span>
                                        case &lt;-watcherStop:<span class="cov0" title="0">
                                                // Stop the DocDB watcher first
                                                select </span>{
                                                case docdbWatcherStop &lt;- true:<span class="cov0" title="0">
                                                        logger.Info("sent close event to docdb.WatchBackend()...")</span>
                                                default:<span class="cov0" title="0">
                                                        logger.Info("could not send close event to docdb.WatchBackend()...")</span>
                                                }

                                                // Now stop this backend
                                                <span class="cov0" title="0">logger.Info("stop watching backends...")
                                                return</span>
                                        }
                                }
                        }()
                default:<span class="cov0" title="0">
                        logger.Debugf("no backends to watch...")</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tekton

import (
        "context"
        "encoding/base64"
        "fmt"
        "strings"

        intoto "github.com/in-toto/attestation/go/v1"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/chains/signing"
        "github.com/tektoncd/chains/pkg/chains/storage/api"
        "github.com/tektoncd/chains/pkg/config"
        "knative.dev/pkg/logging"

        "github.com/tektoncd/chains/pkg/patch"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
)

const (
        // ChainsAnnotationPrefix is the prefix for all Chains annotations
        ChainsAnnotationPrefix    = "chains.tekton.dev/"
        StorageBackendTekton      = "tekton"
        PayloadAnnotationFormat   = "chains.tekton.dev/payload-%s"
        SignatureAnnotationFormat = "chains.tekton.dev/signature-%s"
        CertAnnotationsFormat     = "chains.tekton.dev/cert-%s"
        ChainAnnotationFormat     = "chains.tekton.dev/chain-%s"
)

// Backend is a storage backend that stores signed payloads in the TaskRun metadata as an annotation.
// It is stored as base64 encoded JSON.
// Deprecated: use Storer instead.
type Backend struct {
        pipelineclientset versioned.Interface
}

// NewStorageBackend returns a new Tekton StorageBackend that stores signatures on a TaskRun
func NewStorageBackend(ps versioned.Interface) *Backend <span class="cov0" title="0">{
        return &amp;Backend{
                pipelineclientset: ps,
        }
}</span>

// StorePayload implements the Payloader interface.
func (b *Backend) StorePayload(ctx context.Context, obj objects.TektonObject, rawPayload []byte, signature string, opts config.StorageOpts) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        store := &amp;Storer{
                client: b.pipelineclientset,
                key:    opts.ShortKey,
        }
        if _, err := store.Store(ctx, &amp;api.StoreRequest[objects.TektonObject, *intoto.Statement]{
                Object:   obj,
                Artifact: obj,
                // We don't actually use payload - we store the raw bundle values directly.
                Payload: nil,
                Bundle: &amp;signing.Bundle{
                        Content:   rawPayload,
                        Signature: []byte(signature),
                        Cert:      []byte(opts.Cert),
                        Chain:     []byte(opts.Chain),
                },
        }); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error writing to Tekton object: %w", err)
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (b *Backend) Type() string <span class="cov0" title="0">{
        return StorageBackendTekton
}</span>

// retrieveAnnotationValue retrieve the value of an annotation and base64 decode it if needed.
func (b *Backend) retrieveAnnotationValue(ctx context.Context, obj objects.TektonObject, annotationKey string, decode bool) (string, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Infof("Retrieving annotation %q on %s/%s/%s", annotationKey, obj.GetGVK(), obj.GetNamespace(), obj.GetName())

        var annotationValue string
        annotations, err := obj.GetLatestAnnotations(ctx, b.pipelineclientset)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error retrieving the annotation value for the key %q: %w", annotationKey, err)
        }</span>
        <span class="cov8" title="1">val, ok := annotations[annotationKey]

        // Ensure it exists.
        if ok </span><span class="cov8" title="1">{
                // Decode it if needed.
                if decode </span><span class="cov8" title="1">{
                        decodedAnnotation, err := base64.StdEncoding.DecodeString(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("error decoding the annotation value for the key %q: %w", annotationKey, err)
                        }</span>
                        <span class="cov8" title="1">annotationValue = string(decodedAnnotation)</span>
                } else<span class="cov0" title="0"> {
                        annotationValue = val
                }</span>
        }

        <span class="cov8" title="1">return annotationValue, nil</span>
}

// RetrieveSignatures retrieve the signature stored in the taskrun.
func (b *Backend) RetrieveSignatures(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string][]string, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Infof("Retrieving signature on %s/%s/%s", obj.GetGVK(), obj.GetNamespace(), obj.GetName())
        signatureAnnotation := sigName(opts)
        signature, err := b.retrieveAnnotationValue(ctx, obj, signatureAnnotation, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := make(map[string][]string)
        m[signatureAnnotation] = []string{signature}
        return m, nil</span>
}

// RetrievePayloads retrieve the payload stored in the taskrun.
func (b *Backend) RetrievePayloads(ctx context.Context, obj objects.TektonObject, opts config.StorageOpts) (map[string]string, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Infof("Retrieving payload on %s/%s/%s", obj.GetGVK(), obj.GetNamespace(), obj.GetName())
        payloadAnnotation := payloadName(opts)
        payload, err := b.retrieveAnnotationValue(ctx, obj, payloadAnnotation, true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := make(map[string]string)
        m[payloadAnnotation] = payload
        return m, nil</span>
}

func sigName(opts config.StorageOpts) string <span class="cov8" title="1">{
        return fmt.Sprintf(SignatureAnnotationFormat, opts.ShortKey)
}</span>

func payloadName(opts config.StorageOpts) string <span class="cov8" title="1">{
        return fmt.Sprintf(PayloadAnnotationFormat, opts.ShortKey)
}</span>

type Storer struct {
        client versioned.Interface
        // optional key override. If not specified, the UID of the object is used.
        key string
}

var (
        _ api.Storer[objects.TektonObject, *intoto.Statement] = &amp;Storer{}
)

// Store stores the statement in the TaskRun metadata as an annotation.
func (s *Storer) Store(ctx context.Context, req *api.StoreRequest[objects.TektonObject, *intoto.Statement]) (*api.StoreResponse, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        obj := req.Object
        logger.Infof("Storing payload on %s/%s/%s", obj.GetGVK(), obj.GetNamespace(), obj.GetName())

        // Use patch instead of update to prevent race conditions.
        key := s.key
        if key == "" </span><span class="cov0" title="0">{
                key = string(obj.GetUID())
        }</span>

        // Get current annotations from API server to ensure we have the latest state
        <span class="cov8" title="1">currentAnnotations, err := obj.GetLatestAnnotations(ctx, s.client)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Merge existing annotations with new Chains annotations
        <span class="cov8" title="1">mergedAnnotations := make(map[string]string)
        for k, v := range currentAnnotations </span><span class="cov8" title="1">{
                if strings.HasPrefix(k, ChainsAnnotationPrefix) </span><span class="cov8" title="1">{
                        mergedAnnotations[k] = v
                }</span>
        }

        // Add Chains-specific annotations
        <span class="cov8" title="1">mergedAnnotations[fmt.Sprintf(PayloadAnnotationFormat, key)] = base64.StdEncoding.EncodeToString(req.Bundle.Content)
        mergedAnnotations[fmt.Sprintf(SignatureAnnotationFormat, key)] = base64.StdEncoding.EncodeToString(req.Bundle.Signature)
        mergedAnnotations[fmt.Sprintf(CertAnnotationsFormat, key)] = base64.StdEncoding.EncodeToString(req.Bundle.Cert)
        mergedAnnotations[fmt.Sprintf(ChainAnnotationFormat, key)] = base64.StdEncoding.EncodeToString(req.Bundle.Chain)

        patchBytes, err := patch.GetAnnotationsPatch(mergedAnnotations, obj)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">patchErr := obj.Patch(ctx, s.client, patchBytes)
        if patchErr != nil </span><span class="cov0" title="0">{
                return nil, patchErr
        }</span>

        // Note: Ideally here we'll update the in-memory object to keep it consistent through
        // the reconciliation loop. It hasn't been done to preserve the existing controller behavior
        // and maintain compatibility with existing tests. This could be revisited in the future.

        <span class="cov8" title="1">return &amp;api.StoreResponse{}, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package chains

import (
        "context"
        "strings"

        "github.com/tektoncd/chains/pkg/artifacts"
        "github.com/tektoncd/chains/pkg/chains/objects"
        "github.com/tektoncd/chains/pkg/chains/storage"
        "github.com/tektoncd/chains/pkg/config"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        versioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/logging"
)

type Verifier interface {
        VerifyTaskRun(ctx context.Context, tr *v1.TaskRun) error
}

type TaskRunVerifier struct {
        KubeClient        kubernetes.Interface
        Pipelineclientset versioned.Interface
        SecretPath        string
}

func (tv *TaskRunVerifier) VerifyTaskRun(ctx context.Context, tr *v1.TaskRun) error <span class="cov0" title="0">{
        // Get all the things we might need (storage backends, signers and formatters)
        cfg := *config.FromContext(ctx)
        logger := logging.FromContext(ctx)
        logger.Infof("Verifying signature for TaskRun %s/%s", tr.Namespace, tr.Name)

        // TODO: Hook this up to config.
        enabledSignableTypes := []artifacts.Signable{
                &amp;artifacts.TaskRunArtifact{},
                &amp;artifacts.OCIArtifact{},
        }

        trObj := objects.NewTaskRunObjectV1(tr)

        // Storage
        allBackends, err := storage.InitializeBackends(ctx, tv.Pipelineclientset, tv.KubeClient, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">signers := allSigners(ctx, tv.SecretPath, cfg)

        for _, signableType := range enabledSignableTypes </span><span class="cov0" title="0">{
                if !signableType.Enabled(cfg) </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Verify the signature.
                <span class="cov0" title="0">signerType := signableType.Signer(cfg)
                signer, ok := signers[signerType]
                if !ok </span><span class="cov0" title="0">{
                        logger.Warnf("No signer %s configured for %s", signerType, signableType.Type())
                        continue</span>
                }

                <span class="cov0" title="0">for _, backend := range sets.List[string](signableType.StorageBackend(cfg)) </span><span class="cov0" title="0">{
                        b := allBackends[backend]
                        signatures, err := b.RetrieveSignatures(ctx, trObj, config.StorageOpts{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">payload, err := b.RetrievePayloads(ctx, trObj, config.StorageOpts{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">for image, sigs := range signatures </span><span class="cov0" title="0">{
                                for _, sig := range sigs </span><span class="cov0" title="0">{
                                        if err := signer.VerifySignature(strings.NewReader(sig), strings.NewReader(payload[image])); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/sigstore/sigstore/pkg/tuf"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        cm "knative.dev/pkg/configmap"
)

type Config struct {
        Artifacts       ArtifactConfigs
        Storage         StorageConfigs
        Signers         SignerConfigs
        Builder         BuilderConfig
        Transparency    TransparencyConfig
        BuildDefinition BuildDefinitionConfig
}

// ArtifactConfigs contains the configuration for how to sign/store/format the signatures for each artifact type
type ArtifactConfigs struct {
        OCI          Artifact
        PipelineRuns Artifact
        TaskRuns     Artifact
}

// Artifact contains the configuration for how to sign/store/format the signatures for a single artifact
type Artifact struct {
        Format                string
        StorageBackend        sets.Set[string]
        Signer                string
        DeepInspectionEnabled bool
}

// StorageConfigs contains the configuration to instantiate different storage providers
type StorageConfigs struct {
        GCS        GCSStorageConfig
        OCI        OCIStorageConfig
        Tekton     TektonStorageConfig
        DocDB      DocDBStorageConfig
        Grafeas    GrafeasConfig
        PubSub     PubSubStorageConfig
        Archivista ArchivistaStorageConfig
}

// SignerConfigs contains the configuration to instantiate different signers
type SignerConfigs struct {
        X509 X509Signer
        KMS  KMSSigner
}

type BuilderConfig struct {
        ID string
}

type BuildDefinitionConfig struct {
        BuildType string
}

type X509Signer struct {
        FulcioEnabled     bool
        FulcioAddr        string
        FulcioOIDCIssuer  string
        FulcioProvider    string
        IdentityTokenFile string
        TUFMirrorURL      string
}

type KMSSigner struct {
        KMSRef string
        Auth   KMSAuth
}

// KMSAuth configures authentication to the KMS server
type KMSAuth struct {
        Address   string
        Token     string
        TokenPath string
        OIDC      KMSAuthOIDC
        Spire     KMSAuthSpire
}

// KMSAuthOIDC configures settings to authenticate with OIDC
type KMSAuthOIDC struct {
        Path string
        Role string
}

// KMSAuthSpire configures settings to get an auth token from spire
type KMSAuthSpire struct {
        Sock     string
        Audience string
}

type GCSStorageConfig struct {
        Bucket string
}

type OCIStorageConfig struct {
        Repository string
        Insecure   bool
}

type TektonStorageConfig struct {
}

type DocDBStorageConfig struct {
        URL                string
        MongoServerURL     string
        MongoServerURLDir  string
        MongoServerURLPath string
}

type GrafeasConfig struct {
        // project id that is used to store notes and occurences
        ProjectID string
        // note id used to create a note that an occurrence will be attached to
        NoteID string

        // NoteHint is used to set the attestation note
        NoteHint string
}

type PubSubStorageConfig struct {
        Provider string
        Topic    string
        Kafka    KafkaStorageConfig
}

type KafkaStorageConfig struct {
        BootstrapServers string
}

type TransparencyConfig struct {
        Enabled          bool
        VerifyAnnotation bool
        URL              string
}

// ArchivistaStorageConfig holds configuration for the Archivista storage backend.
type ArchivistaStorageConfig struct {
        // URL is the endpoint for the Archivista service.
        URL string `json:"url"`
}

const (
        taskrunFormatKey  = "artifacts.taskrun.format"
        taskrunStorageKey = "artifacts.taskrun.storage"
        taskrunSignerKey  = "artifacts.taskrun.signer"

        pipelinerunFormatKey               = "artifacts.pipelinerun.format"
        pipelinerunStorageKey              = "artifacts.pipelinerun.storage"
        pipelinerunSignerKey               = "artifacts.pipelinerun.signer"
        pipelinerunEnableDeepInspectionKey = "artifacts.pipelinerun.enable-deep-inspection"

        ociFormatKey  = "artifacts.oci.format"
        ociStorageKey = "artifacts.oci.storage"
        ociSignerKey  = "artifacts.oci.signer"

        gcsBucketKey               = "storage.gcs.bucket"
        ociRepositoryKey           = "storage.oci.repository"
        ociRepositoryInsecureKey   = "storage.oci.repository.insecure"
        docDBUrlKey                = "storage.docdb.url"
        docDBMongoServerURLKey     = "storage.docdb.mongo-server-url"
        docDBMongoServerURLDirKey  = "storage.docdb.mongo-server-url-dir"
        docDBMongoServerURLPathKey = "storage.docdb.mongo-server-url-path"

        archivistaURLKey = "storage.archivista.url"

        grafeasProjectIDKey = "storage.grafeas.projectid"
        grafeasNoteIDKey    = "storage.grafeas.noteid"
        grafeasNoteHint     = "storage.grafeas.notehint"

        // PubSub - General
        pubsubProvider = "storage.pubsub.provider"
        pubsubTopic    = "storage.pubsub.topic"

        // No config for PubSub - In-Memory

        // PubSub - Kafka
        pubsubKafkaBootstrapServer = "storage.pubsub.kafka.bootstrap.servers"

        // KMS
        kmsSignerKMSRef      = "signers.kms.kmsref"
        kmsAuthAddress       = "signers.kms.auth.address"
        kmsAuthToken         = "signers.kms.auth.token"
        kmsAuthOIDCPath      = "signers.kms.auth.oidc.path"
        kmsAuthTokenPath     = "signers.kms.auth.token-path" // #nosec G101
        kmsAuthOIDCRole      = "signers.kms.auth.oidc.role"
        kmsAuthSpireSock     = "signers.kms.auth.spire.sock"
        kmsAuthSpireAudience = "signers.kms.auth.spire.audience"

        // Fulcio
        x509SignerFulcioEnabled     = "signers.x509.fulcio.enabled"
        x509SignerFulcioAddr        = "signers.x509.fulcio.address"
        x509SignerFulcioOIDCIssuer  = "signers.x509.fulcio.issuer"
        x509SignerFulcioProvider    = "signers.x509.fulcio.provider"
        x509SignerIdentityTokenFile = "signers.x509.identity.token.file"
        x509SignerTUFMirrorURL      = "signers.x509.tuf.mirror.url"

        // Builder config
        builderIDKey = "builder.id"

        transparencyEnabledKey = "transparency.enabled"
        transparencyURLKey     = "transparency.url"

        // Build type
        buildTypeKey = "builddefinition.buildtype"

        ChainsConfig = "chains-config"
)

func (artifact *Artifact) Enabled() bool <span class="cov8" title="1">{
        return !(artifact.StorageBackend.Len() == 1 &amp;&amp; artifact.StorageBackend.Has(""))
}</span>

func defaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Artifacts: ArtifactConfigs{
                        TaskRuns: Artifact{
                                Format:         "in-toto",
                                StorageBackend: sets.New[string]("tekton"),
                                Signer:         "x509",
                        },
                        PipelineRuns: Artifact{
                                Format:                "in-toto",
                                StorageBackend:        sets.New[string]("tekton"),
                                Signer:                "x509",
                                DeepInspectionEnabled: false,
                        },
                        OCI: Artifact{
                                Format:         "simplesigning",
                                StorageBackend: sets.New[string]("oci"),
                                Signer:         "x509",
                        },
                },
                Transparency: TransparencyConfig{
                        URL: "https://rekor.sigstore.dev",
                },
                Signers: SignerConfigs{
                        X509: X509Signer{
                                FulcioAddr:       "https://fulcio.sigstore.dev",
                                FulcioOIDCIssuer: "https://oauth2.sigstore.dev/auth",
                                TUFMirrorURL:     tuf.DefaultRemoteRoot,
                        },
                },
                Storage: StorageConfigs{
                        Grafeas: GrafeasConfig{
                                NoteHint: "This attestation note was generated by Tekton Chains",
                        },
                },
                Builder: BuilderConfig{
                        ID: "https://tekton.dev/chains/v2",
                },
                BuildDefinition: BuildDefinitionConfig{
                        BuildType: "https://tekton.dev/chains/v2/slsa",
                },
        }
}</span>

// NewConfigFromMap creates a Config from the supplied map
func NewConfigFromMap(data map[string]string) (*Config, error) <span class="cov8" title="1">{
        cfg := defaultConfig()

        if err := cm.Parse(data,
                // Artifact-specific configs
                // TaskRuns
                asString(taskrunFormatKey, &amp;cfg.Artifacts.TaskRuns.Format, "in-toto", "slsa/v1", "slsa/v2alpha3", "slsa/v2alpha4"),
                asStringSet(taskrunStorageKey, &amp;cfg.Artifacts.TaskRuns.StorageBackend, sets.New[string]("tekton", "oci", "gcs", "docdb", "grafeas", "kafka", "archivista")),
                asString(taskrunSignerKey, &amp;cfg.Artifacts.TaskRuns.Signer, "x509", "kms"),

                // PipelineRuns
                asString(pipelinerunFormatKey, &amp;cfg.Artifacts.PipelineRuns.Format, "in-toto", "slsa/v1", "slsa/v2alpha3", "slsa/v2alpha4"),
                asStringSet(pipelinerunStorageKey, &amp;cfg.Artifacts.PipelineRuns.StorageBackend, sets.New[string]("tekton", "oci", "gcs", "docdb", "grafeas", "archivista")),
                asString(pipelinerunSignerKey, &amp;cfg.Artifacts.PipelineRuns.Signer, "x509", "kms"),
                asBool(pipelinerunEnableDeepInspectionKey, &amp;cfg.Artifacts.PipelineRuns.DeepInspectionEnabled),

                // OCI
                asString(ociFormatKey, &amp;cfg.Artifacts.OCI.Format, "simplesigning"),
                asStringSet(ociStorageKey, &amp;cfg.Artifacts.OCI.StorageBackend, sets.New[string]("tekton", "oci", "gcs", "docdb", "grafeas", "kafka", "archivista")),
                asString(ociSignerKey, &amp;cfg.Artifacts.OCI.Signer, "x509", "kms"),

                // PubSub - General
                asString(pubsubProvider, &amp;cfg.Storage.PubSub.Provider, "inmemory", "kafka"),
                asString(pubsubTopic, &amp;cfg.Storage.PubSub.Topic),

                // PubSub - Kafka
                asString(pubsubKafkaBootstrapServer, &amp;cfg.Storage.PubSub.Kafka.BootstrapServers),

                // Storage level configs
                asString(gcsBucketKey, &amp;cfg.Storage.GCS.Bucket),
                asString(ociRepositoryKey, &amp;cfg.Storage.OCI.Repository),
                asBool(ociRepositoryInsecureKey, &amp;cfg.Storage.OCI.Insecure),
                asString(docDBUrlKey, &amp;cfg.Storage.DocDB.URL),
                asString(docDBMongoServerURLKey, &amp;cfg.Storage.DocDB.MongoServerURL),
                asString(docDBMongoServerURLDirKey, &amp;cfg.Storage.DocDB.MongoServerURLDir),
                asString(docDBMongoServerURLPathKey, &amp;cfg.Storage.DocDB.MongoServerURLPath),

                asString(archivistaURLKey, &amp;cfg.Storage.Archivista.URL),

                asString(grafeasProjectIDKey, &amp;cfg.Storage.Grafeas.ProjectID),
                asString(grafeasNoteIDKey, &amp;cfg.Storage.Grafeas.NoteID),
                asString(grafeasNoteHint, &amp;cfg.Storage.Grafeas.NoteHint),

                oneOf(transparencyEnabledKey, &amp;cfg.Transparency.Enabled, "true", "manual"),
                oneOf(transparencyEnabledKey, &amp;cfg.Transparency.VerifyAnnotation, "manual"),
                asString(transparencyURLKey, &amp;cfg.Transparency.URL),

                asString(kmsSignerKMSRef, &amp;cfg.Signers.KMS.KMSRef),
                asString(kmsAuthAddress, &amp;cfg.Signers.KMS.Auth.Address),
                asString(kmsAuthToken, &amp;cfg.Signers.KMS.Auth.Token),
                asString(kmsAuthTokenPath, &amp;cfg.Signers.KMS.Auth.TokenPath),
                asString(kmsAuthOIDCPath, &amp;cfg.Signers.KMS.Auth.OIDC.Path),
                asString(kmsAuthOIDCRole, &amp;cfg.Signers.KMS.Auth.OIDC.Role),
                asString(kmsAuthSpireSock, &amp;cfg.Signers.KMS.Auth.Spire.Sock),
                asString(kmsAuthSpireAudience, &amp;cfg.Signers.KMS.Auth.Spire.Audience),

                // Fulcio
                asBool(x509SignerFulcioEnabled, &amp;cfg.Signers.X509.FulcioEnabled),
                asString(x509SignerFulcioAddr, &amp;cfg.Signers.X509.FulcioAddr),
                asString(x509SignerFulcioOIDCIssuer, &amp;cfg.Signers.X509.FulcioOIDCIssuer),
                asString(x509SignerFulcioProvider, &amp;cfg.Signers.X509.FulcioProvider),
                asString(x509SignerIdentityTokenFile, &amp;cfg.Signers.X509.IdentityTokenFile),
                asString(x509SignerTUFMirrorURL, &amp;cfg.Signers.X509.TUFMirrorURL),

                // Build config
                asString(builderIDKey, &amp;cfg.Builder.ID),

                // Build type
                asString(buildTypeKey, &amp;cfg.BuildDefinition.BuildType, "https://tekton.dev/chains/v2/slsa", "https://tekton.dev/chains/v2/slsa-tekton"),
        ); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse data: %w", err)
        }</span>

        <span class="cov8" title="1">return cfg, nil</span>
}

// NewConfigFromConfigMap creates a Config from the supplied ConfigMap
func NewConfigFromConfigMap(configMap *corev1.ConfigMap) (*Config, error) <span class="cov8" title="1">{
        return NewConfigFromMap(configMap.Data)
}</span>

// oneOf sets target to true if it maches any of the values
func oneOf(key string, target *bool, values ...string) cm.ParseFunc <span class="cov8" title="1">{
        return func(data map[string]string) error </span><span class="cov8" title="1">{
                raw, ok := data[key]
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if values == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                        if v == raw </span><span class="cov8" title="1">{
                                *target = true
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
}

// allow additional supported values for a "true" decision
// in additional to the usual ones provided by strconv.ParseBool
func asBool(key string, target *bool) cm.ParseFunc <span class="cov8" title="1">{
        return func(data map[string]string) error </span><span class="cov8" title="1">{
                raw, ok := data[key]
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">val, err := strconv.ParseBool(raw)
                if err == nil </span><span class="cov8" title="1">{
                        *target = val
                        return nil
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

// asString passes the value at key through into the target, if it exists.
// TODO(mattmoor): This might be a nice variation on cm.AsString to upstream.
func asString(key string, target *string, values ...string) cm.ParseFunc <span class="cov8" title="1">{
        return func(data map[string]string) error </span><span class="cov8" title="1">{
                raw, ok := data[key]
                if !ok </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if len(values) &gt; 0 </span><span class="cov8" title="1">{
                        vals := sets.New[string](values...)
                        if !vals.Has(raw) </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid value %q wanted one of %v", raw, sets.List[string](vals))
                        }</span>
                }
                <span class="cov8" title="1">*target = raw
                return nil</span>
        }
}

// asStringSet parses the value at key as a sets.Set[string] (split by ',') into the target, if it exists.
func asStringSet(key string, target *sets.Set[string], allowed sets.Set[string]) cm.ParseFunc <span class="cov8" title="1">{
        return func(data map[string]string) error </span><span class="cov8" title="1">{
                if raw, ok := data[key]; ok </span><span class="cov8" title="1">{
                        if raw == "" </span><span class="cov8" title="1">{
                                *target = sets.New[string]("")
                                return nil
                        }</span>
                        <span class="cov8" title="1">splitted := strings.Split(raw, ",")
                        if allowed.Len() &gt; 0 </span><span class="cov8" title="1">{
                                for i, v := range splitted </span><span class="cov8" title="1">{
                                        splitted[i] = strings.TrimSpace(v)
                                        if !allowed.Has(splitted[i]) </span><span class="cov0" title="0">{
                                                return fmt.Errorf("invalid value %q wanted one of %v", splitted[i], sets.List[string](allowed))
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">*target = sets.New[string](splitted...)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"

        "knative.dev/pkg/configmap"
        "knative.dev/pkg/reconciler"
)

type cfgKey struct{}

// ConfigStore is the configuration from a ConfigMap
// +k8s:deepcopy-gen=false
type ConfigStore struct {
        *configmap.UntypedStore
}

var _ reconciler.ConfigStore = (*ConfigStore)(nil)

// FromContext fetch config from context.
func FromContext(ctx context.Context) *Config <span class="cov0" title="0">{
        return ctx.Value(cfgKey{}).(*Config)
}</span>

// ToContext adds config to given context.
func ToContext(ctx context.Context, c *Config) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, cfgKey{}, c)
}</span>

// ToContext adds Store contents to given context.
func (s *ConfigStore) ToContext(ctx context.Context) context.Context <span class="cov0" title="0">{
        return ToContext(ctx, s.Load())
}</span>

// Load fetches config from Store.
func (s *ConfigStore) Load() *Config <span class="cov8" title="1">{
        return s.UntypedLoad(ChainsConfig).(*Config).DeepCopy()
}</span>

// NewConfigStore returns a reconciler.ConfigStore for the chains configuration data.
func NewConfigStore(logger configmap.Logger, onAfterStore ...func(name string, value interface{})) *ConfigStore <span class="cov8" title="1">{
        return &amp;ConfigStore{
                UntypedStore: configmap.NewUntypedStore(
                        "chains",
                        logger,
                        configmap.Constructors{
                                ChainsConfig: NewConfigFromConfigMap,
                        },
                        onAfterStore...,
                ),
        }
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package mocksigner

import (
        "context"

        "github.com/tektoncd/chains/pkg/chains/objects"
)

type Signer struct {
        Signed bool
}

func (m *Signer) Sign(ctx context.Context, obj objects.TektonObject) error <span class="cov0" title="0">{
        m.Signed = true
        return nil
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package objectloader

import (
        "encoding/json"
        "os"

        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
)

func TaskRunV1FromFile(f string) (*v1.TaskRun, error) <span class="cov0" title="0">{
        contents, err := os.ReadFile(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var tr v1.TaskRun
        if err := json.Unmarshal(contents, &amp;tr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;tr, nil</span>
}

func PipelineRunV1FromFile(f string) (*v1.PipelineRun, error) <span class="cov0" title="0">{
        contents, err := os.ReadFile(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var pr v1.PipelineRun
        if err := json.Unmarshal(contents, &amp;pr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pr, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright 2021 The Tekton Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package patch

import (
        "encoding/json"
        "fmt"
        "strings"
)

// TektonObject interface to get GVK information needed for server-side apply
type TektonObject interface {
        GetName() string
        GetNamespace() string
        GetGVK() string // Returns GroupVersionKind as "group/version/kind" string
}

// GetAnnotationsPatch returns patch bytes that can be used with kubectl patch
func GetAnnotationsPatch(newAnnotations map[string]string, obj TektonObject) ([]byte, error) <span class="cov8" title="1">{
        // Get GVK using the TektonObject interface method (more reliable than runtime.Object)
        gvkStr := obj.GetGVK()
        if gvkStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to determine GroupVersionKind for object %s/%s", obj.GetNamespace(), obj.GetName())
        }</span>

        // Parse the string format "group/version/kind"
        <span class="cov8" title="1">parts := strings.Split(gvkStr, "/")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid GVK format: %s", gvkStr)
        }</span>
        <span class="cov8" title="1">apiVersion := parts[0] + "/" + parts[1]
        kind := parts[2]

        // For server-side apply, we need to create a structured patch with metadata
        p := serverSideApplyPatch{
                APIVersion: apiVersion,
                Kind:       kind,
                Metadata: serverSideApplyMetadata{
                        Name:        obj.GetName(),
                        Namespace:   obj.GetNamespace(),
                        Annotations: newAnnotations,
                },
        }
        return json.Marshal(p)</span>
}

// These are used to get proper json formatting for server-side apply
type serverSideApplyPatch struct {
        APIVersion string                  `json:"apiVersion"`
        Kind       string                  `json:"kind"`
        Metadata   serverSideApplyMetadata `json:"metadata"`
}

type serverSideApplyMetadata struct {
        Name        string            `json:"name"`
        Namespace   string            `json:"namespace,omitempty"`
        Annotations map[string]string `json:"annotations,omitempty"`
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package fake

import (
        "context"

        "github.com/tektoncd/chains/pkg/pipelinerunmetrics"
        _ "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun/fake" // Make sure the fake pipelinerun informer is setup
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return pipelinerunmetrics.WithClient(ctx) }</span>)
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerunmetrics

import (
        "context"

        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return WithClient(ctx) }</span>)
}

// RecorderKey is used for associating the Recorder inside the context.Context.
type RecorderKey struct{}

// WithClient adds a metrics recorder to the given context
func WithClient(ctx context.Context) context.Context <span class="cov8" title="1">{
        rec, err := NewRecorder(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Failed to create pipelinerun metrics recorder %v", err)
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, RecorderKey{}, rec)</span>
}

// Get extracts the pipelinerunmetrics.Recorder from the context.
func Get(ctx context.Context) *Recorder <span class="cov8" title="1">{
        untyped := ctx.Value(RecorderKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Unable to fetch *pipelinerunmetrics.Recorder from context.")
        }</span>
        <span class="cov8" title="1">return untyped.(*Recorder)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerunmetrics

import (
        "context"
        "sync"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/metrics"

        common "github.com/tektoncd/chains/pkg/metrics"
)

const (
        pipelineRunSignedName     common.Metric = "pipelinerun_sign_created_total"
        pipelineRunSignedDesc     string        = "Total number of signed messages for pipelineruns"
        pipelineRunUploadedName   common.Metric = "pipelinerun_payload_uploaded_total"
        pipelineRunUploadedDesc   string        = "Total number of uploaded payloads for pipelineruns"
        pipelineRunStoredName     common.Metric = "pipelinerun_payload_stored_total"
        pipelineRunStoredDesc     string        = "Total number of stored payloads for pipelineruns"
        pipelineRunMarkedName     common.Metric = "pipelinerun_marked_signed_total"
        pipelineRunMarkedDesc     string        = "Total number of objects marked as signed for pipelineruns"
        pipelineRunErrorCountName common.Metric = "pipelinerun_signing_failures_total"
        pipelineRunErrorCountDesc string        = "Total number of PipelineRun signing failures"
)

var (
        sgCount = stats.Float64(string(pipelineRunSignedName),
                pipelineRunSignedDesc,
                stats.UnitDimensionless)

        sgCountView *view.View

        plCount = stats.Float64(string(pipelineRunUploadedName),
                pipelineRunUploadedDesc,
                stats.UnitDimensionless)

        plCountView *view.View

        stCount = stats.Float64(string(pipelineRunStoredName),
                pipelineRunStoredDesc,
                stats.UnitDimensionless)

        stCountView *view.View

        mrCount = stats.Float64(string(pipelineRunMarkedName),
                pipelineRunMarkedDesc,
                stats.UnitDimensionless)

        mrCountView *view.View

        pipelineRunErrorCount = stats.Float64(
                string(pipelineRunErrorCountName),
                pipelineRunErrorCountDesc,
                stats.UnitDimensionless,
        )

        pipelineErrorView *view.View

        errorTypeKey, _ = tag.NewKey("error_type")
)

var _ common.Recorder = &amp;Recorder{}

// Recorder holds keys for PipelineRun metrics.
type Recorder struct {
        initialized bool
}

// We cannot register the view multiple times, so NewRecorder lazily
// initializes this singleton and returns the same recorder across any
// subsequent invocations.
var (
        once sync.Once
        r    *Recorder
)

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics.
func NewRecorder(ctx context.Context) (*Recorder, error) <span class="cov8" title="1">{
        var errRegistering error
        logger := logging.FromContext(ctx)
        once.Do(func() </span><span class="cov8" title="1">{
                r = &amp;Recorder{
                        initialized: true,
                }
                errRegistering = viewRegister()
                if errRegistering != nil </span><span class="cov0" title="0">{
                        r.initialized = false
                        logger.Errorf("View Register Failed ", r.initialized)
                        return
                }</span>
        })

        <span class="cov8" title="1">return r, errRegistering</span>
}

func viewRegister() error <span class="cov8" title="1">{
        sgCountView = &amp;view.View{
                Description: sgCount.Description(),
                Measure:     sgCount,
                Aggregation: view.Count(),
        }

        plCountView = &amp;view.View{
                Description: plCount.Description(),
                Measure:     plCount,
                Aggregation: view.Count(),
        }

        stCountView = &amp;view.View{
                Description: stCount.Description(),
                Measure:     stCount,
                Aggregation: view.Count(),
        }

        mrCountView = &amp;view.View{
                Description: mrCount.Description(),
                Measure:     mrCount,
                Aggregation: view.Count(),
        }

        pipelineErrorView = &amp;view.View{
                Description: pipelineRunErrorCount.Description(),
                Measure:     pipelineRunErrorCount,
                TagKeys:     []tag.Key{errorTypeKey},
                Aggregation: view.Count(),
        }

        return view.Register(
                sgCountView,
                plCountView,
                stCountView,
                mrCountView,
                pipelineErrorView,
        )
}</span>

// RecordCountMetrics implements github.com/tektoncd/chains/pkg/metrics.Recorder.RecordCountMetrics
func (r *Recorder) RecordCountMetrics(ctx context.Context, metricType common.Metric) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if !r.initialized </span><span class="cov8" title="1">{
                logger.Errorf("Ignoring the metrics recording as recorder not initialized ")
                return
        }</span>
        <span class="cov8" title="1">switch mt := metricType; mt </span>{
        case common.SignedMessagesCount:<span class="cov8" title="1">
                r.countMetrics(ctx, sgCount)</span>
        case common.PayloadUploadeCount:<span class="cov8" title="1">
                r.countMetrics(ctx, plCount)</span>
        case common.SignsStoredCount:<span class="cov8" title="1">
                r.countMetrics(ctx, stCount)</span>
        case common.MarkedAsSignedCount:<span class="cov8" title="1">
                r.countMetrics(ctx, mrCount)</span>
        default:<span class="cov0" title="0">
                logger.Errorf("Ignoring the metrics recording as valid Metric type matching %v was not found", mt)</span>
        }
}

func (r *Recorder) countMetrics(ctx context.Context, measure *stats.Float64Measure) <span class="cov8" title="1">{
        metrics.Record(ctx, measure.M(1))
}</span>

// RecordErrorMetric records a PipelineRun signing failure with a given error type tag.
func (r *Recorder) RecordErrorMetric(ctx context.Context, errType common.MetricErrorType) <span class="cov8" title="1">{
        // Add the error_type tag to the context.
        ctx, _ = tag.New(ctx, tag.Upsert(errorTypeKey, string(errType)))
        metrics.Record(ctx, pipelineRunErrorCount.M(1))
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright 2024 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package reconciler

import (
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "knative.dev/pkg/controller"
        "slices"
)

// PipelineRunInformerFilterFunc returns a filter function
// for PipelineRuns ensuring PipelineRuns are filtered by list of namespaces membership
func PipelineRunInformerFilterFunc(namespaces []string) func(obj interface{}) bool <span class="cov8" title="1">{
        return func(obj interface{}) bool </span><span class="cov8" title="1">{
                // Namespace filter
                if len(namespaces) == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if pr, ok := obj.(*v1.PipelineRun); ok </span><span class="cov8" title="1">{
                        if slices.Contains(namespaces, pr.Namespace) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
}

// TaskRunInformerFilterFunc returns a filter function
// for TaskRuns ensuring TaskRuns are filtered by list of namespaces membership
func TaskRunInformerFilterFunc(namespaces []string) func(obj interface{}) bool <span class="cov8" title="1">{
        return func(obj interface{}) bool </span><span class="cov8" title="1">{
                // Namespace filter
                if len(namespaces) == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if tr, ok := obj.(*v1.TaskRun); ok </span><span class="cov8" title="1">{
                        if slices.Contains(namespaces, tr.Namespace) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
}

// TaskRunInformerFilterFuncWithOwnership returns a filter function
// for TaskRuns ensuring Ownership by a PipelineRun and filtered by list of namespaces membership and
func TaskRunInformerFilterFuncWithOwnership(namespaces []string) func(obj interface{}) bool <span class="cov8" title="1">{
        return func(obj interface{}) bool </span><span class="cov8" title="1">{
                // Ownership filter
                if !controller.FilterController(&amp;v1.PipelineRun{})(obj) </span><span class="cov8" title="1">{
                        return false
                }</span>
                // Namespace filter
                <span class="cov8" title="1">if len(namespaces) == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if tr, ok := obj.(*v1.TaskRun); ok </span><span class="cov8" title="1">{
                        if slices.Contains(namespaces, tr.Namespace) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
Copyright 2021 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"

        "github.com/tektoncd/chains/pkg/chains"
        "github.com/tektoncd/chains/pkg/chains/storage"
        "github.com/tektoncd/chains/pkg/config"
        "github.com/tektoncd/chains/pkg/pipelinerunmetrics"
        "github.com/tektoncd/chains/pkg/reconciler"
        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipelineruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"

        _ "github.com/tektoncd/chains/pkg/chains/formats/all"
)

// NewNamespacesScopedController returns a new controller implementation where informer is filtered
// given a list of namespaces
func NewNamespacesScopedController(namespaces []string) func(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                pipelineRunInformer := pipelineruninformer.Get(ctx)
                taskRunInformer := taskruninformer.Get(ctx)

                kubeClient := kubeclient.Get(ctx)
                pipelineClient := pipelineclient.Get(ctx)

                psSigner := &amp;chains.ObjectSigner{
                        SecretPath:        SecretPath,
                        Pipelineclientset: pipelineClient,
                        Recorder:          pipelinerunmetrics.Get(ctx),
                }

                c := &amp;Reconciler{
                        PipelineRunSigner: psSigner,
                        Pipelineclientset: pipelineClient,
                        TaskRunLister:     taskRunInformer.Lister(),
                }

                impl := pipelinerunreconciler.NewImpl(ctx, c, func(_ *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        watcherStop := make(chan bool)

                        cfgStore := config.NewConfigStore(logger, func(_ string, value interface{}) </span><span class="cov8" title="1">{
                                select </span>{
                                case watcherStop &lt;- true:<span class="cov0" title="0">
                                        logger.Info("sent close event to WatchBackends()...")</span>
                                default:<span class="cov8" title="1">
                                        logger.Info("could not send close event to WatchBackends()...")</span>
                                }

                                // get updated config
                                <span class="cov8" title="1">cfg := *value.(*config.Config)

                                // get all backends for storing provenance
                                backends, err := storage.InitializeBackends(ctx, pipelineClient, kubeClient, cfg)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err)
                                }</span>
                                <span class="cov8" title="1">psSigner.Backends = backends

                                if err := storage.WatchBackends(ctx, watcherStop, psSigner.Backends, cfg); err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err)
                                }</span>
                        })

                        // setup watches for the config names provided by client
                        <span class="cov8" title="1">cfgStore.WatchConfigs(cmw)

                        return controller.Options{
                                // The chains reconciler shouldn't mutate the pipelinerun's status.
                                SkipStatusUpdates: true,
                                ConfigStore:       cfgStore,
                                FinalizerName:     "chains.tekton.dev/pipelinerun", // TODO: unique name required?
                        }</span>
                })

                <span class="cov8" title="1">c.Tracker = impl.Tracker

                if _, err := pipelineRunInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: reconciler.PipelineRunInformerFilterFunc(namespaces),
                        Handler:    controller.HandleAll(impl.Enqueue),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("adding event handler for pipelinerun controller's pipelinerun informer encountered error: %v", err)
                }</span>

                <span class="cov8" title="1">if _, err := taskRunInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: reconciler.TaskRunInformerFilterFuncWithOwnership(namespaces),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("adding event handler for pipelinerun controller's taskrun informer encountered error: %v", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package pipelinerun

import (
        "context"
        "fmt"

        signing "github.com/tektoncd/chains/pkg/chains"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        listers "github.com/tektoncd/pipeline/pkg/client/listers/pipeline/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
        "knative.dev/pkg/tracker"
)

const (
        // SecretPath contains the path to the secrets volume that is mounted in.
        SecretPath = "/etc/signing-secrets"
)

type Reconciler struct {
        PipelineRunSigner signing.Signer
        Pipelineclientset versioned.Interface
        TaskRunLister     listers.TaskRunLister
        Tracker           tracker.Interface
}

// Check that our Reconciler implements pipelinerunreconciler.Interface and pipelinerunreconciler.Finalizer
var _ pipelinerunreconciler.Interface = (*Reconciler)(nil)
var _ pipelinerunreconciler.Finalizer = (*Reconciler)(nil)

// ReconcileKind  handles a changed or created PipelineRun.
// This is the main entrypoint for chains business logic.
func (r *Reconciler) ReconcileKind(ctx context.Context, pr *v1.PipelineRun) pkgreconciler.Event <span class="cov8" title="1">{
        log := logging.FromContext(ctx).With("pipelinerun", fmt.Sprintf("%s/%s", pr.Namespace, pr.Name))
        return r.FinalizeKind(logging.WithLogger(ctx, log), pr)
}</span>

// FinalizeKind implements pipelinerunreconciler.Finalizer
// We utilize finalizers to ensure that we get a crack at signing every pipelinerun
// that we see flowing through the system.  If we don't add a finalizer, it could
// get cleaned up before we see the final state and sign it.
func (r *Reconciler) FinalizeKind(ctx context.Context, pr *v1.PipelineRun) pkgreconciler.Event <span class="cov8" title="1">{
        // Check to make sure the PipelineRun is finished.
        if !pr.IsDone() </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Infof("pipelinerun is still running")
                return nil
        }</span>
        <span class="cov8" title="1">pro := objects.NewPipelineRunObjectV1(pr)

        // Check to see if it has already been signed.
        if signing.Reconciled(ctx, r.Pipelineclientset, pro) </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Infof("pipelinerun has been reconciled")
                return nil
        }</span>

        // Get TaskRun names depending on whether embeddedstatus feature is set or not
        <span class="cov8" title="1">var trs []string
        for _, cr := range pr.Status.ChildReferences </span><span class="cov8" title="1">{
                trs = append(trs, cr.Name)
        }</span>

        // Signing both taskruns and pipelineruns causes a race condition when using oci storage
        // during the push to the registry. This checks the taskruns to ensure they've been reconciled
        // before attempting to sign the pippelinerun.
        <span class="cov8" title="1">for _, name := range trs </span><span class="cov8" title="1">{
                tr, err := r.TaskRunLister.TaskRuns(pr.Namespace).Get(name)
                if err != nil </span><span class="cov8" title="1">{
                        logging.FromContext(ctx).Errorf("Unable to get reconciled status of taskrun %s within pipelinerun", name)
                        if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                                // Since this is an unrecoverable scenario, returning the error would prevent the
                                // finalizer from being removed, thus preventing the PipelineRun from being deleted.
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">if tr == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Infof("taskrun %s within pipelinerun is not found", name)
                        return nil
                }</span>
                <span class="cov8" title="1">if tr.Status.CompletionTime == nil </span><span class="cov8" title="1">{
                        logging.FromContext(ctx).Infof("taskrun %s within pipelinerun is not yet finalized: status is not complete", name)
                        return r.trackTaskRun(tr, pr)
                }</span>
                <span class="cov8" title="1">reconciled := signing.Reconciled(ctx, r.Pipelineclientset, objects.NewTaskRunObjectV1(tr))
                if !reconciled </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Infof("taskrun %s within pipelinerun is not yet reconciled", name)
                        return r.trackTaskRun(tr, pr)
                }</span>
                <span class="cov8" title="1">pro.AppendTaskRun(tr)</span>
        }

        <span class="cov8" title="1">if err := r.PipelineRunSigner.Sign(ctx, pro); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) trackTaskRun(tr *v1.TaskRun, pr *v1.PipelineRun) error <span class="cov8" title="1">{
        ref := tracker.Reference{
                APIVersion: "tekton.dev/v1",
                Kind:       "TaskRun",
                Namespace:  tr.Namespace,
                Name:       tr.Name,
        }
        return r.Tracker.TrackReference(ref, pr)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright 2021 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"

        "github.com/tektoncd/chains/pkg/chains"
        "github.com/tektoncd/chains/pkg/chains/storage"
        "github.com/tektoncd/chains/pkg/config"
        "github.com/tektoncd/chains/pkg/reconciler"
        "github.com/tektoncd/chains/pkg/taskrunmetrics"
        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"

        _ "github.com/tektoncd/chains/pkg/chains/formats/all"
)

// NewNamespacesScopedController returns a new controller implementation where informer is filtered
// given a list of namespaces
func NewNamespacesScopedController(namespaces []string) func(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                taskRunInformer := taskruninformer.Get(ctx)

                kubeClient := kubeclient.Get(ctx)
                pipelineClient := pipelineclient.Get(ctx)

                tsSigner := &amp;chains.ObjectSigner{
                        SecretPath:        SecretPath,
                        Pipelineclientset: pipelineClient,
                        Recorder:          taskrunmetrics.Get(ctx),
                }

                c := &amp;Reconciler{
                        TaskRunSigner:     tsSigner,
                        Pipelineclientset: pipelineClient,
                }
                impl := taskrunreconciler.NewImpl(ctx, c, func(_ *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        watcherStop := make(chan bool)

                        cfgStore := config.NewConfigStore(logger, func(_ string, value interface{}) </span><span class="cov8" title="1">{
                                select </span>{
                                case watcherStop &lt;- true:<span class="cov0" title="0">
                                        logger.Info("sent close event to WatchBackends()...")</span>
                                default:<span class="cov8" title="1">
                                        logger.Info("could not send close event to WatchBackends()...")</span>
                                }

                                // get updated config
                                <span class="cov8" title="1">cfg := *value.(*config.Config)

                                // get all backends for storing provenance
                                backends, err := storage.InitializeBackends(ctx, pipelineClient, kubeClient, cfg)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err)
                                }</span>
                                <span class="cov8" title="1">tsSigner.Backends = backends

                                if err := storage.WatchBackends(ctx, watcherStop, tsSigner.Backends, cfg); err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err)
                                }</span>
                        })

                        // setup watches for the config names provided by client
                        <span class="cov8" title="1">cfgStore.WatchConfigs(cmw)

                        return controller.Options{
                                // The chains reconciler shouldn't mutate the taskrun's status.
                                SkipStatusUpdates: true,
                                ConfigStore:       cfgStore,
                                FinalizerName:     "chains.tekton.dev/taskrun",
                        }</span>
                })

                <span class="cov8" title="1">if _, err := taskRunInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: reconciler.TaskRunInformerFilterFunc(namespaces),
                        Handler:    controller.HandleAll(impl.Enqueue),
                }); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("adding event handler for taskrun controller's taskrun informer encountered error: %v", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright 2020 The Tekton Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrun

import (
        "context"

        signing "github.com/tektoncd/chains/pkg/chains"
        "github.com/tektoncd/chains/pkg/chains/objects"
        v1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        // SecretPath contains the path to the secrets volume that is mounted in.
        SecretPath = "/etc/signing-secrets"
)

type Reconciler struct {
        TaskRunSigner     signing.Signer
        Pipelineclientset versioned.Interface
}

// Check that our Reconciler implements taskrunreconciler.Interface and taskrunreconciler.Finalizer
var _ taskrunreconciler.Interface = (*Reconciler)(nil)
var _ taskrunreconciler.Finalizer = (*Reconciler)(nil)

// ReconcileKind  handles a changed or created TaskRun.
// This is the main entrypoint for chains business logic.
func (r *Reconciler) ReconcileKind(ctx context.Context, tr *v1.TaskRun) pkgreconciler.Event <span class="cov8" title="1">{
        return r.FinalizeKind(ctx, tr)
}</span>

// 01-Jul-2025; this is a temp solution util we consider the old finalizer name no longer used.
// removeOldFinalizerIfExists removes the old finalizer from the TaskRun if it exists.
func removeOldFinalizerIfExists(tr *v1.TaskRun) <span class="cov8" title="1">{
        const oldFinalizerName = "chains.tekton.dev"
        for i, f := range tr.ObjectMeta.Finalizers </span><span class="cov0" title="0">{
                if f == oldFinalizerName </span><span class="cov0" title="0">{
                        tr.ObjectMeta.Finalizers = append(tr.ObjectMeta.Finalizers[:i], tr.ObjectMeta.Finalizers[i+1:]...)
                        break</span>
                }
        }
}

// FinalizeKind implements taskrunreconciler.Finalizer
// We utilize finalizers to ensure that we get a crack at signing every taskrun
// that we see flowing through the system.  If we don't add a finalizer, it could
// get cleaned up before we see the final state and sign it.
func (r *Reconciler) FinalizeKind(ctx context.Context, tr *v1.TaskRun) pkgreconciler.Event <span class="cov8" title="1">{
        // Check to make sure the TaskRun is finished.
        if !tr.IsDone() </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Infof("taskrun %s/%s is still running", tr.Namespace, tr.Name)
                return nil
        }</span>

        <span class="cov8" title="1">obj := objects.NewTaskRunObjectV1(tr)

        // Check to see if it has already been signed.
        if signing.Reconciled(ctx, r.Pipelineclientset, obj) </span><span class="cov8" title="1">{
                logging.FromContext(ctx).Infof("taskrun %s/%s has been reconciled", tr.Namespace, tr.Name)
                removeOldFinalizerIfExists(tr)
                return nil
        }</span>

        <span class="cov8" title="1">if err := r.TaskRunSigner.Sign(ctx, obj); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">removeOldFinalizerIfExists(tr)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package fake

import (
        "context"

        "github.com/tektoncd/chains/pkg/taskrunmetrics"
        _ "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun/fake" // Make sure the fake taskrun informer is setup
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return taskrunmetrics.WithClient(ctx) }</span>)
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrunmetrics

import (
        "context"

        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return WithClient(ctx) }</span>)
}

// RecorderKey is used for associating the Recorder inside the context.Context.
type RecorderKey struct{}

// WithClient adds a metrics recorder to the given context
func WithClient(ctx context.Context) context.Context <span class="cov8" title="1">{
        rec, err := NewRecorder(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Failed to create taskrun metrics recorder %v", err)
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, RecorderKey{}, rec)</span>
}

// Get extracts the taskrunmetrics.Recorder from the context.
func Get(ctx context.Context) *Recorder <span class="cov8" title="1">{
        untyped := ctx.Value(RecorderKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic("Unable to fetch *taskrunmetrics.Recorder from context.")
        }</span>
        <span class="cov8" title="1">return untyped.(*Recorder)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright 2024 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package taskrunmetrics

import (
        "context"
        "sync"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/metrics"

        common "github.com/tektoncd/chains/pkg/metrics"
)

const (
        taskRunSignedName     common.Metric = "taskrun_sign_created_total"
        taskRunSignedDesc     string        = "Total number of signed messages for taskruns"
        taskRunUploadedName   common.Metric = "taskrun_payload_uploaded_total"
        taskRunUploadedDesc   string        = "Total number of uploaded payloads for taskruns"
        taskRunStoredName     common.Metric = "taskrun_payload_stored_total"
        taskRunStoredDesc     string        = "Total number of stored payloads for taskruns"
        taskRunMarkedName     common.Metric = "taskrun_marked_signed_total"
        taskRunMarkedDesc     string        = "Total number of objects marked as signed for taskruns"
        taskRunErrorCountName common.Metric = "taskrun_signing_failures_total"
        taskRunErrorCountDesc string        = "Total number of TaskRun signing failures"
)

var (
        sgCountView *view.View

        sgCount = stats.Float64(string(taskRunSignedName),
                taskRunSignedDesc,
                stats.UnitDimensionless)

        plCount = stats.Float64(string(taskRunUploadedName),
                taskRunUploadedDesc,
                stats.UnitDimensionless)

        plCountView *view.View

        stCount = stats.Float64(string(taskRunStoredName),
                taskRunStoredDesc,
                stats.UnitDimensionless)

        stCountView *view.View

        mrCount = stats.Float64(string(taskRunMarkedName),
                taskRunMarkedDesc,
                stats.UnitDimensionless)

        mrCountView *view.View

        taskRunErrorCount = stats.Float64(
                string(taskRunErrorCountName),
                taskRunErrorCountDesc,
                stats.UnitDimensionless,
        )

        errorCountView *view.View

        errorTypeKey, _ = tag.NewKey("error_type")
)

var _ common.Recorder = &amp;Recorder{}

// Recorder is used to actually record TaskRun metrics.
type Recorder struct {
        initialized bool
}

// We cannot register the view multiple times, so NewRecorder lazily
// initializes this singleton and returns the same recorder across any
// subsequent invocations.
var (
        once sync.Once
        r    *Recorder
)

// NewRecorder creates a new metrics recorder instance
// to log the TaskRun related metrics.
func NewRecorder(ctx context.Context) (*Recorder, error) <span class="cov8" title="1">{
        var errRegistering error
        logger := logging.FromContext(ctx)
        once.Do(func() </span><span class="cov8" title="1">{
                r = &amp;Recorder{
                        initialized: true,
                }
                errRegistering = viewRegister()
                if errRegistering != nil </span><span class="cov0" title="0">{
                        r.initialized = false
                        logger.Errorf("View Register Failed ", r.initialized)
                        return
                }</span>
        })

        <span class="cov8" title="1">return r, errRegistering</span>
}

func viewRegister() error <span class="cov8" title="1">{

        sgCountView = &amp;view.View{
                Description: sgCount.Description(),
                Measure:     sgCount,
                Aggregation: view.Count(),
        }

        plCountView = &amp;view.View{
                Description: plCount.Description(),
                Measure:     plCount,
                Aggregation: view.Count(),
        }

        stCountView = &amp;view.View{
                Description: stCount.Description(),
                Measure:     stCount,
                Aggregation: view.Count(),
        }

        mrCountView = &amp;view.View{
                Description: mrCount.Description(),
                Measure:     mrCount,
                Aggregation: view.Count(),
        }

        errorCountView = &amp;view.View{
                Description: taskRunErrorCount.Description(),
                Measure:     taskRunErrorCount,
                TagKeys:     []tag.Key{errorTypeKey},
                Aggregation: view.Count(),
        }

        return view.Register(
                sgCountView,
                plCountView,
                stCountView,
                mrCountView,
                errorCountView,
        )
}</span>

// RecordCountMetrics implements github.com/tektoncd/chains/pkg/metrics.Recorder.RecordCountMetrics
func (r *Recorder) RecordCountMetrics(ctx context.Context, metricType common.Metric) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        if !r.initialized </span><span class="cov8" title="1">{
                logger.Errorf("ignoring the metrics recording as recorder not initialized ")
        }</span>
        <span class="cov8" title="1">switch mt := metricType; mt </span>{
        case common.SignedMessagesCount:<span class="cov8" title="1">
                r.countMetrics(ctx, sgCount)</span>
        case common.PayloadUploadeCount:<span class="cov8" title="1">
                r.countMetrics(ctx, plCount)</span>
        case common.SignsStoredCount:<span class="cov8" title="1">
                r.countMetrics(ctx, stCount)</span>
        case common.MarkedAsSignedCount:<span class="cov8" title="1">
                r.countMetrics(ctx, mrCount)</span>
        default:<span class="cov0" title="0">
                logger.Errorf("Ignoring the metrics recording as valid Metric type matching %v was not found", mt)</span>
        }
}

func (r *Recorder) countMetrics(ctx context.Context, measure *stats.Float64Measure) <span class="cov8" title="1">{
        metrics.Record(ctx, measure.M(1))
}</span>

// RecordErrorMetric records a TaskRun signing failure with a given error type tag.
func (r *Recorder) RecordErrorMetric(ctx context.Context, errType common.MetricErrorType) <span class="cov8" title="1">{
        // Add the error_type tag to the context.
        ctx, _ = tag.New(ctx, tag.Upsert(errorTypeKey, string(errType)))
        metrics.Record(ctx, taskRunErrorCount.M(1))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
