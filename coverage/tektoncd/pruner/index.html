
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/pruner/pkg/config/config.go (61.0%)</option>
				
				<option value="file1">github.com/tektoncd/pruner/pkg/config/config_defaults.go (0.0%)</option>
				
				<option value="file2">github.com/tektoncd/pruner/pkg/config/constants.go (0.0%)</option>
				
				<option value="file3">github.com/tektoncd/pruner/pkg/config/helper.go (35.3%)</option>
				
				<option value="file4">github.com/tektoncd/pruner/pkg/config/history_limiter.go (65.2%)</option>
				
				<option value="file5">github.com/tektoncd/pruner/pkg/config/ttl_handler.go (64.1%)</option>
				
				<option value="file6">github.com/tektoncd/pruner/pkg/metrics/metrics.go (93.1%)</option>
				
				<option value="file7">github.com/tektoncd/pruner/pkg/reconciler/namespaceprunerconfig/controller.go (0.0%)</option>
				
				<option value="file8">github.com/tektoncd/pruner/pkg/reconciler/namespaceprunerconfig/reconciler.go (91.7%)</option>
				
				<option value="file9">github.com/tektoncd/pruner/pkg/reconciler/pipelinerun/controller.go (0.0%)</option>
				
				<option value="file10">github.com/tektoncd/pruner/pkg/reconciler/pipelinerun/reconciler.go (73.9%)</option>
				
				<option value="file11">github.com/tektoncd/pruner/pkg/reconciler/taskrun/controller.go (17.1%)</option>
				
				<option value="file12">github.com/tektoncd/pruner/pkg/reconciler/taskrun/reconciler.go (78.8%)</option>
				
				<option value="file13">github.com/tektoncd/pruner/pkg/reconciler/tektonpruner/controller.go (12.8%)</option>
				
				<option value="file14">github.com/tektoncd/pruner/pkg/reconciler/tektonpruner/reconciler.go (0.0%)</option>
				
				<option value="file15">github.com/tektoncd/pruner/pkg/webhook/configmapvalidation.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"
        "fmt"
        "strings"
        "sync"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/yaml"
        "knative.dev/pkg/logging"
)

// following types are for internal use

// PrunerResourceType is a string type used to represent different types of resources that the pruner manages
type PrunerResourceType string

// PrunerFieldType is a string type used to represent different configuration types for pruner
type PrunerFieldType string

// EnforcedConfigLevel is a string type to manage the different override levels allowed for Pruner config
type EnforcedConfigLevel string

const (
        // PrunerResourceTypePipelineRun represents the resource type for a PipelineRun in the pruner.
        PrunerResourceTypePipelineRun PrunerResourceType = "pipelineRun"

        // PrunerResourceTypeTaskRun represents the resource type for a TaskRun in the pruner.
        PrunerResourceTypeTaskRun PrunerResourceType = "taskRun"

        // PrunerFieldTypeTTLSecondsAfterFinished represents the field type for the TTL (Time-to-Live) in seconds after the resource is finished.
        PrunerFieldTypeTTLSecondsAfterFinished PrunerFieldType = "ttlSecondsAfterFinished"

        // PrunerFieldTypeSuccessfulHistoryLimit represents the field type for the successful history limit of a resource.
        PrunerFieldTypeSuccessfulHistoryLimit PrunerFieldType = "successfulHistoryLimit"

        // PrunerFieldTypeFailedHistoryLimit represents the field type for the failed history limit of a resource.
        PrunerFieldTypeFailedHistoryLimit PrunerFieldType = "failedHistoryLimit"

        // EnforcedConfigLevelGlobal represents the cluster-wide config level for pruner.
        EnforcedConfigLevelGlobal EnforcedConfigLevel = "global"

        // EnforcedConfigLevelNamespace represents the namespace config level for pruner.
        EnforcedConfigLevelNamespace EnforcedConfigLevel = "namespace"

        // EnforcedConfigLevelResource represents the resource-level config for pruner.
        EnforcedConfigLevelResource EnforcedConfigLevel = "resource"
)

// ResourceSpec is used to hold the config of a specific resource
// Only used in namespace-level ConfigMaps (tekton-pruner-namespace-spec), NOT in global ConfigMaps
type ResourceSpec struct {
        Name         string         `yaml:"name"`               // Exact name of the parent Pipeline or Task
        Selector     []SelectorSpec `yaml:"selector,omitempty"` // Supports selection based on labels and annotations. If Name is given, Name takes precedence
        PrunerConfig `yaml:",inline"`
}

// SelectorSpec allows specifying selectors for matching resources like PipelineRun or TaskRun
// Only applicable in namespace-level ConfigMaps, NOT in global ConfigMaps
type SelectorSpec struct {
        // Match by labels AND annotations. If both are specified, BOTH must match (AND logic)
        MatchLabels      map[string]string `yaml:"matchLabels,omitempty"`
        MatchAnnotations map[string]string `yaml:"matchAnnotations,omitempty"`
}

// NamespaceSpec is used to hold the pruning config of a specific namespace and its resources
// Used in both global ConfigMap (tekton-pruner-default-spec) and namespace ConfigMap (tekton-pruner-namespace-spec)
// Selector support (PipelineRuns/TaskRuns arrays) ONLY works in namespace ConfigMaps
type NamespaceSpec struct {
        PrunerConfig `yaml:",inline"` // Root-level defaults
        PipelineRuns []ResourceSpec   `yaml:"pipelineRuns"` // Selector-based configs (namespace ConfigMap only)
        TaskRuns     []ResourceSpec   `yaml:"taskRuns"`     // Selector-based configs (namespace ConfigMap only)
}

// GlobalConfig represents the global ConfigMap (tekton-pruner-default-spec)
// Root-level fields are defaults; Namespaces map is for per-namespace defaults
// NOTE: Selector support (PipelineRuns/TaskRuns arrays) is IGNORED in global ConfigMap
type GlobalConfig struct {
        PrunerConfig `yaml:",inline"`         // Global root-level defaults
        Namespaces   map[string]NamespaceSpec `yaml:"namespaces"  json:"namespaces"` // Per-namespace defaults (selectors ignored)
}

// PrunerConfig used to hold the cluster-wide pruning config as well as namespace specific pruning config
type PrunerConfig struct {
        // EnforcedConfigLevel allowed values: global, namespace, resource (default: resource)
        EnforcedConfigLevel     *EnforcedConfigLevel `yaml:"enforcedConfigLevel" json:"enforcedConfigLevel"`
        TTLSecondsAfterFinished *int32               `yaml:"ttlSecondsAfterFinished" json:"ttlSecondsAfterFinished"`
        SuccessfulHistoryLimit  *int32               `yaml:"successfulHistoryLimit" json:"successfulHistoryLimit"`
        FailedHistoryLimit      *int32               `yaml:"failedHistoryLimit" json:"failedHistoryLimit"`
        HistoryLimit            *int32               `yaml:"historyLimit" json:"historyLimit"`
}

// prunerConfigStore defines the store structure to hold config from ConfigMap
type prunerConfigStore struct {
        mutex           sync.RWMutex
        globalConfig    GlobalConfig
        namespaceConfig map[string]NamespaceSpec // namespace -&gt; NamespaceSpec
}

var (
        // PrunerConfigStore is the singleton instance to store pruner config
        PrunerConfigStore = prunerConfigStore{
                mutex:           sync.RWMutex{},
                namespaceConfig: make(map[string]NamespaceSpec),
        }
)

// loads config from configMap (global-config) should be called on startup and if there is a change detected on the ConfigMap
func (ps *prunerConfigStore) LoadGlobalConfig(ctx context.Context, configMap *corev1.ConfigMap) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        // Log the current state of globalConfig and namespacedConfig before updating
        logger.Debugw("Loading global config", "oldGlobalConfig", ps.globalConfig)

        globalConfig := &amp;GlobalConfig{}
        if configMap.Data != nil &amp;&amp; configMap.Data[PrunerGlobalConfigKey] != "" </span><span class="cov8" title="1">{
                err := yaml.Unmarshal([]byte(configMap.Data[PrunerGlobalConfigKey]), globalConfig)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">ps.globalConfig = *globalConfig

        if ps.globalConfig.Namespaces == nil </span><span class="cov8" title="1">{
                ps.globalConfig.Namespaces = map[string]NamespaceSpec{}
        }</span>

        // Log the updated state of globalConfig and namespacedConfig after the update
        <span class="cov8" title="1">logger.Debugw("Updated global config", "newGlobalConfig", ps.globalConfig)

        return nil</span>
}

// LoadNamespaceConfig loads config from namespace-level ConfigMap
func (ps *prunerConfigStore) LoadNamespaceConfig(ctx context.Context, namespace string, configMap *corev1.ConfigMap) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        // Log the current state before updating
        logger.Debugw("Loading namespace config", "namespace", namespace, "oldConfig", ps.namespaceConfig[namespace])

        namespaceSpec := NamespaceSpec{}
        if configMap.Data != nil &amp;&amp; configMap.Data[PrunerNamespaceConfigKey] != "" </span><span class="cov8" title="1">{
                err := yaml.Unmarshal([]byte(configMap.Data[PrunerNamespaceConfigKey]), &amp;namespaceSpec)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">ps.namespaceConfig[namespace] = namespaceSpec

        // Log the updated state after the update
        logger.Debugw("Updated namespace config", "namespace", namespace, "newConfig", ps.namespaceConfig[namespace])

        return nil</span>
}

// DeleteNamespaceConfig removes namespace-level config from the store
func (ps *prunerConfigStore) DeleteNamespaceConfig(ctx context.Context, namespace string) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        ps.mutex.Lock()
        defer ps.mutex.Unlock()

        logger.Debugw("Deleting namespace config", "namespace", namespace)
        delete(ps.namespaceConfig, namespace)
}</span>

// loads config from configMap (global-config) should be called on startup and if there is a change detected on the ConfigMap
func (ps *prunerConfigStore) WorkerCount(ctx context.Context, configMap *corev1.ConfigMap) (count int, err error) <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Log the current state of globalConfig and namespacedConfig before updating
        logger.Debugw("get worker count to concurrently cleanup namesapces", "nsCleanupConcurrentWorkerCount", configMap.Data["WorkerCountForNamespaceCleanup"])

        if configMap.Data != nil &amp;&amp; configMap.Data["WorkerCountForNamespaceCleanup"] != "" </span><span class="cov0" title="0">{
                count, err = GetEnvValueAsInt("WorkerCountForNamespaceCleanup", DefaultWorkerCountForNamespaceCleanup)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
        } else<span class="cov0" title="0"> {
                count = DefaultWorkerCountForNamespaceCleanup
        }</span>
        <span class="cov0" title="0">logger.Debugw("get worker count to concurrently cleanup namesapces", "nsCleanupConcurrentWorkerCount", count)
        return count, nil</span>
}

// getFromPrunerConfigResourceLevelwithSelector retrieves resource-level configuration using selectors
// This function is used ONLY for namespace-level ConfigMaps (tekton-pruner-namespace-spec), NOT global ConfigMaps
// Selector matching logic:
// - If 'name' is provided, it has absolute precedence (returns nil if no match, no fallback)
// - Otherwise, checks selector arrays (PipelineRuns/TaskRuns) for matches
// - When both matchLabels AND matchAnnotations are specified, BOTH must match (AND logic)
func getFromPrunerConfigResourceLevelwithSelector(namespacesSpec map[string]NamespaceSpec, namespace, name string, selector SelectorSpec, resourceType PrunerResourceType, fieldType PrunerFieldType) (*int32, string) <span class="cov8" title="1">{
        prunerResourceSpec, found := namespacesSpec[namespace]
        if !found </span><span class="cov8" title="1">{
                return nil, "identifiedBy_global"
        }</span>

        <span class="cov8" title="1">var resourceSpecs []ResourceSpec

        // Select the right resource specs based on the resource type
        switch resourceType </span>{
        case PrunerResourceTypePipelineRun:<span class="cov8" title="1">
                resourceSpecs = prunerResourceSpec.PipelineRuns</span>
        case PrunerResourceTypeTaskRun:<span class="cov0" title="0">
                resourceSpecs = prunerResourceSpec.TaskRuns</span>
        }

        // First, check if name is provided, and use it to match exactly (absolute precedence)
        <span class="cov8" title="1">if name != "" </span><span class="cov8" title="1">{
                for _, resourceSpec := range resourceSpecs </span><span class="cov8" title="1">{
                        if resourceSpec.Name == name </span><span class="cov8" title="1">{
                                // Return the field value from the matched resourceSpec
                                switch fieldType </span>{
                                case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov8" title="1">
                                        return resourceSpec.TTLSecondsAfterFinished, "identifiedBy_resource_name"</span>
                                case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov0" title="0">
                                        return resourceSpec.SuccessfulHistoryLimit, "identifiedBy_resource_name"</span>
                                case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                                        return resourceSpec.FailedHistoryLimit, "identifiedBy_resource_name"</span>
                                }
                        }
                }
                // Name was specified but no match found - continue to selector matching
        }

        // If name-based matching didn't succeed, proceed with selector matching
        <span class="cov8" title="1">if len(selector.MatchAnnotations) &gt; 0 || len(selector.MatchLabels) &gt; 0 </span><span class="cov8" title="1">{

                for _, resourceSpec := range resourceSpecs </span><span class="cov8" title="1">{
                        // Check if the resourceSpec matches the provided selector by annotations AND labels
                        for _, selectorSpec := range resourceSpec.Selector </span><span class="cov8" title="1">{
                                // Both annotations and labels must match when both are specified (AND logic)
                                // The ConfigMap's selectorSpec defines the required labels/annotations to match
                                // The selector (from the PipelineRun/TaskRun) contains the actual labels/annotations
                                annotationsMatch := true
                                labelsMatch := true

                                // If ConfigMap's selectorSpec has matchAnnotations, check if resource has all of them
                                if len(selectorSpec.MatchAnnotations) &gt; 0 </span><span class="cov8" title="1">{
                                        if len(selector.MatchAnnotations) == 0 </span><span class="cov8" title="1">{
                                                // ConfigMap requires annotations but resource has none - no match
                                                annotationsMatch = false
                                        }</span> else<span class="cov8" title="1"> {
                                                // Check if all ConfigMap's required annotations exist in resource
                                                for key, value := range selectorSpec.MatchAnnotations </span><span class="cov8" title="1">{
                                                        if resourceAnnotationValue, exists := selector.MatchAnnotations[key]; !exists || resourceAnnotationValue != value </span><span class="cov0" title="0">{
                                                                annotationsMatch = false
                                                                break</span>
                                                        }
                                                }
                                        }
                                }

                                // If ConfigMap's selectorSpec has matchLabels, check if resource has all of them
                                <span class="cov8" title="1">if len(selectorSpec.MatchLabels) &gt; 0 </span><span class="cov8" title="1">{
                                        if len(selector.MatchLabels) == 0 </span><span class="cov8" title="1">{
                                                // ConfigMap requires labels but resource has none - no match
                                                labelsMatch = false
                                        }</span> else<span class="cov8" title="1"> {
                                                // Check if all ConfigMap's required labels exist in resource
                                                for key, value := range selectorSpec.MatchLabels </span><span class="cov8" title="1">{
                                                        if resourceLabelValue, exists := selector.MatchLabels[key]; !exists || resourceLabelValue != value </span><span class="cov8" title="1">{
                                                                labelsMatch = false
                                                                break</span>
                                                        }
                                                }
                                        }
                                }

                                // Only return if BOTH match (AND logic)
                                <span class="cov8" title="1">if annotationsMatch &amp;&amp; labelsMatch </span><span class="cov8" title="1">{
                                        // Return the field value if selectors match
                                        switch fieldType </span>{
                                        case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov8" title="1">
                                                return resourceSpec.TTLSecondsAfterFinished, "identifiedBy_resource_selector"</span>
                                        case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov0" title="0">
                                                if resourceSpec.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                                        return resourceSpec.SuccessfulHistoryLimit, "identifiedBy_resource_selector"
                                                }</span> else<span class="cov0" title="0"> {
                                                        return resourceSpec.HistoryLimit, "identifiedBy_resource_selector"
                                                }</span>
                                        case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                                                if resourceSpec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                                        return resourceSpec.FailedHistoryLimit, "identifiedBy_resource_selector"
                                                }</span> else<span class="cov0" title="0"> {
                                                        return resourceSpec.HistoryLimit, "identifiedBy_resource_selector"
                                                }</span>
                                        }
                                }
                        }
                }
        }

        // If no match found, return nil
        <span class="cov8" title="1">return nil, ""</span>
}

// getResourceFieldData retrieves configuration field values based on enforcedConfigLevel
// Design principle: Selector support ONLY for namespace-level ConfigMaps, NOT global ConfigMaps
//
// Lookup hierarchy by enforcedConfigLevel:
//
// 1. EnforcedConfigLevelResource:
//   - Resource-level selector match (from global ConfigMap's Namespaces map)
//   - Namespace root-level (from global ConfigMap's Namespaces map)
//   - Global root-level defaults
//
// 2. EnforcedConfigLevelNamespace:
//   - Resource-level selector match (from namespace ConfigMap - NEW)
//   - Namespace root-level (from namespace ConfigMap)
//   - Namespace root-level (from global ConfigMap's Namespaces map)
//   - Global root-level defaults
//
// 3. EnforcedConfigLevelGlobal:
//   - Global root-level defaults ONLY (no selectors, no namespace lookup)
func getResourceFieldData(globalSpec GlobalConfig, namespaceConfigMap map[string]NamespaceSpec, namespace, name string, selector SelectorSpec, resourceType PrunerResourceType, fieldType PrunerFieldType, enforcedConfigLevel EnforcedConfigLevel) (*int32, string) <span class="cov8" title="1">{
        var fieldData *int32
        var identified_by string

        switch enforcedConfigLevel </span>{
        case EnforcedConfigLevelResource:<span class="cov8" title="1">
                // First try resource level
                fieldData, identified_by = getFromPrunerConfigResourceLevelwithSelector(globalSpec.Namespaces, namespace, name, selector, resourceType, fieldType)
                if fieldData != nil </span><span class="cov0" title="0">{
                        return fieldData, identified_by
                }</span>
                // If no resource level config found, try namespace level
                <span class="cov8" title="1">spec, found := globalSpec.Namespaces[namespace]
                if found </span><span class="cov0" title="0">{
                        switch fieldType </span>{
                        case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov0" title="0">
                                fieldData = spec.TTLSecondsAfterFinished</span>

                        case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov0" title="0">
                                if spec.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = spec.SuccessfulHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = spec.HistoryLimit
                                }</span>

                        case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                                if spec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = spec.FailedHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = spec.HistoryLimit
                                }</span>
                        }
                        <span class="cov0" title="0">identified_by = "identified_by_ns"</span>
                } else<span class="cov8" title="1"> {
                        // If no namespace level config found, try global level
                        switch fieldType </span>{
                        case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov8" title="1">
                                fieldData = globalSpec.TTLSecondsAfterFinished</span>

                        case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov8" title="1">
                                if globalSpec.SuccessfulHistoryLimit != nil </span><span class="cov8" title="1">{
                                        fieldData = globalSpec.SuccessfulHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = globalSpec.HistoryLimit
                                }</span>

                        case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                                if globalSpec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = globalSpec.FailedHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = globalSpec.HistoryLimit
                                }</span>
                        }
                        <span class="cov8" title="1">identified_by = "identified_by_global"</span>
                }
                <span class="cov8" title="1">return fieldData, identified_by</span>
        case EnforcedConfigLevelNamespace:<span class="cov8" title="1">
                // First check namespace-level ConfigMap (tekton-pruner-namespace-spec) for selector matches
                fieldData, identified_by = getFromPrunerConfigResourceLevelwithSelector(namespaceConfigMap, namespace, name, selector, resourceType, fieldType)
                if fieldData != nil </span><span class="cov8" title="1">{
                        return fieldData, identified_by
                }</span>

                // Then check namespace-level ConfigMap root-level fields
                <span class="cov0" title="0">nsSpec, found := namespaceConfigMap[namespace]
                if found </span><span class="cov0" title="0">{
                        switch fieldType </span>{
                        case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov0" title="0">
                                fieldData = nsSpec.TTLSecondsAfterFinished</span>

                        case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov0" title="0">
                                if nsSpec.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = nsSpec.SuccessfulHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = nsSpec.HistoryLimit
                                }</span>

                        case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                                if nsSpec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = nsSpec.FailedHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = nsSpec.HistoryLimit
                                }</span>
                        }
                        <span class="cov0" title="0">if fieldData != nil </span><span class="cov0" title="0">{
                                identified_by = "identified_by_ns_configmap"
                                return fieldData, identified_by
                        }</span>
                }

                // Fall back to global spec, namespace root level
                <span class="cov0" title="0">spec, found := globalSpec.Namespaces[namespace]
                if found </span><span class="cov0" title="0">{
                        switch fieldType </span>{
                        case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov0" title="0">
                                fieldData = spec.TTLSecondsAfterFinished</span>

                        case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov0" title="0">
                                if spec.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = spec.SuccessfulHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = spec.HistoryLimit
                                }</span>

                        case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                                if spec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = spec.FailedHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = spec.HistoryLimit
                                }</span>
                        }
                        <span class="cov0" title="0">identified_by = "identified_by_ns"</span>
                } else<span class="cov0" title="0"> {
                        // If no namespace level config found, try global level
                        switch fieldType </span>{
                        case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov0" title="0">
                                fieldData = globalSpec.TTLSecondsAfterFinished</span>

                        case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov0" title="0">
                                if globalSpec.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = globalSpec.SuccessfulHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = globalSpec.HistoryLimit
                                }</span>

                        case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                                if globalSpec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                        fieldData = globalSpec.FailedHistoryLimit
                                }</span> else<span class="cov0" title="0"> {
                                        fieldData = globalSpec.HistoryLimit
                                }</span>
                        }
                        <span class="cov0" title="0">identified_by = "identified_by_global"</span>
                }
                <span class="cov0" title="0">return fieldData, identified_by</span>

        case EnforcedConfigLevelGlobal:<span class="cov8" title="1">
                // get it from global spec, root level
                switch fieldType </span>{
                case PrunerFieldTypeTTLSecondsAfterFinished:<span class="cov8" title="1">
                        fieldData = globalSpec.TTLSecondsAfterFinished</span>

                case PrunerFieldTypeSuccessfulHistoryLimit:<span class="cov0" title="0">
                        if globalSpec.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                fieldData = globalSpec.SuccessfulHistoryLimit
                        }</span> else<span class="cov0" title="0"> {
                                fieldData = globalSpec.HistoryLimit
                        }</span>

                case PrunerFieldTypeFailedHistoryLimit:<span class="cov0" title="0">
                        if globalSpec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                fieldData = globalSpec.FailedHistoryLimit
                        }</span> else<span class="cov0" title="0"> {
                                fieldData = globalSpec.HistoryLimit
                        }</span>
                }
                <span class="cov8" title="1">identified_by = "identified_by_global"</span>
        }

        <span class="cov8" title="1">return fieldData, identified_by</span>
}

func (ps *prunerConfigStore) GetEnforcedConfigLevelFromNamespaceSpec(namespacesSpec map[string]NamespaceSpec, namespace, name string, selector SelectorSpec, resourceType PrunerResourceType) *EnforcedConfigLevel <span class="cov8" title="1">{
        var enforcedConfigLevel *EnforcedConfigLevel

        namespaceSpec, found := ps.globalConfig.Namespaces[namespace]
        if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Get the appropriate resource specs based on type
        <span class="cov0" title="0">var resourceSpecs []ResourceSpec
        switch resourceType </span>{
        case PrunerResourceTypePipelineRun:<span class="cov0" title="0">
                resourceSpecs = namespaceSpec.PipelineRuns</span>
        case PrunerResourceTypeTaskRun:<span class="cov0" title="0">
                resourceSpecs = namespaceSpec.TaskRuns</span>
        }

        // Try to find resource level config first
        <span class="cov0" title="0">if name != "" &amp;&amp; (len(selector.MatchAnnotations) == 0 &amp;&amp; len(selector.MatchLabels) == 0) </span><span class="cov0" title="0">{
                // Search by exact name
                for _, resourceSpec := range resourceSpecs </span><span class="cov0" title="0">{
                        if resourceSpec.Name == name </span><span class="cov0" title="0">{
                                enforcedConfigLevel = resourceSpec.EnforcedConfigLevel
                                if enforcedConfigLevel != nil </span><span class="cov0" title="0">{
                                        return enforcedConfigLevel
                                }</span>
                                <span class="cov0" title="0">break</span>
                        }
                }
        } else<span class="cov0" title="0"> if len(selector.MatchAnnotations) &gt; 0 || len(selector.MatchLabels) &gt; 0 </span><span class="cov0" title="0">{
                // Search by selectors
                for _, resourceSpec := range resourceSpecs </span><span class="cov0" title="0">{
                        for _, selectorSpec := range resourceSpec.Selector </span><span class="cov0" title="0">{
                                annotationsMatch := true
                                labelsMatch := true

                                // Check if ConfigMap's required annotations exist in the resource
                                if len(selectorSpec.MatchAnnotations) &gt; 0 </span><span class="cov0" title="0">{
                                        if len(selector.MatchAnnotations) == 0 </span><span class="cov0" title="0">{
                                                // ConfigMap requires annotations but resource has none - no match
                                                annotationsMatch = false
                                        }</span> else<span class="cov0" title="0"> {
                                                // Check if all ConfigMap's required annotations exist in resource
                                                for key, value := range selectorSpec.MatchAnnotations </span><span class="cov0" title="0">{
                                                        if resourceAnnotationValue, exists := selector.MatchAnnotations[key]; !exists || resourceAnnotationValue != value </span><span class="cov0" title="0">{
                                                                annotationsMatch = false
                                                                break</span>
                                                        }
                                                }
                                        }
                                }

                                // Check if ConfigMap's required labels exist in the resource
                                <span class="cov0" title="0">if len(selectorSpec.MatchLabels) &gt; 0 </span><span class="cov0" title="0">{
                                        if len(selector.MatchLabels) == 0 </span><span class="cov0" title="0">{
                                                // ConfigMap requires labels but resource has none - no match
                                                labelsMatch = false
                                        }</span> else<span class="cov0" title="0"> {
                                                // Check if all ConfigMap's required labels exist in resource
                                                for key, value := range selectorSpec.MatchLabels </span><span class="cov0" title="0">{
                                                        if resourceLabelValue, exists := selector.MatchLabels[key]; !exists || resourceLabelValue != value </span><span class="cov0" title="0">{
                                                                labelsMatch = false
                                                                break</span>
                                                        }
                                                }
                                        }
                                }

                                // Both annotations and labels must match (AND logic)
                                <span class="cov0" title="0">if annotationsMatch &amp;&amp; labelsMatch </span><span class="cov0" title="0">{
                                        enforcedConfigLevel = resourceSpec.EnforcedConfigLevel
                                        if enforcedConfigLevel != nil </span><span class="cov0" title="0">{
                                                return enforcedConfigLevel
                                        }</span>
                                        <span class="cov0" title="0">break</span>
                                }
                        }
                }
        }

        // If no resource level config found or it was nil, return namespace level
        <span class="cov0" title="0">return namespaceSpec.EnforcedConfigLevel</span>
}

func (ps *prunerConfigStore) getEnforcedConfigLevel(namespace, name string, selector SelectorSpec, resourceType PrunerResourceType) EnforcedConfigLevel <span class="cov8" title="1">{
        var enforcedConfigLevel *EnforcedConfigLevel

        // get it from global spec (order: resource level, namespace root level)
        enforcedConfigLevel = ps.GetEnforcedConfigLevelFromNamespaceSpec(ps.globalConfig.Namespaces, namespace, name, selector, resourceType)
        if enforcedConfigLevel != nil </span><span class="cov0" title="0">{
                return *enforcedConfigLevel
        }</span>

        // get it from global spec, root level
        <span class="cov8" title="1">enforcedConfigLevel = ps.globalConfig.EnforcedConfigLevel
        if enforcedConfigLevel != nil </span><span class="cov0" title="0">{
                return *enforcedConfigLevel
        }</span>

        // default level, if no where specified
        <span class="cov8" title="1">return EnforcedConfigLevelResource</span>
}

func (ps *prunerConfigStore) GetPipelineEnforcedConfigLevel(namespace, name string, selector SelectorSpec) EnforcedConfigLevel <span class="cov8" title="1">{
        return ps.getEnforcedConfigLevel(namespace, name, selector, PrunerResourceTypePipelineRun)
}</span>

func (ps *prunerConfigStore) GetTaskEnforcedConfigLevel(namespace, name string, selector SelectorSpec) EnforcedConfigLevel <span class="cov8" title="1">{
        return ps.getEnforcedConfigLevel(namespace, name, selector, PrunerResourceTypeTaskRun)
}</span>

func (ps *prunerConfigStore) GetPipelineTTLSecondsAfterFinished(namespace, name string, selector SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()
        enforcedConfigLevel := ps.GetPipelineEnforcedConfigLevel(namespace, name, selector)
        return getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypePipelineRun, PrunerFieldTypeTTLSecondsAfterFinished, enforcedConfigLevel)
}</span>

func (ps *prunerConfigStore) GetPipelineSuccessHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()
        enforcedConfigLevel := ps.GetPipelineEnforcedConfigLevel(namespace, name, selector)
        return getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypePipelineRun, PrunerFieldTypeSuccessfulHistoryLimit, enforcedConfigLevel)
}</span>

func (ps *prunerConfigStore) GetPipelineFailedHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) <span class="cov0" title="0">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()
        enforcedConfigLevel := ps.GetPipelineEnforcedConfigLevel(namespace, name, selector)
        return getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypePipelineRun, PrunerFieldTypeFailedHistoryLimit, enforcedConfigLevel)
}</span>

func (ps *prunerConfigStore) GetTaskTTLSecondsAfterFinished(namespace, name string, selector SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()
        enforcedConfigLevel := ps.GetTaskEnforcedConfigLevel(namespace, name, selector)
        return getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypeTaskRun, PrunerFieldTypeTTLSecondsAfterFinished, enforcedConfigLevel)
}</span>

func (ps *prunerConfigStore) GetTaskSuccessHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()
        enforcedConfigLevel := ps.GetTaskEnforcedConfigLevel(namespace, name, selector)
        return getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypeTaskRun, PrunerFieldTypeSuccessfulHistoryLimit, enforcedConfigLevel)
}</span>

func (ps *prunerConfigStore) GetTaskFailedHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) <span class="cov0" title="0">{
        ps.mutex.Lock()
        defer ps.mutex.Unlock()
        enforcedConfigLevel := ps.GetTaskEnforcedConfigLevel(namespace, name, selector)
        return getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypeTaskRun, PrunerFieldTypeFailedHistoryLimit, enforcedConfigLevel)
}</span>

// ValidateGlobalConfig validates a GlobalConfig struct directly without ConfigMap conversion
// This is a convenience function for validating global config and all nested namespace configs
// without the overhead of serialization/deserialization through ConfigMaps.
//
// Use this function when you have a GlobalConfig struct and want to validate it directly,
// for example when validating configuration from operator CRDs or other non-ConfigMap sources.
//
// For ConfigMap-based validation, use ValidateConfigMap or ValidateConfigMapWithGlobal instead.
func ValidateGlobalConfig(globalConfig *GlobalConfig) error <span class="cov8" title="1">{
        if globalConfig == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Validate root-level global config
        <span class="cov8" title="1">if err := validatePrunerConfig(&amp;globalConfig.PrunerConfig, "global-config", nil); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate nested namespace configs
        // These are validated against the global limits
        <span class="cov8" title="1">for ns, nsSpec := range globalConfig.Namespaces </span><span class="cov8" title="1">{
                path := fmt.Sprintf("global-config.namespaces.%s", ns)
                if err := validatePrunerConfig(&amp;nsSpec.PrunerConfig, path, &amp;globalConfig.PrunerConfig); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // CRITICAL: Validate that global ConfigMap namespace sections do NOT contain selectors
                // Selectors are ONLY supported in namespace-level ConfigMaps (tekton-pruner-namespace-spec)
                <span class="cov8" title="1">for i, pr := range nsSpec.PipelineRuns </span><span class="cov8" title="1">{
                        if len(pr.Selector) &gt; 0 </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s.pipelineRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead", path, i)
                        }</span>
                }
                <span class="cov8" title="1">for i, tr := range nsSpec.TaskRuns </span><span class="cov0" title="0">{
                        if len(tr.Selector) &gt; 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s.taskRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead", path, i)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func ValidateConfigMap(cm *corev1.ConfigMap) error <span class="cov8" title="1">{
        return ValidateConfigMapWithGlobal(cm, nil)
}</span>

// ValidateConfigMapWithGlobal validates a ConfigMap with optional global config for limit enforcement
// If globalConfigMap is provided and cm is a namespace-level config, it validates that namespace
// limits do not exceed global limits
func ValidateConfigMapWithGlobal(cm *corev1.ConfigMap, globalConfigMap *corev1.ConfigMap) error <span class="cov8" title="1">{
        if cm.Data == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Parse global config if validating a global ConfigMap
        <span class="cov8" title="1">var globalLimits *PrunerConfig
        if cm.Data[PrunerGlobalConfigKey] != "" </span><span class="cov8" title="1">{
                globalConfig := &amp;GlobalConfig{}
                if err := yaml.Unmarshal([]byte(cm.Data[PrunerGlobalConfigKey]), globalConfig); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to parse global-config: %w", err)
                }</span>
                <span class="cov8" title="1">if err := validatePrunerConfig(&amp;globalConfig.PrunerConfig, "global-config", nil); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // Validate nested namespace configs within global config
                // These are validated against the global limits
                <span class="cov8" title="1">for ns, nsSpec := range globalConfig.Namespaces </span><span class="cov8" title="1">{
                        if err := validatePrunerConfig(&amp;nsSpec.PrunerConfig, "global-config.namespaces."+ns, &amp;globalConfig.PrunerConfig); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        // CRITICAL: Validate that global ConfigMap namespace sections do NOT contain selectors
                        // Selectors are ONLY supported in namespace-level ConfigMaps (tekton-pruner-namespace-spec)
                        <span class="cov8" title="1">for i, pr := range nsSpec.PipelineRuns </span><span class="cov8" title="1">{
                                if len(pr.Selector) &gt; 0 </span><span class="cov8" title="1">{
                                        return fmt.Errorf("global-config.namespaces.%s.pipelineRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead", ns, i)
                                }</span>
                        }
                        <span class="cov8" title="1">for i, tr := range nsSpec.TaskRuns </span><span class="cov8" title="1">{
                                if len(tr.Selector) &gt; 0 </span><span class="cov8" title="1">{
                                        return fmt.Errorf("global-config.namespaces.%s.taskRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead", ns, i)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        }

        // Parse and validate namespace config against global limits
        <span class="cov8" title="1">if cm.Data[PrunerNamespaceConfigKey] != "" </span><span class="cov8" title="1">{
                namespaceConfig := &amp;NamespaceSpec{}
                if err := yaml.Unmarshal([]byte(cm.Data[PrunerNamespaceConfigKey]), namespaceConfig); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to parse ns-config: %w", err)
                }</span>

                // Extract global limits if global config is provided
                <span class="cov8" title="1">if globalConfigMap != nil &amp;&amp; globalConfigMap.Data != nil &amp;&amp; globalConfigMap.Data[PrunerGlobalConfigKey] != "" </span><span class="cov8" title="1">{
                        globalConfig := &amp;GlobalConfig{}
                        if err := yaml.Unmarshal([]byte(globalConfigMap.Data[PrunerGlobalConfigKey]), globalConfig); err != nil </span><span class="cov8" title="1">{
                                // If we can't parse global config, just do basic validation
                                return validatePrunerConfig(&amp;namespaceConfig.PrunerConfig, "ns-config", nil)
                        }</span>
                        <span class="cov8" title="1">globalLimits = &amp;globalConfig.PrunerConfig</span>
                }

                // Validate namespace config, enforcing global limits if available
                <span class="cov8" title="1">if err := validatePrunerConfig(&amp;namespaceConfig.PrunerConfig, "ns-config", globalLimits); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Validate selector-based limits (sum of selectors must not exceed namespace/global limits)
                // Extract namespace name from ConfigMap metadata
                <span class="cov8" title="1">namespace := cm.Namespace
                var globalNamespaceSpec *NamespaceSpec
                if globalConfigMap != nil &amp;&amp; globalConfigMap.Data != nil &amp;&amp; globalConfigMap.Data[PrunerGlobalConfigKey] != "" </span><span class="cov8" title="1">{
                        globalConfig := &amp;GlobalConfig{}
                        if err := yaml.Unmarshal([]byte(globalConfigMap.Data[PrunerGlobalConfigKey]), globalConfig); err == nil </span><span class="cov8" title="1">{
                                if nsSpec, exists := globalConfig.Namespaces[namespace]; exists </span><span class="cov0" title="0">{
                                        globalNamespaceSpec = &amp;nsSpec
                                }</span>
                                // Pass both globalConfig and globalNamespaceSpec for 4-tier hierarchy
                                <span class="cov8" title="1">if err := validateSelectorLimits(namespaceConfig, &amp;globalConfig.PrunerConfig, globalNamespaceSpec, namespace); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        // No global config, validate with system maximum only
                        if err := validateSelectorLimits(namespaceConfig, nil, nil, namespace); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// ValidateNamespaceSpec validates a NamespaceSpec struct directly without ConfigMap conversion
// This function validates namespace-level configuration against optional global limits.
//
// Parameters:
//   - namespaceSpec: The namespace configuration to validate
//   - namespace: The namespace name (used for error messages)
//   - globalConfig: Optional global config for limit enforcement (can be nil)
//
// Use this function when you have a NamespaceSpec struct and want to validate it directly,
// for example when validating configuration from operator CRDs or other non-ConfigMap sources.
//
// For ConfigMap-based validation, use ValidateConfigMapWithGlobal instead.
func ValidateNamespaceSpec(namespaceSpec *NamespaceSpec, namespace string, globalConfig *GlobalConfig) error <span class="cov8" title="1">{
        if namespaceSpec == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var globalLimits *PrunerConfig
        var globalNamespaceSpec *NamespaceSpec

        // Extract global limits if provided
        if globalConfig != nil </span><span class="cov8" title="1">{
                globalLimits = &amp;globalConfig.PrunerConfig
                // Check if there's a namespace-specific override in global config
                if nsSpec, exists := globalConfig.Namespaces[namespace]; exists </span><span class="cov0" title="0">{
                        globalNamespaceSpec = &amp;nsSpec
                }</span>
        }

        // Validate namespace config, enforcing global limits if available
        <span class="cov8" title="1">if err := validatePrunerConfig(&amp;namespaceSpec.PrunerConfig, "ns-config", globalLimits); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate selector-based limits (sum of selectors must not exceed namespace/global limits)
        <span class="cov8" title="1">if err := validateSelectorLimits(namespaceSpec, globalLimits, globalNamespaceSpec, namespace); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validatePrunerConfig validates the fields of a PrunerConfig
// If globalConfig is provided, namespace-level settings are validated to not exceed global limits
// If globalConfig is nil and path indicates a namespace config, system maximums are enforced
func validatePrunerConfig(config *PrunerConfig, path string, globalConfig *PrunerConfig) error <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Determine if this is a namespace-level config validation (not a top-level global config)
        // Namespace configs can be:
        // - Standalone: path starts with "ns-config"
        // - Nested in global: path contains ".namespaces."
        <span class="cov8" title="1">isNamespaceConfig := strings.HasPrefix(path, "ns-config") || strings.Contains(path, ".namespaces.")

        // Validate EnforcedConfigLevel
        if config.EnforcedConfigLevel != nil </span><span class="cov8" title="1">{
                level := *config.EnforcedConfigLevel
                if level != EnforcedConfigLevelGlobal &amp;&amp;
                        level != EnforcedConfigLevelNamespace &amp;&amp;
                        level != EnforcedConfigLevelResource </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s: invalid enforcedConfigLevel '%s', must be one of: global, namespace, resource", path, level)
                }</span>
        }

        // Validate TTLSecondsAfterFinished
        <span class="cov8" title="1">if config.TTLSecondsAfterFinished != nil </span><span class="cov8" title="1">{
                if *config.TTLSecondsAfterFinished &lt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s: ttlSecondsAfterFinished cannot be negative, got %d", path, *config.TTLSecondsAfterFinished)
                }</span>
                // Namespace config cannot have longer TTL than global config
                <span class="cov8" title="1">if globalConfig != nil &amp;&amp; globalConfig.TTLSecondsAfterFinished != nil </span><span class="cov8" title="1">{
                        if *config.TTLSecondsAfterFinished &gt; *globalConfig.TTLSecondsAfterFinished </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s: ttlSecondsAfterFinished (%d) cannot exceed global limit (%d)",
                                        path, *config.TTLSecondsAfterFinished, *globalConfig.TTLSecondsAfterFinished)
                        }</span>
                } else<span class="cov8" title="1"> if isNamespaceConfig &amp;&amp; (globalConfig == nil || globalConfig.TTLSecondsAfterFinished == nil) </span><span class="cov8" title="1">{
                        // If this is a namespace config and no global limit is set, enforce system maximum
                        if *config.TTLSecondsAfterFinished &gt; MaxTTLSecondsAfterFinished </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s: ttlSecondsAfterFinished (%d) cannot exceed system maximum (%d seconds / 30 days)",
                                        path, *config.TTLSecondsAfterFinished, MaxTTLSecondsAfterFinished)
                        }</span>
                }
        }

        // Validate SuccessfulHistoryLimit
        <span class="cov8" title="1">if config.SuccessfulHistoryLimit != nil </span><span class="cov8" title="1">{
                if *config.SuccessfulHistoryLimit &lt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s: successfulHistoryLimit cannot be negative, got %d", path, *config.SuccessfulHistoryLimit)
                }</span>
                // For namespace configs, determine the upper limit based on global config
                <span class="cov8" title="1">if isNamespaceConfig &amp;&amp; globalConfig != nil </span><span class="cov8" title="1">{
                        // Priority 1: Use global successfulHistoryLimit if set
                        if globalConfig.SuccessfulHistoryLimit != nil </span><span class="cov8" title="1">{
                                if *config.SuccessfulHistoryLimit &gt; *globalConfig.SuccessfulHistoryLimit </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%s: successfulHistoryLimit (%d) cannot exceed global limit (%d)",
                                                path, *config.SuccessfulHistoryLimit, *globalConfig.SuccessfulHistoryLimit)
                                }</span>
                        } else<span class="cov8" title="1"> if globalConfig.HistoryLimit != nil </span><span class="cov8" title="1">{
                                // Priority 2: Use global historyLimit as fallback if no granular limit
                                if *config.SuccessfulHistoryLimit &gt; *globalConfig.HistoryLimit </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%s: successfulHistoryLimit (%d) cannot exceed global historyLimit (%d)",
                                                path, *config.SuccessfulHistoryLimit, *globalConfig.HistoryLimit)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Priority 3: Use system maximum if global config exists but has no relevant limits
                                if *config.SuccessfulHistoryLimit &gt; MaxHistoryLimit </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%s: successfulHistoryLimit (%d) cannot exceed system maximum (%d)",
                                                path, *config.SuccessfulHistoryLimit, MaxHistoryLimit)
                                }</span>
                        }
                } else<span class="cov8" title="1"> if isNamespaceConfig &amp;&amp; globalConfig == nil </span><span class="cov8" title="1">{
                        // Priority 3: Use system maximum if no global config at all
                        if *config.SuccessfulHistoryLimit &gt; MaxHistoryLimit </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s: successfulHistoryLimit (%d) cannot exceed system maximum (%d)",
                                        path, *config.SuccessfulHistoryLimit, MaxHistoryLimit)
                        }</span>
                }
        }

        // Validate FailedHistoryLimit
        <span class="cov8" title="1">if config.FailedHistoryLimit != nil </span><span class="cov8" title="1">{
                if *config.FailedHistoryLimit &lt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s: failedHistoryLimit cannot be negative, got %d", path, *config.FailedHistoryLimit)
                }</span>
                // For namespace configs, determine the upper limit based on global config
                <span class="cov8" title="1">if isNamespaceConfig &amp;&amp; globalConfig != nil </span><span class="cov8" title="1">{
                        // Priority 1: Use global failedHistoryLimit if set
                        if globalConfig.FailedHistoryLimit != nil </span><span class="cov8" title="1">{
                                if *config.FailedHistoryLimit &gt; *globalConfig.FailedHistoryLimit </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%s: failedHistoryLimit (%d) cannot exceed global limit (%d)",
                                                path, *config.FailedHistoryLimit, *globalConfig.FailedHistoryLimit)
                                }</span>
                        } else<span class="cov8" title="1"> if globalConfig.HistoryLimit != nil </span><span class="cov8" title="1">{
                                // Priority 2: Use global historyLimit as fallback if no granular limit
                                if *config.FailedHistoryLimit &gt; *globalConfig.HistoryLimit </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%s: failedHistoryLimit (%d) cannot exceed global historyLimit (%d)",
                                                path, *config.FailedHistoryLimit, *globalConfig.HistoryLimit)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // Priority 3: Use system maximum if global config exists but has no relevant limits
                                if *config.FailedHistoryLimit &gt; MaxHistoryLimit </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%s: failedHistoryLimit (%d) cannot exceed system maximum (%d)",
                                                path, *config.FailedHistoryLimit, MaxHistoryLimit)
                                }</span>
                        }
                } else<span class="cov8" title="1"> if isNamespaceConfig &amp;&amp; globalConfig == nil </span><span class="cov8" title="1">{
                        // Priority 3: Use system maximum if no global config at all
                        if *config.FailedHistoryLimit &gt; MaxHistoryLimit </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: failedHistoryLimit (%d) cannot exceed system maximum (%d)",
                                        path, *config.FailedHistoryLimit, MaxHistoryLimit)
                        }</span>
                }
        }

        // Validate HistoryLimit
        <span class="cov8" title="1">if config.HistoryLimit != nil </span><span class="cov8" title="1">{
                if *config.HistoryLimit &lt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("%s: historyLimit cannot be negative, got %d", path, *config.HistoryLimit)
                }</span>
                // For namespace configs, validate against global historyLimit
                <span class="cov8" title="1">if isNamespaceConfig &amp;&amp; globalConfig != nil &amp;&amp; globalConfig.HistoryLimit != nil </span><span class="cov8" title="1">{
                        if *config.HistoryLimit &gt; *globalConfig.HistoryLimit </span><span class="cov8" title="1">{
                                return fmt.Errorf("%s: historyLimit (%d) cannot exceed global limit (%d)",
                                        path, *config.HistoryLimit, *globalConfig.HistoryLimit)
                        }</span>
                } else<span class="cov8" title="1"> if isNamespaceConfig &amp;&amp; (globalConfig == nil || globalConfig.HistoryLimit == nil) </span><span class="cov8" title="1">{
                        // Use system maximum if no global historyLimit is set
                        if *config.HistoryLimit &gt; MaxHistoryLimit </span><span class="cov0" title="0">{
                                return fmt.Errorf("%s: historyLimit (%d) cannot exceed system maximum (%d)",
                                        path, *config.HistoryLimit, MaxHistoryLimit)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// validateSelectorLimits validates that the sum of selector-based limits does not exceed the allowed upper bound
// Uses a 4-tier hierarchy to determine the upper bound:
// 1. Namespace-level spec (in the same namespace config)
// 2. Global namespace override (from global.namespaces[namespace])
// 3. Global default spec
// 4. System maximum
func validateSelectorLimits(nsConfig *NamespaceSpec, globalConfig *PrunerConfig, globalNsSpec *NamespaceSpec, namespace string) error <span class="cov8" title="1">{
        if nsConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Validate PipelineRuns selectors
        <span class="cov8" title="1">if err := validateResourceSelectorLimits(nsConfig.PipelineRuns, &amp;nsConfig.PrunerConfig, globalConfig, globalNsSpec, namespace, "pipelineRuns"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate TaskRuns selectors
        <span class="cov8" title="1">if err := validateResourceSelectorLimits(nsConfig.TaskRuns, &amp;nsConfig.PrunerConfig, globalConfig, globalNsSpec, namespace, "taskRuns"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateResourceSelectorLimits validates selector limits for a specific resource type (PipelineRuns or TaskRuns)
func validateResourceSelectorLimits(resources []ResourceSpec, nsConfig *PrunerConfig, globalConfig *PrunerConfig, globalNsSpec *NamespaceSpec, namespace, resourceType string) error <span class="cov8" title="1">{
        if len(resources) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Calculate sum of selector-based limits for each limit type
        <span class="cov8" title="1">var sumSuccessful, sumFailed, sumHistory int32

        for i, resource := range resources </span><span class="cov8" title="1">{
                // Only count resources that have selectors (not name-based)
                if len(resource.Selector) &gt; 0 </span><span class="cov8" title="1">{
                        if resource.SuccessfulHistoryLimit != nil </span><span class="cov8" title="1">{
                                sumSuccessful += *resource.SuccessfulHistoryLimit
                        }</span>
                        <span class="cov8" title="1">if resource.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                sumFailed += *resource.FailedHistoryLimit
                        }</span>
                        <span class="cov8" title="1">if resource.HistoryLimit != nil </span><span class="cov0" title="0">{
                                sumHistory += *resource.HistoryLimit
                        }</span>
                }

                // Validate individual selector limits are non-negative
                <span class="cov8" title="1">if resource.SuccessfulHistoryLimit != nil &amp;&amp; *resource.SuccessfulHistoryLimit &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ns-config.%s[%d]: successfulHistoryLimit cannot be negative, got %d", resourceType, i, *resource.SuccessfulHistoryLimit)
                }</span>
                <span class="cov8" title="1">if resource.FailedHistoryLimit != nil &amp;&amp; *resource.FailedHistoryLimit &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ns-config.%s[%d]: failedHistoryLimit cannot be negative, got %d", resourceType, i, *resource.FailedHistoryLimit)
                }</span>
                <span class="cov8" title="1">if resource.HistoryLimit != nil &amp;&amp; *resource.HistoryLimit &lt; 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("ns-config.%s[%d]: historyLimit cannot be negative, got %d", resourceType, i, *resource.HistoryLimit)
                }</span>
        }

        // Validate successfulHistoryLimit sum
        <span class="cov8" title="1">if sumSuccessful &gt; 0 </span><span class="cov8" title="1">{
                upperBound := determineUpperBound(nsConfig.SuccessfulHistoryLimit, nsConfig.HistoryLimit,
                        globalNsSpec, globalConfig, "successfulHistoryLimit")
                if sumSuccessful &gt; upperBound </span><span class="cov8" title="1">{
                        return fmt.Errorf("namespace '%s' ns-config.%s: sum of selector successfulHistoryLimit (%d) cannot exceed upper bound (%d)",
                                namespace, resourceType, sumSuccessful, upperBound)
                }</span>
        }

        // Validate failedHistoryLimit sum
        <span class="cov8" title="1">if sumFailed &gt; 0 </span><span class="cov0" title="0">{
                upperBound := determineUpperBound(nsConfig.FailedHistoryLimit, nsConfig.HistoryLimit,
                        globalNsSpec, globalConfig, "failedHistoryLimit")
                if sumFailed &gt; upperBound </span><span class="cov0" title="0">{
                        return fmt.Errorf("namespace '%s' ns-config.%s: sum of selector failedHistoryLimit (%d) cannot exceed upper bound (%d)",
                                namespace, resourceType, sumFailed, upperBound)
                }</span>
        }

        // Validate historyLimit sum
        <span class="cov8" title="1">if sumHistory &gt; 0 </span><span class="cov0" title="0">{
                upperBound := determineUpperBound(nsConfig.HistoryLimit, nil,
                        globalNsSpec, globalConfig, "historyLimit")
                if sumHistory &gt; upperBound </span><span class="cov0" title="0">{
                        return fmt.Errorf("namespace '%s' ns-config.%s: sum of selector historyLimit (%d) cannot exceed upper bound (%d)",
                                namespace, resourceType, sumHistory, upperBound)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// determineUpperBound implements the 4-tier hierarchy to find the upper bound for selector validation
// limitType should be "successfulHistoryLimit", "failedHistoryLimit", or "historyLimit"
func determineUpperBound(nsGranularLimit, nsHistoryLimit *int32, globalNsSpec *NamespaceSpec, globalConfig *PrunerConfig, limitType string) int32 <span class="cov8" title="1">{
        // Level 1: Namespace-level spec (most specific)
        if nsGranularLimit != nil &amp;&amp; limitType != "historyLimit" </span><span class="cov8" title="1">{
                return *nsGranularLimit
        }</span>
        <span class="cov8" title="1">if limitType != "historyLimit" &amp;&amp; nsHistoryLimit != nil </span><span class="cov0" title="0">{
                // For granular limits, fallback to namespace historyLimit if granular not set
                return *nsHistoryLimit
        }</span>
        <span class="cov8" title="1">if limitType == "historyLimit" &amp;&amp; nsHistoryLimit != nil </span><span class="cov0" title="0">{
                return *nsHistoryLimit
        }</span>

        // Level 2: Global namespace override (from global.namespaces[namespace])
        <span class="cov8" title="1">if globalNsSpec != nil </span><span class="cov0" title="0">{
                switch limitType </span>{
                case "successfulHistoryLimit":<span class="cov0" title="0">
                        if globalNsSpec.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalNsSpec.SuccessfulHistoryLimit
                        }</span>
                        // Fallback to globalNsSpec.HistoryLimit
                        <span class="cov0" title="0">if globalNsSpec.HistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalNsSpec.HistoryLimit
                        }</span>
                case "failedHistoryLimit":<span class="cov0" title="0">
                        if globalNsSpec.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalNsSpec.FailedHistoryLimit
                        }</span>
                        // Fallback to globalNsSpec.HistoryLimit
                        <span class="cov0" title="0">if globalNsSpec.HistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalNsSpec.HistoryLimit
                        }</span>
                case "historyLimit":<span class="cov0" title="0">
                        if globalNsSpec.HistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalNsSpec.HistoryLimit
                        }</span>
                }
        }

        // Level 3: Global default spec
        <span class="cov8" title="1">if globalConfig != nil </span><span class="cov0" title="0">{
                switch limitType </span>{
                case "successfulHistoryLimit":<span class="cov0" title="0">
                        if globalConfig.SuccessfulHistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalConfig.SuccessfulHistoryLimit
                        }</span>
                        // Fallback to globalConfig.HistoryLimit
                        <span class="cov0" title="0">if globalConfig.HistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalConfig.HistoryLimit
                        }</span>
                case "failedHistoryLimit":<span class="cov0" title="0">
                        if globalConfig.FailedHistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalConfig.FailedHistoryLimit
                        }</span>
                        // Fallback to globalConfig.HistoryLimit
                        <span class="cov0" title="0">if globalConfig.HistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalConfig.HistoryLimit
                        }</span>
                case "historyLimit":<span class="cov0" title="0">
                        if globalConfig.HistoryLimit != nil </span><span class="cov0" title="0">{
                                return *globalConfig.HistoryLimit
                        }</span>
                }
        }

        // Level 4: System maximum
        <span class="cov8" title="1">return int32(MaxHistoryLimit)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import "knative.dev/pkg/ptr"

func (pc *PrunerConfig) SetDefaults() <span class="cov0" title="0">{
        if pc.HistoryLimit == nil </span><span class="cov0" title="0">{
                pc.HistoryLimit = ptr.Int32(DefaultHistoryLimit)
        }</span>
        <span class="cov0" title="0">if pc.EnforcedConfigLevel == nil </span><span class="cov0" title="0">{
                v := EnforcedConfigLevelGlobal
                pc.EnforcedConfigLevel = &amp;v
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "strconv"
)

const (
        // EnvSystemNamespace is the environment variable name used to define the system namespace
        // it is used for setting the namespace where pruner-related resources are managed
        EnvSystemNamespace = "SYSTEM_NAMESPACE"

        // EnvTTLConcurrentWorkersPipelineRun is the environment variable name
        // used to specify the count of concurrent workers in action to prune pipelineruns
        EnvTTLConcurrentWorkersPipelineRun = "TTL_CONCURRENT_WORKERS_PIPELINE_RUN"

        // EnvTTLConcurrentWorkersTaskRun is the environment variable name
        // used to specify the count of concurrent workers in action to prune taskruns
        EnvTTLConcurrentWorkersTaskRun = "TTL_CONCURRENT_WORKERS_TASK_RUN"

        // LabelPipelineName represents the label key in a pipeline run's metadata,
        // where its value corresponds to the name of the pipeline
        LabelPipelineName = "tekton.dev/pipeline"

        // LabelPipelineRunName represents the label key in a pipeline run's metadata,
        // where its value corresponds to the name of the pipeline run
        LabelPipelineRunName = "tekton.dev/pipelineRun"

        // LabelTaskName represents the label key in a task run's metadata,
        // where its value corresponds to the name of the task
        LabelTaskName = "tekton.dev/task"

        // LabelTaskRunName represents the label key in a task run's metadata,
        // where its value corresponds to the name of the task run
        LabelTaskRunName = "tekton.dev/taskRun"

        // KindPipelineRun represents the kind value of pipelineRun custom resource
        KindPipelineRun = "PipelineRun"

        // KindTaskRun represents the kind value of taskRun custom resource
        KindTaskRun = "TaskRun"

        // AnnotationTTLSecondsAfterFinished represents the annotation key
        // that stores the ttlSecondsAfterFinished value for the resource.
        AnnotationTTLSecondsAfterFinished = "pruner.tekton.dev/ttlSecondsAfterFinished"

        // AnnotationResourceNameLabelKey represents the annotation key
        // that stores the label key value used to uniquely identify the resource.
        AnnotationResourceNameLabelKey = "pruner.tekton.dev/resourceNameLabelKey"

        // AnnotationSuccessfulHistoryLimit represents the annotation key
        // that stores the successfulHistoryLimit value for the resource.
        AnnotationSuccessfulHistoryLimit = "pruner.tekton.dev/successfulHistoryLimit"

        // AnnotationFailedHistoryLimit represents the annotation key
        // that stores the failedHistoryLimit value for the resource.
        AnnotationFailedHistoryLimit = "pruner.tekton.dev/failedHistoryLimit"

        // AnnotationHistoryLimitCheckProcessed represents the annotation key
        // that indicates whether history limit checks have been processed for the resource.
        AnnotationHistoryLimitCheckProcessed = "pruner.tekton.dev/historyLimitCheckProcessed"

        // PrunerConfigMapName represents the name of the config map
        // that holds the cluster-wide pruner configuration data
        PrunerConfigMapName = "tekton-pruner-default-spec"

        // PrunerNamespaceConfigMapName represents the name of the config map
        // that holds the namespace-level pruner configuration data
        PrunerNamespaceConfigMapName = "tekton-pruner-namespace-spec"

        // PrunerGlobalConfigKey represents the key name
        // used to fetch the cluster-wide pruner configuration data
        PrunerGlobalConfigKey = "global-config"

        // PrunerNamespaceConfigKey represents the key name
        // used to fetch the namespace-level pruner configuration data
        PrunerNamespaceConfigKey = "ns-config"

        // DefaultTTLConcurrentWorkersPipelineRun represents
        // number of workers in the PipelineRun controller
        DefaultTTLConcurrentWorkersPipelineRun = int(5)

        // DefaultTTLConcurrentWorkersTaskRun represents
        // number of workers in the TaskRun controller
        DefaultTTLConcurrentWorkersTaskRun = int(5)

        // DefaultGCInterval represents
        // interval in seconds for the periodic cleanup i.e garbage collector to run
        DefaultPeriodicCleanupIntervalSeconds = 600 // 10 minutes

        // DefaultWorkerCountForNamespaceCleanup represents        the number of workers to be used
        // for cleaning up resources in a namespace concurrently
        DefaultWorkerCountForNamespaceCleanup = 5

        // DefaultHistoryLimit represents the default history limit for successful and failed resources
        DefaultHistoryLimit = 100

        // MaxTTLSecondsAfterFinished represents the maximum TTL in seconds that can be set
        // when no explicit global limit is defined. This is 30 days (2,592,000 seconds)
        MaxTTLSecondsAfterFinished = 2592000

        // MaxHistoryLimit represents the maximum history limit that can be set
        // when no explicit global limit is defined for history-based retention
        MaxHistoryLimit = 100
)

// GetEnvValueAsInt fetches the value of an environment variable and converts it to an integer
// if the environment variable is not set or if the conversion fails, it returns a default value
func GetEnvValueAsInt(envKey string, defaultValue int) (int, error) <span class="cov0" title="0">{
        strValue := os.Getenv(envKey)
        if strValue == "" </span><span class="cov0" title="0">{
                // If the environment variable is not set, return the default value
                return defaultValue, nil
        }</span>

        // Try to convert the string to an integer
        <span class="cov0" title="0">intValue, err := strconv.Atoi(strValue)
        if err != nil </span><span class="cov0" title="0">{
                // If conversion fails, return an error with context.
                return 0, fmt.Errorf("failed to convert value of %s to int: %w", envKey, err)
        }</span>

        <span class="cov0" title="0">return intValue, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// common functions used across history limiter and ttl handler

func getResourceNameLabelKey(resource metav1.Object, defaultLabelKey string) string <span class="cov8" title="1">{
        annotations := resource.GetAnnotations()
        // update user defined label key
        if len(annotations) &gt; 0 &amp;&amp; annotations[AnnotationResourceNameLabelKey] != "" </span><span class="cov0" title="0">{
                defaultLabelKey = annotations[AnnotationResourceNameLabelKey]
        }</span>

        <span class="cov8" title="1">return defaultLabelKey</span>
}

func getResourceName(resource metav1.Object, labelKey string) string <span class="cov8" title="1">{
        labels := resource.GetLabels()
        // if there is no label present, no option to filter
        if len(labels) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // get label value
        <span class="cov0" title="0">return labels[labelKey]</span>
}

/*
// getResourceNameFromMatch returns the resource name for a resource based on annotations first, then labels.
// If all annotations match or if all labels match, it returns the value of the "tekton.dev/pipelineRun" or "tekton.dev/taskRun" label else none
func getResourceNameFromMatch(resource metav1.Object, matchAnnotations map[string]string, matchLabels map[string]string, defaultLabelKey string) string {
        var annotationsMatch bool
        var labelsMatch bool
        var runName string

        labels := resource.GetLabels()

        // If matchAnnotations is not null or empty, process annotations
        if len(matchAnnotations) &gt; 0 {
                annotations := resource.GetAnnotations()
                if len(annotations) &gt; 0 { // Check if the resource has annotations
                        // Ensure all annotations in matchAnnotations exist in the resource annotations
                        annotationsMatch = true
                        for key, value := range matchAnnotations {
                                if annotationValue, exists := annotations[key]; !exists || annotationValue != value {
                                        annotationsMatch = false
                                        break
                                }
                        }

                        if annotationsMatch {
                                if value, exists := labels[defaultLabelKey]; exists {
                                        runName = value
                                }
                                return runName
                        }
                }
        }

        // If matchLabels is not null or empty, process labels
        if len(matchLabels) &gt; 0 {
                if len(labels) &gt; 0 { // Check if the resource has labels
                        // Ensure all labels in matchLabels exist in the resource labels
                        labelsMatch = true
                        for key, value := range matchLabels {
                                if labelValue, exists := labels[key]; !exists || labelValue != value {
                                        labelsMatch = false
                                        break
                                }
                        }

                        if labelsMatch {
                                if value, exists := labels[defaultLabelKey]; exists {
                                        runName = value
                                }
                                return runName
                        }
                }
        }

        // If no match found in either annotations or labels, return an empty string
        return ""
}
*/

// Helper function to match labels against label selector
func MatchLabels(labels map[string]string, labelSelector string) bool <span class="cov0" title="0">{
        labelPairs := strings.Split(labelSelector, ",")
        for _, labelPair := range labelPairs </span><span class="cov0" title="0">{
                parts := strings.Split(labelPair, "=")
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">labelKey, labelValue := parts[0], parts[1]
                if value, exists := labels[labelKey]; !exists || value != labelValue </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"
        "encoding/json"
        "fmt"
        "math"
        "slices"
        "strconv"
        "time"

        "github.com/tektoncd/pruner/pkg/metrics"
        // tektonprunerv1alpha1 "github.com/tektoncd/pruner/pkg/apis/tektonpruner/v1alpha1"
        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/ptr"
)

// HistoryLimiterResourceFuncs defines a set of methods that operate on resources
// with history limit capabilities.
type HistoryLimiterResourceFuncs interface {
        Type() string
        Get(ctx context.Context, namespace, name string) (metav1.Object, error)
        Update(ctx context.Context, resource metav1.Object) error
        Patch(ctx context.Context, namespace, name string, patchBytes []byte) error
        Delete(ctx context.Context, namespace, name string) error
        List(ctx context.Context, namespace, label string) ([]metav1.Object, error)
        GetFailedHistoryLimitCount(namespace, name string, selectors SelectorSpec) (*int32, string)
        GetSuccessHistoryLimitCount(namespace, name string, selectors SelectorSpec) (*int32, string)
        IsSuccessful(resource metav1.Object) bool
        IsFailed(resource metav1.Object) bool
        IsCompleted(resource metav1.Object) bool
        GetDefaultLabelKey() string
        GetEnforcedConfigLevel(namespace, name string, selectors SelectorSpec) EnforcedConfigLevel
}

// HistoryLimiter is a struct that encapsulates functionality for managing resources
// with history limits. It uses the HistoryLimiterResourceFuncs interface to interact
// with different types of resources
type HistoryLimiter struct {
        resourceFn HistoryLimiterResourceFuncs
}

// NewHistoryLimiter creates a new instance of HistoryLimiter, ensuring that the
// provided HistoryLimiterResourceFuncs interface is not nil
func NewHistoryLimiter(resourceFn HistoryLimiterResourceFuncs) (*HistoryLimiter, error) <span class="cov8" title="1">{
        hl := &amp;HistoryLimiter{
                resourceFn: resourceFn,
        }
        if hl.resourceFn == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("resourceFunc interface cannot be nil")
        }</span>

        <span class="cov8" title="1">return hl, nil</span>
}

// ProcessEvent processes an event for a given resource and performs cleanup
// based on its status. The method checks if the resource is in a deletion state,
// whether it has already been processed, and if it's in a completed state. Depending
// on the resource's completion status, it will either trigger cleanup for successful
// or failed resources
func (hl *HistoryLimiter) ProcessEvent(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Debugw("processing an event for limit logic", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())

        // if the resource is on deletion state, no action needed
        if resource.GetDeletionTimestamp() != nil </span><span class="cov8" title="1">{
                logger.Debugw("resource is in deletion state", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())
                return nil
        }</span>

        <span class="cov8" title="1">if hl.isProcessed(resource) </span><span class="cov8" title="1">{
                logger.Debugw("already processed", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())
                return nil
        }</span>

        // if the resource is still in running state, ignore it
        <span class="cov8" title="1">if !hl.resourceFn.IsCompleted(resource) </span><span class="cov8" title="1">{
                logger.Debugw("resource is not in completion state", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())
                return nil
        }</span>

        <span class="cov8" title="1">defer hl.markAsProcessed(ctx, resource)

        if hl.resourceFn.IsSuccessful(resource) </span><span class="cov8" title="1">{
                logger.Debugw("success - cleanup", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())
                return hl.DoSuccessfulResourceCleanup(ctx, resource)
        }</span>

        <span class="cov8" title="1">if hl.resourceFn.IsFailed(resource) </span><span class="cov8" title="1">{
                logger.Debugw("failed - cleanup", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())
                return hl.DoFailedResourceCleanup(ctx, resource)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// adds an annotation, indicates this resource is already processed
// no action needed on the further reconcile loop for this Resource
// markAsProcessed patches the resource with the annotation 'mark as processed'
func (hl *HistoryLimiter) markAsProcessed(ctx context.Context, resource metav1.Object) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        logger.Debugw("marking resource as processed", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())

        // Fetch the latest version of the resource
        resourceLatest, err := hl.resourceFn.Get(ctx, resource.GetNamespace(), resource.GetName())
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">logger.Errorw("error getting resource", "resource", hl.resourceFn.Type(),
                        "namespace", resource.GetNamespace(), "name", resource.GetName(), zap.Error(err))
                return</span>
        }

        // Prepare the annotation update
        <span class="cov8" title="1">processedTimeAsString := time.Now().Format(time.RFC3339)
        annotations := resourceLatest.GetAnnotations()
        if annotations == nil </span><span class="cov8" title="1">{
                annotations = map[string]string{}
        }</span>
        <span class="cov8" title="1">annotations[AnnotationHistoryLimitCheckProcessed] = processedTimeAsString

        // Create a patch with the new annotations
        patchData := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "annotations": annotations,
                },
        }

        // Convert patchData to JSON
        patchBytes, err := json.Marshal(patchData)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error marshaling patch data", zap.Error(err))
                return
        }</span>

        // Apply the patch
        <span class="cov8" title="1">err = hl.resourceFn.Patch(ctx, resourceLatest.GetNamespace(), resourceLatest.GetName(), patchBytes)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error patching resource with 'mark as processed' annotation",
                        "resource", hl.resourceFn.Type(), "namespace", resourceLatest.GetNamespace(), "name", resourceLatest.GetName(), zap.Error(err))
        }</span>
}

func (hl *HistoryLimiter) isProcessed(resource metav1.Object) bool <span class="cov8" title="1">{
        annotations := resource.GetAnnotations()
        if annotations == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, found := annotations[AnnotationHistoryLimitCheckProcessed]
        return found</span>
}

func (hl *HistoryLimiter) DoSuccessfulResourceCleanup(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        logging := logging.FromContext(ctx)

        logging.Debugw("processing a successful resource", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())
        return hl.doResourceCleanup(ctx, resource, AnnotationSuccessfulHistoryLimit, hl.resourceFn.GetSuccessHistoryLimitCount, hl.isSuccessfulResource)
}</span>

func (hl *HistoryLimiter) DoFailedResourceCleanup(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        logging := logging.FromContext(ctx)
        logging.Debugw("processing a failed resource", "resource", hl.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName())
        return hl.doResourceCleanup(ctx, resource, AnnotationFailedHistoryLimit, hl.resourceFn.GetFailedHistoryLimitCount, hl.isFailedResource)
}</span>

func (hl *HistoryLimiter) isFailedResource(resource metav1.Object) bool <span class="cov8" title="1">{
        return hl.resourceFn.IsCompleted(resource) &amp;&amp; hl.resourceFn.IsFailed(resource)
}</span>

func (hl *HistoryLimiter) isSuccessfulResource(resource metav1.Object) bool <span class="cov8" title="1">{
        return hl.resourceFn.IsCompleted(resource) &amp;&amp; hl.resourceFn.IsSuccessful(resource)
}</span>

func (hl *HistoryLimiter) doResourceCleanup(ctx context.Context, resource metav1.Object, historyLimitAnnotation string, getHistoryLimitFn func(string, string, SelectorSpec) (*int32, string), getResourceFilterFn func(metav1.Object) bool) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // get the label key and resource name
        labelKey := getResourceNameLabelKey(resource, hl.resourceFn.GetDefaultLabelKey())
        resourceName := getResourceName(resource, labelKey)

        // Get Annotations and Labels
        resourceAnnotations := resource.GetAnnotations()
        resourceLabels := resource.GetLabels()

        // Construct the selectors with both matchLabels and matchAnnotations
        resourceSelectors := SelectorSpec{}
        if len(resourceAnnotations) &gt; 0 </span><span class="cov0" title="0">{
                resourceSelectors.MatchAnnotations = resourceAnnotations
        }</span>
        <span class="cov8" title="1">if len(resourceLabels) &gt; 0 </span><span class="cov0" title="0">{
                resourceSelectors.MatchLabels = resourceLabels
        }</span>

        // Get enforced config level first
        <span class="cov8" title="1">enforcedConfigLevel := hl.resourceFn.GetEnforcedConfigLevel(resource.GetNamespace(), resourceName, resourceSelectors)
        logger.Debugw("enforcedConfigLevel for the resource is", "resourceName", resourceName, "enforcedlevel", enforcedConfigLevel)

        // Get configured history limit
        var historyLimit *int32
        var identifiedBy string
        configHistoryLimit, configIdentifiedBy := getHistoryLimitFn(resource.GetNamespace(), resourceName, resourceSelectors)

        // For resource-level enforcement, check annotation only if it matches config
        annotations := resource.GetAnnotations()
        if enforcedConfigLevel == EnforcedConfigLevelResource &amp;&amp; len(annotations) != 0 &amp;&amp; annotations[historyLimitAnnotation] != "" </span><span class="cov0" title="0">{
                annotationLimit, err := strconv.Atoi(annotations[historyLimitAnnotation])
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("error converting history limit annotation to int",
                                "resource", hl.resourceFn.Type(),
                                "namespace", resource.GetNamespace(),
                                "name", resource.GetName(),
                                "annotation", historyLimitAnnotation,
                                "value", annotations[historyLimitAnnotation],
                                zap.Error(err))
                        return err
                }</span>
                // Check bounds before converting to int32
                <span class="cov0" title="0">if annotationLimit &lt; 0 || annotationLimit &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        logger.Errorw("history limit annotation value out of bounds for int32",
                                "resource", hl.resourceFn.Type(),
                                "namespace", resource.GetNamespace(),
                                "name", resource.GetName(),
                                "annotation", historyLimitAnnotation,
                                "value", annotationLimit)
                        return fmt.Errorf("history limit value %d is out of bounds for type int32", annotationLimit)
                }</span>

                // Only use annotation value if it matches configured value
                <span class="cov0" title="0">if configHistoryLimit != nil &amp;&amp; annotationLimit == int(*configHistoryLimit) </span><span class="cov0" title="0">{
                        historyLimit = ptr.Int32(int32(annotationLimit))
                        identifiedBy = "identifiedBy_resource_ann"
                }</span> else<span class="cov0" title="0"> {
                        historyLimit = configHistoryLimit
                        identifiedBy = configIdentifiedBy
                }</span>
        } else<span class="cov8" title="1"> {
                historyLimit = configHistoryLimit
                identifiedBy = configIdentifiedBy
        }</span>

        <span class="cov8" title="1">logger.Debugw("historylimit for the resource", "resourcename", resourceName, "limit", historyLimit, "identifiedBy", identifiedBy)

        if historyLimit == nil || *historyLimit &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // List Resources (using appropriate selector based on enforcement level and identifier)
        <span class="cov8" title="1">var resources []metav1.Object
        var err error

        // Handle selector-based identification for both resource and namespace enforcement levels
        switch identifiedBy </span>{
        case "identifiedBy_resource_name":<span class="cov0" title="0">
                // Filter by name label (resource-level enforcement)
                label := fmt.Sprintf("%s=%s", labelKey, resourceName)
                resources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), label)</span>
        case "identifiedBy_resource_selector":<span class="cov0" title="0">
                // Filter by selector labels (namespace-level enforcement with selectors)
                labelSelector := ""
                for k, v := range resourceLabels </span><span class="cov0" title="0">{
                        if labelSelector != "" </span><span class="cov0" title="0">{
                                labelSelector += ","
                        }</span>
                        <span class="cov0" title="0">labelSelector += fmt.Sprintf("%s=%s", k, v)</span>
                }
                <span class="cov0" title="0">resources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), labelSelector)</span>
        case "identifiedBy_resource_ann":<span class="cov0" title="0">
                // Filter by annotations (converted to labels for listing)
                labelSelector := ""
                for k, v := range resourceAnnotations </span><span class="cov0" title="0">{
                        if labelSelector != "" </span><span class="cov0" title="0">{
                                labelSelector += ","
                        }</span>
                        <span class="cov0" title="0">labelSelector += fmt.Sprintf("%s=%s", k, v)</span>
                }
                <span class="cov0" title="0">resources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), labelSelector)</span>
        case "identifiedBy_resource_label":<span class="cov0" title="0">
                // Filter by all resource labels
                labelSelector := ""
                for k, v := range resourceLabels </span><span class="cov0" title="0">{
                        if labelSelector != "" </span><span class="cov0" title="0">{
                                labelSelector += ","
                        }</span>
                        <span class="cov0" title="0">labelSelector += fmt.Sprintf("%s=%s", k, v)</span>
                }
                <span class="cov0" title="0">resources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), labelSelector)</span>
        default:<span class="cov8" title="1">
                // For namespace/global level without selectors, list all resources in namespace
                resources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), "")</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Filter resources by status (success/failed)
        <span class="cov8" title="1">resourcesFiltered := []metav1.Object{}
        for _, res := range resources </span><span class="cov8" title="1">{
                if getResourceFilterFn(res) </span><span class="cov8" title="1">{
                        resourcesFiltered = append(resourcesFiltered, res)
                }</span>
        }
        <span class="cov8" title="1">resources = resourcesFiltered

        if int(*historyLimit) &gt; len(resources) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Sort resources by creation timestamp (newest first)
        <span class="cov8" title="1">slices.SortStableFunc(resources, func(a, b metav1.Object) int </span><span class="cov8" title="1">{
                objA := a.GetCreationTimestamp()
                objB := b.GetCreationTimestamp()
                if objA.Time.Before(objB.Time) </span><span class="cov0" title="0">{
                        return 1
                }</span> else<span class="cov8" title="1"> if objA.Time.After(objB.Time) </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov0" title="0">return 0</span>
        })

        // Select resources to delete (keep newest up to historyLimit)
        <span class="cov8" title="1">var selectionForDeletion []metav1.Object
        if *historyLimit == 0 </span><span class="cov0" title="0">{
                selectionForDeletion = resources
        }</span> else<span class="cov8" title="1"> {
                selectionForDeletion = resources[*historyLimit:]
        }</span>

        // Delete selected resources
        <span class="cov8" title="1">metricsRecorder := metrics.GetRecorder()
        resourceType := metrics.ResourceTypePipelineRun
        if hl.resourceFn.Type() == KindTaskRun </span><span class="cov0" title="0">{
                resourceType = metrics.ResourceTypeTaskRun
        }</span>

        <span class="cov8" title="1">for _, res := range selectionForDeletion </span><span class="cov8" title="1">{
                logger.Debugw("deleting resource",
                        "resource", hl.resourceFn.Type(),
                        "namespace", res.GetNamespace(),
                        "name", res.GetName(),
                        "creationTimestamp", res.GetCreationTimestamp(),
                )

                // Calculate resource age for metrics
                var resourceAge time.Duration
                creationTime := res.GetCreationTimestamp()
                if !creationTime.IsZero() </span><span class="cov8" title="1">{
                        resourceAge = time.Since(creationTime.Time)
                }</span>

                <span class="cov8" title="1">if err := hl.resourceFn.Delete(ctx, res.GetNamespace(), res.GetName()); err != nil </span><span class="cov0" title="0">{
                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Record deletion error
                        <span class="cov0" title="0">errorType := metrics.ClassifyError(err)
                        metricsRecorder.RecordResourceError(ctx, resourceType, res.GetNamespace(), errorType, "history_deletion_failed")
                        logger.Errorw("error deleting resource",
                                "resource", hl.resourceFn.Type(),
                                "namespace", res.GetNamespace(),
                                "name", res.GetName(),
                                zap.Error(err),
                        )
                        return err</span>
                }

                // Record successful deletion
                <span class="cov8" title="1">metricsRecorder.RecordResourceDeleted(ctx, resourceType, res.GetNamespace(), metrics.OperationHistory, resourceAge)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"
        "encoding/json"
        "fmt"
        "strconv"
        "time"

        "github.com/tektoncd/pruner/pkg/metrics"
        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        clockUtil "k8s.io/utils/clock"
        controller "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

const (
        // NoTTL represents a TTL value that indicates no TTL should be applied
        NoTTL = "-1"
        // DefaultTTL represents the default TTL duration if none is specified
        DefaultTTL = 0
)

// TTLResourceFuncs defines the set of functions that should be implemented for
// resources that are subject to Time-To-Live (TTL) management, including determining
// whether a resource is completed, updating or deleting the resource, and handling
// the TTL (time-to-live) after the resource is finished
type TTLResourceFuncs interface {
        Type() string
        Get(ctx context.Context, namespace, name string) (metav1.Object, error)
        Delete(ctx context.Context, namespace, name string) error
        Patch(ctx context.Context, namespace, name string, patchBytes []byte) error
        Update(ctx context.Context, resource metav1.Object) error
        IsCompleted(resource metav1.Object) bool
        GetCompletionTime(resource metav1.Object) (metav1.Time, error)
        Ignore(resource metav1.Object) bool
        GetTTLSecondsAfterFinished(namespace, name string, selectors SelectorSpec) (*int32, string)
        GetDefaultLabelKey() string
        GetEnforcedConfigLevel(namespace, name string, selectors SelectorSpec) EnforcedConfigLevel
}

// TTLHandler is responsible for managing resources with a Time-To-Live (TTL) configuration
type TTLHandler struct {
        clock      clockUtil.Clock // the clock for tracking time
        resourceFn TTLResourceFuncs
}

// NewTTLHandler creates a new instance of TTLHandler, which is responsible for managing
// resources with a Time-To-Live (TTL) configuration and initializes a TTLHandler with
// the provided clock and resource function interface.
func NewTTLHandler(clock clockUtil.Clock, resourceFn TTLResourceFuncs) (*TTLHandler, error) <span class="cov8" title="1">{
        tq := &amp;TTLHandler{
                clock:      clock,
                resourceFn: resourceFn,
        }
        if tq.resourceFn == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("resourceFunc interface cannot be nil")
        }</span>

        <span class="cov8" title="1">if tq.clock == nil </span><span class="cov0" title="0">{
                tq.clock = clockUtil.RealClock{}
        }</span>

        <span class="cov8" title="1">return tq, nil</span>
}

// ProcessEvent handles an event for a resource by processing its TTL-based actions.
// It evaluates the resource's state, checks whether it should be cleaned up,
// and updates the TTL annotation if needed
func (th *TTLHandler) ProcessEvent(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        // if a resource is in deletion state, no further action needed
        if resource.GetDeletionTimestamp() != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // if a resource is not completed state, no further action needed
        <span class="cov8" title="1">if !th.resourceFn.IsCompleted(resource) &amp;&amp; th.resourceFn.Ignore(resource) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // update ttl annotation, if not present
        <span class="cov8" title="1">err := th.updateAnnotationTTLSeconds(ctx, resource)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // if the resource is not available for cleanup, no further action needed
        <span class="cov8" title="1">if !th.needsCleanup(resource) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return th.removeResource(ctx, resource)</span>
}

// updateAnnotationTTLSeconds updates the TTL annotation of a resource if needed
func (th *TTLHandler) updateAnnotationTTLSeconds(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // get resource name and selectors first to avoid redundant work if no update needed
        labelKey := getResourceNameLabelKey(resource, th.resourceFn.GetDefaultLabelKey())
        resourceName := getResourceName(resource, labelKey)
        resourceSelectors := th.getResourceSelectors(resource)

        // Check enforced config level early
        enforcedLevel := th.resourceFn.GetEnforcedConfigLevel(resource.GetNamespace(), resourceName, resourceSelectors)
        logger.Debugw("checking TTL configuration",
                "resource", th.resourceFn.Type(),
                "namespace", resource.GetNamespace(),
                "name", resourceName,
                "enforced_level", enforcedLevel)

        // Check if update is needed
        if !th.needsTTLUpdate(resource, enforcedLevel) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get TTL value
        <span class="cov8" title="1">ttl, identifiedBy := th.resourceFn.GetTTLSecondsAfterFinished(resource.GetNamespace(), resourceName, resourceSelectors)
        logger.Debugw("TTL configuration found",
                "ttl", ttl,
                "source", identifiedBy,
                "resource", th.resourceFn.Type(),
                "namespace", resource.GetNamespace(),
                "name", resourceName)

        // Get latest version of resource to avoid conflicts
        resourceLatest, err := th.resourceFn.Get(ctx, resource.GetNamespace(), resource.GetName())
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get resource: %w", err)</span>
        }

        // Update annotations
        <span class="cov8" title="1">annotations := resourceLatest.GetAnnotations()
        if annotations == nil </span><span class="cov8" title="1">{
                annotations = make(map[string]string)
        }</span>

        <span class="cov8" title="1">if ttl == nil </span><span class="cov0" title="0">{
                // If TTL is nil, remove the annotation if it exists
                if _, exists := annotations[AnnotationTTLSecondsAfterFinished]; exists </span><span class="cov0" title="0">{
                        delete(annotations, AnnotationTTLSecondsAfterFinished)
                        logger.Debugw("removing TTL annotation - no TTL configuration found",
                                "resource", th.resourceFn.Type(),
                                "namespace", resource.GetNamespace(),
                                "name", resource.GetName())
                }</span>
        } else<span class="cov8" title="1"> {
                // Set new TTL annotation
                newTTL := strconv.Itoa(int(*ttl))
                currentTTL, hasCurrentTTL := annotations[AnnotationTTLSecondsAfterFinished]
                if !hasCurrentTTL || currentTTL != newTTL </span><span class="cov8" title="1">{
                        annotations[AnnotationTTLSecondsAfterFinished] = newTTL
                        logger.Debugw("updating TTL annotation",
                                "resource", th.resourceFn.Type(),
                                "namespace", resource.GetNamespace(),
                                "name", resource.GetName(),
                                "oldTTL", currentTTL,
                                "newTTL", newTTL,
                                "hadPreviousTTL", hasCurrentTTL)
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }

        <span class="cov8" title="1">patchData := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "annotations": annotations,
                },
        }

        patchBytes, err := json.Marshal(patchData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal patch data: %w", err)
        }</span>

        <span class="cov8" title="1">if err := th.resourceFn.Patch(ctx, resourceLatest.GetNamespace(), resourceLatest.GetName(), patchBytes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to patch resource with TTL annotation: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// needsCleanup checks whether a Resource has finished and has a TTL set.
func (th *TTLHandler) needsCleanup(resource metav1.Object) bool <span class="cov8" title="1">{
        // Check completion state first as it's likely to be the most expensive operation
        if !th.resourceFn.IsCompleted(resource) </span><span class="cov8" title="1">{
                return false
        }</span>

        // get the annotations
        <span class="cov8" title="1">annotations := resource.GetAnnotations()
        if annotations == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">ttlValue := annotations[AnnotationTTLSecondsAfterFinished]
        return ttlValue != "" &amp;&amp; ttlValue != NoTTL</span>
}

// removeResource checks the TTL and deletes the Resource if it has expired
func (th *TTLHandler) removeResource(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Debugw("checking resource cleanup eligibility",
                "resourceType", th.resourceFn.Type(),
                "namespace", resource.GetNamespace(),
                "name", resource.GetName(),
        )

        // check the resource ttl status
        expiredAt, err := th.processTTL(logger, resource)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process TTL: %w", err)
        }</span>
        <span class="cov8" title="1">if expiredAt == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Verify TTL hasn't been modified before deletion
        <span class="cov8" title="1">freshResource, err := th.resourceFn.Get(ctx, resource.GetNamespace(), resource.GetName())
        if err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to get fresh resource: %w", err)</span>
        }

        <span class="cov8" title="1">expiredAt, err = th.processTTL(logger, freshResource)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to process TTL for fresh resource: %w", err)
        }</span>
        <span class="cov8" title="1">if expiredAt == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">logger.Debugw("cleaning up expired resource",
                "resourceType", th.resourceFn.Type(),
                "namespace", resource.GetNamespace(),
                "name", resource.GetName(),
                "expiredAt", expiredAt,
        )

        // Calculate resource age for metrics
        var resourceAge time.Duration
        creationTime := resource.GetCreationTimestamp()
        if !creationTime.IsZero() </span><span class="cov0" title="0">{
                resourceAge = time.Since(creationTime.Time)
        }</span>

        // Get resource type for metrics
        <span class="cov8" title="1">resourceType := metrics.ResourceTypePipelineRun
        if th.resourceFn.Type() == KindTaskRun </span><span class="cov0" title="0">{
                resourceType = metrics.ResourceTypeTaskRun
        }</span>

        <span class="cov8" title="1">if err := th.resourceFn.Delete(ctx, resource.GetNamespace(), resource.GetName()); err != nil </span><span class="cov0" title="0">{
                if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                // Record deletion error
                <span class="cov0" title="0">metricsRecorder := metrics.GetRecorder()
                errorType := metrics.ClassifyError(err)
                metricsRecorder.RecordResourceError(ctx, resourceType, resource.GetNamespace(), errorType, "ttl_deletion_failed")
                return fmt.Errorf("failed to delete resource: %w", err)</span>
        }

        // Record successful deletion
        <span class="cov8" title="1">metricsRecorder := metrics.GetRecorder()
        metricsRecorder.RecordResourceDeleted(ctx, resourceType, resource.GetNamespace(), metrics.OperationTTL, resourceAge)

        return nil</span>
}

// processTTL checks whether a given Resource's TTL has expired, and add it to the queue after the TTL is expected to expire
// if the TTL will expire later.
func (th *TTLHandler) processTTL(logger *zap.SugaredLogger, resource metav1.Object) (expiredAt *time.Time, err error) <span class="cov8" title="1">{
        // We don't care about the Resources that are going to be deleted, or the ones that don't need clean up.
        if resource.GetDeletionTimestamp() != nil || !th.needsCleanup(resource) </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">now := th.clock.Now()
        t, e, err := th.timeLeft(logger, resource, &amp;now)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TTL has expired
        <span class="cov8" title="1">if *t &lt;= 0 </span><span class="cov8" title="1">{
                return e, nil
        }</span>

        <span class="cov0" title="0">return nil, th.enqueueAfter(logger, resource, *t)</span>
}

// calculates the remaining time to hold this resource
func (th *TTLHandler) timeLeft(logger *zap.SugaredLogger, resource metav1.Object, since *time.Time) (*time.Duration, *time.Time, error) <span class="cov8" title="1">{
        finishAt, expireAt, err := th.getFinishAndExpireTime(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if finishAt.After(*since) </span><span class="cov0" title="0">{
                logger.Warn("found resource finished in the future. This is likely due to time skew in the cluster. Resource cleanup will be deferred.")
        }</span>
        <span class="cov8" title="1">remaining := expireAt.Sub(*since)
        logger.Debugw("resource is in finished state",
                "finishTime", finishAt.UTC(), "remainingTTL", remaining, "startTime", since.UTC(), "deadlineTTL", expireAt.UTC(),
        )
        return &amp;remaining, expireAt, nil</span>
}

// returns finished and expire time of the Resource
func (th *TTLHandler) getFinishAndExpireTime(resource metav1.Object) (*time.Time, *time.Time, error) <span class="cov8" title="1">{
        if !th.needsCleanup(resource) </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("resource '%s/%s' should not be cleaned up", resource.GetNamespace(), resource.GetName())
        }</span>
        <span class="cov8" title="1">t, err := th.resourceFn.GetCompletionTime(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">finishAt := t.Time
        // get ttl duration
        ttlDuration, err := th.getTTLSeconds(resource)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">expireAt := finishAt.Add(*ttlDuration)
        return &amp;finishAt, &amp;expireAt, nil</span>
}

// returns ttl of the resource
func (th *TTLHandler) getTTLSeconds(resource metav1.Object) (*time.Duration, error) <span class="cov8" title="1">{
        annotations := resource.GetAnnotations()
        // if there is no annotation present, no action needed
        if annotations == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">ttlString := annotations[AnnotationTTLSecondsAfterFinished]
        // if there is no ttl present on annotation, no action needed
        if ttlString == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">ttl, err := strconv.Atoi(ttlString)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid TTL value %q: %w", ttlString, err)
        }</span>

        // Check for negative TTL values (except -1 which means no TTL)
        <span class="cov8" title="1">if ttl &lt; -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TTL value %d must be &gt;= -1", ttl)
        }</span>

        <span class="cov8" title="1">ttlDuration := time.Duration(ttl) * time.Second
        return &amp;ttlDuration, nil</span>
}

// enqueue the Resource for later reconcile
// the resource expire duration is in the future
func (th *TTLHandler) enqueueAfter(logger *zap.SugaredLogger, resource metav1.Object, after time.Duration) error <span class="cov0" title="0">{
        logger.Debugw("the resource to be reconciled later, it has expire in the future",
                "resource", th.resourceFn.Type(), "namespace", resource.GetNamespace(), "name", resource.GetName(), "waitDuration", after,
        )
        return controller.NewRequeueAfter(after)
}</span>

// getResourceSelectors constructs the selector spec for a resource
func (th *TTLHandler) getResourceSelectors(resource metav1.Object) SelectorSpec <span class="cov8" title="1">{
        selectors := SelectorSpec{}
        if annotations := resource.GetAnnotations(); len(annotations) &gt; 0 </span><span class="cov0" title="0">{
                selectors.MatchAnnotations = annotations
        }</span>
        <span class="cov8" title="1">if labels := resource.GetLabels(); len(labels) &gt; 0 </span><span class="cov0" title="0">{
                selectors.MatchLabels = labels
        }</span>
        <span class="cov8" title="1">return selectors</span>
}

// needsTTLUpdate determines if a resource needs its TTL annotation updated
func (th *TTLHandler) needsTTLUpdate(resource metav1.Object, enforcedLevel EnforcedConfigLevel) bool <span class="cov8" title="1">{
        annotations := resource.GetAnnotations()
        if annotations == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">currentTTL, exists := annotations[AnnotationTTLSecondsAfterFinished]
        if !exists </span><span class="cov0" title="0">{
                return true
        }</span>

        // Get the current TTL from config
        <span class="cov0" title="0">labelKey := getResourceNameLabelKey(resource, th.resourceFn.GetDefaultLabelKey())
        resourceName := getResourceName(resource, labelKey)
        resourceSelectors := th.getResourceSelectors(resource)

        configTTL, _ := th.resourceFn.GetTTLSecondsAfterFinished(resource.GetNamespace(), resourceName, resourceSelectors)

        // If there's no config TTL, we should remove the annotation
        if configTTL == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        // Compare current TTL with config TTL
        <span class="cov0" title="0">configTTLStr := strconv.Itoa(int(*configTTL))
        return currentTTL != configTTLStr</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"
        "sync"
        "time"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/metric"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
)

const (
        // Metric names
        MetricResourcesProcessed        = "tekton_pruner_controller_resources_processed"
        MetricReconciliationEvents      = "tekton_pruner_controller_reconciliation_events"
        MetricResourcesDeleted          = "tekton_pruner_controller_resources_deleted"
        MetricResourcesErrors           = "tekton_pruner_controller_resources_errors"
        MetricReconciliationDuration    = "tekton_pruner_controller_reconciliation_duration"
        MetricTTLProcessingDuration     = "tekton_pruner_controller_ttl_processing_duration"
        MetricHistoryProcessingDuration = "tekton_pruner_controller_history_processing_duration"
        MetricActiveResourcesCount      = "tekton_pruner_controller_active_resources"
        MetricPendingDeletionsCount     = "tekton_pruner_controller_pending_deletions"
        MetricResourceAgeAtDeletion     = "tekton_pruner_controller_resource_age_at_deletion"

        // Label keys
        LabelNamespace    = "namespace"
        LabelResourceType = "resource_type"
        LabelStatus       = "status"
        LabelReason       = "reason"
        LabelErrorType    = "error_type"
        LabelOperation    = "operation"

        // Label values for resource types
        ResourceTypePipelineRun = "pipelinerun"
        ResourceTypeTaskRun     = "taskrun"

        // Label values for operations
        OperationTTL     = "ttl"
        OperationHistory = "history"

        // Label values for status
        StatusSuccess = "success"
        StatusFailed  = "failed"
        StatusError   = "error"

        // Label values for error types
        ErrorTypeAPI        = "api_error"
        ErrorTypeTimeout    = "timeout"
        ErrorTypeValidation = "validation"
        ErrorTypeInternal   = "internal"
        ErrorTypeNotFound   = "not_found"
        ErrorTypePermission = "permission"
)

// Recorder holds all the OpenTelemetry instruments for recording metrics
type Recorder struct {
        // Counters
        resourcesProcessed   metric.Int64Counter
        reconciliationEvents metric.Int64Counter
        resourcesDeleted     metric.Int64Counter
        resourcesErrors      metric.Int64Counter

        // Histograms for duration measurements
        reconciliationDuration    metric.Float64Histogram
        ttlProcessingDuration     metric.Float64Histogram
        historyProcessingDuration metric.Float64Histogram
        resourceAgeAtDeletion     metric.Float64Histogram

        // UpDownCounters for gauge-like metrics
        activeResourcesCount  metric.Int64UpDownCounter
        pendingDeletionsCount metric.Int64UpDownCounter

        // Cache for tracking unique resources
        seenResources map[types.UID]bool
        cacheMutex    sync.RWMutex
}

var (
        recorder *Recorder
        once     sync.Once
)

// GetRecorder returns the singleton metrics recorder instance
func GetRecorder() *Recorder <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                recorder = newRecorder()
        }</span>)
        <span class="cov8" title="1">return recorder</span>
}

// newRecorder creates and initializes a new metrics recorder with all instruments
func newRecorder() *Recorder <span class="cov8" title="1">{
        meter := otel.Meter("tekton_pruner_controller")

        r := &amp;Recorder{}

        // Initialize cache for unique resource tracking
        r.seenResources = make(map[types.UID]bool)

        // Initialize counters
        r.resourcesProcessed, _ = meter.Int64Counter(
                MetricResourcesProcessed,
                metric.WithDescription("Total number of Tekton resources processed by the pruner"),
                metric.WithUnit("1"),
        )

        r.reconciliationEvents, _ = meter.Int64Counter(
                MetricReconciliationEvents,
                metric.WithDescription("Total number of reconciliation events processed by the pruner"),
                metric.WithUnit("1"),
        )

        r.resourcesDeleted, _ = meter.Int64Counter(
                MetricResourcesDeleted,
                metric.WithDescription("Total number of Tekton resources deleted by the pruner"),
                metric.WithUnit("1"),
        )

        r.resourcesErrors, _ = meter.Int64Counter(
                MetricResourcesErrors,
                metric.WithDescription("Total number of errors encountered while processing Tekton resources"),
                metric.WithUnit("1"),
        )

        // Initialize histograms
        r.reconciliationDuration, _ = meter.Float64Histogram(
                MetricReconciliationDuration,
                metric.WithDescription("Time spent in reconciliation loops"),
                metric.WithUnit("s"),
                metric.WithExplicitBucketBoundaries(0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0),
        )

        r.ttlProcessingDuration, _ = meter.Float64Histogram(
                MetricTTLProcessingDuration,
                metric.WithDescription("Time spent processing TTL-based pruning"),
                metric.WithUnit("s"),
                metric.WithExplicitBucketBoundaries(0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0),
        )

        r.historyProcessingDuration, _ = meter.Float64Histogram(
                MetricHistoryProcessingDuration,
                metric.WithDescription("Time spent processing history-based pruning"),
                metric.WithUnit("s"),
                metric.WithExplicitBucketBoundaries(0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0),
        )

        r.resourceAgeAtDeletion, _ = meter.Float64Histogram(
                MetricResourceAgeAtDeletion,
                metric.WithDescription("Age of resources when they are deleted"),
                metric.WithUnit("s"),
                metric.WithExplicitBucketBoundaries(
                        60, 300, 600, 1800, 3600, 7200, 14400, 28800, 86400, 172800, 345600, 604800,
                ), // 1m, 5m, 10m, 30m, 1h, 2h, 4h, 8h, 1d, 2d, 4d, 1w
        )

        // Initialize up-down counters
        r.activeResourcesCount, _ = meter.Int64UpDownCounter(
                MetricActiveResourcesCount,
                metric.WithDescription("Current number of active Tekton resources being tracked"),
                metric.WithUnit("1"),
        )

        r.pendingDeletionsCount, _ = meter.Int64UpDownCounter(
                MetricPendingDeletionsCount,
                metric.WithDescription("Current number of resources pending deletion"),
                metric.WithUnit("1"),
        )

        return r
}</span>

// Timer represents a duration measurement that can be recorded when stopped
type Timer struct {
        start    time.Time
        recorder *Recorder
        labels   []attribute.KeyValue
}

// NewTimer creates a new timer for measuring durations
func (r *Recorder) NewTimer(labels ...attribute.KeyValue) *Timer <span class="cov8" title="1">{
        return &amp;Timer{
                start:    time.Now(),
                recorder: r,
                labels:   labels,
        }
}</span>

// RecordReconciliationDuration records the duration since the timer was created
func (t *Timer) RecordReconciliationDuration(ctx context.Context) <span class="cov8" title="1">{
        duration := time.Since(t.start).Seconds()
        t.recorder.reconciliationDuration.Record(ctx, duration, metric.WithAttributes(t.labels...))
}</span>

// RecordTTLProcessingDuration records the duration since the timer was created
func (t *Timer) RecordTTLProcessingDuration(ctx context.Context) <span class="cov8" title="1">{
        duration := time.Since(t.start).Seconds()
        t.recorder.ttlProcessingDuration.Record(ctx, duration, metric.WithAttributes(t.labels...))
}</span>

// RecordHistoryProcessingDuration records the duration since the timer was created
func (t *Timer) RecordHistoryProcessingDuration(ctx context.Context) <span class="cov8" title="1">{
        duration := time.Since(t.start).Seconds()
        t.recorder.historyProcessingDuration.Record(ctx, duration, metric.WithAttributes(t.labels...))
}</span>

// RecordReconciliationEvent increments the reconciliation events counter
func (r *Recorder) RecordReconciliationEvent(ctx context.Context, resourceType, namespace, status string) <span class="cov8" title="1">{
        labels := []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
                attribute.String(LabelStatus, status),
        }
        r.reconciliationEvents.Add(ctx, 1, metric.WithAttributes(labels...))
}</span>

// RecordResourceProcessed increments the unique resources counter if this UID hasn't been seen before
func (r *Recorder) RecordResourceProcessed(ctx context.Context, resourceUID types.UID, resourceType, namespace, status string) <span class="cov8" title="1">{
        r.cacheMutex.Lock()
        defer r.cacheMutex.Unlock()

        // Only count if we haven't seen this UID before
        if !r.seenResources[resourceUID] </span><span class="cov8" title="1">{
                r.seenResources[resourceUID] = true

                labels := []attribute.KeyValue{
                        attribute.String(LabelResourceType, resourceType),
                        attribute.String(LabelNamespace, namespace),
                        attribute.String(LabelStatus, status),
                }
                r.resourcesProcessed.Add(ctx, 1, metric.WithAttributes(labels...))
        }</span>
}

// RecordResourceDeleted increments the resources deleted counter and records age
func (r *Recorder) RecordResourceDeleted(ctx context.Context, resourceType, namespace, operation string, resourceAge time.Duration) <span class="cov8" title="1">{
        // Record deletion count
        labels := []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
                attribute.String(LabelOperation, operation),
        }
        r.resourcesDeleted.Add(ctx, 1, metric.WithAttributes(labels...))

        // Record resource age at deletion
        r.resourceAgeAtDeletion.Record(ctx, resourceAge.Seconds(), metric.WithAttributes(labels...))
}</span>

// RecordResourceError increments the resources error counter
func (r *Recorder) RecordResourceError(ctx context.Context, resourceType, namespace, errorType, reason string) <span class="cov8" title="1">{
        labels := []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
                attribute.String(LabelErrorType, errorType),
                attribute.String(LabelReason, reason),
        }
        r.resourcesErrors.Add(ctx, 1, metric.WithAttributes(labels...))
}</span>

// UpdateActiveResourcesCount updates the active resources gauge
func (r *Recorder) UpdateActiveResourcesCount(ctx context.Context, resourceType, namespace string, delta int64) <span class="cov8" title="1">{
        labels := []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
        }
        r.activeResourcesCount.Add(ctx, delta, metric.WithAttributes(labels...))
}</span>

// UpdatePendingDeletionsCount updates the pending deletions gauge
func (r *Recorder) UpdatePendingDeletionsCount(ctx context.Context, resourceType, namespace string, delta int64) <span class="cov0" title="0">{
        labels := []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
        }
        r.pendingDeletionsCount.Add(ctx, delta, metric.WithAttributes(labels...))
}</span>

// Helper functions for creating common attribute sets

// ResourceAttributes creates common resource-related attributes
func ResourceAttributes(resourceType, namespace string) []attribute.KeyValue <span class="cov8" title="1">{
        return []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
        }
}</span>

// ErrorAttributes creates error-related attributes
func ErrorAttributes(resourceType, namespace, errorType, reason string) []attribute.KeyValue <span class="cov8" title="1">{
        return []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
                attribute.String(LabelErrorType, errorType),
                attribute.String(LabelReason, reason),
        }
}</span>

// OperationAttributes creates operation-related attributes
func OperationAttributes(resourceType, namespace, operation string) []attribute.KeyValue <span class="cov0" title="0">{
        return []attribute.KeyValue{
                attribute.String(LabelResourceType, resourceType),
                attribute.String(LabelNamespace, namespace),
                attribute.String(LabelOperation, operation),
        }
}</span>

// ClassifyError determines the error type based on the error
func ClassifyError(err error) string <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">switch </span>{
        case isAPIError(err):<span class="cov8" title="1">
                return ErrorTypeAPI</span>
        case isTimeoutError(err):<span class="cov8" title="1">
                return ErrorTypeTimeout</span>
        case isValidationError(err):<span class="cov8" title="1">
                return ErrorTypeValidation</span>
        case isNotFoundError(err):<span class="cov8" title="1">
                return ErrorTypeNotFound</span>
        case isPermissionError(err):<span class="cov8" title="1">
                return ErrorTypePermission</span>
        default:<span class="cov0" title="0">
                return ErrorTypeInternal</span>
        }
}

// Helper functions to classify errors (can be expanded based on actual error types)

func isAPIError(err error) bool <span class="cov8" title="1">{
        // Check for Kubernetes API errors
        return errors.IsInternalError(err) || errors.IsServerTimeout(err) || errors.IsServiceUnavailable(err)
}</span>

func isTimeoutError(err error) bool <span class="cov8" title="1">{
        // Check for timeout-related errors
        return errors.IsTimeout(err) || errors.IsServerTimeout(err)
}</span>

func isValidationError(err error) bool <span class="cov8" title="1">{
        // Check for validation errors
        return errors.IsInvalid(err) || errors.IsBadRequest(err)
}</span>

func isNotFoundError(err error) bool <span class="cov8" title="1">{
        // Check for not found errors
        return errors.IsNotFound(err)
}</span>

func isPermissionError(err error) bool <span class="cov8" title="1">{
        // Check for permission/authorization errors
        return errors.IsForbidden(err) || errors.IsUnauthorized(err)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package namespaceprunerconfig

import (
        "context"

        "github.com/tektoncd/pruner/pkg/config"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/client-go/tools/cache"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        configmapinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/configmap"
        namespaceinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/namespace"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)
        logger.Info("Starting Namespace Pruner Config controller")

        kubeClient := kubeclient.Get(ctx)
        configMapInformer := configmapinformer.Get(ctx)
        namespaceInformer := namespaceinformer.Get(ctx)

        r := &amp;Reconciler{
                kubeclient: kubeClient,
        }

        impl := controller.NewContext(ctx, r, controller.ControllerOptions{
                Logger:        logger,
                WorkQueueName: "namespace-pruner-config",
        })

        // Add event handler to watch ConfigMaps with the specified name across filtered namespaces
        // The informer will only watch namespaces specified via injection.WithNamespaceScope()
        _, err := configMapInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: func(obj interface{}) bool </span><span class="cov0" title="0">{
                        cm, ok := obj.(*corev1.ConfigMap)
                        if !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        // Only react to ConfigMaps with the namespace-level pruner config name
                        <span class="cov0" title="0">return cm.Name == config.PrunerNamespaceConfigMapName</span>
                },
                Handler: cache.ResourceEventHandlerFuncs{
                        AddFunc:    func(obj interface{}) <span class="cov0" title="0">{ impl.Enqueue(obj) }</span>,
                        UpdateFunc: func(oldObj, newObj interface{}) <span class="cov0" title="0">{ impl.Enqueue(newObj) }</span>,
                        DeleteFunc: func(obj interface{}) <span class="cov0" title="0">{ impl.Enqueue(obj) }</span>,
                },
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to add ConfigMap event handler", zap.Error(err))
        }</span>

        // Watch for namespace deletions to clean up orphaned config entries
        // This prevents memory leaks when namespaces are deleted
        <span class="cov0" title="0">_, err = namespaceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{
                DeleteFunc: func(obj interface{}) </span><span class="cov0" title="0">{
                        ns, ok := obj.(*corev1.Namespace)
                        if !ok </span><span class="cov0" title="0">{
                                // Handle tombstone case (object was deleted but informer hasn't caught up)
                                tombstone, ok := obj.(cache.DeletedFinalStateUnknown)
                                if !ok </span><span class="cov0" title="0">{
                                        logger.Warnw("Failed to decode namespace deletion event", "object", obj)
                                        return
                                }</span>
                                <span class="cov0" title="0">ns, ok = tombstone.Obj.(*corev1.Namespace)
                                if !ok </span><span class="cov0" title="0">{
                                        logger.Warnw("Tombstone contained unexpected object", "object", tombstone.Obj)
                                        return
                                }</span>
                        }

                        // Clean up namespace config from the store when namespace is deleted
                        <span class="cov0" title="0">logger.Infow("Namespace deleted, cleaning up config", "namespace", ns.Name)
                        config.PrunerConfigStore.DeleteNamespaceConfig(ctx, ns.Name)</span>
                },
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to add Namespace event handler", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return impl</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package namespaceprunerconfig

import (
        "context"
        "strings"

        "github.com/tektoncd/pruner/pkg/config"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// Reconciler implements controller.Reconciler for NamespacePrunerConfig resources
type Reconciler struct {
        kubeclient kubernetes.Interface
}

// Reconcile is called when a ConfigMap with name "tekton-pruner-namespace-spec" changes
func (r *Reconciler) Reconcile(ctx context.Context, key string) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Debugf("Reconciling namespace pruner config: %s", key)

        // Parse the key to get namespace and name
        namespace, name, err := parseKey(key)
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Invalid key: %s", key)
                return err
        }</span>

        // Get the ConfigMap
        <span class="cov8" title="1">cm, err := r.kubeclient.CoreV1().ConfigMaps(namespace).Get(ctx, name, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                // If the ConfigMap is not found, it was deleted
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        logger.Infof("Namespace ConfigMap deleted: %s/%s", namespace, name)
                        config.PrunerConfigStore.DeleteNamespaceConfig(ctx, namespace)
                        return nil
                }</span>
                <span class="cov0" title="0">logger.Errorf("Failed to get ConfigMap %s/%s: %v", namespace, name, err)
                return err</span>
        }

        // Load the namespace config
        <span class="cov8" title="1">logger.Infof("Loading namespace config from ConfigMap: %s/%s", namespace, name)
        if err := config.PrunerConfigStore.LoadNamespaceConfig(ctx, namespace, cm); err != nil </span><span class="cov8" title="1">{
                logger.Errorf("Failed to load namespace config from ConfigMap %s/%s: %v", namespace, name, err)
                return err
        }</span>

        <span class="cov8" title="1">logger.Infof("Successfully loaded namespace config: %s/%s", namespace, name)
        return nil</span>
}

// parseKey parses the key in the format "namespace/name" and returns namespace and name
func parseKey(key string) (namespace, name string, err error) <span class="cov8" title="1">{
        parts := strings.SplitN(key, "/", 2)
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return "", "", controller.NewPermanentError(nil)
        }</span>
        <span class="cov8" title="1">return parts[0], parts[1], nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package pipelinerun

import (
        "context"
        "os"

        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        pipelineruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        "github.com/tektoncd/pruner/pkg/config"
        "go.uber.org/zap"
        "k8s.io/utils/clock"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

// NewController creates a Reconciler and returns the result of NewImpl.
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        // Obtain an informer to both the main and child resources. These will be started by
        // the injection framework automatically. They'll keep a cached representation of the
        // cluster's state of the respective resource at all times.
        pipelineRunInformer := pipelineruninformer.Get(ctx)

        logger := logging.FromContext(ctx)

        pipelineRunFuncs := &amp;PrFuncs{
                client: pipelineclient.Get(ctx),
        }
        ttlHandler, err := config.NewTTLHandler(clock.RealClock{}, pipelineRunFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting ttl handler", zap.Error(err))
        }</span>

        <span class="cov0" title="0">historyLimiter, err := config.NewHistoryLimiter(pipelineRunFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting history limiter", zap.Error(err))
        }</span>

        <span class="cov0" title="0">r := &amp;Reconciler{
                // The client will be needed to create/delete Pods via the API.
                kubeclient:     kubeclient.Get(ctx),
                ttlHandler:     ttlHandler,
                historyLimiter: historyLimiter,
        }

        // number of works to process the events
        concurrentWorkers, err := config.GetEnvValueAsInt(config.EnvTTLConcurrentWorkersPipelineRun, config.DefaultTTLConcurrentWorkersPipelineRun)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("error on getting PipelineRun ttl concurrent workers count",
                        "environmentKey", config.EnvTTLConcurrentWorkersPipelineRun, "environmentValue", os.Getenv(config.EnvTTLConcurrentWorkersPipelineRun),
                        zap.Error(err),
                )
        }</span>

        <span class="cov0" title="0">ctrlOptions := controller.Options{
                Concurrency: concurrentWorkers,
        }

        impl := pipelinerunreconciler.NewImpl(ctx, r, func(impl *controller.Impl) controller.Options </span><span class="cov0" title="0">{ return ctrlOptions }</span>)

        // listen for events on the main resource and enqueue themselves.
        <span class="cov0" title="0">_, err = pipelineRunInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to add event handler", zap.Error(err))
        }</span>
        <span class="cov0" title="0">return impl</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package pipelinerun

import (
        "context"
        "encoding/json"
        "fmt"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        "github.com/tektoncd/pruner/pkg/config"
        "github.com/tektoncd/pruner/pkg/metrics"

        pipelineversioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        pipelinerunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/reconciler"
)

// Reconciler includes the kubernetes client to interact with the cluster
type Reconciler struct {
        kubeclient     kubernetes.Interface
        ttlHandler     *config.TTLHandler
        historyLimiter *config.HistoryLimiter
}

// Check that our Reconciler implements Interface
var _ pipelinerunreconciler.Interface = (*Reconciler)(nil)

// ReconcileKind implements Interface.ReconcileKind.
func (r *Reconciler) ReconcileKind(ctx context.Context, pr *pipelinev1.PipelineRun) reconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Debugw("received a PipelineRun event", "namespace", pr.Namespace, "name", pr.Name, "status", pr.Status)

        // Start timing the reconciliation
        metricsRecorder := metrics.GetRecorder()
        reconcileTimer := metricsRecorder.NewTimer(metrics.ResourceAttributes(metrics.ResourceTypePipelineRun, pr.Namespace)...)
        defer reconcileTimer.RecordReconciliationDuration(ctx)

        // Record that we processed a resource
        status := metrics.StatusSuccess
        defer func() </span><span class="cov8" title="1">{
                // Record reconciliation event (every reconciliation)
                metricsRecorder.RecordReconciliationEvent(ctx, metrics.ResourceTypePipelineRun, pr.Namespace, status)
                // Record unique resource (only first time we see this UID)
                metricsRecorder.RecordResourceProcessed(ctx, pr.UID, metrics.ResourceTypePipelineRun, pr.Namespace, status)
        }</span>()

        // execute the history limiter earlier than the ttl handler

        // execute history limit action
        <span class="cov8" title="1">historyTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypePipelineRun, pr.Namespace, metrics.OperationHistory)...)
        err := r.historyLimiter.ProcessEvent(ctx, pr)
        historyTimer.RecordHistoryProcessingDuration(ctx)

        if err != nil </span><span class="cov0" title="0">{
                status = metrics.StatusError
                errorType := metrics.ClassifyError(err)
                metricsRecorder.RecordResourceError(ctx, metrics.ResourceTypePipelineRun, pr.Namespace, errorType, "history_processing_failed")
                logger.Errorw("Error on processing history limiting for a PipelineRun", "namespace", pr.Namespace, "name", pr.Name, zap.Error(err))
                return err
        }</span>

        // execute ttl handler
        <span class="cov8" title="1">ttlTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypePipelineRun, pr.Namespace, metrics.OperationTTL)...)
        err = r.ttlHandler.ProcessEvent(ctx, pr)
        ttlTimer.RecordTTLProcessingDuration(ctx)

        if err != nil </span><span class="cov0" title="0">{
                isRequeueKey, _ := controller.IsRequeueKey(err)
                // the error is not a requeue error, print the error
                if !isRequeueKey </span><span class="cov0" title="0">{
                        status = metrics.StatusError
                        errorType := metrics.ClassifyError(err)
                        metricsRecorder.RecordResourceError(ctx, metrics.ResourceTypePipelineRun, pr.Namespace, errorType, "ttl_processing_failed")
                        data, _ := json.Marshal(pr)
                        logger.Errorw("Error on processing ttl for a PipelineRun", "namespace", pr.Namespace, "name", pr.Name, "resource", string(data), zap.Error(err))
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// PrFuncs provides methods for working with PipelineRun resources
// it contains a client to interact with the pipeline API and manage PipelineRuns
type PrFuncs struct {
        client pipelineversioned.Interface
}

// Type returns the kind of resource represented by the PRFuncs struct, which is "PipelineRun".
func (prf *PrFuncs) Type() string <span class="cov8" title="1">{
        return config.KindPipelineRun
}</span>

// NewPrFuncs creates a new instance of PrFuncs with the provided pipeline client.
// This client is used to interact with the Tekton Pipeline API.
func NewPrFuncs(client pipelineversioned.Interface) *PrFuncs <span class="cov8" title="1">{
        return &amp;PrFuncs{client: client}
}</span>

// List returns a list of PipelineRuns in a given namespace with a label selector.
func (prf *PrFuncs) List(ctx context.Context, namespace, label string) ([]metav1.Object, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // TODO: should we have to implement pagination support?
        prsList, err := prf.client.TektonV1().PipelineRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: label})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">prs := []metav1.Object{}
        prnames := []string{}
        for _, pr := range prsList.Items </span><span class="cov8" title="1">{
                prs = append(prs, pr.DeepCopy())
                prnames = append(prnames, pr.GetName())
        }</span>

        <span class="cov8" title="1">logger.Debugw("PipelineRuns list", "namespace", namespace, "label", label, "prnames", prnames)

        return prs, nil</span>
}

// ListByLabels returns a list of PipelineRuns in a given namespace filtered by multiple labels.
func (prf *PrFuncs) ListByLabels(ctx context.Context, namespace string, labels map[string]string) ([]metav1.Object, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        selector := metav1.FormatLabelSelector(&amp;metav1.LabelSelector{MatchLabels: labels})

        prsList, err := prf.client.TektonV1().PipelineRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: selector})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">prs := []metav1.Object{}
        for _, pr := range prsList.Items </span><span class="cov8" title="1">{
                prs = append(prs, pr.DeepCopy())
        }</span>

        <span class="cov8" title="1">logger.Debugw("PipelineRuns list by labels", "namespace", namespace, "labels", labels)

        return prs, nil</span>
}

// ListByAnnotations returns a list of PipelineRuns in a given namespace filtered by annotations.
func (prf *PrFuncs) ListByAnnotations(ctx context.Context, namespace string, annotations map[string]string) ([]metav1.Object, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        allPrs, err := prf.List(ctx, namespace, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">filteredPrs := []metav1.Object{}
        for _, pr := range allPrs </span><span class="cov8" title="1">{
                match := true
                for key, value := range annotations </span><span class="cov8" title="1">{
                        if pr.GetAnnotations()[key] != value </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        filteredPrs = append(filteredPrs, pr)
                }</span>
        }

        <span class="cov8" title="1">logger.Debugw("PipelineRuns list by annotations", "namespace", namespace, "annotations", annotations)

        return filteredPrs, nil</span>
}

// ListByNamespaces returns a list of PipelineRuns across multiple namespaces.
func (prf *PrFuncs) ListByNamespaces(ctx context.Context, namespaces []string) (map[string][]metav1.Object, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        results := make(map[string][]metav1.Object)

        for _, ns := range namespaces </span><span class="cov8" title="1">{
                prs, err := prf.List(ctx, ns, "")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to list PipelineRuns", "namespace", ns, "error", err)
                        continue</span>
                }
                <span class="cov8" title="1">results[ns] = prs</span>
        }

        <span class="cov8" title="1">logger.Debugw("PipelineRuns list by namespaces", "namespaces", namespaces)

        return results, nil</span>
}

/*
// List returns a list of PipelineRuns in a given namespace with label and annotation selectors.
// Annotations take higher priority. If annotations match, labels are ignored for that resource.
func (prf *PrFuncs) List(ctx context.Context, namespace string, annotations interface{}, labels interface{}) ([]metav1.Object, error) {
        logger := logging.FromContext(ctx)

        var annotationSelector string
        var labelSelector string

        // Handle annotations (manually filter later if provided)
        if annotations != nil {
                switch v := annotations.(type) {
                case string:
                        // If a single annotation is provided, use it directly
                        annotationSelector = v
                case map[string]string:
                        // If a map of annotations is provided, construct a selector for multiple annotations
                        for key, value := range v {
                                if annotationSelector != "" {
                                        annotationSelector += ","
                                }
                                annotationSelector += key + "=" + value
                        }
                default:
                        return nil, fmt.Errorf("invalid annotations type: must be string or map[string]string")
                }
        }
        logger.Debugw("annotationSelector", annotationSelector)

        // Handle labels
        if labels != nil {
                switch v := labels.(type) {
                case string:
                        // If a single label is provided, use it directly
                        labelSelector = v
                case map[string]string:
                        // If a map of labels is provided, construct a selector for multiple labels
                        for key, value := range v {
                                if labelSelector != "" {
                                        labelSelector += ","
                                }
                                labelSelector += key + "=" + value
                        }
                default:
                        return nil, fmt.Errorf("invalid labels type: must be string or map[string]string")
                }
        }

        logger.Debugw("labelSelector", labelSelector)

        // Prepare options to list resources with the correct label selector
        options := metav1.ListOptions{}

        // Apply label selector if provided
        if labelSelector != "" {
                options.LabelSelector = labelSelector
        }

        // List PipelineRuns using the constructed label selector
        prsList, err := prf.client.TektonV1().PipelineRuns(namespace).List(ctx, options)
        if err != nil {
                return nil, err
        }

        // Filter by annotations first if annotations are provided
        var filteredPRs []metav1.Object
        if annotationSelector != "" {
                for _, pr := range prsList.Items {
                        matches := true
                        // Check annotations if the selector matches
                        annotations := pr.GetAnnotations()
                        for key, value := range annotations {
                                if !strings.Contains(annotationSelector, key+"="+value) {
                                        matches = false
                                        break
                                }
                        }
                        if matches {
                                // If annotations match, include the resource and skip label filtering
                                filteredPRs = append(filteredPRs, pr.DeepCopy())
                        }
                }
        } else {
                // If no annotations are provided, apply label filtering
                for _, pr := range prsList.Items {
                        if labelSelector == "" || config.MatchLabels(pr.GetLabels(), labelSelector) {
                                filteredPRs = append(filteredPRs, pr.DeepCopy())
                        }
                }
        }

        // Return the filtered list of PipelineRuns
        return filteredPRs, nil
}
*/

// Get retrieves a specific PipelineRun by name in the given namespace.
func (prf *PrFuncs) Get(ctx context.Context, namespace, name string) (metav1.Object, error) <span class="cov8" title="1">{
        return prf.client.TektonV1().PipelineRuns(namespace).Get(ctx, name, metav1.GetOptions{})
}</span>

// Delete removes a specific PipelineRun by name in the given namespace.
func (prf *PrFuncs) Delete(ctx context.Context, namespace, name string) error <span class="cov8" title="1">{
        return prf.client.TektonV1().PipelineRuns(namespace).Delete(ctx, name, metav1.DeleteOptions{})
}</span>

// Update modifies an existing PipelineRun resource.
func (prf *PrFuncs) Update(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        pr, ok := resource.(*pipelinev1.PipelineRun)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid type received. namespace:%s, Name:%s", resource.GetNamespace(), resource.GetName())
        }</span>
        <span class="cov8" title="1">_, err := prf.client.TektonV1().PipelineRuns(resource.GetNamespace()).Update(ctx, pr, metav1.UpdateOptions{})
        return err</span>
}

// Patch modifies an existing PipelineRun resource using a Merge Patch
// This is useful for updating only specific fields of the resource.
func (prf *PrFuncs) Patch(ctx context.Context, namespace, name string, patchBytes []byte) error <span class="cov8" title="1">{
        _, err := prf.client.TektonV1().PipelineRuns(namespace).Patch(
                ctx,
                name,
                types.MergePatchType,
                patchBytes,
                metav1.PatchOptions{},
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to patch PipelineRun %s/%s: %w", namespace, name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCompletionTime retrieves the completion time of a PipelineRun resource.
func (prf *PrFuncs) GetCompletionTime(resource metav1.Object) (metav1.Time, error) <span class="cov8" title="1">{
        pr, ok := resource.(*pipelinev1.PipelineRun)
        if !ok </span><span class="cov0" title="0">{
                return metav1.Time{}, fmt.Errorf("resource type error, this is not a PipelineRun resource. namespace:%s, name:%s, type:%T",
                        resource.GetNamespace(), resource.GetName(), resource)
        }</span>
        <span class="cov8" title="1">if pr.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                return *pr.Status.CompletionTime, nil
        }</span>
        <span class="cov8" title="1">for _, c := range pr.Status.Conditions </span><span class="cov0" title="0">{
                if c.Type == apis.ConditionSucceeded &amp;&amp; c.Status != corev1.ConditionUnknown </span><span class="cov0" title="0">{
                        finishAt := c.LastTransitionTime
                        if finishAt.Inner.IsZero() </span><span class="cov0" title="0">{
                                return metav1.Time{}, fmt.Errorf("unable to find the time when the resource '%s/%s' finished", pr.Namespace, pr.Name)
                        }</span>
                        <span class="cov0" title="0">return c.LastTransitionTime.Inner, nil</span>
                }
        }

        // This should never happen if the Resource has finished
        <span class="cov8" title="1">return metav1.Time{}, fmt.Errorf("unable to find the status of the finished resource: %s/%s", pr.Namespace, pr.Name)</span>
}

// Ignore returns true if the resource should be ignored based on labels and annotations.
func (prf *PrFuncs) Ignore(resource metav1.Object) bool <span class="cov8" title="1">{
        // labels and annotations are not populated, lets wait sometime
        if resource.GetLabels() == nil </span><span class="cov8" title="1">{
                if resource.GetAnnotations() == nil || resource.GetAnnotations()[config.AnnotationTTLSecondsAfterFinished] == "" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsCompleted checks if the PipelineRun resource has completed.
func (prf *PrFuncs) IsCompleted(resource metav1.Object) bool <span class="cov8" title="1">{
        pr, ok := resource.(*pipelinev1.PipelineRun)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if pr.Status.StartTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if pr.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if pr.IsPending() </span><span class="cov0" title="0">{
                return false
        }</span>

        // check the status from conditions
        <span class="cov8" title="1">condition := pr.Status.GetCondition(apis.ConditionSucceeded)
        if condition == nil || condition.Status == corev1.ConditionUnknown </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// IsSuccessful checks if the PipelineRun resource has successfully completed.
func (prf *PrFuncs) IsSuccessful(resource metav1.Object) bool <span class="cov8" title="1">{
        pr, ok := resource.(*pipelinev1.PipelineRun)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if pr.IsPending() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">condition := pr.Status.GetCondition(apis.ConditionSucceeded)
        if condition == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">runReason := pipelinev1.PipelineRunReason(condition.Reason)

        if runReason == pipelinev1.PipelineRunReasonSuccessful || runReason == pipelinev1.PipelineRunReasonCompleted </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}

// IsFailed checks if the PipelineRun resource has failed.
func (prf *PrFuncs) IsFailed(resource metav1.Object) bool <span class="cov8" title="1">{
        pr, ok := resource.(*pipelinev1.PipelineRun)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if pr.IsPending() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return !prf.IsSuccessful(resource)</span>
}

// GetDefaultLabelKey returns the default label key for PipelineRun resources.
func (prf *PrFuncs) GetDefaultLabelKey() string <span class="cov8" title="1">{
        return config.LabelPipelineName
}</span>

// GetTTLSecondsAfterFinished retrieves the TTL (time-to-live) in seconds after a PipelineRun finishes.
func (prf *PrFuncs) GetTTLSecondsAfterFinished(namespace, pipelineName string, selectors config.SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        return config.PrunerConfigStore.GetPipelineTTLSecondsAfterFinished(namespace, pipelineName, selectors)
}</span>

// GetSuccessHistoryLimitCount retrieves the success history limit count for a PipelineRun.
func (prf *PrFuncs) GetSuccessHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) <span class="cov0" title="0">{
        return config.PrunerConfigStore.GetPipelineSuccessHistoryLimitCount(namespace, name, selectors)
}</span>

// GetFailedHistoryLimitCount retrieves the failed history limit count for a PipelineRun.
func (prf *PrFuncs) GetFailedHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        return config.PrunerConfigStore.GetPipelineFailedHistoryLimitCount(namespace, name, selectors)
}</span>

// GetEnforcedConfigLevel retrieves the enforced config level for a PipelineRun.
func (prf *PrFuncs) GetEnforcedConfigLevel(namespace, name string, selectors config.SelectorSpec) config.EnforcedConfigLevel <span class="cov8" title="1">{
        return config.PrunerConfigStore.GetPipelineEnforcedConfigLevel(namespace, name, selectors)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package taskrun

import (
        "context"
        "os"

        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        taskruninformer "github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        "github.com/tektoncd/pruner/pkg/config"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/utils/clock"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
)

// NewController creates a Reconciler and returns the result of NewImpl.
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        // Obtain an informer to both the main and child resources. These will be started by
        // the injection framework automatically. They'll keep a cached representation of the
        // cluster's state of the respective resource at all times.
        taskRunInformer := taskruninformer.Get(ctx)

        logger := logging.FromContext(ctx)

        taskRunFuncs := &amp;TrFuncs{
                client: pipelineclient.Get(ctx),
        }
        ttlHandler, err := config.NewTTLHandler(clock.RealClock{}, taskRunFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting ttl handler", zap.Error(err))
        }</span>

        <span class="cov0" title="0">historyLimiter, err := config.NewHistoryLimiter(taskRunFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting history limiter", zap.Error(err))
        }</span>

        <span class="cov0" title="0">r := &amp;Reconciler{
                // The client will be needed to create/delete Pods via the API.
                kubeclient:     kubeclient.Get(ctx),
                ttlHandler:     ttlHandler,
                historyLimiter: historyLimiter,
        }

        // number of works to process the events
        concurrentWorkers, err := config.GetEnvValueAsInt(config.EnvTTLConcurrentWorkersTaskRun, config.DefaultTTLConcurrentWorkersTaskRun)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalw("error on getting TaskRun ttl concurrent workers count",
                        "environmentKey", config.EnvTTLConcurrentWorkersTaskRun, "environmentValue", os.Getenv(config.EnvTTLConcurrentWorkersTaskRun),
                        zap.Error(err),
                )
        }</span>

        <span class="cov0" title="0">ctrlOptions := controller.Options{
                Concurrency: concurrentWorkers,
        }

        impl := taskrunreconciler.NewImpl(ctx, r, func(impl *controller.Impl) controller.Options </span><span class="cov0" title="0">{ return ctrlOptions }</span>)

        <span class="cov0" title="0">_, err = taskRunInformer.Informer().AddEventHandler(controller.HandleAll(filterTaskRun(logger, impl)))
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("Failed to add event handler", zap.Error(err))
        }</span>

        <span class="cov0" title="0">return impl</span>
}

// filters the taskrun which has a parent
func filterTaskRun(logger *zap.SugaredLogger, impl *controller.Impl) func(obj interface{}) <span class="cov0" title="0">{
        return func(obj interface{}) </span><span class="cov0" title="0">{
                taskRun, err := kmeta.DeletionHandlingAccessor(obj)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("error on getting object as Accessor", zap.Error(err))
                        return
                }</span>

                <span class="cov0" title="0">if !isStandaloneTaskRun(taskRun) </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">impl.EnqueueKey(types.NamespacedName{Namespace: taskRun.GetNamespace(), Name: taskRun.GetName()})</span>
        }
}

// returns true if the TaskRun is part of a PipelineRun
func isStandaloneTaskRun(taskRun metav1.Object) bool <span class="cov8" title="1">{
        // verify the taskRun is not part of a pipelineRun
        if taskRun.GetLabels() != nil &amp;&amp; taskRun.GetLabels()[config.LabelPipelineRunName] != "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // if the resource has owner reference as PipelineRun, it is not a standalone TaskRun
        // if so, ignore this taskRun
        <span class="cov8" title="1">if len(taskRun.GetOwnerReferences()) &gt; 0 </span><span class="cov8" title="1">{
                for _, ownerReference := range taskRun.GetOwnerReferences() </span><span class="cov8" title="1">{
                        if ownerReference.Kind == config.KindPipelineRun </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package taskrun

import (
        "context"
        "encoding/json"
        "fmt"

        "go.uber.org/zap"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1"
        pipelineversioned "github.com/tektoncd/pipeline/pkg/client/clientset/versioned"
        taskrunreconciler "github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun"
        "github.com/tektoncd/pruner/pkg/config"
        "github.com/tektoncd/pruner/pkg/metrics"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/reconciler"
)

// Reconciler implements simpledeploymentreconciler.Interface for
// SimpleDeployment resources.
type Reconciler struct {
        kubeclient     kubernetes.Interface
        ttlHandler     *config.TTLHandler
        historyLimiter *config.HistoryLimiter
}

// Check that our Reconciler implements Interface
var _ taskrunreconciler.Interface = (*Reconciler)(nil)

// ReconcileKind implements Interface.ReconcileKind.
func (r *Reconciler) ReconcileKind(ctx context.Context, tr *pipelinev1.TaskRun) reconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        logger.Debugw("received a TaskRun event",
                "namespace", tr.Namespace, "name", tr.Name,
        )

        // if the TaskRun is not a standalone, no action needed
        // if so, will be handled by it is parent resource(PipelineRun)
        if !isStandaloneTaskRun(tr) </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Start timing the reconciliation
        <span class="cov8" title="1">metricsRecorder := metrics.GetRecorder()
        reconcileTimer := metricsRecorder.NewTimer(metrics.ResourceAttributes(metrics.ResourceTypeTaskRun, tr.Namespace)...)
        defer reconcileTimer.RecordReconciliationDuration(ctx)

        // Record that we processed a resource
        status := metrics.StatusSuccess
        defer func() </span><span class="cov8" title="1">{
                // Record reconciliation event (every reconciliation)
                metricsRecorder.RecordReconciliationEvent(ctx, metrics.ResourceTypeTaskRun, tr.Namespace, status)
                // Record unique resource (only first time we see this UID)
                metricsRecorder.RecordResourceProcessed(ctx, tr.UID, metrics.ResourceTypeTaskRun, tr.Namespace, status)
        }</span>()

        // execute the history limiter earlier than the ttl handler

        // execute history limit action
        <span class="cov8" title="1">historyTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypeTaskRun, tr.Namespace, metrics.OperationHistory)...)
        err := r.historyLimiter.ProcessEvent(ctx, tr)
        historyTimer.RecordHistoryProcessingDuration(ctx)

        if err != nil </span><span class="cov0" title="0">{
                status = metrics.StatusError
                errorType := metrics.ClassifyError(err)
                metricsRecorder.RecordResourceError(ctx, metrics.ResourceTypeTaskRun, tr.Namespace, errorType, "history_processing_failed")
                logger.Errorw("Error on processing history limiting for a TaskRun",
                        "namespace", tr.Namespace, "name", tr.Name,
                        zap.Error(err),
                )
                return err
        }</span>

        // execute ttl handler
        <span class="cov8" title="1">ttlTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypeTaskRun, tr.Namespace, metrics.OperationTTL)...)
        err = r.ttlHandler.ProcessEvent(ctx, tr)
        ttlTimer.RecordTTLProcessingDuration(ctx)

        if err != nil </span><span class="cov8" title="1">{
                isRequeueKey, _ := controller.IsRequeueKey(err)
                // the error is not a requeue error, print the error
                if !isRequeueKey </span><span class="cov0" title="0">{
                        status = metrics.StatusError
                        errorType := metrics.ClassifyError(err)
                        metricsRecorder.RecordResourceError(ctx, metrics.ResourceTypeTaskRun, tr.Namespace, errorType, "ttl_processing_failed")
                        data, _ := json.Marshal(tr)
                        logger.Errorw("Error on processing ttl for a TaskRun",
                                "namespace", tr.Namespace, "name", tr.Name,
                                "resource", string(data),
                                zap.Error(err),
                        )
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// TrFuncs provides methods for working with TaskRun resources
// it contains a client to interact with the pipeline API and manage TaskRuns
type TrFuncs struct {
        client pipelineversioned.Interface
}

// Type returns the kind of resource represented by the TaskRunFuncs struct, which is "TaskRun".
func (trf *TrFuncs) Type() string <span class="cov8" title="1">{
        return config.KindTaskRun
}</span>

// NewTrFuncs creates a new instance of TrFuncs with the provided pipeline client.
// This client is used to interact with the Tekton pipeline API.
func NewTrFuncs(client pipelineversioned.Interface) *TrFuncs <span class="cov8" title="1">{
        return &amp;TrFuncs{client: client}
}</span>

// List returns a list of TaskRuns in a given namespace with a label selector.
func (trf *TrFuncs) List(ctx context.Context, namespace, labelSelector string) ([]metav1.Object, error) <span class="cov8" title="1">{
        // TODO: should we have to implement pagination support?
        prsList, err := trf.client.TektonV1().TaskRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: labelSelector})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">trs := []metav1.Object{}
        for _, tr := range prsList.Items </span><span class="cov8" title="1">{
                trs = append(trs, tr.DeepCopy())
        }</span>
        <span class="cov8" title="1">return trs, nil</span>
}

// ListByLabels returns a list of TaskRuns in a given namespace filtered by multiple labels.
func (trf *TrFuncs) ListByLabels(ctx context.Context, namespace string, labels map[string]string) ([]metav1.Object, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        selector := metav1.FormatLabelSelector(&amp;metav1.LabelSelector{MatchLabels: labels})

        trsList, err := trf.client.TektonV1().TaskRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: selector})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">trs := []metav1.Object{}
        for _, tr := range trsList.Items </span><span class="cov8" title="1">{
                trs = append(trs, tr.DeepCopy())
        }</span>

        <span class="cov8" title="1">logger.Debugw("TaskRuns list by labels", "namespace", namespace, "labels", labels)

        return trs, nil</span>
}

// ListByAnnotations returns a list of TaskRuns in a given namespace filtered by annotations.
func (trf *TrFuncs) ListByAnnotations(ctx context.Context, namespace string, annotations map[string]string) ([]metav1.Object, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        allTrs, err := trf.List(ctx, namespace, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">filteredTrs := []metav1.Object{}
        for _, tr := range allTrs </span><span class="cov8" title="1">{
                match := true
                for key, value := range annotations </span><span class="cov8" title="1">{
                        if tr.GetAnnotations()[key] != value </span><span class="cov8" title="1">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        filteredTrs = append(filteredTrs, tr)
                }</span>
        }

        <span class="cov8" title="1">logger.Debugw("TaskRuns list by annotations", "namespace", namespace, "annotations", annotations)

        return filteredTrs, nil</span>
}

// ListByNamespaces returns a list of TaskRuns across multiple namespaces.
func (trf *TrFuncs) ListByNamespaces(ctx context.Context, namespaces []string) (map[string][]metav1.Object, error) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        results := make(map[string][]metav1.Object)

        for _, ns := range namespaces </span><span class="cov8" title="1">{
                trs, err := trf.List(ctx, ns, "")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to list TaskRuns", "namespace", ns, "error", err)
                        continue</span>
                }
                <span class="cov8" title="1">results[ns] = trs</span>
        }

        <span class="cov8" title="1">logger.Debugw("TaskRuns list by namespaces", "namespaces", namespaces)

        return results, nil</span>
}

/*
// List returns a list of TaskRuns in a given namespace with label and annotation selectors.
// Annotations take higher priority. If annotations match, labels are ignored for that resource.
func (trf *TrFuncs) List(ctx context.Context, namespace string, annotations interface{}, labels interface{}) ([]metav1.Object, error) {
        logger := logging.FromContext(ctx)

        var annotationSelector string
        var labelSelector string

        // Handle annotations (manually filter later if provided)
        if annotations != nil {
                switch v := annotations.(type) {
                case string:
                        // If a single annotation is provided, use it directly
                        annotationSelector = v
                case map[string]string:
                        // If a map of annotations is provided, construct a selector for multiple annotations
                        for key, value := range v {
                                if annotationSelector != "" {
                                        annotationSelector += ","
                                }
                                annotationSelector += key + "=" + value
                        }
                default:
                        return nil, fmt.Errorf("invalid annotations type: must be string or map[string]string")
                }
        }
        logger.Debugw("annotationSelector", annotationSelector)

        // Handle labels
        if labels != nil {
                switch v := labels.(type) {
                case string:
                        // If a single label is provided, use it directly
                        labelSelector = v
                case map[string]string:
                        // If a map of labels is provided, construct a selector for multiple labels
                        for key, value := range v {
                                if labelSelector != "" {
                                        labelSelector += ","
                                }
                                labelSelector += key + "=" + value
                        }
                default:
                        return nil, fmt.Errorf("invalid labels type: must be string or map[string]string")
                }
        }
        logger.Debugw("labelSelector", labelSelector)

        // Prepare options to list resources with the correct label selector
        options := metav1.ListOptions{}

        // Apply label selector if provided
        if labelSelector != "" {
                options.LabelSelector = labelSelector
        }

        // List TaskRuns using the constructed label selector
        trsList, err := trf.client.TektonV1().TaskRuns(namespace).List(ctx, options)
        if err != nil {
                return nil, err
        }

        // Filter by annotations first if annotations are provided
        var filteredTRs []metav1.Object
        if annotationSelector != "" {
                for _, tr := range trsList.Items {
                        matches := true
                        // Check annotations if the selector matches
                        annotations := tr.GetAnnotations()
                        for key, value := range annotations {
                                if !strings.Contains(annotationSelector, key+"="+value) {
                                        matches = false
                                        break
                                }
                        }
                        if matches {
                                // If annotations match, include the resource and skip label filtering
                                filteredTRs = append(filteredTRs, tr.DeepCopy())
                        }
                }
        } else {
                // If no annotations are provided, apply label filtering
                for _, tr := range trsList.Items {
                        if labelSelector == "" || config.MatchLabels(tr.GetLabels(), labelSelector) {
                                filteredTRs = append(filteredTRs, tr.DeepCopy())
                        }
                }
        }

        // Return the filtered list of TaskRuns
        return filteredTRs, nil
}
*/

// Get retrieves a specific TaskRun by name in the given namespace.
func (trf *TrFuncs) Get(ctx context.Context, namespace, name string) (metav1.Object, error) <span class="cov8" title="1">{
        return trf.client.TektonV1().TaskRuns(namespace).Get(ctx, name, metav1.GetOptions{})
}</span>

// Delete removes a specific TaskRun by name in the given namespace.
func (trf *TrFuncs) Delete(ctx context.Context, namespace, name string) error <span class="cov8" title="1">{
        return trf.client.TektonV1().TaskRuns(namespace).Delete(ctx, name, metav1.DeleteOptions{})
}</span>

// Update modifies an existing TaskRun resource.
func (trf *TrFuncs) Update(ctx context.Context, resource metav1.Object) error <span class="cov8" title="1">{
        tr, ok := resource.(*pipelinev1.TaskRun)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid type received. namespace:%s, Name:%s", resource.GetNamespace(), resource.GetName())
        }</span>
        <span class="cov8" title="1">_, err := trf.client.TektonV1().TaskRuns(resource.GetNamespace()).Update(ctx, tr, metav1.UpdateOptions{})
        return err</span>
}

// Patch modifies an existing TaskRun resource using a JSON patch.
// This is useful for updating only specific fields of the resource.
func (trf *TrFuncs) Patch(ctx context.Context, namespace, name string, patchBytes []byte) error <span class="cov8" title="1">{
        _, err := trf.client.TektonV1().TaskRuns(namespace).Patch(
                ctx,
                name,
                types.MergePatchType,
                patchBytes,
                metav1.PatchOptions{},
        )

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to patch TaskRun %s/%s: %w", namespace, name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetCompletionTime retrieves the completion time of a TaskRun resource.
func (trf *TrFuncs) GetCompletionTime(resource metav1.Object) (metav1.Time, error) <span class="cov8" title="1">{
        tr, ok := resource.(*pipelinev1.TaskRun)
        if !ok </span><span class="cov0" title="0">{
                return metav1.Time{}, fmt.Errorf("resource type error, this is not a TaskRun resource. namespace:%s, name:%s, type:%T",
                        resource.GetNamespace(), resource.GetName(), resource)
        }</span>
        <span class="cov8" title="1">if tr.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                return *tr.Status.CompletionTime, nil
        }</span>

        // check the status from conditions
        <span class="cov8" title="1">condition := tr.Status.GetCondition(apis.ConditionSucceeded)
        if condition != nil &amp;&amp; condition.Status != corev1.ConditionUnknown </span><span class="cov0" title="0">{
                finishAt := condition.LastTransitionTime
                if finishAt.Inner.IsZero() </span><span class="cov0" title="0">{
                        return metav1.Time{}, fmt.Errorf("unable to find the time when the resource '%s/%s' finished", tr.Namespace, tr.Name)
                }</span>
                <span class="cov0" title="0">return condition.LastTransitionTime.Inner, nil</span>
        }

        // This should never happen if the Resource has finished
        <span class="cov8" title="1">return metav1.Time{}, fmt.Errorf("unable to find the status of the finished resource: %s/%s", tr.Namespace, tr.Name)</span>
}

// Ignore returns true if the resource should be ignored based on labels and annotations.
func (trf *TrFuncs) Ignore(resource metav1.Object) bool <span class="cov8" title="1">{
        // labels and annotations are not populated, lets wait sometime
        if resource.GetLabels() == nil </span><span class="cov8" title="1">{
                if resource.GetAnnotations() == nil || resource.GetAnnotations()[config.AnnotationTTLSecondsAfterFinished] == "" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsCompleted checks if the TaskRun resource has completed.
func (trf *TrFuncs) IsCompleted(resource metav1.Object) bool <span class="cov8" title="1">{
        tr, ok := resource.(*pipelinev1.TaskRun)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if tr.Status.StartTime == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if tr.Status.CompletionTime != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        // check the status from conditions
        <span class="cov8" title="1">condition := tr.Status.GetCondition(apis.ConditionSucceeded)
        if condition == nil || condition.Status == corev1.ConditionUnknown </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}

// IsSuccessful checks if the TaskRun resource has successfully completed.
func (trf *TrFuncs) IsSuccessful(resource metav1.Object) bool <span class="cov8" title="1">{
        tr, ok := resource.(*pipelinev1.TaskRun)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">condition := tr.Status.GetCondition(apis.ConditionSucceeded)
        if condition == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">runReason := pipelinev1.TaskRunReason(condition.Reason)
        return runReason == pipelinev1.TaskRunReasonSuccessful</span>
}

// IsFailed checks if the TaskRun resource has failed.
func (trf *TrFuncs) IsFailed(resource metav1.Object) bool <span class="cov8" title="1">{
        _, ok := resource.(*pipelinev1.TaskRun)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return !trf.IsSuccessful(resource)</span>
}

// GetDefaultLabelKey returns the default label key for TaskRun resources.
func (trf *TrFuncs) GetDefaultLabelKey() string <span class="cov8" title="1">{
        return config.LabelTaskName
}</span>

// GetTTLSecondsAfterFinished retrieves the TTL (time-to-live) in seconds after a TaskRun finishes.
func (trf *TrFuncs) GetTTLSecondsAfterFinished(namespace, taskName string, selectors config.SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        return config.PrunerConfigStore.GetTaskTTLSecondsAfterFinished(namespace, taskName, selectors)
}</span>

// GetSuccessHistoryLimitCount retrieves the success history limit count for a TaskRun.
func (trf *TrFuncs) GetSuccessHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) <span class="cov0" title="0">{
        return config.PrunerConfigStore.GetTaskSuccessHistoryLimitCount(namespace, name, selectors)
}</span>

// GetFailedHistoryLimitCount retrieves the failed history limit count for a TaskRun.
func (trf *TrFuncs) GetFailedHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) <span class="cov8" title="1">{
        return config.PrunerConfigStore.GetTaskFailedHistoryLimitCount(namespace, name, selectors)
}</span>

// GetEnforcedConfigLevel retrieves the enforced config level for a TaskRun.
func (trf *TrFuncs) GetEnforcedConfigLevel(namespace, name string, selectors config.SelectorSpec) config.EnforcedConfigLevel <span class="cov8" title="1">{
        return config.PrunerConfigStore.GetTaskEnforcedConfigLevel(namespace, name, selectors)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package tektonpruner

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"
        "time"

        "go.uber.org/zap"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/system"

        pipelineclient "github.com/tektoncd/pipeline/pkg/client/injection/client"
        "github.com/tektoncd/pruner/pkg/config"
        "github.com/tektoncd/pruner/pkg/reconciler/pipelinerun"
        "github.com/tektoncd/pruner/pkg/reconciler/taskrun"
        "github.com/tektoncd/pruner/pkg/version"

        clockUtil "k8s.io/utils/clock"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/client-go/kubernetes"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
)

// NewController creates a Reconciler and returns the result of NewImpl.
// It watches for changes to the pruner ConfigMap and triggers garbage collection (GC)
// when configuration changes are detected. The GC process cleans up resources based
// on the TTL configuration across all namespaces.
func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        logger.Info("Started Pruner controller")

        ver := version.Get()
        logger.Infow("pruner version details",
                "version", ver.Version, "arch", ver.Arch, "platform", ver.Platform,
                "goVersion", ver.GoLang, "buildDate", ver.BuildDate, "gitCommit", ver.GitCommit,
        )

        r := &amp;Reconciler{
                kubeclient: kubeclient.Get(ctx),
        }

        impl := controller.NewContext(ctx, r, controller.ControllerOptions{
                Logger:        logger,
                WorkQueueName: "pruner",
        })

        // ConfigMap watcher triggers GC
        cmw.Watch(config.PrunerConfigMapName, func(cm *corev1.ConfigMap) </span><span class="cov0" title="0">{
                go safeRunGarbageCollector(ctx, logger)
        }</span>)

        <span class="cov0" title="0">return impl</span>
}

// safeRunGarbageCollector is a thread-safe wrapper around the garbage collection process.
func safeRunGarbageCollector(ctx context.Context, logger *zap.SugaredLogger) <span class="cov8" title="1">{
        var gcMutex sync.Mutex

        logger.Debug("Waiting to acquire cleanup thread lock")
        gcMutex.Lock()
        defer gcMutex.Unlock()

        logger.Info("Running Cleanup")
        runGarbageCollector(ctx)
        logger.Info("Cleanup thread completed")
}</span>

func runGarbageCollector(ctx context.Context) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        kubeClient := kubeclient.Get(ctx)

        namespace := system.Namespace()

        // Load config from ConfigMap
        configMap, err := kubeClient.CoreV1().ConfigMaps(namespace).Get(ctx, config.PrunerConfigMapName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                logger.Error("Failed to load ConfigMap for GC", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">if err := config.PrunerConfigStore.LoadGlobalConfig(ctx, configMap); err != nil </span><span class="cov0" title="0">{
                logger.Error("Error loading pruner global config", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">configMapUpdateTime := time.Now().Format(time.RFC3339)

        // Get filtered namespaces
        namespaces, err := getFilteredNamespaces(ctx, kubeClient)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to filter namespaces for GC", zap.Error(err))
                return
        }</span>

        <span class="cov0" title="0">logger.Infow("Namespaces selected for garbage collection", "namespaces", namespaces)

        // Get worker count from config or default to 5
        workerCount, err := config.PrunerConfigStore.WorkerCount(ctx, configMap)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to get worker count from config", zap.Error(err))
                workerCount = config.DefaultWorkerCountForNamespaceCleanup
        }</span>

        // Setup channels
        <span class="cov0" title="0">nsChan := make(chan string)
        var wg sync.WaitGroup

        // Start workers
        for i := 0; i &lt; workerCount; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(workerID int) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        for ns := range nsChan </span><span class="cov0" title="0">{
                                logger.Infow("Worker processing namespace", "worker", workerID, "namespace", ns)

                                if err := cleanupPRs(ctx, ns, configMapUpdateTime); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorw("Error collecting PipelineRuns", zap.String("namespace", ns), zap.Error(err))
                                        continue</span>
                                }
                                <span class="cov0" title="0">if err := cleanupTRs(ctx, ns, configMapUpdateTime); err != nil </span><span class="cov0" title="0">{
                                        logger.Errorw("Error collecting TaskRuns", zap.String("namespace", ns), zap.Error(err))
                                        continue</span>
                                }
                        }
                }(i)
        }

        // Send namespaces to workers
        <span class="cov0" title="0">for _, ns := range namespaces </span><span class="cov0" title="0">{
                nsChan &lt;- ns
        }</span>
        <span class="cov0" title="0">close(nsChan)

        wg.Wait()
        logger.Info("Garbage collection completed")</span>
}

// getFilteredNamespaces returns namespaces excluding system namespaces
// Excluded: kube-*, openshift-*, tekton-pipelines, tekton-operator
func getFilteredNamespaces(ctx context.Context, client kubernetes.Interface) ([]string, error) <span class="cov8" title="1">{
        nsList, err := client.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var filtered []string
        for _, ns := range nsList.Items </span><span class="cov8" title="1">{
                name := ns.Name
                if !strings.HasPrefix(name, "kube-") &amp;&amp; !strings.HasPrefix(name, "openshift-") &amp;&amp;
                        name != "tekton-pipelines" &amp;&amp; name != "tekton-operator" </span><span class="cov8" title="1">{
                        filtered = append(filtered, name)
                }</span>
        }
        <span class="cov8" title="1">return filtered, nil</span>
}

// CleanupPRs is responsible for cleaning up completed PipelineRuns based on their TTL and history limit.
func cleanupPRs(ctx context.Context, namespace string, configMapUpdateTime string) error <span class="cov0" title="0">{

        logger := logging.FromContext(ctx)
        logger.Debugw("Start Cleanup PipelineRuns", "namespace", namespace)

        pipelineClient := pipelineclient.Get(ctx)
        prFuncs := pipelinerun.NewPrFuncs(pipelineClient)

        prTTLHandler, err := config.NewTTLHandler(clockUtil.RealClock{}, prFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting ttl handler", zap.Error(err))
        }</span>

        <span class="cov0" title="0">prHistoryLimiter, err := config.NewHistoryLimiter(prFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting history limiter", zap.Error(err))
        }</span>

        <span class="cov0" title="0">prsList, err := pipelineClient.TektonV1().PipelineRuns(namespace).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logger.Debugw("Progressing cleanup PipelineRuns list", "list", prsList.Items, "namespace", namespace)

        if len(prsList.Items) &gt; 0 </span><span class="cov0" title="0">{

                for _, prInstance := range prsList.Items </span><span class="cov0" title="0">{
                        logger.Debugw("Processing PipelineRun", "name", prInstance.Name, "namespace", prInstance.Namespace)
                        // Check if the PipelineRun is completed
                        if prInstance.Status.CompletionTime != nil </span><span class="cov0" title="0">{
                                pr := &amp;prInstance

                                // Check if the history limit processed time which is stored as a string in annotation of PR config.AnnotationHistoryLimitCheckProcessed is not nil
                                // and earlier than the configmap update time
                                if prInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed] != "" </span><span class="cov0" title="0">{
                                        // Parse the annotation value to a time.Time object
                                        annotationTime, err := time.Parse(time.RFC3339, prInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed])
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Errorw("Error parsing history limit check processed time", "namespace", pr.Namespace, "name", pr.Name, zap.Error(err))
                                                continue</span> // Continue to next PR instead of returning error
                                        }
                                        // Compare the annotation time with the configmap update time
                                        // If the configmap update time is after the annotation time, remove the annotation and patch the PipelineRun
                                        // to trigger the history limit check again

                                        <span class="cov0" title="0">updateTime, err := time.Parse(time.RFC3339, configMapUpdateTime)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Errorw("Error parsing configmap update time", "namespace", pr.Namespace, "name", pr.Name, zap.Error(err))
                                                continue</span> // Continue to next PR instead of returning error
                                        }

                                        <span class="cov0" title="0">if updateTime.After(annotationTime) </span><span class="cov0" title="0">{
                                                // Use JSON Patch to remove only the specific annotation without affecting others
                                                jsonPatch := fmt.Sprintf(`[{"op": "remove", "path": "/metadata/annotations/%s"}]`,
                                                        strings.ReplaceAll(config.AnnotationHistoryLimitCheckProcessed, "/", "~1"))

                                                // Patch the PipelineRun to remove the annotation
                                                _, err = pipelineClient.TektonV1().PipelineRuns(pr.Namespace).Patch(ctx, pr.Name, types.JSONPatchType, []byte(jsonPatch), metav1.PatchOptions{})
                                                if err != nil </span><span class="cov0" title="0">{
                                                        // If the PipelineRun is not found, it may have been deleted already, so we can continue
                                                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                                                logger.Debugw("PipelineRun not found during annotation patch - may have been deleted already", "namespace", pr.Namespace, "name", pr.Name)
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">logger.Errorw("error patching PipelineRun to remove history limit check processed annotation", "namespace", pr.Namespace, "name", pr.Name, zap.Error(err))
                                                        continue</span> // Continue to next PR instead of returning error
                                                }
                                        }
                                }

                                <span class="cov0" title="0">err := prHistoryLimiter.ProcessEvent(ctx, pr)
                                if err != nil </span><span class="cov0" title="0">{
                                        // If the PipelineRun is not found, it may have been processed/deleted by another worker, continue to next PR
                                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                                logger.Debugw("PipelineRun not found during history limiting - may have been processed by another worker", "namespace", pr.Namespace, "name", pr.Name)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">logger.Errorw("error processing history limiting for a PipelineRun", "namespace", pr.Namespace, "name", pr.Name, zap.Error(err))
                                        continue</span> // Continue to next PR instead of returning error
                                }
                                // execute ttl handler
                                <span class="cov0" title="0">err = prTTLHandler.ProcessEvent(ctx, pr)
                                if err != nil </span><span class="cov0" title="0">{
                                        // If the PipelineRun is not found, it may have been processed/deleted by another worker, continue to next PR
                                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                                logger.Debugw("PipelineRun not found during TTL processing - may have been processed by another worker", "namespace", pr.Namespace, "name", pr.Name)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">isRequeueKey, _ := controller.IsRequeueKey(err)
                                        // the error is not a requeue error, print the error
                                        if !isRequeueKey </span><span class="cov0" title="0">{
                                                data, _ := json.Marshal(pr)
                                                logger.Errorw("error processing ttl for a PipelineRun", "namespace", pr.Namespace, "name", pr.Name, "resource", string(data), zap.Error(err))
                                        }</span>
                                        <span class="cov0" title="0">continue</span> // Continue to next PR instead of returning error
                                }
                        }

                }
        }
        <span class="cov0" title="0">return nil</span>
}

// CleanupTRs is responsible for cleaning up completed TaskRuns based on their TTL and history limit.
// It checks if the TaskRun has a completion time and is not owned by a PipelineRun before processing.
func cleanupTRs(ctx context.Context, namespace string, configMapUpdateTime string) error <span class="cov0" title="0">{

        logger := logging.FromContext(ctx)
        logger.Debugw("Start Cleanup TaskRuns", "namespace", namespace)

        pipelineClient := pipelineclient.Get(ctx)
        trFuncs := taskrun.NewTrFuncs(pipelineClient)

        trTTLHandler, err := config.NewTTLHandler(clockUtil.RealClock{}, trFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting ttl handler", zap.Error(err))
        }</span>

        <span class="cov0" title="0">trHistoryLimiter, err := config.NewHistoryLimiter(trFuncs)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatal("error on getting history limiter", zap.Error(err))
        }</span>

        <span class="cov0" title="0">trsList, err := pipelineClient.TektonV1().TaskRuns(namespace).List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(trsList.Items) &gt; 0 </span><span class="cov0" title="0">{

                for _, trInstance := range trsList.Items </span><span class="cov0" title="0">{
                        if trInstance.Status.CompletionTime != nil &amp;&amp; !trInstance.HasPipelineRunOwnerReference() </span><span class="cov0" title="0">{
                                tr := &amp;trInstance

                                // Check if the history limit processed time which is stored as a string in annotation of PR config.AnnotationHistoryLimitCheckProcessed is not nil
                                // and earlier than the configmap update time
                                if trInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed] != "" </span><span class="cov0" title="0">{
                                        // Parse the annotation value to a time.Time object
                                        annotationTime, err := time.Parse(time.RFC3339, trInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed])
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Errorw("error parsing history limit check processed time", "namespace", tr.Namespace, "name", tr.Name, zap.Error(err))
                                                continue</span> // Continue to next TR instead of returning error
                                        }
                                        // Compare the annotation time with the configmap update time
                                        // If the configmap update time is after the annotation time, remove the annotation and patch the TaskRun
                                        // to trigger the history limit check again

                                        <span class="cov0" title="0">updateTime, err := time.Parse(time.RFC3339, configMapUpdateTime)
                                        if err != nil </span><span class="cov0" title="0">{
                                                logger.Errorw("error parsing configmap update time", "namespace", tr.Namespace, "name", tr.Name, zap.Error(err))
                                                continue</span> // Continue to next TR instead of returning error
                                        }
                                        // If the configmap update time is after the annotation time, remove the annotation and patch the TaskRun

                                        <span class="cov0" title="0">if updateTime.After(annotationTime) </span><span class="cov0" title="0">{
                                                // Use JSON Patch to remove only the specific annotation without affecting others
                                                jsonPatch := fmt.Sprintf(`[{"op": "remove", "path": "/metadata/annotations/%s"}]`,
                                                        strings.ReplaceAll(config.AnnotationHistoryLimitCheckProcessed, "/", "~1"))

                                                // Patch the TaskRun to remove the annotation
                                                _, err = pipelineClient.TektonV1().TaskRuns(tr.Namespace).Patch(ctx, tr.Name, types.JSONPatchType, []byte(jsonPatch), metav1.PatchOptions{})
                                                if err != nil </span><span class="cov0" title="0">{
                                                        // If the TaskRun is not found, it may have been deleted already, so we can continue
                                                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                                                logger.Debugw("TaskRun not found during annotation patch - may have been deleted already", "namespace", tr.Namespace, "name", tr.Name)
                                                                continue</span>
                                                        }
                                                        <span class="cov0" title="0">logger.Errorw("error patching TaskRun to remove history limit check processed annotation", "namespace", tr.Namespace, "name", tr.Name, zap.Error(err))
                                                        continue</span> // Continue to next TR instead of returning error
                                                }
                                        }
                                }

                                <span class="cov0" title="0">err := trHistoryLimiter.ProcessEvent(ctx, tr)
                                if err != nil </span><span class="cov0" title="0">{
                                        // If the TaskRun is not found, it may have been processed/deleted by another worker, continue to next TR
                                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                                logger.Debugw("TaskRun not found during history limiting - may have been processed by another worker", "namespace", tr.Namespace, "name", tr.Name)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">logger.Errorw("error processing history limiting for a TaskRun", "namespace", tr.Namespace, "name", tr.Name, zap.Error(err))
                                        continue</span> // Continue to next TR instead of returning error
                                }
                                // execute ttl handler
                                <span class="cov0" title="0">err = trTTLHandler.ProcessEvent(ctx, tr)
                                if err != nil </span><span class="cov0" title="0">{
                                        // If the TaskRun is not found, it may have been processed/deleted by another worker, continue to next TR
                                        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                                logger.Debugw("TaskRun not found during TTL processing - may have been processed by another worker", "namespace", tr.Namespace, "name", tr.Name)
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">isRequeueKey, _ := controller.IsRequeueKey(err)
                                        // the error is not a requeue error, print the error
                                        if !isRequeueKey </span><span class="cov0" title="0">{
                                                data, _ := json.Marshal(tr)
                                                logger.Errorw("error processing ttl for a TaskRun", "namespace", tr.Namespace, "name", tr.Name, "resource", string(data), zap.Error(err))
                                        }</span>
                                        <span class="cov0" title="0">continue</span> // Continue to next TR instead of returning error
                                }
                        }

                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package tektonpruner

import (
        "context"

        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/logging"
)

// Reconciler includes the kubernetes client to interact with the cluster
type Reconciler struct {
        kubeclient kubernetes.Interface
}

// Reconcile is the method that will be called when resources change
func (r *Reconciler) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Example logic: log the key of the changed resource (you can replace this with your custom logic)
        logger.Infof("Reconcile called for key: %s", key)

        // Nothing to reconcile at the moment. We are just updating the configstore

        return nil // Return nil to indicate successful reconciliation
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package webhook

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/tektoncd/pruner/pkg/config"
        admissionv1 "k8s.io/api/admission/v1"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/system"
        "knative.dev/pkg/webhook"
        certresources "knative.dev/pkg/webhook/certificates/resources"
)

type ValidateConfigMap struct {
        Client      kubernetes.Interface
        SecretName  string
        WebhookName string
}

var _ webhook.AdmissionController = (*ValidateConfigMap)(nil)
var _ webhook.StatelessAdmissionController = (*ValidateConfigMap)(nil)
var _ controller.Reconciler = (*ValidateConfigMap)(nil)

// ThisTypeDoesNotDependOnInformerState implements StatelessAdmissionController
func (v *ValidateConfigMap) ThisTypeDoesNotDependOnInformerState() {<span class="cov0" title="0">}</span>

// validateRequiredLabels checks if the ConfigMap has the required labels for pruner configs
func validateRequiredLabels(cm *corev1.ConfigMap) error <span class="cov8" title="1">{
        if cm.Labels == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("ConfigMap must have labels")
        }</span>

        // Check for required label: app.kubernetes.io/part-of=tekton-pruner
        <span class="cov8" title="1">if partOf, ok := cm.Labels["app.kubernetes.io/part-of"]; !ok || partOf != "tekton-pruner" </span><span class="cov0" title="0">{
                return fmt.Errorf("ConfigMap must have label app.kubernetes.io/part-of=tekton-pruner")
        }</span>

        // Check for config-type label
        <span class="cov8" title="1">configType, ok := cm.Labels["pruner.tekton.dev/config-type"]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("ConfigMap must have label pruner.tekton.dev/config-type (global or namespace)")
        }</span>

        // Validate config-type value
        <span class="cov8" title="1">if configType != "global" &amp;&amp; configType != "namespace" </span><span class="cov0" title="0">{
                return fmt.Errorf("label pruner.tekton.dev/config-type must be 'global' or 'namespace', got: %s", configType)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// validateNamespaceForConfig checks if a namespace is allowed for namespace-level configs
// Forbidden namespaces: kube-*, openshift-*, tekton-pipelines, tekton-operator
func validateNamespaceForConfig(namespace string) error <span class="cov8" title="1">{
        if strings.HasPrefix(namespace, "kube-") </span><span class="cov8" title="1">{
                return fmt.Errorf("namespace-level config cannot be created in kube-* namespaces, got: %s", namespace)
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(namespace, "openshift-") </span><span class="cov8" title="1">{
                return fmt.Errorf("namespace-level config cannot be created in openshift-* namespaces, got: %s", namespace)
        }</span>
        <span class="cov8" title="1">if namespace == "tekton-pipelines" || namespace == "tekton-operator" </span><span class="cov8" title="1">{
                return fmt.Errorf("namespace-level config cannot be created in %s namespace", namespace)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Reconcile updates the ValidatingWebhookConfiguration with CA bundle
func (v *ValidateConfigMap) Reconcile(ctx context.Context, key string) error <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // Get the secret containing the CA certificate
        secret, err := v.Client.CoreV1().Secrets(system.Namespace()).Get(ctx, v.SecretName, metav1.GetOptions{})
        if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                logger.Infof("Secret %s not found yet, skipping webhook configuration update", v.SecretName)
                return nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error fetching secret", "secret", v.SecretName, "error", err)
                return err
        }</span>

        // Get the CA certificate from the secret
        <span class="cov0" title="0">caCert, ok := secret.Data[certresources.CACert]
        if !ok </span><span class="cov0" title="0">{
                logger.Infof("CA cert not yet present in secret %s", v.SecretName)
                return nil
        }</span>

        // Get the ValidatingWebhookConfiguration
        <span class="cov0" title="0">vwc, err := v.Client.AdmissionregistrationV1().ValidatingWebhookConfigurations().Get(ctx, v.WebhookName, metav1.GetOptions{})
        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                logger.Infof("ValidatingWebhookConfiguration %s not found yet", v.WebhookName)
                return nil
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error fetching ValidatingWebhookConfiguration", "name", v.WebhookName, "error", err)
                return err
        }</span>

        // Update the CA bundle in all webhooks
        <span class="cov0" title="0">updated := false
        for i := range vwc.Webhooks </span><span class="cov0" title="0">{
                if string(vwc.Webhooks[i].ClientConfig.CABundle) != string(caCert) </span><span class="cov0" title="0">{
                        vwc.Webhooks[i].ClientConfig.CABundle = caCert
                        updated = true
                }</span>
        }

        <span class="cov0" title="0">if !updated </span><span class="cov0" title="0">{
                logger.Debug("CA bundle already up to date")
                return nil
        }</span>

        // Update the webhook configuration
        <span class="cov0" title="0">_, err = v.Client.AdmissionregistrationV1().ValidatingWebhookConfigurations().Update(ctx, vwc, metav1.UpdateOptions{})
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Error updating ValidatingWebhookConfiguration", "name", v.WebhookName, "error", err)
                return err
        }</span>

        <span class="cov0" title="0">logger.Infow("Successfully updated ValidatingWebhookConfiguration with CA bundle", "name", v.WebhookName)
        return nil</span>
}

func (v *ValidateConfigMap) Path() string <span class="cov8" title="1">{
        return "/validate-configmap"
}</span>

// Admit handles the admission request
func (v *ValidateConfigMap) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        // Only validate ConfigMaps
        if request.Kind.Kind != "ConfigMap" </span><span class="cov8" title="1">{
                return &amp;admissionv1.AdmissionResponse{Allowed: true}
        }</span>

        // Parse the ConfigMap (use OldObject for DELETE operations)
        <span class="cov8" title="1">var cm corev1.ConfigMap
        if request.Operation == admissionv1.Delete </span><span class="cov0" title="0">{
                if err := json.Unmarshal(request.OldObject.Raw, &amp;cm); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to unmarshal ConfigMap from OldObject", "error", err)
                        return &amp;admissionv1.AdmissionResponse{Allowed: true}
                }</span>
        } else<span class="cov8" title="1"> {
                if err := json.Unmarshal(request.Object.Raw, &amp;cm); err != nil </span><span class="cov8" title="1">{
                        logger.Warnw("Failed to unmarshal ConfigMap", "error", err)
                        return &amp;admissionv1.AdmissionResponse{Allowed: true}
                }</span>
        }

        // Validate that ConfigMap has required labels
        // The webhook objectSelector ensures only ConfigMaps with proper labels reach this point
        // This is a defense-in-depth check
        <span class="cov8" title="1">if err := validateRequiredLabels(&amp;cm); err != nil </span><span class="cov8" title="1">{
                logger.Warnw("ConfigMap missing required labels", "name", cm.Name, "namespace", cm.Namespace, "error", err)
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Status:  metav1.StatusFailure,
                                Message: fmt.Sprintf("Invalid pruner ConfigMap labels: %v", err),
                                Reason:  metav1.StatusReasonInvalid,
                                Code:    400,
                        },
                }
        }</span>

        // Determine config type from labels
        <span class="cov8" title="1">configType := cm.Labels["pruner.tekton.dev/config-type"]
        isGlobalConfig := configType == "global" &amp;&amp; cm.Namespace == system.Namespace()
        isNamespaceConfig := configType == "namespace" &amp;&amp; cm.Namespace != system.Namespace()

        // Validate ConfigMap names match expected patterns
        if isGlobalConfig &amp;&amp; cm.Name != "tekton-pruner-default-spec" </span><span class="cov0" title="0">{
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Status:  metav1.StatusFailure,
                                Message: fmt.Sprintf("Global config must be named 'tekton-pruner-default-spec', got: %s", cm.Name),
                                Reason:  metav1.StatusReasonInvalid,
                                Code:    400,
                        },
                }
        }</span>

        <span class="cov8" title="1">if isNamespaceConfig &amp;&amp; cm.Name != "tekton-pruner-namespace-spec" </span><span class="cov0" title="0">{
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Status:  metav1.StatusFailure,
                                Message: fmt.Sprintf("Namespace config must be named 'tekton-pruner-namespace-spec', got: %s", cm.Name),
                                Reason:  metav1.StatusReasonInvalid,
                                Code:    400,
                        },
                }
        }</span>

        // Validate that namespace-level configs are not in forbidden namespaces
        <span class="cov8" title="1">if isNamespaceConfig </span><span class="cov8" title="1">{
                if err := validateNamespaceForConfig(cm.Namespace); err != nil </span><span class="cov8" title="1">{
                        logger.Warnw("Namespace config in forbidden namespace", "name", cm.Name, "namespace", cm.Namespace, "error", err)
                        return &amp;admissionv1.AdmissionResponse{
                                Allowed: false,
                                Result: &amp;metav1.Status{
                                        Status:  metav1.StatusFailure,
                                        Message: fmt.Sprintf("Invalid namespace for namespace-level config: %v", err),
                                        Reason:  metav1.StatusReasonInvalid,
                                        Code:    400,
                                },
                        }
                }</span>
        }

        <span class="cov8" title="1">if !isGlobalConfig &amp;&amp; !isNamespaceConfig </span><span class="cov0" title="0">{
                logger.Warnw("Received unexpected ConfigMap", "name", cm.Name, "namespace", cm.Namespace, "configType", configType)
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Status:  metav1.StatusFailure,
                                Message: fmt.Sprintf("Invalid pruner ConfigMap configuration: wrong config-type label or namespace combination"),
                                Reason:  metav1.StatusReasonInvalid,
                                Code:    400,
                        },
                }
        }</span>

        <span class="cov8" title="1">logger.Infow("Validating pruner ConfigMap",
                "name", cm.Name,
                "namespace", cm.Namespace,
                "operation", request.Operation,
                "isGlobalConfig", isGlobalConfig,
                "isNamespaceConfig", isNamespaceConfig)

        // Handle DELETE operations
        if request.Operation == admissionv1.Delete </span><span class="cov0" title="0">{
                // Prevent deletion of global config if namespace configs still exist
                if isGlobalConfig </span><span class="cov0" title="0">{
                        nsList, err := v.Client.CoreV1().ConfigMaps("").List(ctx, metav1.ListOptions{
                                FieldSelector: "metadata.name=tekton-pruner-namespace-spec",
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorw("Failed to check for existing namespace configs", "error", err)
                                // Allow deletion if we can't check (fail open for DELETE)
                                logger.Infow("Allowing deletion of global config (unable to verify dependents)", "name", cm.Name)
                                return &amp;admissionv1.AdmissionResponse{Allowed: true}
                        }</span>
                        <span class="cov0" title="0">if len(nsList.Items) &gt; 0 </span><span class="cov0" title="0">{
                                namespaces := make([]string, len(nsList.Items))
                                for i, item := range nsList.Items </span><span class="cov0" title="0">{
                                        namespaces[i] = item.Namespace
                                }</span>
                                <span class="cov0" title="0">logger.Errorw("Attempted to delete global config while namespace configs exist",
                                        "namespaceConfigCount", len(nsList.Items),
                                        "affectedNamespaces", namespaces)
                                return &amp;admissionv1.AdmissionResponse{
                                        Allowed: false,
                                        Result: &amp;metav1.Status{
                                                Status: metav1.StatusFailure,
                                                Message: fmt.Sprintf("Cannot delete global config: %d namespace config(s) still exist that depend on it in namespaces: %v. Delete namespace configs first.",
                                                        len(nsList.Items), namespaces),
                                                Reason: metav1.StatusReasonInvalid,
                                                Code:   422,
                                        },
                                }</span>
                        }
                        <span class="cov0" title="0">logger.Infow("Allowing deletion of global config (no dependents)", "name", cm.Name)</span>
                } else<span class="cov0" title="0"> if isNamespaceConfig </span><span class="cov0" title="0">{
                        logger.Infow("Allowing deletion of namespace config", "name", cm.Name, "namespace", cm.Namespace)
                }</span>
                <span class="cov0" title="0">return &amp;admissionv1.AdmissionResponse{Allowed: true}</span>
        }

        // For CREATE/UPDATE operations, perform validation
        // For namespace-level configs, fetch global config to enforce limits
        <span class="cov8" title="1">var globalConfig *corev1.ConfigMap
        if isNamespaceConfig </span><span class="cov8" title="1">{
                var err error
                globalConfig, err = v.Client.CoreV1().ConfigMaps(system.Namespace()).Get(ctx, "tekton-pruner-default-spec", metav1.GetOptions{})
                if err != nil </span><span class="cov8" title="1">{
                        logger.Warnw("Failed to fetch global config for namespace validation", "error", err)
                        // Allow if global config is not available (e.g., during initial setup)
                        // Basic validation will still be performed
                }</span>
        }

        // Validate using the centralized validation function
        <span class="cov8" title="1">if err := config.ValidateConfigMapWithGlobal(&amp;cm, globalConfig); err != nil </span><span class="cov8" title="1">{
                logger.Errorw("ConfigMap validation failed", "name", cm.Name, "namespace", cm.Namespace, "error", err)
                return &amp;admissionv1.AdmissionResponse{
                        Allowed: false,
                        Result: &amp;metav1.Status{
                                Status:  metav1.StatusFailure,
                                Message: fmt.Sprintf("Invalid pruner configuration: %v", err),
                                Reason:  metav1.StatusReasonInvalid,
                                Code:    422,
                        },
                }
        }</span>

        <span class="cov8" title="1">logger.Infow("ConfigMap validation successful", "name", cm.Name, "namespace", cm.Namespace)
        return &amp;admissionv1.AdmissionResponse{Allowed: true}</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
