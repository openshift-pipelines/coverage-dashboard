<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coverage Report</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <style>
      :root {
  --sidebar-width: 280px;
  --topbar-height: 48px;
  --line-height: 20px;
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
}

[data-theme="dark"] {
  --bg: #1e1e1e;
  --bg-secondary: #252526;
  --bg-tertiary: #2d2d2d;
  --text: #d4d4d4;
  --text-muted: #808080;
  --border: #3c3c3c;
  --covered: rgba(35, 134, 54, 0.25);
  --covered-gutter: #238636;
  --uncovered: rgba(218, 54, 51, 0.25);
  --uncovered-gutter: #da3633;
  --highlight: #264f78;
  --highlight-match: #613214;
  --accent: #569cd6;
  --hover: #2a2d2e;
}

[data-theme="light"] {
  --bg: #ffffff;
  --bg-secondary: #f3f3f3;
  --bg-tertiary: #e8e8e8;
  --text: #24292f;
  --text-muted: #656d76;
  --border: #d0d7de;
  --covered: rgba(35, 134, 54, 0.15);
  --covered-gutter: #1a7f37;
  --uncovered: rgba(218, 54, 51, 0.15);
  --uncovered-gutter: #cf222e;
  --highlight: #ddf4ff;
  --highlight-match: #fff8c5;
  --accent: #0969da;
  --hover: #f6f8fa;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  font-size: 14px;
  background: var(--bg);
  color: var(--text);
}

#app {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  height: 100%;
}

/* Sidebar */
#sidebar {
  display: flex;
  flex-direction: column;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  overflow: hidden;
}

#sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
}

/* Logo link */
#logo-link {
  text-decoration: none;
  color: inherit;
  display: block;
}

#logo-link:hover #logo-container {
  opacity: 0.8;
}

#logo-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  transition: opacity 0.15s ease;
}

#logo-container .github-icon {
  flex-shrink: 0;
  color: var(--text-muted);
  transition: color 0.15s ease;
}

#logo-link:hover .github-icon {
  color: var(--accent);
}

#logo {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

#logo-text {
  flex: 1;
  min-width: 0;
}

#sidebar-header h1 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  line-height: 1.2;
}

#tagline {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  margin: 2px 0 0 0;
  line-height: 1.3;
}

#summary {
  font-size: 13px;
  color: var(--text-muted);
}

#summary .percent {
  font-weight: 600;
  color: var(--text);
}

#search-box {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
}

#search-input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 13px;
}

#search-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Sort controls */
#sort-controls {
  display: flex;
  gap: 0;
  margin: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}

.sort-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 6px 8px;
  background: var(--bg-secondary);
  color: var(--text);
  border: none;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.2s, color 0.2s;
}

.sort-btn:hover {
  background: var(--hover);
}

.sort-btn.active {
  background: var(--accent);
  color: #fff;
}

.sort-btn .icon {
  font-weight: 600;
}

.sort-btn .label {
  font-size: 11px;
}

/* Coverage badges for directories */
.coverage-badge {
  margin-left: auto;
  padding-left: 8px;
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  font-family: var(--font-mono);
}

#file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}

/* Sidebar footer */
#sidebar-footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  font-size: 12px;
  text-align: center;
}

#sidebar-footer a {
  color: var(--text-muted);
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

#sidebar-footer a:hover {
  color: var(--accent);
  text-decoration: underline;
}

#sidebar-footer .github-icon {
  flex-shrink: 0;
}

.tree-node {
  cursor: pointer;
  user-select: none;
}

.tree-item {
  display: flex;
  align-items: center;
  padding: 4px 16px;
  gap: 6px;
  white-space: nowrap;
}

.tree-item:hover {
  background: var(--hover);
}

.tree-item.selected {
  background: var(--highlight);
}

.tree-item .icon {
  width: 16px;
  text-align: center;
  font-size: 12px;
  color: var(--text-muted);
}

.tree-item .name {
  font-size: 13px;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.tree-children {
  display: none;
}

.tree-node.expanded > .tree-children {
  display: block;
}

.tree-children .tree-item {
  padding-left: calc(16px + var(--depth, 0) * 16px);
}

.tree-node.hidden {
  display: none;
}

/* Canvas */
#canvas {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--topbar-height);
  padding: 0 16px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  gap: 16px;
}

#file-path {
  font-size: 13px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#topbar-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

#in-file-search {
  display: flex;
  align-items: center;
  gap: 8px;
}

#content-search {
  width: 180px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 12px;
}

#content-search:focus {
  outline: none;
  border-color: var(--accent);
}

#match-info {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
}

#prev-match, #next-match {
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 10px;
}

#prev-match:hover, #next-match:hover {
  background: var(--hover);
}

#theme-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 16px;
}

#theme-toggle:hover {
  background: var(--hover);
}

#syntax-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-family: var(--font-mono);
}

#syntax-toggle:hover {
  background: var(--hover);
}

#syntax-toggle.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

#help-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
}

#help-toggle:hover {
  background: var(--hover);
}

/* Override highlight.js to use theme-aware colors */
.hljs { background: transparent !important; }

[data-theme="dark"] .hljs-keyword { color: #569cd6; }
[data-theme="dark"] .hljs-type { color: #4ec9b0; }
[data-theme="dark"] .hljs-string { color: #ce9178; }
[data-theme="dark"] .hljs-number { color: #b5cea8; }
[data-theme="dark"] .hljs-comment { color: #6a9955; }
[data-theme="dark"] .hljs-built_in { color: #dcdcaa; }
[data-theme="dark"] .hljs-literal { color: #569cd6; }
[data-theme="dark"] .hljs-function { color: #dcdcaa; }

[data-theme="light"] .hljs-keyword { color: #0000ff; }
[data-theme="light"] .hljs-type { color: #267f99; }
[data-theme="light"] .hljs-string { color: #a31515; }
[data-theme="light"] .hljs-number { color: #098658; }
[data-theme="light"] .hljs-comment { color: #008000; }
[data-theme="light"] .hljs-built_in { color: #795e26; }
[data-theme="light"] .hljs-literal { color: #0000ff; }
[data-theme="light"] .hljs-function { color: #795e26; }

/* Viewport */
#viewport {
  flex: 1;
  overflow: auto;
  background: var(--bg);
  outline: none;
}

#viewport::-webkit-scrollbar {
  width: 14px;
  height: 14px;
}

#viewport::-webkit-scrollbar-track {
  background: var(--bg);
}

#viewport::-webkit-scrollbar-thumb {
  background: var(--border);
  border: 3px solid var(--bg);
  border-radius: 7px;
}

#viewport::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

.code-container {
  display: table;
  min-width: 100%;
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: var(--line-height);
}

.code-line {
  display: table-row;
}

.code-line:hover {
  background: var(--hover);
}

.code-line.covered {
  background: var(--covered);
}

.code-line.uncovered {
  background: var(--uncovered);
}

.code-line.covered:hover {
  background: var(--covered);
}

.code-line.uncovered:hover {
  background: var(--uncovered);
}

.gutter {
  display: table-cell;
  width: 4px;
  min-width: 4px;
}

.code-line.covered .gutter {
  background: var(--covered-gutter);
}

.code-line.uncovered .gutter {
  background: var(--uncovered-gutter);
}

.line-number {
  display: table-cell;
  width: 50px;
  min-width: 50px;
  padding: 0 12px 0 8px;
  text-align: right;
  color: var(--text-muted);
  user-select: none;
  vertical-align: top;
}

.line-content {
  display: table-cell;
  padding-right: 16px;
  white-space: pre;
  tab-size: 4;
}

.match-highlight {
  background: var(--highlight-match);
  border-radius: 2px;
}

.current-match {
  background: var(--accent);
  color: #fff;
}

/* Empty state */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-muted);
  gap: 8px;
}

.empty-state .icon {
  font-size: 48px;
  opacity: 0.5;
}

/* Scrollbar for file tree */
#file-tree::-webkit-scrollbar {
  width: 8px;
}

#file-tree::-webkit-scrollbar-track {
  background: transparent;
}

#file-tree::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

#file-tree::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Help modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  max-width: 400px;
  width: 90%;
}

.modal-content h2 {
  margin-bottom: 16px;
  font-size: 18px;
}

.modal-content dl {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px 16px;
}

.modal-content dt {
  font-family: var(--font-mono);
  background: var(--bg-tertiary);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
}

.modal-content dd {
  color: var(--text-muted);
}

.modal-content button {
  margin-top: 20px;
  padding: 8px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  width: 100%;
}

/* Selected line range (multi-line selection) */
.code-line.selected-line {
  background-color: var(--highlight);
}

.code-line.selected-line.covered {
  background-color: var(--highlight);
}

.code-line.selected-line.uncovered {
  background-color: var(--highlight);
}

/* Line number click indicator */
.line-number {
  cursor: pointer;
}

.line-number:hover {
  color: var(--accent);
}

    </style>
  </head>
  <body data-theme="dark">
    <div id="app">
      <aside id="sidebar">
        <div id="sidebar-header">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            id="logo-link"
            target="_blank"
            rel="noopener"
          >
            <div id="logo-container">
              <svg id="logo" viewBox="0 0 32 32" width="32" height="32">
                <defs>
                  <linearGradient
                    id="logoGradient"
                    x1="0%"
                    y1="0%"
                    x2="100%"
                    y2="100%"
                  >
                    <stop
                      offset="0%"
                      style="stop-color: var(--accent); stop-opacity: 1"
                    />
                    <stop
                      offset="100%"
                      style="stop-color: var(--accent); stop-opacity: 0.7"
                    />
                  </linearGradient>
                </defs>
                
                <circle
                  cx="16"
                  cy="16"
                  r="14"
                  fill="none"
                  stroke="url(#logoGradient)"
                  stroke-width="2"
                  opacity="0.3"
                />
                
                <path
                  d="M 10 17 L 14 21 L 22 11"
                  fill="none"
                  stroke="var(--accent)"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                
                <circle
                  cx="24"
                  cy="10"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
                <circle
                  cx="26"
                  cy="12"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
              </svg>
              <div id="logo-text">
                <h1>GO Coverage</h1>
                <div id="tagline">A better HTML Go Coverage</div>
              </div>
            </div>
          </a>
          <div id="summary"></div>
        </div>
        <div id="search-box">
          <input type="text" id="search-input" placeholder="Search files..." />
        </div>
        <div id="sort-controls">
          <button
            class="sort-btn active"
            data-sort="name"
            title="Sort alphabetically"
          >
            <span class="icon">Aâ†’Z</span>
            <span class="label">Name</span>
          </button>
          <button
            class="sort-btn"
            data-sort="coverage"
            title="Sort by coverage percentage"
          >
            <span class="icon">%</span>
            <span class="label">Coverage</span>
          </button>
        </div>
        <div id="file-tree"></div>
        <footer id="sidebar-footer">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            target="_blank"
            rel="noopener"
          >
            <svg
              class="github-icon"
              viewBox="0 0 16 16"
              width="14"
              height="14"
              fill="currentColor"
            >
              <path
                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
              />
            </svg>
            chmouel/go-better-html-coverage
          </a>
        </footer>
      </aside>
      <main id="canvas">
        <header id="topbar">
          <div id="file-path"></div>
          <div id="topbar-actions">
            <div id="in-file-search">
              <input
                type="text"
                id="content-search"
                placeholder="Search in file..."
              />
              <span id="match-info"></span>
              <button id="prev-match" title="Previous match">&#9650;</button>
              <button id="next-match" title="Next match">&#9660;</button>
            </div>
            <button id="syntax-toggle" title="Toggle syntax highlighting">
              &lt;/&gt;
            </button>
            <button id="theme-toggle" title="Toggle theme">&#9788;</button>
            <button id="help-toggle" title="Keyboard shortcuts">?</button>
          </div>
        </header>
        <div id="viewport" tabindex="-1"></div>
      </main>
      <div id="help-modal" class="modal hidden">
        <div class="modal-content">
          <h2>Keyboard Shortcuts</h2>
          <dl>
            <dt>Ctrl+P</dt>
            <dd>Focus file search</dd>
            <dt>Ctrl+F</dt>
            <dd>Search in file</dd>
            <dt>Enter</dt>
            <dd>Next match</dd>
            <dt>Shift+Enter</dt>
            <dd>Previous match</dd>
            <dt>?</dt>
            <dd>Show this help</dd>
            <dt>Esc</dt>
            <dd>Close modal</dd>
          </dl>
          <h2>Permalinks</h2>
          <dl>
            <dt>Click line</dt>
            <dd>Select line, update URL</dd>
            <dt>Shift+Click</dt>
            <dd>Select line range</dd>
          </dl>
          <button id="close-help">Close</button>
        </div>
      </div>
    </div>
    <script>
      window.COVERAGE_DATA = {"files":[{"id":0,"path":"pkg/config/config.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","\t\"sync\"","","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/util/yaml\"","\t\"knative.dev/pkg/logging\"",")","","// following types are for internal use","","// PrunerResourceType is a string type used to represent different types of resources that the pruner manages","type PrunerResourceType string","","// PrunerFieldType is a string type used to represent different configuration types for pruner","type PrunerFieldType string","","// EnforcedConfigLevel is a string type to manage the different override levels allowed for Pruner config","type EnforcedConfigLevel string","","const (","\t// PrunerResourceTypePipelineRun represents the resource type for a PipelineRun in the pruner.","\tPrunerResourceTypePipelineRun PrunerResourceType = \"pipelineRun\"","","\t// PrunerResourceTypeTaskRun represents the resource type for a TaskRun in the pruner.","\tPrunerResourceTypeTaskRun PrunerResourceType = \"taskRun\"","","\t// PrunerFieldTypeTTLSecondsAfterFinished represents the field type for the TTL (Time-to-Live) in seconds after the resource is finished.","\tPrunerFieldTypeTTLSecondsAfterFinished PrunerFieldType = \"ttlSecondsAfterFinished\"","","\t// PrunerFieldTypeSuccessfulHistoryLimit represents the field type for the successful history limit of a resource.","\tPrunerFieldTypeSuccessfulHistoryLimit PrunerFieldType = \"successfulHistoryLimit\"","","\t// PrunerFieldTypeFailedHistoryLimit represents the field type for the failed history limit of a resource.","\tPrunerFieldTypeFailedHistoryLimit PrunerFieldType = \"failedHistoryLimit\"","","\t// EnforcedConfigLevelGlobal represents the cluster-wide config level for pruner.","\tEnforcedConfigLevelGlobal EnforcedConfigLevel = \"global\"","","\t// EnforcedConfigLevelNamespace represents the namespace config level for pruner.","\tEnforcedConfigLevelNamespace EnforcedConfigLevel = \"namespace\"","","\t// EnforcedConfigLevelResource represents the resource-level config for pruner.","\tEnforcedConfigLevelResource EnforcedConfigLevel = \"resource\"",")","","// ResourceSpec is used to hold the config of a specific resource","// Only used in namespace-level ConfigMaps (tekton-pruner-namespace-spec), NOT in global ConfigMaps","type ResourceSpec struct {","\tName         string         `yaml:\"name,omitempty\" json:\"name,omitempty\"`         // Exact name of the parent Pipeline or Task","\tSelector     []SelectorSpec `yaml:\"selector,omitempty\" json:\"selector,omitempty\"` // Supports selection based on labels and annotations. If Name is given, Name takes precedence","\tPrunerConfig `yaml:\",inline,omitempty\" json:\",inline,omitempty\"`","}","","// SelectorSpec allows specifying selectors for matching resources like PipelineRun or TaskRun","// Only applicable in namespace-level ConfigMaps, NOT in global ConfigMaps","type SelectorSpec struct {","\t// Match by labels AND annotations. If both are specified, BOTH must match (AND logic)","\tMatchLabels      map[string]string `yaml:\"matchLabels,omitempty\" json:\"matchLabels,omitempty\"`","\tMatchAnnotations map[string]string `yaml:\"matchAnnotations,omitempty\" json:\"matchAnnotations,omitempty\"`","}","","// NamespaceSpec is used to hold the pruning config of a specific namespace and its resources","// Used in both global ConfigMap (tekton-pruner-default-spec) and namespace ConfigMap (tekton-pruner-namespace-spec)","// Selector support (PipelineRuns/TaskRuns arrays) ONLY works in namespace ConfigMaps","type NamespaceSpec struct {","\tPrunerConfig `yaml:\",inline,omitempty\" json:\",inline,omitempty\"` // Root-level defaults","\tPipelineRuns []ResourceSpec                                      `yaml:\"pipelineRuns,omitempty\" json:\"pipelineRuns,omitempty\"` // Selector-based configs (namespace ConfigMap only)","\tTaskRuns     []ResourceSpec                                      `yaml:\"taskRuns,omitempty\" json:\"taskRuns,omitempty\"`         // Selector-based configs (namespace ConfigMap only)","}","","// GlobalConfig represents the global ConfigMap (tekton-pruner-default-spec)","// Root-level fields are defaults; Namespaces map is for per-namespace defaults","// NOTE: Selector support (PipelineRuns/TaskRuns arrays) is IGNORED in global ConfigMap","type GlobalConfig struct {","\tPrunerConfig `yaml:\",inline,omitempty\" json:\",inline,omitempty\"` // Global root-level defaults","\tNamespaces   map[string]NamespaceSpec                            `yaml:\"namespaces,omitempty\" json:\"namespaces,omitempty\"` // Per-namespace defaults (selectors ignored)","}","","// PrunerConfig used to hold the cluster-wide pruning config as well as namespace specific pruning config","type PrunerConfig struct {","\t// EnforcedConfigLevel allowed values: global, namespace (default: namespace)","\tEnforcedConfigLevel     *EnforcedConfigLevel `yaml:\"enforcedConfigLevel,omitempty\" json:\"enforcedConfigLevel,omitempty\"`","\tTTLSecondsAfterFinished *int32               `yaml:\"ttlSecondsAfterFinished,omitempty\" json:\"ttlSecondsAfterFinished,omitempty\"`","\tSuccessfulHistoryLimit  *int32               `yaml:\"successfulHistoryLimit,omitempty\" json:\"successfulHistoryLimit,omitempty\"`","\tFailedHistoryLimit      *int32               `yaml:\"failedHistoryLimit,omitempty\" json:\"failedHistoryLimit,omitempty\"`","\tHistoryLimit            *int32               `yaml:\"historyLimit,omitempty\" json:\"historyLimit,omitempty\"`","}","","// prunerConfigStore defines the store structure to hold config from ConfigMap","type prunerConfigStore struct {","\tmutex           sync.RWMutex","\tglobalConfig    GlobalConfig","\tnamespaceConfig map[string]NamespaceSpec // namespace -\u003e NamespaceSpec","}","","var (","\t// PrunerConfigStore is the singleton instance to store pruner config","\tPrunerConfigStore = prunerConfigStore{","\t\tmutex:           sync.RWMutex{},","\t\tnamespaceConfig: make(map[string]NamespaceSpec),","\t}",")","","// loads config from configMap (global-config) should be called on startup and if there is a change detected on the ConfigMap","func (ps *prunerConfigStore) LoadGlobalConfig(ctx context.Context, configMap *corev1.ConfigMap) error {","\tlogger := logging.FromContext(ctx)","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","","\t// Log the current state of globalConfig and namespacedConfig before updating","\tlogger.Debugw(\"Loading global config\", \"oldGlobalConfig\", ps.globalConfig)","","\tglobalConfig := \u0026GlobalConfig{}","\tif configMap.Data != nil \u0026\u0026 configMap.Data[PrunerGlobalConfigKey] != \"\" {","\t\terr := yaml.Unmarshal([]byte(configMap.Data[PrunerGlobalConfigKey]), globalConfig)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\tps.globalConfig = *globalConfig","","\tif ps.globalConfig.Namespaces == nil {","\t\tps.globalConfig.Namespaces = map[string]NamespaceSpec{}","\t}","","\t// Log the updated state of globalConfig and namespacedConfig after the update","\tlogger.Debugw(\"Updated global config\", \"newGlobalConfig\", ps.globalConfig)","","\treturn nil","}","","// LoadNamespaceConfig loads config from namespace-level ConfigMap","func (ps *prunerConfigStore) LoadNamespaceConfig(ctx context.Context, namespace string, configMap *corev1.ConfigMap) error {","\tlogger := logging.FromContext(ctx)","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","","\t// Log the current state before updating","\tlogger.Debugw(\"Loading namespace config\", \"namespace\", namespace, \"oldConfig\", ps.namespaceConfig[namespace])","","\tnamespaceSpec := NamespaceSpec{}","\tif configMap.Data != nil \u0026\u0026 configMap.Data[PrunerNamespaceConfigKey] != \"\" {","\t\terr := yaml.Unmarshal([]byte(configMap.Data[PrunerNamespaceConfigKey]), \u0026namespaceSpec)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t}","","\tps.namespaceConfig[namespace] = namespaceSpec","","\t// Log the updated state after the update","\tlogger.Debugw(\"Updated namespace config\", \"namespace\", namespace, \"newConfig\", ps.namespaceConfig[namespace])","","\treturn nil","}","","// DeleteNamespaceConfig removes namespace-level config from the store","func (ps *prunerConfigStore) DeleteNamespaceConfig(ctx context.Context, namespace string) {","\tlogger := logging.FromContext(ctx)","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","","\tlogger.Debugw(\"Deleting namespace config\", \"namespace\", namespace)","\tdelete(ps.namespaceConfig, namespace)","}","","// loads config from configMap (global-config) should be called on startup and if there is a change detected on the ConfigMap","func (ps *prunerConfigStore) WorkerCount(ctx context.Context, configMap *corev1.ConfigMap) (count int, err error) {","\tlogger := logging.FromContext(ctx)","","\t// Log the current state of globalConfig and namespacedConfig before updating","\tlogger.Debugw(\"get worker count to concurrently cleanup namesapces\", \"nsCleanupConcurrentWorkerCount\", configMap.Data[\"WorkerCountForNamespaceCleanup\"])","","\tif configMap.Data != nil \u0026\u0026 configMap.Data[\"WorkerCountForNamespaceCleanup\"] != \"\" {","\t\tcount, err = GetEnvValueAsInt(\"WorkerCountForNamespaceCleanup\", DefaultWorkerCountForNamespaceCleanup)","\t\tif err != nil {","\t\t\treturn 0, err","\t\t}","\t} else {","\t\tcount = DefaultWorkerCountForNamespaceCleanup","\t}","\tlogger.Debugw(\"get worker count to concurrently cleanup namesapces\", \"nsCleanupConcurrentWorkerCount\", count)","\treturn count, nil","}","","// getFromPrunerConfigResourceLevelwithSelector retrieves resource-level configuration using selectors","// This function is used ONLY for namespace-level ConfigMaps (tekton-pruner-namespace-spec), NOT global ConfigMaps","// Selector matching logic:","// - If 'name' is provided, it has absolute precedence (returns nil if no match, no fallback)","// - Otherwise, checks selector arrays (PipelineRuns/TaskRuns) for matches","// - When both matchLabels AND matchAnnotations are specified, BOTH must match (AND logic)","func getFromPrunerConfigResourceLevelwithSelector(namespacesSpec map[string]NamespaceSpec, namespace, name string, selector SelectorSpec, resourceType PrunerResourceType, fieldType PrunerFieldType) (*int32, string) {","\tprunerResourceSpec, found := namespacesSpec[namespace]","\tif !found {","\t\treturn nil, \"identifiedBy_global\"","\t}","","\tvar resourceSpecs []ResourceSpec","","\t// Select the right resource specs based on the resource type","\tswitch resourceType {","\tcase PrunerResourceTypePipelineRun:","\t\tresourceSpecs = prunerResourceSpec.PipelineRuns","\tcase PrunerResourceTypeTaskRun:","\t\tresourceSpecs = prunerResourceSpec.TaskRuns","\t}","","\t// First, check if name is provided, and use it to match exactly (absolute precedence)","\tif name != \"\" {","\t\tfor _, resourceSpec := range resourceSpecs {","\t\t\tif resourceSpec.Name == name {","\t\t\t\t// Return the field value from the matched resourceSpec","\t\t\t\tswitch fieldType {","\t\t\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\t\t\treturn resourceSpec.TTLSecondsAfterFinished, \"identifiedBy_resource_name\"","\t\t\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\t\t\treturn resourceSpec.SuccessfulHistoryLimit, \"identifiedBy_resource_name\"","\t\t\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\t\t\treturn resourceSpec.FailedHistoryLimit, \"identifiedBy_resource_name\"","\t\t\t\t}","\t\t\t}","\t\t}","\t\t// Name was specified but no match found - continue to selector matching","\t}","","\t// If name-based matching didn't succeed, proceed with selector matching","\tif len(selector.MatchAnnotations) \u003e 0 || len(selector.MatchLabels) \u003e 0 {","","\t\tfor _, resourceSpec := range resourceSpecs {","\t\t\t// Check if the resourceSpec matches the provided selector by annotations AND labels","\t\t\tfor _, selectorSpec := range resourceSpec.Selector {","\t\t\t\t// Both annotations and labels must match when both are specified (AND logic)","\t\t\t\t// The ConfigMap's selectorSpec defines the required labels/annotations to match","\t\t\t\t// The selector (from the PipelineRun/TaskRun) contains the actual labels/annotations","\t\t\t\tannotationsMatch := true","\t\t\t\tlabelsMatch := true","","\t\t\t\t// If ConfigMap's selectorSpec has matchAnnotations, check if resource has all of them","\t\t\t\tif len(selectorSpec.MatchAnnotations) \u003e 0 {","\t\t\t\t\tif len(selector.MatchAnnotations) == 0 {","\t\t\t\t\t\t// ConfigMap requires annotations but resource has none - no match","\t\t\t\t\t\tannotationsMatch = false","\t\t\t\t\t} else {","\t\t\t\t\t\t// Check if all ConfigMap's required annotations exist in resource","\t\t\t\t\t\tfor key, value := range selectorSpec.MatchAnnotations {","\t\t\t\t\t\t\tif resourceAnnotationValue, exists := selector.MatchAnnotations[key]; !exists || resourceAnnotationValue != value {","\t\t\t\t\t\t\t\tannotationsMatch = false","\t\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// If ConfigMap's selectorSpec has matchLabels, check if resource has all of them","\t\t\t\tif len(selectorSpec.MatchLabels) \u003e 0 {","\t\t\t\t\tif len(selector.MatchLabels) == 0 {","\t\t\t\t\t\t// ConfigMap requires labels but resource has none - no match","\t\t\t\t\t\tlabelsMatch = false","\t\t\t\t\t} else {","\t\t\t\t\t\t// Check if all ConfigMap's required labels exist in resource","\t\t\t\t\t\tfor key, value := range selectorSpec.MatchLabels {","\t\t\t\t\t\t\tif resourceLabelValue, exists := selector.MatchLabels[key]; !exists || resourceLabelValue != value {","\t\t\t\t\t\t\t\tlabelsMatch = false","\t\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// Only return if BOTH match (AND logic)","\t\t\t\tif annotationsMatch \u0026\u0026 labelsMatch {","\t\t\t\t\t// Return the field value if selectors match","\t\t\t\t\tswitch fieldType {","\t\t\t\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\t\t\t\treturn resourceSpec.TTLSecondsAfterFinished, \"identifiedBy_resource_selector\"","\t\t\t\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\t\t\t\tif resourceSpec.SuccessfulHistoryLimit != nil {","\t\t\t\t\t\t\treturn resourceSpec.SuccessfulHistoryLimit, \"identifiedBy_resource_selector\"","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\treturn resourceSpec.HistoryLimit, \"identifiedBy_resource_selector\"","\t\t\t\t\t\t}","\t\t\t\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\t\t\t\tif resourceSpec.FailedHistoryLimit != nil {","\t\t\t\t\t\t\treturn resourceSpec.FailedHistoryLimit, \"identifiedBy_resource_selector\"","\t\t\t\t\t\t} else {","\t\t\t\t\t\t\treturn resourceSpec.HistoryLimit, \"identifiedBy_resource_selector\"","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\t// If no match found, return nil","\treturn nil, \"\"","}","","// getMatchingSelectorFromConfig retrieves the ConfigMap's selector that matches a resource","func getMatchingSelectorFromConfig(namespacesSpec map[string]NamespaceSpec, namespace, name string, selector SelectorSpec, resourceType PrunerResourceType) *SelectorSpec {","\tprunerResourceSpec, found := namespacesSpec[namespace]","\tif !found {","\t\treturn nil","\t}","","\tvar resourceSpecs []ResourceSpec","\tswitch resourceType {","\tcase PrunerResourceTypePipelineRun:","\t\tresourceSpecs = prunerResourceSpec.PipelineRuns","\tcase PrunerResourceTypeTaskRun:","\t\tresourceSpecs = prunerResourceSpec.TaskRuns","\t}","","\tif len(selector.MatchAnnotations) == 0 \u0026\u0026 len(selector.MatchLabels) == 0 {","\t\treturn nil","\t}","","\tfor _, resourceSpec := range resourceSpecs {","\t\tfor _, selectorSpec := range resourceSpec.Selector {","\t\t\tannotationsMatch := true","\t\t\tlabelsMatch := true","","\t\t\tif len(selectorSpec.MatchAnnotations) \u003e 0 {","\t\t\t\tif len(selector.MatchAnnotations) == 0 {","\t\t\t\t\tannotationsMatch = false","\t\t\t\t} else {","\t\t\t\t\tfor key, value := range selectorSpec.MatchAnnotations {","\t\t\t\t\t\tif resourceAnnotationValue, exists := selector.MatchAnnotations[key]; !exists || resourceAnnotationValue != value {","\t\t\t\t\t\t\tannotationsMatch = false","\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\tif len(selectorSpec.MatchLabels) \u003e 0 {","\t\t\t\tif len(selector.MatchLabels) == 0 {","\t\t\t\t\tlabelsMatch = false","\t\t\t\t} else {","\t\t\t\t\tfor key, value := range selectorSpec.MatchLabels {","\t\t\t\t\t\tif resourceLabelValue, exists := selector.MatchLabels[key]; !exists || resourceLabelValue != value {","\t\t\t\t\t\t\tlabelsMatch = false","\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","","\t\t\tif annotationsMatch \u0026\u0026 labelsMatch {","\t\t\t\treturn \u0026selectorSpec","\t\t\t}","\t\t}","\t}","","\treturn nil","}","","// getResourceFieldData retrieves configuration field values based on enforcedConfigLevel","// Design principle: Selector support ONLY for namespace-level ConfigMaps, NOT global ConfigMaps","//","// Lookup hierarchy by enforcedConfigLevel:","//","// 1. EnforcedConfigLevelResource:","//   - Resource-level selector match (from global ConfigMap's Namespaces map)","//   - Namespace root-level (from global ConfigMap's Namespaces map)","//   - Global root-level defaults","//","// 2. EnforcedConfigLevelNamespace:","//   - Resource-level selector match (from namespace ConfigMap - NEW)","//   - Namespace root-level (from namespace ConfigMap)","//   - Namespace root-level (from global ConfigMap's Namespaces map)","//   - Global root-level defaults","//","// 3. EnforcedConfigLevelGlobal:","//   - Global root-level defaults ONLY (no selectors, no namespace lookup)","func getResourceFieldData(globalSpec GlobalConfig, namespaceConfigMap map[string]NamespaceSpec, namespace, name string, selector SelectorSpec, resourceType PrunerResourceType, fieldType PrunerFieldType, enforcedConfigLevel EnforcedConfigLevel) (*int32, string) {","\tvar fieldData *int32","\tvar identified_by string","","\tswitch enforcedConfigLevel {","\tcase EnforcedConfigLevelResource:","\t\t// First try resource level","\t\tfieldData, identified_by = getFromPrunerConfigResourceLevelwithSelector(globalSpec.Namespaces, namespace, name, selector, resourceType, fieldType)","\t\tif fieldData != nil {","\t\t\treturn fieldData, identified_by","\t\t}","\t\t// If no resource level config found, try namespace level","\t\tspec, found := globalSpec.Namespaces[namespace]","\t\tif found {","\t\t\tswitch fieldType {","\t\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\t\tfieldData = spec.TTLSecondsAfterFinished","","\t\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\t\tif spec.SuccessfulHistoryLimit != nil {","\t\t\t\t\tfieldData = spec.SuccessfulHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = spec.HistoryLimit","\t\t\t\t}","","\t\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\t\tif spec.FailedHistoryLimit != nil {","\t\t\t\t\tfieldData = spec.FailedHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = spec.HistoryLimit","\t\t\t\t}","\t\t\t}","\t\t\tidentified_by = \"identified_by_ns\"","\t\t} else {","\t\t\t// If no namespace level config found, try global level","\t\t\tswitch fieldType {","\t\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\t\tfieldData = globalSpec.TTLSecondsAfterFinished","","\t\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\t\tif globalSpec.SuccessfulHistoryLimit != nil {","\t\t\t\t\tfieldData = globalSpec.SuccessfulHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = globalSpec.HistoryLimit","\t\t\t\t}","","\t\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\t\tif globalSpec.FailedHistoryLimit != nil {","\t\t\t\t\tfieldData = globalSpec.FailedHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = globalSpec.HistoryLimit","\t\t\t\t}","\t\t\t}","\t\t\tidentified_by = \"identified_by_global\"","\t\t}","\t\treturn fieldData, identified_by","\tcase EnforcedConfigLevelNamespace:","\t\t// First check namespace-level ConfigMap (tekton-pruner-namespace-spec) for selector matches","\t\tfieldData, identified_by = getFromPrunerConfigResourceLevelwithSelector(namespaceConfigMap, namespace, name, selector, resourceType, fieldType)","\t\tif fieldData != nil {","\t\t\treturn fieldData, identified_by","\t\t}","","\t\t// Then check namespace-level ConfigMap root-level fields","\t\tnsSpec, found := namespaceConfigMap[namespace]","\t\tif found {","\t\t\tswitch fieldType {","\t\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\t\tfieldData = nsSpec.TTLSecondsAfterFinished","","\t\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\t\tif nsSpec.SuccessfulHistoryLimit != nil {","\t\t\t\t\tfieldData = nsSpec.SuccessfulHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = nsSpec.HistoryLimit","\t\t\t\t}","","\t\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\t\tif nsSpec.FailedHistoryLimit != nil {","\t\t\t\t\tfieldData = nsSpec.FailedHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = nsSpec.HistoryLimit","\t\t\t\t}","\t\t\t}","\t\t\tif fieldData != nil {","\t\t\t\tidentified_by = \"identified_by_ns_configmap\"","\t\t\t\treturn fieldData, identified_by","\t\t\t}","\t\t}","","\t\t// Fall back to global spec, namespace root level","\t\tspec, found := globalSpec.Namespaces[namespace]","\t\tif found {","\t\t\tswitch fieldType {","\t\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\t\tfieldData = spec.TTLSecondsAfterFinished","","\t\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\t\tif spec.SuccessfulHistoryLimit != nil {","\t\t\t\t\tfieldData = spec.SuccessfulHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = spec.HistoryLimit","\t\t\t\t}","","\t\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\t\tif spec.FailedHistoryLimit != nil {","\t\t\t\t\tfieldData = spec.FailedHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = spec.HistoryLimit","\t\t\t\t}","\t\t\t}","\t\t\tidentified_by = \"identified_by_ns\"","\t\t} else {","\t\t\t// If no namespace level config found, try global level","\t\t\tswitch fieldType {","\t\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\t\tfieldData = globalSpec.TTLSecondsAfterFinished","","\t\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\t\tif globalSpec.SuccessfulHistoryLimit != nil {","\t\t\t\t\tfieldData = globalSpec.SuccessfulHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = globalSpec.HistoryLimit","\t\t\t\t}","","\t\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\t\tif globalSpec.FailedHistoryLimit != nil {","\t\t\t\t\tfieldData = globalSpec.FailedHistoryLimit","\t\t\t\t} else {","\t\t\t\t\tfieldData = globalSpec.HistoryLimit","\t\t\t\t}","\t\t\t}","\t\t\tidentified_by = \"identified_by_global\"","\t\t}","\t\treturn fieldData, identified_by","","\tcase EnforcedConfigLevelGlobal:","\t\t// get it from global spec, root level","\t\tswitch fieldType {","\t\tcase PrunerFieldTypeTTLSecondsAfterFinished:","\t\t\tfieldData = globalSpec.TTLSecondsAfterFinished","","\t\tcase PrunerFieldTypeSuccessfulHistoryLimit:","\t\t\tif globalSpec.SuccessfulHistoryLimit != nil {","\t\t\t\tfieldData = globalSpec.SuccessfulHistoryLimit","\t\t\t} else {","\t\t\t\tfieldData = globalSpec.HistoryLimit","\t\t\t}","","\t\tcase PrunerFieldTypeFailedHistoryLimit:","\t\t\tif globalSpec.FailedHistoryLimit != nil {","\t\t\t\tfieldData = globalSpec.FailedHistoryLimit","\t\t\t} else {","\t\t\t\tfieldData = globalSpec.HistoryLimit","\t\t\t}","\t\t}","\t\tidentified_by = \"identified_by_global\"","\t}","","\treturn fieldData, identified_by","}","","func (ps *prunerConfigStore) GetEnforcedConfigLevelFromNamespaceSpec(namespacesSpec map[string]NamespaceSpec, namespace, name string, selector SelectorSpec, resourceType PrunerResourceType) *EnforcedConfigLevel {","\tvar enforcedConfigLevel *EnforcedConfigLevel","","\tnamespaceSpec, found := ps.globalConfig.Namespaces[namespace]","\tif !found {","\t\treturn nil","\t}","","\t// Get the appropriate resource specs based on type","\tvar resourceSpecs []ResourceSpec","\tswitch resourceType {","\tcase PrunerResourceTypePipelineRun:","\t\tresourceSpecs = namespaceSpec.PipelineRuns","\tcase PrunerResourceTypeTaskRun:","\t\tresourceSpecs = namespaceSpec.TaskRuns","\t}","","\t// Try to find resource level config first","\tif name != \"\" \u0026\u0026 (len(selector.MatchAnnotations) == 0 \u0026\u0026 len(selector.MatchLabels) == 0) {","\t\t// Search by exact name","\t\tfor _, resourceSpec := range resourceSpecs {","\t\t\tif resourceSpec.Name == name {","\t\t\t\tenforcedConfigLevel = resourceSpec.EnforcedConfigLevel","\t\t\t\tif enforcedConfigLevel != nil {","\t\t\t\t\treturn enforcedConfigLevel","\t\t\t\t}","\t\t\t\tbreak","\t\t\t}","\t\t}","\t} else if len(selector.MatchAnnotations) \u003e 0 || len(selector.MatchLabels) \u003e 0 {","\t\t// Search by selectors","\t\tfor _, resourceSpec := range resourceSpecs {","\t\t\tfor _, selectorSpec := range resourceSpec.Selector {","\t\t\t\tannotationsMatch := true","\t\t\t\tlabelsMatch := true","","\t\t\t\t// Check if ConfigMap's required annotations exist in the resource","\t\t\t\tif len(selectorSpec.MatchAnnotations) \u003e 0 {","\t\t\t\t\tif len(selector.MatchAnnotations) == 0 {","\t\t\t\t\t\t// ConfigMap requires annotations but resource has none - no match","\t\t\t\t\t\tannotationsMatch = false","\t\t\t\t\t} else {","\t\t\t\t\t\t// Check if all ConfigMap's required annotations exist in resource","\t\t\t\t\t\tfor key, value := range selectorSpec.MatchAnnotations {","\t\t\t\t\t\t\tif resourceAnnotationValue, exists := selector.MatchAnnotations[key]; !exists || resourceAnnotationValue != value {","\t\t\t\t\t\t\t\tannotationsMatch = false","\t\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// Check if ConfigMap's required labels exist in the resource","\t\t\t\tif len(selectorSpec.MatchLabels) \u003e 0 {","\t\t\t\t\tif len(selector.MatchLabels) == 0 {","\t\t\t\t\t\t// ConfigMap requires labels but resource has none - no match","\t\t\t\t\t\tlabelsMatch = false","\t\t\t\t\t} else {","\t\t\t\t\t\t// Check if all ConfigMap's required labels exist in resource","\t\t\t\t\t\tfor key, value := range selectorSpec.MatchLabels {","\t\t\t\t\t\t\tif resourceLabelValue, exists := selector.MatchLabels[key]; !exists || resourceLabelValue != value {","\t\t\t\t\t\t\t\tlabelsMatch = false","\t\t\t\t\t\t\t\tbreak","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t// Both annotations and labels must match (AND logic)","\t\t\t\tif annotationsMatch \u0026\u0026 labelsMatch {","\t\t\t\t\tenforcedConfigLevel = resourceSpec.EnforcedConfigLevel","\t\t\t\t\tif enforcedConfigLevel != nil {","\t\t\t\t\t\treturn enforcedConfigLevel","\t\t\t\t\t}","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\t// If no resource level config found or it was nil, return namespace level","\treturn namespaceSpec.EnforcedConfigLevel","}","","func (ps *prunerConfigStore) getEnforcedConfigLevel(namespace, name string, selector SelectorSpec, resourceType PrunerResourceType) EnforcedConfigLevel {","\tvar enforcedConfigLevel *EnforcedConfigLevel","","\t// get it from global spec (order: resource level, namespace root level)","\tenforcedConfigLevel = ps.GetEnforcedConfigLevelFromNamespaceSpec(ps.globalConfig.Namespaces, namespace, name, selector, resourceType)","\tif enforcedConfigLevel != nil {","\t\treturn *enforcedConfigLevel","\t}","","\t// get it from global spec, root level","\tenforcedConfigLevel = ps.globalConfig.EnforcedConfigLevel","\tif enforcedConfigLevel != nil {","\t\treturn *enforcedConfigLevel","\t}","","\t// default level, if no where specified","\treturn EnforcedConfigLevelResource","}","","func (ps *prunerConfigStore) GetPipelineEnforcedConfigLevel(namespace, name string, selector SelectorSpec) EnforcedConfigLevel {","\treturn ps.getEnforcedConfigLevel(namespace, name, selector, PrunerResourceTypePipelineRun)","}","","func (ps *prunerConfigStore) GetTaskEnforcedConfigLevel(namespace, name string, selector SelectorSpec) EnforcedConfigLevel {","\treturn ps.getEnforcedConfigLevel(namespace, name, selector, PrunerResourceTypeTaskRun)","}","","func (ps *prunerConfigStore) GetPipelineTTLSecondsAfterFinished(namespace, name string, selector SelectorSpec) (*int32, string) {","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","\tenforcedConfigLevel := ps.GetPipelineEnforcedConfigLevel(namespace, name, selector)","\treturn getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypePipelineRun, PrunerFieldTypeTTLSecondsAfterFinished, enforcedConfigLevel)","}","","func (ps *prunerConfigStore) GetPipelineSuccessHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) {","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","\tenforcedConfigLevel := ps.GetPipelineEnforcedConfigLevel(namespace, name, selector)","\treturn getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypePipelineRun, PrunerFieldTypeSuccessfulHistoryLimit, enforcedConfigLevel)","}","","func (ps *prunerConfigStore) GetPipelineFailedHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) {","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","\tenforcedConfigLevel := ps.GetPipelineEnforcedConfigLevel(namespace, name, selector)","\treturn getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypePipelineRun, PrunerFieldTypeFailedHistoryLimit, enforcedConfigLevel)","}","","func (ps *prunerConfigStore) GetTaskTTLSecondsAfterFinished(namespace, name string, selector SelectorSpec) (*int32, string) {","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","\tenforcedConfigLevel := ps.GetTaskEnforcedConfigLevel(namespace, name, selector)","\treturn getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypeTaskRun, PrunerFieldTypeTTLSecondsAfterFinished, enforcedConfigLevel)","}","","func (ps *prunerConfigStore) GetTaskSuccessHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) {","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","\tenforcedConfigLevel := ps.GetTaskEnforcedConfigLevel(namespace, name, selector)","\treturn getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypeTaskRun, PrunerFieldTypeSuccessfulHistoryLimit, enforcedConfigLevel)","}","","func (ps *prunerConfigStore) GetTaskFailedHistoryLimitCount(namespace, name string, selector SelectorSpec) (*int32, string) {","\tps.mutex.Lock()","\tdefer ps.mutex.Unlock()","\tenforcedConfigLevel := ps.GetTaskEnforcedConfigLevel(namespace, name, selector)","\treturn getResourceFieldData(ps.globalConfig, ps.namespaceConfig, namespace, name, selector, PrunerResourceTypeTaskRun, PrunerFieldTypeFailedHistoryLimit, enforcedConfigLevel)","}","","// GetPipelineMatchingSelector returns the ConfigMap's selector that matches a PipelineRun.","func (ps *prunerConfigStore) GetPipelineMatchingSelector(namespace, name string, selector SelectorSpec) *SelectorSpec {","\tps.mutex.RLock()","\tdefer ps.mutex.RUnlock()","\treturn getMatchingSelectorFromConfig(ps.namespaceConfig, namespace, name, selector, PrunerResourceTypePipelineRun)","}","","// GetTaskMatchingSelector returns the ConfigMap's selector that matches a TaskRun.","func (ps *prunerConfigStore) GetTaskMatchingSelector(namespace, name string, selector SelectorSpec) *SelectorSpec {","\tps.mutex.RLock()","\tdefer ps.mutex.RUnlock()","\treturn getMatchingSelectorFromConfig(ps.namespaceConfig, namespace, name, selector, PrunerResourceTypeTaskRun)","}","","// ValidateGlobalConfig validates a GlobalConfig struct directly without ConfigMap conversion","// This is a convenience function for validating global config and all nested namespace configs","// without the overhead of serialization/deserialization through ConfigMaps.","//","// Use this function when you have a GlobalConfig struct and want to validate it directly,","// for example when validating configuration from operator CRDs or other non-ConfigMap sources.","//","// For ConfigMap-based validation, use ValidateConfigMap or ValidateConfigMapWithGlobal instead.","func ValidateGlobalConfig(globalConfig *GlobalConfig) error {","\tif globalConfig == nil {","\t\treturn nil","\t}","","\t// Validate root-level global config","\tif err := validatePrunerConfig(\u0026globalConfig.PrunerConfig, \"global-config\", nil); err != nil {","\t\treturn err","\t}","","\t// Validate nested namespace configs","\t// These are validated against the global limits","\tfor ns, nsSpec := range globalConfig.Namespaces {","\t\tpath := fmt.Sprintf(\"global-config.namespaces.%s\", ns)","\t\tif err := validatePrunerConfig(\u0026nsSpec.PrunerConfig, path, \u0026globalConfig.PrunerConfig); err != nil {","\t\t\treturn err","\t\t}","","\t\t// CRITICAL: Validate that global ConfigMap namespace sections do NOT contain selectors","\t\t// Selectors are ONLY supported in namespace-level ConfigMaps (tekton-pruner-namespace-spec)","\t\tfor i, pr := range nsSpec.PipelineRuns {","\t\t\tif len(pr.Selector) \u003e 0 {","\t\t\t\treturn fmt.Errorf(\"%s.pipelineRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead\", path, i)","\t\t\t}","\t\t}","\t\tfor i, tr := range nsSpec.TaskRuns {","\t\t\tif len(tr.Selector) \u003e 0 {","\t\t\t\treturn fmt.Errorf(\"%s.taskRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead\", path, i)","\t\t\t}","\t\t}","\t}","","\treturn nil","}","","func ValidateConfigMap(cm *corev1.ConfigMap) error {","\treturn ValidateConfigMapWithGlobal(cm, nil)","}","","// ValidateConfigMapWithGlobal validates a ConfigMap with optional global config for limit enforcement","// If globalConfigMap is provided and cm is a namespace-level config, it validates that namespace","// limits do not exceed global limits","func ValidateConfigMapWithGlobal(cm *corev1.ConfigMap, globalConfigMap *corev1.ConfigMap) error {","\tif cm.Data == nil {","\t\treturn nil","\t}","","\t// Parse global config if validating a global ConfigMap","\tvar globalLimits *PrunerConfig","\tif cm.Data[PrunerGlobalConfigKey] != \"\" {","\t\tglobalConfig := \u0026GlobalConfig{}","\t\tif err := yaml.Unmarshal([]byte(cm.Data[PrunerGlobalConfigKey]), globalConfig); err != nil {","\t\t\treturn fmt.Errorf(\"failed to parse global-config: %w\", err)","\t\t}","\t\tif err := validatePrunerConfig(\u0026globalConfig.PrunerConfig, \"global-config\", nil); err != nil {","\t\t\treturn err","\t\t}","\t\t// Validate nested namespace configs within global config","\t\t// These are validated against the global limits","\t\tfor ns, nsSpec := range globalConfig.Namespaces {","\t\t\tif err := validatePrunerConfig(\u0026nsSpec.PrunerConfig, \"global-config.namespaces.\"+ns, \u0026globalConfig.PrunerConfig); err != nil {","\t\t\t\treturn err","\t\t\t}","","\t\t\t// CRITICAL: Validate that global ConfigMap namespace sections do NOT contain selectors","\t\t\t// Selectors are ONLY supported in namespace-level ConfigMaps (tekton-pruner-namespace-spec)","\t\t\tfor i, pr := range nsSpec.PipelineRuns {","\t\t\t\tif len(pr.Selector) \u003e 0 {","\t\t\t\t\treturn fmt.Errorf(\"global-config.namespaces.%s.pipelineRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead\", ns, i)","\t\t\t\t}","\t\t\t}","\t\t\tfor i, tr := range nsSpec.TaskRuns {","\t\t\t\tif len(tr.Selector) \u003e 0 {","\t\t\t\t\treturn fmt.Errorf(\"global-config.namespaces.%s.taskRuns[%d]: selectors are NOT supported in global ConfigMap. Use namespace-level ConfigMap (tekton-pruner-namespace-spec) instead\", ns, i)","\t\t\t\t}","\t\t\t}","\t\t}","\t\treturn nil","\t}","","\t// Parse and validate namespace config against global limits","\tif cm.Data[PrunerNamespaceConfigKey] != \"\" {","\t\tnamespaceConfig := \u0026NamespaceSpec{}","\t\tif err := yaml.Unmarshal([]byte(cm.Data[PrunerNamespaceConfigKey]), namespaceConfig); err != nil {","\t\t\treturn fmt.Errorf(\"failed to parse ns-config: %w\", err)","\t\t}","","\t\t// Extract global limits if global config is provided","\t\tif globalConfigMap != nil \u0026\u0026 globalConfigMap.Data != nil \u0026\u0026 globalConfigMap.Data[PrunerGlobalConfigKey] != \"\" {","\t\t\tglobalConfig := \u0026GlobalConfig{}","\t\t\tif err := yaml.Unmarshal([]byte(globalConfigMap.Data[PrunerGlobalConfigKey]), globalConfig); err != nil {","\t\t\t\t// If we can't parse global config, just do basic validation","\t\t\t\treturn validatePrunerConfig(\u0026namespaceConfig.PrunerConfig, \"ns-config\", nil)","\t\t\t}","\t\t\tglobalLimits = \u0026globalConfig.PrunerConfig","\t\t}","","\t\t// Validate namespace config, enforcing global limits if available","\t\tif err := validatePrunerConfig(\u0026namespaceConfig.PrunerConfig, \"ns-config\", globalLimits); err != nil {","\t\t\treturn err","\t\t}","","\t\t// Validate selector-based limits (sum of selectors must not exceed namespace/global limits)","\t\t// Extract namespace name from ConfigMap metadata","\t\tnamespace := cm.Namespace","\t\tvar globalNamespaceSpec *NamespaceSpec","\t\tif globalConfigMap != nil \u0026\u0026 globalConfigMap.Data != nil \u0026\u0026 globalConfigMap.Data[PrunerGlobalConfigKey] != \"\" {","\t\t\tglobalConfig := \u0026GlobalConfig{}","\t\t\tif err := yaml.Unmarshal([]byte(globalConfigMap.Data[PrunerGlobalConfigKey]), globalConfig); err == nil {","\t\t\t\tif nsSpec, exists := globalConfig.Namespaces[namespace]; exists {","\t\t\t\t\tglobalNamespaceSpec = \u0026nsSpec","\t\t\t\t}","\t\t\t\t// Pass both globalConfig and globalNamespaceSpec for 4-tier hierarchy","\t\t\t\tif err := validateSelectorLimits(namespaceConfig, \u0026globalConfig.PrunerConfig, globalNamespaceSpec, namespace); err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t}","\t\t} else {","\t\t\t// No global config, validate with system maximum only","\t\t\tif err := validateSelectorLimits(namespaceConfig, nil, nil, namespace); err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t}","\t}","","\treturn nil","}","","// ValidateNamespaceSpec validates a NamespaceSpec struct directly without ConfigMap conversion","// This function validates namespace-level configuration against optional global limits.","//","// Parameters:","//   - namespaceSpec: The namespace configuration to validate","//   - namespace: The namespace name (used for error messages)","//   - globalConfig: Optional global config for limit enforcement (can be nil)","//","// Use this function when you have a NamespaceSpec struct and want to validate it directly,","// for example when validating configuration from operator CRDs or other non-ConfigMap sources.","//","// For ConfigMap-based validation, use ValidateConfigMapWithGlobal instead.","func ValidateNamespaceSpec(namespaceSpec *NamespaceSpec, namespace string, globalConfig *GlobalConfig) error {","\tif namespaceSpec == nil {","\t\treturn nil","\t}","","\tvar globalLimits *PrunerConfig","\tvar globalNamespaceSpec *NamespaceSpec","","\t// Extract global limits if provided","\tif globalConfig != nil {","\t\tglobalLimits = \u0026globalConfig.PrunerConfig","\t\t// Check if there's a namespace-specific override in global config","\t\tif nsSpec, exists := globalConfig.Namespaces[namespace]; exists {","\t\t\tglobalNamespaceSpec = \u0026nsSpec","\t\t}","\t}","","\t// Validate namespace config, enforcing global limits if available","\tif err := validatePrunerConfig(\u0026namespaceSpec.PrunerConfig, \"ns-config\", globalLimits); err != nil {","\t\treturn err","\t}","","\t// Validate selector-based limits (sum of selectors must not exceed namespace/global limits)","\tif err := validateSelectorLimits(namespaceSpec, globalLimits, globalNamespaceSpec, namespace); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","// validatePrunerConfig validates the fields of a PrunerConfig","// If globalConfig is provided, namespace-level settings are validated to not exceed global limits","// If globalConfig is nil and path indicates a namespace config, system maximums are enforced","func validatePrunerConfig(config *PrunerConfig, path string, globalConfig *PrunerConfig) error {","\tif config == nil {","\t\treturn nil","\t}","","\t// Determine if this is a namespace-level config validation (not a top-level global config)","\t// Namespace configs can be:","\t// - Standalone: path starts with \"ns-config\"","\t// - Nested in global: path contains \".namespaces.\"","\tisNamespaceConfig := strings.HasPrefix(path, \"ns-config\") || strings.Contains(path, \".namespaces.\")","","\t// Validate EnforcedConfigLevel","\tif config.EnforcedConfigLevel != nil {","\t\tlevel := *config.EnforcedConfigLevel","\t\tif level != EnforcedConfigLevelGlobal \u0026\u0026","\t\t\tlevel != EnforcedConfigLevelNamespace \u0026\u0026","\t\t\tlevel != EnforcedConfigLevelResource {","\t\t\treturn fmt.Errorf(\"%s: invalid enforcedConfigLevel '%s', must be one of: global, namespace, resource\", path, level)","\t\t}","\t}","","\t// Validate TTLSecondsAfterFinished","\tif config.TTLSecondsAfterFinished != nil {","\t\tif *config.TTLSecondsAfterFinished \u003c 0 {","\t\t\treturn fmt.Errorf(\"%s: ttlSecondsAfterFinished cannot be negative, got %d\", path, *config.TTLSecondsAfterFinished)","\t\t}","\t\t// Namespace config cannot have longer TTL than global config","\t\tif globalConfig != nil \u0026\u0026 globalConfig.TTLSecondsAfterFinished != nil {","\t\t\tif *config.TTLSecondsAfterFinished \u003e *globalConfig.TTLSecondsAfterFinished {","\t\t\t\treturn fmt.Errorf(\"%s: ttlSecondsAfterFinished (%d) cannot exceed global limit (%d)\",","\t\t\t\t\tpath, *config.TTLSecondsAfterFinished, *globalConfig.TTLSecondsAfterFinished)","\t\t\t}","\t\t} else if isNamespaceConfig \u0026\u0026 (globalConfig == nil || globalConfig.TTLSecondsAfterFinished == nil) {","\t\t\t// If this is a namespace config and no global limit is set, enforce system maximum","\t\t\tif *config.TTLSecondsAfterFinished \u003e MaxTTLSecondsAfterFinished {","\t\t\t\treturn fmt.Errorf(\"%s: ttlSecondsAfterFinished (%d) cannot exceed system maximum (%d seconds / 30 days)\",","\t\t\t\t\tpath, *config.TTLSecondsAfterFinished, MaxTTLSecondsAfterFinished)","\t\t\t}","\t\t}","\t}","","\t// Validate SuccessfulHistoryLimit","\tif config.SuccessfulHistoryLimit != nil {","\t\tif *config.SuccessfulHistoryLimit \u003c 0 {","\t\t\treturn fmt.Errorf(\"%s: successfulHistoryLimit cannot be negative, got %d\", path, *config.SuccessfulHistoryLimit)","\t\t}","\t\t// For namespace configs, determine the upper limit based on global config","\t\tif isNamespaceConfig \u0026\u0026 globalConfig != nil {","\t\t\t// Priority 1: Use global successfulHistoryLimit if set","\t\t\tif globalConfig.SuccessfulHistoryLimit != nil {","\t\t\t\tif *config.SuccessfulHistoryLimit \u003e *globalConfig.SuccessfulHistoryLimit {","\t\t\t\t\treturn fmt.Errorf(\"%s: successfulHistoryLimit (%d) cannot exceed global limit (%d)\",","\t\t\t\t\t\tpath, *config.SuccessfulHistoryLimit, *globalConfig.SuccessfulHistoryLimit)","\t\t\t\t}","\t\t\t} else if globalConfig.HistoryLimit != nil {","\t\t\t\t// Priority 2: Use global historyLimit as fallback if no granular limit","\t\t\t\tif *config.SuccessfulHistoryLimit \u003e *globalConfig.HistoryLimit {","\t\t\t\t\treturn fmt.Errorf(\"%s: successfulHistoryLimit (%d) cannot exceed global historyLimit (%d)\",","\t\t\t\t\t\tpath, *config.SuccessfulHistoryLimit, *globalConfig.HistoryLimit)","\t\t\t\t}","\t\t\t} else {","\t\t\t\t// Priority 3: Use system maximum if global config exists but has no relevant limits","\t\t\t\tif *config.SuccessfulHistoryLimit \u003e MaxHistoryLimit {","\t\t\t\t\treturn fmt.Errorf(\"%s: successfulHistoryLimit (%d) cannot exceed system maximum (%d)\",","\t\t\t\t\t\tpath, *config.SuccessfulHistoryLimit, MaxHistoryLimit)","\t\t\t\t}","\t\t\t}","\t\t} else if isNamespaceConfig \u0026\u0026 globalConfig == nil {","\t\t\t// Priority 3: Use system maximum if no global config at all","\t\t\tif *config.SuccessfulHistoryLimit \u003e MaxHistoryLimit {","\t\t\t\treturn fmt.Errorf(\"%s: successfulHistoryLimit (%d) cannot exceed system maximum (%d)\",","\t\t\t\t\tpath, *config.SuccessfulHistoryLimit, MaxHistoryLimit)","\t\t\t}","\t\t}","\t}","","\t// Validate FailedHistoryLimit","\tif config.FailedHistoryLimit != nil {","\t\tif *config.FailedHistoryLimit \u003c 0 {","\t\t\treturn fmt.Errorf(\"%s: failedHistoryLimit cannot be negative, got %d\", path, *config.FailedHistoryLimit)","\t\t}","\t\t// For namespace configs, determine the upper limit based on global config","\t\tif isNamespaceConfig \u0026\u0026 globalConfig != nil {","\t\t\t// Priority 1: Use global failedHistoryLimit if set","\t\t\tif globalConfig.FailedHistoryLimit != nil {","\t\t\t\tif *config.FailedHistoryLimit \u003e *globalConfig.FailedHistoryLimit {","\t\t\t\t\treturn fmt.Errorf(\"%s: failedHistoryLimit (%d) cannot exceed global limit (%d)\",","\t\t\t\t\t\tpath, *config.FailedHistoryLimit, *globalConfig.FailedHistoryLimit)","\t\t\t\t}","\t\t\t} else if globalConfig.HistoryLimit != nil {","\t\t\t\t// Priority 2: Use global historyLimit as fallback if no granular limit","\t\t\t\tif *config.FailedHistoryLimit \u003e *globalConfig.HistoryLimit {","\t\t\t\t\treturn fmt.Errorf(\"%s: failedHistoryLimit (%d) cannot exceed global historyLimit (%d)\",","\t\t\t\t\t\tpath, *config.FailedHistoryLimit, *globalConfig.HistoryLimit)","\t\t\t\t}","\t\t\t} else {","\t\t\t\t// Priority 3: Use system maximum if global config exists but has no relevant limits","\t\t\t\tif *config.FailedHistoryLimit \u003e MaxHistoryLimit {","\t\t\t\t\treturn fmt.Errorf(\"%s: failedHistoryLimit (%d) cannot exceed system maximum (%d)\",","\t\t\t\t\t\tpath, *config.FailedHistoryLimit, MaxHistoryLimit)","\t\t\t\t}","\t\t\t}","\t\t} else if isNamespaceConfig \u0026\u0026 globalConfig == nil {","\t\t\t// Priority 3: Use system maximum if no global config at all","\t\t\tif *config.FailedHistoryLimit \u003e MaxHistoryLimit {","\t\t\t\treturn fmt.Errorf(\"%s: failedHistoryLimit (%d) cannot exceed system maximum (%d)\",","\t\t\t\t\tpath, *config.FailedHistoryLimit, MaxHistoryLimit)","\t\t\t}","\t\t}","\t}","","\t// Validate HistoryLimit","\tif config.HistoryLimit != nil {","\t\tif *config.HistoryLimit \u003c 0 {","\t\t\treturn fmt.Errorf(\"%s: historyLimit cannot be negative, got %d\", path, *config.HistoryLimit)","\t\t}","\t\t// For namespace configs, validate against global historyLimit","\t\tif isNamespaceConfig \u0026\u0026 globalConfig != nil \u0026\u0026 globalConfig.HistoryLimit != nil {","\t\t\tif *config.HistoryLimit \u003e *globalConfig.HistoryLimit {","\t\t\t\treturn fmt.Errorf(\"%s: historyLimit (%d) cannot exceed global limit (%d)\",","\t\t\t\t\tpath, *config.HistoryLimit, *globalConfig.HistoryLimit)","\t\t\t}","\t\t} else if isNamespaceConfig \u0026\u0026 (globalConfig == nil || globalConfig.HistoryLimit == nil) {","\t\t\t// Use system maximum if no global historyLimit is set","\t\t\tif *config.HistoryLimit \u003e MaxHistoryLimit {","\t\t\t\treturn fmt.Errorf(\"%s: historyLimit (%d) cannot exceed system maximum (%d)\",","\t\t\t\t\tpath, *config.HistoryLimit, MaxHistoryLimit)","\t\t\t}","\t\t}","\t}","","\treturn nil","}","","// validateSelectorLimits validates that the sum of selector-based limits does not exceed the allowed upper bound","// Uses a 4-tier hierarchy to determine the upper bound:","// 1. Namespace-level spec (in the same namespace config)","// 2. Global namespace override (from global.namespaces[namespace])","// 3. Global default spec","// 4. System maximum","func validateSelectorLimits(nsConfig *NamespaceSpec, globalConfig *PrunerConfig, globalNsSpec *NamespaceSpec, namespace string) error {","\tif nsConfig == nil {","\t\treturn nil","\t}","","\t// Validate PipelineRuns selectors","\tif err := validateResourceSelectorLimits(nsConfig.PipelineRuns, \u0026nsConfig.PrunerConfig, globalConfig, globalNsSpec, namespace, \"pipelineRuns\"); err != nil {","\t\treturn err","\t}","","\t// Validate TaskRuns selectors","\tif err := validateResourceSelectorLimits(nsConfig.TaskRuns, \u0026nsConfig.PrunerConfig, globalConfig, globalNsSpec, namespace, \"taskRuns\"); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","// validateResourceSelectorLimits validates selector limits for a specific resource type (PipelineRuns or TaskRuns)","func validateResourceSelectorLimits(resources []ResourceSpec, nsConfig *PrunerConfig, globalConfig *PrunerConfig, globalNsSpec *NamespaceSpec, namespace, resourceType string) error {","\tif len(resources) == 0 {","\t\treturn nil","\t}","","\t// Calculate sum of selector-based limits for each limit type","\tvar sumSuccessful, sumFailed, sumHistory int32","","\tfor i, resource := range resources {","\t\t// Only count resources that have selectors (not name-based)","\t\tif len(resource.Selector) \u003e 0 {","\t\t\tif resource.SuccessfulHistoryLimit != nil {","\t\t\t\tsumSuccessful += *resource.SuccessfulHistoryLimit","\t\t\t}","\t\t\tif resource.FailedHistoryLimit != nil {","\t\t\t\tsumFailed += *resource.FailedHistoryLimit","\t\t\t}","\t\t\tif resource.HistoryLimit != nil {","\t\t\t\tsumHistory += *resource.HistoryLimit","\t\t\t}","\t\t}","","\t\t// Validate individual selector limits are non-negative","\t\tif resource.SuccessfulHistoryLimit != nil \u0026\u0026 *resource.SuccessfulHistoryLimit \u003c 0 {","\t\t\treturn fmt.Errorf(\"ns-config.%s[%d]: successfulHistoryLimit cannot be negative, got %d\", resourceType, i, *resource.SuccessfulHistoryLimit)","\t\t}","\t\tif resource.FailedHistoryLimit != nil \u0026\u0026 *resource.FailedHistoryLimit \u003c 0 {","\t\t\treturn fmt.Errorf(\"ns-config.%s[%d]: failedHistoryLimit cannot be negative, got %d\", resourceType, i, *resource.FailedHistoryLimit)","\t\t}","\t\tif resource.HistoryLimit != nil \u0026\u0026 *resource.HistoryLimit \u003c 0 {","\t\t\treturn fmt.Errorf(\"ns-config.%s[%d]: historyLimit cannot be negative, got %d\", resourceType, i, *resource.HistoryLimit)","\t\t}","\t}","","\t// Validate successfulHistoryLimit sum","\tif sumSuccessful \u003e 0 {","\t\tupperBound := determineUpperBound(nsConfig.SuccessfulHistoryLimit, nsConfig.HistoryLimit,","\t\t\tglobalNsSpec, globalConfig, \"successfulHistoryLimit\")","\t\tif sumSuccessful \u003e upperBound {","\t\t\treturn fmt.Errorf(\"namespace '%s' ns-config.%s: sum of selector successfulHistoryLimit (%d) cannot exceed upper bound (%d)\",","\t\t\t\tnamespace, resourceType, sumSuccessful, upperBound)","\t\t}","\t}","","\t// Validate failedHistoryLimit sum","\tif sumFailed \u003e 0 {","\t\tupperBound := determineUpperBound(nsConfig.FailedHistoryLimit, nsConfig.HistoryLimit,","\t\t\tglobalNsSpec, globalConfig, \"failedHistoryLimit\")","\t\tif sumFailed \u003e upperBound {","\t\t\treturn fmt.Errorf(\"namespace '%s' ns-config.%s: sum of selector failedHistoryLimit (%d) cannot exceed upper bound (%d)\",","\t\t\t\tnamespace, resourceType, sumFailed, upperBound)","\t\t}","\t}","","\t// Validate historyLimit sum","\tif sumHistory \u003e 0 {","\t\tupperBound := determineUpperBound(nsConfig.HistoryLimit, nil,","\t\t\tglobalNsSpec, globalConfig, \"historyLimit\")","\t\tif sumHistory \u003e upperBound {","\t\t\treturn fmt.Errorf(\"namespace '%s' ns-config.%s: sum of selector historyLimit (%d) cannot exceed upper bound (%d)\",","\t\t\t\tnamespace, resourceType, sumHistory, upperBound)","\t\t}","\t}","","\treturn nil","}","","// determineUpperBound implements the 4-tier hierarchy to find the upper bound for selector validation","// limitType should be \"successfulHistoryLimit\", \"failedHistoryLimit\", or \"historyLimit\"","func determineUpperBound(nsGranularLimit, nsHistoryLimit *int32, globalNsSpec *NamespaceSpec, globalConfig *PrunerConfig, limitType string) int32 {","\t// Level 1: Namespace-level spec (most specific)","\tif nsGranularLimit != nil \u0026\u0026 limitType != \"historyLimit\" {","\t\treturn *nsGranularLimit","\t}","\tif limitType != \"historyLimit\" \u0026\u0026 nsHistoryLimit != nil {","\t\t// For granular limits, fallback to namespace historyLimit if granular not set","\t\treturn *nsHistoryLimit","\t}","\tif limitType == \"historyLimit\" \u0026\u0026 nsHistoryLimit != nil {","\t\treturn *nsHistoryLimit","\t}","","\t// Level 2: Global namespace override (from global.namespaces[namespace])","\tif globalNsSpec != nil {","\t\tswitch limitType {","\t\tcase \"successfulHistoryLimit\":","\t\t\tif globalNsSpec.SuccessfulHistoryLimit != nil {","\t\t\t\treturn *globalNsSpec.SuccessfulHistoryLimit","\t\t\t}","\t\t\t// Fallback to globalNsSpec.HistoryLimit","\t\t\tif globalNsSpec.HistoryLimit != nil {","\t\t\t\treturn *globalNsSpec.HistoryLimit","\t\t\t}","\t\tcase \"failedHistoryLimit\":","\t\t\tif globalNsSpec.FailedHistoryLimit != nil {","\t\t\t\treturn *globalNsSpec.FailedHistoryLimit","\t\t\t}","\t\t\t// Fallback to globalNsSpec.HistoryLimit","\t\t\tif globalNsSpec.HistoryLimit != nil {","\t\t\t\treturn *globalNsSpec.HistoryLimit","\t\t\t}","\t\tcase \"historyLimit\":","\t\t\tif globalNsSpec.HistoryLimit != nil {","\t\t\t\treturn *globalNsSpec.HistoryLimit","\t\t\t}","\t\t}","\t}","","\t// Level 3: Global default spec","\tif globalConfig != nil {","\t\tswitch limitType {","\t\tcase \"successfulHistoryLimit\":","\t\t\tif globalConfig.SuccessfulHistoryLimit != nil {","\t\t\t\treturn *globalConfig.SuccessfulHistoryLimit","\t\t\t}","\t\t\t// Fallback to globalConfig.HistoryLimit","\t\t\tif globalConfig.HistoryLimit != nil {","\t\t\t\treturn *globalConfig.HistoryLimit","\t\t\t}","\t\tcase \"failedHistoryLimit\":","\t\t\tif globalConfig.FailedHistoryLimit != nil {","\t\t\t\treturn *globalConfig.FailedHistoryLimit","\t\t\t}","\t\t\t// Fallback to globalConfig.HistoryLimit","\t\t\tif globalConfig.HistoryLimit != nil {","\t\t\t\treturn *globalConfig.HistoryLimit","\t\t\t}","\t\tcase \"historyLimit\":","\t\t\tif globalConfig.HistoryLimit != nil {","\t\t\t\treturn *globalConfig.HistoryLimit","\t\t\t}","\t\t}","\t}","","\t// Level 4: System maximum","\treturn int32(MaxHistoryLimit)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,1,1,0,0,0,2,2,2,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,2,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,1,0,2,2,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,2,2,2,2,2,0,2,2,2,2,1,1,0,1,1,1,1,1,1,0,2,0,2,2,2,2,2,2,2,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,2,2,2,2,2,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,2,0,0,2,0,0,2,2,2,2,2,2,2,0,0,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,1,0,0,2,2,2,2,2,2,1,1,0,0,2,2,1,1,0,0,2,0,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,0,2,2,2,2,2,2,0,2,2,2,2,2,2,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,2,0,0,0,2,2,2,2,0,2,1,1,1,0,0,0,2,0,0,2,2,2,0,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,0,2,2,2,2,0,2,2,2,2,0,0,2,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,0,2,2,2,2,2,2,1,1,0,2,1,1,0,2,2,2,1,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,0,0,0,2,2,2,0,0,2,2,2,0,2,0,0,0,0,0,2,2,1,1,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,1,0,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,1,0,0,0,2,0,0,0,0,0,0,0,0,2,2,1,1,0,0,2,2,2,0,0,2,1,1,0,2,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,1,1,2,1,1,0,0,0,2,1,1,2,1,1,2,1,1,0,0,0,2,2,2,2,2,2,2,0,0,0,2,1,1,1,1,1,1,0,0,0,2,1,1,1,1,1,1,0,0,2,0,0,0,0,2,2,2,2,2,2,1,1,1,2,1,1,0,0,2,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,2,1,1,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,2,0]},{"id":1,"path":"pkg/config/config_defaults.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import \"knative.dev/pkg/ptr\"","","func (pc *PrunerConfig) SetDefaults() {","\tif pc.HistoryLimit == nil {","\t\tpc.HistoryLimit = ptr.Int32(DefaultHistoryLimit)","\t}","\tif pc.EnforcedConfigLevel == nil {","\t\tv := EnforcedConfigLevelGlobal","\t\tpc.EnforcedConfigLevel = \u0026v","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0]},{"id":2,"path":"pkg/config/constants.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"fmt\"","\t\"os\"","\t\"strconv\"",")","","const (","\t// EnvSystemNamespace is the environment variable name used to define the system namespace","\t// it is used for setting the namespace where pruner-related resources are managed","\tEnvSystemNamespace = \"SYSTEM_NAMESPACE\"","","\t// EnvTTLConcurrentWorkersPipelineRun is the environment variable name","\t// used to specify the count of concurrent workers in action to prune pipelineruns","\tEnvTTLConcurrentWorkersPipelineRun = \"TTL_CONCURRENT_WORKERS_PIPELINE_RUN\"","","\t// EnvTTLConcurrentWorkersTaskRun is the environment variable name","\t// used to specify the count of concurrent workers in action to prune taskruns","\tEnvTTLConcurrentWorkersTaskRun = \"TTL_CONCURRENT_WORKERS_TASK_RUN\"","","\t// LabelPipelineName represents the label key in a pipeline run's metadata,","\t// where its value corresponds to the name of the pipeline","\tLabelPipelineName = \"tekton.dev/pipeline\"","","\t// LabelPipelineRunName represents the label key in a pipeline run's metadata,","\t// where its value corresponds to the name of the pipeline run","\tLabelPipelineRunName = \"tekton.dev/pipelineRun\"","","\t// LabelTaskName represents the label key in a task run's metadata,","\t// where its value corresponds to the name of the task","\tLabelTaskName = \"tekton.dev/task\"","","\t// LabelTaskRunName represents the label key in a task run's metadata,","\t// where its value corresponds to the name of the task run","\tLabelTaskRunName = \"tekton.dev/taskRun\"","","\t// KindPipelineRun represents the kind value of pipelineRun custom resource","\tKindPipelineRun = \"PipelineRun\"","","\t// KindTaskRun represents the kind value of taskRun custom resource","\tKindTaskRun = \"TaskRun\"","","\t// AnnotationTTLSecondsAfterFinished represents the annotation key","\t// that stores the ttlSecondsAfterFinished value for the resource.","\tAnnotationTTLSecondsAfterFinished = \"pruner.tekton.dev/ttlSecondsAfterFinished\"","","\t// AnnotationResourceNameLabelKey represents the annotation key","\t// that stores the label key value used to uniquely identify the resource.","\tAnnotationResourceNameLabelKey = \"pruner.tekton.dev/resourceNameLabelKey\"","","\t// AnnotationSuccessfulHistoryLimit represents the annotation key","\t// that stores the successfulHistoryLimit value for the resource.","\tAnnotationSuccessfulHistoryLimit = \"pruner.tekton.dev/successfulHistoryLimit\"","","\t// AnnotationFailedHistoryLimit represents the annotation key","\t// that stores the failedHistoryLimit value for the resource.","\tAnnotationFailedHistoryLimit = \"pruner.tekton.dev/failedHistoryLimit\"","","\t// AnnotationHistoryLimitCheckProcessed represents the annotation key","\t// that indicates whether history limit checks have been processed for the resource.","\tAnnotationHistoryLimitCheckProcessed = \"pruner.tekton.dev/historyLimitCheckProcessed\"","","\t// PrunerConfigMapName represents the name of the config map","\t// that holds the cluster-wide pruner configuration data","\tPrunerConfigMapName = \"tekton-pruner-default-spec\"","","\t// PrunerNamespaceConfigMapName represents the name of the config map","\t// that holds the namespace-level pruner configuration data","\tPrunerNamespaceConfigMapName = \"tekton-pruner-namespace-spec\"","","\t// PrunerGlobalConfigKey represents the key name","\t// used to fetch the cluster-wide pruner configuration data","\tPrunerGlobalConfigKey = \"global-config\"","","\t// PrunerNamespaceConfigKey represents the key name","\t// used to fetch the namespace-level pruner configuration data","\tPrunerNamespaceConfigKey = \"ns-config\"","","\t// DefaultTTLConcurrentWorkersPipelineRun represents","\t// number of workers in the PipelineRun controller","\tDefaultTTLConcurrentWorkersPipelineRun = int(5)","","\t// DefaultTTLConcurrentWorkersTaskRun represents","\t// number of workers in the TaskRun controller","\tDefaultTTLConcurrentWorkersTaskRun = int(5)","","\t// DefaultGCInterval represents","\t// interval in seconds for the periodic cleanup i.e garbage collector to run","\tDefaultPeriodicCleanupIntervalSeconds = 600 // 10 minutes","","\t// DefaultWorkerCountForNamespaceCleanup represents\tthe number of workers to be used","\t// for cleaning up resources in a namespace concurrently","\tDefaultWorkerCountForNamespaceCleanup = 5","","\t// DefaultHistoryLimit represents the default history limit for successful and failed resources","\tDefaultHistoryLimit = 100","","\t// MaxTTLSecondsAfterFinished represents the maximum TTL in seconds that can be set","\t// when no explicit global limit is defined. This is 30 days (2,592,000 seconds)","\tMaxTTLSecondsAfterFinished = 2592000","","\t// MaxHistoryLimit represents the maximum history limit that can be set","\t// when no explicit global limit is defined for history-based retention","\tMaxHistoryLimit = 100",")","","// GetEnvValueAsInt fetches the value of an environment variable and converts it to an integer","// if the environment variable is not set or if the conversion fails, it returns a default value","func GetEnvValueAsInt(envKey string, defaultValue int) (int, error) {","\tstrValue := os.Getenv(envKey)","\tif strValue == \"\" {","\t\t// If the environment variable is not set, return the default value","\t\treturn defaultValue, nil","\t}","","\t// Try to convert the string to an integer","\tintValue, err := strconv.Atoi(strValue)","\tif err != nil {","\t\t// If conversion fails, return an error with context.","\t\treturn 0, fmt.Errorf(\"failed to convert value of %s to int: %w\", envKey, err)","\t}","","\treturn intValue, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0]},{"id":3,"path":"pkg/config/helper.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"strings\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","// common functions used across history limiter and ttl handler","","func getResourceNameLabelKey(resource metav1.Object, defaultLabelKey string) string {","\tannotations := resource.GetAnnotations()","\t// update user defined label key","\tif len(annotations) \u003e 0 \u0026\u0026 annotations[AnnotationResourceNameLabelKey] != \"\" {","\t\tdefaultLabelKey = annotations[AnnotationResourceNameLabelKey]","\t}","","\treturn defaultLabelKey","}","","func getResourceName(resource metav1.Object, labelKey string) string {","\tlabels := resource.GetLabels()","\t// if there is no label present, no option to filter","\tif len(labels) == 0 {","\t\treturn \"\"","\t}","","\t// get label value","\treturn labels[labelKey]","}","","/*","// getResourceNameFromMatch returns the resource name for a resource based on annotations first, then labels.","// If all annotations match or if all labels match, it returns the value of the \"tekton.dev/pipelineRun\" or \"tekton.dev/taskRun\" label else none","func getResourceNameFromMatch(resource metav1.Object, matchAnnotations map[string]string, matchLabels map[string]string, defaultLabelKey string) string {","\tvar annotationsMatch bool","\tvar labelsMatch bool","\tvar runName string","","\tlabels := resource.GetLabels()","","\t// If matchAnnotations is not null or empty, process annotations","\tif len(matchAnnotations) \u003e 0 {","\t\tannotations := resource.GetAnnotations()","\t\tif len(annotations) \u003e 0 { // Check if the resource has annotations","\t\t\t// Ensure all annotations in matchAnnotations exist in the resource annotations","\t\t\tannotationsMatch = true","\t\t\tfor key, value := range matchAnnotations {","\t\t\t\tif annotationValue, exists := annotations[key]; !exists || annotationValue != value {","\t\t\t\t\tannotationsMatch = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","","\t\t\tif annotationsMatch {","\t\t\t\tif value, exists := labels[defaultLabelKey]; exists {","\t\t\t\t\trunName = value","\t\t\t\t}","\t\t\t\treturn runName","\t\t\t}","\t\t}","\t}","","\t// If matchLabels is not null or empty, process labels","\tif len(matchLabels) \u003e 0 {","\t\tif len(labels) \u003e 0 { // Check if the resource has labels","\t\t\t// Ensure all labels in matchLabels exist in the resource labels","\t\t\tlabelsMatch = true","\t\t\tfor key, value := range matchLabels {","\t\t\t\tif labelValue, exists := labels[key]; !exists || labelValue != value {","\t\t\t\t\tlabelsMatch = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","","\t\t\tif labelsMatch {","\t\t\t\tif value, exists := labels[defaultLabelKey]; exists {","\t\t\t\t\trunName = value","\t\t\t\t}","\t\t\t\treturn runName","\t\t\t}","\t\t}","\t}","","\t// If no match found in either annotations or labels, return an empty string","\treturn \"\"","}","*/","","// Helper function to match labels against label selector","func MatchLabels(labels map[string]string, labelSelector string) bool {","\tlabelPairs := strings.Split(labelSelector, \",\")","\tfor _, labelPair := range labelPairs {","\t\tparts := strings.Split(labelPair, \"=\")","\t\tif len(parts) != 2 {","\t\t\tcontinue","\t\t}","\t\tlabelKey, labelValue := parts[0], parts[1]","\t\tif value, exists := labels[labelKey]; !exists || value != labelValue {","\t\t\treturn false","\t\t}","\t}","\treturn true","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,1,0,1,0]},{"id":4,"path":"pkg/config/history_limiter.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"math\"","\t\"slices\"","\t\"strconv\"","\t\"time\"","","\t\"github.com/tektoncd/pruner/pkg/metrics\"","\t// tektonprunerv1alpha1 \"github.com/tektoncd/pruner/pkg/apis/tektonpruner/v1alpha1\"","\t\"go.uber.org/zap\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/ptr\"",")","","// HistoryLimiterResourceFuncs defines a set of methods that operate on resources","// with history limit capabilities.","type HistoryLimiterResourceFuncs interface {","\tType() string","\tGet(ctx context.Context, namespace, name string) (metav1.Object, error)","\tUpdate(ctx context.Context, resource metav1.Object) error","\tPatch(ctx context.Context, namespace, name string, patchBytes []byte) error","\tDelete(ctx context.Context, namespace, name string) error","\tList(ctx context.Context, namespace, label string) ([]metav1.Object, error)","\tGetFailedHistoryLimitCount(namespace, name string, selectors SelectorSpec) (*int32, string)","\tGetSuccessHistoryLimitCount(namespace, name string, selectors SelectorSpec) (*int32, string)","\tIsSuccessful(resource metav1.Object) bool","\tIsFailed(resource metav1.Object) bool","\tIsCompleted(resource metav1.Object) bool","\tGetDefaultLabelKey() string","\tGetEnforcedConfigLevel(namespace, name string, selectors SelectorSpec) EnforcedConfigLevel","\tGetMatchingSelector(namespace, name string, selectors SelectorSpec) *SelectorSpec","}","","// HistoryLimiter is a struct that encapsulates functionality for managing resources","// with history limits. It uses the HistoryLimiterResourceFuncs interface to interact","// with different types of resources","type HistoryLimiter struct {","\tresourceFn HistoryLimiterResourceFuncs","}","","// NewHistoryLimiter creates a new instance of HistoryLimiter, ensuring that the","// provided HistoryLimiterResourceFuncs interface is not nil","func NewHistoryLimiter(resourceFn HistoryLimiterResourceFuncs) (*HistoryLimiter, error) {","\thl := \u0026HistoryLimiter{","\t\tresourceFn: resourceFn,","\t}","\tif hl.resourceFn == nil {","\t\treturn nil, fmt.Errorf(\"resourceFunc interface cannot be nil\")","\t}","","\treturn hl, nil","}","","// ProcessEvent processes an event for a given resource and performs cleanup","// based on its status. The method checks if the resource is in a deletion state,","// whether it has already been processed, and if it's in a completed state. Depending","// on the resource's completion status, it will either trigger cleanup for successful","// or failed resources","func (hl *HistoryLimiter) ProcessEvent(ctx context.Context, resource metav1.Object) error {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"processing an event for limit logic\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","","\t// if the resource is on deletion state, no action needed","\tif resource.GetDeletionTimestamp() != nil {","\t\tlogger.Debugw(\"resource is in deletion state\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","\t\treturn nil","\t}","","\tif hl.isProcessed(resource) {","\t\tlogger.Debugw(\"already processed\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","\t\treturn nil","\t}","","\t// if the resource is still in running state, ignore it","\tif !hl.resourceFn.IsCompleted(resource) {","\t\tlogger.Debugw(\"resource is not in completion state\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","\t\treturn nil","\t}","","\tdefer hl.markAsProcessed(ctx, resource)","","\tif hl.resourceFn.IsSuccessful(resource) {","\t\tlogger.Debugw(\"success - cleanup\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","\t\treturn hl.DoSuccessfulResourceCleanup(ctx, resource)","\t}","","\tif hl.resourceFn.IsFailed(resource) {","\t\tlogger.Debugw(\"failed - cleanup\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","\t\treturn hl.DoFailedResourceCleanup(ctx, resource)","\t}","","\treturn nil","}","","// adds an annotation, indicates this resource is already processed","// no action needed on the further reconcile loop for this Resource","// markAsProcessed patches the resource with the annotation 'mark as processed'","func (hl *HistoryLimiter) markAsProcessed(ctx context.Context, resource metav1.Object) {","\tlogger := logging.FromContext(ctx)","","\tlogger.Debugw(\"marking resource as processed\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","","\t// Fetch the latest version of the resource","\tresourceLatest, err := hl.resourceFn.Get(ctx, resource.GetNamespace(), resource.GetName())","\tif err != nil {","\t\tif errors.IsNotFound(err) {","\t\t\treturn","\t\t}","\t\tlogger.Errorw(\"error getting resource\", \"resource\", hl.resourceFn.Type(),","\t\t\t\"namespace\", resource.GetNamespace(), \"name\", resource.GetName(), zap.Error(err))","\t\treturn","\t}","","\t// Prepare the annotation update","\tprocessedTimeAsString := time.Now().Format(time.RFC3339)","\tannotations := resourceLatest.GetAnnotations()","\tif annotations == nil {","\t\tannotations = map[string]string{}","\t}","\tannotations[AnnotationHistoryLimitCheckProcessed] = processedTimeAsString","","\t// Create a patch with the new annotations","\tpatchData := map[string]interface{}{","\t\t\"metadata\": map[string]interface{}{","\t\t\t\"annotations\": annotations,","\t\t},","\t}","","\t// Convert patchData to JSON","\tpatchBytes, err := json.Marshal(patchData)","\tif err != nil {","\t\tlogger.Errorw(\"Error marshaling patch data\", zap.Error(err))","\t\treturn","\t}","","\t// Apply the patch","\terr = hl.resourceFn.Patch(ctx, resourceLatest.GetNamespace(), resourceLatest.GetName(), patchBytes)","\tif err != nil {","\t\tlogger.Errorw(\"Error patching resource with 'mark as processed' annotation\",","\t\t\t\"resource\", hl.resourceFn.Type(), \"namespace\", resourceLatest.GetNamespace(), \"name\", resourceLatest.GetName(), zap.Error(err))","\t}","}","","func (hl *HistoryLimiter) isProcessed(resource metav1.Object) bool {","\tannotations := resource.GetAnnotations()","\tif annotations == nil {","\t\treturn false","\t}","\t_, found := annotations[AnnotationHistoryLimitCheckProcessed]","\treturn found","}","","func (hl *HistoryLimiter) DoSuccessfulResourceCleanup(ctx context.Context, resource metav1.Object) error {","\tlogging := logging.FromContext(ctx)","","\tlogging.Debugw(\"processing a successful resource\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","\treturn hl.doResourceCleanup(ctx, resource, AnnotationSuccessfulHistoryLimit, hl.resourceFn.GetSuccessHistoryLimitCount, hl.isSuccessfulResource)","}","","func (hl *HistoryLimiter) DoFailedResourceCleanup(ctx context.Context, resource metav1.Object) error {","\tlogging := logging.FromContext(ctx)","\tlogging.Debugw(\"processing a failed resource\", \"resource\", hl.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName())","\treturn hl.doResourceCleanup(ctx, resource, AnnotationFailedHistoryLimit, hl.resourceFn.GetFailedHistoryLimitCount, hl.isFailedResource)","}","","func (hl *HistoryLimiter) isFailedResource(resource metav1.Object) bool {","\treturn hl.resourceFn.IsCompleted(resource) \u0026\u0026 hl.resourceFn.IsFailed(resource)","}","","func (hl *HistoryLimiter) isSuccessfulResource(resource metav1.Object) bool {","\treturn hl.resourceFn.IsCompleted(resource) \u0026\u0026 hl.resourceFn.IsSuccessful(resource)","}","","func (hl *HistoryLimiter) doResourceCleanup(ctx context.Context, resource metav1.Object, historyLimitAnnotation string, getHistoryLimitFn func(string, string, SelectorSpec) (*int32, string), getResourceFilterFn func(metav1.Object) bool) error {","\tlogger := logging.FromContext(ctx)","","\t// get the label key and resource name","\tlabelKey := getResourceNameLabelKey(resource, hl.resourceFn.GetDefaultLabelKey())","\tresourceName := getResourceName(resource, labelKey)","","\t// Get Annotations and Labels","\tresourceAnnotations := resource.GetAnnotations()","\tresourceLabels := resource.GetLabels()","","\t// Construct the selectors with both matchLabels and matchAnnotations","\tresourceSelectors := SelectorSpec{}","\tif len(resourceAnnotations) \u003e 0 {","\t\tresourceSelectors.MatchAnnotations = resourceAnnotations","\t}","\tif len(resourceLabels) \u003e 0 {","\t\tresourceSelectors.MatchLabels = resourceLabels","\t}","","\t// Get enforced config level first","\tenforcedConfigLevel := hl.resourceFn.GetEnforcedConfigLevel(resource.GetNamespace(), resourceName, resourceSelectors)","\tlogger.Debugw(\"enforcedConfigLevel for the resource is\", \"resourceName\", resourceName, \"enforcedlevel\", enforcedConfigLevel)","","\t// Get configured history limit","\tvar historyLimit *int32","\tvar identifiedBy string","\tconfigHistoryLimit, configIdentifiedBy := getHistoryLimitFn(resource.GetNamespace(), resourceName, resourceSelectors)","","\t// For resource-level enforcement, check annotation only if it matches config","\tannotations := resource.GetAnnotations()","\tif enforcedConfigLevel == EnforcedConfigLevelResource \u0026\u0026 len(annotations) != 0 \u0026\u0026 annotations[historyLimitAnnotation] != \"\" {","\t\tannotationLimit, err := strconv.Atoi(annotations[historyLimitAnnotation])","\t\tif err != nil {","\t\t\tlogger.Errorw(\"error converting history limit annotation to int\",","\t\t\t\t\"resource\", hl.resourceFn.Type(),","\t\t\t\t\"namespace\", resource.GetNamespace(),","\t\t\t\t\"name\", resource.GetName(),","\t\t\t\t\"annotation\", historyLimitAnnotation,","\t\t\t\t\"value\", annotations[historyLimitAnnotation],","\t\t\t\tzap.Error(err))","\t\t\treturn err","\t\t}","\t\t// Check bounds before converting to int32","\t\tif annotationLimit \u003c 0 || annotationLimit \u003e math.MaxInt32 {","\t\t\tlogger.Errorw(\"history limit annotation value out of bounds for int32\",","\t\t\t\t\"resource\", hl.resourceFn.Type(),","\t\t\t\t\"namespace\", resource.GetNamespace(),","\t\t\t\t\"name\", resource.GetName(),","\t\t\t\t\"annotation\", historyLimitAnnotation,","\t\t\t\t\"value\", annotationLimit)","\t\t\treturn fmt.Errorf(\"history limit value %d is out of bounds for type int32\", annotationLimit)","\t\t}","","\t\t// Only use annotation value if it matches configured value","\t\tif configHistoryLimit != nil \u0026\u0026 annotationLimit == int(*configHistoryLimit) {","\t\t\thistoryLimit = ptr.Int32(int32(annotationLimit))","\t\t\tidentifiedBy = \"identifiedBy_resource_ann\"","\t\t} else {","\t\t\thistoryLimit = configHistoryLimit","\t\t\tidentifiedBy = configIdentifiedBy","\t\t}","\t} else {","\t\thistoryLimit = configHistoryLimit","\t\tidentifiedBy = configIdentifiedBy","\t}","","\tlogger.Debugw(\"historylimit for the resource\", \"resourcename\", resourceName, \"limit\", historyLimit, \"identifiedBy\", identifiedBy)","","\tif historyLimit == nil || *historyLimit \u003c 0 {","\t\treturn nil","\t}","","\t// List Resources (using appropriate selector based on enforcement level and identifier)","\tvar resources []metav1.Object","\tvar err error","","\t// Handle selector-based identification for both resource and namespace enforcement levels","\tswitch identifiedBy {","\tcase \"identifiedBy_resource_name\":","\t\t// Filter by name label (resource-level enforcement)","\t\tlabel := fmt.Sprintf(\"%s=%s\", labelKey, resourceName)","\t\tresources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), label)","\tcase \"identifiedBy_resource_selector\":","\t\t// Filter by the ConfigMap's selector labels only","\t\tmatchingSelector := hl.resourceFn.GetMatchingSelector(resource.GetNamespace(), resourceName, resourceSelectors)","\t\tlabelSelector := \"\"","\t\tif matchingSelector != nil \u0026\u0026 len(matchingSelector.MatchLabels) \u003e 0 {","\t\t\tfor k, v := range matchingSelector.MatchLabels {","\t\t\t\tif labelSelector != \"\" {","\t\t\t\t\tlabelSelector += \",\"","\t\t\t\t}","\t\t\t\tlabelSelector += fmt.Sprintf(\"%s=%s\", k, v)","\t\t\t}","\t\t}","\t\tlogger.Debugw(\"listing resources with selector from ConfigMap\",","\t\t\t\"resource\", hl.resourceFn.Type(),","\t\t\t\"namespace\", resource.GetNamespace(),","\t\t\t\"labelSelector\", labelSelector)","\t\tresources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), labelSelector)","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tif matchingSelector != nil \u0026\u0026 len(matchingSelector.MatchAnnotations) \u003e 0 {","\t\t\tfilteredResources := []metav1.Object{}","\t\t\tfor _, res := range resources {","\t\t\t\tresAnnotations := res.GetAnnotations()","\t\t\t\tif resAnnotations == nil {","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tmatches := true","\t\t\t\tfor k, v := range matchingSelector.MatchAnnotations {","\t\t\t\t\tif resAnnotations[k] != v {","\t\t\t\t\t\tmatches = false","\t\t\t\t\t\tbreak","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\tif matches {","\t\t\t\t\tfilteredResources = append(filteredResources, res)","\t\t\t\t}","\t\t\t}","\t\t\tresources = filteredResources","\t\t}","\tcase \"identifiedBy_resource_ann\":","\t\t// Filter by annotations (converted to labels for listing)","\t\tlabelSelector := \"\"","\t\tfor k, v := range resourceAnnotations {","\t\t\tif labelSelector != \"\" {","\t\t\t\tlabelSelector += \",\"","\t\t\t}","\t\t\tlabelSelector += fmt.Sprintf(\"%s=%s\", k, v)","\t\t}","\t\tresources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), labelSelector)","\tcase \"identifiedBy_resource_label\":","\t\t// Filter by all resource labels","\t\tlabelSelector := \"\"","\t\tfor k, v := range resourceLabels {","\t\t\tif labelSelector != \"\" {","\t\t\t\tlabelSelector += \",\"","\t\t\t}","\t\t\tlabelSelector += fmt.Sprintf(\"%s=%s\", k, v)","\t\t}","\t\tresources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), labelSelector)","\tdefault:","\t\t// For namespace/global level without selectors, list all resources in namespace","\t\tresources, err = hl.resourceFn.List(ctx, resource.GetNamespace(), \"\")","\t}","","\tif err != nil {","\t\treturn err","\t}","","\t// Filter resources by status (success/failed)","\tresourcesFiltered := []metav1.Object{}","\tfor _, res := range resources {","\t\tif getResourceFilterFn(res) {","\t\t\tresourcesFiltered = append(resourcesFiltered, res)","\t\t}","\t}","\tresources = resourcesFiltered","","\tif int(*historyLimit) \u003e len(resources) {","\t\treturn nil","\t}","","\t// Sort resources by creation timestamp (newest first)","\tslices.SortStableFunc(resources, func(a, b metav1.Object) int {","\t\tobjA := a.GetCreationTimestamp()","\t\tobjB := b.GetCreationTimestamp()","\t\tif objA.Time.Before(objB.Time) {","\t\t\treturn 1","\t\t} else if objA.Time.After(objB.Time) {","\t\t\treturn -1","\t\t}","\t\treturn 0","\t})","","\t// Select resources to delete (keep newest up to historyLimit)","\tvar selectionForDeletion []metav1.Object","\tif *historyLimit == 0 {","\t\tselectionForDeletion = resources","\t} else {","\t\tselectionForDeletion = resources[*historyLimit:]","\t}","","\t// Delete selected resources","\tmetricsRecorder := metrics.GetRecorder()","\tresourceType := metrics.ResourceTypePipelineRun","\tif hl.resourceFn.Type() == KindTaskRun {","\t\tresourceType = metrics.ResourceTypeTaskRun","\t}","","\tfor _, res := range selectionForDeletion {","\t\tlogger.Debugw(\"deleting resource\",","\t\t\t\"resource\", hl.resourceFn.Type(),","\t\t\t\"namespace\", res.GetNamespace(),","\t\t\t\"name\", res.GetName(),","\t\t\t\"creationTimestamp\", res.GetCreationTimestamp(),","\t\t)","","\t\t// Calculate resource age for metrics","\t\tvar resourceAge time.Duration","\t\tcreationTime := res.GetCreationTimestamp()","\t\tif !creationTime.IsZero() {","\t\t\tresourceAge = time.Since(creationTime.Time)","\t\t}","","\t\tif err := hl.resourceFn.Delete(ctx, res.GetNamespace(), res.GetName()); err != nil {","\t\t\tif errors.IsNotFound(err) {","\t\t\t\tcontinue","\t\t\t}","\t\t\t// Record deletion error","\t\t\terrorType := metrics.ClassifyError(err)","\t\t\tmetricsRecorder.RecordResourceError(ctx, resourceType, res.GetNamespace(), errorType, \"history_deletion_failed\")","\t\t\tlogger.Errorw(\"error deleting resource\",","\t\t\t\t\"resource\", hl.resourceFn.Type(),","\t\t\t\t\"namespace\", res.GetNamespace(),","\t\t\t\t\"name\", res.GetName(),","\t\t\t\tzap.Error(err),","\t\t\t)","\t\t\treturn err","\t\t}","","\t\t// Record successful deletion","\t\tmetricsRecorder.RecordResourceDeleted(ctx, resourceType, res.GetNamespace(), metrics.OperationHistory, resourceAge)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,0,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,0,1,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,1,1,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,2,1,1,1,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,2,2,2,2,0,2,2,2,1,1,0,0,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,2,2,2,0,0,2,1,1,0,0,2,2,2,2,2,0,2,2,2,2,2,0,0,2,2,2,2,1,2,2,2,1,0,0,0,2,2,1,2,2,2,0,0,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,2,0,0,2,0]},{"id":5,"path":"pkg/config/ttl_handler.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strconv\"","\t\"time\"","","\t\"github.com/tektoncd/pruner/pkg/metrics\"","\t\"go.uber.org/zap\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tclockUtil \"k8s.io/utils/clock\"","\tcontroller \"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","const (","\t// NoTTL represents a TTL value that indicates no TTL should be applied","\tNoTTL = \"-1\"","\t// DefaultTTL represents the default TTL duration if none is specified","\tDefaultTTL = 0",")","","// TTLResourceFuncs defines the set of functions that should be implemented for","// resources that are subject to Time-To-Live (TTL) management, including determining","// whether a resource is completed, updating or deleting the resource, and handling","// the TTL (time-to-live) after the resource is finished","type TTLResourceFuncs interface {","\tType() string","\tGet(ctx context.Context, namespace, name string) (metav1.Object, error)","\tDelete(ctx context.Context, namespace, name string) error","\tPatch(ctx context.Context, namespace, name string, patchBytes []byte) error","\tUpdate(ctx context.Context, resource metav1.Object) error","\tIsCompleted(resource metav1.Object) bool","\tGetCompletionTime(resource metav1.Object) (metav1.Time, error)","\tIgnore(resource metav1.Object) bool","\tGetTTLSecondsAfterFinished(namespace, name string, selectors SelectorSpec) (*int32, string)","\tGetDefaultLabelKey() string","\tGetEnforcedConfigLevel(namespace, name string, selectors SelectorSpec) EnforcedConfigLevel","}","","// TTLHandler is responsible for managing resources with a Time-To-Live (TTL) configuration","type TTLHandler struct {","\tclock      clockUtil.Clock // the clock for tracking time","\tresourceFn TTLResourceFuncs","}","","// NewTTLHandler creates a new instance of TTLHandler, which is responsible for managing","// resources with a Time-To-Live (TTL) configuration and initializes a TTLHandler with","// the provided clock and resource function interface.","func NewTTLHandler(clock clockUtil.Clock, resourceFn TTLResourceFuncs) (*TTLHandler, error) {","\ttq := \u0026TTLHandler{","\t\tclock:      clock,","\t\tresourceFn: resourceFn,","\t}","\tif tq.resourceFn == nil {","\t\treturn nil, fmt.Errorf(\"resourceFunc interface cannot be nil\")","\t}","","\tif tq.clock == nil {","\t\ttq.clock = clockUtil.RealClock{}","\t}","","\treturn tq, nil","}","","// ProcessEvent handles an event for a resource by processing its TTL-based actions.","// It evaluates the resource's state, checks whether it should be cleaned up,","// and updates the TTL annotation if needed","func (th *TTLHandler) ProcessEvent(ctx context.Context, resource metav1.Object) error {","\t// if a resource is in deletion state, no further action needed","\tif resource.GetDeletionTimestamp() != nil {","\t\treturn nil","\t}","","\t// if a resource is not completed state, no further action needed","\tif !th.resourceFn.IsCompleted(resource) \u0026\u0026 th.resourceFn.Ignore(resource) {","\t\treturn nil","\t}","","\t// update ttl annotation, if not present","\terr := th.updateAnnotationTTLSeconds(ctx, resource)","\tif err != nil {","\t\treturn err","\t}","","\t// if the resource is not available for cleanup, no further action needed","\tif !th.needsCleanup(resource) {","\t\treturn nil","\t}","","\treturn th.removeResource(ctx, resource)","}","","// updateAnnotationTTLSeconds updates the TTL annotation of a resource if needed","func (th *TTLHandler) updateAnnotationTTLSeconds(ctx context.Context, resource metav1.Object) error {","\tlogger := logging.FromContext(ctx)","","\t// get resource name and selectors first to avoid redundant work if no update needed","\tlabelKey := getResourceNameLabelKey(resource, th.resourceFn.GetDefaultLabelKey())","\tresourceName := getResourceName(resource, labelKey)","\tresourceSelectors := th.getResourceSelectors(resource)","","\t// Check enforced config level early","\tenforcedLevel := th.resourceFn.GetEnforcedConfigLevel(resource.GetNamespace(), resourceName, resourceSelectors)","\tlogger.Debugw(\"checking TTL configuration\",","\t\t\"resource\", th.resourceFn.Type(),","\t\t\"namespace\", resource.GetNamespace(),","\t\t\"name\", resourceName,","\t\t\"enforced_level\", enforcedLevel)","","\t// Check if update is needed","\tif !th.needsTTLUpdate(resource, enforcedLevel) {","\t\treturn nil","\t}","","\t// Get TTL value","\tttl, identifiedBy := th.resourceFn.GetTTLSecondsAfterFinished(resource.GetNamespace(), resourceName, resourceSelectors)","\tlogger.Debugw(\"TTL configuration found\",","\t\t\"ttl\", ttl,","\t\t\"source\", identifiedBy,","\t\t\"resource\", th.resourceFn.Type(),","\t\t\"namespace\", resource.GetNamespace(),","\t\t\"name\", resourceName)","","\t// Get latest version of resource to avoid conflicts","\tresourceLatest, err := th.resourceFn.Get(ctx, resource.GetNamespace(), resource.GetName())","\tif err != nil {","\t\tif errors.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"failed to get resource: %w\", err)","\t}","","\t// Update annotations","\tannotations := resourceLatest.GetAnnotations()","\tif annotations == nil {","\t\tannotations = make(map[string]string)","\t}","","\tif ttl == nil {","\t\t// If TTL is nil, remove the annotation if it exists","\t\tif _, exists := annotations[AnnotationTTLSecondsAfterFinished]; exists {","\t\t\tdelete(annotations, AnnotationTTLSecondsAfterFinished)","\t\t\tlogger.Debugw(\"removing TTL annotation - no TTL configuration found\",","\t\t\t\t\"resource\", th.resourceFn.Type(),","\t\t\t\t\"namespace\", resource.GetNamespace(),","\t\t\t\t\"name\", resource.GetName())","\t\t}","\t} else {","\t\t// Set new TTL annotation","\t\tnewTTL := strconv.Itoa(int(*ttl))","\t\tcurrentTTL, hasCurrentTTL := annotations[AnnotationTTLSecondsAfterFinished]","\t\tif !hasCurrentTTL || currentTTL != newTTL {","\t\t\tannotations[AnnotationTTLSecondsAfterFinished] = newTTL","\t\t\tlogger.Debugw(\"updating TTL annotation\",","\t\t\t\t\"resource\", th.resourceFn.Type(),","\t\t\t\t\"namespace\", resource.GetNamespace(),","\t\t\t\t\"name\", resource.GetName(),","\t\t\t\t\"oldTTL\", currentTTL,","\t\t\t\t\"newTTL\", newTTL,","\t\t\t\t\"hadPreviousTTL\", hasCurrentTTL)","\t\t} else {","\t\t\treturn nil","\t\t}","\t}","","\tpatchData := map[string]interface{}{","\t\t\"metadata\": map[string]interface{}{","\t\t\t\"annotations\": annotations,","\t\t},","\t}","","\tpatchBytes, err := json.Marshal(patchData)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to marshal patch data: %w\", err)","\t}","","\tif err := th.resourceFn.Patch(ctx, resourceLatest.GetNamespace(), resourceLatest.GetName(), patchBytes); err != nil {","\t\treturn fmt.Errorf(\"failed to patch resource with TTL annotation: %w\", err)","\t}","","\treturn nil","}","","// needsCleanup checks whether a Resource has finished and has a TTL set.","func (th *TTLHandler) needsCleanup(resource metav1.Object) bool {","\t// Check completion state first as it's likely to be the most expensive operation","\tif !th.resourceFn.IsCompleted(resource) {","\t\treturn false","\t}","","\t// get the annotations","\tannotations := resource.GetAnnotations()","\tif annotations == nil {","\t\treturn false","\t}","","\tttlValue := annotations[AnnotationTTLSecondsAfterFinished]","\treturn ttlValue != \"\" \u0026\u0026 ttlValue != NoTTL","}","","// removeResource checks the TTL and deletes the Resource if it has expired","func (th *TTLHandler) removeResource(ctx context.Context, resource metav1.Object) error {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"checking resource cleanup eligibility\",","\t\t\"resourceType\", th.resourceFn.Type(),","\t\t\"namespace\", resource.GetNamespace(),","\t\t\"name\", resource.GetName(),","\t)","","\t// check the resource ttl status","\texpiredAt, err := th.processTTL(logger, resource)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to process TTL: %w\", err)","\t}","\tif expiredAt == nil {","\t\treturn nil","\t}","","\t// Verify TTL hasn't been modified before deletion","\tfreshResource, err := th.resourceFn.Get(ctx, resource.GetNamespace(), resource.GetName())","\tif err != nil {","\t\tif errors.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\treturn fmt.Errorf(\"failed to get fresh resource: %w\", err)","\t}","","\texpiredAt, err = th.processTTL(logger, freshResource)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to process TTL for fresh resource: %w\", err)","\t}","\tif expiredAt == nil {","\t\treturn nil","\t}","","\tlogger.Debugw(\"cleaning up expired resource\",","\t\t\"resourceType\", th.resourceFn.Type(),","\t\t\"namespace\", resource.GetNamespace(),","\t\t\"name\", resource.GetName(),","\t\t\"expiredAt\", expiredAt,","\t)","","\t// Calculate resource age for metrics","\tvar resourceAge time.Duration","\tcreationTime := resource.GetCreationTimestamp()","\tif !creationTime.IsZero() {","\t\tresourceAge = time.Since(creationTime.Time)","\t}","","\t// Get resource type for metrics","\tresourceType := metrics.ResourceTypePipelineRun","\tif th.resourceFn.Type() == KindTaskRun {","\t\tresourceType = metrics.ResourceTypeTaskRun","\t}","","\tif err := th.resourceFn.Delete(ctx, resource.GetNamespace(), resource.GetName()); err != nil {","\t\tif errors.IsNotFound(err) {","\t\t\treturn nil","\t\t}","\t\t// Record deletion error","\t\tmetricsRecorder := metrics.GetRecorder()","\t\terrorType := metrics.ClassifyError(err)","\t\tmetricsRecorder.RecordResourceError(ctx, resourceType, resource.GetNamespace(), errorType, \"ttl_deletion_failed\")","\t\treturn fmt.Errorf(\"failed to delete resource: %w\", err)","\t}","","\t// Record successful deletion","\tmetricsRecorder := metrics.GetRecorder()","\tmetricsRecorder.RecordResourceDeleted(ctx, resourceType, resource.GetNamespace(), metrics.OperationTTL, resourceAge)","","\treturn nil","}","","// processTTL checks whether a given Resource's TTL has expired, and add it to the queue after the TTL is expected to expire","// if the TTL will expire later.","func (th *TTLHandler) processTTL(logger *zap.SugaredLogger, resource metav1.Object) (expiredAt *time.Time, err error) {","\t// We don't care about the Resources that are going to be deleted, or the ones that don't need clean up.","\tif resource.GetDeletionTimestamp() != nil || !th.needsCleanup(resource) {","\t\treturn nil, nil","\t}","","\tnow := th.clock.Now()","\tt, e, err := th.timeLeft(logger, resource, \u0026now)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// TTL has expired","\tif *t \u003c= 0 {","\t\treturn e, nil","\t}","","\treturn nil, th.enqueueAfter(logger, resource, *t)","}","","// calculates the remaining time to hold this resource","func (th *TTLHandler) timeLeft(logger *zap.SugaredLogger, resource metav1.Object, since *time.Time) (*time.Duration, *time.Time, error) {","\tfinishAt, expireAt, err := th.getFinishAndExpireTime(resource)","\tif err != nil {","\t\treturn nil, nil, err","\t}","","\tif finishAt.After(*since) {","\t\tlogger.Warn(\"found resource finished in the future. This is likely due to time skew in the cluster. Resource cleanup will be deferred.\")","\t}","\tremaining := expireAt.Sub(*since)","\tlogger.Debugw(\"resource is in finished state\",","\t\t\"finishTime\", finishAt.UTC(), \"remainingTTL\", remaining, \"startTime\", since.UTC(), \"deadlineTTL\", expireAt.UTC(),","\t)","\treturn \u0026remaining, expireAt, nil","}","","// returns finished and expire time of the Resource","func (th *TTLHandler) getFinishAndExpireTime(resource metav1.Object) (*time.Time, *time.Time, error) {","\tif !th.needsCleanup(resource) {","\t\treturn nil, nil, fmt.Errorf(\"resource '%s/%s' should not be cleaned up\", resource.GetNamespace(), resource.GetName())","\t}","\tt, err := th.resourceFn.GetCompletionTime(resource)","\tif err != nil {","\t\treturn nil, nil, err","\t}","\tfinishAt := t.Time","\t// get ttl duration","\tttlDuration, err := th.getTTLSeconds(resource)","\tif err != nil {","\t\treturn nil, nil, err","\t}","\texpireAt := finishAt.Add(*ttlDuration)","\treturn \u0026finishAt, \u0026expireAt, nil","}","","// returns ttl of the resource","func (th *TTLHandler) getTTLSeconds(resource metav1.Object) (*time.Duration, error) {","\tannotations := resource.GetAnnotations()","\t// if there is no annotation present, no action needed","\tif annotations == nil {","\t\treturn nil, nil","\t}","","\tttlString := annotations[AnnotationTTLSecondsAfterFinished]","\t// if there is no ttl present on annotation, no action needed","\tif ttlString == \"\" {","\t\treturn nil, nil","\t}","","\tttl, err := strconv.Atoi(ttlString)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"invalid TTL value %q: %w\", ttlString, err)","\t}","","\t// Check for negative TTL values (except -1 which means no TTL)","\tif ttl \u003c -1 {","\t\treturn nil, fmt.Errorf(\"TTL value %d must be \u003e= -1\", ttl)","\t}","","\tttlDuration := time.Duration(ttl) * time.Second","\treturn \u0026ttlDuration, nil","}","","// enqueue the Resource for later reconcile","// the resource expire duration is in the future","func (th *TTLHandler) enqueueAfter(logger *zap.SugaredLogger, resource metav1.Object, after time.Duration) error {","\tlogger.Debugw(\"the resource to be reconciled later, it has expire in the future\",","\t\t\"resource\", th.resourceFn.Type(), \"namespace\", resource.GetNamespace(), \"name\", resource.GetName(), \"waitDuration\", after,","\t)","\treturn controller.NewRequeueAfter(after)","}","","// getResourceSelectors constructs the selector spec for a resource","func (th *TTLHandler) getResourceSelectors(resource metav1.Object) SelectorSpec {","\tselectors := SelectorSpec{}","\tif annotations := resource.GetAnnotations(); len(annotations) \u003e 0 {","\t\tselectors.MatchAnnotations = annotations","\t}","\tif labels := resource.GetLabels(); len(labels) \u003e 0 {","\t\tselectors.MatchLabels = labels","\t}","\treturn selectors","}","","// needsTTLUpdate determines if a resource needs its TTL annotation updated","func (th *TTLHandler) needsTTLUpdate(resource metav1.Object, enforcedLevel EnforcedConfigLevel) bool {","\tannotations := resource.GetAnnotations()","\tif annotations == nil {","\t\treturn true","\t}","","\tcurrentTTL, exists := annotations[AnnotationTTLSecondsAfterFinished]","\tif !exists {","\t\treturn true","\t}","","\t// Get the current TTL from config","\tlabelKey := getResourceNameLabelKey(resource, th.resourceFn.GetDefaultLabelKey())","\tresourceName := getResourceName(resource, labelKey)","\tresourceSelectors := th.getResourceSelectors(resource)","","\tconfigTTL, _ := th.resourceFn.GetTTLSecondsAfterFinished(resource.GetNamespace(), resourceName, resourceSelectors)","","\t// If there's no config TTL, we should remove the annotation","\tif configTTL == nil {","\t\treturn true","\t}","","\t// Compare current TTL with config TTL","\tconfigTTLStr := strconv.Itoa(int(*configTTL))","\treturn currentTTL != configTTLStr","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,2,1,1,0,2,0,0,0,0,0,2,2,2,1,1,0,0,2,1,1,0,0,2,2,1,1,0,0,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,0,0,0,2,2,2,2,0,2,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,1,1,0,2,1,1,0,2,0,0,0,2,2,2,2,2,0,0,2,2,2,2,0,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,0,0,2,2,1,1,1,1,0,0,2,2,1,1,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,1,1,0,2,1,1,1,0,1,1,1,1,0,0,0,2,2,2,2,0,0,0,0,2,2,2,1,1,0,2,2,2,1,1,0,0,2,2,2,0,1,0,0,0,2,2,2,1,1,0,2,1,1,2,2,2,2,2,0,0,0,2,2,1,1,2,2,1,1,2,2,2,2,1,1,2,2,0,0,0,2,2,2,2,1,1,0,2,2,2,1,1,0,2,2,1,1,0,0,2,1,1,0,2,2,0,0,0,0,1,1,1,1,1,1,0,0,2,2,2,1,1,2,1,1,2,0,0,0,2,2,2,2,2,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0]},{"id":6,"path":"pkg/metrics/metrics.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package metrics","","import (","\t\"context\"","\t\"sync\"","\t\"time\"","","\t\"go.opentelemetry.io/otel\"","\t\"go.opentelemetry.io/otel/attribute\"","\t\"go.opentelemetry.io/otel/metric\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\t\"k8s.io/apimachinery/pkg/types\"",")","","const (","\t// Metric names","\tMetricResourcesProcessed        = \"tekton_pruner_controller_resources_processed\"","\tMetricReconciliationEvents      = \"tekton_pruner_controller_reconciliation_events\"","\tMetricResourcesDeleted          = \"tekton_pruner_controller_resources_deleted\"","\tMetricResourcesErrors           = \"tekton_pruner_controller_resources_errors\"","\tMetricReconciliationDuration    = \"tekton_pruner_controller_reconciliation_duration\"","\tMetricTTLProcessingDuration     = \"tekton_pruner_controller_ttl_processing_duration\"","\tMetricHistoryProcessingDuration = \"tekton_pruner_controller_history_processing_duration\"","\tMetricActiveResourcesCount      = \"tekton_pruner_controller_active_resources\"","\tMetricPendingDeletionsCount     = \"tekton_pruner_controller_pending_deletions\"","\tMetricResourceAgeAtDeletion     = \"tekton_pruner_controller_resource_age_at_deletion\"","","\t// Label keys","\tLabelNamespace    = \"namespace\"","\tLabelResourceType = \"resource_type\"","\tLabelStatus       = \"status\"","\tLabelReason       = \"reason\"","\tLabelErrorType    = \"error_type\"","\tLabelOperation    = \"operation\"","","\t// Label values for resource types","\tResourceTypePipelineRun = \"pipelinerun\"","\tResourceTypeTaskRun     = \"taskrun\"","","\t// Label values for operations","\tOperationTTL     = \"ttl\"","\tOperationHistory = \"history\"","","\t// Label values for status","\tStatusSuccess = \"success\"","\tStatusFailed  = \"failed\"","\tStatusError   = \"error\"","","\t// Label values for error types","\tErrorTypeAPI        = \"api_error\"","\tErrorTypeTimeout    = \"timeout\"","\tErrorTypeValidation = \"validation\"","\tErrorTypeInternal   = \"internal\"","\tErrorTypeNotFound   = \"not_found\"","\tErrorTypePermission = \"permission\"",")","","// Recorder holds all the OpenTelemetry instruments for recording metrics","type Recorder struct {","\t// Counters","\tresourcesProcessed   metric.Int64Counter","\treconciliationEvents metric.Int64Counter","\tresourcesDeleted     metric.Int64Counter","\tresourcesErrors      metric.Int64Counter","","\t// Histograms for duration measurements","\treconciliationDuration    metric.Float64Histogram","\tttlProcessingDuration     metric.Float64Histogram","\thistoryProcessingDuration metric.Float64Histogram","\tresourceAgeAtDeletion     metric.Float64Histogram","","\t// UpDownCounters for gauge-like metrics","\tactiveResourcesCount  metric.Int64UpDownCounter","\tpendingDeletionsCount metric.Int64UpDownCounter","","\t// Cache for tracking unique resources","\tseenResources map[types.UID]bool","\tcacheMutex    sync.RWMutex","}","","var (","\trecorder *Recorder","\tonce     sync.Once",")","","// GetRecorder returns the singleton metrics recorder instance","func GetRecorder() *Recorder {","\tonce.Do(func() {","\t\trecorder = newRecorder()","\t})","\treturn recorder","}","","// newRecorder creates and initializes a new metrics recorder with all instruments","func newRecorder() *Recorder {","\tmeter := otel.Meter(\"tekton_pruner_controller\")","","\tr := \u0026Recorder{}","","\t// Initialize cache for unique resource tracking","\tr.seenResources = make(map[types.UID]bool)","","\t// Initialize counters","\tr.resourcesProcessed, _ = meter.Int64Counter(","\t\tMetricResourcesProcessed,","\t\tmetric.WithDescription(\"Total number of Tekton resources processed by the pruner\"),","\t\tmetric.WithUnit(\"1\"),","\t)","","\tr.reconciliationEvents, _ = meter.Int64Counter(","\t\tMetricReconciliationEvents,","\t\tmetric.WithDescription(\"Total number of reconciliation events processed by the pruner\"),","\t\tmetric.WithUnit(\"1\"),","\t)","","\tr.resourcesDeleted, _ = meter.Int64Counter(","\t\tMetricResourcesDeleted,","\t\tmetric.WithDescription(\"Total number of Tekton resources deleted by the pruner\"),","\t\tmetric.WithUnit(\"1\"),","\t)","","\tr.resourcesErrors, _ = meter.Int64Counter(","\t\tMetricResourcesErrors,","\t\tmetric.WithDescription(\"Total number of errors encountered while processing Tekton resources\"),","\t\tmetric.WithUnit(\"1\"),","\t)","","\t// Initialize histograms","\tr.reconciliationDuration, _ = meter.Float64Histogram(","\t\tMetricReconciliationDuration,","\t\tmetric.WithDescription(\"Time spent in reconciliation loops\"),","\t\tmetric.WithUnit(\"s\"),","\t\tmetric.WithExplicitBucketBoundaries(0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0),","\t)","","\tr.ttlProcessingDuration, _ = meter.Float64Histogram(","\t\tMetricTTLProcessingDuration,","\t\tmetric.WithDescription(\"Time spent processing TTL-based pruning\"),","\t\tmetric.WithUnit(\"s\"),","\t\tmetric.WithExplicitBucketBoundaries(0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0),","\t)","","\tr.historyProcessingDuration, _ = meter.Float64Histogram(","\t\tMetricHistoryProcessingDuration,","\t\tmetric.WithDescription(\"Time spent processing history-based pruning\"),","\t\tmetric.WithUnit(\"s\"),","\t\tmetric.WithExplicitBucketBoundaries(0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0),","\t)","","\tr.resourceAgeAtDeletion, _ = meter.Float64Histogram(","\t\tMetricResourceAgeAtDeletion,","\t\tmetric.WithDescription(\"Age of resources when they are deleted\"),","\t\tmetric.WithUnit(\"s\"),","\t\tmetric.WithExplicitBucketBoundaries(","\t\t\t60, 300, 600, 1800, 3600, 7200, 14400, 28800, 86400, 172800, 345600, 604800,","\t\t), // 1m, 5m, 10m, 30m, 1h, 2h, 4h, 8h, 1d, 2d, 4d, 1w","\t)","","\t// Initialize up-down counters","\tr.activeResourcesCount, _ = meter.Int64UpDownCounter(","\t\tMetricActiveResourcesCount,","\t\tmetric.WithDescription(\"Current number of active Tekton resources being tracked\"),","\t\tmetric.WithUnit(\"1\"),","\t)","","\tr.pendingDeletionsCount, _ = meter.Int64UpDownCounter(","\t\tMetricPendingDeletionsCount,","\t\tmetric.WithDescription(\"Current number of resources pending deletion\"),","\t\tmetric.WithUnit(\"1\"),","\t)","","\treturn r","}","","// Timer represents a duration measurement that can be recorded when stopped","type Timer struct {","\tstart    time.Time","\trecorder *Recorder","\tlabels   []attribute.KeyValue","}","","// NewTimer creates a new timer for measuring durations","func (r *Recorder) NewTimer(labels ...attribute.KeyValue) *Timer {","\treturn \u0026Timer{","\t\tstart:    time.Now(),","\t\trecorder: r,","\t\tlabels:   labels,","\t}","}","","// RecordReconciliationDuration records the duration since the timer was created","func (t *Timer) RecordReconciliationDuration(ctx context.Context) {","\tduration := time.Since(t.start).Seconds()","\tt.recorder.reconciliationDuration.Record(ctx, duration, metric.WithAttributes(t.labels...))","}","","// RecordTTLProcessingDuration records the duration since the timer was created","func (t *Timer) RecordTTLProcessingDuration(ctx context.Context) {","\tduration := time.Since(t.start).Seconds()","\tt.recorder.ttlProcessingDuration.Record(ctx, duration, metric.WithAttributes(t.labels...))","}","","// RecordHistoryProcessingDuration records the duration since the timer was created","func (t *Timer) RecordHistoryProcessingDuration(ctx context.Context) {","\tduration := time.Since(t.start).Seconds()","\tt.recorder.historyProcessingDuration.Record(ctx, duration, metric.WithAttributes(t.labels...))","}","","// RecordReconciliationEvent increments the reconciliation events counter","func (r *Recorder) RecordReconciliationEvent(ctx context.Context, resourceType, namespace, status string) {","\tlabels := []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t\tattribute.String(LabelStatus, status),","\t}","\tr.reconciliationEvents.Add(ctx, 1, metric.WithAttributes(labels...))","}","","// RecordResourceProcessed increments the unique resources counter if this UID hasn't been seen before","func (r *Recorder) RecordResourceProcessed(ctx context.Context, resourceUID types.UID, resourceType, namespace, status string) {","\tr.cacheMutex.Lock()","\tdefer r.cacheMutex.Unlock()","","\t// Only count if we haven't seen this UID before","\tif !r.seenResources[resourceUID] {","\t\tr.seenResources[resourceUID] = true","","\t\tlabels := []attribute.KeyValue{","\t\t\tattribute.String(LabelResourceType, resourceType),","\t\t\tattribute.String(LabelNamespace, namespace),","\t\t\tattribute.String(LabelStatus, status),","\t\t}","\t\tr.resourcesProcessed.Add(ctx, 1, metric.WithAttributes(labels...))","\t}","}","","// RecordResourceDeleted increments the resources deleted counter and records age","func (r *Recorder) RecordResourceDeleted(ctx context.Context, resourceType, namespace, operation string, resourceAge time.Duration) {","\t// Record deletion count","\tlabels := []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t\tattribute.String(LabelOperation, operation),","\t}","\tr.resourcesDeleted.Add(ctx, 1, metric.WithAttributes(labels...))","","\t// Record resource age at deletion","\tr.resourceAgeAtDeletion.Record(ctx, resourceAge.Seconds(), metric.WithAttributes(labels...))","}","","// RecordResourceError increments the resources error counter","func (r *Recorder) RecordResourceError(ctx context.Context, resourceType, namespace, errorType, reason string) {","\tlabels := []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t\tattribute.String(LabelErrorType, errorType),","\t\tattribute.String(LabelReason, reason),","\t}","\tr.resourcesErrors.Add(ctx, 1, metric.WithAttributes(labels...))","}","","// UpdateActiveResourcesCount updates the active resources gauge","func (r *Recorder) UpdateActiveResourcesCount(ctx context.Context, resourceType, namespace string, delta int64) {","\tlabels := []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t}","\tr.activeResourcesCount.Add(ctx, delta, metric.WithAttributes(labels...))","}","","// UpdatePendingDeletionsCount updates the pending deletions gauge","func (r *Recorder) UpdatePendingDeletionsCount(ctx context.Context, resourceType, namespace string, delta int64) {","\tlabels := []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t}","\tr.pendingDeletionsCount.Add(ctx, delta, metric.WithAttributes(labels...))","}","","// Helper functions for creating common attribute sets","","// ResourceAttributes creates common resource-related attributes","func ResourceAttributes(resourceType, namespace string) []attribute.KeyValue {","\treturn []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t}","}","","// ErrorAttributes creates error-related attributes","func ErrorAttributes(resourceType, namespace, errorType, reason string) []attribute.KeyValue {","\treturn []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t\tattribute.String(LabelErrorType, errorType),","\t\tattribute.String(LabelReason, reason),","\t}","}","","// OperationAttributes creates operation-related attributes","func OperationAttributes(resourceType, namespace, operation string) []attribute.KeyValue {","\treturn []attribute.KeyValue{","\t\tattribute.String(LabelResourceType, resourceType),","\t\tattribute.String(LabelNamespace, namespace),","\t\tattribute.String(LabelOperation, operation),","\t}","}","","// ClassifyError determines the error type based on the error","func ClassifyError(err error) string {","\tif err == nil {","\t\treturn \"\"","\t}","","\tswitch {","\tcase isAPIError(err):","\t\treturn ErrorTypeAPI","\tcase isTimeoutError(err):","\t\treturn ErrorTypeTimeout","\tcase isValidationError(err):","\t\treturn ErrorTypeValidation","\tcase isNotFoundError(err):","\t\treturn ErrorTypeNotFound","\tcase isPermissionError(err):","\t\treturn ErrorTypePermission","\tdefault:","\t\treturn ErrorTypeInternal","\t}","}","","// Helper functions to classify errors (can be expanded based on actual error types)","","func isAPIError(err error) bool {","\t// Check for Kubernetes API errors","\treturn errors.IsInternalError(err) || errors.IsServerTimeout(err) || errors.IsServiceUnavailable(err)","}","","func isTimeoutError(err error) bool {","\t// Check for timeout-related errors","\treturn errors.IsTimeout(err) || errors.IsServerTimeout(err)","}","","func isValidationError(err error) bool {","\t// Check for validation errors","\treturn errors.IsInvalid(err) || errors.IsBadRequest(err)","}","","func isNotFoundError(err error) bool {","\t// Check for not found errors","\treturn errors.IsNotFound(err)","}","","func isPermissionError(err error) bool {","\t// Check for permission/authorization errors","\treturn errors.IsForbidden(err) || errors.IsUnauthorized(err)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,0,1,1,1,1,1,1,1,0,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,0,0,1,1,1,1,1,1,1,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,0,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2]},{"id":7,"path":"pkg/reconciler/namespaceprunerconfig/controller.go","lines":["package namespaceprunerconfig","","import (","\t\"context\"","","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"go.uber.org/zap\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/client-go/tools/cache\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tconfigmapinformer \"knative.dev/pkg/client/injection/kube/informers/core/v1/configmap\"","\tnamespaceinformer \"knative.dev/pkg/client/injection/kube/informers/core/v1/namespace\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\tlogger := logging.FromContext(ctx)","\tlogger.Info(\"Starting Namespace Pruner Config controller\")","","\tkubeClient := kubeclient.Get(ctx)","\tconfigMapInformer := configmapinformer.Get(ctx)","\tnamespaceInformer := namespaceinformer.Get(ctx)","","\tr := \u0026Reconciler{","\t\tkubeclient: kubeClient,","\t}","","\timpl := controller.NewContext(ctx, r, controller.ControllerOptions{","\t\tLogger:        logger,","\t\tWorkQueueName: \"namespace-pruner-config\",","\t})","","\t// Add event handler to watch ConfigMaps with the specified name across filtered namespaces","\t// The informer will only watch namespaces specified via injection.WithNamespaceScope()","\t_, err := configMapInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: func(obj interface{}) bool {","\t\t\tcm, ok := obj.(*corev1.ConfigMap)","\t\t\tif !ok {","\t\t\t\treturn false","\t\t\t}","\t\t\t// Only react to ConfigMaps with the namespace-level pruner config name","\t\t\treturn cm.Name == config.PrunerNamespaceConfigMapName","\t\t},","\t\tHandler: cache.ResourceEventHandlerFuncs{","\t\t\tAddFunc:    func(obj interface{}) { impl.Enqueue(obj) },","\t\t\tUpdateFunc: func(oldObj, newObj interface{}) { impl.Enqueue(newObj) },","\t\t\tDeleteFunc: func(obj interface{}) { impl.Enqueue(obj) },","\t\t},","\t})","\tif err != nil {","\t\tlogger.Fatal(\"Failed to add ConfigMap event handler\", zap.Error(err))","\t}","","\t// Watch for namespace deletions to clean up orphaned config entries","\t// This prevents memory leaks when namespaces are deleted","\t_, err = namespaceInformer.Informer().AddEventHandler(cache.ResourceEventHandlerFuncs{","\t\tDeleteFunc: func(obj interface{}) {","\t\t\tns, ok := obj.(*corev1.Namespace)","\t\t\tif !ok {","\t\t\t\t// Handle tombstone case (object was deleted but informer hasn't caught up)","\t\t\t\ttombstone, ok := obj.(cache.DeletedFinalStateUnknown)","\t\t\t\tif !ok {","\t\t\t\t\tlogger.Warnw(\"Failed to decode namespace deletion event\", \"object\", obj)","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\tns, ok = tombstone.Obj.(*corev1.Namespace)","\t\t\t\tif !ok {","\t\t\t\t\tlogger.Warnw(\"Tombstone contained unexpected object\", \"object\", tombstone.Obj)","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t}","","\t\t\t// Clean up namespace config from the store when namespace is deleted","\t\t\tlogger.Infow(\"Namespace deleted, cleaning up config\", \"namespace\", ns.Name)","\t\t\tconfig.PrunerConfigStore.DeleteNamespaceConfig(ctx, ns.Name)","\t\t},","\t})","\tif err != nil {","\t\tlogger.Fatal(\"Failed to add Namespace event handler\", zap.Error(err))","\t}","","\treturn impl","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,0,1,0]},{"id":8,"path":"pkg/reconciler/namespaceprunerconfig/reconciler.go","lines":["package namespaceprunerconfig","","import (","\t\"context\"","\t\"strings\"","","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","// Reconciler implements controller.Reconciler for NamespacePrunerConfig resources","type Reconciler struct {","\tkubeclient kubernetes.Interface","}","","// Reconcile is called when a ConfigMap with name \"tekton-pruner-namespace-spec\" changes","func (r *Reconciler) Reconcile(ctx context.Context, key string) error {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugf(\"Reconciling namespace pruner config: %s\", key)","","\t// Parse the key to get namespace and name","\tnamespace, name, err := parseKey(key)","\tif err != nil {","\t\tlogger.Errorf(\"Invalid key: %s\", key)","\t\treturn err","\t}","","\t// Get the ConfigMap","\tcm, err := r.kubeclient.CoreV1().ConfigMaps(namespace).Get(ctx, name, metav1.GetOptions{})","\tif err != nil {","\t\t// If the ConfigMap is not found, it was deleted","\t\tif errors.IsNotFound(err) {","\t\t\tlogger.Infof(\"Namespace ConfigMap deleted: %s/%s\", namespace, name)","\t\t\tconfig.PrunerConfigStore.DeleteNamespaceConfig(ctx, namespace)","\t\t\treturn nil","\t\t}","\t\tlogger.Errorf(\"Failed to get ConfigMap %s/%s: %v\", namespace, name, err)","\t\treturn err","\t}","","\t// Load the namespace config","\tlogger.Infof(\"Loading namespace config from ConfigMap: %s/%s\", namespace, name)","\tif err := config.PrunerConfigStore.LoadNamespaceConfig(ctx, namespace, cm); err != nil {","\t\tlogger.Errorf(\"Failed to load namespace config from ConfigMap %s/%s: %v\", namespace, name, err)","\t\treturn err","\t}","","\tlogger.Infof(\"Successfully loaded namespace config: %s/%s\", namespace, name)","\treturn nil","}","","// parseKey parses the key in the format \"namespace/name\" and returns namespace and name","func parseKey(key string) (namespace, name string, err error) {","\tparts := strings.SplitN(key, \"/\", 2)","\tif len(parts) != 2 {","\t\treturn \"\", \"\", controller.NewPermanentError(nil)","\t}","\treturn parts[0], parts[1], nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,1,1,0,0,0,2,2,2,2,2,0,2,2,0,0,0,2,2,2,2,2,2,0]},{"id":9,"path":"pkg/reconciler/pipelinerun/controller.go","lines":["package pipelinerun","","import (","\t\"context\"","\t\"os\"","","\tpipelineclient \"github.com/tektoncd/pipeline/pkg/client/injection/client\"","\tpipelineruninformer \"github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/pipelinerun\"","\tpipelinerunreconciler \"github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun\"","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"go.uber.org/zap\"","\t\"k8s.io/utils/clock\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","// NewController creates a Reconciler and returns the result of NewImpl.","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t// Obtain an informer to both the main and child resources. These will be started by","\t// the injection framework automatically. They'll keep a cached representation of the","\t// cluster's state of the respective resource at all times.","\tpipelineRunInformer := pipelineruninformer.Get(ctx)","","\tlogger := logging.FromContext(ctx)","","\tpipelineRunFuncs := \u0026PrFuncs{","\t\tclient: pipelineclient.Get(ctx),","\t}","\tttlHandler, err := config.NewTTLHandler(clock.RealClock{}, pipelineRunFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting ttl handler\", zap.Error(err))","\t}","","\thistoryLimiter, err := config.NewHistoryLimiter(pipelineRunFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting history limiter\", zap.Error(err))","\t}","","\tr := \u0026Reconciler{","\t\t// The client will be needed to create/delete Pods via the API.","\t\tkubeclient:     kubeclient.Get(ctx),","\t\tttlHandler:     ttlHandler,","\t\thistoryLimiter: historyLimiter,","\t}","","\t// number of works to process the events","\tconcurrentWorkers, err := config.GetEnvValueAsInt(config.EnvTTLConcurrentWorkersPipelineRun, config.DefaultTTLConcurrentWorkersPipelineRun)","\tif err != nil {","\t\tlogger.Fatalw(\"error on getting PipelineRun ttl concurrent workers count\",","\t\t\t\"environmentKey\", config.EnvTTLConcurrentWorkersPipelineRun, \"environmentValue\", os.Getenv(config.EnvTTLConcurrentWorkersPipelineRun),","\t\t\tzap.Error(err),","\t\t)","\t}","","\tctrlOptions := controller.Options{","\t\tConcurrency: concurrentWorkers,","\t}","","\timpl := pipelinerunreconciler.NewImpl(ctx, r, func(impl *controller.Impl) controller.Options { return ctrlOptions })","","\t// listen for events on the main resource and enqueue themselves.","\t_, err = pipelineRunInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue))","\tif err != nil {","\t\tlogger.Fatal(\"Failed to add event handler\", zap.Error(err))","\t}","\treturn impl","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0]},{"id":10,"path":"pkg/reconciler/pipelinerun/reconciler.go","lines":["package pipelinerun","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","","\tpipelinev1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"github.com/tektoncd/pruner/pkg/metrics\"","","\tpipelineversioned \"github.com/tektoncd/pipeline/pkg/client/clientset/versioned\"","\tpipelinerunreconciler \"github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/pipelinerun\"","\t\"go.uber.org/zap\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/reconciler\"",")","","// Reconciler includes the kubernetes client to interact with the cluster","type Reconciler struct {","\tkubeclient     kubernetes.Interface","\tttlHandler     *config.TTLHandler","\thistoryLimiter *config.HistoryLimiter","}","","// Check that our Reconciler implements Interface","var _ pipelinerunreconciler.Interface = (*Reconciler)(nil)","","// ReconcileKind implements Interface.ReconcileKind.","func (r *Reconciler) ReconcileKind(ctx context.Context, pr *pipelinev1.PipelineRun) reconciler.Event {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"received a PipelineRun event\", \"namespace\", pr.Namespace, \"name\", pr.Name, \"status\", pr.Status)","","\t// Start timing the reconciliation","\tmetricsRecorder := metrics.GetRecorder()","\treconcileTimer := metricsRecorder.NewTimer(metrics.ResourceAttributes(metrics.ResourceTypePipelineRun, pr.Namespace)...)","\tdefer reconcileTimer.RecordReconciliationDuration(ctx)","","\t// Record that we processed a resource","\tstatus := metrics.StatusSuccess","\tdefer func() {","\t\t// Record reconciliation event (every reconciliation)","\t\tmetricsRecorder.RecordReconciliationEvent(ctx, metrics.ResourceTypePipelineRun, pr.Namespace, status)","\t\t// Record unique resource (only first time we see this UID)","\t\tmetricsRecorder.RecordResourceProcessed(ctx, pr.UID, metrics.ResourceTypePipelineRun, pr.Namespace, status)","\t}()","","\t// execute the history limiter earlier than the ttl handler","","\t// execute history limit action","\thistoryTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypePipelineRun, pr.Namespace, metrics.OperationHistory)...)","\terr := r.historyLimiter.ProcessEvent(ctx, pr)","\thistoryTimer.RecordHistoryProcessingDuration(ctx)","","\tif err != nil {","\t\tstatus = metrics.StatusError","\t\terrorType := metrics.ClassifyError(err)","\t\tmetricsRecorder.RecordResourceError(ctx, metrics.ResourceTypePipelineRun, pr.Namespace, errorType, \"history_processing_failed\")","\t\tlogger.Errorw(\"Error on processing history limiting for a PipelineRun\", \"namespace\", pr.Namespace, \"name\", pr.Name, zap.Error(err))","\t\treturn err","\t}","","\t// execute ttl handler","\tttlTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypePipelineRun, pr.Namespace, metrics.OperationTTL)...)","\terr = r.ttlHandler.ProcessEvent(ctx, pr)","\tttlTimer.RecordTTLProcessingDuration(ctx)","","\tif err != nil {","\t\tisRequeueKey, _ := controller.IsRequeueKey(err)","\t\t// the error is not a requeue error, print the error","\t\tif !isRequeueKey {","\t\t\tstatus = metrics.StatusError","\t\t\terrorType := metrics.ClassifyError(err)","\t\t\tmetricsRecorder.RecordResourceError(ctx, metrics.ResourceTypePipelineRun, pr.Namespace, errorType, \"ttl_processing_failed\")","\t\t\tdata, _ := json.Marshal(pr)","\t\t\tlogger.Errorw(\"Error on processing ttl for a PipelineRun\", \"namespace\", pr.Namespace, \"name\", pr.Name, \"resource\", string(data), zap.Error(err))","\t\t}","\t\treturn err","\t}","","\treturn nil","}","","// PrFuncs provides methods for working with PipelineRun resources","// it contains a client to interact with the pipeline API and manage PipelineRuns","type PrFuncs struct {","\tclient pipelineversioned.Interface","}","","// Type returns the kind of resource represented by the PRFuncs struct, which is \"PipelineRun\".","func (prf *PrFuncs) Type() string {","\treturn config.KindPipelineRun","}","","// NewPrFuncs creates a new instance of PrFuncs with the provided pipeline client.","// This client is used to interact with the Tekton Pipeline API.","func NewPrFuncs(client pipelineversioned.Interface) *PrFuncs {","\treturn \u0026PrFuncs{client: client}","}","","// List returns a list of PipelineRuns in a given namespace with a label selector.","func (prf *PrFuncs) List(ctx context.Context, namespace, label string) ([]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","","\t// TODO: should we have to implement pagination support?","\tprsList, err := prf.client.TektonV1().PipelineRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: label})","\tif err != nil {","\t\treturn nil, err","\t}","","\tprs := []metav1.Object{}","\tprnames := []string{}","\tfor _, pr := range prsList.Items {","\t\tprs = append(prs, pr.DeepCopy())","\t\tprnames = append(prnames, pr.GetName())","\t}","","\tlogger.Debugw(\"PipelineRuns list\", \"namespace\", namespace, \"label\", label, \"prnames\", prnames)","","\treturn prs, nil","}","","// ListByLabels returns a list of PipelineRuns in a given namespace filtered by multiple labels.","func (prf *PrFuncs) ListByLabels(ctx context.Context, namespace string, labels map[string]string) ([]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","\tselector := metav1.FormatLabelSelector(\u0026metav1.LabelSelector{MatchLabels: labels})","","\tprsList, err := prf.client.TektonV1().PipelineRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: selector})","\tif err != nil {","\t\treturn nil, err","\t}","","\tprs := []metav1.Object{}","\tfor _, pr := range prsList.Items {","\t\tprs = append(prs, pr.DeepCopy())","\t}","","\tlogger.Debugw(\"PipelineRuns list by labels\", \"namespace\", namespace, \"labels\", labels)","","\treturn prs, nil","}","","// ListByAnnotations returns a list of PipelineRuns in a given namespace filtered by annotations.","func (prf *PrFuncs) ListByAnnotations(ctx context.Context, namespace string, annotations map[string]string) ([]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","\tallPrs, err := prf.List(ctx, namespace, \"\")","\tif err != nil {","\t\treturn nil, err","\t}","","\tfilteredPrs := []metav1.Object{}","\tfor _, pr := range allPrs {","\t\tmatch := true","\t\tfor key, value := range annotations {","\t\t\tif pr.GetAnnotations()[key] != value {","\t\t\t\tmatch = false","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif match {","\t\t\tfilteredPrs = append(filteredPrs, pr)","\t\t}","\t}","","\tlogger.Debugw(\"PipelineRuns list by annotations\", \"namespace\", namespace, \"annotations\", annotations)","","\treturn filteredPrs, nil","}","","// ListByNamespaces returns a list of PipelineRuns across multiple namespaces.","func (prf *PrFuncs) ListByNamespaces(ctx context.Context, namespaces []string) (map[string][]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","\tresults := make(map[string][]metav1.Object)","","\tfor _, ns := range namespaces {","\t\tprs, err := prf.List(ctx, ns, \"\")","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to list PipelineRuns\", \"namespace\", ns, \"error\", err)","\t\t\tcontinue","\t\t}","\t\tresults[ns] = prs","\t}","","\tlogger.Debugw(\"PipelineRuns list by namespaces\", \"namespaces\", namespaces)","","\treturn results, nil","}","","/*","// List returns a list of PipelineRuns in a given namespace with label and annotation selectors.","// Annotations take higher priority. If annotations match, labels are ignored for that resource.","func (prf *PrFuncs) List(ctx context.Context, namespace string, annotations interface{}, labels interface{}) ([]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","","\tvar annotationSelector string","\tvar labelSelector string","","\t// Handle annotations (manually filter later if provided)","\tif annotations != nil {","\t\tswitch v := annotations.(type) {","\t\tcase string:","\t\t\t// If a single annotation is provided, use it directly","\t\t\tannotationSelector = v","\t\tcase map[string]string:","\t\t\t// If a map of annotations is provided, construct a selector for multiple annotations","\t\t\tfor key, value := range v {","\t\t\t\tif annotationSelector != \"\" {","\t\t\t\t\tannotationSelector += \",\"","\t\t\t\t}","\t\t\t\tannotationSelector += key + \"=\" + value","\t\t\t}","\t\tdefault:","\t\t\treturn nil, fmt.Errorf(\"invalid annotations type: must be string or map[string]string\")","\t\t}","\t}","\tlogger.Debugw(\"annotationSelector\", annotationSelector)","","\t// Handle labels","\tif labels != nil {","\t\tswitch v := labels.(type) {","\t\tcase string:","\t\t\t// If a single label is provided, use it directly","\t\t\tlabelSelector = v","\t\tcase map[string]string:","\t\t\t// If a map of labels is provided, construct a selector for multiple labels","\t\t\tfor key, value := range v {","\t\t\t\tif labelSelector != \"\" {","\t\t\t\t\tlabelSelector += \",\"","\t\t\t\t}","\t\t\t\tlabelSelector += key + \"=\" + value","\t\t\t}","\t\tdefault:","\t\t\treturn nil, fmt.Errorf(\"invalid labels type: must be string or map[string]string\")","\t\t}","\t}","","\tlogger.Debugw(\"labelSelector\", labelSelector)","","\t// Prepare options to list resources with the correct label selector","\toptions := metav1.ListOptions{}","","\t// Apply label selector if provided","\tif labelSelector != \"\" {","\t\toptions.LabelSelector = labelSelector","\t}","","\t// List PipelineRuns using the constructed label selector","\tprsList, err := prf.client.TektonV1().PipelineRuns(namespace).List(ctx, options)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Filter by annotations first if annotations are provided","\tvar filteredPRs []metav1.Object","\tif annotationSelector != \"\" {","\t\tfor _, pr := range prsList.Items {","\t\t\tmatches := true","\t\t\t// Check annotations if the selector matches","\t\t\tannotations := pr.GetAnnotations()","\t\t\tfor key, value := range annotations {","\t\t\t\tif !strings.Contains(annotationSelector, key+\"=\"+value) {","\t\t\t\t\tmatches = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\tif matches {","\t\t\t\t// If annotations match, include the resource and skip label filtering","\t\t\t\tfilteredPRs = append(filteredPRs, pr.DeepCopy())","\t\t\t}","\t\t}","\t} else {","\t\t// If no annotations are provided, apply label filtering","\t\tfor _, pr := range prsList.Items {","\t\t\tif labelSelector == \"\" || config.MatchLabels(pr.GetLabels(), labelSelector) {","\t\t\t\tfilteredPRs = append(filteredPRs, pr.DeepCopy())","\t\t\t}","\t\t}","\t}","","\t// Return the filtered list of PipelineRuns","\treturn filteredPRs, nil","}","*/","","// Get retrieves a specific PipelineRun by name in the given namespace.","func (prf *PrFuncs) Get(ctx context.Context, namespace, name string) (metav1.Object, error) {","\treturn prf.client.TektonV1().PipelineRuns(namespace).Get(ctx, name, metav1.GetOptions{})","}","","// Delete removes a specific PipelineRun by name in the given namespace.","func (prf *PrFuncs) Delete(ctx context.Context, namespace, name string) error {","\treturn prf.client.TektonV1().PipelineRuns(namespace).Delete(ctx, name, metav1.DeleteOptions{})","}","","// Update modifies an existing PipelineRun resource.","func (prf *PrFuncs) Update(ctx context.Context, resource metav1.Object) error {","\tpr, ok := resource.(*pipelinev1.PipelineRun)","\tif !ok {","\t\treturn fmt.Errorf(\"invalid type received. namespace:%s, Name:%s\", resource.GetNamespace(), resource.GetName())","\t}","\t_, err := prf.client.TektonV1().PipelineRuns(resource.GetNamespace()).Update(ctx, pr, metav1.UpdateOptions{})","\treturn err","}","","// Patch modifies an existing PipelineRun resource using a Merge Patch","// This is useful for updating only specific fields of the resource.","func (prf *PrFuncs) Patch(ctx context.Context, namespace, name string, patchBytes []byte) error {","\t_, err := prf.client.TektonV1().PipelineRuns(namespace).Patch(","\t\tctx,","\t\tname,","\t\ttypes.MergePatchType,","\t\tpatchBytes,","\t\tmetav1.PatchOptions{},","\t)","","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to patch PipelineRun %s/%s: %w\", namespace, name, err)","\t}","","\treturn nil","}","","// GetCompletionTime retrieves the completion time of a PipelineRun resource.","func (prf *PrFuncs) GetCompletionTime(resource metav1.Object) (metav1.Time, error) {","\tpr, ok := resource.(*pipelinev1.PipelineRun)","\tif !ok {","\t\treturn metav1.Time{}, fmt.Errorf(\"resource type error, this is not a PipelineRun resource. namespace:%s, name:%s, type:%T\",","\t\t\tresource.GetNamespace(), resource.GetName(), resource)","\t}","\tif pr.Status.CompletionTime != nil {","\t\treturn *pr.Status.CompletionTime, nil","\t}","\tfor _, c := range pr.Status.Conditions {","\t\tif c.Type == apis.ConditionSucceeded \u0026\u0026 c.Status != corev1.ConditionUnknown {","\t\t\tfinishAt := c.LastTransitionTime","\t\t\tif finishAt.Inner.IsZero() {","\t\t\t\treturn metav1.Time{}, fmt.Errorf(\"unable to find the time when the resource '%s/%s' finished\", pr.Namespace, pr.Name)","\t\t\t}","\t\t\treturn c.LastTransitionTime.Inner, nil","\t\t}","\t}","","\t// This should never happen if the Resource has finished","\treturn metav1.Time{}, fmt.Errorf(\"unable to find the status of the finished resource: %s/%s\", pr.Namespace, pr.Name)","}","","// Ignore returns true if the resource should be ignored based on labels and annotations.","func (prf *PrFuncs) Ignore(resource metav1.Object) bool {","\t// labels and annotations are not populated, lets wait sometime","\tif resource.GetLabels() == nil {","\t\tif resource.GetAnnotations() == nil || resource.GetAnnotations()[config.AnnotationTTLSecondsAfterFinished] == \"\" {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","// IsCompleted checks if the PipelineRun resource has completed.","func (prf *PrFuncs) IsCompleted(resource metav1.Object) bool {","\tpr, ok := resource.(*pipelinev1.PipelineRun)","\tif !ok {","\t\treturn false","\t}","","\tif pr.Status.StartTime == nil {","\t\treturn false","\t}","","\tif pr.Status.CompletionTime != nil {","\t\treturn true","\t}","","\tif pr.IsPending() {","\t\treturn false","\t}","","\t// check the status from conditions","\tcondition := pr.Status.GetCondition(apis.ConditionSucceeded)","\tif condition == nil || condition.Status == corev1.ConditionUnknown {","\t\treturn false","\t}","","\treturn true","}","","// IsSuccessful checks if the PipelineRun resource has successfully completed.","func (prf *PrFuncs) IsSuccessful(resource metav1.Object) bool {","\tpr, ok := resource.(*pipelinev1.PipelineRun)","\tif !ok {","\t\treturn false","\t}","","\tif pr.IsPending() {","\t\treturn false","\t}","","\tcondition := pr.Status.GetCondition(apis.ConditionSucceeded)","\tif condition == nil {","\t\treturn false","\t}","","\trunReason := pipelinev1.PipelineRunReason(condition.Reason)","","\tif runReason == pipelinev1.PipelineRunReasonSuccessful || runReason == pipelinev1.PipelineRunReasonCompleted {","\t\treturn true","\t}","","\treturn false","}","","// IsFailed checks if the PipelineRun resource has failed.","func (prf *PrFuncs) IsFailed(resource metav1.Object) bool {","\tpr, ok := resource.(*pipelinev1.PipelineRun)","\tif !ok {","\t\treturn false","\t}","","\tif pr.IsPending() {","\t\treturn false","\t}","","\treturn !prf.IsSuccessful(resource)","}","","// GetDefaultLabelKey returns the default label key for PipelineRun resources.","func (prf *PrFuncs) GetDefaultLabelKey() string {","\treturn config.LabelPipelineName","}","","// GetTTLSecondsAfterFinished retrieves the TTL (time-to-live) in seconds after a PipelineRun finishes.","func (prf *PrFuncs) GetTTLSecondsAfterFinished(namespace, pipelineName string, selectors config.SelectorSpec) (*int32, string) {","\treturn config.PrunerConfigStore.GetPipelineTTLSecondsAfterFinished(namespace, pipelineName, selectors)","}","","// GetSuccessHistoryLimitCount retrieves the success history limit count for a PipelineRun.","func (prf *PrFuncs) GetSuccessHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) {","\treturn config.PrunerConfigStore.GetPipelineSuccessHistoryLimitCount(namespace, name, selectors)","}","","// GetFailedHistoryLimitCount retrieves the failed history limit count for a PipelineRun.","func (prf *PrFuncs) GetFailedHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) {","\treturn config.PrunerConfigStore.GetPipelineFailedHistoryLimitCount(namespace, name, selectors)","}","","// GetEnforcedConfigLevel retrieves the enforced config level for a PipelineRun.","func (prf *PrFuncs) GetEnforcedConfigLevel(namespace, name string, selectors config.SelectorSpec) config.EnforcedConfigLevel {","\treturn config.PrunerConfigStore.GetPipelineEnforcedConfigLevel(namespace, name, selectors)","}","","// GetMatchingSelector returns the ConfigMap's selector that matches a PipelineRun.","func (prf *PrFuncs) GetMatchingSelector(namespace, name string, selectors config.SelectorSpec) *config.SelectorSpec {","\treturn config.PrunerConfigStore.GetPipelineMatchingSelector(namespace, name, selectors)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,1,1,1,1,1,1,0,0,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,2,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,0,2,2,2,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,2,2,0,0,0,2,2,2,2,1,1,0,2,2,2,2,2,1,1,0,0,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,1,1,0,2,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,1,1,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,1,0,2,0,0,0,2,2,2,1,1,1,2,2,2,2,1,1,1,1,1,1,0,0,0,0,2,0,0,0,2,2,2,2,2,2,0,2,0,0,0,2,2,2,1,1,0,2,2,2,0,2,2,2,0,2,1,1,0,0,2,2,2,2,0,2,0,0,0,2,2,2,1,1,0,2,1,1,0,2,2,1,1,0,2,2,2,1,1,0,2,0,0,0,2,2,2,1,1,0,2,1,1,0,2,0,0,0,2,2,2,0,0,2,2,2,0,0,1,1,1,0,0,2,2,2,0,0,2,2,2,0,0,1,1,1]},{"id":11,"path":"pkg/reconciler/taskrun/controller.go","lines":["package taskrun","","import (","\t\"context\"","\t\"os\"","","\tpipelineclient \"github.com/tektoncd/pipeline/pkg/client/injection/client\"","\ttaskruninformer \"github.com/tektoncd/pipeline/pkg/client/injection/informers/pipeline/v1/taskrun\"","\ttaskrunreconciler \"github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun\"","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"go.uber.org/zap\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/utils/clock\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/kmeta\"","\t\"knative.dev/pkg/logging\"",")","","// NewController creates a Reconciler and returns the result of NewImpl.","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t// Obtain an informer to both the main and child resources. These will be started by","\t// the injection framework automatically. They'll keep a cached representation of the","\t// cluster's state of the respective resource at all times.","\ttaskRunInformer := taskruninformer.Get(ctx)","","\tlogger := logging.FromContext(ctx)","","\ttaskRunFuncs := \u0026TrFuncs{","\t\tclient: pipelineclient.Get(ctx),","\t}","\tttlHandler, err := config.NewTTLHandler(clock.RealClock{}, taskRunFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting ttl handler\", zap.Error(err))","\t}","","\thistoryLimiter, err := config.NewHistoryLimiter(taskRunFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting history limiter\", zap.Error(err))","\t}","","\tr := \u0026Reconciler{","\t\t// The client will be needed to create/delete Pods via the API.","\t\tkubeclient:     kubeclient.Get(ctx),","\t\tttlHandler:     ttlHandler,","\t\thistoryLimiter: historyLimiter,","\t}","","\t// number of works to process the events","\tconcurrentWorkers, err := config.GetEnvValueAsInt(config.EnvTTLConcurrentWorkersTaskRun, config.DefaultTTLConcurrentWorkersTaskRun)","\tif err != nil {","\t\tlogger.Fatalw(\"error on getting TaskRun ttl concurrent workers count\",","\t\t\t\"environmentKey\", config.EnvTTLConcurrentWorkersTaskRun, \"environmentValue\", os.Getenv(config.EnvTTLConcurrentWorkersTaskRun),","\t\t\tzap.Error(err),","\t\t)","\t}","","\tctrlOptions := controller.Options{","\t\tConcurrency: concurrentWorkers,","\t}","","\timpl := taskrunreconciler.NewImpl(ctx, r, func(impl *controller.Impl) controller.Options { return ctrlOptions })","","\t_, err = taskRunInformer.Informer().AddEventHandler(controller.HandleAll(filterTaskRun(logger, impl)))","\tif err != nil {","\t\tlogger.Fatal(\"Failed to add event handler\", zap.Error(err))","\t}","","\treturn impl","}","","// filters the taskrun which has a parent","func filterTaskRun(logger *zap.SugaredLogger, impl *controller.Impl) func(obj interface{}) {","\treturn func(obj interface{}) {","\t\ttaskRun, err := kmeta.DeletionHandlingAccessor(obj)","\t\tif err != nil {","\t\t\tlogger.Errorw(\"error on getting object as Accessor\", zap.Error(err))","\t\t\treturn","\t\t}","","\t\tif !isStandaloneTaskRun(taskRun) {","\t\t\treturn","\t\t}","","\t\timpl.EnqueueKey(types.NamespacedName{Namespace: taskRun.GetNamespace(), Name: taskRun.GetName()})","\t}","}","","// returns true if the TaskRun is part of a PipelineRun","func isStandaloneTaskRun(taskRun metav1.Object) bool {","\t// verify the taskRun is not part of a pipelineRun","\tif taskRun.GetLabels() != nil \u0026\u0026 taskRun.GetLabels()[config.LabelPipelineRunName] != \"\" {","\t\treturn false","\t}","","\t// if the resource has owner reference as PipelineRun, it is not a standalone TaskRun","\t// if so, ignore this taskRun","\tif len(taskRun.GetOwnerReferences()) \u003e 0 {","\t\tfor _, ownerReference := range taskRun.GetOwnerReferences() {","\t\t\tif ownerReference.Kind == config.KindPipelineRun {","\t\t\t\treturn false","\t\t\t}","\t\t}","\t}","","\treturn true","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,0,2,2,2,1,1,0,0,0,2,2,2,2,2,0,0,0,2,0]},{"id":12,"path":"pkg/reconciler/taskrun/reconciler.go","lines":["package taskrun","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","","\t\"go.uber.org/zap\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","","\tpipelinev1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1\"","\tpipelineversioned \"github.com/tektoncd/pipeline/pkg/client/clientset/versioned\"","\ttaskrunreconciler \"github.com/tektoncd/pipeline/pkg/client/injection/reconciler/pipeline/v1/taskrun\"","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"github.com/tektoncd/pruner/pkg/metrics\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/reconciler\"",")","","// Reconciler implements simpledeploymentreconciler.Interface for","// SimpleDeployment resources.","type Reconciler struct {","\tkubeclient     kubernetes.Interface","\tttlHandler     *config.TTLHandler","\thistoryLimiter *config.HistoryLimiter","}","","// Check that our Reconciler implements Interface","var _ taskrunreconciler.Interface = (*Reconciler)(nil)","","// ReconcileKind implements Interface.ReconcileKind.","func (r *Reconciler) ReconcileKind(ctx context.Context, tr *pipelinev1.TaskRun) reconciler.Event {","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"received a TaskRun event\",","\t\t\"namespace\", tr.Namespace, \"name\", tr.Name,","\t)","","\t// if the TaskRun is not a standalone, no action needed","\t// if so, will be handled by it is parent resource(PipelineRun)","\tif !isStandaloneTaskRun(tr) {","\t\treturn nil","\t}","","\t// Start timing the reconciliation","\tmetricsRecorder := metrics.GetRecorder()","\treconcileTimer := metricsRecorder.NewTimer(metrics.ResourceAttributes(metrics.ResourceTypeTaskRun, tr.Namespace)...)","\tdefer reconcileTimer.RecordReconciliationDuration(ctx)","","\t// Record that we processed a resource","\tstatus := metrics.StatusSuccess","\tdefer func() {","\t\t// Record reconciliation event (every reconciliation)","\t\tmetricsRecorder.RecordReconciliationEvent(ctx, metrics.ResourceTypeTaskRun, tr.Namespace, status)","\t\t// Record unique resource (only first time we see this UID)","\t\tmetricsRecorder.RecordResourceProcessed(ctx, tr.UID, metrics.ResourceTypeTaskRun, tr.Namespace, status)","\t}()","","\t// execute the history limiter earlier than the ttl handler","","\t// execute history limit action","\thistoryTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypeTaskRun, tr.Namespace, metrics.OperationHistory)...)","\terr := r.historyLimiter.ProcessEvent(ctx, tr)","\thistoryTimer.RecordHistoryProcessingDuration(ctx)","","\tif err != nil {","\t\tstatus = metrics.StatusError","\t\terrorType := metrics.ClassifyError(err)","\t\tmetricsRecorder.RecordResourceError(ctx, metrics.ResourceTypeTaskRun, tr.Namespace, errorType, \"history_processing_failed\")","\t\tlogger.Errorw(\"Error on processing history limiting for a TaskRun\",","\t\t\t\"namespace\", tr.Namespace, \"name\", tr.Name,","\t\t\tzap.Error(err),","\t\t)","\t\treturn err","\t}","","\t// execute ttl handler","\tttlTimer := metricsRecorder.NewTimer(metrics.OperationAttributes(metrics.ResourceTypeTaskRun, tr.Namespace, metrics.OperationTTL)...)","\terr = r.ttlHandler.ProcessEvent(ctx, tr)","\tttlTimer.RecordTTLProcessingDuration(ctx)","","\tif err != nil {","\t\tisRequeueKey, _ := controller.IsRequeueKey(err)","\t\t// the error is not a requeue error, print the error","\t\tif !isRequeueKey {","\t\t\tstatus = metrics.StatusError","\t\t\terrorType := metrics.ClassifyError(err)","\t\t\tmetricsRecorder.RecordResourceError(ctx, metrics.ResourceTypeTaskRun, tr.Namespace, errorType, \"ttl_processing_failed\")","\t\t\tdata, _ := json.Marshal(tr)","\t\t\tlogger.Errorw(\"Error on processing ttl for a TaskRun\",","\t\t\t\t\"namespace\", tr.Namespace, \"name\", tr.Name,","\t\t\t\t\"resource\", string(data),","\t\t\t\tzap.Error(err),","\t\t\t)","\t\t}","\t\treturn err","\t}","","\treturn nil","}","","// TrFuncs provides methods for working with TaskRun resources","// it contains a client to interact with the pipeline API and manage TaskRuns","type TrFuncs struct {","\tclient pipelineversioned.Interface","}","","// Type returns the kind of resource represented by the TaskRunFuncs struct, which is \"TaskRun\".","func (trf *TrFuncs) Type() string {","\treturn config.KindTaskRun","}","","// NewTrFuncs creates a new instance of TrFuncs with the provided pipeline client.","// This client is used to interact with the Tekton pipeline API.","func NewTrFuncs(client pipelineversioned.Interface) *TrFuncs {","\treturn \u0026TrFuncs{client: client}","}","","// List returns a list of TaskRuns in a given namespace with a label selector.","func (trf *TrFuncs) List(ctx context.Context, namespace, labelSelector string) ([]metav1.Object, error) {","\t// TODO: should we have to implement pagination support?","\tprsList, err := trf.client.TektonV1().TaskRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: labelSelector})","\tif err != nil {","\t\treturn nil, err","\t}","","\ttrs := []metav1.Object{}","\tfor _, tr := range prsList.Items {","\t\ttrs = append(trs, tr.DeepCopy())","\t}","\treturn trs, nil","}","","// ListByLabels returns a list of TaskRuns in a given namespace filtered by multiple labels.","func (trf *TrFuncs) ListByLabels(ctx context.Context, namespace string, labels map[string]string) ([]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","\tselector := metav1.FormatLabelSelector(\u0026metav1.LabelSelector{MatchLabels: labels})","","\ttrsList, err := trf.client.TektonV1().TaskRuns(namespace).List(ctx, metav1.ListOptions{LabelSelector: selector})","\tif err != nil {","\t\treturn nil, err","\t}","","\ttrs := []metav1.Object{}","\tfor _, tr := range trsList.Items {","\t\ttrs = append(trs, tr.DeepCopy())","\t}","","\tlogger.Debugw(\"TaskRuns list by labels\", \"namespace\", namespace, \"labels\", labels)","","\treturn trs, nil","}","","// ListByAnnotations returns a list of TaskRuns in a given namespace filtered by annotations.","func (trf *TrFuncs) ListByAnnotations(ctx context.Context, namespace string, annotations map[string]string) ([]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","\tallTrs, err := trf.List(ctx, namespace, \"\")","\tif err != nil {","\t\treturn nil, err","\t}","","\tfilteredTrs := []metav1.Object{}","\tfor _, tr := range allTrs {","\t\tmatch := true","\t\tfor key, value := range annotations {","\t\t\tif tr.GetAnnotations()[key] != value {","\t\t\t\tmatch = false","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif match {","\t\t\tfilteredTrs = append(filteredTrs, tr)","\t\t}","\t}","","\tlogger.Debugw(\"TaskRuns list by annotations\", \"namespace\", namespace, \"annotations\", annotations)","","\treturn filteredTrs, nil","}","","// ListByNamespaces returns a list of TaskRuns across multiple namespaces.","func (trf *TrFuncs) ListByNamespaces(ctx context.Context, namespaces []string) (map[string][]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","\tresults := make(map[string][]metav1.Object)","","\tfor _, ns := range namespaces {","\t\ttrs, err := trf.List(ctx, ns, \"\")","\t\tif err != nil {","\t\t\tlogger.Errorw(\"Failed to list TaskRuns\", \"namespace\", ns, \"error\", err)","\t\t\tcontinue","\t\t}","\t\tresults[ns] = trs","\t}","","\tlogger.Debugw(\"TaskRuns list by namespaces\", \"namespaces\", namespaces)","","\treturn results, nil","}","","/*","// List returns a list of TaskRuns in a given namespace with label and annotation selectors.","// Annotations take higher priority. If annotations match, labels are ignored for that resource.","func (trf *TrFuncs) List(ctx context.Context, namespace string, annotations interface{}, labels interface{}) ([]metav1.Object, error) {","\tlogger := logging.FromContext(ctx)","","\tvar annotationSelector string","\tvar labelSelector string","","\t// Handle annotations (manually filter later if provided)","\tif annotations != nil {","\t\tswitch v := annotations.(type) {","\t\tcase string:","\t\t\t// If a single annotation is provided, use it directly","\t\t\tannotationSelector = v","\t\tcase map[string]string:","\t\t\t// If a map of annotations is provided, construct a selector for multiple annotations","\t\t\tfor key, value := range v {","\t\t\t\tif annotationSelector != \"\" {","\t\t\t\t\tannotationSelector += \",\"","\t\t\t\t}","\t\t\t\tannotationSelector += key + \"=\" + value","\t\t\t}","\t\tdefault:","\t\t\treturn nil, fmt.Errorf(\"invalid annotations type: must be string or map[string]string\")","\t\t}","\t}","\tlogger.Debugw(\"annotationSelector\", annotationSelector)","","\t// Handle labels","\tif labels != nil {","\t\tswitch v := labels.(type) {","\t\tcase string:","\t\t\t// If a single label is provided, use it directly","\t\t\tlabelSelector = v","\t\tcase map[string]string:","\t\t\t// If a map of labels is provided, construct a selector for multiple labels","\t\t\tfor key, value := range v {","\t\t\t\tif labelSelector != \"\" {","\t\t\t\t\tlabelSelector += \",\"","\t\t\t\t}","\t\t\t\tlabelSelector += key + \"=\" + value","\t\t\t}","\t\tdefault:","\t\t\treturn nil, fmt.Errorf(\"invalid labels type: must be string or map[string]string\")","\t\t}","\t}","\tlogger.Debugw(\"labelSelector\", labelSelector)","","\t// Prepare options to list resources with the correct label selector","\toptions := metav1.ListOptions{}","","\t// Apply label selector if provided","\tif labelSelector != \"\" {","\t\toptions.LabelSelector = labelSelector","\t}","","\t// List TaskRuns using the constructed label selector","\ttrsList, err := trf.client.TektonV1().TaskRuns(namespace).List(ctx, options)","\tif err != nil {","\t\treturn nil, err","\t}","","\t// Filter by annotations first if annotations are provided","\tvar filteredTRs []metav1.Object","\tif annotationSelector != \"\" {","\t\tfor _, tr := range trsList.Items {","\t\t\tmatches := true","\t\t\t// Check annotations if the selector matches","\t\t\tannotations := tr.GetAnnotations()","\t\t\tfor key, value := range annotations {","\t\t\t\tif !strings.Contains(annotationSelector, key+\"=\"+value) {","\t\t\t\t\tmatches = false","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t}","\t\t\tif matches {","\t\t\t\t// If annotations match, include the resource and skip label filtering","\t\t\t\tfilteredTRs = append(filteredTRs, tr.DeepCopy())","\t\t\t}","\t\t}","\t} else {","\t\t// If no annotations are provided, apply label filtering","\t\tfor _, tr := range trsList.Items {","\t\t\tif labelSelector == \"\" || config.MatchLabels(tr.GetLabels(), labelSelector) {","\t\t\t\tfilteredTRs = append(filteredTRs, tr.DeepCopy())","\t\t\t}","\t\t}","\t}","","\t// Return the filtered list of TaskRuns","\treturn filteredTRs, nil","}","*/","","// Get retrieves a specific TaskRun by name in the given namespace.","func (trf *TrFuncs) Get(ctx context.Context, namespace, name string) (metav1.Object, error) {","\treturn trf.client.TektonV1().TaskRuns(namespace).Get(ctx, name, metav1.GetOptions{})","}","","// Delete removes a specific TaskRun by name in the given namespace.","func (trf *TrFuncs) Delete(ctx context.Context, namespace, name string) error {","\treturn trf.client.TektonV1().TaskRuns(namespace).Delete(ctx, name, metav1.DeleteOptions{})","}","","// Update modifies an existing TaskRun resource.","func (trf *TrFuncs) Update(ctx context.Context, resource metav1.Object) error {","\ttr, ok := resource.(*pipelinev1.TaskRun)","\tif !ok {","\t\treturn fmt.Errorf(\"invalid type received. namespace:%s, Name:%s\", resource.GetNamespace(), resource.GetName())","\t}","\t_, err := trf.client.TektonV1().TaskRuns(resource.GetNamespace()).Update(ctx, tr, metav1.UpdateOptions{})","\treturn err","}","","// Patch modifies an existing TaskRun resource using a JSON patch.","// This is useful for updating only specific fields of the resource.","func (trf *TrFuncs) Patch(ctx context.Context, namespace, name string, patchBytes []byte) error {","\t_, err := trf.client.TektonV1().TaskRuns(namespace).Patch(","\t\tctx,","\t\tname,","\t\ttypes.MergePatchType,","\t\tpatchBytes,","\t\tmetav1.PatchOptions{},","\t)","","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to patch TaskRun %s/%s: %w\", namespace, name, err)","\t}","","\treturn nil","}","","// GetCompletionTime retrieves the completion time of a TaskRun resource.","func (trf *TrFuncs) GetCompletionTime(resource metav1.Object) (metav1.Time, error) {","\ttr, ok := resource.(*pipelinev1.TaskRun)","\tif !ok {","\t\treturn metav1.Time{}, fmt.Errorf(\"resource type error, this is not a TaskRun resource. namespace:%s, name:%s, type:%T\",","\t\t\tresource.GetNamespace(), resource.GetName(), resource)","\t}","\tif tr.Status.CompletionTime != nil {","\t\treturn *tr.Status.CompletionTime, nil","\t}","","\t// check the status from conditions","\tcondition := tr.Status.GetCondition(apis.ConditionSucceeded)","\tif condition != nil \u0026\u0026 condition.Status != corev1.ConditionUnknown {","\t\tfinishAt := condition.LastTransitionTime","\t\tif finishAt.Inner.IsZero() {","\t\t\treturn metav1.Time{}, fmt.Errorf(\"unable to find the time when the resource '%s/%s' finished\", tr.Namespace, tr.Name)","\t\t}","\t\treturn condition.LastTransitionTime.Inner, nil","\t}","","\t// This should never happen if the Resource has finished","\treturn metav1.Time{}, fmt.Errorf(\"unable to find the status of the finished resource: %s/%s\", tr.Namespace, tr.Name)","}","","// Ignore returns true if the resource should be ignored based on labels and annotations.","func (trf *TrFuncs) Ignore(resource metav1.Object) bool {","\t// labels and annotations are not populated, lets wait sometime","\tif resource.GetLabels() == nil {","\t\tif resource.GetAnnotations() == nil || resource.GetAnnotations()[config.AnnotationTTLSecondsAfterFinished] == \"\" {","\t\t\treturn true","\t\t}","\t}","\treturn false","}","","// IsCompleted checks if the TaskRun resource has completed.","func (trf *TrFuncs) IsCompleted(resource metav1.Object) bool {","\ttr, ok := resource.(*pipelinev1.TaskRun)","\tif !ok {","\t\treturn false","\t}","","\tif tr.Status.StartTime == nil {","\t\treturn false","\t}","","\tif tr.Status.CompletionTime != nil {","\t\treturn true","\t}","","\t// check the status from conditions","\tcondition := tr.Status.GetCondition(apis.ConditionSucceeded)","\tif condition == nil || condition.Status == corev1.ConditionUnknown {","\t\treturn false","\t}","","\treturn true","}","","// IsSuccessful checks if the TaskRun resource has successfully completed.","func (trf *TrFuncs) IsSuccessful(resource metav1.Object) bool {","\ttr, ok := resource.(*pipelinev1.TaskRun)","\tif !ok {","\t\treturn false","\t}","","\tcondition := tr.Status.GetCondition(apis.ConditionSucceeded)","\tif condition == nil {","\t\treturn false","\t}","","\trunReason := pipelinev1.TaskRunReason(condition.Reason)","\treturn runReason == pipelinev1.TaskRunReasonSuccessful","}","","// IsFailed checks if the TaskRun resource has failed.","func (trf *TrFuncs) IsFailed(resource metav1.Object) bool {","\t_, ok := resource.(*pipelinev1.TaskRun)","\tif !ok {","\t\treturn false","\t}","","\treturn !trf.IsSuccessful(resource)","}","","// GetDefaultLabelKey returns the default label key for TaskRun resources.","func (trf *TrFuncs) GetDefaultLabelKey() string {","\treturn config.LabelTaskName","}","","// GetTTLSecondsAfterFinished retrieves the TTL (time-to-live) in seconds after a TaskRun finishes.","func (trf *TrFuncs) GetTTLSecondsAfterFinished(namespace, taskName string, selectors config.SelectorSpec) (*int32, string) {","\treturn config.PrunerConfigStore.GetTaskTTLSecondsAfterFinished(namespace, taskName, selectors)","}","","// GetSuccessHistoryLimitCount retrieves the success history limit count for a TaskRun.","func (trf *TrFuncs) GetSuccessHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) {","\treturn config.PrunerConfigStore.GetTaskSuccessHistoryLimitCount(namespace, name, selectors)","}","","// GetFailedHistoryLimitCount retrieves the failed history limit count for a TaskRun.","func (trf *TrFuncs) GetFailedHistoryLimitCount(namespace, name string, selectors config.SelectorSpec) (*int32, string) {","\treturn config.PrunerConfigStore.GetTaskFailedHistoryLimitCount(namespace, name, selectors)","}","","// GetEnforcedConfigLevel retrieves the enforced config level for a TaskRun.","func (trf *TrFuncs) GetEnforcedConfigLevel(namespace, name string, selectors config.SelectorSpec) config.EnforcedConfigLevel {","\treturn config.PrunerConfigStore.GetTaskEnforcedConfigLevel(namespace, name, selectors)","}","","// GetMatchingSelector returns the ConfigMap's selector that matches a TaskRun.","func (trf *TrFuncs) GetMatchingSelector(namespace, name string, selectors config.SelectorSpec) *config.SelectorSpec {","\treturn config.PrunerConfigStore.GetTaskMatchingSelector(namespace, name, selectors)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,2,0,0,2,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,0,0,2,2,2,2,1,1,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,2,2,2,0,0,0,2,2,2,2,1,1,0,2,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,1,1,0,2,0,0,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,2,2,2,0,0,2,2,2,1,1,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,1,0,2,0,0,0,2,2,2,1,1,1,2,2,2,0,0,2,2,1,1,1,1,1,0,0,0,2,0,0,0,2,2,2,2,2,2,0,2,0,0,0,2,2,2,1,1,0,2,2,2,0,2,2,2,0,0,2,2,2,2,0,2,0,0,0,2,2,2,1,1,0,2,2,1,1,0,2,2,0,0,0,2,2,2,1,1,0,2,0,0,0,2,2,2,0,0,2,2,2,0,0,1,1,1,0,0,2,2,2,0,0,2,2,2,0,0,1,1,1]},{"id":13,"path":"pkg/reconciler/tektonpruner/controller.go","lines":["package tektonpruner","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","\t\"sync\"","\t\"time\"","","\t\"go.uber.org/zap\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/system\"","","\tpipelineclient \"github.com/tektoncd/pipeline/pkg/client/injection/client\"","\t\"github.com/tektoncd/pruner/pkg/config\"","\t\"github.com/tektoncd/pruner/pkg/reconciler/pipelinerun\"","\t\"github.com/tektoncd/pruner/pkg/reconciler/taskrun\"","\t\"github.com/tektoncd/pruner/pkg/version\"","","\tclockUtil \"k8s.io/utils/clock\"","","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/types\"","\t\"k8s.io/client-go/kubernetes\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"",")","","// NewController creates a Reconciler and returns the result of NewImpl.","// It watches for changes to the pruner ConfigMap and triggers garbage collection (GC)","// when configuration changes are detected. The GC process cleans up resources based","// on the TTL configuration across all namespaces.","func NewController(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\tlogger := logging.FromContext(ctx)","","\tlogger.Info(\"Started Pruner controller\")","","\tver := version.Get()","\tlogger.Infow(\"pruner version details\",","\t\t\"version\", ver.Version, \"arch\", ver.Arch, \"platform\", ver.Platform,","\t\t\"goVersion\", ver.GoLang, \"buildDate\", ver.BuildDate, \"gitCommit\", ver.GitCommit,","\t)","","\tr := \u0026Reconciler{","\t\tkubeclient: kubeclient.Get(ctx),","\t}","","\timpl := controller.NewContext(ctx, r, controller.ControllerOptions{","\t\tLogger:        logger,","\t\tWorkQueueName: \"pruner\",","\t})","","\t// ConfigMap watcher triggers GC","\tcmw.Watch(config.PrunerConfigMapName, func(cm *corev1.ConfigMap) {","\t\tgo safeRunGarbageCollector(ctx, logger)","\t})","","\treturn impl","}","","// safeRunGarbageCollector is a thread-safe wrapper around the garbage collection process.","func safeRunGarbageCollector(ctx context.Context, logger *zap.SugaredLogger) {","\tvar gcMutex sync.Mutex","","\tlogger.Debug(\"Waiting to acquire cleanup thread lock\")","\tgcMutex.Lock()","\tdefer gcMutex.Unlock()","","\tlogger.Info(\"Running Cleanup\")","\trunGarbageCollector(ctx)","\tlogger.Info(\"Cleanup thread completed\")","}","","func runGarbageCollector(ctx context.Context) {","\tlogger := logging.FromContext(ctx)","\tkubeClient := kubeclient.Get(ctx)","","\tnamespace := system.Namespace()","","\t// Load config from ConfigMap","\tconfigMap, err := kubeClient.CoreV1().ConfigMaps(namespace).Get(ctx, config.PrunerConfigMapName, metav1.GetOptions{})","\tif err != nil {","\t\tlogger.Error(\"Failed to load ConfigMap for GC\", zap.Error(err))","\t\treturn","\t}","","\tif err := config.PrunerConfigStore.LoadGlobalConfig(ctx, configMap); err != nil {","\t\tlogger.Error(\"Error loading pruner global config\", zap.Error(err))","\t\treturn","\t}","","\tconfigMapUpdateTime := time.Now().Format(time.RFC3339)","","\t// Get filtered namespaces","\tnamespaces, err := getFilteredNamespaces(ctx, kubeClient)","\tif err != nil {","\t\tlogger.Error(\"Failed to filter namespaces for GC\", zap.Error(err))","\t\treturn","\t}","","\tlogger.Infow(\"Namespaces selected for garbage collection\", \"namespaces\", namespaces)","","\t// Get worker count from config or default to 5","\tworkerCount, err := config.PrunerConfigStore.WorkerCount(ctx, configMap)","\tif err != nil {","\t\tlogger.Error(\"Failed to get worker count from config\", zap.Error(err))","\t\tworkerCount = config.DefaultWorkerCountForNamespaceCleanup","\t}","","\t// Setup channels","\tnsChan := make(chan string)","\tvar wg sync.WaitGroup","","\t// Start workers","\tfor i := 0; i \u003c workerCount; i++ {","\t\twg.Add(1)","\t\tgo func(workerID int) {","\t\t\tdefer wg.Done()","\t\t\tfor ns := range nsChan {","\t\t\t\tlogger.Infow(\"Worker processing namespace\", \"worker\", workerID, \"namespace\", ns)","","\t\t\t\tif err := cleanupPRs(ctx, ns, configMapUpdateTime); err != nil {","\t\t\t\t\tlogger.Errorw(\"Error collecting PipelineRuns\", zap.String(\"namespace\", ns), zap.Error(err))","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t\tif err := cleanupTRs(ctx, ns, configMapUpdateTime); err != nil {","\t\t\t\t\tlogger.Errorw(\"Error collecting TaskRuns\", zap.String(\"namespace\", ns), zap.Error(err))","\t\t\t\t\tcontinue","\t\t\t\t}","\t\t\t}","\t\t}(i)","\t}","","\t// Send namespaces to workers","\tfor _, ns := range namespaces {","\t\tnsChan \u003c- ns","\t}","\tclose(nsChan)","","\twg.Wait()","\tlogger.Info(\"Garbage collection completed\")","}","","// getFilteredNamespaces returns namespaces excluding system namespaces","// Excluded: kube-*, openshift-*, tekton-pipelines, tekton-operator","func getFilteredNamespaces(ctx context.Context, client kubernetes.Interface) ([]string, error) {","\tnsList, err := client.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","","\tvar filtered []string","\tfor _, ns := range nsList.Items {","\t\tname := ns.Name","\t\tif !strings.HasPrefix(name, \"kube-\") \u0026\u0026 !strings.HasPrefix(name, \"openshift-\") \u0026\u0026","\t\t\tname != \"tekton-pipelines\" \u0026\u0026 name != \"tekton-operator\" {","\t\t\tfiltered = append(filtered, name)","\t\t}","\t}","\treturn filtered, nil","}","","// CleanupPRs is responsible for cleaning up completed PipelineRuns based on their TTL and history limit.","func cleanupPRs(ctx context.Context, namespace string, configMapUpdateTime string) error {","","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"Start Cleanup PipelineRuns\", \"namespace\", namespace)","","\tpipelineClient := pipelineclient.Get(ctx)","\tprFuncs := pipelinerun.NewPrFuncs(pipelineClient)","","\tprTTLHandler, err := config.NewTTLHandler(clockUtil.RealClock{}, prFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting ttl handler\", zap.Error(err))","\t}","","\tprHistoryLimiter, err := config.NewHistoryLimiter(prFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting history limiter\", zap.Error(err))","\t}","","\tprsList, err := pipelineClient.TektonV1().PipelineRuns(namespace).List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn err","\t}","\tlogger.Debugw(\"Progressing cleanup PipelineRuns list\", \"list\", prsList.Items, \"namespace\", namespace)","","\tif len(prsList.Items) \u003e 0 {","","\t\tfor _, prInstance := range prsList.Items {","\t\t\tlogger.Debugw(\"Processing PipelineRun\", \"name\", prInstance.Name, \"namespace\", prInstance.Namespace)","\t\t\t// Check if the PipelineRun is completed","\t\t\tif prInstance.Status.CompletionTime != nil {","\t\t\t\tpr := \u0026prInstance","","\t\t\t\t// Check if the history limit processed time which is stored as a string in annotation of PR config.AnnotationHistoryLimitCheckProcessed is not nil","\t\t\t\t// and earlier than the configmap update time","\t\t\t\tif prInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed] != \"\" {","\t\t\t\t\t// Parse the annotation value to a time.Time object","\t\t\t\t\tannotationTime, err := time.Parse(time.RFC3339, prInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed])","\t\t\t\t\tif err != nil {","\t\t\t\t\t\tlogger.Errorw(\"Error parsing history limit check processed time\", \"namespace\", pr.Namespace, \"name\", pr.Name, zap.Error(err))","\t\t\t\t\t\tcontinue // Continue to next PR instead of returning error","\t\t\t\t\t}","\t\t\t\t\t// Compare the annotation time with the configmap update time","\t\t\t\t\t// If the configmap update time is after the annotation time, remove the annotation and patch the PipelineRun","\t\t\t\t\t// to trigger the history limit check again","","\t\t\t\t\tupdateTime, err := time.Parse(time.RFC3339, configMapUpdateTime)","\t\t\t\t\tif err != nil {","\t\t\t\t\t\tlogger.Errorw(\"Error parsing configmap update time\", \"namespace\", pr.Namespace, \"name\", pr.Name, zap.Error(err))","\t\t\t\t\t\tcontinue // Continue to next PR instead of returning error","\t\t\t\t\t}","","\t\t\t\t\tif updateTime.After(annotationTime) {","\t\t\t\t\t\t// Use JSON Patch to remove only the specific annotation without affecting others","\t\t\t\t\t\tjsonPatch := fmt.Sprintf(`[{\"op\": \"remove\", \"path\": \"/metadata/annotations/%s\"}]`,","\t\t\t\t\t\t\tstrings.ReplaceAll(config.AnnotationHistoryLimitCheckProcessed, \"/\", \"~1\"))","","\t\t\t\t\t\t// Patch the PipelineRun to remove the annotation","\t\t\t\t\t\t_, err = pipelineClient.TektonV1().PipelineRuns(pr.Namespace).Patch(ctx, pr.Name, types.JSONPatchType, []byte(jsonPatch), metav1.PatchOptions{})","\t\t\t\t\t\tif err != nil {","\t\t\t\t\t\t\t// If the PipelineRun is not found, it may have been deleted already, so we can continue","\t\t\t\t\t\t\tif errors.IsNotFound(err) {","\t\t\t\t\t\t\t\tlogger.Debugw(\"PipelineRun not found during annotation patch - may have been deleted already\", \"namespace\", pr.Namespace, \"name\", pr.Name)","\t\t\t\t\t\t\t\tcontinue","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\tlogger.Errorw(\"error patching PipelineRun to remove history limit check processed annotation\", \"namespace\", pr.Namespace, \"name\", pr.Name, zap.Error(err))","\t\t\t\t\t\t\tcontinue // Continue to next PR instead of returning error","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\terr := prHistoryLimiter.ProcessEvent(ctx, pr)","\t\t\t\tif err != nil {","\t\t\t\t\t// If the PipelineRun is not found, it may have been processed/deleted by another worker, continue to next PR","\t\t\t\t\tif errors.IsNotFound(err) {","\t\t\t\t\t\tlogger.Debugw(\"PipelineRun not found during history limiting - may have been processed by another worker\", \"namespace\", pr.Namespace, \"name\", pr.Name)","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\tlogger.Errorw(\"error processing history limiting for a PipelineRun\", \"namespace\", pr.Namespace, \"name\", pr.Name, zap.Error(err))","\t\t\t\t\tcontinue // Continue to next PR instead of returning error","\t\t\t\t}","\t\t\t\t// execute ttl handler","\t\t\t\terr = prTTLHandler.ProcessEvent(ctx, pr)","\t\t\t\tif err != nil {","\t\t\t\t\t// If the PipelineRun is not found, it may have been processed/deleted by another worker, continue to next PR","\t\t\t\t\tif errors.IsNotFound(err) {","\t\t\t\t\t\tlogger.Debugw(\"PipelineRun not found during TTL processing - may have been processed by another worker\", \"namespace\", pr.Namespace, \"name\", pr.Name)","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\tisRequeueKey, _ := controller.IsRequeueKey(err)","\t\t\t\t\t// the error is not a requeue error, print the error","\t\t\t\t\tif !isRequeueKey {","\t\t\t\t\t\tdata, _ := json.Marshal(pr)","\t\t\t\t\t\tlogger.Errorw(\"error processing ttl for a PipelineRun\", \"namespace\", pr.Namespace, \"name\", pr.Name, \"resource\", string(data), zap.Error(err))","\t\t\t\t\t}","\t\t\t\t\tcontinue // Continue to next PR instead of returning error","\t\t\t\t}","\t\t\t}","","\t\t}","\t}","\treturn nil","}","","// CleanupTRs is responsible for cleaning up completed TaskRuns based on their TTL and history limit.","// It checks if the TaskRun has a completion time and is not owned by a PipelineRun before processing.","func cleanupTRs(ctx context.Context, namespace string, configMapUpdateTime string) error {","","\tlogger := logging.FromContext(ctx)","\tlogger.Debugw(\"Start Cleanup TaskRuns\", \"namespace\", namespace)","","\tpipelineClient := pipelineclient.Get(ctx)","\ttrFuncs := taskrun.NewTrFuncs(pipelineClient)","","\ttrTTLHandler, err := config.NewTTLHandler(clockUtil.RealClock{}, trFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting ttl handler\", zap.Error(err))","\t}","","\ttrHistoryLimiter, err := config.NewHistoryLimiter(trFuncs)","\tif err != nil {","\t\tlogger.Fatal(\"error on getting history limiter\", zap.Error(err))","\t}","","\ttrsList, err := pipelineClient.TektonV1().TaskRuns(namespace).List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn err","\t}","","\tif len(trsList.Items) \u003e 0 {","","\t\tfor _, trInstance := range trsList.Items {","\t\t\tif trInstance.Status.CompletionTime != nil \u0026\u0026 !trInstance.HasPipelineRunOwnerReference() {","\t\t\t\ttr := \u0026trInstance","","\t\t\t\t// Check if the history limit processed time which is stored as a string in annotation of PR config.AnnotationHistoryLimitCheckProcessed is not nil","\t\t\t\t// and earlier than the configmap update time","\t\t\t\tif trInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed] != \"\" {","\t\t\t\t\t// Parse the annotation value to a time.Time object","\t\t\t\t\tannotationTime, err := time.Parse(time.RFC3339, trInstance.Annotations[config.AnnotationHistoryLimitCheckProcessed])","\t\t\t\t\tif err != nil {","\t\t\t\t\t\tlogger.Errorw(\"error parsing history limit check processed time\", \"namespace\", tr.Namespace, \"name\", tr.Name, zap.Error(err))","\t\t\t\t\t\tcontinue // Continue to next TR instead of returning error","\t\t\t\t\t}","\t\t\t\t\t// Compare the annotation time with the configmap update time","\t\t\t\t\t// If the configmap update time is after the annotation time, remove the annotation and patch the TaskRun","\t\t\t\t\t// to trigger the history limit check again","","\t\t\t\t\tupdateTime, err := time.Parse(time.RFC3339, configMapUpdateTime)","\t\t\t\t\tif err != nil {","\t\t\t\t\t\tlogger.Errorw(\"error parsing configmap update time\", \"namespace\", tr.Namespace, \"name\", tr.Name, zap.Error(err))","\t\t\t\t\t\tcontinue // Continue to next TR instead of returning error","\t\t\t\t\t}","\t\t\t\t\t// If the configmap update time is after the annotation time, remove the annotation and patch the TaskRun","","\t\t\t\t\tif updateTime.After(annotationTime) {","\t\t\t\t\t\t// Use JSON Patch to remove only the specific annotation without affecting others","\t\t\t\t\t\tjsonPatch := fmt.Sprintf(`[{\"op\": \"remove\", \"path\": \"/metadata/annotations/%s\"}]`,","\t\t\t\t\t\t\tstrings.ReplaceAll(config.AnnotationHistoryLimitCheckProcessed, \"/\", \"~1\"))","","\t\t\t\t\t\t// Patch the TaskRun to remove the annotation","\t\t\t\t\t\t_, err = pipelineClient.TektonV1().TaskRuns(tr.Namespace).Patch(ctx, tr.Name, types.JSONPatchType, []byte(jsonPatch), metav1.PatchOptions{})","\t\t\t\t\t\tif err != nil {","\t\t\t\t\t\t\t// If the TaskRun is not found, it may have been deleted already, so we can continue","\t\t\t\t\t\t\tif errors.IsNotFound(err) {","\t\t\t\t\t\t\t\tlogger.Debugw(\"TaskRun not found during annotation patch - may have been deleted already\", \"namespace\", tr.Namespace, \"name\", tr.Name)","\t\t\t\t\t\t\t\tcontinue","\t\t\t\t\t\t\t}","\t\t\t\t\t\t\tlogger.Errorw(\"error patching TaskRun to remove history limit check processed annotation\", \"namespace\", tr.Namespace, \"name\", tr.Name, zap.Error(err))","\t\t\t\t\t\t\tcontinue // Continue to next TR instead of returning error","\t\t\t\t\t\t}","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\terr := trHistoryLimiter.ProcessEvent(ctx, tr)","\t\t\t\tif err != nil {","\t\t\t\t\t// If the TaskRun is not found, it may have been processed/deleted by another worker, continue to next TR","\t\t\t\t\tif errors.IsNotFound(err) {","\t\t\t\t\t\tlogger.Debugw(\"TaskRun not found during history limiting - may have been processed by another worker\", \"namespace\", tr.Namespace, \"name\", tr.Name)","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\tlogger.Errorw(\"error processing history limiting for a TaskRun\", \"namespace\", tr.Namespace, \"name\", tr.Name, zap.Error(err))","\t\t\t\t\tcontinue // Continue to next TR instead of returning error","\t\t\t\t}","\t\t\t\t// execute ttl handler","\t\t\t\terr = trTTLHandler.ProcessEvent(ctx, tr)","\t\t\t\tif err != nil {","\t\t\t\t\t// If the TaskRun is not found, it may have been processed/deleted by another worker, continue to next TR","\t\t\t\t\tif errors.IsNotFound(err) {","\t\t\t\t\t\tlogger.Debugw(\"TaskRun not found during TTL processing - may have been processed by another worker\", \"namespace\", tr.Namespace, \"name\", tr.Name)","\t\t\t\t\t\tcontinue","\t\t\t\t\t}","\t\t\t\t\tisRequeueKey, _ := controller.IsRequeueKey(err)","\t\t\t\t\t// the error is not a requeue error, print the error","\t\t\t\t\tif !isRequeueKey {","\t\t\t\t\t\tdata, _ := json.Marshal(tr)","\t\t\t\t\t\tlogger.Errorw(\"error processing ttl for a TaskRun\", \"namespace\", tr.Namespace, \"name\", tr.Name, \"resource\", string(data), zap.Error(err))","\t\t\t\t\t}","\t\t\t\t\tcontinue // Continue to next TR instead of returning error","\t\t\t\t}","\t\t\t}","","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,2,2,2,1,1,0,2,2,2,2,2,2,2,0,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,1,0]},{"id":14,"path":"pkg/reconciler/tektonpruner/reconciler.go","lines":["package tektonpruner","","import (","\t\"context\"","","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/logging\"",")","","// Reconciler includes the kubernetes client to interact with the cluster","type Reconciler struct {","\tkubeclient kubernetes.Interface","}","","// Reconcile is the method that will be called when resources change","func (r *Reconciler) Reconcile(ctx context.Context, key string) error {","\tlogger := logging.FromContext(ctx)","","\t// Example logic: log the key of the changed resource (you can replace this with your custom logic)","\tlogger.Infof(\"Reconcile called for key: %s\", key)","","\t// Nothing to reconcile at the moment. We are just updating the configstore","","\treturn nil // Return nil to indicate successful reconciliation","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1]},{"id":15,"path":"pkg/webhook/configmapvalidation.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package webhook","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/pruner/pkg/config\"","\tadmissionv1 \"k8s.io/api/admission/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/system\"","\t\"knative.dev/pkg/webhook\"","\tcertresources \"knative.dev/pkg/webhook/certificates/resources\"",")","","type ValidateConfigMap struct {","\tClient      kubernetes.Interface","\tSecretName  string","\tWebhookName string","}","","var _ webhook.AdmissionController = (*ValidateConfigMap)(nil)","var _ webhook.StatelessAdmissionController = (*ValidateConfigMap)(nil)","var _ controller.Reconciler = (*ValidateConfigMap)(nil)","","// ThisTypeDoesNotDependOnInformerState implements StatelessAdmissionController","func (v *ValidateConfigMap) ThisTypeDoesNotDependOnInformerState() {}","","// validateRequiredLabels checks if the ConfigMap has the required labels for pruner configs","func validateRequiredLabels(cm *corev1.ConfigMap) error {","\tif cm.Labels == nil {","\t\treturn fmt.Errorf(\"ConfigMap must have labels\")","\t}","","\t// Check for required label: app.kubernetes.io/part-of=tekton-pruner","\tif partOf, ok := cm.Labels[\"app.kubernetes.io/part-of\"]; !ok || partOf != \"tekton-pruner\" {","\t\treturn fmt.Errorf(\"ConfigMap must have label app.kubernetes.io/part-of=tekton-pruner\")","\t}","","\t// Check for config-type label","\tconfigType, ok := cm.Labels[\"pruner.tekton.dev/config-type\"]","\tif !ok {","\t\treturn fmt.Errorf(\"ConfigMap must have label pruner.tekton.dev/config-type (global or namespace)\")","\t}","","\t// Validate config-type value","\tif configType != \"global\" \u0026\u0026 configType != \"namespace\" {","\t\treturn fmt.Errorf(\"label pruner.tekton.dev/config-type must be 'global' or 'namespace', got: %s\", configType)","\t}","","\treturn nil","}","","// validateNamespaceForConfig checks if a namespace is allowed for namespace-level configs","// Forbidden namespaces: kube-*, openshift-*, tekton-pipelines, tekton-operator","func validateNamespaceForConfig(namespace string) error {","\tif strings.HasPrefix(namespace, \"kube-\") {","\t\treturn fmt.Errorf(\"namespace-level config cannot be created in kube-* namespaces, got: %s\", namespace)","\t}","\tif strings.HasPrefix(namespace, \"openshift-\") {","\t\treturn fmt.Errorf(\"namespace-level config cannot be created in openshift-* namespaces, got: %s\", namespace)","\t}","\tif namespace == \"tekton-pipelines\" || namespace == \"tekton-operator\" {","\t\treturn fmt.Errorf(\"namespace-level config cannot be created in %s namespace\", namespace)","\t}","\treturn nil","}","","// Reconcile updates the ValidatingWebhookConfiguration with CA bundle","func (v *ValidateConfigMap) Reconcile(ctx context.Context, key string) error {","\tlogger := logging.FromContext(ctx)","","\t// Get the secret containing the CA certificate","\tsecret, err := v.Client.CoreV1().Secrets(system.Namespace()).Get(ctx, v.SecretName, metav1.GetOptions{})","\tif apierrors.IsNotFound(err) {","\t\tlogger.Infof(\"Secret %s not found yet, skipping webhook configuration update\", v.SecretName)","\t\treturn nil","\t} else if err != nil {","\t\tlogger.Errorw(\"Error fetching secret\", \"secret\", v.SecretName, \"error\", err)","\t\treturn err","\t}","","\t// Get the CA certificate from the secret","\tcaCert, ok := secret.Data[certresources.CACert]","\tif !ok {","\t\tlogger.Infof(\"CA cert not yet present in secret %s\", v.SecretName)","\t\treturn nil","\t}","","\t// Get the ValidatingWebhookConfiguration","\tvwc, err := v.Client.AdmissionregistrationV1().ValidatingWebhookConfigurations().Get(ctx, v.WebhookName, metav1.GetOptions{})","\tif apierrors.IsNotFound(err) {","\t\tlogger.Infof(\"ValidatingWebhookConfiguration %s not found yet\", v.WebhookName)","\t\treturn nil","\t} else if err != nil {","\t\tlogger.Errorw(\"Error fetching ValidatingWebhookConfiguration\", \"name\", v.WebhookName, \"error\", err)","\t\treturn err","\t}","","\t// Update the CA bundle in all webhooks","\tupdated := false","\tfor i := range vwc.Webhooks {","\t\tif string(vwc.Webhooks[i].ClientConfig.CABundle) != string(caCert) {","\t\t\tvwc.Webhooks[i].ClientConfig.CABundle = caCert","\t\t\tupdated = true","\t\t}","\t}","","\tif !updated {","\t\tlogger.Debug(\"CA bundle already up to date\")","\t\treturn nil","\t}","","\t// Update the webhook configuration","\t_, err = v.Client.AdmissionregistrationV1().ValidatingWebhookConfigurations().Update(ctx, vwc, metav1.UpdateOptions{})","\tif err != nil {","\t\tlogger.Errorw(\"Error updating ValidatingWebhookConfiguration\", \"name\", v.WebhookName, \"error\", err)","\t\treturn err","\t}","","\tlogger.Infow(\"Successfully updated ValidatingWebhookConfiguration with CA bundle\", \"name\", v.WebhookName)","\treturn nil","}","","func (v *ValidateConfigMap) Path() string {","\treturn \"/validate-configmap\"","}","","// Admit handles the admission request","func (v *ValidateConfigMap) Admit(ctx context.Context, request *admissionv1.AdmissionRequest) *admissionv1.AdmissionResponse {","\tlogger := logging.FromContext(ctx)","","\t// Only validate ConfigMaps","\tif request.Kind.Kind != \"ConfigMap\" {","\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t}","","\t// Parse the ConfigMap (use OldObject for DELETE operations)","\tvar cm corev1.ConfigMap","\tif request.Operation == admissionv1.Delete {","\t\tif err := json.Unmarshal(request.OldObject.Raw, \u0026cm); err != nil {","\t\t\tlogger.Warnw(\"Failed to unmarshal ConfigMap from OldObject\", \"error\", err)","\t\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t\t}","\t} else {","\t\tif err := json.Unmarshal(request.Object.Raw, \u0026cm); err != nil {","\t\t\tlogger.Warnw(\"Failed to unmarshal ConfigMap\", \"error\", err)","\t\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t\t}","\t}","","\t// Validate that ConfigMap has required labels","\t// The webhook objectSelector ensures only ConfigMaps with proper labels reach this point","\t// This is a defense-in-depth check","\tif err := validateRequiredLabels(\u0026cm); err != nil {","\t\tlogger.Warnw(\"ConfigMap missing required labels\", \"name\", cm.Name, \"namespace\", cm.Namespace, \"error\", err)","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tStatus:  metav1.StatusFailure,","\t\t\t\tMessage: fmt.Sprintf(\"Invalid pruner ConfigMap labels: %v\", err),","\t\t\t\tReason:  metav1.StatusReasonInvalid,","\t\t\t\tCode:    400,","\t\t\t},","\t\t}","\t}","","\t// Determine config type from labels","\tconfigType := cm.Labels[\"pruner.tekton.dev/config-type\"]","\tisGlobalConfig := configType == \"global\" \u0026\u0026 cm.Namespace == system.Namespace()","\tisNamespaceConfig := configType == \"namespace\" \u0026\u0026 cm.Namespace != system.Namespace()","","\t// Validate ConfigMap names match expected patterns","\tif isGlobalConfig \u0026\u0026 cm.Name != \"tekton-pruner-default-spec\" {","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tStatus:  metav1.StatusFailure,","\t\t\t\tMessage: fmt.Sprintf(\"Global config must be named 'tekton-pruner-default-spec', got: %s\", cm.Name),","\t\t\t\tReason:  metav1.StatusReasonInvalid,","\t\t\t\tCode:    400,","\t\t\t},","\t\t}","\t}","","\tif isNamespaceConfig \u0026\u0026 cm.Name != \"tekton-pruner-namespace-spec\" {","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tStatus:  metav1.StatusFailure,","\t\t\t\tMessage: fmt.Sprintf(\"Namespace config must be named 'tekton-pruner-namespace-spec', got: %s\", cm.Name),","\t\t\t\tReason:  metav1.StatusReasonInvalid,","\t\t\t\tCode:    400,","\t\t\t},","\t\t}","\t}","","\t// Validate that namespace-level configs are not in forbidden namespaces","\tif isNamespaceConfig {","\t\tif err := validateNamespaceForConfig(cm.Namespace); err != nil {","\t\t\tlogger.Warnw(\"Namespace config in forbidden namespace\", \"name\", cm.Name, \"namespace\", cm.Namespace, \"error\", err)","\t\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\t\tAllowed: false,","\t\t\t\tResult: \u0026metav1.Status{","\t\t\t\t\tStatus:  metav1.StatusFailure,","\t\t\t\t\tMessage: fmt.Sprintf(\"Invalid namespace for namespace-level config: %v\", err),","\t\t\t\t\tReason:  metav1.StatusReasonInvalid,","\t\t\t\t\tCode:    400,","\t\t\t\t},","\t\t\t}","\t\t}","\t}","","\tif !isGlobalConfig \u0026\u0026 !isNamespaceConfig {","\t\tlogger.Warnw(\"Received unexpected ConfigMap\", \"name\", cm.Name, \"namespace\", cm.Namespace, \"configType\", configType)","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tStatus:  metav1.StatusFailure,","\t\t\t\tMessage: fmt.Sprintf(\"Invalid pruner ConfigMap configuration: wrong config-type label or namespace combination\"),","\t\t\t\tReason:  metav1.StatusReasonInvalid,","\t\t\t\tCode:    400,","\t\t\t},","\t\t}","\t}","","\tlogger.Infow(\"Validating pruner ConfigMap\",","\t\t\"name\", cm.Name,","\t\t\"namespace\", cm.Namespace,","\t\t\"operation\", request.Operation,","\t\t\"isGlobalConfig\", isGlobalConfig,","\t\t\"isNamespaceConfig\", isNamespaceConfig)","","\t// Handle DELETE operations","\tif request.Operation == admissionv1.Delete {","\t\t// Prevent deletion of global config if namespace configs still exist","\t\tif isGlobalConfig {","\t\t\tnsList, err := v.Client.CoreV1().ConfigMaps(\"\").List(ctx, metav1.ListOptions{","\t\t\t\tFieldSelector: \"metadata.name=tekton-pruner-namespace-spec\",","\t\t\t})","\t\t\tif err != nil {","\t\t\t\tlogger.Errorw(\"Failed to check for existing namespace configs\", \"error\", err)","\t\t\t\t// Allow deletion if we can't check (fail open for DELETE)","\t\t\t\tlogger.Infow(\"Allowing deletion of global config (unable to verify dependents)\", \"name\", cm.Name)","\t\t\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t\t\t}","\t\t\tif len(nsList.Items) \u003e 0 {","\t\t\t\tnamespaces := make([]string, len(nsList.Items))","\t\t\t\tfor i, item := range nsList.Items {","\t\t\t\t\tnamespaces[i] = item.Namespace","\t\t\t\t}","\t\t\t\tlogger.Errorw(\"Attempted to delete global config while namespace configs exist\",","\t\t\t\t\t\"namespaceConfigCount\", len(nsList.Items),","\t\t\t\t\t\"affectedNamespaces\", namespaces)","\t\t\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\t\t\tAllowed: false,","\t\t\t\t\tResult: \u0026metav1.Status{","\t\t\t\t\t\tStatus: metav1.StatusFailure,","\t\t\t\t\t\tMessage: fmt.Sprintf(\"Cannot delete global config: %d namespace config(s) still exist that depend on it in namespaces: %v. Delete namespace configs first.\",","\t\t\t\t\t\t\tlen(nsList.Items), namespaces),","\t\t\t\t\t\tReason: metav1.StatusReasonInvalid,","\t\t\t\t\t\tCode:   422,","\t\t\t\t\t},","\t\t\t\t}","\t\t\t}","\t\t\tlogger.Infow(\"Allowing deletion of global config (no dependents)\", \"name\", cm.Name)","\t\t} else if isNamespaceConfig {","\t\t\tlogger.Infow(\"Allowing deletion of namespace config\", \"name\", cm.Name, \"namespace\", cm.Namespace)","\t\t}","\t\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","\t}","","\t// For CREATE/UPDATE operations, perform validation","\t// For namespace-level configs, fetch global config to enforce limits","\tvar globalConfig *corev1.ConfigMap","\tif isNamespaceConfig {","\t\tvar err error","\t\tglobalConfig, err = v.Client.CoreV1().ConfigMaps(system.Namespace()).Get(ctx, \"tekton-pruner-default-spec\", metav1.GetOptions{})","\t\tif err != nil {","\t\t\tlogger.Warnw(\"Failed to fetch global config for namespace validation\", \"error\", err)","\t\t\t// Allow if global config is not available (e.g., during initial setup)","\t\t\t// Basic validation will still be performed","\t\t}","\t}","","\t// Validate using the centralized validation function","\tif err := config.ValidateConfigMapWithGlobal(\u0026cm, globalConfig); err != nil {","\t\tlogger.Errorw(\"ConfigMap validation failed\", \"name\", cm.Name, \"namespace\", cm.Namespace, \"error\", err)","\t\treturn \u0026admissionv1.AdmissionResponse{","\t\t\tAllowed: false,","\t\t\tResult: \u0026metav1.Status{","\t\t\t\tStatus:  metav1.StatusFailure,","\t\t\t\tMessage: fmt.Sprintf(\"Invalid pruner configuration: %v\", err),","\t\t\t\tReason:  metav1.StatusReasonInvalid,","\t\t\t\tCode:    422,","\t\t\t},","\t\t}","\t}","","\tlogger.Infow(\"ConfigMap validation successful\", \"name\", cm.Name, \"namespace\", cm.Namespace)","\treturn \u0026admissionv1.AdmissionResponse{Allowed: true}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,1,1,0,0,2,2,1,1,0,0,2,1,1,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,0,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,2,1,1,1,1,2,2,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,2,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,1,1,1,1,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0]}],"tree":{"name":".","type":"dir","children":[{"name":"pkg","type":"dir","children":[{"name":"config","type":"dir","children":[{"name":"config.go","type":"file","fileId":0},{"name":"config_defaults.go","type":"file","fileId":1},{"name":"constants.go","type":"file","fileId":2},{"name":"helper.go","type":"file","fileId":3},{"name":"history_limiter.go","type":"file","fileId":4},{"name":"ttl_handler.go","type":"file","fileId":5}]},{"name":"metrics","type":"dir","children":[{"name":"metrics.go","type":"file","fileId":6}]},{"name":"reconciler","type":"dir","children":[{"name":"namespaceprunerconfig","type":"dir","children":[{"name":"controller.go","type":"file","fileId":7},{"name":"reconciler.go","type":"file","fileId":8}]},{"name":"pipelinerun","type":"dir","children":[{"name":"controller.go","type":"file","fileId":9},{"name":"reconciler.go","type":"file","fileId":10}]},{"name":"taskrun","type":"dir","children":[{"name":"controller.go","type":"file","fileId":11},{"name":"reconciler.go","type":"file","fileId":12}]},{"name":"tektonpruner","type":"dir","children":[{"name":"controller.go","type":"file","fileId":13},{"name":"reconciler.go","type":"file","fileId":14}]}]},{"name":"webhook","type":"dir","children":[{"name":"configmapvalidation.go","type":"file","fileId":15}]}]}]},"summary":{"totalLines":2710,"coveredLines":1493,"percent":55.09225092250922}};
    </script>
    <script>
      window.COVERAGE_CONFIG = {"syntaxEnabled":true};
    </script>
    <script>
      (function() {
  'use strict';

  const data = window.COVERAGE_DATA;
  const config = window.COVERAGE_CONFIG || { syntaxEnabled: true };

  // State
  let currentFileId = null;
  let searchQuery = '';
  let contentSearchQuery = '';
  let matches = [];
  let currentMatchIndex = -1;
  let expandedDirs = new Set();
  let syntaxHighlightEnabled = config.syntaxEnabled;
  let sortMode = 'name'; // 'name' or 'coverage'
  let anchorLine = null;        // First line clicked (anchor for shift-select)
  let selectedRange = null;     // { start: N, end: M } or null

  // DOM elements
  const fileTree = document.getElementById('file-tree');
  const viewport = document.getElementById('viewport');
  const filePath = document.getElementById('file-path');
  const summary = document.getElementById('summary');
  const searchInput = document.getElementById('search-input');
  const contentSearch = document.getElementById('content-search');
  const matchInfo = document.getElementById('match-info');
  const prevMatch = document.getElementById('prev-match');
  const nextMatch = document.getElementById('next-match');
  const themeToggle = document.getElementById('theme-toggle');
  const syntaxToggle = document.getElementById('syntax-toggle');
  const helpModal = document.getElementById('help-modal');
  const closeHelp = document.getElementById('close-help');
  const helpToggle = document.getElementById('help-toggle');

  // Coverage cache: fileId -> percentage
  let coverageCache = new Map();

  function initCoverageCache() {
    data.files.forEach((file, idx) => {
      coverageCache.set(idx, calculateFileCoverage(idx));
    });
  }

  function calculateFileCoverage(fileId) {
    const file = data.files[fileId];
    let totalStatements = 0;
    let coveredStatements = 0;

    file.coverage.forEach(cov => {
      if (cov > 0) totalStatements++;
      if (cov === 2) coveredStatements++;
    });

    return totalStatements === 0 ? 0 : (coveredStatements / totalStatements) * 100;
  }

  function calculateDirectoryCoverage(node) {
    if (node.type === 'file') {
      return coverageCache.get(node.fileId) || 0;
    }

    let totalCoverage = 0;
    let fileCount = 0;

    node.children?.forEach(child => {
      const childCov = calculateDirectoryCoverage(child);
      totalCoverage += childCov;
      fileCount++;
    });

    return fileCount === 0 ? 0 : totalCoverage / fileCount;
  }

  function sortTreeNodes(node, mode) {
    if (!node.children || node.children.length === 0) return node;

    // Deep copy to avoid mutating original
    const sorted = { ...node };
    sorted.children = [...node.children].map(child => sortTreeNodes(child, mode));

    // Sort children
    sorted.children.sort((a, b) => {
      // Directories always first
      if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;

      if (mode === 'coverage') {
        const aCov = calculateDirectoryCoverage(a);
        const bCov = calculateDirectoryCoverage(b);
        console.log('Sorting:', a.name, '('+aCov.toFixed(1)+'%) vs', b.name, '('+bCov.toFixed(1)+'%)', '=', bCov - aCov);
        // Descending: high coverage first
        return aCov !== bCov ? bCov - aCov : a.name.localeCompare(b.name);
      }

      return a.name.localeCompare(b.name);
    });

    return sorted;
  }

  // Initialize
  function init() {
    initCoverageCache();
    loadSortPreference();
    renderSummary();
    renderTree();
    setupEventListeners();
    loadTheme();
    loadSyntaxPreference();

    // Check for deep link hash first, otherwise select first file
    if (!navigateToHash() && data.files.length > 0) {
      selectFile(0);
    }

    // Listen for hash changes (browser back/forward)
    window.addEventListener('hashchange', navigateToHash);
  }

  // Deep linking: parse URL hash
  function parseHash() {
    const hash = window.location.hash.slice(1);
    if (!hash) return null;

    const match = hash.match(/^file-(\d+)(?::line-(\d+)(?:-(\d+))?)?$/);
    if (!match) return null;

    return {
      fileId: parseInt(match[1], 10),
      lineStart: match[2] ? parseInt(match[2], 10) : null,
      lineEnd: match[3] ? parseInt(match[3], 10) : null
    };
  }

  // Deep linking: navigate to hash location
  function navigateToHash() {
    const target = parseHash();
    if (!target) return false;

    if (target.fileId < 0 || target.fileId >= data.files.length) return false;

    selectFile(target.fileId);

    if (target.lineStart) {
      requestAnimationFrame(() => {
        const lineEnd = target.lineEnd || target.lineStart;
        anchorLine = target.lineStart;
        selectedRange = { start: target.lineStart, end: lineEnd };
        selectLineRange(target.lineStart, lineEnd);
        scrollToLine(target.lineStart);
      });
    }

    return true;
  }

  // Deep linking: scroll to and highlight a line
  function scrollToLine(lineNum) {
    const lineEl = document.querySelector('.code-line[data-line="' + lineNum + '"]');
    if (!lineEl) return;

    lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  // Clear all selected lines
  function clearLineSelection() {
    document.querySelectorAll('.code-line.selected-line').forEach(el => {
      el.classList.remove('selected-line');
    });
  }

  // Select a range of lines (inclusive)
  function selectLineRange(start, end) {
    clearLineSelection();
    const minLine = Math.min(start, end);
    const maxLine = Math.max(start, end);
    for (let i = minLine; i <= maxLine; i++) {
      const lineEl = document.querySelector('.code-line[data-line="' + i + '"]');
      if (lineEl) {
        lineEl.classList.add('selected-line');
      }
    }
  }

  // Deep linking: update URL hash
  function updateHash(fileId, lineStart, lineEnd) {
    let hash = 'file-' + fileId;
    if (lineStart) {
      hash += ':line-' + lineStart;
      if (lineEnd && lineEnd !== lineStart) {
        // Normalise so start < end
        const minLine = Math.min(lineStart, lineEnd);
        const maxLine = Math.max(lineStart, lineEnd);
        hash = 'file-' + fileId + ':line-' + minLine + '-' + maxLine;
      }
    }
    history.replaceState(null, '', '#' + hash);
  }

  function renderSummary() {
    // Build summary safely using DOM methods
    summary.textContent = '';
    const span = document.createElement('span');
    span.className = 'percent';
    span.textContent = data.summary.percent.toFixed(1) + '%';
    summary.appendChild(span);
    summary.appendChild(document.createTextNode(
      ' coverage (' + data.summary.coveredLines + '/' + data.summary.totalLines + ' lines)'
    ));
  }

  function renderTree() {
    fileTree.textContent = '';
    // Auto-expand all top-level directories
    if (data.tree.children && data.tree.children.length > 0) {
      data.tree.children.forEach(child => {
        if (child.type === 'dir') {
          expandedDirs.add(getNodePath(child, 0));
        }
      });
    }
    const sortedTree = sortTreeNodes(data.tree, sortMode);
    renderNode(sortedTree, fileTree, 0);
  }

  function renderNode(node, container, depth) {
    if (node.name === '.' && node.type === 'dir') {
      // Root node, render children directly
      node.children.forEach(child => renderNode(child, container, depth));
      return;
    }

    const nodeEl = document.createElement('div');
    nodeEl.className = 'tree-node';
    nodeEl.dataset.name = node.name.toLowerCase();

    const item = document.createElement('div');
    item.className = 'tree-item';
    item.style.setProperty('--depth', depth);

    const icon = document.createElement('span');
    icon.className = 'icon';

    const name = document.createElement('span');
    name.className = 'name';
    name.textContent = node.name;

    if (node.type === 'dir') {
      const dirPath = getNodePath(node, depth);
      icon.textContent = expandedDirs.has(dirPath) ? '\u25BC' : '\u25B6';
      if (expandedDirs.has(dirPath)) {
        nodeEl.classList.add('expanded');
      }

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleDir(nodeEl, dirPath, icon);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to all directories
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);

      if (node.children && node.children.length > 0) {
        const children = document.createElement('div');
        children.className = 'tree-children';
        node.children.forEach(child => renderNode(child, children, depth + 1));
        nodeEl.appendChild(children);
      }
    } else {
      icon.textContent = '\uD83D\uDCC4';
      nodeEl.dataset.fileId = node.fileId;

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        selectFile(node.fileId);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to files
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);
    }

    container.appendChild(nodeEl);
  }

  function getNodePath(node, depth) {
    return node.name + '_' + depth;
  }

  function toggleDir(nodeEl, path, icon) {
    if (nodeEl.classList.contains('expanded')) {
      nodeEl.classList.remove('expanded');
      expandedDirs.delete(path);
      icon.textContent = '\u25B6';
    } else {
      nodeEl.classList.add('expanded');
      expandedDirs.add(path);
      icon.textContent = '\u25BC';
    }
  }

  function selectFile(fileId) {
    currentFileId = fileId;
    matches = [];
    currentMatchIndex = -1;
    matchInfo.textContent = '';
    contentSearch.value = '';
    contentSearchQuery = '';
    anchorLine = null;
    selectedRange = null;

    // Update selection in tree
    document.querySelectorAll('.tree-item.selected').forEach(el => {
      el.classList.remove('selected');
    });
    const selected = document.querySelector('[data-file-id="' + fileId + '"] .tree-item');
    if (selected) {
      selected.classList.add('selected');
    }

    const file = data.files[fileId];
    if (!file) return;

    filePath.textContent = file.path;
    renderCode(file);

    // Update URL hash for deep linking
    updateHash(fileId, null);
  }

  function renderCode(file) {
    viewport.textContent = '';

    if (!file.lines || file.lines.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty-state';
      const iconDiv = document.createElement('div');
      iconDiv.className = 'icon';
      iconDiv.textContent = '\uD83D\uDCED';
      const textDiv = document.createElement('div');
      textDiv.textContent = 'No content';
      empty.appendChild(iconDiv);
      empty.appendChild(textDiv);
      viewport.appendChild(empty);
      return;
    }

    const container = document.createElement('div');
    container.className = 'code-container';

    file.lines.forEach((line, idx) => {
      const lineEl = document.createElement('div');
      lineEl.className = 'code-line';
      lineEl.dataset.line = idx + 1;

      const cov = file.coverage[idx];
      if (cov === 2) {
        lineEl.classList.add('covered');
      } else if (cov === 1) {
        lineEl.classList.add('uncovered');
      }

      const gutter = document.createElement('div');
      gutter.className = 'gutter';

      const lineNum = document.createElement('div');
      lineNum.className = 'line-number';
      lineNum.textContent = idx + 1;
      lineNum.title = 'Click to select line, Shift+Click for range';

      // Add click handler for line number deep linking
      const lineNumber = idx + 1;
      lineNum.addEventListener('click', (e) => {
        e.stopPropagation();

        if (e.shiftKey && anchorLine !== null) {
          // Shift-click: select range from anchor to clicked line
          const start = Math.min(anchorLine, lineNumber);
          const end = Math.max(anchorLine, lineNumber);
          selectedRange = { start: start, end: end };
          selectLineRange(start, end);
          updateHash(currentFileId, start, end);
        } else {
          // Regular click: set anchor and select single line
          anchorLine = lineNumber;
          selectedRange = { start: lineNumber, end: lineNumber };
          selectLineRange(lineNumber, lineNumber);
          updateHash(currentFileId, lineNumber, null);
        }
      });

      const content = document.createElement('div');
      content.className = 'line-content';
      content.textContent = line || ' ';

      lineEl.appendChild(gutter);
      lineEl.appendChild(lineNum);
      lineEl.appendChild(content);
      container.appendChild(lineEl);
    });

    viewport.appendChild(container);

    // Apply syntax highlighting after rendering if enabled
    if (syntaxHighlightEnabled) {
      applySyntaxHighlighting();
    }
  }

  function setupEventListeners() {
    // File search
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchQuery = e.target.value.toLowerCase();
        filterTree();
      }, 300);
    });

    // Content search
    let contentTimeout;
    contentSearch.addEventListener('input', (e) => {
      clearTimeout(contentTimeout);
      contentTimeout = setTimeout(() => {
        contentSearchQuery = e.target.value;
        searchInFile();
      }, 300);
    });

    contentSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (e.shiftKey) {
          goToPrevMatch();
        } else {
          goToNextMatch();
        }
      }
    });

    prevMatch.addEventListener('click', goToPrevMatch);
    nextMatch.addEventListener('click', goToNextMatch);

    // Theme toggle
    themeToggle.addEventListener('click', toggleTheme);

    // Syntax toggle
    syntaxToggle.addEventListener('click', toggleSyntax);

    // Sort controls
    const sortButtons = document.querySelectorAll('.sort-btn');
    console.log('Found', sortButtons.length, 'sort buttons');
    sortButtons.forEach(btn => {
      console.log('Attaching click handler to button:', btn.dataset.sort);
      btn.addEventListener('click', () => {
        console.log('Sort button clicked:', btn.dataset.sort);
        changeSortMode(btn.dataset.sort);
      });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f' && currentFileId !== null) {
        e.preventDefault();
        contentSearch.focus();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        searchInput.focus();
      }
      // Help modal
      if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        showHelp();
      }
      if (e.key === 'Escape') {
        // Exit search if focused
        if (document.activeElement === searchInput) {
          searchInput.value = '';
          searchQuery = '';
          filterTree();
          searchInput.blur();
          viewport.focus();
          return;
        }
        if (document.activeElement === contentSearch) {
          contentSearch.value = '';
          contentSearchQuery = '';
          matchInfo.textContent = '';
          matches = [];
          currentMatchIndex = -1;
          if (currentFileId !== null) {
            renderCode(data.files[currentFileId]);
          }
          contentSearch.blur();
          viewport.focus();
          return;
        }
        hideHelp();
      }
    });

    closeHelp.addEventListener('click', hideHelp);
    helpToggle.addEventListener('click', showHelp);
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) hideHelp();
    });
  }

  function filterTree() {
    const nodes = document.querySelectorAll('.tree-node');

    if (!searchQuery) {
      nodes.forEach(n => n.classList.remove('hidden'));
      return;
    }

    nodes.forEach(node => {
      const name = node.dataset.name || '';
      const fileId = node.dataset.fileId;

      if (fileId !== undefined) {
        const file = data.files[parseInt(fileId)];
        const matchesQuery = file && file.path.toLowerCase().includes(searchQuery);
        node.classList.toggle('hidden', !matchesQuery);
      } else {
        const hasVisibleChild = Array.from(node.querySelectorAll('[data-file-id]')).some(f => {
          const fid = parseInt(f.dataset.fileId);
          const file = data.files[fid];
          return file && file.path.toLowerCase().includes(searchQuery);
        });
        node.classList.toggle('hidden', !hasVisibleChild);
        if (hasVisibleChild && searchQuery) {
          node.classList.add('expanded');
          const icon = node.querySelector('.icon');
          if (icon && icon.textContent === '\u25B6') {
            icon.textContent = '\u25BC';
          }
        }
      }
    });
  }

  function searchInFile() {
    matches = [];
    currentMatchIndex = -1;

    // Re-render code to clear highlights
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }

    if (!contentSearchQuery || currentFileId === null) {
      matchInfo.textContent = '';
      return;
    }

    const file = data.files[currentFileId];
    if (!file) return;

    const query = contentSearchQuery.toLowerCase();

    file.lines.forEach((line, idx) => {
      const text = line || '';
      const lowerText = text.toLowerCase();
      let pos = 0;
      let matchIndex;

      while ((matchIndex = lowerText.indexOf(query, pos)) !== -1) {
        matches.push({ line: idx, start: matchIndex, length: query.length });
        pos = matchIndex + 1;
      }
    });

    if (matches.length > 0) {
      highlightMatches();
      currentMatchIndex = 0;
      scrollToMatch(0);
      updateMatchInfo();
    } else {
      matchInfo.textContent = 'No matches';
    }
  }

  function highlightMatches() {
    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    // Group matches by line
    const matchesByLine = {};
    matches.forEach((m, idx) => {
      if (!matchesByLine[m.line]) matchesByLine[m.line] = [];
      matchesByLine[m.line].push({ ...m, idx });
    });

    Object.keys(matchesByLine).forEach(lineIdx => {
      const lineEl = lineEls[parseInt(lineIdx)];
      if (!lineEl) return;

      const content = lineEl.querySelector('.line-content');
      if (!content) return;

      const text = file.lines[parseInt(lineIdx)] || '';
      const lineMatches = matchesByLine[lineIdx].sort((a, b) => a.start - b.start);

      // Build content using DOM nodes for safety
      content.textContent = '';
      let lastEnd = 0;

      lineMatches.forEach(m => {
        // Text before match
        if (m.start > lastEnd) {
          content.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
        }
        // Match span
        const span = document.createElement('span');
        span.className = 'match-highlight';
        span.dataset.matchIdx = m.idx;
        span.textContent = text.substring(m.start, m.start + m.length);
        content.appendChild(span);
        lastEnd = m.start + m.length;
      });

      // Text after last match
      if (lastEnd < text.length) {
        content.appendChild(document.createTextNode(text.substring(lastEnd)));
      }

      // Handle empty line
      if (content.childNodes.length === 0) {
        content.textContent = ' ';
      }
    });
  }

  function scrollToMatch(idx) {
    document.querySelectorAll('.current-match').forEach(el => {
      el.classList.remove('current-match');
    });

    const matchEl = document.querySelector('[data-match-idx="' + idx + '"]');
    if (matchEl) {
      matchEl.classList.add('current-match');
      matchEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function updateMatchInfo() {
    if (matches.length === 0) {
      matchInfo.textContent = 'No matches';
    } else {
      matchInfo.textContent = (currentMatchIndex + 1) + '/' + matches.length;
    }
  }

  function goToNextMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex + 1) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function goToPrevMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex - 1 + matches.length) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function toggleTheme() {
    const body = document.body;
    const current = body.dataset.theme;
    const next = current === 'dark' ? 'light' : 'dark';
    body.dataset.theme = next;
    localStorage.setItem('coverage-theme', next);
  }

  function loadTheme() {
    const saved = localStorage.getItem('coverage-theme');
    if (saved) {
      document.body.dataset.theme = saved;
    }
  }

  function applySyntaxHighlighting() {
    if (!syntaxHighlightEnabled || currentFileId === null) return;
    if (typeof hljs === 'undefined') return;

    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    lineEls.forEach((lineEl, idx) => {
      const cov = file.coverage[idx];
      // Only highlight lines with no coverage info
      if (cov !== 0) return;

      const content = lineEl.querySelector('.line-content');
      if (!content || !content.textContent.trim()) return;

      const text = content.textContent;

      // Use hljs.highlight() which returns result object
      const result = hljs.highlight(text, { language: 'go' });

      // Parse the highlighted HTML safely using DOMParser
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + result.value + '</div>', 'text/html');
      const wrapper = doc.body.firstChild;

      // Clear and append parsed nodes
      content.textContent = '';
      while (wrapper.firstChild) {
        content.appendChild(wrapper.firstChild);
      }
    });
  }

  function toggleSyntax() {
    syntaxHighlightEnabled = !syntaxHighlightEnabled;
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
    localStorage.setItem('coverage-syntax', syntaxHighlightEnabled ? 'on' : 'off');

    // Re-render current file
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }
  }

  function loadSyntaxPreference() {
    const saved = localStorage.getItem('coverage-syntax');
    if (saved !== null) {
      // User preference overrides default
      syntaxHighlightEnabled = saved === 'on';
    }
    // Update button state
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
  }

  function changeSortMode(mode) {
    if (sortMode === mode) return;

    console.log('Changing sort mode from', sortMode, 'to', mode);
    sortMode = mode;
    localStorage.setItem('coverage-sort-mode', mode);

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === mode);
    });

    // Re-render tree
    renderTree();
  }

  function loadSortPreference() {
    const saved = localStorage.getItem('coverage-sort-mode');
    if (saved && (saved === 'name' || saved === 'coverage')) {
      sortMode = saved;
    }

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === sortMode);
    });
  }

  function showHelp() {
    helpModal.classList.remove('hidden');
  }

  function hideHelp() {
    helpModal.classList.add('hidden');
  }

  // Start the app
  init();
})();

    </script>
  </body>
</html>
