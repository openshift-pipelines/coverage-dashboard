
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>webhook-interceptors: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/triggers/examples/v1alpha1/webhook-interceptors/main.go (0.0%)</option>
				
				<option value="file1">github.com/tektoncd/triggers/pkg/adapter/adapter.go (24.1%)</option>
				
				<option value="file2">github.com/tektoncd/triggers/pkg/apis/config/default.go (87.8%)</option>
				
				<option value="file3">github.com/tektoncd/triggers/pkg/apis/config/feature_flags.go (100.0%)</option>
				
				<option value="file4">github.com/tektoncd/triggers/pkg/apis/config/store.go (95.0%)</option>
				
				<option value="file5">github.com/tektoncd/triggers/pkg/apis/triggers/contexts/contexts.go (0.0%)</option>
				
				<option value="file6">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_interceptor_defaults.go (0.0%)</option>
				
				<option value="file7">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_interceptor_types.go (100.0%)</option>
				
				<option value="file8">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_interceptor_validation.go (100.0%)</option>
				
				<option value="file9">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file10">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_trigger_binding_types.go (0.0%)</option>
				
				<option value="file11">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_trigger_binding_validation.go (80.0%)</option>
				
				<option value="file12">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/event_listener_defaults.go (87.5%)</option>
				
				<option value="file13">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/event_listener_types.go (81.2%)</option>
				
				<option value="file14">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/event_listener_validation.go (97.2%)</option>
				
				<option value="file15">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/interceptor_defaults.go (0.0%)</option>
				
				<option value="file16">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/interceptor_types.go (90.9%)</option>
				
				<option value="file17">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/interceptor_validation.go (100.0%)</option>
				
				<option value="file18">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/register.go (60.0%)</option>
				
				<option value="file19">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file20">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_binding_types.go (0.0%)</option>
				
				<option value="file21">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_binding_validation.go (100.0%)</option>
				
				<option value="file22">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_defaults.go (83.3%)</option>
				
				<option value="file23">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_template_defaults.go (0.0%)</option>
				
				<option value="file24">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_template_validation.go (100.0%)</option>
				
				<option value="file25">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_types.go (77.6%)</option>
				
				<option value="file26">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_types_convert.go (71.4%)</option>
				
				<option value="file27">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_validation.go (94.3%)</option>
				
				<option value="file28">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/cluster_trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file29">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/cluster_trigger_binding_types.go (0.0%)</option>
				
				<option value="file30">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/cluster_trigger_binding_validation.go (50.0%)</option>
				
				<option value="file31">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/event_listener_defaults.go (100.0%)</option>
				
				<option value="file32">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/event_listener_types.go (81.2%)</option>
				
				<option value="file33">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/event_listener_validation.go (97.4%)</option>
				
				<option value="file34">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/interceptor_types.go (66.7%)</option>
				
				<option value="file35">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/register.go (60.0%)</option>
				
				<option value="file36">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file37">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_binding_types.go (0.0%)</option>
				
				<option value="file38">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_binding_validation.go (97.1%)</option>
				
				<option value="file39">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_defaults.go (100.0%)</option>
				
				<option value="file40">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_template_defaults.go (0.0%)</option>
				
				<option value="file41">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_template_validation.go (96.6%)</option>
				
				<option value="file42">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_types.go (100.0%)</option>
				
				<option value="file43">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_types_convert.go (71.4%)</option>
				
				<option value="file44">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_validation.go (94.0%)</option>
				
				<option value="file45">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/version_validation.go (100.0%)</option>
				
				<option value="file46">github.com/tektoncd/triggers/pkg/apis/triggers/validation.go (100.0%)</option>
				
				<option value="file47">github.com/tektoncd/triggers/pkg/client/clientset/versioned/clientset.go (0.0%)</option>
				
				<option value="file48">github.com/tektoncd/triggers/pkg/client/clientset/versioned/fake/clientset_generated.go (0.0%)</option>
				
				<option value="file49">github.com/tektoncd/triggers/pkg/client/clientset/versioned/fake/register.go (0.0%)</option>
				
				<option value="file50">github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme/register.go (0.0%)</option>
				
				<option value="file51">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/clusterinterceptor.go (0.0%)</option>
				
				<option value="file52">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file53">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/eventlistener.go (0.0%)</option>
				
				<option value="file54">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_clusterinterceptor.go (0.0%)</option>
				
				<option value="file55">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_clustertriggerbinding.go (0.0%)</option>
				
				<option value="file56">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_eventlistener.go (0.0%)</option>
				
				<option value="file57">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_interceptor.go (0.0%)</option>
				
				<option value="file58">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_trigger.go (0.0%)</option>
				
				<option value="file59">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_triggerbinding.go (0.0%)</option>
				
				<option value="file60">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_triggers_client.go (0.0%)</option>
				
				<option value="file61">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake/fake_triggertemplate.go (0.0%)</option>
				
				<option value="file62">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/interceptor.go (0.0%)</option>
				
				<option value="file63">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/trigger.go (0.0%)</option>
				
				<option value="file64">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/triggerbinding.go (0.0%)</option>
				
				<option value="file65">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/triggers_client.go (0.0%)</option>
				
				<option value="file66">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/triggertemplate.go (0.0%)</option>
				
				<option value="file67">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file68">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/eventlistener.go (0.0%)</option>
				
				<option value="file69">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/fake/fake_clustertriggerbinding.go (0.0%)</option>
				
				<option value="file70">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/fake/fake_eventlistener.go (0.0%)</option>
				
				<option value="file71">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/fake/fake_trigger.go (0.0%)</option>
				
				<option value="file72">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/fake/fake_triggerbinding.go (0.0%)</option>
				
				<option value="file73">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/fake/fake_triggers_client.go (0.0%)</option>
				
				<option value="file74">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/fake/fake_triggertemplate.go (0.0%)</option>
				
				<option value="file75">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/trigger.go (0.0%)</option>
				
				<option value="file76">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/triggerbinding.go (0.0%)</option>
				
				<option value="file77">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/triggers_client.go (0.0%)</option>
				
				<option value="file78">github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/triggertemplate.go (0.0%)</option>
				
				<option value="file79">github.com/tektoncd/triggers/pkg/client/dynamic/clientset/clientset.go (0.0%)</option>
				
				<option value="file80">github.com/tektoncd/triggers/pkg/client/dynamic/clientset/errorclient.go (0.0%)</option>
				
				<option value="file81">github.com/tektoncd/triggers/pkg/client/informers/externalversions/factory.go (0.0%)</option>
				
				<option value="file82">github.com/tektoncd/triggers/pkg/client/informers/externalversions/generic.go (0.0%)</option>
				
				<option value="file83">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/interface.go (0.0%)</option>
				
				<option value="file84">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/clusterinterceptor.go (0.0%)</option>
				
				<option value="file85">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file86">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/eventlistener.go (0.0%)</option>
				
				<option value="file87">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/interceptor.go (0.0%)</option>
				
				<option value="file88">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/interface.go (0.0%)</option>
				
				<option value="file89">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/trigger.go (0.0%)</option>
				
				<option value="file90">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/triggerbinding.go (0.0%)</option>
				
				<option value="file91">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1/triggertemplate.go (0.0%)</option>
				
				<option value="file92">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file93">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1/eventlistener.go (0.0%)</option>
				
				<option value="file94">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1/interface.go (0.0%)</option>
				
				<option value="file95">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1/trigger.go (0.0%)</option>
				
				<option value="file96">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1/triggerbinding.go (0.0%)</option>
				
				<option value="file97">github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1/triggertemplate.go (0.0%)</option>
				
				<option value="file98">github.com/tektoncd/triggers/pkg/client/injection/client/client.go (0.0%)</option>
				
				<option value="file99">github.com/tektoncd/triggers/pkg/client/injection/client/fake/fake.go (0.0%)</option>
				
				<option value="file100">github.com/tektoncd/triggers/pkg/client/injection/informers/factory/factory.go (0.0%)</option>
				
				<option value="file101">github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake/fake.go (0.0%)</option>
				
				<option value="file102">github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered/fake/fake_filtered_factory.go (0.0%)</option>
				
				<option value="file103">github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered/filtered_factory.go (0.0%)</option>
				
				<option value="file104">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor/clusterinterceptor.go (0.0%)</option>
				
				<option value="file105">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor/fake/fake.go (0.0%)</option>
				
				<option value="file106">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor/filtered/clusterinterceptor.go (0.0%)</option>
				
				<option value="file107">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file108">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clustertriggerbinding/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file109">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clustertriggerbinding/fake/fake.go (0.0%)</option>
				
				<option value="file110">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clustertriggerbinding/filtered/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file111">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clustertriggerbinding/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file112">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/eventlistener/eventlistener.go (0.0%)</option>
				
				<option value="file113">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/eventlistener/fake/fake.go (0.0%)</option>
				
				<option value="file114">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/eventlistener/filtered/eventlistener.go (0.0%)</option>
				
				<option value="file115">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/eventlistener/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file116">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor/fake/fake.go (0.0%)</option>
				
				<option value="file117">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file118">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor/filtered/interceptor.go (0.0%)</option>
				
				<option value="file119">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor/interceptor.go (0.0%)</option>
				
				<option value="file120">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/trigger/fake/fake.go (0.0%)</option>
				
				<option value="file121">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/trigger/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file122">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/trigger/filtered/trigger.go (0.0%)</option>
				
				<option value="file123">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/trigger/trigger.go (0.0%)</option>
				
				<option value="file124">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggerbinding/fake/fake.go (0.0%)</option>
				
				<option value="file125">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggerbinding/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file126">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggerbinding/filtered/triggerbinding.go (0.0%)</option>
				
				<option value="file127">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggerbinding/triggerbinding.go (0.0%)</option>
				
				<option value="file128">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggertemplate/fake/fake.go (0.0%)</option>
				
				<option value="file129">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggertemplate/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file130">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggertemplate/filtered/triggertemplate.go (0.0%)</option>
				
				<option value="file131">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggertemplate/triggertemplate.go (0.0%)</option>
				
				<option value="file132">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file133">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding/fake/fake.go (0.0%)</option>
				
				<option value="file134">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding/filtered/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file135">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file136">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener/eventlistener.go (0.0%)</option>
				
				<option value="file137">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener/fake/fake.go (0.0%)</option>
				
				<option value="file138">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener/filtered/eventlistener.go (0.0%)</option>
				
				<option value="file139">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file140">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger/fake/fake.go (0.0%)</option>
				
				<option value="file141">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file142">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger/filtered/trigger.go (0.0%)</option>
				
				<option value="file143">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger/trigger.go (0.0%)</option>
				
				<option value="file144">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding/fake/fake.go (0.0%)</option>
				
				<option value="file145">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file146">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding/filtered/triggerbinding.go (0.0%)</option>
				
				<option value="file147">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding/triggerbinding.go (0.0%)</option>
				
				<option value="file148">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate/fake/fake.go (0.0%)</option>
				
				<option value="file149">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate/filtered/fake/fake.go (0.0%)</option>
				
				<option value="file150">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate/filtered/triggertemplate.go (0.0%)</option>
				
				<option value="file151">github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate/triggertemplate.go (0.0%)</option>
				
				<option value="file152">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor/controller.go (0.0%)</option>
				
				<option value="file153">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor/reconciler.go (0.0%)</option>
				
				<option value="file154">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor/state.go (0.0%)</option>
				
				<option value="file155">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/eventlistener/controller.go (0.0%)</option>
				
				<option value="file156">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/eventlistener/reconciler.go (0.0%)</option>
				
				<option value="file157">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/eventlistener/state.go (0.0%)</option>
				
				<option value="file158">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor/controller.go (0.0%)</option>
				
				<option value="file159">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor/reconciler.go (0.0%)</option>
				
				<option value="file160">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor/state.go (0.0%)</option>
				
				<option value="file161">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener/controller.go (0.0%)</option>
				
				<option value="file162">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener/reconciler.go (0.0%)</option>
				
				<option value="file163">github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener/state.go (0.0%)</option>
				
				<option value="file164">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1/clusterinterceptor.go (0.0%)</option>
				
				<option value="file165">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file166">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1/eventlistener.go (0.0%)</option>
				
				<option value="file167">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1/interceptor.go (0.0%)</option>
				
				<option value="file168">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1/trigger.go (0.0%)</option>
				
				<option value="file169">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1/triggerbinding.go (0.0%)</option>
				
				<option value="file170">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1/triggertemplate.go (0.0%)</option>
				
				<option value="file171">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1/clustertriggerbinding.go (0.0%)</option>
				
				<option value="file172">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1/eventlistener.go (0.0%)</option>
				
				<option value="file173">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1/trigger.go (0.0%)</option>
				
				<option value="file174">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1/triggerbinding.go (0.0%)</option>
				
				<option value="file175">github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1/triggertemplate.go (0.0%)</option>
				
				<option value="file176">github.com/tektoncd/triggers/pkg/dynamic/custom_reconcile.go (86.7%)</option>
				
				<option value="file177">github.com/tektoncd/triggers/pkg/dynamic/dynamic.go (0.0%)</option>
				
				<option value="file178">github.com/tektoncd/triggers/pkg/interceptors/bitbucket/bitbucket.go (89.7%)</option>
				
				<option value="file179">github.com/tektoncd/triggers/pkg/interceptors/cel/cel.go (88.2%)</option>
				
				<option value="file180">github.com/tektoncd/triggers/pkg/interceptors/cel/triggers.go (88.2%)</option>
				
				<option value="file181">github.com/tektoncd/triggers/pkg/interceptors/github/github.go (92.7%)</option>
				
				<option value="file182">github.com/tektoncd/triggers/pkg/interceptors/gitlab/gitlab.go (89.7%)</option>
				
				<option value="file183">github.com/tektoncd/triggers/pkg/interceptors/interceptors.go (89.4%)</option>
				
				<option value="file184">github.com/tektoncd/triggers/pkg/interceptors/secret_getter.go (84.6%)</option>
				
				<option value="file185">github.com/tektoncd/triggers/pkg/interceptors/server/server.go (80.9%)</option>
				
				<option value="file186">github.com/tektoncd/triggers/pkg/interceptors/slack/slack.go (80.0%)</option>
				
				<option value="file187">github.com/tektoncd/triggers/pkg/interceptors/webhook/webhook.go (90.0%)</option>
				
				<option value="file188">github.com/tektoncd/triggers/pkg/observability/attributekey/key.go (92.3%)</option>
				
				<option value="file189">github.com/tektoncd/triggers/pkg/observability/config.go (80.0%)</option>
				
				<option value="file190">github.com/tektoncd/triggers/pkg/observability/configmap/parse.go (100.0%)</option>
				
				<option value="file191">github.com/tektoncd/triggers/pkg/observability/metrics/config.go (0.0%)</option>
				
				<option value="file192">github.com/tektoncd/triggers/pkg/observability/metrics/provider.go (0.0%)</option>
				
				<option value="file193">github.com/tektoncd/triggers/pkg/observability/resource/default.go (100.0%)</option>
				
				<option value="file194">github.com/tektoncd/triggers/pkg/observability/runtime/config.go (0.0%)</option>
				
				<option value="file195">github.com/tektoncd/triggers/pkg/observability/tracing/config.go (0.0%)</option>
				
				<option value="file196">github.com/tektoncd/triggers/pkg/reconciler/clusterinterceptor/clusterinterceptor.go (90.9%)</option>
				
				<option value="file197">github.com/tektoncd/triggers/pkg/reconciler/clusterinterceptor/controller.go (0.0%)</option>
				
				<option value="file198">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/controller.go (85.7%)</option>
				
				<option value="file199">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/eventlistener.go (71.5%)</option>
				
				<option value="file200">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/config.go (100.0%)</option>
				
				<option value="file201">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/container.go (100.0%)</option>
				
				<option value="file202">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/custom.go (94.1%)</option>
				
				<option value="file203">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/deployment.go (98.6%)</option>
				
				<option value="file204">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/meta.go (100.0%)</option>
				
				<option value="file205">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/service.go (100.0%)</option>
				
				<option value="file206">github.com/tektoncd/triggers/pkg/reconciler/events/event.go (66.7%)</option>
				
				<option value="file207">github.com/tektoncd/triggers/pkg/reconciler/interceptor/controller.go (0.0%)</option>
				
				<option value="file208">github.com/tektoncd/triggers/pkg/reconciler/interceptor/interceptor.go (90.9%)</option>
				
				<option value="file209">github.com/tektoncd/triggers/pkg/reconciler/metrics/injection.go (44.4%)</option>
				
				<option value="file210">github.com/tektoncd/triggers/pkg/reconciler/metrics/metrics.go (76.6%)</option>
				
				<option value="file211">github.com/tektoncd/triggers/pkg/resources/create.go (81.2%)</option>
				
				<option value="file212">github.com/tektoncd/triggers/pkg/sink/auth_override.go (0.0%)</option>
				
				<option value="file213">github.com/tektoncd/triggers/pkg/sink/cloudevent/cloudevent.go (73.3%)</option>
				
				<option value="file214">github.com/tektoncd/triggers/pkg/sink/cloudevent/cloudeventclient.go (5.9%)</option>
				
				<option value="file215">github.com/tektoncd/triggers/pkg/sink/initialization.go (50.0%)</option>
				
				<option value="file216">github.com/tektoncd/triggers/pkg/sink/metrics.go (77.1%)</option>
				
				<option value="file217">github.com/tektoncd/triggers/pkg/sink/sink.go (71.6%)</option>
				
				<option value="file218">github.com/tektoncd/triggers/pkg/sink/validate_payload.go (76.2%)</option>
				
				<option value="file219">github.com/tektoncd/triggers/pkg/system/system.go (0.0%)</option>
				
				<option value="file220">github.com/tektoncd/triggers/pkg/template/event.go (100.0%)</option>
				
				<option value="file221">github.com/tektoncd/triggers/pkg/template/jsonpath.go (93.3%)</option>
				
				<option value="file222">github.com/tektoncd/triggers/pkg/template/resource.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 Copyright 2019 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package main

import (
        "fmt"
        "log"
        "net/http"
        "os"

        "github.com/google/go-github/v31/github"
)

const (
        // Environment variable containing GitHub secret token
        envSecret = "GITHUB_SECRET_TOKEN"
)

func main() <span class="cov0" title="0">{
        secretToken := os.Getenv(envSecret)
        if secretToken == "" </span><span class="cov0" title="0">{
                log.Fatalf("No secret token given")
        }</span>

        <span class="cov0" title="0">http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                // TODO: We should probably send over the EL eventID as a X-Tekton-Event-Id header as well
                payload, err := github.ValidatePayload(request, []byte(secretToken))
                id := github.DeliveryID(request)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error handling GitHub Event with delivery ID %s : %q", id, err)
                        http.Error(writer, fmt.Sprint(err), http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">log.Printf("Handling GitHub Event with delivery ID: %s; Payload: %s", id, payload)
                n, err := writer.Write(payload)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to write response for GitHub event ID: %s. Bytes writted: %d. Error: %q", id, n, err)
                }</span>
        })

        <span class="cov0" title="0">log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", 8080), nil))</span> //nolint:gosec
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package adapter

import (
        "bytes"
        "context"
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "net"
        "net/http"
        "sync"
        "time"

        clusterinterceptorsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        interceptorsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor"
        clustertriggerbindingsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding"
        eventlistenerinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        triggersinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger"
        triggerbindingsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding"
        triggertemplatesinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        "github.com/tektoncd/triggers/pkg/sink"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/apimachinery/pkg/watch"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/tools/record"
        "knative.dev/eventing/pkg/adapter/v2"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection/clients/dynamicclient"
        "knative.dev/pkg/logging"
)

type envConfig struct {
        adapter.EnvConfig
}

func NewEnvConfig() adapter.EnvConfigAccessor <span class="cov0" title="0">{
        return &amp;envConfig{}
}</span>

var (
        interval = 10 * time.Second
        timeout  = 1 * time.Minute
)

// sinker implements the adapter for an event listener.
type sinker struct {
        Logger    *zap.SugaredLogger
        Namespace string

        Args     sink.Args
        Clients  sink.Clients
        Recorder *sink.Recorder

        injCtx context.Context //nolint:containedctx
}

var _ adapter.Adapter = (*sinker)(nil)

func (s *sinker) createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: s.Clients.K8sClient.CoreV1().Events("")}),
                }

                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func (s *sinker) getHTTPClient() (*http.Client, error) <span class="cov8" title="1">{
        var tlsConfig *tls.Config

        certPool := x509.NewCertPool()

        err := s.getCertFromInterceptor(certPool)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;http.Client{}, fmt.Errorf("Timed out waiting on CaBundle to available for clusterInterceptor: %w", err)
        }</span>

        // running go routine here to add/update certPool if there is new or change in caCert bundle.
        // caCert changes if certs expired, if someone adds new ClusterInterceptor with caBundle
        <span class="cov0" title="0">ticker := time.NewTicker(time.Minute)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        &lt;-ticker.C
                        if err := s.getCertFromInterceptor(certPool); err != nil </span><span class="cov0" title="0">{
                                s.Logger.Fatalf("Timed out waiting on CaBundle to available for clusterInterceptor: %v", err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">tlsConfig = &amp;tls.Config{
                RootCAs:    certPool,
                MinVersion: tls.VersionTLS12, // Added MinVersion to avoid  G402: TLS MinVersion too low. (gosec)
        }
        return &amp;http.Client{
                Transport: &amp;http.Transport{
                        TLSClientConfig: tlsConfig,
                        Dial: (&amp;net.Dialer{
                                Timeout:   s.Args.ElHTTPClientReadTimeOut * time.Second, //nolint:durationcheck
                                KeepAlive: s.Args.ElHTTPClientKeepAlive * time.Second,   //nolint:durationcheck
                        }).Dial,
                        TLSHandshakeTimeout:   s.Args.ElHTTPClientTLSHandshakeTimeout * time.Second,         //nolint:durationcheck
                        ResponseHeaderTimeout: s.Args.ElHTTPClientResponseHeaderTimeout * time.Second,       //nolint:durationcheck
                        ExpectContinueTimeout: s.Args.ElHTTPClientExpectContinueTimeout * time.Second}}, nil</span> //nolint:durationcheck
}

func (s *sinker) getCertFromInterceptor(certPool *x509.CertPool) error <span class="cov8" title="1">{
        var (
                caCert     []byte
                count      int
                httpsCILen int
        )
        ctx := context.Background()
        if err := wait.PollUntilContextTimeout(ctx, interval, timeout, true, func(_ context.Context) (bool, error) </span><span class="cov8" title="1">{
                clusterInterceptorList, err := clusterinterceptorsinformer.Get(s.injCtx).Lister().List(labels.NewSelector()) //nolint:contextcheck
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">for i := range clusterInterceptorList </span><span class="cov8" title="1">{
                        if v, k := clusterInterceptorList[i].Labels["server/type"]; k &amp;&amp; v == "https" </span><span class="cov8" title="1">{
                                httpsCILen++
                                if !bytes.Equal(clusterInterceptorList[i].Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov8" title="1">{
                                        caCert = clusterInterceptorList[i].Spec.ClientConfig.CaBundle
                                        if ok := certPool.AppendCertsFromPEM(caCert); !ok </span><span class="cov8" title="1">{
                                                return false, fmt.Errorf("unable to parse cert from %s", caCert)
                                        }</span>
                                        <span class="cov0" title="0">count++</span>
                                }
                        }
                }

                <span class="cov8" title="1">if httpsCILen == 0 || httpsCILen != count </span><span class="cov8" title="1">{
                        return false, errors.New("empty caBundle in clusterInterceptor spec")
                }</span>

                <span class="cov0" title="0">httpsCILen = 0
                count = 0

                interceptorList, err := interceptorsinformer.Get(s.injCtx).Lister().Interceptors(s.Namespace).List(labels.Everything()) //nolint:contextcheck
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">for i := range interceptorList </span><span class="cov0" title="0">{
                        if v, k := interceptorList[i].Labels["server/type"]; k &amp;&amp; v == "https" </span><span class="cov0" title="0">{
                                httpsCILen++
                                if !bytes.Equal(interceptorList[i].Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov0" title="0">{
                                        caCert = interceptorList[i].Spec.ClientConfig.CaBundle
                                        if ok := certPool.AppendCertsFromPEM(caCert); !ok </span><span class="cov0" title="0">{
                                                return false, fmt.Errorf("unable to parse cert from %s", caCert)
                                        }</span>
                                        <span class="cov0" title="0">count++</span>
                                }
                        }
                }
                <span class="cov0" title="0">if httpsCILen != count </span><span class="cov0" title="0">{
                        return false, errors.New("empty caBundle in interceptor spec")
                }</span>

                <span class="cov0" title="0">return true, nil</span>
        }); err != nil <span class="cov8" title="1">{
                return fmt.Errorf("Timed out waiting on CaBundle to available for Interceptor: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *sinker) Start(ctx context.Context) error <span class="cov0" title="0">{
        clientObj, err := s.getHTTPClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Create EventListener Sink

        <span class="cov0" title="0">dynamicClient := dynamicclient.Get(ctx)

        r := sink.Sink{
                KubeClientSet:          kubeclient.Get(ctx),
                DiscoveryClient:        s.Clients.DiscoveryClient,
                DynamicClient:          dynamicClient,
                TriggersClient:         s.Clients.TriggersClient,
                HTTPClient:             clientObj,
                CEClient:               s.Clients.CEClient,
                EventListenerName:      s.Args.ElName,
                EventListenerNamespace: s.Args.ElNamespace,
                PayloadValidation:      s.Args.PayloadValidation,
                Logger:                 s.Logger,
                Recorder:               s.Recorder,
                CloudEventURI:          s.Args.CloudEventURI,
                Auth:                   sink.DefaultAuthOverride{},
                WGProcessTriggers:      &amp;sync.WaitGroup{},
                EventRecorder:          s.createRecorder(s.injCtx, "EventListener"), //nolint:contextcheck

                // Register all the listers we'll need
                EventListenerLister:         eventlistenerinformer.Get(s.injCtx).Lister(),          //nolint:contextcheck
                TriggerLister:               triggersinformer.Get(s.injCtx).Lister(),               //nolint:contextcheck
                TriggerBindingLister:        triggerbindingsinformer.Get(s.injCtx).Lister(),        //nolint:contextcheck
                ClusterTriggerBindingLister: clustertriggerbindingsinformer.Get(s.injCtx).Lister(), //nolint:contextcheck
                TriggerTemplateLister:       triggertemplatesinformer.Get(s.injCtx).Lister(),       //nolint:contextcheck
                ClusterInterceptorLister:    clusterinterceptorsinformer.Get(s.injCtx).Lister(),    //nolint:contextcheck
                InterceptorLister:           interceptorsinformer.Get(s.injCtx).Lister(),           //nolint:contextcheck
        }

        mux := http.NewServeMux()
        eventHandler := http.HandlerFunc(r.HandleEvent)
        metricsRecorder := &amp;sink.MetricsHandler{Handler: r.IsValidPayload(eventHandler)}

        mux.HandleFunc("/", metricsRecorder.Intercept(r.NewMetricsRecorderInterceptor()))

        // For handling Liveness Probe
        // TODO(dibyom): Livness, metrics etc. should be on a separate port
        mux.HandleFunc("/live", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                fmt.Fprint(w, "ok")
        }</span>)

        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:              ":" + s.Args.Port,
                ReadHeaderTimeout: s.Args.ELReadTimeOut * time.Second,  //nolint:durationcheck
                ReadTimeout:       s.Args.ELReadTimeOut * time.Second,  //nolint:durationcheck
                WriteTimeout:      s.Args.ELWriteTimeOut * time.Second, //nolint:durationcheck
                IdleTimeout:       s.Args.ELIdleTimeOut * time.Second,  //nolint:durationcheck
                Handler: http.TimeoutHandler(mux,
                        s.Args.ELTimeOutHandler*time.Second, "EventListener Timeout!\n"), //nolint:durationcheck
        }

        if s.Args.Cert == "" &amp;&amp; s.Args.Key == "" </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := srv.ListenAndServeTLS(s.Args.Cert, s.Args.Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func New(sinkArgs sink.Args, sinkClients sink.Clients, recorder *sink.Recorder) adapter.AdapterConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, processed adapter.EnvConfigAccessor, _ cloudevents.Client) adapter.Adapter </span><span class="cov0" title="0">{
                env := processed.(*envConfig)
                logger := logging.FromContext(ctx)

                return &amp;sinker{
                        Logger:    logger,
                        Namespace: env.Namespace,
                        Args:      sinkArgs,
                        Clients:   sinkClients,
                        Recorder:  recorder,
                        injCtx:    ctx,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "strconv"

        corev1 "k8s.io/api/core/v1"
)

const (
        defaultServiceAccountKey   = "default-service-account"
        DefaultRunAsUserKey        = "default-run-as-user"
        DefaultRunAsGroupKey       = "default-run-as-group"
        DefaultFSGroupKey          = "default-fs-group"
        defaultRunAsNonRootKey     = "default-run-as-non-root"
        DefaultServiceAccountValue = "default"
        defaultRunAsUserValue      = 65532
        defaultRunAsGroupValue     = 65532
        defaultFsGroupValue        = 65532
        defaultRunAsNonRootValue   = true
)

// Defaults holds the default configurations
// +k8s:deepcopy-gen=true
type Defaults struct {
        DefaultServiceAccount string
        DefaultRunAsUser      int64
        DefaultRunAsGroup     int64
        DefaultFSGroup        int64
        DefaultRunAsNonRoot   bool
        // These three fields are used to decide whether to configure
        // runAsUser, runAsGroup and fsGroup within a Security Context Constraint (SCC).
        IsDefaultRunAsUserEmpty  bool
        IsDefaultRunAsGroupEmpty bool
        IsDefaultFsGroupEmpty    bool
}

// GetDefaultsConfigName returns the name of the configmap containing all
// defined defaults.
func GetDefaultsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_DEFAULTS_NAME"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return "config-defaults-triggers"</span>
}

// Equals returns true if two Configs are identical
func (cfg *Defaults) Equals(other *Defaults) bool <span class="cov8" title="1">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if cfg == nil || other == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return other.DefaultServiceAccount == cfg.DefaultServiceAccount &amp;&amp;
                other.DefaultRunAsUser == cfg.DefaultRunAsUser &amp;&amp;
                other.DefaultRunAsGroup == cfg.DefaultRunAsGroup &amp;&amp;
                other.DefaultFSGroup == cfg.DefaultFSGroup &amp;&amp;
                other.DefaultRunAsNonRoot == cfg.DefaultRunAsNonRoot</span>
}

// NewDefaultsFromMap returns a Config given a map corresponding to a ConfigMap
func NewDefaultsFromMap(cfgMap map[string]string) (*Defaults, error) <span class="cov8" title="1">{
        tc := Defaults{
                DefaultServiceAccount: DefaultServiceAccountValue,
                DefaultRunAsUser:      defaultRunAsUserValue,
                DefaultRunAsGroup:     defaultRunAsGroupValue,
                DefaultFSGroup:        defaultFsGroupValue,
                DefaultRunAsNonRoot:   defaultRunAsNonRootValue,
        }

        if defaultServiceAccount, ok := cfgMap[defaultServiceAccountKey]; ok </span><span class="cov8" title="1">{
                tc.DefaultServiceAccount = defaultServiceAccount
        }</span>

        <span class="cov8" title="1">if defaultRunAsUser, ok := cfgMap[DefaultRunAsUserKey]; ok </span><span class="cov8" title="1">{
                if defaultRunAsUser != "" </span><span class="cov8" title="1">{
                        runAsUser, err := strconv.ParseInt(defaultRunAsUser, 10, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing runAsUser config %q", defaultRunAsUser)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultRunAsUser = runAsUser</span>
                } else<span class="cov8" title="1"> {
                        // if runAsUser is "" don't set runAsUser in SCC
                        tc.IsDefaultRunAsUserEmpty = true
                }</span>
        }

        <span class="cov8" title="1">if defaultRunAsGroup, ok := cfgMap[DefaultRunAsGroupKey]; ok </span><span class="cov8" title="1">{
                if defaultRunAsGroup != "" </span><span class="cov8" title="1">{
                        runAsGroup, err := strconv.ParseInt(defaultRunAsGroup, 10, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing runAsGroup config %q", defaultRunAsGroup)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultRunAsGroup = runAsGroup</span>
                } else<span class="cov8" title="1"> {
                        // if runAsGroup is "" don't set runAsGroup in SCC
                        tc.IsDefaultRunAsGroupEmpty = true
                }</span>
        }

        <span class="cov8" title="1">if defaultFsGroup, ok := cfgMap[DefaultFSGroupKey]; ok </span><span class="cov8" title="1">{
                if defaultFsGroup != "" </span><span class="cov8" title="1">{
                        fsGroup, err := strconv.ParseInt(defaultFsGroup, 10, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing fsGroup config %q", defaultFsGroup)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultFSGroup = fsGroup</span>
                } else<span class="cov8" title="1"> {
                        // if fsGroup is "" don't set fsGroup in SCC
                        tc.IsDefaultFsGroupEmpty = true
                }</span>
        }

        <span class="cov8" title="1">if defaultRunAsNonRoot, ok := cfgMap[defaultRunAsNonRootKey]; ok </span><span class="cov8" title="1">{
                if defaultRunAsNonRoot != "" </span><span class="cov8" title="1">{
                        runAsNonRoot, err := strconv.ParseBool(defaultRunAsNonRoot)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing runAsNonRoot config %q", defaultRunAsNonRoot)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultRunAsNonRoot = runAsNonRoot</span>
                } else<span class="cov8" title="1"> {
                        // if "" value is provided via configmap set back to default value which is true
                        tc.DefaultRunAsNonRoot = defaultRunAsNonRootValue
                }</span>
        }

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// NewDefaultsFromConfigMap returns a Config for the given configmap
func NewDefaultsFromConfigMap(config *corev1.ConfigMap) (*Defaults, error) <span class="cov8" title="1">{
        return NewDefaultsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "regexp"
        "strings"

        corev1 "k8s.io/api/core/v1"
)

const (
        StableAPIFieldValue    = "stable"
        AlphaAPIFieldValue     = "alpha"
        enableAPIFieldsKey     = "enable-api-fields"
        DefaultEnableAPIFields = StableAPIFieldValue

        labelsExclusionPattern = "labels-exclusion-pattern"
)

// FeatureFlags holds the features configurations
// +k8s:deepcopy-gen=true
type FeatureFlags struct {
        // EnableAPIFields determines which gated features are enabled.
        // Acceptable values are "stable" or "alpha". Defaults to "stable"
        EnableAPIFields string
        // LabelsExclusionPattern determines the regex pattern to use to exclude
        // labels being propagated to resources created by the EventListener
        LabelsExclusionPattern string
}

// GetFeatureFlagsConfigName returns the name of the configmap containing all
// feature flags.
func GetFeatureFlagsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_FEATURE_FLAGS_NAME"); e != "" </span><span class="cov8" title="1">{
                return e
        }</span>
        <span class="cov8" title="1">return "feature-flags-triggers"</span>
}

// NewFeatureFlagsFromMap returns a Config given a map corresponding to a ConfigMap
func NewFeatureFlagsFromMap(cfgMap map[string]string) (*FeatureFlags, error) <span class="cov8" title="1">{
        tc := FeatureFlags{}
        var err error
        if tc.EnableAPIFields, err = getEnabledAPI(cfgMap); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if tc.LabelsExclusionPattern, err = getLabelsExclusionPattern(cfgMap); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// getLabelsExclusionPattern gets the "labels-exclusion-pattern" flag based on the content of a given map.
// If the feature gate is not defined then we ignore it, if the pattern is not
// valid regex then we return error
func getLabelsExclusionPattern(cfgMap map[string]string) (string, error) <span class="cov8" title="1">{
        if pattern, ok := cfgMap[labelsExclusionPattern]; ok </span><span class="cov8" title="1">{
                if _, err := regexp.Compile(pattern); err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("invalid value for feature flag %q: %q", labelsExclusionPattern, pattern)
                }</span>
                <span class="cov8" title="1">return pattern, nil</span>
        }

        <span class="cov8" title="1">return "", nil</span>
}

// getEnabledAPI gets the "enable-api-fields" flag based on the content of a given map.
// If the feature gate is invalid or missing then an error is returned.
func getEnabledAPI(cfgMap map[string]string) (string, error) <span class="cov8" title="1">{
        value := DefaultEnableAPIFields
        if cfg, ok := cfgMap[enableAPIFieldsKey]; ok </span><span class="cov8" title="1">{
                value = strings.ToLower(cfg)
        }</span>
        <span class="cov8" title="1">if value != AlphaAPIFieldValue &amp;&amp; value != StableAPIFieldValue </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid value for feature flag %q: %q", enableAPIFieldsKey, value)
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

// NewFeatureFlagsFromConfigMap returns a Config for the given configmap
func NewFeatureFlagsFromConfigMap(config *corev1.ConfigMap) (*FeatureFlags, error) <span class="cov8" title="1">{
        return NewFeatureFlagsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"

        "knative.dev/pkg/configmap"
)

type cfgKey struct{}

// Config holds the collection of configurations that we attach to contexts.
// +k8s:deepcopy-gen=false
type Config struct {
        Defaults     *Defaults
        FeatureFlags *FeatureFlags
}

// FromContext extracts a Config from the provided context.
func FromContext(ctx context.Context) *Config <span class="cov8" title="1">{
        x, ok := ctx.Value(cfgKey{}).(*Config)
        if ok </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// FromContextOrDefaults is like FromContext, but when no Config is attached it
// returns a Config populated with the defaults for each of the Config fields.
func FromContextOrDefaults(ctx context.Context) *Config <span class="cov8" title="1">{
        if cfg := FromContext(ctx); cfg != nil </span><span class="cov8" title="1">{
                return cfg
        }</span>
        <span class="cov8" title="1">defaults, _ := NewDefaultsFromMap(map[string]string{})
        featureFlags, _ := NewFeatureFlagsFromMap(map[string]string{})
        return &amp;Config{
                Defaults:     defaults,
                FeatureFlags: featureFlags,
        }</span>
}

// ToContext attaches the provided Config to the provided context, returning the
// new context with the Config attached.
func ToContext(ctx context.Context, c *Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, cfgKey{}, c)
}</span>

// Store is a typed wrapper around configmap.Untyped store to handle our configmaps.
// +k8s:deepcopy-gen=false
type Store struct {
        *configmap.UntypedStore
}

// NewStore creates a new store of Configs and optionally calls functions when ConfigMaps are updated.
func NewStore(logger configmap.Logger, onAfterStore ...func(name string, value interface{})) *Store <span class="cov8" title="1">{
        store := &amp;Store{
                UntypedStore: configmap.NewUntypedStore(
                        "defaults/features/artifacts",
                        logger,
                        configmap.Constructors{
                                GetFeatureFlagsConfigName(): NewFeatureFlagsFromConfigMap,
                                GetDefaultsConfigName():     NewDefaultsFromConfigMap,
                        },
                        onAfterStore...,
                ),
        }

        return store
}</span>

// ToContext attaches the current Config state to the provided context.
func (s *Store) ToContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        return ToContext(ctx, s.Load())
}</span>

// Load creates a Config from the current config state of the Store.
func (s *Store) Load() *Config <span class="cov8" title="1">{
        defaults := s.UntypedLoad(GetDefaultsConfigName())
        if defaults == nil </span><span class="cov0" title="0">{
                defaults, _ = NewDefaultsFromMap(map[string]string{})
        }</span>
        <span class="cov8" title="1">featureFlags := s.UntypedLoad(GetFeatureFlagsConfigName())
        if featureFlags == nil </span><span class="cov8" title="1">{
                featureFlags, _ = NewFeatureFlagsFromMap(map[string]string{})
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                Defaults:     defaults.(*Defaults).DeepCopy(),
                FeatureFlags: featureFlags.(*FeatureFlags).DeepCopy(),
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package contexts

import "context"

// upgradeViaDefaultingKey is used as the key in a context.Context.
// This variable doesn't really matter, so it can be a total random name.
// Setting this key indicates that default values for a resource should be
// updated to new values. This is used to ensure non breaking updates when
// a default value of a resource changes or when a field is removed.
type upgradeViaDefaultingKey struct{}

// WithUpgradeViaDefaulting sets the upgradeViaDefaultingKey on the context
// indicating that default values for a resource should be updated to new values.
func WithUpgradeViaDefaulting(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, upgradeViaDefaultingKey{}, struct{}{})
}</span>

// IsUpgradeViaDefaulting checks if the upgradeViaDefaultingKey is set on
// the context.
func IsUpgradeViaDefaulting(ctx context.Context) bool <span class="cov0" title="0">{
        return ctx.Value(upgradeViaDefaultingKey{}) != nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

// SetDefaults sets the defaults on the object.
func (it *ClusterInterceptor) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, ok := it.GetLabels()["server/type"]; !ok </span><span class="cov0" title="0">{
                // if server type is not set its assumed that running server is http
                it.Labels = map[string]string{
                        "server/type": "http",
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "bytes"
        "errors"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// Check that EventListener may be validated and defaulted.
var _ apis.Validatable = (*ClusterInterceptor)(nil)
var _ apis.Defaultable = (*ClusterInterceptor)(nil)

// +genclient
// +genclient:nonNamespaced
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
// ClusterInterceptor describes a pluggable interceptor including configuration
// such as the fields it accepts and its deployment address. The type is based on
// the Validating/MutatingWebhookConfiguration types for configuring AdmissionWebhooks
type ClusterInterceptor struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec ClusterInterceptorSpec `json:"spec"`
        // +optional
        Status ClusterInterceptorStatus `json:"status"`
}

// ClusterInterceptorSpec describes the Spec for an ClusterInterceptor
type ClusterInterceptorSpec struct {
        ClientConfig ClientConfig `json:"clientConfig"`
}

// ClusterInterceptorStatus holds the status of the ClusterInterceptor
// +k8s:deepcopy-gen=true
type ClusterInterceptorStatus struct {
        duckv1.Status `json:",inline"`

        // ClusterInterceptor is Addressable and exposes the URL where the Interceptor is running
        duckv1.AddressStatus `json:",inline"`
}

// ClientConfig describes how a client can communicate with the Interceptor
type ClientConfig struct {
        // CaBundle is a PEM encoded CA bundle which will be used to validate the clusterinterceptor server certificate
        CaBundle []byte `json:"caBundle,omitempty"`
        // URL is a fully formed URL pointing to the interceptor
        // Mutually exclusive with Service
        URL *apis.URL `json:"url,omitempty"`

        // Service is a reference to a Service object where the interceptor is running
        // Mutually exclusive with URL
        Service *ServiceReference `json:"service,omitempty"`
}

var (
        defaultHTTPSPort = int32(8443)
        defaultHTTPPort  = int32(80)
)

// ServiceReference is a reference to a Service object
// with an optional path
type ServiceReference struct {
        // Name is the name of the service
        Name string `json:"name"`

        // Namespace is the namespace of the service
        Namespace string `json:"namespace"`

        // Path is an optional URL path
        // +optional
        Path string `json:"path,omitempty"`

        // Port is a valid port number
        Port *int32 `json:"port,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ClusterInterceptorList contains a list of ClusterInterceptor
// We don't use this but it's required for certain codegen features.
type ClusterInterceptorList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ClusterInterceptor `json:"items"`
}

var ErrNilURL = errors.New("interceptor URL was nil")

// ResolveAddress returns the URL where the interceptor is running using its clientConfig
func (it *ClusterInterceptor) ResolveAddress() (*apis.URL, error) <span class="cov8" title="1">{
        if url := it.Spec.ClientConfig.URL; url != nil </span><span class="cov8" title="1">{
                return url, nil
        }</span>
        <span class="cov8" title="1">svc := it.Spec.ClientConfig.Service
        if svc == nil </span><span class="cov8" title="1">{
                return nil, ErrNilURL
        }</span>
        <span class="cov8" title="1">var (
                port *int32
                url  *apis.URL
        )

        if svc.Port != nil </span><span class="cov8" title="1">{
                port = svc.Port
        }</span>

        <span class="cov8" title="1">if bytes.Equal(it.Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov8" title="1">{
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPPort
                }</span>
                <span class="cov8" title="1">url = formURL("http", svc, port)</span>
        } else<span class="cov8" title="1"> {
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPSPort
                }</span>
                <span class="cov8" title="1">url = formURL("https", svc, port)</span>
        }
        <span class="cov8" title="1">return url, nil</span>
}

func formURL(scheme string, svc *ServiceReference, port *int32) *apis.URL <span class="cov8" title="1">{
        return &amp;apis.URL{
                Scheme: scheme,
                Host:   fmt.Sprintf("%s.%s.svc:%d", svc.Name, svc.Namespace, *port),
                Path:   svc.Path,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/apis"
)

// Validate ClusterInterceptor
func (it *ClusterInterceptor) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return it.Spec.validate(ctx)</span>
}

// revive:disable:unused-parameter

func (s *ClusterInterceptorSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.ClientConfig.URL != nil &amp;&amp; s.ClientConfig.Service != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("spec.clientConfig.url", "spec.clientConfig.service"))
        }</span>
        <span class="cov8" title="1">if svc := s.ClientConfig.Service; svc != nil </span><span class="cov8" title="1">{
                if svc.Namespace == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.namespace"))
                }</span>
                <span class="cov8" title="1">if svc.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.name"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes ClusterTriggerBinding ctb with its default values.
func (ctb *ClusterTriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that ClusterTriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*ClusterTriggerBinding)(nil)
var _ apis.Defaultable = (*ClusterTriggerBinding)(nil)

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// ClusterTriggerBinding is a TriggerBinding with a cluster scope.
// ClusterTriggerBindings are used to represent TriggerBindings that
// should be publicly addressable from any namespace in the cluster.
type ClusterTriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the desired state of the ClusterTriggerBinding from the client
        // +optional
        Spec TriggerBindingSpec `json:"spec,omitempty"`

        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ClusterTriggerBindingList contains a list of ClusterTriggerBinding
type ClusterTriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ClusterTriggerBinding `json:"items"`
}

func (ctb *ClusterTriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return ctb.Spec
}</span>

func (ctb *ClusterTriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return ctb.ObjectMeta
}</span>

func (ctb *ClusterTriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return ctb.DeepCopy()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "knative.dev/pkg/apis"
)

func (ctb *ClusterTriggerBinding) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := validate.ObjectMetadata(ctb.GetObjectMeta()); err != nil </span><span class="cov0" title="0">{
                return err.ViaField("metadata")
        }</span>
        <span class="cov8" title="1">return ctb.Spec.Validate(ctx)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "knative.dev/pkg/logging"
)

// SetDefaults sets the defaults on the object.
func (el *EventListener) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                defaultSA := cfg.Defaults.DefaultServiceAccount
                if el.Spec.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                        el.Spec.ServiceAccountName = defaultSA
                }</span>
                // set defaults
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                        if el.Spec.Resources.KubernetesResource.Replicas != nil &amp;&amp; *el.Spec.Resources.KubernetesResource.Replicas == 0 </span><span class="cov8" title="1">{
                                *el.Spec.Resources.KubernetesResource.Replicas = 1
                        }</span>
                }

                <span class="cov8" title="1">for i, t := range el.Spec.Triggers </span><span class="cov8" title="1">{
                        triggerSpecBindingArray(el.Spec.Triggers[i].Bindings).defaultBindings()
                        for _, ti := range t.Interceptors </span><span class="cov8" title="1">{
                                if ti != nil </span><span class="cov8" title="1">{
                                        ti.defaultInterceptorKind()
                                        if err := ti.updateCoreInterceptors(); err != nil </span><span class="cov0" title="0">{
                                                // The err only happens due to malformed JSON and should never really happen
                                                // We can't return an error here, so print out the error
                                                logger := logging.FromContext(ctx)
                                                logger.Errorf("failed to setDefaults for trigger: %s; err: %s", t.Name, err)
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        duckv1alpha1 "knative.dev/pkg/apis/duck/v1alpha1"
        "knative.dev/pkg/apis/duck/v1beta1"
        "knative.dev/pkg/kmeta"
)

// Check that EventListener may be validated and defaulted.
var _ apis.Validatable = (*EventListener)(nil)
var _ apis.Defaultable = (*EventListener)(nil)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// EventListener exposes a service to accept HTTP event payloads.
//
// +k8s:openapi-gen=true
type EventListener struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the EventListener from the client
        // +optional
        Spec EventListenerSpec `json:"spec"`
        // +optional
        Status EventListenerStatus `json:"status,omitempty"`
}

var _ kmeta.OwnerRefable = (*EventListener)(nil)

// EventListenerSpec defines the desired state of the EventListener, represented
// by a list of Triggers.
type EventListenerSpec struct {
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
        // +listType=atomic
        Triggers          []EventListenerTrigger `json:"triggers"`
        NamespaceSelector NamespaceSelector      `json:"namespaceSelector,omitempty"`
        LabelSelector     *metav1.LabelSelector  `json:"labelSelector,omitempty"`
        Resources         Resources              `json:"resources,omitempty"`
}

type Resources struct {
        KubernetesResource *KubernetesResource `json:"kubernetesResource,omitempty"`
        CustomResource     *CustomResource     `json:"customResource,omitempty"`
}

type CustomResource struct {
        runtime.RawExtension `json:",inline"`
}

type KubernetesResource struct {
        Replicas           *int32             `json:"replicas,omitempty"`
        ServiceType        corev1.ServiceType `json:"serviceType,omitempty"`
        duckv1.WithPodSpec `json:"spec,omitempty"`
}

// EventListenerTrigger represents a connection between TriggerBinding, Params,
// and TriggerTemplate; TriggerBinding provides extracted values for
// TriggerTemplate to then create resources from. TriggerRef can also be
// provided instead of TriggerBinding, Interceptors and TriggerTemplate
type EventListenerTrigger struct {
        // +listType=atomic
        Bindings   []*EventListenerBinding `json:"bindings,omitempty"`
        Template   *EventListenerTemplate  `json:"template,omitempty"`
        TriggerRef string                  `json:"triggerRef,omitempty"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*EventInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // more granular authorization for
        // who is allowed to utilize the associated pipeline
        // vs. defaulting to whatever permissions are associated
        // with the entire EventListener and associated sink facilitates
        // multi-tenant model based scenarios
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

// EventInterceptor provides a hook to intercept and pre-process events
type EventInterceptor = TriggerInterceptor

// SecretRef contains the information required to reference a single secret string
// This is needed because the other secretRef types are not cross-namespace and do not
// actually contain the "SecretName" field, which allows us to access a single secret value.
type SecretRef struct {
        SecretKey  string `json:"secretKey,omitempty"`
        SecretName string `json:"secretName,omitempty"`
}

// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBindingresource.
type EventListenerBinding = TriggerSpecBinding

// EventListenerTemplate refers to a particular TriggerTemplate resource.
type EventListenerTemplate = TriggerSpecTemplate

// EventListenerList contains a list of TriggerBinding
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type EventListenerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []EventListener `json:"items"`
}

// EventListenerStatus holds the status of the EventListener
// +k8s:deepcopy-gen=true
type EventListenerStatus struct {
        duckv1.Status `json:",inline"`

        // EventListener is Addressable. It currently exposes the service DNS
        // address of the EventListener sink
        duckv1alpha1.AddressStatus `json:",inline"`

        // Configuration stores configuration for the EventListener service
        Configuration EventListenerConfig `json:"configuration"`
}

// EventListenerConfig stores configuration for resources generated by the
// EventListener
type EventListenerConfig struct {
        // GeneratedResourceName is the name given to all resources reconciled by
        // the EventListener
        GeneratedResourceName string `json:"generatedName"`
}

// NamespaceSelector is a selector for selecting either all namespaces or a
// list of namespaces.
// +k8s:openapi-gen=true
type NamespaceSelector struct {
        // List of namespace names.
        // +listType=atomic
        MatchNames []string `json:"matchNames,omitempty"`
}

// The conditions that are internally resolved by the EventListener reconciler
const (
        // ServiceExists is the ConditionType set on the EventListener, which
        // specifies Service existence.
        ServiceExists apis.ConditionType = "Service"
        // DeploymentExists is the ConditionType set on the EventListener, which
        // specifies Deployment existence.
        DeploymentExists apis.ConditionType = "Deployment"
)

// Check that EventListener may be validated and defaulted.
// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.
type TriggerBindingKind string

const (
        // NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.
        NamespacedTriggerBindingKind TriggerBindingKind = "TriggerBinding"
        // ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.
        ClusterTriggerBindingKind TriggerBindingKind = "ClusterTriggerBinding"
)

var eventListenerCondSet = apis.NewLivingConditionSet(
        ServiceExists,
        DeploymentExists,
)

// GetGroupVersionKind implements kmeta.OwnerRefable
func (el *EventListener) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("EventListener")
}</span>

// GetCondition returns the Condition matching the given type.
func (els *EventListenerStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return eventListenerCondSet.Manage(els).GetCondition(t)
}</span>

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary. This is a local change and needs to be persisted to the
// K8s API elsewhere.
func (els *EventListenerStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                // TODO: Should the ConditionManager be set somewhere?
                eventListenerCondSet.Manage(els).SetCondition(*newCond)
        }</span>
}

func (els *EventListenerStatus) SetReadyCondition() <span class="cov8" title="1">{
        for _, ct := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionType(appsv1.DeploymentProgressing),
                apis.ConditionType(appsv1.DeploymentAvailable)} </span><span class="cov8" title="1">{
                if sc := els.GetCondition(ct); sc != nil </span><span class="cov8" title="1">{
                        if sc.Status != corev1.ConditionTrue </span><span class="cov8" title="1">{
                                els.SetCondition(&amp;apis.Condition{
                                        Type:    apis.ConditionReady,
                                        Status:  corev1.ConditionFalse,
                                        Message: fmt.Sprintf("Condition %s has status: %s with message: %s", sc.Type, sc.Status, sc.Message),
                                })
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetDeploymentConditions sets the Deployment conditions on the EventListener,
// which is a reflection of the actual Deployment status.
func (els *EventListenerStatus) SetDeploymentConditions(deploymentConditions []appsv1.DeploymentCondition) <span class="cov8" title="1">{
        // Manually remove the DeploymentReplicaFailure condition since it does
        // not always exist and would stay around otherwise
        replicaFailureIndex := -1
        for i := range els.Conditions </span><span class="cov8" title="1">{
                if els.Conditions[i].Type == apis.ConditionType(appsv1.DeploymentReplicaFailure) </span><span class="cov8" title="1">{
                        replicaFailureIndex = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if replicaFailureIndex != -1 </span><span class="cov8" title="1">{
                els.Conditions = append(els.Conditions[:replicaFailureIndex], els.Conditions[replicaFailureIndex+1:]...)
        }</span>
        <span class="cov8" title="1">for _, cond := range deploymentConditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionType(cond.Type),
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>
}

func (els *EventListenerStatus) SetConditionsForDynamicObjects(conditions v1beta1.Conditions) <span class="cov8" title="1">{
        for _, cond := range conditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond.Type,
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>

        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetExistsCondition simplifies setting the exists conditions on the
// EventListenerStatus.
func (els *EventListenerStatus) SetExistsCondition(cond apis.ConditionType, err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionFalse,
                        Message: err.Error(),
                })
        }</span> else<span class="cov8" title="1"> {
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionTrue,
                        Message: fmt.Sprintf("%s exists", cond),
                })
        }</span>
}

// InitializeConditions will set all conditions in eventListenerCondSet to false
// for the EventListener. This does not use the InitializeCondition() provided
// by the conditionsImpl to avoid setting the happy condition. This is a local
// change and needs to be persisted to the K8s API elsewhere.
func (els *EventListenerStatus) InitializeConditions() <span class="cov8" title="1">{
        for _, condition := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionReady,
        } </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:   condition,
                        Status: corev1.ConditionFalse,
                })
        }</span>
}

// SetAddress sets the address (as part of Addressable contract) and marks the correct condition.
func (els *EventListenerStatus) SetAddress(hostname string) <span class="cov0" title="0">{
        if els.Address == nil </span><span class="cov0" title="0">{
                els.Address = &amp;duckv1alpha1.Addressable{}
        }</span>
        <span class="cov0" title="0">if hostname != "" </span><span class="cov0" title="0">{
                els.Address.URL = &amp;apis.URL{
                        Scheme: "http",
                        Host:   hostname,
                }
        }</span> else<span class="cov0" title="0"> {
                els.Address.URL = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/triggers"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        reservedEnvVars = sets.NewString(
                "TLS_CERT",
                "TLS_KEY",
        )
)

var _ resourcesemantics.VerbLimited = (*EventListener)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (e *EventListener) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate EventListener.
func (e *EventListener) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var errs *apis.FieldError
        if len(e.ObjectMeta.Name) &gt; 60 </span><span class="cov8" title="1">{
                // Since `el-` is added as the prefix of EventListener services, the name of EventListener must be no more than 60 characters long.
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("eventListener name '%s' must be no more than 60 characters long", e.ObjectMeta.Name), "metadata.name"))
        }</span>

        <span class="cov8" title="1">if len(e.ObjectMeta.Annotations) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(triggers.ValidateAnnotations(e.ObjectMeta.Annotations))
        }</span>

        <span class="cov8" title="1">return errs.Also(e.Spec.validate(ctx))</span>
}

func (s *EventListenerSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.LabelSelector == nil &amp;&amp; len(s.NamespaceSelector.MatchNames) == 0 &amp;&amp; len(s.Triggers) == 0 </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf("spec.labelSelector", "spec.namespaceSelector", "spec.triggers")
        }</span>

        <span class="cov8" title="1">for i, trigger := range s.Triggers </span><span class="cov8" title="1">{
                errs = errs.Also(trigger.validate(ctx).ViaField(fmt.Sprintf("spec.triggers[%d]", i)))
        }</span>

        // Both Kubernetes and Custom resource can't be present at the same time
        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil &amp;&amp; s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf("spec.resources.kubernetesResource", "spec.resources.customResource")
        }</span>

        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateKubernetesObject(s.Resources.KubernetesResource).ViaField("spec.resources.kubernetesResource"))
        }</span>

        <span class="cov8" title="1">if s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateCustomObject(s.Resources.CustomResource).ViaField("spec.resources.customResource"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateCustomObject(customData *CustomResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        orig := duckv1.WithPod{}
        decoder := json.NewDecoder(bytes.NewBuffer(customData.RawExtension.Raw))

        if err := decoder.Decode(&amp;orig); err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(err, "spec"))
        }</span>

        <span class="cov8" title="1">if len(orig.Spec.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec,
                *podSpecMask(&amp;orig.Spec.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Spec.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec.Containers[0],
                        *containerFieldMaskForCustomResource(&amp;orig.Spec.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Spec.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateKubernetesObject(orig *KubernetesResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        if orig.Replicas != nil </span><span class="cov8" title="1">{
                if *orig.Replicas &lt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(*orig.Replicas, "spec.replicas"))
                }</span>
        }
        <span class="cov8" title="1">if len(orig.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec,
                *podSpecMask(&amp;orig.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec.Containers[0],
                        *containerFieldMaskForKubernetes(&amp;orig.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateEnv(envVars []corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        var (
                count    = 0
                envValue string
        )
        for i, env := range envVars </span><span class="cov8" title="1">{
                errs = errs.Also(validateEnvVar(env).ViaIndex(i))
                if reservedEnvVars.Has(env.Name) </span><span class="cov8" title="1">{
                        count++
                        envValue = env.Name
                }</span>
        }
        // This is to make sure both TLS_CERT and TLS_KEY is set for tls connection
        <span class="cov8" title="1">if count == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "Expected env's are TLS_CERT and TLS_KEY, but got only one env " + envValue,
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateEnvVar(env corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(apis.CheckDisallowedFields(env, *envVarMask(&amp;env)))

        return errs.Also(validateEnvValueFrom(env.ValueFrom).ViaField("valueFrom"))
}</span>

func validateEnvValueFrom(source *corev1.EnvVarSource) *apis.FieldError <span class="cov8" title="1">{
        if source == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apis.CheckDisallowedFields(*source, *envVarSourceMask(source))</span>
}

// envVarSourceMask performs a _shallow_ copy of the Kubernetes EnvVarSource object to a new
// Kubernetes EnvVarSource object bringing over only the fields allowed in the Triggers EventListener API.
func envVarSourceMask(in *corev1.EnvVarSource) *corev1.EnvVarSource <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVarSource)
        // Allowed fields
        out.SecretKeyRef = in.SecretKeyRef

        // Disallowed fields
        out.ConfigMapKeyRef = nil
        out.FieldRef = nil
        out.ResourceFieldRef = nil

        return out</span>
}

// envVarMask performs a _shallow_ copy of the Kubernetes EnvVar object to a new
// Kubernetes EnvVar object bringing over only the fields allowed in the Triggers EventListener API.
func envVarMask(in *corev1.EnvVar) *corev1.EnvVar <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVar)
        // Allowed fields
        out.Name = in.Name
        out.ValueFrom = in.ValueFrom

        // Disallowed fields
        out.Value = ""

        return out</span>
}

func containerFieldMaskForKubernetes(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        out.LivenessProbe = in.LivenessProbe
        out.ReadinessProbe = in.ReadinessProbe
        out.StartupProbe = in.StartupProbe
        return containerFieldMask(out)
}</span>

func containerFieldMaskForCustomResource(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        return containerFieldMask(out)
}</span>

func containerFieldMask(out *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        // Disallowed fields
        // This list clarifies which all container attributes are not allowed.
        out.Name = ""
        out.Image = ""
        out.Args = nil
        out.Ports = nil
        out.Command = nil
        out.VolumeMounts = nil
        out.ImagePullPolicy = ""
        out.Lifecycle = nil
        out.Stdin = false
        out.StdinOnce = false
        out.TerminationMessagePath = ""
        out.TerminationMessagePolicy = ""
        out.WorkingDir = ""
        out.TTY = false
        out.VolumeDevices = nil
        out.EnvFrom = nil

        return out
}</span>

// podSpecMask performs a _shallow_ copy of the Kubernetes PodSpec object to a new
// Kubernetes PodSpec object bringing over only the fields allowed in the Triggers EvenListener.
func podSpecMask(in *corev1.PodSpec) *corev1.PodSpec <span class="cov8" title="1">{
        out := new(corev1.PodSpec)

        // Allowed fields
        out.ServiceAccountName = in.ServiceAccountName
        out.Containers = in.Containers
        out.Tolerations = in.Tolerations
        out.NodeSelector = in.NodeSelector

        // Disallowed fields
        // This list clarifies which all podspec fields are not allowed.
        out.Volumes = nil
        out.EnableServiceLinks = nil
        out.ImagePullSecrets = nil
        out.InitContainers = nil
        out.RestartPolicy = ""
        out.TerminationGracePeriodSeconds = nil
        out.ActiveDeadlineSeconds = nil
        out.DNSPolicy = ""
        out.AutomountServiceAccountToken = nil
        out.NodeName = ""
        out.HostNetwork = false
        out.HostPID = false
        out.HostIPC = false
        out.ShareProcessNamespace = nil
        out.SecurityContext = nil
        out.Hostname = ""
        out.Subdomain = ""
        out.SchedulerName = ""
        out.HostAliases = nil
        out.PriorityClassName = ""
        out.Priority = nil
        out.DNSConfig = nil
        out.ReadinessGates = nil
        out.RuntimeClassName = nil
        out.Affinity = nil
        out.TopologySpreadConstraints = nil

        return out
}</span>

func (t *EventListenerTrigger) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if t.Template == nil &amp;&amp; t.TriggerRef == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("template", "triggerRef"))
        }</span>

        <span class="cov8" title="1">if t.TriggerRef != "" &amp;&amp; (t.Template != nil || t.Bindings != nil || t.Interceptors != nil) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("triggerRef", "template or bindings or interceptors"))
        }</span>

        // Validate optional Bindings
        <span class="cov8" title="1">errs = errs.Also(triggerSpecBindingArray(t.Bindings).validate(ctx))
        if t.Template != nil </span><span class="cov8" title="1">{
                // Validate required TriggerTemplate
                errs = errs.Also(t.Template.validate(ctx))
        }</span>

        // Validate optional Interceptors
        <span class="cov8" title="1">for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                // No continuation if provided interceptor is nil.
                if interceptor == nil </span><span class="cov8" title="1">{
                        return errs.Also(apis.ErrInvalidValue(fmt.Sprintf("interceptor '%v' must be a valid value", interceptor), fmt.Sprintf("interceptors[%d]", i)))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))</span>
        }

        // The trigger name is added as a label value for 'tekton.dev/trigger' so it must follow the k8s label guidelines:
        // https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
        <span class="cov8" title="1">if err := validation.IsValidLabelValue(t.Name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("trigger name '%s' must be a valid label value", t.Name), "name"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

// SetDefaults sets the defaults on the object.
func (it *Interceptor) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, ok := it.GetLabels()["server/type"]; !ok </span><span class="cov0" title="0">{
                // if server type is not set its assumed that running server is http
                it.Labels = map[string]string{
                        "server/type": "http",
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package v1alpha1

import (
        "bytes"
        "context"
        "fmt"
        "strings"

        "google.golang.org/grpc/codes"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// Check that Interceptor may be validated and defaulted.
var _ apis.Validatable = (*Interceptor)(nil)
var _ apis.Defaultable = (*Interceptor)(nil)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
// Interceptor describes a pluggable interceptor including configuration
// such as the fields it accepts and its deployment address. The type is based on
// the Validating/MutatingWebhookConfiguration types for configuring AdmissionWebhooks
type Interceptor struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec InterceptorSpec `json:"spec"`
        // +optional
        Status InterceptorStatus `json:"status"`
}

// InterceptorSpec describes the Spec for an Interceptor
type InterceptorSpec struct {
        ClientConfig ClientConfig `json:"clientConfig"`
}

// InterceptorStatus holds the status of the Interceptor
// +k8s:deepcopy-gen=true
type InterceptorStatus struct {
        duckv1.Status `json:",inline"`

        // Interceptor is Addressable and exposes the URL where the Interceptor is running
        duckv1.AddressStatus `json:",inline"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// InterceptorList contains a list of Interceptor
// We don't use this but it's required for certain codegen features.
type InterceptorList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Interceptor `json:"items"`
}

// ResolveAddress returns the URL where the interceptor is running using its clientConfig
func (it *Interceptor) ResolveAddress() (*apis.URL, error) <span class="cov8" title="1">{
        if url := it.Spec.ClientConfig.URL; url != nil </span><span class="cov8" title="1">{
                return url, nil
        }</span>
        <span class="cov8" title="1">svc := it.Spec.ClientConfig.Service
        if svc == nil </span><span class="cov8" title="1">{
                return nil, ErrNilURL
        }</span>
        <span class="cov8" title="1">var (
                port *int32
                url  *apis.URL
        )

        if svc.Port != nil </span><span class="cov8" title="1">{
                port = svc.Port
        }</span>

        <span class="cov8" title="1">if bytes.Equal(it.Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov8" title="1">{
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPPort
                }</span>
                <span class="cov8" title="1">url = formURL("http", svc, port)</span>
        } else<span class="cov8" title="1"> {
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPSPort
                }</span>
                <span class="cov8" title="1">url = formURL("https", svc, port)</span>
        }
        <span class="cov8" title="1">return url, nil</span>
}

type InterceptorInterface interface {
        // Process executes the given InterceptorRequest. Simply getting a non-nil InterceptorResponse back is not sufficient
        // to determine if the interceptor processing was successful. Instead use the InterceptorResponse.Status.Continue to
        // see if processing should continue and InterceptorResponse.Status.Code to distinguish between the kinds of errors
        // (i.e user errors vs system errors)
        Process(ctx context.Context, r *InterceptorRequest) *InterceptorResponse
}

// Do not generate DeepCopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorRequest struct {
        // Body is the incoming HTTP event body. We use a "string" representation of the JSON body
        // in order to preserve the body exactly as it was sent (including spaces etc.). This is necessary
        // for some interceptors e.g. GitHub for validating the body with a signature. While []byte can also
        // store an exact representation of the body, `json.Marshal` will compact []byte to a base64 encoded
        // string which means that we will lose the spaces any time we marshal this struct.
        Body string `json:"body,omitempty"`

        // Header are the headers for the incoming HTTP event
        Header map[string][]string `json:"header,omitempty"`

        // Extensions are extra values that are added by previous interceptors in a chain
        Extensions map[string]interface{} `json:"extensions,omitempty"`

        // InterceptorParams are the user specified params for interceptor in the Trigger
        InterceptorParams map[string]interface{} `json:"interceptor_params,omitempty"`

        // Context contains additional metadata about the event being processed
        Context *TriggerContext `json:"context"`
}

type TriggerContext struct {
        // EventURL is the URL of the incoming event
        EventURL string `json:"event_url,omitempty"`
        // EventID is a unique ID assigned by Triggers to each event
        EventID string `json:"event_id,omitempty"`
        // TriggerID is of the form namespace/$ns/triggers/$name
        TriggerID string `json:"trigger_id,omitempty"`
}

// Do not generate Deepcopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorResponse struct {
        // Extensions are additional fields that is added to the interceptor event.
        Extensions map[string]interface{} `json:"extensions,omitempty"`
        // Continue indicates if the EventListener should continue processing the Trigger or not
        Continue bool `json:"continue"` // Don't add omitempty -- it  will remove the continue field when the value is false.
        // Status is an Error status containing details on any interceptor processing errors
        Status Status `json:"status"`
}

type Status struct {
        // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
        Code codes.Code `json:"code,omitempty"`
        // A developer-facing error message, which should be in English.
        Message string `json:"message,omitempty"`
}

func (s Status) Err() StatusError <span class="cov0" title="0">{
        return StatusError{s: s}
}</span>

type StatusError struct {
        s Status
}

func (s StatusError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("rpc error: code = %s desc = %s", s.s.Code, s.s.Message)
}</span>

func ParseTriggerID(triggerID string) (namespace, name string) <span class="cov8" title="1">{
        splits := strings.Split(triggerID, "/")
        if len(splits) != 4 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return splits[1], splits[3]</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/apis"
)

// Validate Interceptor
func (it *Interceptor) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return it.Spec.validate(ctx)</span>
}

// revive:disable:unused-parameter

func (s *InterceptorSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.ClientConfig.URL != nil &amp;&amp; s.ClientConfig.Service != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("spec.clientConfig.url", "spec.clientConfig.service"))
        }</span>
        <span class="cov8" title="1">if svc := s.ClientConfig.Service; svc != nil </span><span class="cov8" title="1">{
                if svc.Namespace == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.namespace"))
                }</span>
                <span class="cov8" title="1">if svc.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.name"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: triggers.GroupName, Version: "v1alpha1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;ClusterInterceptor{},
                &amp;ClusterInterceptorList{},
                &amp;ClusterTriggerBinding{},
                &amp;ClusterTriggerBindingList{},
                &amp;EventListener{},
                &amp;EventListenerList{},
                &amp;Interceptor{},
                &amp;InterceptorList{},
                &amp;TriggerBinding{},
                &amp;TriggerBindingList{},
                &amp;TriggerTemplate{},
                &amp;TriggerTemplateList{},
                &amp;Trigger{},
                &amp;TriggerList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerBinding tb with its default values.
func (tb *TriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that TriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*TriggerBinding)(nil)
var _ apis.Defaultable = (*TriggerBinding)(nil)

func (tb *TriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return tb.Spec
}</span>

func (tb *TriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return tb.ObjectMeta
}</span>

func (tb *TriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return tb.DeepCopy()
}</span>

// TriggerBindingSpec defines the desired state of the TriggerBinding.
type TriggerBindingSpec struct {
        // Params defines the parameter mapping from the given input event.
        // +listType=atomic
        Params []Param `json:"params,omitempty"`
}

// TriggerBindingStatus defines the observed state of TriggerBinding.
type TriggerBindingStatus struct{}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBinding defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type TriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the TriggerBinding
        // +optional
        Spec TriggerBindingSpec `json:"spec"`
        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBindingList contains a list of TriggerBindings.
// We don't use this but it's required for certain codegen features.
type TriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TriggerBinding `json:"items"`
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

// Validate TriggerBinding.
func (tb *TriggerBinding) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">errs = validate.ObjectMetadata(tb.GetObjectMeta()).ViaField("metadata")
        return errs.Also(tb.Spec.Validate(ctx).ViaField("spec"))</span>
}

// revive:disable:unused-parameter

// Validate TriggerBindingSpec.
func (s *TriggerBindingSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerBindingSpec{}) </span><span class="cov8" title="1">{
                return errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">return errs.Also(validateParams(s.Params).ViaField("params"))</span>
}

func validateParams(params []Param) *apis.FieldError <span class="cov8" title="1">{
        // Ensure there aren't multiple params with the same name.
        seen := sets.NewString()
        for i, param := range params </span><span class="cov8" title="1">{
                if seen.Has(param.Name) </span><span class="cov8" title="1">{
                        return apis.ErrMultipleOneOf(fmt.Sprintf("[%d].name", i))
                }</span>
                <span class="cov8" title="1">seen.Insert(param.Name)
                errs := validateParamValue(param.Value).ViaField(fmt.Sprintf("[%d]", i))
                if errs != nil </span><span class="cov8" title="1">{
                        return errs
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateParamValue(in string) *apis.FieldError <span class="cov8" title="1">{
        if !strings.Contains(in, "$(") </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Splits string on $( to find potential Tekton expressions
        <span class="cov8" title="1">maybeExpressions := strings.Split(in, "$(")
        terminated := true
        for _, e := range maybeExpressions[1:] </span><span class="cov8" title="1">{ // Split always returns at least one element
                // Iterate until we find the first unbalanced )
                numOpenBrackets := 0
                if !terminated </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(in, "value")
                }</span>
                <span class="cov8" title="1">terminated = false
                for _, ch := range e </span><span class="cov8" title="1">{
                        switch ch </span>{
                        case '(':<span class="cov8" title="1">
                                numOpenBrackets++</span>
                        case ')':<span class="cov8" title="1">
                                numOpenBrackets--
                                if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                        terminated = true
                                }</span>
                        default:<span class="cov8" title="1">
                                continue</span>
                        }
                        <span class="cov8" title="1">if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                terminated = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "knative.dev/pkg/logging"
)

type triggerSpecBindingArray []*TriggerSpecBinding

// SetDefaults sets the defaults on the object.
func (t *Trigger) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">triggerSpecBindingArray(t.Spec.Bindings).defaultBindings()
        for _, ti := range t.Spec.Interceptors </span><span class="cov8" title="1">{
                ti.defaultInterceptorKind()
                if err := ti.updateCoreInterceptors(); err != nil </span><span class="cov0" title="0">{
                        // The err only happens due to malformed JSON and should never really happen
                        // We can't return an error here, so print out the error
                        logger := logging.FromContext(ctx)
                        logger.Errorf("failed to setDefaults for trigger: %s; err: %s", t.Name, err)
                }</span>
        }
}

// set default TriggerBinding kind for Bindings in TriggerSpec
func (t triggerSpecBindingArray) defaultBindings() <span class="cov8" title="1">{
        if len(t) &gt; 0 </span><span class="cov8" title="1">{
                for _, b := range t </span><span class="cov8" title="1">{
                        if b.Kind == "" </span><span class="cov8" title="1">{
                                b.Kind = NamespacedTriggerBindingKind
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerTemplate with default values.
func (tt *TriggerTemplate) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "regexp"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

// paramsRegexp captures TriggerTemplate parameter names $(tt.params.NAME)
var paramsRegexp = regexp.MustCompile(`\$\(tt.params.(?P&lt;var&gt;[_a-zA-Z][_a-zA-Z0-9.-]*)\)`)

// revive:disable:unused-parameter

// Validate validates a TriggerTemplate.
func (t *TriggerTemplate) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))</span>
}

// Validate validates a TriggerTemplateSpec.
func (s *TriggerTemplateSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerTemplateSpec{}) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">if len(s.ResourceTemplates) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("resourcetemplates"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateResourceTemplates(s.ResourceTemplates).ViaField("resourcetemplates"))
        errs = errs.Also(verifyParamDeclarations(s.Params, s.ResourceTemplates).ViaField("resourcetemplates"))
        return errs</span>
}

func validateResourceTemplates(templates []TriggerResourceTemplate) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, trt := range templates </span><span class="cov8" title="1">{
                data := new(unstructured.Unstructured)
                if err := data.UnmarshalJSON(trt.Raw); err != nil </span><span class="cov8" title="1">{
                        // a missing kind makes the unmarshalling throw an error
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].kind", i)))
                }</span>

                <span class="cov8" title="1">if data.GetAPIVersion() == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].apiVersion", i)))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Verify every param in the ResourceTemplates is declared with a ParamSpec
func verifyParamDeclarations(params []ParamSpec, templates []TriggerResourceTemplate) *apis.FieldError <span class="cov8" title="1">{
        declaredParamNames := sets.NewString()
        for _, param := range params </span><span class="cov8" title="1">{
                declaredParamNames.Insert(param.Name)
        }</span>
        <span class="cov8" title="1">for i, template := range templates </span><span class="cov8" title="1">{
                // Get all params in the template $(tt.params.NAME)
                templateParams := paramsRegexp.FindAllSubmatch(template.RawExtension.Raw, -1)
                for _, templateParam := range templateParams </span><span class="cov8" title="1">{
                        templateParamName := string(templateParam[1])
                        if !declaredParamNames.Has(templateParamName) </span><span class="cov8" title="1">{
                                fieldErr := apis.ErrInvalidValue(
                                        fmt.Sprintf("undeclared param '$(tt.params.%s)'", templateParamName),
                                        fmt.Sprintf("[%d]", i),
                                )
                                fieldErr.Details = fmt.Sprintf("'$(tt.params.%s)' must be declared in spec.params", templateParamName)
                                return fieldErr
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "encoding/json"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// TriggerSpec represents a connection between TriggerSpecBinding,
// and TriggerSpecTemplate; TriggerSpecBinding provides extracted values for
// TriggerSpecTemplate to then create resources from.
type TriggerSpec struct {
        // +listType=atomic
        Bindings []*TriggerSpecBinding `json:"bindings"`
        Template TriggerSpecTemplate   `json:"template"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*TriggerInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // Unlike EventListeners, this should be scoped to the same namespace
        // as the Trigger itself
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

type TriggerSpecTemplate struct {
        Ref        *string              `json:"ref,omitempty"`
        APIVersion string               `json:"apiversion,omitempty"`
        Spec       *TriggerTemplateSpec `json:"spec,omitempty"`
}

type TriggerSpecBinding struct {
        // Name is the name of the binding param
        // Mutually exclusive with Ref
        Name string `json:"name,omitempty"`
        // Value is the value of the binding param. Can contain JSONPath
        // Has to be pointer since "" is a valid value
        // Required if Name is also specified.
        Value *string `json:"value,omitempty"`

        // Ref is a reference to a TriggerBinding kind.
        // Mutually exclusive with Name
        Ref string `json:"ref,omitempty"`

        // Kind can only be provided if Ref is also provided. Defaults to TriggerBinding
        Kind TriggerBindingKind `json:"kind,omitempty"`

        // APIVersion of the binding ref
        APIVersion string `json:"apiversion,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Trigger defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type Trigger struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the Trigger
        // +optional
        Spec TriggerSpec `json:"spec"`
}

// TriggerInterceptor provides a hook to intercept and pre-process events
type TriggerInterceptor struct {
        // Optional name to identify the current interceptor configuration
        Name *string `json:"name,omitempty"`
        // Ref refers to the Interceptor to use
        Ref InterceptorRef `json:"ref"`
        // Params are the params to send to the interceptor
        // +listType=atomic
        Params []InterceptorParams `json:"params,omitempty"`

        // WebhookInterceptor refers to an old style webhook interceptor service
        Webhook *WebhookInterceptor `json:"webhook,omitempty"`

        // Deprecated old fields below
        DeprecatedGitHub    *GitHubInterceptor    `json:"github,omitempty"`
        DeprecatedGitLab    *GitLabInterceptor    `json:"gitlab,omitempty"`
        DeprecatedCEL       *CELInterceptor       `json:"cel,omitempty"`
        DeprecatedBitbucket *BitbucketInterceptor `json:"bitbucket,omitempty"`
}

// InterceptorParams defines a key-value pair that can be passed on an interceptor
type InterceptorParams struct {
        Name  string               `json:"name"`
        Value apiextensionsv1.JSON `json:"value"`
}

// InterceptorRef provides a Reference to a ClusterInterceptor
type InterceptorRef struct {
        // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        Name string `json:"name,omitempty"`
        // InterceptorKind indicates the kind of the Interceptor, namespaced or cluster scoped.
        // +optional
        Kind InterceptorKind `json:"kind,omitempty"`
        // API version of the referent
        // +optional
        APIVersion string `json:"apiVersion,omitempty"`
}

// InterceptorKind defines the type of Interceptor used by the Trigger.
type InterceptorKind string

const (
        // ClusterInterceptorKind indicates that Interceptor type has a cluster scope.
        ClusterInterceptorKind InterceptorKind = "ClusterInterceptor"
        // NamespacedInterceptorKind indicated that interceptor has a namespaced scope
        NamespacedInterceptorKind InterceptorKind = "NamespacedInterceptor"
)

func (ti *TriggerInterceptor) defaultInterceptorKind() <span class="cov8" title="1">{
        if ti.Ref.Kind == "" </span><span class="cov8" title="1">{
                ti.Ref.Kind = ClusterInterceptorKind
        }</span>
}

func (ti *TriggerInterceptor) updateCoreInterceptors() error <span class="cov8" title="1">{
        if ti == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if ti.Ref.Name != "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ti.Ref.Name = ti.GetName()
        ti.Params = []InterceptorParams{}
        switch ti.Ref.Name </span>{
        case "bitbucket":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "secretRef", ti.DeprecatedBitbucket.SecretRef); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "eventTypes", ti.DeprecatedBitbucket.EventTypes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedBitbucket = nil</span>
        case "gitlab":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "secretRef", ti.DeprecatedGitLab.SecretRef); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "eventTypes", ti.DeprecatedGitLab.EventTypes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedGitLab = nil</span>
        case "github":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "secretRef", ti.DeprecatedGitHub.SecretRef); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "eventTypes", ti.DeprecatedGitHub.EventTypes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedGitHub = nil</span>
        case "cel":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "filter", ti.DeprecatedCEL.Filter); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "overlays", ti.DeprecatedCEL.Overlays); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedCEL = nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func addToParams(params *[]InterceptorParams, name string, val interface{}) error <span class="cov8" title="1">{
        if val == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">v, err := toV1JSON(val)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*params = append(*params, InterceptorParams{
                Name:  name,
                Value: v,
        })
        return nil</span>
}

func toV1JSON(v interface{}) (apiextensionsv1.JSON, error) <span class="cov8" title="1">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return apiextensionsv1.JSON{}, fmt.Errorf("json.Marshal() failed: %w", err)
        }</span>
        <span class="cov8" title="1">return apiextensionsv1.JSON{
                Raw: b,
        }, nil</span>
}

// GetName returns the name for the given interceptor
func (ti *TriggerInterceptor) GetName() string <span class="cov8" title="1">{
        // This is temporary until we implement #869
        name := ""
        switch </span>{
        case ti.Ref.Name != "":<span class="cov8" title="1">
                name = ti.Ref.Name</span>
        case ti.DeprecatedBitbucket != nil:<span class="cov8" title="1">
                name = "bitbucket"</span>
        case ti.DeprecatedCEL != nil:<span class="cov8" title="1">
                name = "cel"</span>
        case ti.DeprecatedGitHub != nil:<span class="cov8" title="1">
                name = "github"</span>
        case ti.DeprecatedGitLab != nil:<span class="cov8" title="1">
                name = "gitlab"</span>
        }
        <span class="cov8" title="1">return name</span>
}

// WebhookInterceptor provides a webhook to intercept and pre-process events
type WebhookInterceptor struct {
        // ObjectRef is a reference to an object that will resolve to a cluster DNS
        // name to use as the EventInterceptor. Either objectRef or url can be specified
        // +optional
        ObjectRef *corev1.ObjectReference `json:"objectRef,omitempty"`
        // +optional
        URL *apis.URL `json:"url,omitempty"`
        // Header is a group of key-value pairs that can be appended to the
        // interceptor request headers. This allows the interceptor to make
        // decisions specific to an EventListenerTrigger.
        // +listType=atomic
        Header []v1beta1.Param `json:"header,omitempty"`
}

// BitbucketInterceptor provides a webhook to intercept and pre-process events
type BitbucketInterceptor struct {
        SecretRef *SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

// GitHubInterceptor provides a webhook to intercept and pre-process events
type GitHubInterceptor struct {
        SecretRef *SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

// GitLabInterceptor provides a webhook to intercept and pre-process events
type GitLabInterceptor struct {
        SecretRef *SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

// CELInterceptor provides a webhook to intercept and pre-process events
type CELInterceptor struct {
        Filter string `json:"filter,omitempty"`
        // +listType=atomic
        Overlays []CELOverlay `json:"overlays,omitempty"`
}

// CELOverlay provides a way to modify the request body using DeprecatedCEL expressions
type CELOverlay struct {
        Key        string `json:"key,omitempty"`
        Expression string `json:"expression,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerList contains a list of Triggers.
// We don't use this but it's required for certain codegen features.
type TriggerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Trigger `json:"items"`
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "encoding/json"
)

// ToEventListenerTrigger converts a TriggerSpec into an EventListenerTrigger.
// This is primarily for compatibility between CRD and non-CRD types so that
// underlying libraries can reuse existing code.
func ToEventListenerTrigger(in TriggerSpec) (EventListenerTrigger, error) <span class="cov8" title="1">{
        var out EventListenerTrigger

        // Use json Marshalling in order to be field agnostic. Since TriggerSpec
        // is a subset of the existing EventListenerTrigger type, and should always
        // contain the same field labels, this should be safe to do.
        b, err := json.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;out); err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/google/cel-go/cel"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "knative.dev/pkg/apis"
)

// Validate validates a Trigger
func (t *Trigger) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))</span>
}

func (t *TriggerSpec) validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // Validate optional Bindings
        errs := triggerSpecBindingArray(t.Bindings).validate(ctx)
        // Validate required TriggerTemplate
        errs = errs.Also(t.Template.validate(ctx))

        // Validate optional Interceptors
        for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// revive:disable:unused-parameter

func (t TriggerSpecTemplate) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Optional explicit match
        if t.APIVersion != "" </span><span class="cov8" title="1">{
                if t.APIVersion != "v1alpha1" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "template.apiVersion"))
                }</span>
        }

        <span class="cov8" title="1">switch </span>{
        case t.Spec != nil &amp;&amp; t.Ref != nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMultipleOneOf("template.spec", "template.ref"))</span>
        case t.Spec == nil &amp;&amp; t.Ref == nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingOneOf("template.spec", "template.ref"))</span>
        case t.Spec != nil:<span class="cov8" title="1">
                errs = errs.Also(t.Spec.validate(ctx))</span>
        case t.Ref == nil || *t.Ref == "":<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("template.ref"))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func (t triggerSpecBindingArray) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, b := range t </span><span class="cov8" title="1">{
                switch </span>{
                case b.Ref != "":<span class="cov8" title="1">
                        switch </span>{
                        case b.Name != "":<span class="cov8" title="1"> // Cannot specify both Ref and Name
                                errs = errs.Also(apis.ErrMultipleOneOf(fmt.Sprintf("bindings[%d].Ref", i), fmt.Sprintf("bindings[%d].Name", i)))</span>
                        case b.Kind != NamespacedTriggerBindingKind &amp;&amp; b.Kind != ClusterTriggerBindingKind:<span class="cov8" title="1"> // Kind must be valid
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), fmt.Sprintf("bindings[%d].kind", i)))</span>
                        }
                case b.Name != "":<span class="cov8" title="1">
                        if b.Value == nil </span><span class="cov8" title="1">{ // Value is mandatory if Name is specified
                                errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("bindings[%d].Value", i)))
                        }</span>
                default:<span class="cov8" title="1">
                        errs = errs.Also(apis.ErrMissingOneOf(fmt.Sprintf("bindings[%d].Ref", i), fmt.Sprintf("bindings[%d].Spec", i), fmt.Sprintf("bindings[%d].Name", i)))</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func (i *TriggerInterceptor) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if i.Webhook == nil &amp;&amp; i.DeprecatedGitHub == nil &amp;&amp; i.DeprecatedGitLab == nil &amp;&amp; i.DeprecatedCEL == nil &amp;&amp; i.DeprecatedBitbucket == nil </span><span class="cov8" title="1">{
                if i.Ref.Name == "" </span><span class="cov8" title="1">{ // Check to see if Interceptor referenced using Ref
                        errs = errs.Also(apis.ErrMissingField("interceptor"))
                }</span>
        }

        // Enforce oneof
        <span class="cov8" title="1">numSet := 0
        if i.Webhook != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>
        <span class="cov8" title="1">if i.DeprecatedGitHub != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>
        <span class="cov8" title="1">if i.DeprecatedGitLab != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>
        <span class="cov8" title="1">if i.DeprecatedBitbucket != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>

        <span class="cov8" title="1">if numSet &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("interceptor.webhook", "interceptor.github", "interceptor.gitlab"))
        }</span>

        <span class="cov8" title="1">if i.Webhook != nil </span><span class="cov8" title="1">{
                if i.Webhook.ObjectRef == nil || i.Webhook.ObjectRef.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef"))
                }</span>
                <span class="cov8" title="1">w := i.Webhook
                if w.ObjectRef.Kind != "Service" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), "interceptor.webhook.objectRef.kind"))
                }</span>

                // Optional explicit match
                <span class="cov8" title="1">if w.ObjectRef.APIVersion != "v1" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "interceptor.webhook.objectRef.apiVersion"))
                }</span>

                <span class="cov8" title="1">for i, header := range w.Header </span><span class="cov8" title="1">{
                        // Enforce non-empty canonical header keys
                        if len(header.Name) == 0 || http.CanonicalHeaderKey(header.Name) != header.Name </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header name"), fmt.Sprintf("interceptor.webhook.header[%d].name", i)))
                        }</span>
                        // Enforce non-empty header values
                        <span class="cov8" title="1">if header.Value.Type == pipelinev1.ParamTypeString </span><span class="cov8" title="1">{
                                if len(header.Value.StringVal) == 0 </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                                }</span>
                        } else<span class="cov0" title="0"> if len(header.Value.ArrayVal) == 0 </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                        }</span>
                }
        }

        <span class="cov8" title="1">if i.DeprecatedCEL != nil </span><span class="cov8" title="1">{
                if i.DeprecatedCEL.Filter == "" &amp;&amp; len(i.DeprecatedCEL.Overlays) == 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMultipleOneOf("cel.filter", "cel.overlays"))
                }</span>
                <span class="cov8" title="1">env, err := cel.NewEnv()
                if err != nil </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Errorf("failed to create a DeprecatedCEL env: %w", err), "cel.filter"))
                }</span>
                <span class="cov8" title="1">if i.DeprecatedCEL.Filter != "" </span><span class="cov8" title="1">{
                        if _, issues := env.Parse(i.DeprecatedCEL.Filter); issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Errorf("failed to parse the DeprecatedCEL filter: %w", issues.Err()), "cel.filter"))
                        }</span>
                }
                <span class="cov8" title="1">for _, v := range i.DeprecatedCEL.Overlays </span><span class="cov8" title="1">{
                        if _, issues := env.Parse(v.Expression); issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Errorf("failed to parse the DeprecatedCEL overlay: %w", issues.Err()), "cel.overlay"))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes ClusterTriggerBinding ctb with its default values.
func (ctb *ClusterTriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that ClusterTriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*ClusterTriggerBinding)(nil)
var _ apis.Defaultable = (*ClusterTriggerBinding)(nil)

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// ClusterTriggerBinding is a TriggerBinding with a cluster scope.
// ClusterTriggerBindings are used to represent TriggerBindings that
// should be publicly addressable from any namespace in the cluster.
type ClusterTriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the desired state of the ClusterTriggerBinding from the client
        // +optional
        Spec TriggerBindingSpec `json:"spec,omitempty"`

        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ClusterTriggerBindingList contains a list of ClusterTriggerBinding
type ClusterTriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ClusterTriggerBinding `json:"items"`
}

func (ctb *ClusterTriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return ctb.Spec
}</span>

func (ctb *ClusterTriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return ctb.ObjectMeta
}</span>

func (ctb *ClusterTriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return ctb.DeepCopy()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ resourcesemantics.VerbLimited = (*ClusterTriggerBinding)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (ctb *ClusterTriggerBinding) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

func (ctb *ClusterTriggerBinding) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if err := validate.ObjectMetadata(ctb.GetObjectMeta()); err != nil </span><span class="cov0" title="0">{
                return err.ViaField("metadata")
        }</span>
        <span class="cov8" title="1">return ctb.Spec.Validate(ctx)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

// SetDefaults sets the defaults on the object.
func (el *EventListener) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                defaultSA := cfg.Defaults.DefaultServiceAccount
                // set defaults
                if el.Spec.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                        el.Spec.ServiceAccountName = defaultSA
                }</span>

                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                        if el.Spec.Resources.KubernetesResource.Replicas != nil &amp;&amp; *el.Spec.Resources.KubernetesResource.Replicas == 0 </span><span class="cov8" title="1">{
                                *el.Spec.Resources.KubernetesResource.Replicas = 1
                        }</span>
                }

                <span class="cov8" title="1">for i, t := range el.Spec.Triggers </span><span class="cov8" title="1">{
                        triggerSpecBindingArray(el.Spec.Triggers[i].Bindings).defaultBindings()
                        for _, ti := range t.Interceptors </span><span class="cov8" title="1">{
                                if ti != nil </span><span class="cov8" title="1">{
                                        ti.defaultInterceptorKind()
                                }</span>
                        }
                }

                <span class="cov8" title="1">for _, tg := range el.Spec.TriggerGroups </span><span class="cov8" title="1">{
                        for _, ti := range tg.Interceptors </span><span class="cov8" title="1">{
                                if ti != nil </span><span class="cov8" title="1">{
                                        ti.defaultInterceptorKind()
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/apis/duck/v1beta1"
        "knative.dev/pkg/kmeta"
)

// Check that EventListener may be validated and defaulted.
var _ apis.Validatable = (*EventListener)(nil)
var _ apis.Defaultable = (*EventListener)(nil)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// EventListener exposes a service to accept HTTP event payloads.
//
// +k8s:openapi-gen=true
type EventListener struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the EventListener from the client
        // +optional
        Spec EventListenerSpec `json:"spec"`
        // +optional
        Status EventListenerStatus `json:"status,omitempty"`
}

var _ kmeta.OwnerRefable = (*EventListener)(nil)

// EventListenerSpec defines the desired state of the EventListener, represented
// by a list of Triggers.
type EventListenerSpec struct {
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
        // +listType=atomic
        Triggers []EventListenerTrigger `json:"triggers,omitempty"`
        // Trigger groups allow for centralized processing of an interceptor chain
        // +listType=atomic
        TriggerGroups     []EventListenerTriggerGroup `json:"triggerGroups,omitempty"`
        NamespaceSelector NamespaceSelector           `json:"namespaceSelector,omitempty"`
        LabelSelector     *metav1.LabelSelector       `json:"labelSelector,omitempty"`
        Resources         Resources                   `json:"resources,omitempty"`
        CloudEventURI     string                      `json:"cloudEventURI,omitempty"`
}

type Resources struct {
        KubernetesResource *KubernetesResource `json:"kubernetesResource,omitempty"`
        CustomResource     *CustomResource     `json:"customResource,omitempty"`
}

type CustomResource struct {
        runtime.RawExtension `json:",inline"`
}

type KubernetesResource struct {
        Replicas                 *int32             `json:"replicas,omitempty"`
        ServiceType              corev1.ServiceType `json:"serviceType,omitempty"`
        ServicePort              *int32             `json:"servicePort,omitempty"`
        ServiceLoadBalancerClass *string            `json:"serviceLoadBalancerClass,omitempty"`
        duckv1.WithPodSpec       `json:"spec,omitempty"`
}

// EventListenerTrigger represents a connection between TriggerBinding, Params,
// and TriggerTemplate; TriggerBinding provides extracted values for
// TriggerTemplate to then create resources from. TriggerRef can also be
// provided instead of TriggerBinding, Interceptors and TriggerTemplate
type EventListenerTrigger struct {
        // +listType=atomic
        Bindings   []*EventListenerBinding `json:"bindings,omitempty"`
        Template   *EventListenerTemplate  `json:"template,omitempty"`
        TriggerRef string                  `json:"triggerRef,omitempty"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*EventInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // more granular authorization for
        // who is allowed to utilize the associated pipeline
        // vs. defaulting to whatever permissions are associated
        // with the entire EventListener and associated sink facilitates
        // multi-tenant model based scenarios
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

// EventListenerTriggerGroup defines a group of Triggers that share a common set of interceptors
type EventListenerTriggerGroup struct {
        Name string `json:"name"`
        // +listType=atomic
        Interceptors    []*TriggerInterceptor        `json:"interceptors"`
        TriggerSelector EventListenerTriggerSelector `json:"triggerSelector"`
}

// EventListenerTriggerSelector  defines ways to select a group of triggers using their metadata
type EventListenerTriggerSelector struct {
        NamespaceSelector NamespaceSelector     `json:"namespaceSelector,omitempty"`
        LabelSelector     *metav1.LabelSelector `json:"labelSelector,omitempty"`
}

// EventInterceptor provides a hook to intercept and pre-process events
type EventInterceptor = TriggerInterceptor

// SecretRef contains the information required to reference a single secret string
// This is needed because the other secretRef types are not cross-namespace and do not
// actually contain the "SecretName" field, which allows us to access a single secret value.
type SecretRef struct {
        SecretKey  string `json:"secretKey,omitempty"`
        SecretName string `json:"secretName,omitempty"`
}

// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBinding resource.
type EventListenerBinding = TriggerSpecBinding

// EventListenerTemplate refers to a particular TriggerTemplate resource.
type EventListenerTemplate = TriggerSpecTemplate

// EventListenerList contains a list of TriggerBinding
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type EventListenerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []EventListener `json:"items"`
}

// EventListenerStatus holds the status of the EventListener
// +k8s:deepcopy-gen=true
type EventListenerStatus struct {
        duckv1.Status `json:",inline"`

        // EventListener is Addressable. It currently exposes the service DNS
        // address of the EventListener sink
        v1beta1.AddressStatus `json:",inline"`

        // Configuration stores configuration for the EventListener service
        Configuration EventListenerConfig `json:"configuration"`
}

// EventListenerConfig stores configuration for resources generated by the
// EventListener
type EventListenerConfig struct {
        // GeneratedResourceName is the name given to all resources reconciled by
        // the EventListener
        GeneratedResourceName string `json:"generatedName"`
}

// NamespaceSelector is a selector for selecting either all namespaces or a
// list of namespaces.
// +k8s:openapi-gen=true
type NamespaceSelector struct {
        // List of namespace names.
        // +listType=atomic
        MatchNames []string `json:"matchNames,omitempty"`
}

// The conditions that are internally resolved by the EventListener reconciler
const (
        // ServiceExists is the ConditionType set on the EventListener, which
        // specifies Service existence.
        ServiceExists apis.ConditionType = "Service"
        // DeploymentExists is the ConditionType set on the EventListener, which
        // specifies Deployment existence.
        DeploymentExists apis.ConditionType = "Deployment"
)

// Check that EventListener may be validated and defaulted.
// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.
type TriggerBindingKind string

const (
        // NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.
        NamespacedTriggerBindingKind TriggerBindingKind = "TriggerBinding"
        // ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.
        ClusterTriggerBindingKind TriggerBindingKind = "ClusterTriggerBinding"
)

var eventListenerCondSet = apis.NewLivingConditionSet(
        ServiceExists,
        DeploymentExists,
)

// GetGroupVersionKind implements kmeta.OwnerRefable
func (el *EventListener) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("EventListener")
}</span>

// GetCondition returns the Condition matching the given type.
func (els *EventListenerStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return eventListenerCondSet.Manage(els).GetCondition(t)
}</span>

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary. This is a local change and needs to be persisted to the
// K8s API elsewhere.
func (els *EventListenerStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                // TODO: Should the ConditionManager be set somewhere?
                eventListenerCondSet.Manage(els).SetCondition(*newCond)
        }</span>
}

func (els *EventListenerStatus) SetReadyCondition() <span class="cov8" title="1">{
        for _, ct := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionType(appsv1.DeploymentProgressing),
                apis.ConditionType(appsv1.DeploymentAvailable)} </span><span class="cov8" title="1">{
                if sc := els.GetCondition(ct); sc != nil </span><span class="cov8" title="1">{
                        if sc.Status != corev1.ConditionTrue </span><span class="cov8" title="1">{
                                els.SetCondition(&amp;apis.Condition{
                                        Type:    apis.ConditionReady,
                                        Status:  corev1.ConditionFalse,
                                        Message: fmt.Sprintf("Condition %s has status: %s with message: %s", sc.Type, sc.Status, sc.Message),
                                })
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetDeploymentConditions sets the Deployment conditions on the EventListener,
// which is a reflection of the actual Deployment status.
func (els *EventListenerStatus) SetDeploymentConditions(deploymentConditions []appsv1.DeploymentCondition) <span class="cov8" title="1">{
        // Manually remove the DeploymentReplicaFailure condition since it does
        // not always exist and would stay around otherwise
        replicaFailureIndex := -1
        for i := range els.Conditions </span><span class="cov8" title="1">{
                if els.Conditions[i].Type == apis.ConditionType(appsv1.DeploymentReplicaFailure) </span><span class="cov8" title="1">{
                        replicaFailureIndex = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if replicaFailureIndex != -1 </span><span class="cov8" title="1">{
                els.Conditions = append(els.Conditions[:replicaFailureIndex], els.Conditions[replicaFailureIndex+1:]...)
        }</span>
        <span class="cov8" title="1">for _, cond := range deploymentConditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionType(cond.Type),
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>
}

func (els *EventListenerStatus) SetConditionsForDynamicObjects(conditions v1beta1.Conditions) <span class="cov8" title="1">{
        for _, cond := range conditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond.Type,
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>

        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetExistsCondition simplifies setting the exists conditions on the
// EventListenerStatus.
func (els *EventListenerStatus) SetExistsCondition(cond apis.ConditionType, err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionFalse,
                        Message: err.Error(),
                })
        }</span> else<span class="cov8" title="1"> {
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionTrue,
                        Message: fmt.Sprintf("%s exists", cond),
                })
        }</span>
}

// InitializeConditions will set all conditions in eventListenerCondSet to false
// for the EventListener. This does not use the InitializeCondition() provided
// by the conditionsImpl to avoid setting the happy condition. This is a local
// change and needs to be persisted to the K8s API elsewhere.
func (els *EventListenerStatus) InitializeConditions() <span class="cov8" title="1">{
        for _, condition := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionReady,
        } </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:   condition,
                        Status: corev1.ConditionFalse,
                })
        }</span>
}

// SetAddress sets the address (as part of Addressable contract) and marks the correct condition.
func (els *EventListenerStatus) SetAddress(hostname string) <span class="cov0" title="0">{
        if els.Address == nil </span><span class="cov0" title="0">{
                els.Address = &amp;v1beta1.Addressable{}
        }</span>
        <span class="cov0" title="0">if hostname != "" </span><span class="cov0" title="0">{
                els.Address.URL = &amp;apis.URL{
                        Scheme: "http",
                        Host:   hostname,
                }
        }</span> else<span class="cov0" title="0"> {
                els.Address.URL = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/triggers"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        reservedEnvVars = sets.NewString(
                "TLS_CERT",
                "TLS_KEY",
        )
)

var _ resourcesemantics.VerbLimited = (*EventListener)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (e *EventListener) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// revive:disable:unused-parameter

// Validate EventListener.
func (e *EventListener) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        if len(e.ObjectMeta.Name) &gt; 60 </span><span class="cov8" title="1">{
                // Since `el-` is added as the prefix of EventListener services, the name of EventListener must be no more than 60 characters long.
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("eventListener name '%s' must be no more than 60 characters long", e.ObjectMeta.Name), "metadata.name"))
        }</span>

        <span class="cov8" title="1">if len(e.GetObjectMeta().GetAnnotations()) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(triggers.ValidateAnnotations(e.GetObjectMeta().GetAnnotations()))
        }</span>

        <span class="cov8" title="1">return errs.Also(e.Spec.validate(ctx))</span>
}

func (s *EventListenerSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.LabelSelector == nil &amp;&amp; len(s.NamespaceSelector.MatchNames) == 0 &amp;&amp; len(s.TriggerGroups) == 0 &amp;&amp; len(s.Triggers) == 0 </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf("spec.labelSelector", "spec.namespaceSelector", "spec.triggerGroups", "spec.triggers")
        }</span>

        <span class="cov8" title="1">for i, trigger := range s.Triggers </span><span class="cov8" title="1">{
                errs = errs.Also(trigger.validate(ctx).ViaField(fmt.Sprintf("spec.triggers[%d]", i)))
        }</span>

        // Both Kubernetes and Custom resource can't be present at the same time
        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil &amp;&amp; s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf("spec.resources.kubernetesResource", "spec.resources.customResource")
        }</span>

        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateKubernetesObject(s.Resources.KubernetesResource).ViaField("spec.resources.kubernetesResource"))
        }</span>

        <span class="cov8" title="1">if s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateCustomObject(s.Resources.CustomResource).ViaField("spec.resources.customResource"))
        }</span>

        <span class="cov8" title="1">if len(s.TriggerGroups) &gt; 0 </span><span class="cov8" title="1">{
                for i, group := range s.TriggerGroups </span><span class="cov8" title="1">{
                        errs = errs.Also(group.validate(ctx).ViaField(fmt.Sprintf("spec.triggerGroups[%d]", i)))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func (g *EventListenerTriggerGroup) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if g.TriggerSelector.LabelSelector == nil &amp;&amp; len(g.TriggerSelector.NamespaceSelector.MatchNames) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("triggerSelector.labelSelector", "triggerSelector.namespaceSelector"))
        }</span>
        <span class="cov8" title="1">if len(g.Interceptors) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("interceptors"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateCustomObject(customData *CustomResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        orig := duckv1.WithPod{}
        decoder := json.NewDecoder(bytes.NewBuffer(customData.RawExtension.Raw))

        if err := decoder.Decode(&amp;orig); err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(err, "spec"))
        }</span>

        <span class="cov8" title="1">if len(orig.Spec.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec,
                *podSpecMask(&amp;orig.Spec.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Spec.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec.Containers[0],
                        *containerFieldMaskForCustomResource(&amp;orig.Spec.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Spec.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateKubernetesObject(orig *KubernetesResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        if orig.Replicas != nil </span><span class="cov8" title="1">{
                if *orig.Replicas &lt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(*orig.Replicas, "spec.replicas"))
                }</span>
        }
        <span class="cov8" title="1">if len(orig.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec,
                *podSpecMask(&amp;orig.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec.Containers[0],
                        *containerFieldMaskForKubernetes(&amp;orig.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">if orig.ServiceLoadBalancerClass != nil &amp;&amp; orig.ServiceType != corev1.ServiceTypeLoadBalancer </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(*orig.ServiceLoadBalancerClass, "serviceLoadBalancerClass", "ServiceLoadBalancerClass is only needed for LoadBalancer service type"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateEnv(envVars []corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        var (
                count    = 0
                envValue string
        )
        for i, env := range envVars </span><span class="cov8" title="1">{
                errs = errs.Also(validateEnvVar(env).ViaIndex(i))
                if reservedEnvVars.Has(env.Name) </span><span class="cov8" title="1">{
                        count++
                        envValue = env.Name
                }</span>
        }
        // This is to make sure both TLS_CERT and TLS_KEY is set for tls connection
        <span class="cov8" title="1">if count == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "Expected env's are TLS_CERT and TLS_KEY, but got only one env " + envValue,
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateEnvVar(env corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(apis.CheckDisallowedFields(env, *envVarMask(&amp;env)))

        return errs.Also(validateEnvValueFrom(env.ValueFrom).ViaField("valueFrom"))
}</span>

func validateEnvValueFrom(source *corev1.EnvVarSource) *apis.FieldError <span class="cov8" title="1">{
        if source == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apis.CheckDisallowedFields(*source, *envVarSourceMask(source))</span>
}

// envVarSourceMask performs a _shallow_ copy of the Kubernetes EnvVarSource object to a new
// Kubernetes EnvVarSource object bringing over only the fields allowed in the Triggers EventListener API.
func envVarSourceMask(in *corev1.EnvVarSource) *corev1.EnvVarSource <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVarSource)
        // Allowed fields
        out.SecretKeyRef = in.SecretKeyRef

        // Disallowed fields
        out.ConfigMapKeyRef = nil
        out.FieldRef = nil
        out.ResourceFieldRef = nil

        return out</span>
}

// envVarMask performs a _shallow_ copy of the Kubernetes EnvVar object to a new
// Kubernetes EnvVar object bringing over only the fields allowed in the Triggers EventListener API.
func envVarMask(in *corev1.EnvVar) *corev1.EnvVar <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVar)
        // Allowed fields
        out.Name = in.Name
        out.ValueFrom = in.ValueFrom

        // Disallowed fields
        out.Value = ""

        return out</span>
}

func containerFieldMaskForKubernetes(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        out.LivenessProbe = in.LivenessProbe
        out.ReadinessProbe = in.ReadinessProbe
        out.StartupProbe = in.StartupProbe
        out.SecurityContext = in.SecurityContext
        return containerFieldMask(out)
}</span>

func containerFieldMaskForCustomResource(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        out.SecurityContext = in.SecurityContext
        return containerFieldMask(out)
}</span>

func containerFieldMask(out *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        // Disallowed fields
        // This list clarifies which all container attributes are not allowed.
        out.Name = ""
        out.Image = ""
        out.Args = nil
        out.Ports = nil
        out.Command = nil
        out.VolumeMounts = nil
        out.ImagePullPolicy = ""
        out.Lifecycle = nil
        out.Stdin = false
        out.StdinOnce = false
        out.TerminationMessagePath = ""
        out.TerminationMessagePolicy = ""
        out.WorkingDir = ""
        out.TTY = false
        out.VolumeDevices = nil
        out.EnvFrom = nil

        return out
}</span>

// podSpecMask performs a _shallow_ copy of the Kubernetes PodSpec object to a new
// Kubernetes PodSpec object bringing over only the fields allowed in the Triggers EvenListener.
func podSpecMask(in *corev1.PodSpec) *corev1.PodSpec <span class="cov8" title="1">{
        out := new(corev1.PodSpec)

        // Allowed fields
        out.ServiceAccountName = in.ServiceAccountName
        out.Containers = in.Containers
        out.Tolerations = in.Tolerations
        out.NodeSelector = in.NodeSelector
        out.Affinity = in.Affinity
        out.TopologySpreadConstraints = in.TopologySpreadConstraints
        out.ImagePullSecrets = in.ImagePullSecrets
        out.SecurityContext = in.SecurityContext

        // Disallowed fields
        // This list clarifies which all podspec fields are not allowed.
        out.Volumes = nil
        out.EnableServiceLinks = nil
        out.InitContainers = nil
        out.RestartPolicy = ""
        out.TerminationGracePeriodSeconds = nil
        out.ActiveDeadlineSeconds = nil
        out.DNSPolicy = ""
        out.AutomountServiceAccountToken = nil
        out.NodeName = ""
        out.HostNetwork = false
        out.HostPID = false
        out.HostIPC = false
        out.ShareProcessNamespace = nil
        out.Hostname = ""
        out.Subdomain = ""
        out.SchedulerName = ""
        out.HostAliases = nil
        out.PriorityClassName = ""
        out.Priority = nil
        out.DNSConfig = nil
        out.ReadinessGates = nil
        out.RuntimeClassName = nil

        return out
}</span>

func (t *EventListenerTrigger) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if t.Template == nil &amp;&amp; t.TriggerRef == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("template", "triggerRef"))
        }</span>

        <span class="cov8" title="1">if t.TriggerRef != "" &amp;&amp; (t.Template != nil || t.Bindings != nil || t.Interceptors != nil) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("triggerRef", "template or bindings or interceptors"))
        }</span>

        // Validate optional Bindings
        <span class="cov8" title="1">errs = errs.Also(triggerSpecBindingArray(t.Bindings).validate(ctx))
        if t.Template != nil </span><span class="cov8" title="1">{
                // Validate required TriggerTemplate
                errs = errs.Also(t.Template.validate(ctx))
        }</span>

        // Validate optional Interceptors
        <span class="cov8" title="1">for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                // No continuation if provided interceptor is nil.
                if interceptor == nil </span><span class="cov8" title="1">{
                        return errs.Also(apis.ErrInvalidValue(fmt.Sprintf("interceptor '%v' must be a valid value", interceptor), fmt.Sprintf("interceptors[%d]", i)))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))</span>
        }

        // The trigger name is added as a label value for 'tekton.dev/trigger' so it must follow the k8s label guidelines:
        // https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
        <span class="cov8" title="1">if err := validation.IsValidLabelValue(t.Name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("trigger name '%s' must be a valid label value", t.Name), "name"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "google.golang.org/grpc/codes"
)

type InterceptorInterface interface {
        // Process executes the given InterceptorRequest. Simply getting a non-nil InterceptorResponse back is not sufficient
        // to determine if the interceptor processing was successful. Instead use the InterceptorResponse.Status.Continue to
        // see if processing should continue and InterceptorResponse.Status.Code to distinguish between the kinds of errors
        // (i.e user errors vs system errors)
        Process(ctx context.Context, r *InterceptorRequest) *InterceptorResponse
}

// Do not generate DeepCopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorRequest struct {
        // Body is the incoming HTTP event body. We use a "string" representation of the JSON body
        // in order to preserve the body exactly as it was sent (including spaces etc.). This is necessary
        // for some interceptors e.g. GitHub for validating the body with a signature. While []byte can also
        // store an exact representation of the body, `json.Marshal` will compact []byte to a base64 encoded
        // string which means that we will lose the spaces any time we marshal this struct.
        Body string `json:"body,omitempty"`

        // Header are the headers for the incoming HTTP event
        Header map[string][]string `json:"header,omitempty"`

        // Extensions are extra values that are added by previous interceptors in a chain
        Extensions map[string]interface{} `json:"extensions,omitempty"`

        // InterceptorParams are the user specified params for interceptor in the Trigger
        InterceptorParams map[string]interface{} `json:"interceptor_params,omitempty"`

        // Context contains additional metadata about the event being processed
        Context *TriggerContext `json:"context"`
}

type TriggerContext struct {
        // EventURL is the URL of the incoming event
        EventURL string `json:"event_url,omitempty"`
        // EventID is a unique ID assigned by Triggers to each event
        EventID string `json:"event_id,omitempty"`
        // TriggerID is of the form namespace/$ns/triggers/$name
        TriggerID string `json:"trigger_id,omitempty"`
}

// Do not generate Deepcopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorResponse struct {
        // Extensions are additional fields that is added to the interceptor event.
        Extensions map[string]interface{} `json:"extensions,omitempty"`
        // Continue indicates if the EventListener should continue processing the Trigger or not
        Continue bool `json:"continue"` // Don't add omitempty -- it  will remove the continue field when the value is false.
        // Status is an Error status containing details on any interceptor processing errors
        Status Status `json:"status"`
}

type Status struct {
        // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
        Code codes.Code `json:"code,omitempty"`
        // A developer-facing error message, which should be in English.
        Message string `json:"message,omitempty"`
}

func (s Status) Err() StatusError <span class="cov0" title="0">{
        return StatusError{s: s}
}</span>

type StatusError struct {
        s Status
}

func (s StatusError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("rpc error: code = %s desc = %s", s.s.Code, s.s.Message)
}</span>

func ParseTriggerID(triggerID string) (namespace, name string) <span class="cov8" title="1">{
        splits := strings.Split(triggerID, "/")
        if len(splits) != 4 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return splits[1], splits[3]</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: triggers.GroupName, Version: "v1beta1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;ClusterTriggerBinding{},
                &amp;ClusterTriggerBindingList{},
                &amp;EventListener{},
                &amp;EventListenerList{},
                &amp;TriggerBinding{},
                &amp;TriggerBindingList{},
                &amp;TriggerTemplate{},
                &amp;TriggerTemplateList{},
                &amp;Trigger{},
                &amp;TriggerList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerBinding tb with its default values.
func (tb *TriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that TriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*TriggerBinding)(nil)
var _ apis.Defaultable = (*TriggerBinding)(nil)

func (tb *TriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return tb.Spec
}</span>

func (tb *TriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return tb.ObjectMeta
}</span>

func (tb *TriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return tb.DeepCopy()
}</span>

// TriggerBindingSpec defines the desired state of the TriggerBinding.
type TriggerBindingSpec struct {
        // Params defines the parameter mapping from the given input event.
        // +listType=atomic
        Params []Param `json:"params,omitempty"`
}

// TriggerBindingStatus defines the observed state of TriggerBinding.
type TriggerBindingStatus struct{}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBinding defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type TriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the TriggerBinding
        // +optional
        Spec TriggerBindingSpec `json:"spec"`
        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBindingList contains a list of TriggerBindings.
// We don't use this but it's required for certain codegen features.
type TriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TriggerBinding `json:"items"`
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ resourcesemantics.VerbLimited = (*TriggerBinding)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (tb *TriggerBinding) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate TriggerBinding.
func (tb *TriggerBinding) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(tb.GetObjectMeta()).ViaField("metadata")
        return errs.Also(tb.Spec.Validate(ctx).ViaField("spec"))
}</span>

// revive:disable:unused-parameter

// Validate TriggerBindingSpec.
func (s *TriggerBindingSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerBindingSpec{}) </span><span class="cov8" title="1">{
                return errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">return errs.Also(validateParams(s.Params).ViaField("params"))</span>
}

func validateParams(params []Param) *apis.FieldError <span class="cov8" title="1">{
        // Ensure there aren't multiple params with the same name.
        seen := sets.NewString()
        for i, param := range params </span><span class="cov8" title="1">{
                if seen.Has(param.Name) </span><span class="cov8" title="1">{
                        return apis.ErrMultipleOneOf(fmt.Sprintf("[%d].name", i))
                }</span>
                <span class="cov8" title="1">seen.Insert(param.Name)
                errs := validateParamValue(param.Value).ViaField(fmt.Sprintf("[%d]", i))
                if errs != nil </span><span class="cov8" title="1">{
                        return errs
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateParamValue(in string) *apis.FieldError <span class="cov8" title="1">{
        if !strings.Contains(in, "$(") </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Splits string on $( to find potential Tekton expressions
        <span class="cov8" title="1">maybeExpressions := strings.Split(in, "$(")
        terminated := true
        for _, e := range maybeExpressions[1:] </span><span class="cov8" title="1">{ // Split always returns at least one element
                // Iterate until we find the first unbalanced )
                numOpenBrackets := 0
                if !terminated </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(in, "value")
                }</span>
                <span class="cov8" title="1">terminated = false
                for _, ch := range e </span><span class="cov8" title="1">{
                        switch ch </span>{
                        case '(':<span class="cov8" title="1">
                                numOpenBrackets++</span>
                        case ')':<span class="cov8" title="1">
                                numOpenBrackets--
                                if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                        terminated = true
                                }</span>
                        default:<span class="cov8" title="1">
                                continue</span>
                        }
                        <span class="cov8" title="1">if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                terminated = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

type triggerSpecBindingArray []*TriggerSpecBinding

// SetDefaults sets the defaults on the object.
func (t *Trigger) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">triggerSpecBindingArray(t.Spec.Bindings).defaultBindings()
        for _, ti := range t.Spec.Interceptors </span><span class="cov8" title="1">{
                ti.defaultInterceptorKind()
        }</span>
}

// set default TriggerBinding kind for Bindings in TriggerSpec
func (t triggerSpecBindingArray) defaultBindings() <span class="cov8" title="1">{
        if len(t) &gt; 0 </span><span class="cov8" title="1">{
                for _, b := range t </span><span class="cov8" title="1">{
                        if b.Kind == "" </span><span class="cov8" title="1">{
                                b.Kind = NamespacedTriggerBindingKind
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerTemplate with default values.
func (tt *TriggerTemplate) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "regexp"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

// paramsRegexp captures TriggerTemplate parameter names $(tt.params.NAME)
var paramsRegexp = regexp.MustCompile(`\$\(tt.params.(?P&lt;var&gt;[_a-zA-Z][_a-zA-Z0-9.-]*)\)`)

var _ resourcesemantics.VerbLimited = (*TriggerTemplate)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (t *TriggerTemplate) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate validates a TriggerTemplate.
func (t *TriggerTemplate) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))
}</span>

// revive:disable:unused-parameter

// Validate validates a TriggerTemplateSpec.
func (s *TriggerTemplateSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerTemplateSpec{}) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">if len(s.ResourceTemplates) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("resourcetemplates"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateResourceTemplates(s.ResourceTemplates).ViaField("resourcetemplates"))
        errs = errs.Also(verifyParamDeclarations(s.Params, s.ResourceTemplates).ViaField("resourcetemplates"))
        return errs</span>
}

func validateResourceTemplates(templates []TriggerResourceTemplate) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, trt := range templates </span><span class="cov8" title="1">{
                data := new(unstructured.Unstructured)
                if err := data.UnmarshalJSON(trt.Raw); err != nil </span><span class="cov8" title="1">{
                        // a missing kind makes the unmarshalling throw an error
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].kind", i)))
                }</span>

                <span class="cov8" title="1">if data.GetAPIVersion() == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].apiVersion", i)))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Verify every param in the ResourceTemplates is declared with a ParamSpec
func verifyParamDeclarations(params []ParamSpec, templates []TriggerResourceTemplate) *apis.FieldError <span class="cov8" title="1">{
        declaredParamNames := sets.NewString()
        for _, param := range params </span><span class="cov8" title="1">{
                declaredParamNames.Insert(param.Name)
        }</span>
        <span class="cov8" title="1">for i, template := range templates </span><span class="cov8" title="1">{
                // Get all params in the template $(tt.params.NAME)
                templateParams := paramsRegexp.FindAllSubmatch(template.RawExtension.Raw, -1)
                for _, templateParam := range templateParams </span><span class="cov8" title="1">{
                        templateParamName := string(templateParam[1])
                        if !declaredParamNames.Has(templateParamName) </span><span class="cov8" title="1">{
                                fieldErr := apis.ErrInvalidValue(
                                        fmt.Sprintf("undeclared param '$(tt.params.%s)'", templateParamName),
                                        fmt.Sprintf("[%d]", i),
                                )
                                fieldErr.Details = fmt.Sprintf("'$(tt.params.%s)' must be declared in spec.params", templateParamName)
                                return fieldErr
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// TriggerSpec represents a connection between TriggerSpecBinding,
// and TriggerSpecTemplate; TriggerSpecBinding provides extracted values for
// TriggerSpecTemplate to then create resources from.
type TriggerSpec struct {
        // +listType=atomic
        Bindings []*TriggerSpecBinding `json:"bindings"`
        Template TriggerSpecTemplate   `json:"template"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*TriggerInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // Unlike EventListeners, this should be scoped to the same namespace
        // as the Trigger itself
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

type TriggerSpecTemplate struct {
        Ref        *string              `json:"ref,omitempty"`
        APIVersion string               `json:"apiversion,omitempty"`
        Spec       *TriggerTemplateSpec `json:"spec,omitempty"`
}

type TriggerSpecBinding struct {
        // Name is the name of the binding param
        // Mutually exclusive with Ref
        Name string `json:"name,omitempty"`
        // Value is the value of the binding param. Can contain JSONPath
        // Has to be pointer since "" is a valid value
        // Required if Name is also specified.
        Value *string `json:"value,omitempty"`

        // Ref is a reference to a TriggerBinding kind.
        // Mutually exclusive with Name
        Ref string `json:"ref,omitempty"`

        // Kind can only be provided if Ref is also provided. Defaults to TriggerBinding
        Kind TriggerBindingKind `json:"kind,omitempty"`

        // APIVersion of the binding ref
        APIVersion string `json:"apiversion,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Trigger defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type Trigger struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the Trigger
        // +optional
        Spec TriggerSpec `json:"spec"`
}

// TriggerInterceptor provides a hook to intercept and pre-process events
type TriggerInterceptor struct {
        // Optional name to identify the current interceptor configuration
        Name *string `json:"name,omitempty"`
        // Ref refers to the Interceptor to use
        Ref InterceptorRef `json:"ref"`
        // Params are the params to send to the interceptor
        // +listType=atomic
        Params []InterceptorParams `json:"params,omitempty"`

        // WebhookInterceptor refers to an old style webhook interceptor service
        Webhook *WebhookInterceptor `json:"webhook,omitempty"`
}

// InterceptorParams defines a key-value pair that can be passed on an interceptor
type InterceptorParams struct {
        Name  string               `json:"name"`
        Value apiextensionsv1.JSON `json:"value"`
}

// InterceptorRef provides a Reference to a ClusterInterceptor
type InterceptorRef struct {
        // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        Name string `json:"name,omitempty"`
        // InterceptorKind indicates the kind of the Interceptor, namespaced or cluster scoped.
        // +optional
        Kind InterceptorKind `json:"kind,omitempty"`
        // API version of the referent
        // +optional
        APIVersion string `json:"apiVersion,omitempty"`
}

// InterceptorKind defines the type of Interceptor used by the Trigger.
type InterceptorKind string

const (
        // ClusterInterceptorKind indicates that Interceptor type has a cluster scope.
        ClusterInterceptorKind InterceptorKind = "ClusterInterceptor"
        // NamespacedInterceptorKind indicates that Interceptor type has a namespace scope.
        NamespacedInterceptorKind InterceptorKind = "NamespacedInterceptor"
)

func (ti *TriggerInterceptor) defaultInterceptorKind() <span class="cov8" title="1">{
        if ti.Ref.Kind == "" </span><span class="cov8" title="1">{
                ti.Ref.Kind = ClusterInterceptorKind
        }</span>
}

// GetName returns the name for the given interceptor
func (ti *TriggerInterceptor) GetName() string <span class="cov8" title="1">{
        if ti.Ref.Name != "" </span><span class="cov8" title="1">{
                return ti.Ref.Name
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// WebhookInterceptor provides a webhook to intercept and pre-process events
type WebhookInterceptor struct {
        // ObjectRef is a reference to an object that will resolve to a cluster DNS
        // name to use as the EventInterceptor. Either objectRef or url can be specified
        // +optional
        ObjectRef *corev1.ObjectReference `json:"objectRef,omitempty"`
        // +optional
        URL *apis.URL `json:"url,omitempty"`
        // Header is a group of key-value pairs that can be appended to the
        // interceptor request headers. This allows the interceptor to make
        // decisions specific to an EventListenerTrigger.
        // +listType=atomic
        Header []v1beta1.Param `json:"header,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerList contains a list of Triggers.
// We don't use this but it's required for certain codegen features.
type TriggerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Trigger `json:"items"`
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/json"
)

// ToEventListenerTrigger converts a TriggerSpec into an EventListenerTrigger.
// This is primarily for compatibility between CRD and non-CRD types so that
// underlying libraries can reuse existing code.
func ToEventListenerTrigger(in TriggerSpec) (EventListenerTrigger, error) <span class="cov8" title="1">{
        var out EventListenerTrigger

        // Use json Marshalling in order to be field agnostic. Since TriggerSpec
        // is a subset of the existing EventListenerTrigger type, and should always
        // contain the same field labels, this should be safe to do.
        b, err := json.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;out); err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ resourcesemantics.VerbLimited = (*Trigger)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (t *Trigger) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate validates a Trigger
func (t *Trigger) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))
}</span>

func (t *TriggerSpec) validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // Validate optional Bindings
        errs := triggerSpecBindingArray(t.Bindings).validate(ctx)
        // Validate required TriggerTemplate
        errs = errs.Also(t.Template.validate(ctx))

        // Validate optional Interceptors
        for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func (t TriggerSpecTemplate) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Optional explicit match
        if t.APIVersion != "" </span><span class="cov8" title="1">{
                if t.APIVersion != "v1alpha1" &amp;&amp; t.APIVersion != "v1beta1" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "template.apiVersion"))
                }</span>
        }

        <span class="cov8" title="1">switch </span>{
        case t.Spec != nil &amp;&amp; t.Ref != nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMultipleOneOf("template.spec", "template.ref"))</span>
        case t.Spec == nil &amp;&amp; t.Ref == nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingOneOf("template.spec", "template.ref"))</span>
        case t.Spec != nil:<span class="cov8" title="1">
                errs = errs.Also(t.Spec.validate(ctx))</span>
        case t.Ref == nil || *t.Ref == "":<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("template.ref"))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// revive:disable:unused-parameter

func (t triggerSpecBindingArray) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, b := range t </span><span class="cov8" title="1">{
                switch </span>{
                case b.Ref != "":<span class="cov8" title="1">
                        switch </span>{
                        case b.Name != "":<span class="cov8" title="1"> // Cannot specify both Ref and Name
                                errs = errs.Also(apis.ErrMultipleOneOf(fmt.Sprintf("bindings[%d].ref", i), fmt.Sprintf("bindings[%d].name", i)))</span>
                        case b.Kind != NamespacedTriggerBindingKind &amp;&amp; b.Kind != ClusterTriggerBindingKind:<span class="cov8" title="1"> // Kind must be valid
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), fmt.Sprintf("bindings[%d].kind", i)))</span>
                        }
                case b.Name != "":<span class="cov8" title="1">
                        if b.Value == nil </span><span class="cov8" title="1">{ // Value is mandatory if Name is specified
                                errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("bindings[%d].value", i)))
                        }</span>
                default:<span class="cov8" title="1">
                        errs = errs.Also(apis.ErrMissingOneOf(fmt.Sprintf("bindings[%d].ref", i), fmt.Sprintf("bindings[%d].spec", i), fmt.Sprintf("bindings[%d].name", i)))</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func (i *TriggerInterceptor) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if i.Webhook == nil </span><span class="cov8" title="1">{
                if i.Ref.Name == "" </span><span class="cov8" title="1">{ // Check to see if Interceptor referenced using Ref
                        errs = errs.Also(apis.ErrMissingField("interceptor"))
                }</span>
        }

        <span class="cov8" title="1">if i.Webhook != nil </span><span class="cov8" title="1">{ // TODO: This should be an error?
                w := i.Webhook
                if i.Webhook.ObjectRef == nil </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef"))
                }</span> else<span class="cov8" title="1"> {
                        if w.ObjectRef.Kind == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef.kind"))
                        }</span> else<span class="cov8" title="1"> if w.ObjectRef.Kind != "Service" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), "interceptor.webhook.objectRef.kind"))
                        }</span>

                        // Optional explicit match
                        <span class="cov8" title="1">if w.ObjectRef.APIVersion == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef.apiVersion"))
                        }</span> else<span class="cov8" title="1"> if w.ObjectRef.APIVersion != "v1" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "interceptor.webhook.objectRef.apiVersion"))
                        }</span>
                }

                <span class="cov8" title="1">for i, header := range w.Header </span><span class="cov8" title="1">{
                        // Enforce non-empty canonical header keys
                        if len(header.Name) == 0 || http.CanonicalHeaderKey(header.Name) != header.Name </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header name"), fmt.Sprintf("interceptor.webhook.header[%d].name", i)))
                        }</span>
                        // Enforce non-empty header values
                        <span class="cov8" title="1">if header.Value.Type == pipelinev1.ParamTypeString </span><span class="cov8" title="1">{
                                if len(header.Value.StringVal) == 0 </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                                }</span>
                        } else<span class="cov0" title="0"> if len(header.Value.ArrayVal) == 0 </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "knative.dev/pkg/apis"
)

// ValidateEnabledAPIFields checks that the enable-api-fields feature gate is set
// to the wantVersion value and, if not, returns an error stating which feature
// is dependent on the version and what the current version actually is.
func ValidateEnabledAPIFields(ctx context.Context, featureName, wantVersion string) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">currentVersion := config.FromContextOrDefaults(ctx).FeatureFlags.EnableAPIFields
        if currentVersion != wantVersion </span><span class="cov8" title="1">{
                var errs *apis.FieldError
                message := fmt.Sprintf(`%s requires "enable-api-fields" feature gate to be %q but it is %q`, featureName, wantVersion, currentVersion)
                return errs.Also(apis.ErrGeneric(message))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package triggers

import (
        "knative.dev/pkg/apis"
)

const (
        PayloadValidationAnnotation = "tekton.dev/payload-validation"
)

func ValidateAnnotations(annotations map[string]string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        if value, ok := annotations[PayloadValidationAnnotation]; ok </span><span class="cov8" title="1">{
                if value != "true" &amp;&amp; value != "false" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(PayloadValidationAnnotation+" annotation must have value 'true' or 'false'", "metadata.annotations"))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package versioned

import (
        fmt "fmt"
        http "net/http"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        discovery "k8s.io/client-go/discovery"
        rest "k8s.io/client-go/rest"
        flowcontrol "k8s.io/client-go/util/flowcontrol"
)

type Interface interface {
        Discovery() discovery.DiscoveryInterface
        TriggersV1alpha1() triggersv1alpha1.TriggersV1alpha1Interface
        TriggersV1beta1() triggersv1beta1.TriggersV1beta1Interface
}

// Clientset contains the clients for groups.
type Clientset struct {
        *discovery.DiscoveryClient
        triggersV1alpha1 *triggersv1alpha1.TriggersV1alpha1Client
        triggersV1beta1  *triggersv1beta1.TriggersV1beta1Client
}

// TriggersV1alpha1 retrieves the TriggersV1alpha1Client
func (c *Clientset) TriggersV1alpha1() triggersv1alpha1.TriggersV1alpha1Interface <span class="cov0" title="0">{
        return c.triggersV1alpha1
}</span>

// TriggersV1beta1 retrieves the TriggersV1beta1Client
func (c *Clientset) TriggersV1beta1() triggersv1beta1.TriggersV1beta1Interface <span class="cov0" title="0">{
        return c.triggersV1beta1
}</span>

// Discovery retrieves the DiscoveryClient
func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.DiscoveryClient</span>
}

// NewForConfig creates a new Clientset for the given config.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfig will generate a rate-limiter in configShallowCopy.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c

        if configShallowCopy.UserAgent == "" </span><span class="cov0" title="0">{
                configShallowCopy.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        // share the transport between all clients
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;configShallowCopy)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return NewForConfigAndClient(&amp;configShallowCopy, httpClient)</span>
}

// NewForConfigAndClient creates a new Clientset for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
// If config's RateLimiter is not set and QPS and Burst are acceptable,
// NewForConfigAndClient will generate a rate-limiter in configShallowCopy.
func NewForConfigAndClient(c *rest.Config, httpClient *http.Client) (*Clientset, error) <span class="cov0" title="0">{
        configShallowCopy := *c
        if configShallowCopy.RateLimiter == nil &amp;&amp; configShallowCopy.QPS &gt; 0 </span><span class="cov0" title="0">{
                if configShallowCopy.Burst &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("burst is required to be greater than 0 when RateLimiter is not set and QPS is set to greater than 0")
                }</span>
                <span class="cov0" title="0">configShallowCopy.RateLimiter = flowcontrol.NewTokenBucketRateLimiter(configShallowCopy.QPS, configShallowCopy.Burst)</span>
        }

        <span class="cov0" title="0">var cs Clientset
        var err error
        cs.triggersV1alpha1, err = triggersv1alpha1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cs.triggersV1beta1, err = triggersv1beta1.NewForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cs.DiscoveryClient, err = discovery.NewDiscoveryClientForConfigAndClient(&amp;configShallowCopy, httpClient)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cs, nil</span>
}

// NewForConfigOrDie creates a new Clientset for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *Clientset <span class="cov0" title="0">{
        cs, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return cs</span>
}

// New creates a new Clientset for the given RESTClient.
func New(c rest.Interface) *Clientset <span class="cov0" title="0">{
        var cs Clientset
        cs.triggersV1alpha1 = triggersv1alpha1.New(c)
        cs.triggersV1beta1 = triggersv1beta1.New(c)

        cs.DiscoveryClient = discovery.NewDiscoveryClient(c)
        return &amp;cs
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        clientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        faketriggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1/fake"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        faketriggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1/fake"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/discovery"
        fakediscovery "k8s.io/client-go/discovery/fake"
        "k8s.io/client-go/testing"
)

// NewSimpleClientset returns a clientset that will respond with the provided objects.
// It's backed by a very simple object tracker that processes creates, updates and deletions as-is,
// without applying any field management, validations and/or defaults. It shouldn't be considered a replacement
// for a real clientset and is mostly useful in simple unit tests.
//
// DEPRECATED: NewClientset replaces this with support for field management, which significantly improves
// server side apply testing. NewClientset is only available when apply configurations are generated (e.g.
// via --with-applyconfig).
func NewSimpleClientset(objects ...runtime.Object) *Clientset <span class="cov0" title="0">{
        o := testing.NewObjectTracker(scheme, codecs.UniversalDecoder())
        for _, obj := range objects </span><span class="cov0" title="0">{
                if err := o.Add(obj); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        <span class="cov0" title="0">cs := &amp;Clientset{tracker: o}
        cs.discovery = &amp;fakediscovery.FakeDiscovery{Fake: &amp;cs.Fake}
        cs.AddReactor("*", "*", testing.ObjectReaction(o))
        cs.AddWatchReactor("*", func(action testing.Action) (handled bool, ret watch.Interface, err error) </span><span class="cov0" title="0">{
                gvr := action.GetResource()
                ns := action.GetNamespace()
                watch, err := o.Watch(gvr, ns)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil, err
                }</span>
                <span class="cov0" title="0">return true, watch, nil</span>
        })

        <span class="cov0" title="0">return cs</span>
}

// Clientset implements clientset.Interface. Meant to be embedded into a
// struct to get a default implementation. This makes faking out just the method
// you want to test easier.
type Clientset struct {
        testing.Fake
        discovery *fakediscovery.FakeDiscovery
        tracker   testing.ObjectTracker
}

func (c *Clientset) Discovery() discovery.DiscoveryInterface <span class="cov0" title="0">{
        return c.discovery
}</span>

func (c *Clientset) Tracker() testing.ObjectTracker <span class="cov0" title="0">{
        return c.tracker
}</span>

var (
        _ clientset.Interface = &amp;Clientset{}
        _ testing.FakeClient  = &amp;Clientset{}
)

// TriggersV1alpha1 retrieves the TriggersV1alpha1Client
func (c *Clientset) TriggersV1alpha1() triggersv1alpha1.TriggersV1alpha1Interface <span class="cov0" title="0">{
        return &amp;faketriggersv1alpha1.FakeTriggersV1alpha1{Fake: &amp;c.Fake}
}</span>

// TriggersV1beta1 retrieves the TriggersV1beta1Client
func (c *Clientset) TriggersV1beta1() triggersv1beta1.TriggersV1beta1Interface <span class="cov0" title="0">{
        return &amp;faketriggersv1beta1.FakeTriggersV1beta1{Fake: &amp;c.Fake}
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var scheme = runtime.NewScheme()
var codecs = serializer.NewCodecFactory(scheme)

var localSchemeBuilder = runtime.SchemeBuilder{
        triggersv1alpha1.AddToScheme,
        triggersv1beta1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(scheme))
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package scheme

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        serializer "k8s.io/apimachinery/pkg/runtime/serializer"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
)

var Scheme = runtime.NewScheme()
var Codecs = serializer.NewCodecFactory(Scheme)
var ParameterCodec = runtime.NewParameterCodec(Scheme)
var localSchemeBuilder = runtime.SchemeBuilder{
        triggersv1alpha1.AddToScheme,
        triggersv1beta1.AddToScheme,
}

// AddToScheme adds all types of this clientset into the given scheme. This allows composition
// of clientsets, like in:
//
//        import (
//          "k8s.io/client-go/kubernetes"
//          clientsetscheme "k8s.io/client-go/kubernetes/scheme"
//          aggregatorclientsetscheme "k8s.io/kube-aggregator/pkg/client/clientset_generated/clientset/scheme"
//        )
//
//        kclientset, _ := kubernetes.NewForConfig(c)
//        _ = aggregatorclientsetscheme.AddToScheme(clientsetscheme.Scheme)
//
// After this, RawExtensions in Kubernetes types will serialize kube-aggregator types
// correctly.
var AddToScheme = localSchemeBuilder.AddToScheme

func init() <span class="cov0" title="0">{
        v1.AddToGroupVersion(Scheme, schema.GroupVersion{Version: "v1"})
        utilruntime.Must(AddToScheme(Scheme))
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// ClusterInterceptorsGetter has a method to return a ClusterInterceptorInterface.
// A group's client should implement this interface.
type ClusterInterceptorsGetter interface {
        ClusterInterceptors() ClusterInterceptorInterface
}

// ClusterInterceptorInterface has methods to work with ClusterInterceptor resources.
type ClusterInterceptorInterface interface {
        Create(ctx context.Context, clusterInterceptor *triggersv1alpha1.ClusterInterceptor, opts v1.CreateOptions) (*triggersv1alpha1.ClusterInterceptor, error)
        Update(ctx context.Context, clusterInterceptor *triggersv1alpha1.ClusterInterceptor, opts v1.UpdateOptions) (*triggersv1alpha1.ClusterInterceptor, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, clusterInterceptor *triggersv1alpha1.ClusterInterceptor, opts v1.UpdateOptions) (*triggersv1alpha1.ClusterInterceptor, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1alpha1.ClusterInterceptor, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1alpha1.ClusterInterceptorList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1alpha1.ClusterInterceptor, err error)
        ClusterInterceptorExpansion
}

// clusterInterceptors implements ClusterInterceptorInterface
type clusterInterceptors struct {
        *gentype.ClientWithList[*triggersv1alpha1.ClusterInterceptor, *triggersv1alpha1.ClusterInterceptorList]
}

// newClusterInterceptors returns a ClusterInterceptors
func newClusterInterceptors(c *TriggersV1alpha1Client) *clusterInterceptors <span class="cov0" title="0">{
        return &amp;clusterInterceptors{
                gentype.NewClientWithList[*triggersv1alpha1.ClusterInterceptor, *triggersv1alpha1.ClusterInterceptorList](
                        "clusterinterceptors",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        "",
                        func() *triggersv1alpha1.ClusterInterceptor </span><span class="cov0" title="0">{ return &amp;triggersv1alpha1.ClusterInterceptor{} }</span>,
                        func() *triggersv1alpha1.ClusterInterceptorList <span class="cov0" title="0">{ return &amp;triggersv1alpha1.ClusterInterceptorList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// ClusterTriggerBindingsGetter has a method to return a ClusterTriggerBindingInterface.
// A group's client should implement this interface.
type ClusterTriggerBindingsGetter interface {
        ClusterTriggerBindings() ClusterTriggerBindingInterface
}

// ClusterTriggerBindingInterface has methods to work with ClusterTriggerBinding resources.
type ClusterTriggerBindingInterface interface {
        Create(ctx context.Context, clusterTriggerBinding *triggersv1alpha1.ClusterTriggerBinding, opts v1.CreateOptions) (*triggersv1alpha1.ClusterTriggerBinding, error)
        Update(ctx context.Context, clusterTriggerBinding *triggersv1alpha1.ClusterTriggerBinding, opts v1.UpdateOptions) (*triggersv1alpha1.ClusterTriggerBinding, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, clusterTriggerBinding *triggersv1alpha1.ClusterTriggerBinding, opts v1.UpdateOptions) (*triggersv1alpha1.ClusterTriggerBinding, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1alpha1.ClusterTriggerBinding, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1alpha1.ClusterTriggerBindingList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1alpha1.ClusterTriggerBinding, err error)
        ClusterTriggerBindingExpansion
}

// clusterTriggerBindings implements ClusterTriggerBindingInterface
type clusterTriggerBindings struct {
        *gentype.ClientWithList[*triggersv1alpha1.ClusterTriggerBinding, *triggersv1alpha1.ClusterTriggerBindingList]
}

// newClusterTriggerBindings returns a ClusterTriggerBindings
func newClusterTriggerBindings(c *TriggersV1alpha1Client) *clusterTriggerBindings <span class="cov0" title="0">{
        return &amp;clusterTriggerBindings{
                gentype.NewClientWithList[*triggersv1alpha1.ClusterTriggerBinding, *triggersv1alpha1.ClusterTriggerBindingList](
                        "clustertriggerbindings",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        "",
                        func() *triggersv1alpha1.ClusterTriggerBinding </span><span class="cov0" title="0">{ return &amp;triggersv1alpha1.ClusterTriggerBinding{} }</span>,
                        func() *triggersv1alpha1.ClusterTriggerBindingList <span class="cov0" title="0">{
                                return &amp;triggersv1alpha1.ClusterTriggerBindingList{}
                        }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// EventListenersGetter has a method to return a EventListenerInterface.
// A group's client should implement this interface.
type EventListenersGetter interface {
        EventListeners(namespace string) EventListenerInterface
}

// EventListenerInterface has methods to work with EventListener resources.
type EventListenerInterface interface {
        Create(ctx context.Context, eventListener *triggersv1alpha1.EventListener, opts v1.CreateOptions) (*triggersv1alpha1.EventListener, error)
        Update(ctx context.Context, eventListener *triggersv1alpha1.EventListener, opts v1.UpdateOptions) (*triggersv1alpha1.EventListener, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, eventListener *triggersv1alpha1.EventListener, opts v1.UpdateOptions) (*triggersv1alpha1.EventListener, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1alpha1.EventListener, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1alpha1.EventListenerList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1alpha1.EventListener, err error)
        EventListenerExpansion
}

// eventListeners implements EventListenerInterface
type eventListeners struct {
        *gentype.ClientWithList[*triggersv1alpha1.EventListener, *triggersv1alpha1.EventListenerList]
}

// newEventListeners returns a EventListeners
func newEventListeners(c *TriggersV1alpha1Client, namespace string) *eventListeners <span class="cov0" title="0">{
        return &amp;eventListeners{
                gentype.NewClientWithList[*triggersv1alpha1.EventListener, *triggersv1alpha1.EventListenerList](
                        "eventlisteners",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1alpha1.EventListener </span><span class="cov0" title="0">{ return &amp;triggersv1alpha1.EventListener{} }</span>,
                        func() *triggersv1alpha1.EventListenerList <span class="cov0" title="0">{ return &amp;triggersv1alpha1.EventListenerList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeClusterInterceptors implements ClusterInterceptorInterface
type fakeClusterInterceptors struct {
        *gentype.FakeClientWithList[*v1alpha1.ClusterInterceptor, *v1alpha1.ClusterInterceptorList]
        Fake *FakeTriggersV1alpha1
}

func newFakeClusterInterceptors(fake *FakeTriggersV1alpha1) triggersv1alpha1.ClusterInterceptorInterface <span class="cov0" title="0">{
        return &amp;fakeClusterInterceptors{
                gentype.NewFakeClientWithList[*v1alpha1.ClusterInterceptor, *v1alpha1.ClusterInterceptorList](
                        fake.Fake,
                        "",
                        v1alpha1.SchemeGroupVersion.WithResource("clusterinterceptors"),
                        v1alpha1.SchemeGroupVersion.WithKind("ClusterInterceptor"),
                        func() *v1alpha1.ClusterInterceptor </span><span class="cov0" title="0">{ return &amp;v1alpha1.ClusterInterceptor{} }</span>,
                        func() *v1alpha1.ClusterInterceptorList <span class="cov0" title="0">{ return &amp;v1alpha1.ClusterInterceptorList{} }</span>,
                        func(dst, src *v1alpha1.ClusterInterceptorList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.ClusterInterceptorList) []*v1alpha1.ClusterInterceptor <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.ClusterInterceptorList, items []*v1alpha1.ClusterInterceptor) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeClusterTriggerBindings implements ClusterTriggerBindingInterface
type fakeClusterTriggerBindings struct {
        *gentype.FakeClientWithList[*v1alpha1.ClusterTriggerBinding, *v1alpha1.ClusterTriggerBindingList]
        Fake *FakeTriggersV1alpha1
}

func newFakeClusterTriggerBindings(fake *FakeTriggersV1alpha1) triggersv1alpha1.ClusterTriggerBindingInterface <span class="cov0" title="0">{
        return &amp;fakeClusterTriggerBindings{
                gentype.NewFakeClientWithList[*v1alpha1.ClusterTriggerBinding, *v1alpha1.ClusterTriggerBindingList](
                        fake.Fake,
                        "",
                        v1alpha1.SchemeGroupVersion.WithResource("clustertriggerbindings"),
                        v1alpha1.SchemeGroupVersion.WithKind("ClusterTriggerBinding"),
                        func() *v1alpha1.ClusterTriggerBinding </span><span class="cov0" title="0">{ return &amp;v1alpha1.ClusterTriggerBinding{} }</span>,
                        func() *v1alpha1.ClusterTriggerBindingList <span class="cov0" title="0">{ return &amp;v1alpha1.ClusterTriggerBindingList{} }</span>,
                        func(dst, src *v1alpha1.ClusterTriggerBindingList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.ClusterTriggerBindingList) []*v1alpha1.ClusterTriggerBinding <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.ClusterTriggerBindingList, items []*v1alpha1.ClusterTriggerBinding) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeEventListeners implements EventListenerInterface
type fakeEventListeners struct {
        *gentype.FakeClientWithList[*v1alpha1.EventListener, *v1alpha1.EventListenerList]
        Fake *FakeTriggersV1alpha1
}

func newFakeEventListeners(fake *FakeTriggersV1alpha1, namespace string) triggersv1alpha1.EventListenerInterface <span class="cov0" title="0">{
        return &amp;fakeEventListeners{
                gentype.NewFakeClientWithList[*v1alpha1.EventListener, *v1alpha1.EventListenerList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("eventlisteners"),
                        v1alpha1.SchemeGroupVersion.WithKind("EventListener"),
                        func() *v1alpha1.EventListener </span><span class="cov0" title="0">{ return &amp;v1alpha1.EventListener{} }</span>,
                        func() *v1alpha1.EventListenerList <span class="cov0" title="0">{ return &amp;v1alpha1.EventListenerList{} }</span>,
                        func(dst, src *v1alpha1.EventListenerList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.EventListenerList) []*v1alpha1.EventListener <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.EventListenerList, items []*v1alpha1.EventListener) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeInterceptors implements InterceptorInterface
type fakeInterceptors struct {
        *gentype.FakeClientWithList[*v1alpha1.Interceptor, *v1alpha1.InterceptorList]
        Fake *FakeTriggersV1alpha1
}

func newFakeInterceptors(fake *FakeTriggersV1alpha1, namespace string) triggersv1alpha1.InterceptorInterface <span class="cov0" title="0">{
        return &amp;fakeInterceptors{
                gentype.NewFakeClientWithList[*v1alpha1.Interceptor, *v1alpha1.InterceptorList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("interceptors"),
                        v1alpha1.SchemeGroupVersion.WithKind("Interceptor"),
                        func() *v1alpha1.Interceptor </span><span class="cov0" title="0">{ return &amp;v1alpha1.Interceptor{} }</span>,
                        func() *v1alpha1.InterceptorList <span class="cov0" title="0">{ return &amp;v1alpha1.InterceptorList{} }</span>,
                        func(dst, src *v1alpha1.InterceptorList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.InterceptorList) []*v1alpha1.Interceptor <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.InterceptorList, items []*v1alpha1.Interceptor) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTriggers implements TriggerInterface
type fakeTriggers struct {
        *gentype.FakeClientWithList[*v1alpha1.Trigger, *v1alpha1.TriggerList]
        Fake *FakeTriggersV1alpha1
}

func newFakeTriggers(fake *FakeTriggersV1alpha1, namespace string) triggersv1alpha1.TriggerInterface <span class="cov0" title="0">{
        return &amp;fakeTriggers{
                gentype.NewFakeClientWithList[*v1alpha1.Trigger, *v1alpha1.TriggerList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("triggers"),
                        v1alpha1.SchemeGroupVersion.WithKind("Trigger"),
                        func() *v1alpha1.Trigger </span><span class="cov0" title="0">{ return &amp;v1alpha1.Trigger{} }</span>,
                        func() *v1alpha1.TriggerList <span class="cov0" title="0">{ return &amp;v1alpha1.TriggerList{} }</span>,
                        func(dst, src *v1alpha1.TriggerList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.TriggerList) []*v1alpha1.Trigger <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1alpha1.TriggerList, items []*v1alpha1.Trigger) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTriggerBindings implements TriggerBindingInterface
type fakeTriggerBindings struct {
        *gentype.FakeClientWithList[*v1alpha1.TriggerBinding, *v1alpha1.TriggerBindingList]
        Fake *FakeTriggersV1alpha1
}

func newFakeTriggerBindings(fake *FakeTriggersV1alpha1, namespace string) triggersv1alpha1.TriggerBindingInterface <span class="cov0" title="0">{
        return &amp;fakeTriggerBindings{
                gentype.NewFakeClientWithList[*v1alpha1.TriggerBinding, *v1alpha1.TriggerBindingList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("triggerbindings"),
                        v1alpha1.SchemeGroupVersion.WithKind("TriggerBinding"),
                        func() *v1alpha1.TriggerBinding </span><span class="cov0" title="0">{ return &amp;v1alpha1.TriggerBinding{} }</span>,
                        func() *v1alpha1.TriggerBindingList <span class="cov0" title="0">{ return &amp;v1alpha1.TriggerBindingList{} }</span>,
                        func(dst, src *v1alpha1.TriggerBindingList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.TriggerBindingList) []*v1alpha1.TriggerBinding <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.TriggerBindingList, items []*v1alpha1.TriggerBinding) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeTriggersV1alpha1 struct {
        *testing.Fake
}

func (c *FakeTriggersV1alpha1) ClusterInterceptors() v1alpha1.ClusterInterceptorInterface <span class="cov0" title="0">{
        return newFakeClusterInterceptors(c)
}</span>

func (c *FakeTriggersV1alpha1) ClusterTriggerBindings() v1alpha1.ClusterTriggerBindingInterface <span class="cov0" title="0">{
        return newFakeClusterTriggerBindings(c)
}</span>

func (c *FakeTriggersV1alpha1) EventListeners(namespace string) v1alpha1.EventListenerInterface <span class="cov0" title="0">{
        return newFakeEventListeners(c, namespace)
}</span>

func (c *FakeTriggersV1alpha1) Interceptors(namespace string) v1alpha1.InterceptorInterface <span class="cov0" title="0">{
        return newFakeInterceptors(c, namespace)
}</span>

func (c *FakeTriggersV1alpha1) Triggers(namespace string) v1alpha1.TriggerInterface <span class="cov0" title="0">{
        return newFakeTriggers(c, namespace)
}</span>

func (c *FakeTriggersV1alpha1) TriggerBindings(namespace string) v1alpha1.TriggerBindingInterface <span class="cov0" title="0">{
        return newFakeTriggerBindings(c, namespace)
}</span>

func (c *FakeTriggersV1alpha1) TriggerTemplates(namespace string) v1alpha1.TriggerTemplateInterface <span class="cov0" title="0">{
        return newFakeTriggerTemplates(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeTriggersV1alpha1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTriggerTemplates implements TriggerTemplateInterface
type fakeTriggerTemplates struct {
        *gentype.FakeClientWithList[*v1alpha1.TriggerTemplate, *v1alpha1.TriggerTemplateList]
        Fake *FakeTriggersV1alpha1
}

func newFakeTriggerTemplates(fake *FakeTriggersV1alpha1, namespace string) triggersv1alpha1.TriggerTemplateInterface <span class="cov0" title="0">{
        return &amp;fakeTriggerTemplates{
                gentype.NewFakeClientWithList[*v1alpha1.TriggerTemplate, *v1alpha1.TriggerTemplateList](
                        fake.Fake,
                        namespace,
                        v1alpha1.SchemeGroupVersion.WithResource("triggertemplates"),
                        v1alpha1.SchemeGroupVersion.WithKind("TriggerTemplate"),
                        func() *v1alpha1.TriggerTemplate </span><span class="cov0" title="0">{ return &amp;v1alpha1.TriggerTemplate{} }</span>,
                        func() *v1alpha1.TriggerTemplateList <span class="cov0" title="0">{ return &amp;v1alpha1.TriggerTemplateList{} }</span>,
                        func(dst, src *v1alpha1.TriggerTemplateList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1alpha1.TriggerTemplateList) []*v1alpha1.TriggerTemplate <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1alpha1.TriggerTemplateList, items []*v1alpha1.TriggerTemplate) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// InterceptorsGetter has a method to return a InterceptorInterface.
// A group's client should implement this interface.
type InterceptorsGetter interface {
        Interceptors(namespace string) InterceptorInterface
}

// InterceptorInterface has methods to work with Interceptor resources.
type InterceptorInterface interface {
        Create(ctx context.Context, interceptor *triggersv1alpha1.Interceptor, opts v1.CreateOptions) (*triggersv1alpha1.Interceptor, error)
        Update(ctx context.Context, interceptor *triggersv1alpha1.Interceptor, opts v1.UpdateOptions) (*triggersv1alpha1.Interceptor, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, interceptor *triggersv1alpha1.Interceptor, opts v1.UpdateOptions) (*triggersv1alpha1.Interceptor, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1alpha1.Interceptor, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1alpha1.InterceptorList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1alpha1.Interceptor, err error)
        InterceptorExpansion
}

// interceptors implements InterceptorInterface
type interceptors struct {
        *gentype.ClientWithList[*triggersv1alpha1.Interceptor, *triggersv1alpha1.InterceptorList]
}

// newInterceptors returns a Interceptors
func newInterceptors(c *TriggersV1alpha1Client, namespace string) *interceptors <span class="cov0" title="0">{
        return &amp;interceptors{
                gentype.NewClientWithList[*triggersv1alpha1.Interceptor, *triggersv1alpha1.InterceptorList](
                        "interceptors",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1alpha1.Interceptor </span><span class="cov0" title="0">{ return &amp;triggersv1alpha1.Interceptor{} }</span>,
                        func() *triggersv1alpha1.InterceptorList <span class="cov0" title="0">{ return &amp;triggersv1alpha1.InterceptorList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TriggersGetter has a method to return a TriggerInterface.
// A group's client should implement this interface.
type TriggersGetter interface {
        Triggers(namespace string) TriggerInterface
}

// TriggerInterface has methods to work with Trigger resources.
type TriggerInterface interface {
        Create(ctx context.Context, trigger *triggersv1alpha1.Trigger, opts v1.CreateOptions) (*triggersv1alpha1.Trigger, error)
        Update(ctx context.Context, trigger *triggersv1alpha1.Trigger, opts v1.UpdateOptions) (*triggersv1alpha1.Trigger, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1alpha1.Trigger, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1alpha1.TriggerList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1alpha1.Trigger, err error)
        TriggerExpansion
}

// triggers implements TriggerInterface
type triggers struct {
        *gentype.ClientWithList[*triggersv1alpha1.Trigger, *triggersv1alpha1.TriggerList]
}

// newTriggers returns a Triggers
func newTriggers(c *TriggersV1alpha1Client, namespace string) *triggers <span class="cov0" title="0">{
        return &amp;triggers{
                gentype.NewClientWithList[*triggersv1alpha1.Trigger, *triggersv1alpha1.TriggerList](
                        "triggers",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1alpha1.Trigger </span><span class="cov0" title="0">{ return &amp;triggersv1alpha1.Trigger{} }</span>,
                        func() *triggersv1alpha1.TriggerList <span class="cov0" title="0">{ return &amp;triggersv1alpha1.TriggerList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file64" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TriggerBindingsGetter has a method to return a TriggerBindingInterface.
// A group's client should implement this interface.
type TriggerBindingsGetter interface {
        TriggerBindings(namespace string) TriggerBindingInterface
}

// TriggerBindingInterface has methods to work with TriggerBinding resources.
type TriggerBindingInterface interface {
        Create(ctx context.Context, triggerBinding *triggersv1alpha1.TriggerBinding, opts v1.CreateOptions) (*triggersv1alpha1.TriggerBinding, error)
        Update(ctx context.Context, triggerBinding *triggersv1alpha1.TriggerBinding, opts v1.UpdateOptions) (*triggersv1alpha1.TriggerBinding, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, triggerBinding *triggersv1alpha1.TriggerBinding, opts v1.UpdateOptions) (*triggersv1alpha1.TriggerBinding, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1alpha1.TriggerBinding, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1alpha1.TriggerBindingList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1alpha1.TriggerBinding, err error)
        TriggerBindingExpansion
}

// triggerBindings implements TriggerBindingInterface
type triggerBindings struct {
        *gentype.ClientWithList[*triggersv1alpha1.TriggerBinding, *triggersv1alpha1.TriggerBindingList]
}

// newTriggerBindings returns a TriggerBindings
func newTriggerBindings(c *TriggersV1alpha1Client, namespace string) *triggerBindings <span class="cov0" title="0">{
        return &amp;triggerBindings{
                gentype.NewClientWithList[*triggersv1alpha1.TriggerBinding, *triggersv1alpha1.TriggerBindingList](
                        "triggerbindings",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1alpha1.TriggerBinding </span><span class="cov0" title="0">{ return &amp;triggersv1alpha1.TriggerBinding{} }</span>,
                        func() *triggersv1alpha1.TriggerBindingList <span class="cov0" title="0">{ return &amp;triggersv1alpha1.TriggerBindingList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        http "net/http"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type TriggersV1alpha1Interface interface {
        RESTClient() rest.Interface
        ClusterInterceptorsGetter
        ClusterTriggerBindingsGetter
        EventListenersGetter
        InterceptorsGetter
        TriggersGetter
        TriggerBindingsGetter
        TriggerTemplatesGetter
}

// TriggersV1alpha1Client is used to interact with features provided by the triggers.tekton.dev group.
type TriggersV1alpha1Client struct {
        restClient rest.Interface
}

func (c *TriggersV1alpha1Client) ClusterInterceptors() ClusterInterceptorInterface <span class="cov0" title="0">{
        return newClusterInterceptors(c)
}</span>

func (c *TriggersV1alpha1Client) ClusterTriggerBindings() ClusterTriggerBindingInterface <span class="cov0" title="0">{
        return newClusterTriggerBindings(c)
}</span>

func (c *TriggersV1alpha1Client) EventListeners(namespace string) EventListenerInterface <span class="cov0" title="0">{
        return newEventListeners(c, namespace)
}</span>

func (c *TriggersV1alpha1Client) Interceptors(namespace string) InterceptorInterface <span class="cov0" title="0">{
        return newInterceptors(c, namespace)
}</span>

func (c *TriggersV1alpha1Client) Triggers(namespace string) TriggerInterface <span class="cov0" title="0">{
        return newTriggers(c, namespace)
}</span>

func (c *TriggersV1alpha1Client) TriggerBindings(namespace string) TriggerBindingInterface <span class="cov0" title="0">{
        return newTriggerBindings(c, namespace)
}</span>

func (c *TriggersV1alpha1Client) TriggerTemplates(namespace string) TriggerTemplateInterface <span class="cov0" title="0">{
        return newTriggerTemplates(c, namespace)
}</span>

// NewForConfig creates a new TriggersV1alpha1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*TriggersV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new TriggersV1alpha1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*TriggersV1alpha1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TriggersV1alpha1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new TriggersV1alpha1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *TriggersV1alpha1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new TriggersV1alpha1Client for the given RESTClient.
func New(c rest.Interface) *TriggersV1alpha1Client <span class="cov0" title="0">{
        return &amp;TriggersV1alpha1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := triggersv1alpha1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *TriggersV1alpha1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TriggerTemplatesGetter has a method to return a TriggerTemplateInterface.
// A group's client should implement this interface.
type TriggerTemplatesGetter interface {
        TriggerTemplates(namespace string) TriggerTemplateInterface
}

// TriggerTemplateInterface has methods to work with TriggerTemplate resources.
type TriggerTemplateInterface interface {
        Create(ctx context.Context, triggerTemplate *triggersv1alpha1.TriggerTemplate, opts v1.CreateOptions) (*triggersv1alpha1.TriggerTemplate, error)
        Update(ctx context.Context, triggerTemplate *triggersv1alpha1.TriggerTemplate, opts v1.UpdateOptions) (*triggersv1alpha1.TriggerTemplate, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, triggerTemplate *triggersv1alpha1.TriggerTemplate, opts v1.UpdateOptions) (*triggersv1alpha1.TriggerTemplate, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1alpha1.TriggerTemplate, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1alpha1.TriggerTemplateList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1alpha1.TriggerTemplate, err error)
        TriggerTemplateExpansion
}

// triggerTemplates implements TriggerTemplateInterface
type triggerTemplates struct {
        *gentype.ClientWithList[*triggersv1alpha1.TriggerTemplate, *triggersv1alpha1.TriggerTemplateList]
}

// newTriggerTemplates returns a TriggerTemplates
func newTriggerTemplates(c *TriggersV1alpha1Client, namespace string) *triggerTemplates <span class="cov0" title="0">{
        return &amp;triggerTemplates{
                gentype.NewClientWithList[*triggersv1alpha1.TriggerTemplate, *triggersv1alpha1.TriggerTemplateList](
                        "triggertemplates",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1alpha1.TriggerTemplate </span><span class="cov0" title="0">{ return &amp;triggersv1alpha1.TriggerTemplate{} }</span>,
                        func() *triggersv1alpha1.TriggerTemplateList <span class="cov0" title="0">{ return &amp;triggersv1alpha1.TriggerTemplateList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// ClusterTriggerBindingsGetter has a method to return a ClusterTriggerBindingInterface.
// A group's client should implement this interface.
type ClusterTriggerBindingsGetter interface {
        ClusterTriggerBindings() ClusterTriggerBindingInterface
}

// ClusterTriggerBindingInterface has methods to work with ClusterTriggerBinding resources.
type ClusterTriggerBindingInterface interface {
        Create(ctx context.Context, clusterTriggerBinding *triggersv1beta1.ClusterTriggerBinding, opts v1.CreateOptions) (*triggersv1beta1.ClusterTriggerBinding, error)
        Update(ctx context.Context, clusterTriggerBinding *triggersv1beta1.ClusterTriggerBinding, opts v1.UpdateOptions) (*triggersv1beta1.ClusterTriggerBinding, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, clusterTriggerBinding *triggersv1beta1.ClusterTriggerBinding, opts v1.UpdateOptions) (*triggersv1beta1.ClusterTriggerBinding, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1beta1.ClusterTriggerBinding, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1beta1.ClusterTriggerBindingList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1beta1.ClusterTriggerBinding, err error)
        ClusterTriggerBindingExpansion
}

// clusterTriggerBindings implements ClusterTriggerBindingInterface
type clusterTriggerBindings struct {
        *gentype.ClientWithList[*triggersv1beta1.ClusterTriggerBinding, *triggersv1beta1.ClusterTriggerBindingList]
}

// newClusterTriggerBindings returns a ClusterTriggerBindings
func newClusterTriggerBindings(c *TriggersV1beta1Client) *clusterTriggerBindings <span class="cov0" title="0">{
        return &amp;clusterTriggerBindings{
                gentype.NewClientWithList[*triggersv1beta1.ClusterTriggerBinding, *triggersv1beta1.ClusterTriggerBindingList](
                        "clustertriggerbindings",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        "",
                        func() *triggersv1beta1.ClusterTriggerBinding </span><span class="cov0" title="0">{ return &amp;triggersv1beta1.ClusterTriggerBinding{} }</span>,
                        func() *triggersv1beta1.ClusterTriggerBindingList <span class="cov0" title="0">{ return &amp;triggersv1beta1.ClusterTriggerBindingList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// EventListenersGetter has a method to return a EventListenerInterface.
// A group's client should implement this interface.
type EventListenersGetter interface {
        EventListeners(namespace string) EventListenerInterface
}

// EventListenerInterface has methods to work with EventListener resources.
type EventListenerInterface interface {
        Create(ctx context.Context, eventListener *triggersv1beta1.EventListener, opts v1.CreateOptions) (*triggersv1beta1.EventListener, error)
        Update(ctx context.Context, eventListener *triggersv1beta1.EventListener, opts v1.UpdateOptions) (*triggersv1beta1.EventListener, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, eventListener *triggersv1beta1.EventListener, opts v1.UpdateOptions) (*triggersv1beta1.EventListener, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1beta1.EventListener, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1beta1.EventListenerList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1beta1.EventListener, err error)
        EventListenerExpansion
}

// eventListeners implements EventListenerInterface
type eventListeners struct {
        *gentype.ClientWithList[*triggersv1beta1.EventListener, *triggersv1beta1.EventListenerList]
}

// newEventListeners returns a EventListeners
func newEventListeners(c *TriggersV1beta1Client, namespace string) *eventListeners <span class="cov0" title="0">{
        return &amp;eventListeners{
                gentype.NewClientWithList[*triggersv1beta1.EventListener, *triggersv1beta1.EventListenerList](
                        "eventlisteners",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1beta1.EventListener </span><span class="cov0" title="0">{ return &amp;triggersv1beta1.EventListener{} }</span>,
                        func() *triggersv1beta1.EventListenerList <span class="cov0" title="0">{ return &amp;triggersv1beta1.EventListenerList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeClusterTriggerBindings implements ClusterTriggerBindingInterface
type fakeClusterTriggerBindings struct {
        *gentype.FakeClientWithList[*v1beta1.ClusterTriggerBinding, *v1beta1.ClusterTriggerBindingList]
        Fake *FakeTriggersV1beta1
}

func newFakeClusterTriggerBindings(fake *FakeTriggersV1beta1) triggersv1beta1.ClusterTriggerBindingInterface <span class="cov0" title="0">{
        return &amp;fakeClusterTriggerBindings{
                gentype.NewFakeClientWithList[*v1beta1.ClusterTriggerBinding, *v1beta1.ClusterTriggerBindingList](
                        fake.Fake,
                        "",
                        v1beta1.SchemeGroupVersion.WithResource("clustertriggerbindings"),
                        v1beta1.SchemeGroupVersion.WithKind("ClusterTriggerBinding"),
                        func() *v1beta1.ClusterTriggerBinding </span><span class="cov0" title="0">{ return &amp;v1beta1.ClusterTriggerBinding{} }</span>,
                        func() *v1beta1.ClusterTriggerBindingList <span class="cov0" title="0">{ return &amp;v1beta1.ClusterTriggerBindingList{} }</span>,
                        func(dst, src *v1beta1.ClusterTriggerBindingList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.ClusterTriggerBindingList) []*v1beta1.ClusterTriggerBinding <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1beta1.ClusterTriggerBindingList, items []*v1beta1.ClusterTriggerBinding) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeEventListeners implements EventListenerInterface
type fakeEventListeners struct {
        *gentype.FakeClientWithList[*v1beta1.EventListener, *v1beta1.EventListenerList]
        Fake *FakeTriggersV1beta1
}

func newFakeEventListeners(fake *FakeTriggersV1beta1, namespace string) triggersv1beta1.EventListenerInterface <span class="cov0" title="0">{
        return &amp;fakeEventListeners{
                gentype.NewFakeClientWithList[*v1beta1.EventListener, *v1beta1.EventListenerList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("eventlisteners"),
                        v1beta1.SchemeGroupVersion.WithKind("EventListener"),
                        func() *v1beta1.EventListener </span><span class="cov0" title="0">{ return &amp;v1beta1.EventListener{} }</span>,
                        func() *v1beta1.EventListenerList <span class="cov0" title="0">{ return &amp;v1beta1.EventListenerList{} }</span>,
                        func(dst, src *v1beta1.EventListenerList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.EventListenerList) []*v1beta1.EventListener <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1beta1.EventListenerList, items []*v1beta1.EventListener) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTriggers implements TriggerInterface
type fakeTriggers struct {
        *gentype.FakeClientWithList[*v1beta1.Trigger, *v1beta1.TriggerList]
        Fake *FakeTriggersV1beta1
}

func newFakeTriggers(fake *FakeTriggersV1beta1, namespace string) triggersv1beta1.TriggerInterface <span class="cov0" title="0">{
        return &amp;fakeTriggers{
                gentype.NewFakeClientWithList[*v1beta1.Trigger, *v1beta1.TriggerList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("triggers"),
                        v1beta1.SchemeGroupVersion.WithKind("Trigger"),
                        func() *v1beta1.Trigger </span><span class="cov0" title="0">{ return &amp;v1beta1.Trigger{} }</span>,
                        func() *v1beta1.TriggerList <span class="cov0" title="0">{ return &amp;v1beta1.TriggerList{} }</span>,
                        func(dst, src *v1beta1.TriggerList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.TriggerList) []*v1beta1.Trigger <span class="cov0" title="0">{ return gentype.ToPointerSlice(list.Items) }</span>,
                        func(list *v1beta1.TriggerList, items []*v1beta1.Trigger) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTriggerBindings implements TriggerBindingInterface
type fakeTriggerBindings struct {
        *gentype.FakeClientWithList[*v1beta1.TriggerBinding, *v1beta1.TriggerBindingList]
        Fake *FakeTriggersV1beta1
}

func newFakeTriggerBindings(fake *FakeTriggersV1beta1, namespace string) triggersv1beta1.TriggerBindingInterface <span class="cov0" title="0">{
        return &amp;fakeTriggerBindings{
                gentype.NewFakeClientWithList[*v1beta1.TriggerBinding, *v1beta1.TriggerBindingList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("triggerbindings"),
                        v1beta1.SchemeGroupVersion.WithKind("TriggerBinding"),
                        func() *v1beta1.TriggerBinding </span><span class="cov0" title="0">{ return &amp;v1beta1.TriggerBinding{} }</span>,
                        func() *v1beta1.TriggerBindingList <span class="cov0" title="0">{ return &amp;v1beta1.TriggerBindingList{} }</span>,
                        func(dst, src *v1beta1.TriggerBindingList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.TriggerBindingList) []*v1beta1.TriggerBinding <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1beta1.TriggerBindingList, items []*v1beta1.TriggerBinding) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        rest "k8s.io/client-go/rest"
        testing "k8s.io/client-go/testing"
)

type FakeTriggersV1beta1 struct {
        *testing.Fake
}

func (c *FakeTriggersV1beta1) ClusterTriggerBindings() v1beta1.ClusterTriggerBindingInterface <span class="cov0" title="0">{
        return newFakeClusterTriggerBindings(c)
}</span>

func (c *FakeTriggersV1beta1) EventListeners(namespace string) v1beta1.EventListenerInterface <span class="cov0" title="0">{
        return newFakeEventListeners(c, namespace)
}</span>

func (c *FakeTriggersV1beta1) Triggers(namespace string) v1beta1.TriggerInterface <span class="cov0" title="0">{
        return newFakeTriggers(c, namespace)
}</span>

func (c *FakeTriggersV1beta1) TriggerBindings(namespace string) v1beta1.TriggerBindingInterface <span class="cov0" title="0">{
        return newFakeTriggerBindings(c, namespace)
}</span>

func (c *FakeTriggersV1beta1) TriggerTemplates(namespace string) v1beta1.TriggerTemplateInterface <span class="cov0" title="0">{
        return newFakeTriggerTemplates(c, namespace)
}</span>

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *FakeTriggersV1beta1) RESTClient() rest.Interface <span class="cov0" title="0">{
        var ret *rest.RESTClient
        return ret
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package fake

import (
        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1beta1"
        gentype "k8s.io/client-go/gentype"
)

// fakeTriggerTemplates implements TriggerTemplateInterface
type fakeTriggerTemplates struct {
        *gentype.FakeClientWithList[*v1beta1.TriggerTemplate, *v1beta1.TriggerTemplateList]
        Fake *FakeTriggersV1beta1
}

func newFakeTriggerTemplates(fake *FakeTriggersV1beta1, namespace string) triggersv1beta1.TriggerTemplateInterface <span class="cov0" title="0">{
        return &amp;fakeTriggerTemplates{
                gentype.NewFakeClientWithList[*v1beta1.TriggerTemplate, *v1beta1.TriggerTemplateList](
                        fake.Fake,
                        namespace,
                        v1beta1.SchemeGroupVersion.WithResource("triggertemplates"),
                        v1beta1.SchemeGroupVersion.WithKind("TriggerTemplate"),
                        func() *v1beta1.TriggerTemplate </span><span class="cov0" title="0">{ return &amp;v1beta1.TriggerTemplate{} }</span>,
                        func() *v1beta1.TriggerTemplateList <span class="cov0" title="0">{ return &amp;v1beta1.TriggerTemplateList{} }</span>,
                        func(dst, src *v1beta1.TriggerTemplateList) <span class="cov0" title="0">{ dst.ListMeta = src.ListMeta }</span>,
                        func(list *v1beta1.TriggerTemplateList) []*v1beta1.TriggerTemplate <span class="cov0" title="0">{
                                return gentype.ToPointerSlice(list.Items)
                        }</span>,
                        func(list *v1beta1.TriggerTemplateList, items []*v1beta1.TriggerTemplate) <span class="cov0" title="0">{
                                list.Items = gentype.FromPointerSlice(items)
                        }</span>,
                ),
                fake,
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TriggersGetter has a method to return a TriggerInterface.
// A group's client should implement this interface.
type TriggersGetter interface {
        Triggers(namespace string) TriggerInterface
}

// TriggerInterface has methods to work with Trigger resources.
type TriggerInterface interface {
        Create(ctx context.Context, trigger *triggersv1beta1.Trigger, opts v1.CreateOptions) (*triggersv1beta1.Trigger, error)
        Update(ctx context.Context, trigger *triggersv1beta1.Trigger, opts v1.UpdateOptions) (*triggersv1beta1.Trigger, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1beta1.Trigger, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1beta1.TriggerList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1beta1.Trigger, err error)
        TriggerExpansion
}

// triggers implements TriggerInterface
type triggers struct {
        *gentype.ClientWithList[*triggersv1beta1.Trigger, *triggersv1beta1.TriggerList]
}

// newTriggers returns a Triggers
func newTriggers(c *TriggersV1beta1Client, namespace string) *triggers <span class="cov0" title="0">{
        return &amp;triggers{
                gentype.NewClientWithList[*triggersv1beta1.Trigger, *triggersv1beta1.TriggerList](
                        "triggers",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1beta1.Trigger </span><span class="cov0" title="0">{ return &amp;triggersv1beta1.Trigger{} }</span>,
                        func() *triggersv1beta1.TriggerList <span class="cov0" title="0">{ return &amp;triggersv1beta1.TriggerList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TriggerBindingsGetter has a method to return a TriggerBindingInterface.
// A group's client should implement this interface.
type TriggerBindingsGetter interface {
        TriggerBindings(namespace string) TriggerBindingInterface
}

// TriggerBindingInterface has methods to work with TriggerBinding resources.
type TriggerBindingInterface interface {
        Create(ctx context.Context, triggerBinding *triggersv1beta1.TriggerBinding, opts v1.CreateOptions) (*triggersv1beta1.TriggerBinding, error)
        Update(ctx context.Context, triggerBinding *triggersv1beta1.TriggerBinding, opts v1.UpdateOptions) (*triggersv1beta1.TriggerBinding, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, triggerBinding *triggersv1beta1.TriggerBinding, opts v1.UpdateOptions) (*triggersv1beta1.TriggerBinding, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1beta1.TriggerBinding, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1beta1.TriggerBindingList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1beta1.TriggerBinding, err error)
        TriggerBindingExpansion
}

// triggerBindings implements TriggerBindingInterface
type triggerBindings struct {
        *gentype.ClientWithList[*triggersv1beta1.TriggerBinding, *triggersv1beta1.TriggerBindingList]
}

// newTriggerBindings returns a TriggerBindings
func newTriggerBindings(c *TriggersV1beta1Client, namespace string) *triggerBindings <span class="cov0" title="0">{
        return &amp;triggerBindings{
                gentype.NewClientWithList[*triggersv1beta1.TriggerBinding, *triggersv1beta1.TriggerBindingList](
                        "triggerbindings",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1beta1.TriggerBinding </span><span class="cov0" title="0">{ return &amp;triggersv1beta1.TriggerBinding{} }</span>,
                        func() *triggersv1beta1.TriggerBindingList <span class="cov0" title="0">{ return &amp;triggersv1beta1.TriggerBindingList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        http "net/http"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        rest "k8s.io/client-go/rest"
)

type TriggersV1beta1Interface interface {
        RESTClient() rest.Interface
        ClusterTriggerBindingsGetter
        EventListenersGetter
        TriggersGetter
        TriggerBindingsGetter
        TriggerTemplatesGetter
}

// TriggersV1beta1Client is used to interact with features provided by the triggers.tekton.dev group.
type TriggersV1beta1Client struct {
        restClient rest.Interface
}

func (c *TriggersV1beta1Client) ClusterTriggerBindings() ClusterTriggerBindingInterface <span class="cov0" title="0">{
        return newClusterTriggerBindings(c)
}</span>

func (c *TriggersV1beta1Client) EventListeners(namespace string) EventListenerInterface <span class="cov0" title="0">{
        return newEventListeners(c, namespace)
}</span>

func (c *TriggersV1beta1Client) Triggers(namespace string) TriggerInterface <span class="cov0" title="0">{
        return newTriggers(c, namespace)
}</span>

func (c *TriggersV1beta1Client) TriggerBindings(namespace string) TriggerBindingInterface <span class="cov0" title="0">{
        return newTriggerBindings(c, namespace)
}</span>

func (c *TriggersV1beta1Client) TriggerTemplates(namespace string) TriggerTemplateInterface <span class="cov0" title="0">{
        return newTriggerTemplates(c, namespace)
}</span>

// NewForConfig creates a new TriggersV1beta1Client for the given config.
// NewForConfig is equivalent to NewForConfigAndClient(c, httpClient),
// where httpClient was generated with rest.HTTPClientFor(c).
func NewForConfig(c *rest.Config) (*TriggersV1beta1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">httpClient, err := rest.HTTPClientFor(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewForConfigAndClient(&amp;config, httpClient)</span>
}

// NewForConfigAndClient creates a new TriggersV1beta1Client for the given config and http client.
// Note the http client provided takes precedence over the configured transport values.
func NewForConfigAndClient(c *rest.Config, h *http.Client) (*TriggersV1beta1Client, error) <span class="cov0" title="0">{
        config := *c
        if err := setConfigDefaults(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client, err := rest.RESTClientForConfigAndClient(&amp;config, h)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;TriggersV1beta1Client{client}, nil</span>
}

// NewForConfigOrDie creates a new TriggersV1beta1Client for the given config and
// panics if there is an error in the config.
func NewForConfigOrDie(c *rest.Config) *TriggersV1beta1Client <span class="cov0" title="0">{
        client, err := NewForConfig(c)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return client</span>
}

// New creates a new TriggersV1beta1Client for the given RESTClient.
func New(c rest.Interface) *TriggersV1beta1Client <span class="cov0" title="0">{
        return &amp;TriggersV1beta1Client{c}
}</span>

func setConfigDefaults(config *rest.Config) error <span class="cov0" title="0">{
        gv := triggersv1beta1.SchemeGroupVersion
        config.GroupVersion = &amp;gv
        config.APIPath = "/apis"
        config.NegotiatedSerializer = rest.CodecFactoryForGeneratedClient(scheme.Scheme, scheme.Codecs).WithoutConversion()

        if config.UserAgent == "" </span><span class="cov0" title="0">{
                config.UserAgent = rest.DefaultKubernetesUserAgent()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// RESTClient returns a RESTClient that is used to communicate
// with API server by this client implementation.
func (c *TriggersV1beta1Client) RESTClient() rest.Interface <span class="cov0" title="0">{
        if c == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.restClient</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by client-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        scheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        gentype "k8s.io/client-go/gentype"
)

// TriggerTemplatesGetter has a method to return a TriggerTemplateInterface.
// A group's client should implement this interface.
type TriggerTemplatesGetter interface {
        TriggerTemplates(namespace string) TriggerTemplateInterface
}

// TriggerTemplateInterface has methods to work with TriggerTemplate resources.
type TriggerTemplateInterface interface {
        Create(ctx context.Context, triggerTemplate *triggersv1beta1.TriggerTemplate, opts v1.CreateOptions) (*triggersv1beta1.TriggerTemplate, error)
        Update(ctx context.Context, triggerTemplate *triggersv1beta1.TriggerTemplate, opts v1.UpdateOptions) (*triggersv1beta1.TriggerTemplate, error)
        // Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().
        UpdateStatus(ctx context.Context, triggerTemplate *triggersv1beta1.TriggerTemplate, opts v1.UpdateOptions) (*triggersv1beta1.TriggerTemplate, error)
        Delete(ctx context.Context, name string, opts v1.DeleteOptions) error
        DeleteCollection(ctx context.Context, opts v1.DeleteOptions, listOpts v1.ListOptions) error
        Get(ctx context.Context, name string, opts v1.GetOptions) (*triggersv1beta1.TriggerTemplate, error)
        List(ctx context.Context, opts v1.ListOptions) (*triggersv1beta1.TriggerTemplateList, error)
        Watch(ctx context.Context, opts v1.ListOptions) (watch.Interface, error)
        Patch(ctx context.Context, name string, pt types.PatchType, data []byte, opts v1.PatchOptions, subresources ...string) (result *triggersv1beta1.TriggerTemplate, err error)
        TriggerTemplateExpansion
}

// triggerTemplates implements TriggerTemplateInterface
type triggerTemplates struct {
        *gentype.ClientWithList[*triggersv1beta1.TriggerTemplate, *triggersv1beta1.TriggerTemplateList]
}

// newTriggerTemplates returns a TriggerTemplates
func newTriggerTemplates(c *TriggersV1beta1Client, namespace string) *triggerTemplates <span class="cov0" title="0">{
        return &amp;triggerTemplates{
                gentype.NewClientWithList[*triggersv1beta1.TriggerTemplate, *triggersv1beta1.TriggerTemplateList](
                        "triggertemplates",
                        c.RESTClient(),
                        scheme.ParameterCodec,
                        namespace,
                        func() *triggersv1beta1.TriggerTemplate </span><span class="cov0" title="0">{ return &amp;triggersv1beta1.TriggerTemplate{} }</span>,
                        func() *triggersv1beta1.TriggerTemplateList <span class="cov0" title="0">{ return &amp;triggersv1beta1.TriggerTemplateList{} }</span>,
                ),
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package clientset

import (
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/dynamic"
)

// Clientset maps GroupVersionResources to underlying dynamic clients. If the
// GVR does not exist, operations will return an error.
type Clientset struct {
        config map[schema.GroupVersionResource]dynamic.Interface
}

// Option defines optional configuration for the Clientset. Most commonly used
// to initialize extensions.
type Option func(*Clientset)

// Add adds a new mapping for the given resource.
func (r *Clientset) Add(resource schema.GroupVersionResource, client dynamic.Interface) <span class="cov0" title="0">{
        r.config[resource] = client
}</span>

// Resource returns the dynamic Resource for the given GVR. If not configured,
// an error resource is returned.
func (r *Clientset) Resource(resource schema.GroupVersionResource) dynamic.NamespaceableResourceInterface <span class="cov0" title="0">{
        i, ok := r.config[resource]
        if !ok </span><span class="cov0" title="0">{
                return newErrorResource(resource)
        }</span>
        <span class="cov0" title="0">return i.Resource(resource)</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package clientset

import (
        "context"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/types"
        "k8s.io/apimachinery/pkg/watch"
        "k8s.io/client-go/dynamic"
)

// revive:disable:unused-parameter

func newErrorResource(r schema.GroupVersionResource) errorResourceInterface <span class="cov0" title="0">{
        return errorResourceInterface{resource: r}
}</span>

type errorResourceInterface struct {
        resource schema.GroupVersionResource
}

func (i errorResourceInterface) Namespace(string) dynamic.ResourceInterface <span class="cov0" title="0">{
        return i
}</span>

func (i errorResourceInterface) err() error <span class="cov0" title="0">{
        return fmt.Errorf("resource %+v not supported", i.resource)
}</span>

func (i errorResourceInterface) Create(ctx context.Context, obj *unstructured.Unstructured, options metav1.CreateOptions, subresources ...string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) Update(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions, subresources ...string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) UpdateStatus(ctx context.Context, obj *unstructured.Unstructured, options metav1.UpdateOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) Delete(ctx context.Context, name string, options metav1.DeleteOptions, subresources ...string) error <span class="cov0" title="0">{
        return i.err()
}</span>

func (i errorResourceInterface) DeleteCollection(ctx context.Context, options metav1.DeleteOptions, listOptions metav1.ListOptions) error <span class="cov0" title="0">{
        return i.err()
}</span>

func (i errorResourceInterface) Get(ctx context.Context, name string, options metav1.GetOptions, subresources ...string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) List(ctx context.Context, opts metav1.ListOptions) (*unstructured.UnstructuredList, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) Watch(ctx context.Context, opts metav1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) Patch(ctx context.Context, name string, pt types.PatchType, data []byte, options metav1.PatchOptions, subresources ...string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) Apply(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions, subresources ...string) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

func (i errorResourceInterface) ApplyStatus(ctx context.Context, name string, obj *unstructured.Unstructured, options metav1.ApplyOptions) (*unstructured.Unstructured, error) <span class="cov0" title="0">{
        return nil, i.err()
}</span>

// revive:enable:unused-parameter
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        reflect "reflect"
        sync "sync"
        time "time"

        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggers "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// SharedInformerOption defines the functional option type for SharedInformerFactory.
type SharedInformerOption func(*sharedInformerFactory) *sharedInformerFactory

type sharedInformerFactory struct {
        client           versioned.Interface
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        lock             sync.Mutex
        defaultResync    time.Duration
        customResync     map[reflect.Type]time.Duration
        transform        cache.TransformFunc

        informers map[reflect.Type]cache.SharedIndexInformer
        // startedInformers is used for tracking which informers have been started.
        // This allows Start() to be called multiple times safely.
        startedInformers map[reflect.Type]bool
        // wg tracks how many goroutines were started.
        wg sync.WaitGroup
        // shuttingDown is true when Shutdown has been called. It may still be running
        // because it needs to wait for goroutines.
        shuttingDown bool
}

// WithCustomResyncConfig sets a custom resync period for the specified informer types.
func WithCustomResyncConfig(resyncConfig map[v1.Object]time.Duration) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                for k, v := range resyncConfig </span><span class="cov0" title="0">{
                        factory.customResync[reflect.TypeOf(k)] = v
                }</span>
                <span class="cov0" title="0">return factory</span>
        }
}

// WithTweakListOptions sets a custom filter on all listers of the configured SharedInformerFactory.
func WithTweakListOptions(tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.tweakListOptions = tweakListOptions
                return factory
        }</span>
}

// WithNamespace limits the SharedInformerFactory to the specified namespace.
func WithNamespace(namespace string) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.namespace = namespace
                return factory
        }</span>
}

// WithTransform sets a transform on all informers.
func WithTransform(transform cache.TransformFunc) SharedInformerOption <span class="cov0" title="0">{
        return func(factory *sharedInformerFactory) *sharedInformerFactory </span><span class="cov0" title="0">{
                factory.transform = transform
                return factory
        }</span>
}

// NewSharedInformerFactory constructs a new instance of sharedInformerFactory for all namespaces.
func NewSharedInformerFactory(client versioned.Interface, defaultResync time.Duration) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync)
}</span>

// NewFilteredSharedInformerFactory constructs a new instance of sharedInformerFactory.
// Listers obtained via this SharedInformerFactory will be subject to the same filters
// as specified here.
// Deprecated: Please use NewSharedInformerFactoryWithOptions instead
func NewFilteredSharedInformerFactory(client versioned.Interface, defaultResync time.Duration, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) SharedInformerFactory <span class="cov0" title="0">{
        return NewSharedInformerFactoryWithOptions(client, defaultResync, WithNamespace(namespace), WithTweakListOptions(tweakListOptions))
}</span>

// NewSharedInformerFactoryWithOptions constructs a new instance of a SharedInformerFactory with additional options.
func NewSharedInformerFactoryWithOptions(client versioned.Interface, defaultResync time.Duration, options ...SharedInformerOption) SharedInformerFactory <span class="cov0" title="0">{
        factory := &amp;sharedInformerFactory{
                client:           client,
                namespace:        v1.NamespaceAll,
                defaultResync:    defaultResync,
                informers:        make(map[reflect.Type]cache.SharedIndexInformer),
                startedInformers: make(map[reflect.Type]bool),
                customResync:     make(map[reflect.Type]time.Duration),
        }

        // Apply all options
        for _, opt := range options </span><span class="cov0" title="0">{
                factory = opt(factory)
        }</span>

        <span class="cov0" title="0">return factory</span>
}

func (f *sharedInformerFactory) Start(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        if f.shuttingDown </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                if !f.startedInformers[informerType] </span><span class="cov0" title="0">{
                        f.wg.Add(1)
                        // We need a new variable in each loop iteration,
                        // otherwise the goroutine would use the loop variable
                        // and that keeps changing.
                        informer := informer
                        go func() </span><span class="cov0" title="0">{
                                defer f.wg.Done()
                                informer.Run(stopCh)
                        }</span>()
                        <span class="cov0" title="0">f.startedInformers[informerType] = true</span>
                }
        }
}

func (f *sharedInformerFactory) Shutdown() <span class="cov0" title="0">{
        f.lock.Lock()
        f.shuttingDown = true
        f.lock.Unlock()

        // Will return immediately if there is nothing to wait for.
        f.wg.Wait()
}</span>

func (f *sharedInformerFactory) WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool <span class="cov0" title="0">{
        informers := func() map[reflect.Type]cache.SharedIndexInformer </span><span class="cov0" title="0">{
                f.lock.Lock()
                defer f.lock.Unlock()

                informers := map[reflect.Type]cache.SharedIndexInformer{}
                for informerType, informer := range f.informers </span><span class="cov0" title="0">{
                        if f.startedInformers[informerType] </span><span class="cov0" title="0">{
                                informers[informerType] = informer
                        }</span>
                }
                <span class="cov0" title="0">return informers</span>
        }()

        <span class="cov0" title="0">res := map[reflect.Type]bool{}
        for informType, informer := range informers </span><span class="cov0" title="0">{
                res[informType] = cache.WaitForCacheSync(stopCh, informer.HasSynced)
        }</span>
        <span class="cov0" title="0">return res</span>
}

// InformerFor returns the SharedIndexInformer for obj using an internal
// client.
func (f *sharedInformerFactory) InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        f.lock.Lock()
        defer f.lock.Unlock()

        informerType := reflect.TypeOf(obj)
        informer, exists := f.informers[informerType]
        if exists </span><span class="cov0" title="0">{
                return informer
        }</span>

        <span class="cov0" title="0">resyncPeriod, exists := f.customResync[informerType]
        if !exists </span><span class="cov0" title="0">{
                resyncPeriod = f.defaultResync
        }</span>

        <span class="cov0" title="0">informer = newFunc(f.client, resyncPeriod)
        informer.SetTransform(f.transform)
        f.informers[informerType] = informer

        return informer</span>
}

// SharedInformerFactory provides shared informers for resources in all known
// API group versions.
//
// It is typically used like this:
//
//        ctx, cancel := context.Background()
//        defer cancel()
//        factory := NewSharedInformerFactory(client, resyncPeriod)
//        defer factory.WaitForStop()    // Returns immediately if nothing was started.
//        genericInformer := factory.ForResource(resource)
//        typedInformer := factory.SomeAPIGroup().V1().SomeType()
//        factory.Start(ctx.Done())          // Start processing these informers.
//        synced := factory.WaitForCacheSync(ctx.Done())
//        for v, ok := range synced {
//            if !ok {
//                fmt.Fprintf(os.Stderr, "caches failed to sync: %v", v)
//                return
//            }
//        }
//
//        // Creating informers can also be created after Start, but then
//        // Start must be called again:
//        anotherGenericInformer := factory.ForResource(resource)
//        factory.Start(ctx.Done())
type SharedInformerFactory interface {
        internalinterfaces.SharedInformerFactory

        // Start initializes all requested informers. They are handled in goroutines
        // which run until the stop channel gets closed.
        // Warning: Start does not block. When run in a go-routine, it will race with a later WaitForCacheSync.
        Start(stopCh &lt;-chan struct{})

        // Shutdown marks a factory as shutting down. At that point no new
        // informers can be started anymore and Start will return without
        // doing anything.
        //
        // In addition, Shutdown blocks until all goroutines have terminated. For that
        // to happen, the close channel(s) that they were started with must be closed,
        // either before Shutdown gets called or while it is waiting.
        //
        // Shutdown may be called multiple times, even concurrently. All such calls will
        // block until all goroutines have terminated.
        Shutdown()

        // WaitForCacheSync blocks until all started informers' caches were synced
        // or the stop channel gets closed.
        WaitForCacheSync(stopCh &lt;-chan struct{}) map[reflect.Type]bool

        // ForResource gives generic access to a shared informer of the matching type.
        ForResource(resource schema.GroupVersionResource) (GenericInformer, error)

        // InformerFor returns the SharedIndexInformer for obj using an internal
        // client.
        InformerFor(obj runtime.Object, newFunc internalinterfaces.NewInformerFunc) cache.SharedIndexInformer

        Triggers() triggers.Interface
}

func (f *sharedInformerFactory) Triggers() triggers.Interface <span class="cov0" title="0">{
        return triggers.New(f, f.namespace, f.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package externalversions

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        schema "k8s.io/apimachinery/pkg/runtime/schema"
        cache "k8s.io/client-go/tools/cache"
)

// GenericInformer is type of SharedIndexInformer which will locate and delegate to other
// sharedInformers based on type
type GenericInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() cache.GenericLister
}

type genericInformer struct {
        informer cache.SharedIndexInformer
        resource schema.GroupResource
}

// Informer returns the SharedIndexInformer.
func (f *genericInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.informer
}</span>

// Lister returns the GenericLister.
func (f *genericInformer) Lister() cache.GenericLister <span class="cov0" title="0">{
        return cache.NewGenericLister(f.Informer().GetIndexer(), f.resource)
}</span>

// ForResource gives generic access to a shared informer of the matching type
// TODO extend this to unknown resources with a client pool
func (f *sharedInformerFactory) ForResource(resource schema.GroupVersionResource) (GenericInformer, error) <span class="cov0" title="0">{
        switch resource </span>{
        // Group=triggers.tekton.dev, Version=v1alpha1
        case v1alpha1.SchemeGroupVersion.WithResource("clusterinterceptors"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1alpha1().ClusterInterceptors().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("clustertriggerbindings"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1alpha1().ClusterTriggerBindings().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("eventlisteners"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1alpha1().EventListeners().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("interceptors"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1alpha1().Interceptors().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("triggers"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1alpha1().Triggers().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("triggerbindings"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1alpha1().TriggerBindings().Informer()}, nil</span>
        case v1alpha1.SchemeGroupVersion.WithResource("triggertemplates"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1alpha1().TriggerTemplates().Informer()}, nil</span>

                // Group=triggers.tekton.dev, Version=v1beta1
        case v1beta1.SchemeGroupVersion.WithResource("clustertriggerbindings"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1beta1().ClusterTriggerBindings().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("eventlisteners"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1beta1().EventListeners().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("triggers"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1beta1().Triggers().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("triggerbindings"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1beta1().TriggerBindings().Informer()}, nil</span>
        case v1beta1.SchemeGroupVersion.WithResource("triggertemplates"):<span class="cov0" title="0">
                return &amp;genericInformer{resource: resource.GroupResource(), informer: f.Triggers().V1beta1().TriggerTemplates().Informer()}, nil</span>

        }

        <span class="cov0" title="0">return nil, fmt.Errorf("no informer found for %v", resource)</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package triggers

import (
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
)

// Interface provides access to each of this group's versions.
type Interface interface {
        // V1alpha1 provides access to shared informers for resources in V1alpha1.
        V1alpha1() v1alpha1.Interface
        // V1beta1 provides access to shared informers for resources in V1beta1.
        V1beta1() v1beta1.Interface
}

type group struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;group{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// V1alpha1 returns a new v1alpha1.Interface.
func (g *group) V1alpha1() v1alpha1.Interface <span class="cov0" title="0">{
        return v1alpha1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>

// V1beta1 returns a new v1beta1.Interface.
func (g *group) V1beta1() v1beta1.Interface <span class="cov0" title="0">{
        return v1beta1.New(g.factory, g.namespace, g.tweakListOptions)
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apistriggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// ClusterInterceptorInformer provides access to a shared informer and lister for
// ClusterInterceptors.
type ClusterInterceptorInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1alpha1.ClusterInterceptorLister
}

type clusterInterceptorInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// NewClusterInterceptorInformer constructs a new informer for ClusterInterceptor type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewClusterInterceptorInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredClusterInterceptorInformer(client, resyncPeriod, indexers, nil)
}</span>

// NewFilteredClusterInterceptorInformer constructs a new informer for ClusterInterceptor type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredClusterInterceptorInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().ClusterInterceptors().List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().ClusterInterceptors().Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1alpha1.ClusterInterceptor{},
                resyncPeriod,
                indexers,
        )
}

func (f *clusterInterceptorInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredClusterInterceptorInformer(client, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *clusterInterceptorInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1alpha1.ClusterInterceptor{}, f.defaultInformer)
}</span>

func (f *clusterInterceptorInformer) Lister() triggersv1alpha1.ClusterInterceptorLister <span class="cov0" title="0">{
        return triggersv1alpha1.NewClusterInterceptorLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apistriggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// ClusterTriggerBindingInformer provides access to a shared informer and lister for
// ClusterTriggerBindings.
type ClusterTriggerBindingInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1alpha1.ClusterTriggerBindingLister
}

type clusterTriggerBindingInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// NewClusterTriggerBindingInformer constructs a new informer for ClusterTriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewClusterTriggerBindingInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredClusterTriggerBindingInformer(client, resyncPeriod, indexers, nil)
}</span>

// NewFilteredClusterTriggerBindingInformer constructs a new informer for ClusterTriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredClusterTriggerBindingInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().ClusterTriggerBindings().List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().ClusterTriggerBindings().Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1alpha1.ClusterTriggerBinding{},
                resyncPeriod,
                indexers,
        )
}

func (f *clusterTriggerBindingInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredClusterTriggerBindingInformer(client, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *clusterTriggerBindingInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1alpha1.ClusterTriggerBinding{}, f.defaultInformer)
}</span>

func (f *clusterTriggerBindingInformer) Lister() triggersv1alpha1.ClusterTriggerBindingLister <span class="cov0" title="0">{
        return triggersv1alpha1.NewClusterTriggerBindingLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apistriggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// EventListenerInformer provides access to a shared informer and lister for
// EventListeners.
type EventListenerInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1alpha1.EventListenerLister
}

type eventListenerInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewEventListenerInformer constructs a new informer for EventListener type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewEventListenerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredEventListenerInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredEventListenerInformer constructs a new informer for EventListener type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredEventListenerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().EventListeners(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().EventListeners(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1alpha1.EventListener{},
                resyncPeriod,
                indexers,
        )
}

func (f *eventListenerInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredEventListenerInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *eventListenerInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1alpha1.EventListener{}, f.defaultInformer)
}</span>

func (f *eventListenerInformer) Lister() triggersv1alpha1.EventListenerLister <span class="cov0" title="0">{
        return triggersv1alpha1.NewEventListenerLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apistriggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// InterceptorInformer provides access to a shared informer and lister for
// Interceptors.
type InterceptorInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1alpha1.InterceptorLister
}

type interceptorInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewInterceptorInformer constructs a new informer for Interceptor type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewInterceptorInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredInterceptorInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredInterceptorInformer constructs a new informer for Interceptor type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredInterceptorInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().Interceptors(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().Interceptors(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1alpha1.Interceptor{},
                resyncPeriod,
                indexers,
        )
}

func (f *interceptorInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredInterceptorInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *interceptorInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1alpha1.Interceptor{}, f.defaultInformer)
}</span>

func (f *interceptorInformer) Lister() triggersv1alpha1.InterceptorLister <span class="cov0" title="0">{
        return triggersv1alpha1.NewInterceptorLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // ClusterInterceptors returns a ClusterInterceptorInformer.
        ClusterInterceptors() ClusterInterceptorInformer
        // ClusterTriggerBindings returns a ClusterTriggerBindingInformer.
        ClusterTriggerBindings() ClusterTriggerBindingInformer
        // EventListeners returns a EventListenerInformer.
        EventListeners() EventListenerInformer
        // Interceptors returns a InterceptorInformer.
        Interceptors() InterceptorInformer
        // Triggers returns a TriggerInformer.
        Triggers() TriggerInformer
        // TriggerBindings returns a TriggerBindingInformer.
        TriggerBindings() TriggerBindingInformer
        // TriggerTemplates returns a TriggerTemplateInformer.
        TriggerTemplates() TriggerTemplateInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// ClusterInterceptors returns a ClusterInterceptorInformer.
func (v *version) ClusterInterceptors() ClusterInterceptorInformer <span class="cov0" title="0">{
        return &amp;clusterInterceptorInformer{factory: v.factory, tweakListOptions: v.tweakListOptions}
}</span>

// ClusterTriggerBindings returns a ClusterTriggerBindingInformer.
func (v *version) ClusterTriggerBindings() ClusterTriggerBindingInformer <span class="cov0" title="0">{
        return &amp;clusterTriggerBindingInformer{factory: v.factory, tweakListOptions: v.tweakListOptions}
}</span>

// EventListeners returns a EventListenerInformer.
func (v *version) EventListeners() EventListenerInformer <span class="cov0" title="0">{
        return &amp;eventListenerInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// Interceptors returns a InterceptorInformer.
func (v *version) Interceptors() InterceptorInformer <span class="cov0" title="0">{
        return &amp;interceptorInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// Triggers returns a TriggerInformer.
func (v *version) Triggers() TriggerInformer <span class="cov0" title="0">{
        return &amp;triggerInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// TriggerBindings returns a TriggerBindingInformer.
func (v *version) TriggerBindings() TriggerBindingInformer <span class="cov0" title="0">{
        return &amp;triggerBindingInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// TriggerTemplates returns a TriggerTemplateInformer.
func (v *version) TriggerTemplates() TriggerTemplateInformer <span class="cov0" title="0">{
        return &amp;triggerTemplateInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apistriggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerInformer provides access to a shared informer and lister for
// Triggers.
type TriggerInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1alpha1.TriggerLister
}

type triggerInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTriggerInformer constructs a new informer for Trigger type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTriggerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTriggerInformer constructs a new informer for Trigger type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTriggerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().Triggers(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().Triggers(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1alpha1.Trigger{},
                resyncPeriod,
                indexers,
        )
}

func (f *triggerInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *triggerInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1alpha1.Trigger{}, f.defaultInformer)
}</span>

func (f *triggerInformer) Lister() triggersv1alpha1.TriggerLister <span class="cov0" title="0">{
        return triggersv1alpha1.NewTriggerLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apistriggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerBindingInformer provides access to a shared informer and lister for
// TriggerBindings.
type TriggerBindingInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1alpha1.TriggerBindingLister
}

type triggerBindingInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTriggerBindingInformer constructs a new informer for TriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTriggerBindingInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerBindingInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTriggerBindingInformer constructs a new informer for TriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTriggerBindingInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().TriggerBindings(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().TriggerBindings(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1alpha1.TriggerBinding{},
                resyncPeriod,
                indexers,
        )
}

func (f *triggerBindingInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerBindingInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *triggerBindingInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1alpha1.TriggerBinding{}, f.defaultInformer)
}</span>

func (f *triggerBindingInformer) Lister() triggersv1alpha1.TriggerBindingLister <span class="cov0" title="0">{
        return triggersv1alpha1.NewTriggerBindingLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1alpha1

import (
        context "context"
        time "time"

        apistriggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerTemplateInformer provides access to a shared informer and lister for
// TriggerTemplates.
type TriggerTemplateInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1alpha1.TriggerTemplateLister
}

type triggerTemplateInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTriggerTemplateInformer constructs a new informer for TriggerTemplate type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTriggerTemplateInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerTemplateInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTriggerTemplateInformer constructs a new informer for TriggerTemplate type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTriggerTemplateInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().TriggerTemplates(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1alpha1().TriggerTemplates(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1alpha1.TriggerTemplate{},
                resyncPeriod,
                indexers,
        )
}

func (f *triggerTemplateInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerTemplateInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *triggerTemplateInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1alpha1.TriggerTemplate{}, f.defaultInformer)
}</span>

func (f *triggerTemplateInformer) Lister() triggersv1alpha1.TriggerTemplateLister <span class="cov0" title="0">{
        return triggersv1alpha1.NewTriggerTemplateLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apistriggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// ClusterTriggerBindingInformer provides access to a shared informer and lister for
// ClusterTriggerBindings.
type ClusterTriggerBindingInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1beta1.ClusterTriggerBindingLister
}

type clusterTriggerBindingInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// NewClusterTriggerBindingInformer constructs a new informer for ClusterTriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewClusterTriggerBindingInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredClusterTriggerBindingInformer(client, resyncPeriod, indexers, nil)
}</span>

// NewFilteredClusterTriggerBindingInformer constructs a new informer for ClusterTriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredClusterTriggerBindingInformer(client versioned.Interface, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().ClusterTriggerBindings().List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().ClusterTriggerBindings().Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1beta1.ClusterTriggerBinding{},
                resyncPeriod,
                indexers,
        )
}

func (f *clusterTriggerBindingInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredClusterTriggerBindingInformer(client, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *clusterTriggerBindingInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1beta1.ClusterTriggerBinding{}, f.defaultInformer)
}</span>

func (f *clusterTriggerBindingInformer) Lister() triggersv1beta1.ClusterTriggerBindingLister <span class="cov0" title="0">{
        return triggersv1beta1.NewClusterTriggerBindingLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apistriggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// EventListenerInformer provides access to a shared informer and lister for
// EventListeners.
type EventListenerInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1beta1.EventListenerLister
}

type eventListenerInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewEventListenerInformer constructs a new informer for EventListener type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewEventListenerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredEventListenerInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredEventListenerInformer constructs a new informer for EventListener type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredEventListenerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().EventListeners(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().EventListeners(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1beta1.EventListener{},
                resyncPeriod,
                indexers,
        )
}

func (f *eventListenerInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredEventListenerInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *eventListenerInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1beta1.EventListener{}, f.defaultInformer)
}</span>

func (f *eventListenerInformer) Lister() triggersv1beta1.EventListenerLister <span class="cov0" title="0">{
        return triggersv1beta1.NewEventListenerLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
)

// Interface provides access to all the informers in this group version.
type Interface interface {
        // ClusterTriggerBindings returns a ClusterTriggerBindingInformer.
        ClusterTriggerBindings() ClusterTriggerBindingInformer
        // EventListeners returns a EventListenerInformer.
        EventListeners() EventListenerInformer
        // Triggers returns a TriggerInformer.
        Triggers() TriggerInformer
        // TriggerBindings returns a TriggerBindingInformer.
        TriggerBindings() TriggerBindingInformer
        // TriggerTemplates returns a TriggerTemplateInformer.
        TriggerTemplates() TriggerTemplateInformer
}

type version struct {
        factory          internalinterfaces.SharedInformerFactory
        namespace        string
        tweakListOptions internalinterfaces.TweakListOptionsFunc
}

// New returns a new Interface.
func New(f internalinterfaces.SharedInformerFactory, namespace string, tweakListOptions internalinterfaces.TweakListOptionsFunc) Interface <span class="cov0" title="0">{
        return &amp;version{factory: f, namespace: namespace, tweakListOptions: tweakListOptions}
}</span>

// ClusterTriggerBindings returns a ClusterTriggerBindingInformer.
func (v *version) ClusterTriggerBindings() ClusterTriggerBindingInformer <span class="cov0" title="0">{
        return &amp;clusterTriggerBindingInformer{factory: v.factory, tweakListOptions: v.tweakListOptions}
}</span>

// EventListeners returns a EventListenerInformer.
func (v *version) EventListeners() EventListenerInformer <span class="cov0" title="0">{
        return &amp;eventListenerInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// Triggers returns a TriggerInformer.
func (v *version) Triggers() TriggerInformer <span class="cov0" title="0">{
        return &amp;triggerInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// TriggerBindings returns a TriggerBindingInformer.
func (v *version) TriggerBindings() TriggerBindingInformer <span class="cov0" title="0">{
        return &amp;triggerBindingInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>

// TriggerTemplates returns a TriggerTemplateInformer.
func (v *version) TriggerTemplates() TriggerTemplateInformer <span class="cov0" title="0">{
        return &amp;triggerTemplateInformer{factory: v.factory, namespace: v.namespace, tweakListOptions: v.tweakListOptions}
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apistriggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerInformer provides access to a shared informer and lister for
// Triggers.
type TriggerInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1beta1.TriggerLister
}

type triggerInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTriggerInformer constructs a new informer for Trigger type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTriggerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTriggerInformer constructs a new informer for Trigger type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTriggerInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().Triggers(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().Triggers(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1beta1.Trigger{},
                resyncPeriod,
                indexers,
        )
}

func (f *triggerInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *triggerInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1beta1.Trigger{}, f.defaultInformer)
}</span>

func (f *triggerInformer) Lister() triggersv1beta1.TriggerLister <span class="cov0" title="0">{
        return triggersv1beta1.NewTriggerLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apistriggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerBindingInformer provides access to a shared informer and lister for
// TriggerBindings.
type TriggerBindingInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1beta1.TriggerBindingLister
}

type triggerBindingInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTriggerBindingInformer constructs a new informer for TriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTriggerBindingInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerBindingInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTriggerBindingInformer constructs a new informer for TriggerBinding type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTriggerBindingInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().TriggerBindings(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().TriggerBindings(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1beta1.TriggerBinding{},
                resyncPeriod,
                indexers,
        )
}

func (f *triggerBindingInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerBindingInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *triggerBindingInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1beta1.TriggerBinding{}, f.defaultInformer)
}</span>

func (f *triggerBindingInformer) Lister() triggersv1beta1.TriggerBindingLister <span class="cov0" title="0">{
        return triggersv1beta1.NewTriggerBindingLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by informer-gen. DO NOT EDIT.

package v1beta1

import (
        context "context"
        time "time"

        apistriggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        internalinterfaces "github.com/tektoncd/triggers/pkg/client/informers/externalversions/internalinterfaces"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
        watch "k8s.io/apimachinery/pkg/watch"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerTemplateInformer provides access to a shared informer and lister for
// TriggerTemplates.
type TriggerTemplateInformer interface {
        Informer() cache.SharedIndexInformer
        Lister() triggersv1beta1.TriggerTemplateLister
}

type triggerTemplateInformer struct {
        factory          internalinterfaces.SharedInformerFactory
        tweakListOptions internalinterfaces.TweakListOptionsFunc
        namespace        string
}

// NewTriggerTemplateInformer constructs a new informer for TriggerTemplate type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewTriggerTemplateInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerTemplateInformer(client, namespace, resyncPeriod, indexers, nil)
}</span>

// NewFilteredTriggerTemplateInformer constructs a new informer for TriggerTemplate type.
// Always prefer using an informer factory to get a shared informer instead of getting an independent
// one. This reduces memory footprint and number of connections to the server.
func NewFilteredTriggerTemplateInformer(client versioned.Interface, namespace string, resyncPeriod time.Duration, indexers cache.Indexers, tweakListOptions internalinterfaces.TweakListOptionsFunc) cache.SharedIndexInformer <span class="cov0" title="0">{
        return cache.NewSharedIndexInformer(
                &amp;cache.ListWatch{
                        ListFunc: func(options v1.ListOptions) (runtime.Object, error) </span><span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().TriggerTemplates(namespace).List(context.TODO(), options)</span>
                        },
                        WatchFunc: func(options v1.ListOptions) (watch.Interface, error) <span class="cov0" title="0">{
                                if tweakListOptions != nil </span><span class="cov0" title="0">{
                                        tweakListOptions(&amp;options)
                                }</span>
                                <span class="cov0" title="0">return client.TriggersV1beta1().TriggerTemplates(namespace).Watch(context.TODO(), options)</span>
                        },
                },
                &amp;apistriggersv1beta1.TriggerTemplate{},
                resyncPeriod,
                indexers,
        )
}

func (f *triggerTemplateInformer) defaultInformer(client versioned.Interface, resyncPeriod time.Duration) cache.SharedIndexInformer <span class="cov0" title="0">{
        return NewFilteredTriggerTemplateInformer(client, f.namespace, resyncPeriod, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}, f.tweakListOptions)
}</span>

func (f *triggerTemplateInformer) Informer() cache.SharedIndexInformer <span class="cov0" title="0">{
        return f.factory.InformerFor(&amp;apistriggersv1beta1.TriggerTemplate{}, f.defaultInformer)
}</span>

func (f *triggerTemplateInformer) Lister() triggersv1beta1.TriggerTemplateLister <span class="cov0" title="0">{
        return triggersv1beta1.NewTriggerTemplateLister(f.Informer().GetIndexer())
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package client

import (
        context "context"

        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterClient(withClientFromConfig)
        injection.Default.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withClientFromConfig(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, Key{}, versioned.NewForConfigOrDie(cfg))
}</span>

// Get extracts the versioned.Interface client from the context.
func Get(ctx context.Context) versioned.Interface <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                if injection.GetConfig(ctx) == nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/triggers/pkg/client/clientset/versioned.Interface from context. This context is not the application context (which is typically given to constructors via sharedmain).")
                }</span> else<span class="cov0" title="0"> {
                        logging.FromContext(ctx).Panic(
                                "Unable to fetch github.com/tektoncd/triggers/pkg/client/clientset/versioned.Interface from context.")
                }</span>
        }
        <span class="cov0" title="0">return untyped.(versioned.Interface)</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/clientset/versioned/fake"
        client "github.com/tektoncd/triggers/pkg/client/injection/client"
        runtime "k8s.io/apimachinery/pkg/runtime"
        rest "k8s.io/client-go/rest"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterClient(withClient)
        injection.Fake.RegisterClientFetcher(func(ctx context.Context) interface{} </span><span class="cov0" title="0">{
                return Get(ctx)
        }</span>)
}

func withClient(ctx context.Context, cfg *rest.Config) context.Context <span class="cov0" title="0">{
        ctx, _ = With(ctx)
        return ctx
}</span>

func With(ctx context.Context, objects ...runtime.Object) (context.Context, *fake.Clientset) <span class="cov0" title="0">{
        cs := fake.NewSimpleClientset(objects...)
        return context.WithValue(ctx, client.Key{}, cs), cs
}</span>

// Get extracts the Kubernetes client from the context.
func Get(ctx context.Context) *fake.Clientset <span class="cov0" title="0">{
        untyped := ctx.Value(client.Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/clientset/versioned/fake.Clientset from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(*fake.Clientset)</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package factory

import (
        context "context"

        externalversions "github.com/tektoncd/triggers/pkg/client/informers/externalversions"
        client "github.com/tektoncd/triggers/pkg/client/injection/client"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct{}

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions.SharedInformerFactory from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        externalversions "github.com/tektoncd/triggers/pkg/client/informers/externalversions"
        fake "github.com/tektoncd/triggers/pkg/client/injection/client/fake"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = factory.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        opts := make([]externalversions.SharedInformerOption, 0, 1)
        if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, factory.Key{},
                externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fakeFilteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/triggers/pkg/client/informers/externalversions"
        fake "github.com/tektoncd/triggers/pkg/client/injection/client/fake"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformerFactory(withInformerFactory)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := fake.Get(ctx)
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, filtered.Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filteredFactory

import (
        context "context"

        externalversions "github.com/tektoncd/triggers/pkg/client/informers/externalversions"
        client "github.com/tektoncd/triggers/pkg/client/injection/client"
        v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformerFactory(withInformerFactory)
}</span>

// Key is used as the key for associating information with a context.Context.
type Key struct {
        Selector string
}

type LabelKey struct{}

func WithSelectors(ctx context.Context, selector ...string) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, LabelKey{}, selector)
}</span>

func withInformerFactory(ctx context.Context) context.Context <span class="cov0" title="0">{
        c := client.Get(ctx)
        untyped := ctx.Value(LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                selectorVal := selector
                opts := []externalversions.SharedInformerOption{}
                if injection.HasNamespaceScope(ctx) </span><span class="cov0" title="0">{
                        opts = append(opts, externalversions.WithNamespace(injection.GetNamespaceScope(ctx)))
                }</span>
                <span class="cov0" title="0">opts = append(opts, externalversions.WithTweakListOptions(func(l *v1.ListOptions) </span><span class="cov0" title="0">{
                        l.LabelSelector = selectorVal
                }</span>))
                <span class="cov0" title="0">ctx = context.WithValue(ctx, Key{Selector: selectorVal},
                        externalversions.NewSharedInformerFactoryWithOptions(c, controller.GetResyncPeriod(ctx), opts...))</span>
        }
        <span class="cov0" title="0">return ctx</span>
}

// Get extracts the InformerFactory from the context.
func Get(ctx context.Context, selector string) externalversions.SharedInformerFactory <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions.SharedInformerFactory with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(externalversions.SharedInformerFactory)</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package clusterinterceptor

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1alpha1().ClusterInterceptors()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.ClusterInterceptorInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.ClusterInterceptorInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ClusterInterceptorInformer)</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        clusterinterceptor "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = clusterinterceptor.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1alpha1().ClusterInterceptors()
        return context.WithValue(ctx, clusterinterceptor.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().ClusterInterceptors()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.ClusterInterceptorInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.ClusterInterceptorInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ClusterInterceptorInformer)</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().ClusterInterceptors()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package clustertriggerbinding

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1alpha1().ClusterTriggerBindings()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.ClusterTriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.ClusterTriggerBindingInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ClusterTriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        clustertriggerbinding "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clustertriggerbinding"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = clustertriggerbinding.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1alpha1().ClusterTriggerBindings()
        return context.WithValue(ctx, clustertriggerbinding.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file110" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().ClusterTriggerBindings()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.ClusterTriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.ClusterTriggerBindingInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.ClusterTriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clustertriggerbinding/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().ClusterTriggerBindings()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1alpha1().EventListeners()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.EventListenerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.EventListenerInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.EventListenerInformer)</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        eventlistener "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/eventlistener"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = eventlistener.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1alpha1().EventListeners()
        return context.WithValue(ctx, eventlistener.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().EventListeners()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.EventListenerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.EventListenerInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.EventListenerInformer)</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/eventlistener/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().EventListeners()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        interceptor "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = interceptor.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1alpha1().Interceptors()
        return context.WithValue(ctx, interceptor.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().Interceptors()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().Interceptors()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.InterceptorInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.InterceptorInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.InterceptorInformer)</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package interceptor

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1alpha1().Interceptors()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.InterceptorInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.InterceptorInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.InterceptorInformer)</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        trigger "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/trigger"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = trigger.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1alpha1().Triggers()
        return context.WithValue(ctx, trigger.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/trigger/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().Triggers()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().Triggers()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.TriggerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.TriggerInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.TriggerInformer)</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package trigger

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1alpha1().Triggers()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.TriggerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.TriggerInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.TriggerInformer)</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        triggerbinding "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggerbinding"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = triggerbinding.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1alpha1().TriggerBindings()
        return context.WithValue(ctx, triggerbinding.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggerbinding/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().TriggerBindings()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().TriggerBindings()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.TriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.TriggerBindingInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.TriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package triggerbinding

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1alpha1().TriggerBindings()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.TriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.TriggerBindingInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.TriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        triggertemplate "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggertemplate"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = triggertemplate.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1alpha1().TriggerTemplates()
        return context.WithValue(ctx, triggertemplate.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/triggertemplate/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().TriggerTemplates()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1alpha1().TriggerTemplates()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1alpha1.TriggerTemplateInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.TriggerTemplateInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.TriggerTemplateInformer)</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package triggertemplate

import (
        context "context"

        v1alpha1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1alpha1().TriggerTemplates()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1alpha1.TriggerTemplateInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1alpha1.TriggerTemplateInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1alpha1.TriggerTemplateInformer)</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package clustertriggerbinding

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1beta1().ClusterTriggerBindings()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.ClusterTriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.ClusterTriggerBindingInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.ClusterTriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        clustertriggerbinding "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = clustertriggerbinding.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1beta1().ClusterTriggerBindings()
        return context.WithValue(ctx, clustertriggerbinding.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().ClusterTriggerBindings()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.ClusterTriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.ClusterTriggerBindingInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.ClusterTriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file135" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().ClusterTriggerBindings()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1beta1().EventListeners()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.EventListenerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.EventListenerInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.EventListenerInformer)</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        eventlistener "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = eventlistener.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1beta1().EventListeners()
        return context.WithValue(ctx, eventlistener.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().EventListeners()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.EventListenerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.EventListenerInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.EventListenerInformer)</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().EventListeners()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        trigger "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = trigger.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1beta1().Triggers()
        return context.WithValue(ctx, trigger.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().Triggers()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().Triggers()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.TriggerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.TriggerInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TriggerInformer)</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package trigger

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1beta1().Triggers()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.TriggerInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.TriggerInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TriggerInformer)</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        triggerbinding "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = triggerbinding.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1beta1().TriggerBindings()
        return context.WithValue(ctx, triggerbinding.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().TriggerBindings()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().TriggerBindings()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.TriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.TriggerBindingInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package triggerbinding

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1beta1().TriggerBindings()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.TriggerBindingInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.TriggerBindingInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TriggerBindingInformer)</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        fake "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/fake"
        triggertemplate "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
)

var Get = triggertemplate.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterInformer(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := fake.Get(ctx)
        inf := f.Triggers().V1beta1().TriggerTemplates()
        return context.WithValue(ctx, triggertemplate.Key{}, inf), inf.Informer()
}</span>
</pre>
		
		<pre class="file" id="file149" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package fake

import (
        context "context"

        factoryfiltered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

var Get = filtered.Get

func init() <span class="cov0" title="0">{
        injection.Fake.RegisterFilteredInformers(withInformer)
}</span>

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(factoryfiltered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := factoryfiltered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().TriggerTemplates()
                ctx = context.WithValue(ctx, filtered.Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package filtered

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        filtered "github.com/tektoncd/triggers/pkg/client/injection/informers/factory/filtered"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterFilteredInformers(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct {
        Selector string
}

func withInformer(ctx context.Context) (context.Context, []controller.Informer) <span class="cov0" title="0">{
        untyped := ctx.Value(filtered.LabelKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch labelkey from context.")
        }</span>
        <span class="cov0" title="0">labelSelectors := untyped.([]string)
        infs := []controller.Informer{}
        for _, selector := range labelSelectors </span><span class="cov0" title="0">{
                f := filtered.Get(ctx, selector)
                inf := f.Triggers().V1beta1().TriggerTemplates()
                ctx = context.WithValue(ctx, Key{Selector: selector}, inf)
                infs = append(infs, inf.Informer())
        }</span>
        <span class="cov0" title="0">return ctx, infs</span>
}

// Get extracts the typed informer from the context.
func Get(ctx context.Context, selector string) v1beta1.TriggerTemplateInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{Selector: selector})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panicf(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.TriggerTemplateInformer with selector %s from context.", selector)
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TriggerTemplateInformer)</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package triggertemplate

import (
        context "context"

        v1beta1 "github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1"
        factory "github.com/tektoncd/triggers/pkg/client/injection/informers/factory"
        controller "knative.dev/pkg/controller"
        injection "knative.dev/pkg/injection"
        logging "knative.dev/pkg/logging"
)

func init() <span class="cov0" title="0">{
        injection.Default.RegisterInformer(withInformer)
}</span>

// Key is used for associating the Informer inside the context.Context.
type Key struct{}

func withInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        f := factory.Get(ctx)
        inf := f.Triggers().V1beta1().TriggerTemplates()
        return context.WithValue(ctx, Key{}, inf), inf.Informer()
}</span>

// Get extracts the typed informer from the context.
func Get(ctx context.Context) v1beta1.TriggerTemplateInformer <span class="cov0" title="0">{
        untyped := ctx.Value(Key{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic(
                        "Unable to fetch github.com/tektoncd/triggers/pkg/client/informers/externalversions/triggers/v1beta1.TriggerTemplateInformer from context.")
        }</span>
        <span class="cov0" title="0">return untyped.(v1beta1.TriggerTemplateInformer)</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package clusterinterceptor

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/triggers/pkg/client/injection/client"
        clusterinterceptor "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "clusterinterceptor-controller"
        defaultFinalizerName       = "clusterinterceptors.triggers.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">clusterinterceptorInformer := clusterinterceptor.Get(ctx)

        lister := clusterinterceptorInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "triggers.tekton.dev.ClusterInterceptor"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file153" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package clusterinterceptor

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.ClusterInterceptor.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1alpha1.ClusterInterceptor. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1alpha1.ClusterInterceptor) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1alpha1.ClusterInterceptor.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1alpha1.ClusterInterceptor. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1alpha1.ClusterInterceptor) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.ClusterInterceptor if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1alpha1.ClusterInterceptor.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1alpha1.ClusterInterceptor) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1alpha1.ClusterInterceptor) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1alpha1.ClusterInterceptor resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister triggersv1alpha1.ClusterInterceptorLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister triggersv1alpha1.ClusterInterceptorLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1alpha1.ClusterInterceptor, desired *v1alpha1.ClusterInterceptor) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TriggersV1alpha1().ClusterInterceptors()

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TriggersV1alpha1().ClusterInterceptors()

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.ClusterInterceptor, desiredFinalizers sets.Set[string]) (*v1alpha1.ClusterInterceptor, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TriggersV1alpha1().ClusterInterceptors()

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.ClusterInterceptor) (*v1alpha1.ClusterInterceptor, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.ClusterInterceptor, reconcileEvent reconciler.Event) (*v1alpha1.ClusterInterceptor, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package clusterinterceptor

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1alpha1.ClusterInterceptor) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/triggers/pkg/client/injection/client"
        eventlistener "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/eventlistener"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "eventlistener-controller"
        defaultFinalizerName       = "eventlisteners.triggers.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">eventlistenerInformer := eventlistener.Get(ctx)

        lister := eventlistenerInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "triggers.tekton.dev.EventListener"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file156" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.EventListener.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1alpha1.EventListener. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1alpha1.EventListener) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1alpha1.EventListener.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1alpha1.EventListener. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1alpha1.EventListener) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.EventListener if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1alpha1.EventListener.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1alpha1.EventListener) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1alpha1.EventListener) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1alpha1.EventListener resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister triggersv1alpha1.EventListenerLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister triggersv1alpha1.EventListenerLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.EventListeners(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1alpha1.EventListener, desired *v1alpha1.EventListener) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TriggersV1alpha1().EventListeners(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TriggersV1alpha1().EventListeners(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.EventListener, desiredFinalizers sets.Set[string]) (*v1alpha1.EventListener, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TriggersV1alpha1().EventListeners(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.EventListener) (*v1alpha1.EventListener, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.EventListener, reconcileEvent reconciler.Event) (*v1alpha1.EventListener, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1alpha1.EventListener) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package interceptor

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/triggers/pkg/client/injection/client"
        interceptor "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "interceptor-controller"
        defaultFinalizerName       = "interceptors.triggers.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">interceptorInformer := interceptor.Get(ctx)

        lister := interceptorInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "triggers.tekton.dev.Interceptor"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package interceptor

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.Interceptor.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1alpha1.Interceptor. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1alpha1.Interceptor) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1alpha1.Interceptor.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1alpha1.Interceptor. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1alpha1.Interceptor) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1alpha1.Interceptor if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1alpha1.Interceptor.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1alpha1.Interceptor) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1alpha1.Interceptor) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1alpha1.Interceptor resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister triggersv1alpha1.InterceptorLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister triggersv1alpha1.InterceptorLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.Interceptors(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1alpha1.Interceptor, desired *v1alpha1.Interceptor) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TriggersV1alpha1().Interceptors(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TriggersV1alpha1().Interceptors(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1alpha1.Interceptor, desiredFinalizers sets.Set[string]) (*v1alpha1.Interceptor, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TriggersV1alpha1().Interceptors(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1alpha1.Interceptor) (*v1alpha1.Interceptor, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1alpha1.Interceptor, reconcileEvent reconciler.Event) (*v1alpha1.Interceptor, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package interceptor

import (
        fmt "fmt"

        v1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1alpha1.Interceptor) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        context "context"
        fmt "fmt"
        reflect "reflect"
        strings "strings"

        versionedscheme "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        client "github.com/tektoncd/triggers/pkg/client/injection/client"
        eventlistener "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        zap "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        watch "k8s.io/apimachinery/pkg/watch"
        scheme "k8s.io/client-go/kubernetes/scheme"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        record "k8s.io/client-go/tools/record"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        controller "knative.dev/pkg/controller"
        logging "knative.dev/pkg/logging"
        logkey "knative.dev/pkg/logging/logkey"
        reconciler "knative.dev/pkg/reconciler"
)

const (
        defaultControllerAgentName = "eventlistener-controller"
        defaultFinalizerName       = "eventlisteners.triggers.tekton.dev"
)

// NewImpl returns a controller.Impl that handles queuing and feeding work from
// the queue through an implementation of controller.Reconciler, delegating to
// the provided Interface and optional Finalizer methods. OptionsFn is used to return
// controller.ControllerOptions to be used by the internal reconciler.
func NewImpl(ctx context.Context, r Interface, optionsFns ...controller.OptionsFn) *controller.Impl <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Check the options function input. It should be 0 or 1.
        if len(optionsFns) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options function is supported, found: ", len(optionsFns))
        }</span>

        <span class="cov0" title="0">eventlistenerInformer := eventlistener.Get(ctx)

        lister := eventlistenerInformer.Lister()

        var promoteFilterFunc func(obj interface{}) bool
        var promoteFunc = func(bkt reconciler.Bucket) </span>{<span class="cov0" title="0">}</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{

                                // Signal promotion event
                                promoteFunc(bkt)

                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        if promoteFilterFunc != nil </span><span class="cov0" title="0">{
                                                if ok := promoteFilterFunc(elt); !ok </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov0" title="0">enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })</span>
                                }
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client.Get(ctx),
                Lister:        lister,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">ctrType := reflect.TypeOf(r).Elem()
        ctrTypeName := fmt.Sprintf("%s.%s", ctrType.PkgPath(), ctrType.Name())
        ctrTypeName = strings.ReplaceAll(ctrTypeName, "/", ".")

        logger = logger.With(
                zap.String(logkey.ControllerType, ctrTypeName),
                zap.String(logkey.Kind, "triggers.tekton.dev.EventListener"),
        )

        impl := controller.NewContext(ctx, rec, controller.ControllerOptions{WorkQueueName: ctrTypeName, Logger: logger})
        agentName := defaultControllerAgentName

        // Pass impl to the options. Save any optional results.
        for _, fn := range optionsFns </span><span class="cov0" title="0">{
                opts := fn(impl)
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.AgentName != "" </span><span class="cov0" title="0">{
                        agentName = opts.AgentName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFilterFunc != nil </span><span class="cov0" title="0">{
                        promoteFilterFunc = opts.PromoteFilterFunc
                }</span>
                <span class="cov0" title="0">if opts.PromoteFunc != nil </span><span class="cov0" title="0">{
                        promoteFunc = opts.PromoteFunc
                }</span>
        }

        <span class="cov0" title="0">rec.Recorder = createRecorder(ctx, agentName)

        return impl</span>
}

func createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: kubeclient.Get(ctx).CoreV1().Events("")}),
                }
                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func init() <span class="cov0" title="0">{
        versionedscheme.AddToScheme(scheme.Scheme)
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        context "context"
        json "encoding/json"
        fmt "fmt"

        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        versioned "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        zap "go.uber.org/zap"
        zapcore "go.uber.org/zap/zapcore"
        v1 "k8s.io/api/core/v1"
        equality "k8s.io/apimachinery/pkg/api/equality"
        errors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        labels "k8s.io/apimachinery/pkg/labels"
        types "k8s.io/apimachinery/pkg/types"
        sets "k8s.io/apimachinery/pkg/util/sets"
        record "k8s.io/client-go/tools/record"
        controller "knative.dev/pkg/controller"
        kmp "knative.dev/pkg/kmp"
        logging "knative.dev/pkg/logging"
        reconciler "knative.dev/pkg/reconciler"
)

// Interface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.EventListener.
type Interface interface {
        // ReconcileKind implements custom logic to reconcile v1beta1.EventListener. Any changes
        // to the objects .Status or .Finalizers will be propagated to the stored
        // object. It is recommended that implementors do not call any update calls
        // for the Kind inside of ReconcileKind, it is the responsibility of the calling
        // controller to propagate those properties. The resource passed to ReconcileKind
        // will always have an empty deletion timestamp.
        ReconcileKind(ctx context.Context, o *v1beta1.EventListener) reconciler.Event
}

// Finalizer defines the strongly typed interfaces to be implemented by a
// controller finalizing v1beta1.EventListener.
type Finalizer interface {
        // FinalizeKind implements custom logic to finalize v1beta1.EventListener. Any changes
        // to the objects .Status or .Finalizers will be ignored. Returning a nil or
        // Normal type reconciler.Event will allow the finalizer to be deleted on
        // the resource. The resource passed to FinalizeKind will always have a set
        // deletion timestamp.
        FinalizeKind(ctx context.Context, o *v1beta1.EventListener) reconciler.Event
}

// ReadOnlyInterface defines the strongly typed interfaces to be implemented by a
// controller reconciling v1beta1.EventListener if they want to process resources for which
// they are not the leader.
type ReadOnlyInterface interface {
        // ObserveKind implements logic to observe v1beta1.EventListener.
        // This method should not write to the API.
        ObserveKind(ctx context.Context, o *v1beta1.EventListener) reconciler.Event
}

type doReconcile func(ctx context.Context, o *v1beta1.EventListener) reconciler.Event

// reconcilerImpl implements controller.Reconciler for v1beta1.EventListener resources.
type reconcilerImpl struct {
        // LeaderAwareFuncs is inlined to help us implement reconciler.LeaderAware.
        reconciler.LeaderAwareFuncs

        // Client is used to write back status updates.
        Client versioned.Interface

        // Listers index properties about resources.
        Lister triggersv1beta1.EventListenerLister

        // Recorder is an event recorder for recording Event resources to the
        // Kubernetes API.
        Recorder record.EventRecorder

        // configStore allows for decorating a context with config maps.
        // +optional
        configStore reconciler.ConfigStore

        // reconciler is the implementation of the business logic of the resource.
        reconciler Interface

        // finalizerName is the name of the finalizer to reconcile.
        finalizerName string

        // skipStatusUpdates configures whether or not this reconciler automatically updates
        // the status of the reconciled resource.
        skipStatusUpdates bool
}

// Check that our Reconciler implements controller.Reconciler.
var _ controller.Reconciler = (*reconcilerImpl)(nil)

// Check that our generated Reconciler is always LeaderAware.
var _ reconciler.LeaderAware = (*reconcilerImpl)(nil)

func NewReconciler(ctx context.Context, logger *zap.SugaredLogger, client versioned.Interface, lister triggersv1beta1.EventListenerLister, recorder record.EventRecorder, r Interface, options ...controller.Options) controller.Reconciler <span class="cov0" title="0">{
        // Check the options function input. It should be 0 or 1.
        if len(options) &gt; 1 </span><span class="cov0" title="0">{
                logger.Fatal("Up to one options struct is supported, found: ", len(options))
        }</span>

        // Fail fast when users inadvertently implement the other LeaderAware interface.
        // For the typed reconcilers, Promote shouldn't take any arguments.
        <span class="cov0" title="0">if _, ok := r.(reconciler.LeaderAware); ok </span><span class="cov0" title="0">{
                logger.Fatalf("%T implements the incorrect LeaderAware interface. Promote() should not take an argument as genreconciler handles the enqueuing automatically.", r)
        }</span>

        <span class="cov0" title="0">rec := &amp;reconcilerImpl{
                LeaderAwareFuncs: reconciler.LeaderAwareFuncs{
                        PromoteFunc: func(bkt reconciler.Bucket, enq func(reconciler.Bucket, types.NamespacedName)) error </span><span class="cov0" title="0">{
                                all, err := lister.List(labels.Everything())
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">for _, elt := range all </span><span class="cov0" title="0">{
                                        // TODO: Consider letting users specify a filter in options.
                                        enq(bkt, types.NamespacedName{
                                                Namespace: elt.GetNamespace(),
                                                Name:      elt.GetName(),
                                        })
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                },
                Client:        client,
                Lister:        lister,
                Recorder:      recorder,
                reconciler:    r,
                finalizerName: defaultFinalizerName,
        }

        <span class="cov0" title="0">for _, opts := range options </span><span class="cov0" title="0">{
                if opts.ConfigStore != nil </span><span class="cov0" title="0">{
                        rec.configStore = opts.ConfigStore
                }</span>
                <span class="cov0" title="0">if opts.FinalizerName != "" </span><span class="cov0" title="0">{
                        rec.finalizerName = opts.FinalizerName
                }</span>
                <span class="cov0" title="0">if opts.SkipStatusUpdates </span><span class="cov0" title="0">{
                        rec.skipStatusUpdates = true
                }</span>
                <span class="cov0" title="0">if opts.DemoteFunc != nil </span><span class="cov0" title="0">{
                        rec.DemoteFunc = opts.DemoteFunc
                }</span>
        }

        <span class="cov0" title="0">return rec</span>
}

// Reconcile implements controller.Reconciler
func (r *reconcilerImpl) Reconcile(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // Initialize the reconciler state. This will convert the namespace/name
        // string into a distinct namespace and name, determine if this instance of
        // the reconciler is the leader, and any additional interfaces implemented
        // by the reconciler. Returns an error is the resource key is invalid.
        s, err := newState(key, r)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Invalid resource key: ", key)
                return nil
        }</span>

        // If we are not the leader, and we don't implement either ReadOnly
        // observer interfaces, then take a fast-path out.
        <span class="cov0" title="0">if s.isNotLeaderNorObserver() </span><span class="cov0" title="0">{
                return controller.NewSkipKey(key)
        }</span>

        // If configStore is set, attach the frozen configuration to the context.
        <span class="cov0" title="0">if r.configStore != nil </span><span class="cov0" title="0">{
                ctx = r.configStore.ToContext(ctx)
        }</span>

        // Add the recorder to context.
        <span class="cov0" title="0">ctx = controller.WithEventRecorder(ctx, r.Recorder)

        // Get the resource with this namespace/name.

        getter := r.Lister.EventListeners(s.namespace)

        original, err := getter.Get(s.name)

        if errors.IsNotFound(err) </span><span class="cov0" title="0">{
                // The resource may no longer exist, in which case we stop processing and call
                // the ObserveDeletion handler if appropriate.
                logger.Debugf("Resource %q no longer exists", key)
                if del, ok := r.reconciler.(reconciler.OnDeletionInterface); ok </span><span class="cov0" title="0">{
                        return del.ObserveDeletion(ctx, types.NamespacedName{
                                Namespace: s.namespace,
                                Name:      s.name,
                        })
                }</span>
                <span class="cov0" title="0">return nil</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Don't modify the informers copy.
        <span class="cov0" title="0">resource := original.DeepCopy()

        var reconcileEvent reconciler.Event

        name, do := s.reconcileMethodFor(resource)
        // Append the target method to the logger.
        logger = logger.With(zap.String("targetMethod", name))
        switch name </span>{
        case reconciler.DoReconcileKind:<span class="cov0" title="0">
                // Set and update the finalizer on resource if r.reconciler
                // implements Finalizer.
                if resource, err = r.setFinalizerIfFinalizer(ctx, resource); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set finalizers: %w", err)
                }</span>

                // Reconcile this copy of the resource and then write back any status
                // updates regardless of whether the reconciliation errored out.
                <span class="cov0" title="0">reconcileEvent = do(ctx, resource)</span>

        case reconciler.DoFinalizeKind:<span class="cov0" title="0">
                // For finalizing reconcilers, if this resource being marked for deletion
                // and reconciled cleanly (nil or normal event), remove the finalizer.
                reconcileEvent = do(ctx, resource)

                if resource, err = r.clearFinalizer(ctx, resource, reconcileEvent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to clear finalizers: %w", err)
                }</span>

        case reconciler.DoObserveKind:<span class="cov0" title="0">
                // Observe any changes to this resource, since we are not the leader.
                reconcileEvent = do(ctx, resource)</span>

        }

        // Synchronize the status.
        <span class="cov0" title="0">switch </span>{
        case r.skipStatusUpdates:<span class="cov0" title="0"></span>
                // This reconciler implementation is configured to skip resource updates.
                // This may mean this reconciler does not observe spec, but reconciles external changes.
        case equality.Semantic.DeepEqual(original.Status, resource.Status):<span class="cov0" title="0"></span>
                // If we didn't change anything then don't call updateStatus.
                // This is important because the copy we loaded from the injectionInformer's
                // cache may be stale and we don't want to overwrite a prior update
                // to status with this stale state.
        case !s.isLeader:<span class="cov0" title="0">
                // High-availability reconcilers may have many replicas watching the resource, but only
                // the elected leader is expected to write modifications.
                logger.Warn("Saw status changes when we aren't the leader!")</span>
        default:<span class="cov0" title="0">
                if err = r.updateStatus(ctx, logger, original, resource); err != nil </span><span class="cov0" title="0">{
                        logger.Warnw("Failed to update resource status", zap.Error(err))
                        r.Recorder.Eventf(resource, v1.EventTypeWarning, "UpdateFailed",
                                "Failed to update status for %q: %v", resource.Name, err)
                        return err
                }</span>
        }

        // Report the reconciler event, if any.
        <span class="cov0" title="0">if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        logger.Infow("Returned an event", zap.Any("event", reconcileEvent))
                        r.Recorder.Event(resource, event.EventType, event.Reason, event.Error())

                        // the event was wrapped inside an error, consider the reconciliation as failed
                        if _, isEvent := reconcileEvent.(*reconciler.ReconcilerEvent); !isEvent </span><span class="cov0" title="0">{
                                return reconcileEvent
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                <span class="cov0" title="0">if controller.IsSkipKey(reconcileEvent) </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> if ok, _ := controller.IsRequeueKey(reconcileEvent); ok </span>{<span class="cov0" title="0">
                        // This is a wrapped error, don't emit an event.
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorw("Returned an error", zap.Error(reconcileEvent))
                        r.Recorder.Event(resource, v1.EventTypeWarning, "InternalError", reconcileEvent.Error())
                }</span>
                <span class="cov0" title="0">return reconcileEvent</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *reconcilerImpl) updateStatus(ctx context.Context, logger *zap.SugaredLogger, existing *v1beta1.EventListener, desired *v1beta1.EventListener) error <span class="cov0" title="0">{
        existing = existing.DeepCopy()
        return reconciler.RetryUpdateConflicts(func(attempts int) (err error) </span><span class="cov0" title="0">{
                // The first iteration tries to use the injectionInformer's state, subsequent attempts fetch the latest state via API.
                if attempts &gt; 0 </span><span class="cov0" title="0">{

                        getter := r.Client.TriggersV1beta1().EventListeners(desired.Namespace)

                        existing, err = getter.Get(ctx, desired.Name, metav1.GetOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                // If there's nothing to update, just return.
                <span class="cov0" title="0">if equality.Semantic.DeepEqual(existing.Status, desired.Status) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">if logger.Desugar().Core().Enabled(zapcore.DebugLevel) </span><span class="cov0" title="0">{
                        if diff, err := kmp.SafeDiff(existing.Status, desired.Status); err == nil &amp;&amp; diff != "" </span><span class="cov0" title="0">{
                                logger.Debug("Updating status with: ", diff)
                        }</span>
                }

                <span class="cov0" title="0">existing.Status = desired.Status

                updater := r.Client.TriggersV1beta1().EventListeners(existing.Namespace)

                _, err = updater.UpdateStatus(ctx, existing, metav1.UpdateOptions{})
                return err</span>
        })
}

// updateFinalizersFiltered will update the Finalizers of the resource.
// TODO: this method could be generic and sync all finalizers. For now it only
// updates defaultFinalizerName or its override.
func (r *reconcilerImpl) updateFinalizersFiltered(ctx context.Context, resource *v1beta1.EventListener, desiredFinalizers sets.Set[string]) (*v1beta1.EventListener, error) <span class="cov0" title="0">{
        // Don't modify the informers copy.
        existing := resource.DeepCopy()

        var finalizers []string

        // If there's nothing to update, just return.
        existingFinalizers := sets.New[string](existing.Finalizers...)

        if desiredFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                if existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Add the finalizer.
                <span class="cov0" title="0">finalizers = append(existing.Finalizers, r.finalizerName)</span>
        } else<span class="cov0" title="0"> {
                if !existingFinalizers.Has(r.finalizerName) </span><span class="cov0" title="0">{
                        // Nothing to do.
                        return resource, nil
                }</span>
                // Remove the finalizer.
                <span class="cov0" title="0">existingFinalizers.Delete(r.finalizerName)
                finalizers = sets.List(existingFinalizers)</span>
        }

        <span class="cov0" title="0">mergePatch := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "finalizers":      finalizers,
                        "resourceVersion": existing.ResourceVersion,
                },
        }

        patch, err := json.Marshal(mergePatch)
        if err != nil </span><span class="cov0" title="0">{
                return resource, err
        }</span>

        <span class="cov0" title="0">patcher := r.Client.TriggersV1beta1().EventListeners(resource.Namespace)

        resourceName := resource.Name
        updated, err := patcher.Patch(ctx, resourceName, types.MergePatchType, patch, metav1.PatchOptions{})
        if err != nil </span><span class="cov0" title="0">{
                r.Recorder.Eventf(existing, v1.EventTypeWarning, "FinalizerUpdateFailed",
                        "Failed to update finalizers for %q: %v", resourceName, err)
        }</span> else<span class="cov0" title="0"> {
                r.Recorder.Eventf(updated, v1.EventTypeNormal, "FinalizerUpdate",
                        "Updated %q finalizers", resource.GetName())
        }</span>
        <span class="cov0" title="0">return updated, err</span>
}

func (r *reconcilerImpl) setFinalizerIfFinalizer(ctx context.Context, resource *v1beta1.EventListener) (*v1beta1.EventListener, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        // If this resource is not being deleted, mark the finalizer.
        if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                finalizers.Insert(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}

func (r *reconcilerImpl) clearFinalizer(ctx context.Context, resource *v1beta1.EventListener, reconcileEvent reconciler.Event) (*v1beta1.EventListener, error) <span class="cov0" title="0">{
        if _, ok := r.reconciler.(Finalizer); !ok </span><span class="cov0" title="0">{
                return resource, nil
        }</span>
        <span class="cov0" title="0">if resource.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                return resource, nil
        }</span>

        <span class="cov0" title="0">finalizers := sets.New[string](resource.Finalizers...)

        if reconcileEvent != nil </span><span class="cov0" title="0">{
                var event *reconciler.ReconcilerEvent
                if reconciler.EventAs(reconcileEvent, &amp;event) </span><span class="cov0" title="0">{
                        if event.EventType == v1.EventTypeNormal </span><span class="cov0" title="0">{
                                finalizers.Delete(r.finalizerName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                finalizers.Delete(r.finalizerName)
        }</span>

        // Synchronize the finalizers filtered by r.finalizerName.
        <span class="cov0" title="0">return r.updateFinalizersFiltered(ctx, resource, finalizers)</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by injection-gen. DO NOT EDIT.

package eventlistener

import (
        fmt "fmt"

        v1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        types "k8s.io/apimachinery/pkg/types"
        cache "k8s.io/client-go/tools/cache"
        reconciler "knative.dev/pkg/reconciler"
)

// state is used to track the state of a reconciler in a single run.
type state struct {
        // key is the original reconciliation key from the queue.
        key string
        // namespace is the namespace split from the reconciliation key.
        namespace string
        // name is the name split from the reconciliation key.
        name string
        // reconciler is the reconciler.
        reconciler Interface
        // roi is the read only interface cast of the reconciler.
        roi ReadOnlyInterface
        // isROI (Read Only Interface) the reconciler only observes reconciliation.
        isROI bool
        // isLeader the instance of the reconciler is the elected leader.
        isLeader bool
}

func newState(key string, r *reconcilerImpl) (*state, error) <span class="cov0" title="0">{
        // Convert the namespace/name string into a distinct namespace and name.
        namespace, name, err := cache.SplitMetaNamespaceKey(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid resource key: %s", key)
        }</span>

        <span class="cov0" title="0">roi, isROI := r.reconciler.(ReadOnlyInterface)

        isLeader := r.IsLeaderFor(types.NamespacedName{
                Namespace: namespace,
                Name:      name,
        })

        return &amp;state{
                key:        key,
                namespace:  namespace,
                name:       name,
                reconciler: r.reconciler,
                roi:        roi,
                isROI:      isROI,
                isLeader:   isLeader,
        }, nil</span>
}

// isNotLeaderNorObserver checks to see if this reconciler with the current
// state is enabled to do any work or not.
// isNotLeaderNorObserver returns true when there is no work possible for the
// reconciler.
func (s *state) isNotLeaderNorObserver() bool <span class="cov0" title="0">{
        if !s.isLeader &amp;&amp; !s.isROI </span><span class="cov0" title="0">{
                // If we are not the leader, and we don't implement the ReadOnly
                // interface, then take a fast-path out.
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *state) reconcileMethodFor(o *v1beta1.EventListener) (string, doReconcile) <span class="cov0" title="0">{
        if o.GetDeletionTimestamp().IsZero() </span><span class="cov0" title="0">{
                if s.isLeader </span><span class="cov0" title="0">{
                        return reconciler.DoReconcileKind, s.reconciler.ReconcileKind
                }</span> else<span class="cov0" title="0"> if s.isROI </span><span class="cov0" title="0">{
                        return reconciler.DoObserveKind, s.roi.ObserveKind
                }</span>
        } else<span class="cov0" title="0"> if fin, ok := s.reconciler.(Finalizer); s.isLeader &amp;&amp; ok </span><span class="cov0" title="0">{
                return reconciler.DoFinalizeKind, fin.FinalizeKind
        }</span>
        <span class="cov0" title="0">return "unknown", nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// ClusterInterceptorLister helps list ClusterInterceptors.
// All objects returned here must be treated as read-only.
type ClusterInterceptorLister interface {
        // List lists all ClusterInterceptors in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.ClusterInterceptor, err error)
        // Get retrieves the ClusterInterceptor from the index for a given name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1alpha1.ClusterInterceptor, error)
        ClusterInterceptorListerExpansion
}

// clusterInterceptorLister implements the ClusterInterceptorLister interface.
type clusterInterceptorLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.ClusterInterceptor]
}

// NewClusterInterceptorLister returns a new ClusterInterceptorLister.
func NewClusterInterceptorLister(indexer cache.Indexer) ClusterInterceptorLister <span class="cov0" title="0">{
        return &amp;clusterInterceptorLister{listers.New[*triggersv1alpha1.ClusterInterceptor](indexer, triggersv1alpha1.Resource("clusterinterceptor"))}
}</span>
</pre>
		
		<pre class="file" id="file165" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// ClusterTriggerBindingLister helps list ClusterTriggerBindings.
// All objects returned here must be treated as read-only.
type ClusterTriggerBindingLister interface {
        // List lists all ClusterTriggerBindings in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.ClusterTriggerBinding, err error)
        // Get retrieves the ClusterTriggerBinding from the index for a given name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1alpha1.ClusterTriggerBinding, error)
        ClusterTriggerBindingListerExpansion
}

// clusterTriggerBindingLister implements the ClusterTriggerBindingLister interface.
type clusterTriggerBindingLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.ClusterTriggerBinding]
}

// NewClusterTriggerBindingLister returns a new ClusterTriggerBindingLister.
func NewClusterTriggerBindingLister(indexer cache.Indexer) ClusterTriggerBindingLister <span class="cov0" title="0">{
        return &amp;clusterTriggerBindingLister{listers.New[*triggersv1alpha1.ClusterTriggerBinding](indexer, triggersv1alpha1.Resource("clustertriggerbinding"))}
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// EventListenerLister helps list EventListeners.
// All objects returned here must be treated as read-only.
type EventListenerLister interface {
        // List lists all EventListeners in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.EventListener, err error)
        // EventListeners returns an object that can list and get EventListeners.
        EventListeners(namespace string) EventListenerNamespaceLister
        EventListenerListerExpansion
}

// eventListenerLister implements the EventListenerLister interface.
type eventListenerLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.EventListener]
}

// NewEventListenerLister returns a new EventListenerLister.
func NewEventListenerLister(indexer cache.Indexer) EventListenerLister <span class="cov0" title="0">{
        return &amp;eventListenerLister{listers.New[*triggersv1alpha1.EventListener](indexer, triggersv1alpha1.Resource("eventlistener"))}
}</span>

// EventListeners returns an object that can list and get EventListeners.
func (s *eventListenerLister) EventListeners(namespace string) EventListenerNamespaceLister <span class="cov0" title="0">{
        return eventListenerNamespaceLister{listers.NewNamespaced[*triggersv1alpha1.EventListener](s.ResourceIndexer, namespace)}
}</span>

// EventListenerNamespaceLister helps list and get EventListeners.
// All objects returned here must be treated as read-only.
type EventListenerNamespaceLister interface {
        // List lists all EventListeners in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.EventListener, err error)
        // Get retrieves the EventListener from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1alpha1.EventListener, error)
        EventListenerNamespaceListerExpansion
}

// eventListenerNamespaceLister implements the EventListenerNamespaceLister
// interface.
type eventListenerNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.EventListener]
}
</pre>
		
		<pre class="file" id="file167" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// InterceptorLister helps list Interceptors.
// All objects returned here must be treated as read-only.
type InterceptorLister interface {
        // List lists all Interceptors in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.Interceptor, err error)
        // Interceptors returns an object that can list and get Interceptors.
        Interceptors(namespace string) InterceptorNamespaceLister
        InterceptorListerExpansion
}

// interceptorLister implements the InterceptorLister interface.
type interceptorLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.Interceptor]
}

// NewInterceptorLister returns a new InterceptorLister.
func NewInterceptorLister(indexer cache.Indexer) InterceptorLister <span class="cov0" title="0">{
        return &amp;interceptorLister{listers.New[*triggersv1alpha1.Interceptor](indexer, triggersv1alpha1.Resource("interceptor"))}
}</span>

// Interceptors returns an object that can list and get Interceptors.
func (s *interceptorLister) Interceptors(namespace string) InterceptorNamespaceLister <span class="cov0" title="0">{
        return interceptorNamespaceLister{listers.NewNamespaced[*triggersv1alpha1.Interceptor](s.ResourceIndexer, namespace)}
}</span>

// InterceptorNamespaceLister helps list and get Interceptors.
// All objects returned here must be treated as read-only.
type InterceptorNamespaceLister interface {
        // List lists all Interceptors in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.Interceptor, err error)
        // Get retrieves the Interceptor from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1alpha1.Interceptor, error)
        InterceptorNamespaceListerExpansion
}

// interceptorNamespaceLister implements the InterceptorNamespaceLister
// interface.
type interceptorNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.Interceptor]
}
</pre>
		
		<pre class="file" id="file168" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerLister helps list Triggers.
// All objects returned here must be treated as read-only.
type TriggerLister interface {
        // List lists all Triggers in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.Trigger, err error)
        // Triggers returns an object that can list and get Triggers.
        Triggers(namespace string) TriggerNamespaceLister
        TriggerListerExpansion
}

// triggerLister implements the TriggerLister interface.
type triggerLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.Trigger]
}

// NewTriggerLister returns a new TriggerLister.
func NewTriggerLister(indexer cache.Indexer) TriggerLister <span class="cov0" title="0">{
        return &amp;triggerLister{listers.New[*triggersv1alpha1.Trigger](indexer, triggersv1alpha1.Resource("trigger"))}
}</span>

// Triggers returns an object that can list and get Triggers.
func (s *triggerLister) Triggers(namespace string) TriggerNamespaceLister <span class="cov0" title="0">{
        return triggerNamespaceLister{listers.NewNamespaced[*triggersv1alpha1.Trigger](s.ResourceIndexer, namespace)}
}</span>

// TriggerNamespaceLister helps list and get Triggers.
// All objects returned here must be treated as read-only.
type TriggerNamespaceLister interface {
        // List lists all Triggers in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.Trigger, err error)
        // Get retrieves the Trigger from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1alpha1.Trigger, error)
        TriggerNamespaceListerExpansion
}

// triggerNamespaceLister implements the TriggerNamespaceLister
// interface.
type triggerNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.Trigger]
}
</pre>
		
		<pre class="file" id="file169" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerBindingLister helps list TriggerBindings.
// All objects returned here must be treated as read-only.
type TriggerBindingLister interface {
        // List lists all TriggerBindings in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.TriggerBinding, err error)
        // TriggerBindings returns an object that can list and get TriggerBindings.
        TriggerBindings(namespace string) TriggerBindingNamespaceLister
        TriggerBindingListerExpansion
}

// triggerBindingLister implements the TriggerBindingLister interface.
type triggerBindingLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.TriggerBinding]
}

// NewTriggerBindingLister returns a new TriggerBindingLister.
func NewTriggerBindingLister(indexer cache.Indexer) TriggerBindingLister <span class="cov0" title="0">{
        return &amp;triggerBindingLister{listers.New[*triggersv1alpha1.TriggerBinding](indexer, triggersv1alpha1.Resource("triggerbinding"))}
}</span>

// TriggerBindings returns an object that can list and get TriggerBindings.
func (s *triggerBindingLister) TriggerBindings(namespace string) TriggerBindingNamespaceLister <span class="cov0" title="0">{
        return triggerBindingNamespaceLister{listers.NewNamespaced[*triggersv1alpha1.TriggerBinding](s.ResourceIndexer, namespace)}
}</span>

// TriggerBindingNamespaceLister helps list and get TriggerBindings.
// All objects returned here must be treated as read-only.
type TriggerBindingNamespaceLister interface {
        // List lists all TriggerBindings in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.TriggerBinding, err error)
        // Get retrieves the TriggerBinding from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1alpha1.TriggerBinding, error)
        TriggerBindingNamespaceListerExpansion
}

// triggerBindingNamespaceLister implements the TriggerBindingNamespaceLister
// interface.
type triggerBindingNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.TriggerBinding]
}
</pre>
		
		<pre class="file" id="file170" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1alpha1

import (
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerTemplateLister helps list TriggerTemplates.
// All objects returned here must be treated as read-only.
type TriggerTemplateLister interface {
        // List lists all TriggerTemplates in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.TriggerTemplate, err error)
        // TriggerTemplates returns an object that can list and get TriggerTemplates.
        TriggerTemplates(namespace string) TriggerTemplateNamespaceLister
        TriggerTemplateListerExpansion
}

// triggerTemplateLister implements the TriggerTemplateLister interface.
type triggerTemplateLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.TriggerTemplate]
}

// NewTriggerTemplateLister returns a new TriggerTemplateLister.
func NewTriggerTemplateLister(indexer cache.Indexer) TriggerTemplateLister <span class="cov0" title="0">{
        return &amp;triggerTemplateLister{listers.New[*triggersv1alpha1.TriggerTemplate](indexer, triggersv1alpha1.Resource("triggertemplate"))}
}</span>

// TriggerTemplates returns an object that can list and get TriggerTemplates.
func (s *triggerTemplateLister) TriggerTemplates(namespace string) TriggerTemplateNamespaceLister <span class="cov0" title="0">{
        return triggerTemplateNamespaceLister{listers.NewNamespaced[*triggersv1alpha1.TriggerTemplate](s.ResourceIndexer, namespace)}
}</span>

// TriggerTemplateNamespaceLister helps list and get TriggerTemplates.
// All objects returned here must be treated as read-only.
type TriggerTemplateNamespaceLister interface {
        // List lists all TriggerTemplates in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1alpha1.TriggerTemplate, err error)
        // Get retrieves the TriggerTemplate from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1alpha1.TriggerTemplate, error)
        TriggerTemplateNamespaceListerExpansion
}

// triggerTemplateNamespaceLister implements the TriggerTemplateNamespaceLister
// interface.
type triggerTemplateNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1alpha1.TriggerTemplate]
}
</pre>
		
		<pre class="file" id="file171" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// ClusterTriggerBindingLister helps list ClusterTriggerBindings.
// All objects returned here must be treated as read-only.
type ClusterTriggerBindingLister interface {
        // List lists all ClusterTriggerBindings in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.ClusterTriggerBinding, err error)
        // Get retrieves the ClusterTriggerBinding from the index for a given name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1beta1.ClusterTriggerBinding, error)
        ClusterTriggerBindingListerExpansion
}

// clusterTriggerBindingLister implements the ClusterTriggerBindingLister interface.
type clusterTriggerBindingLister struct {
        listers.ResourceIndexer[*triggersv1beta1.ClusterTriggerBinding]
}

// NewClusterTriggerBindingLister returns a new ClusterTriggerBindingLister.
func NewClusterTriggerBindingLister(indexer cache.Indexer) ClusterTriggerBindingLister <span class="cov0" title="0">{
        return &amp;clusterTriggerBindingLister{listers.New[*triggersv1beta1.ClusterTriggerBinding](indexer, triggersv1beta1.Resource("clustertriggerbinding"))}
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// EventListenerLister helps list EventListeners.
// All objects returned here must be treated as read-only.
type EventListenerLister interface {
        // List lists all EventListeners in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.EventListener, err error)
        // EventListeners returns an object that can list and get EventListeners.
        EventListeners(namespace string) EventListenerNamespaceLister
        EventListenerListerExpansion
}

// eventListenerLister implements the EventListenerLister interface.
type eventListenerLister struct {
        listers.ResourceIndexer[*triggersv1beta1.EventListener]
}

// NewEventListenerLister returns a new EventListenerLister.
func NewEventListenerLister(indexer cache.Indexer) EventListenerLister <span class="cov0" title="0">{
        return &amp;eventListenerLister{listers.New[*triggersv1beta1.EventListener](indexer, triggersv1beta1.Resource("eventlistener"))}
}</span>

// EventListeners returns an object that can list and get EventListeners.
func (s *eventListenerLister) EventListeners(namespace string) EventListenerNamespaceLister <span class="cov0" title="0">{
        return eventListenerNamespaceLister{listers.NewNamespaced[*triggersv1beta1.EventListener](s.ResourceIndexer, namespace)}
}</span>

// EventListenerNamespaceLister helps list and get EventListeners.
// All objects returned here must be treated as read-only.
type EventListenerNamespaceLister interface {
        // List lists all EventListeners in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.EventListener, err error)
        // Get retrieves the EventListener from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1beta1.EventListener, error)
        EventListenerNamespaceListerExpansion
}

// eventListenerNamespaceLister implements the EventListenerNamespaceLister
// interface.
type eventListenerNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1beta1.EventListener]
}
</pre>
		
		<pre class="file" id="file173" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerLister helps list Triggers.
// All objects returned here must be treated as read-only.
type TriggerLister interface {
        // List lists all Triggers in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.Trigger, err error)
        // Triggers returns an object that can list and get Triggers.
        Triggers(namespace string) TriggerNamespaceLister
        TriggerListerExpansion
}

// triggerLister implements the TriggerLister interface.
type triggerLister struct {
        listers.ResourceIndexer[*triggersv1beta1.Trigger]
}

// NewTriggerLister returns a new TriggerLister.
func NewTriggerLister(indexer cache.Indexer) TriggerLister <span class="cov0" title="0">{
        return &amp;triggerLister{listers.New[*triggersv1beta1.Trigger](indexer, triggersv1beta1.Resource("trigger"))}
}</span>

// Triggers returns an object that can list and get Triggers.
func (s *triggerLister) Triggers(namespace string) TriggerNamespaceLister <span class="cov0" title="0">{
        return triggerNamespaceLister{listers.NewNamespaced[*triggersv1beta1.Trigger](s.ResourceIndexer, namespace)}
}</span>

// TriggerNamespaceLister helps list and get Triggers.
// All objects returned here must be treated as read-only.
type TriggerNamespaceLister interface {
        // List lists all Triggers in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.Trigger, err error)
        // Get retrieves the Trigger from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1beta1.Trigger, error)
        TriggerNamespaceListerExpansion
}

// triggerNamespaceLister implements the TriggerNamespaceLister
// interface.
type triggerNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1beta1.Trigger]
}
</pre>
		
		<pre class="file" id="file174" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerBindingLister helps list TriggerBindings.
// All objects returned here must be treated as read-only.
type TriggerBindingLister interface {
        // List lists all TriggerBindings in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.TriggerBinding, err error)
        // TriggerBindings returns an object that can list and get TriggerBindings.
        TriggerBindings(namespace string) TriggerBindingNamespaceLister
        TriggerBindingListerExpansion
}

// triggerBindingLister implements the TriggerBindingLister interface.
type triggerBindingLister struct {
        listers.ResourceIndexer[*triggersv1beta1.TriggerBinding]
}

// NewTriggerBindingLister returns a new TriggerBindingLister.
func NewTriggerBindingLister(indexer cache.Indexer) TriggerBindingLister <span class="cov0" title="0">{
        return &amp;triggerBindingLister{listers.New[*triggersv1beta1.TriggerBinding](indexer, triggersv1beta1.Resource("triggerbinding"))}
}</span>

// TriggerBindings returns an object that can list and get TriggerBindings.
func (s *triggerBindingLister) TriggerBindings(namespace string) TriggerBindingNamespaceLister <span class="cov0" title="0">{
        return triggerBindingNamespaceLister{listers.NewNamespaced[*triggersv1beta1.TriggerBinding](s.ResourceIndexer, namespace)}
}</span>

// TriggerBindingNamespaceLister helps list and get TriggerBindings.
// All objects returned here must be treated as read-only.
type TriggerBindingNamespaceLister interface {
        // List lists all TriggerBindings in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.TriggerBinding, err error)
        // Get retrieves the TriggerBinding from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1beta1.TriggerBinding, error)
        TriggerBindingNamespaceListerExpansion
}

// triggerBindingNamespaceLister implements the TriggerBindingNamespaceLister
// interface.
type triggerBindingNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1beta1.TriggerBinding]
}
</pre>
		
		<pre class="file" id="file175" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by lister-gen. DO NOT EDIT.

package v1beta1

import (
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        labels "k8s.io/apimachinery/pkg/labels"
        listers "k8s.io/client-go/listers"
        cache "k8s.io/client-go/tools/cache"
)

// TriggerTemplateLister helps list TriggerTemplates.
// All objects returned here must be treated as read-only.
type TriggerTemplateLister interface {
        // List lists all TriggerTemplates in the indexer.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.TriggerTemplate, err error)
        // TriggerTemplates returns an object that can list and get TriggerTemplates.
        TriggerTemplates(namespace string) TriggerTemplateNamespaceLister
        TriggerTemplateListerExpansion
}

// triggerTemplateLister implements the TriggerTemplateLister interface.
type triggerTemplateLister struct {
        listers.ResourceIndexer[*triggersv1beta1.TriggerTemplate]
}

// NewTriggerTemplateLister returns a new TriggerTemplateLister.
func NewTriggerTemplateLister(indexer cache.Indexer) TriggerTemplateLister <span class="cov0" title="0">{
        return &amp;triggerTemplateLister{listers.New[*triggersv1beta1.TriggerTemplate](indexer, triggersv1beta1.Resource("triggertemplate"))}
}</span>

// TriggerTemplates returns an object that can list and get TriggerTemplates.
func (s *triggerTemplateLister) TriggerTemplates(namespace string) TriggerTemplateNamespaceLister <span class="cov0" title="0">{
        return triggerTemplateNamespaceLister{listers.NewNamespaced[*triggersv1beta1.TriggerTemplate](s.ResourceIndexer, namespace)}
}</span>

// TriggerTemplateNamespaceLister helps list and get TriggerTemplates.
// All objects returned here must be treated as read-only.
type TriggerTemplateNamespaceLister interface {
        // List lists all TriggerTemplates in the indexer for a given namespace.
        // Objects returned here must be treated as read-only.
        List(selector labels.Selector) (ret []*triggersv1beta1.TriggerTemplate, err error)
        // Get retrieves the TriggerTemplate from the indexer for a given namespace and name.
        // Objects returned here must be treated as read-only.
        Get(name string) (*triggersv1beta1.TriggerTemplate, error)
        TriggerTemplateNamespaceListerExpansion
}

// triggerTemplateNamespaceLister implements the TriggerTemplateNamespaceLister
// interface.
type triggerTemplateNamespaceLister struct {
        listers.ResourceIndexer[*triggersv1beta1.TriggerTemplate]
}
</pre>
		
		<pre class="file" id="file176" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package dynamic

import (
        "encoding/json"

        logger "github.com/sirupsen/logrus"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "knative.dev/pkg/apis/duck/v1beta1"
)

func GetConditions(existingData *unstructured.Unstructured) (v1beta1.Conditions, interface{}, error) <span class="cov8" title="1">{
        statusData, ok, err := unstructured.NestedMap(existingData.Object, "status")
        if !ok || err != nil </span><span class="cov8" title="1">{
                // No status in the created object, it is weird but let's not fail
                logger.Warn("empty status for the created custom object")
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">conditionData, ok, err := unstructured.NestedFieldCopy(statusData, "conditions")
        if !ok || err != nil </span><span class="cov8" title="1">{
                // No conditions in the created object, it is weird but let's not fail
                logger.Warn("empty status conditions for the created custom object")
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">cMarshalledData, err := json.Marshal(conditionData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">var customConditions v1beta1.Conditions
        if err = json.Unmarshal(cMarshalledData, &amp;customConditions); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return customConditions, statusData["url"], nil</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package dynamic

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/apis/duck"
        "knative.dev/pkg/controller"
)

type ListableTracker interface {
        WatchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error
}

type listableTracker struct {
        informerFactory duck.InformerFactory
        impl            *controller.Impl
}

// NewListableTracker creates a new ListableTracker, backed by a TypedInformerFactory.
func NewListableTracker(ctx context.Context, getter func(ctx context.Context) duck.InformerFactory, impl *controller.Impl) ListableTracker <span class="cov0" title="0">{
        return &amp;listableTracker{
                informerFactory: getter(ctx),
                impl:            impl,
        }
}</span>

func (t *listableTracker) WatchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error <span class="cov0" title="0">{
        return t.watchOnDynamicObject(ctx, gvr)
}</span>

func (t *listableTracker) watchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error <span class="cov0" title="0">{
        shInformer, _, err := t.informerFactory.Get(ctx, gvr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = shInformer.AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterController(&amp;v1beta1.EventListener{}),
                Handler:    controller.HandleAll(t.impl.EnqueueControllerOf),
        })
        return err</span>
}
</pre>
		
		<pre class="file" id="file178" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bitbucket

import (
        "context"
        "net/http"

        gh "github.com/google/go-github/v31/github"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "google.golang.org/grpc/codes"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        SecretRef *triggersv1.SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">headers := interceptors.Canonical(r.Header)

        // Check if the event type is in the allow-list
        if p.EventTypes != nil </span><span class="cov8" title="1">{
                actualEvent := http.Header(r.Header).Get("X-Event-Key")
                isAllowed := false
                for _, allowedEvent := range p.EventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                isAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isAllowed </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "event type %s is not allowed", actualEvent)
                }</span>
        }

        // Next validate secrets if set
        <span class="cov8" title="1">if p.SecretRef != nil </span><span class="cov8" title="1">{
                // Check the secret to see if it is empty
                if p.SecretRef.SecretKey == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "bitbucket interceptor secretRef.secretKey is empty")
                }</span>
                <span class="cov8" title="1">header := headers.Get("X-Hub-Signature")
                if header == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.InvalidArgument, "no X-Hub-Signature header set")
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
                secretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                <span class="cov8" title="1">if err := gh.ValidateSignature(header, []byte(r.Body), secretToken); err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error validating signature: %s", err.Error())
                }</span>
        }

        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue: true,
        }</span>
}
</pre>
		
		<pre class="file" id="file179" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cel

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "reflect"

        "github.com/tektoncd/triggers/pkg/interceptors"

        structpb "github.com/golang/protobuf/ptypes/struct"
        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/decls"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
        "github.com/google/cel-go/common/types/traits"
        celext "github.com/google/cel-go/ext"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tidwall/sjson"
        "google.golang.org/grpc/codes"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

// InterceptorImpl implements a CEL based interceptor that uses CEL expressions
// against the incoming body and headers to match, if the expression returns
// a true value, then the interception is "successful".
type InterceptorImpl struct {
        SecretGetter     interceptors.SecretGetter
        CEL              *InterceptorParams
        TriggerNamespace string
}

var (
        structType = reflect.TypeOf(&amp;structpb.Value{})
        listType   = reflect.TypeOf(&amp;structpb.ListValue{})
        mapType    = reflect.TypeOf(&amp;structpb.Struct{})
)

// NewInterceptor creates a prepopulated Interceptor.
func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        Filter string `json:"filter,omitempty"`
        // +listType=atomic
        Overlays []Overlay `json:"overlays,omitempty"`
}

// Overlay provides a way to modify the request body using CEL expressions
type Overlay struct {
        Key        string `json:"key,omitempty"`
        Expression string `json:"expression,omitempty"`
}

func evaluate(expr string, env *cel.Env, data map[string]interface{}) (ref.Val, error) <span class="cov8" title="1">{
        parsed, issues := env.Parse(expr)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse expression %#v: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">checked, issues := env.Check(parsed)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expression %#v check failed: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">prg, err := env.Program(checked, cel.EvalOptions(cel.OptOptimize))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v failed to create a Program: %w", expr, err)
        }</span>

        <span class="cov8" title="1">out, _, err := prg.Eval(data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expression %#v failed to evaluate: %w", expr, err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func makeCelEnv(ctx context.Context, ns string, sg interceptors.SecretGetter) (*cel.Env, error) <span class="cov8" title="1">{
        mapStrDyn := types.NewMapType(types.StringType, types.DynType)

        return cel.NewEnv(
                Triggers(ctx, ns, sg),
                celext.Strings(),
                celext.Encoders(),
                celext.Sets(),
                celext.Lists(),
                celext.Math(),
                cel.VariableDecls(
                        decls.NewVariable("body", mapStrDyn),
                        decls.NewVariable("header", mapStrDyn),
                        decls.NewVariable("extensions", mapStrDyn),
                        decls.NewVariable("requestURL", types.StringType),
                ))
}</span>

func makeEvalContext(body []byte, h http.Header, url string, extensions map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        var jsonMap map[string]interface{}
        err := json.Unmarshal(body, &amp;jsonMap)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse the body as JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{
                "body":       jsonMap,
                "header":     h,
                "requestURL": url,
                "extensions": extensions,
        }, nil</span>
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">if r.Context == nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.InvalidArgument, "no request context passed")
        }</span>

        <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
        env, err := makeCelEnv(ctx, ns, w.SecretGetter)
        if err != nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.Internal, "error creating cel environment: %v", err)
        }</span>

        <span class="cov8" title="1">var payload = []byte(`{}`)
        if r.Body != "" </span><span class="cov8" title="1">{
                payload = []byte(r.Body)
        }</span>

        <span class="cov8" title="1">evalContext, err := makeEvalContext(payload, r.Header, r.Context.EventURL, r.Extensions)
        if err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "error making the evaluation context: %v", err)
        }</span>

        <span class="cov8" title="1">if p.Filter != "" </span><span class="cov8" title="1">{
                out, err := evaluate(p.Filter, env, evalContext)

                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "error evaluating cel expression: %v", err)
                }</span>

                <span class="cov8" title="1">if out != types.True </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "expression %s did not return true", p.Filter)
                }</span>
        }

        // Empty JSON body bytes.
        // We use []byte instead of map[string]interface{} to allow ovewriting keys using sjson.
        <span class="cov8" title="1">var extensions []byte
        for _, u := range p.Overlays </span><span class="cov8" title="1">{
                val, err := evaluate(u.Expression, env, evalContext)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "error evaluating cel expression: %v", err)
                }</span>

                <span class="cov8" title="1">var raw interface{}
                var b []byte

                switch val.(type) </span>{
                // this causes types.Bytes to be rendered as a Base64 string this is
                // because the Go JSON Encoder encodes []bytes this way, see
                // https://golang.org/pkg/encoding/json/#Marshal
                //
                // An alternative might be to return " + val + " for types.Bytes to
                // simulate the JSON encoding.
                case types.String, types.Bytes:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(structType)
                        if err == nil </span><span class="cov8" title="1">{
                                b, err = raw.(*structpb.Value).MarshalJSON()
                        }</span>
                case types.Double, types.Int:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(structType)
                        if err == nil </span><span class="cov8" title="1">{
                                b, err = raw.(*structpb.Value).MarshalJSON()
                        }</span>
                case traits.Lister:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(listType)
                        if err == nil </span><span class="cov8" title="1">{
                                s, err := protojson.Marshal(raw.(proto.Message))
                                if err == nil </span><span class="cov8" title="1">{
                                        b = s
                                }</span>
                        }
                case traits.Mapper:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(mapType)
                        if err == nil </span><span class="cov8" title="1">{
                                s, err := protojson.Marshal(raw.(proto.Message))
                                if err == nil </span><span class="cov8" title="1">{
                                        b = s
                                }</span>
                        }
                case types.Bool:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(structType)
                        if err == nil </span><span class="cov8" title="1">{
                                b, err = json.Marshal(raw.(*structpb.Value).GetBoolValue())
                        }</span>
                default:<span class="cov0" title="0">
                        raw, err = val.ConvertToNative(reflect.TypeOf([]byte{}))
                        if err == nil </span><span class="cov0" title="0">{
                                b = raw.([]byte)
                        }</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.Internal, "failed to convert overlay result to type: %v", err)
                }</span>

                // TODO: For backwards compatibility, consider also merging and returning the body back?
                <span class="cov8" title="1">if extensions == nil </span><span class="cov8" title="1">{
                        extensions = []byte("{}")
                }</span>
                <span class="cov8" title="1">extensions, err = sjson.SetRawBytes(extensions, u.Key, b)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.Internal, "failed to sjson for key '%s' to '%s': %v", u.Key, val, err)
                }</span>
        }

        <span class="cov8" title="1">if extensions == nil </span><span class="cov8" title="1">{
                return &amp;triggersv1.InterceptorResponse{
                        Continue: true,
                }
        }</span>

        <span class="cov8" title="1">extensionsMap := map[string]interface{}{}
        if err := json.Unmarshal(extensions, &amp;extensionsMap); err != nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.Internal, "failed to unmarshal extensions into map: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue:   true,
                Extensions: extensionsMap,
        }</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cel

import (
        "context"
        "crypto/subtle"
        "encoding/json"
        "net/http"
        "net/url"
        "reflect"
        "regexp"
        "strings"

        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
        "github.com/google/cel-go/common/types/traits"
        "github.com/google/cel-go/interpreter/functions"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "sigs.k8s.io/yaml"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

// Triggers returns a cel.EnvOption to configure extended functions for
// Tekton CEL interceptor expressions.
//
// match
//
// Returns true if the specified provided header matches the provided string
// key.
//
// It is case insensitive; the header is canonicalised using the rules described
// here https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
//
//     &lt;header&gt;.match(&lt;string&gt;, &lt;string&gt;) -&gt; &lt;bool&gt;
//
// Examples:
//
//     header.match('X-Github-Event', 'push')
//
// canonical
//
// Can only be applied to the `header` key in the CEL expression context.
//
// Gets the first value associated with the given key. If there are no values
// associated with the key, returns "".
//
// It is case insensitive; the header is canonicalised using the rules described
// here https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
//
//     &lt;header&gt;.canonical(&lt;string&gt;) -&gt; &lt;string&gt;
//
// Examples:
//
//     header.canonical('X-Github-Event') // returns 'push'
//
// truncate
//
// Returns a truncated copy of the string, at the given position.
//
// If the requested length is longer than the actual length, then the string
// will be returned unchanged.
//
//     &lt;string&gt;.truncate(&lt;int&gt;) -&gt; &lt;string&gt;
//
// Examples:
//
//     body.request.sha.truncate(7) // returns truncated string
//
// compareSecret
//
// Returns true if the string matches the value from a Kubernetes secret with
// the provided key, secret-name, namespace combination.
//
//     &lt;string&gt;.compareSecret(&lt;string&gt;, &lt;string&gt;, &lt;string&gt;) -&gt; &lt;bool&gt;
//
// Examples:
//
//     header.canonical('X-Secret-Token').compareSecret('key', 'secret-name', 'namespace')
//
// There is also an alternative compareSecret which accepts two parameters
//
// Returns true if the string matches the value from a Kubernetes secret with
// the provided key, secret-name combination, this default to the namespace the
// event-listener is in.
//
//     &lt;string&gt;.compareSecret(&lt;string&gt;, &lt;string&gt;) -&gt; &lt;bool&gt;
//
// Examples:
//
//     header.canonical('X-Secret-Token').compareSecret('key', 'secret-name')
//
// parseJSON
//
// Parses a string into a map of strings to dynamic values.
//
//     &lt;string&gt;.parseJSON() -&gt; map&lt;string, dyn&gt;
//
// Examples:
//
//     body.field.parseJSON().item
//
// parseURL
//
// Parses a URL (in the form of a string) into a map with keys representing the
// elements of the URL.
//
//     &lt;string&gt;.parseURL() -&gt; map&lt;string, dyn&gt;
//
// Examples:
//
//     'https://example.com/testing'.parseURL().host == 'example.com'
//
// parseYAML
//
// Parses a YAML string into a map of strings to dynamic values
//
//                 &lt;string&gt;.parseYAML() -&gt; map&lt;string, dyn&gt;
//
// Examples:
//
//                 body.field.parseYAML().item
//
// marshalJSON
//
// Returns the JSON encoding of 'jsonObjectOrList'.
//
//                 &lt;jsonObjectOrList&gt;.marshalJSON() -&gt; &lt;string&gt;
//
// Examples:
//
//                 body.jsonObjectOrList.marshalJSON()

// translate
//
// translate returns a copy of src, replacing matches of the with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.
//
//                 &lt;string&gt;.translate(string, string) -&gt; &lt;string&gt;
//
// Examples:
//
//                 "this is $aN INvalid5string ".replace("[^a-z0-9]+", "") == "thisisaninvalid5string"

// Triggers creates and returns a new cel.Lib with the triggers extensions.
func Triggers(ctx context.Context, ns string, sg interceptors.SecretGetter) cel.EnvOption <span class="cov8" title="1">{
        return cel.Lib(triggersLib{ctx: ctx, defaultNS: ns, secretGetter: sg})
}</span>

type triggersLib struct {
        ctx          context.Context //nolint:containedctx
        defaultNS    string
        secretGetter interceptors.SecretGetter
}

func (t triggersLib) CompileOptions() []cel.EnvOption <span class="cov8" title="1">{
        mapStrDyn := cel.MapType(cel.StringType, cel.DynType)
        listStrDyn := cel.ListType(cel.DynType)
        return []cel.EnvOption{
                cel.Function("match",
                        cel.MemberOverload("match_map_string_string", []*cel.Type{mapStrDyn, cel.StringType, cel.StringType}, cel.BoolType,
                                cel.FunctionBinding(matchHeader))),
                cel.Function("canonical",
                        cel.MemberOverload("canonical_map_string", []*cel.Type{mapStrDyn, cel.StringType}, cel.StringType,
                                cel.BinaryBinding(canonicalHeader))),
                cel.Function("truncate",
                        cel.MemberOverload("truncate_string_uint", []*cel.Type{cel.StringType, cel.IntType}, cel.StringType,
                                cel.BinaryBinding(truncateString))),
                cel.Function("compareSecret",
                        cel.MemberOverload("compareSecret_string_string_string", []*cel.Type{cel.StringType, cel.StringType, cel.StringType, cel.StringType}, cel.BoolType,
                                cel.FunctionBinding(makeCompareSecret(t.ctx, t.defaultNS, t.secretGetter))),
                        cel.MemberOverload("compareSecret_string_string", []*cel.Type{cel.StringType, cel.StringType, cel.StringType}, cel.BoolType,
                                cel.FunctionBinding(makeCompareSecret(t.ctx, t.defaultNS, t.secretGetter)))),
                cel.Function("parseJSON",
                        cel.MemberOverload("parseJSON_string", []*cel.Type{cel.StringType}, mapStrDyn,
                                cel.UnaryBinding(parseJSONString))),
                cel.Function("parseYAML",
                        cel.MemberOverload("parseYAML_string", []*cel.Type{cel.StringType}, mapStrDyn,
                                cel.UnaryBinding(parseYAMLString))),
                cel.Function("parseURL",
                        cel.MemberOverload("parseURL_string", []*cel.Type{cel.StringType}, mapStrDyn,
                                cel.UnaryBinding(parseURLString))),
                cel.Function("marshalJSON",
                        cel.MemberOverload("marshalJSON_map", []*cel.Type{mapStrDyn}, cel.StringType,
                                cel.UnaryBinding(marshalJSON)),
                        cel.MemberOverload("marshalJSON_list", []*cel.Type{listStrDyn}, cel.StringType,
                                cel.UnaryBinding(marshalJSON))),
                cel.Function("last",
                        cel.MemberOverload("last_list", []*cel.Type{listStrDyn}, cel.DynType,
                                cel.UnaryBinding(listLast))),
                cel.Function("first",
                        cel.MemberOverload("first_list", []*cel.Type{listStrDyn}, cel.DynType,
                                cel.UnaryBinding(listFirst))),
                cel.Function("translate",
                        cel.MemberOverload("translate_string_string", []*cel.Type{cel.StringType, cel.StringType, cel.StringType}, cel.StringType,
                                cel.FunctionBinding(translateString))),
        }
}</span>

func (t triggersLib) ProgramOptions() []cel.ProgramOption <span class="cov8" title="1">{
        return []cel.ProgramOption{}
}</span>

func matchHeader(vals ...ref.Val) ref.Val <span class="cov8" title="1">{
        h, err := vals[0].ConvertToNative(reflect.TypeOf(http.Header{}))
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to convert to http.Header: %w", err)
        }</span>

        <span class="cov8" title="1">key := vals[1].(types.String)
        val := vals[2].(types.String)
        return types.Bool(h.(http.Header).Get(string(key)) == string(val))</span>
}

func truncateString(lhs, rhs ref.Val) ref.Val <span class="cov8" title="1">{
        str := lhs.(types.String)
        n := rhs.(types.Int)
        return str[:max(n, types.Int(len(str)))]
}</span>

func canonicalHeader(lhs, rhs ref.Val) ref.Val <span class="cov8" title="1">{
        h, err := lhs.ConvertToNative(reflect.TypeOf(http.Header{}))
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to convert to http.Header: %w", err)
        }</span>

        <span class="cov8" title="1">key := rhs.(types.String)
        return types.String(h.(http.Header).Get(string(key)))</span>
}

// makeCompareSecret creates and returns a functions.FunctionOp that wraps the
// ns and client in a closure with a function that can compare the string.
func makeCompareSecret(ctx context.Context, defaultNS string, sg interceptors.SecretGetter) functions.FunctionOp <span class="cov8" title="1">{
        return func(vals ...ref.Val) ref.Val </span><span class="cov8" title="1">{
                var ok bool
                compareString, ok := vals[0].(types.String)
                if !ok </span><span class="cov0" title="0">{
                        return types.ValOrErr(compareString, "unexpected type '%v' passed to compareSecret", vals[0].Type())
                }</span>

                <span class="cov8" title="1">secretNS := types.String(defaultNS)

                secretName, ok := vals[2].(types.String)
                if !ok </span><span class="cov0" title="0">{
                        return types.ValOrErr(secretName, "unexpected type '%v' passed to compareSecret", vals[2].Type())
                }</span>

                <span class="cov8" title="1">secretKey, ok := vals[1].(types.String)
                if !ok </span><span class="cov0" title="0">{
                        return types.ValOrErr(secretKey, "unexpected type '%v' passed to compareSecret", vals[3].Type())
                }</span>

                <span class="cov8" title="1">secretRef := &amp;triggersv1.SecretRef{
                        SecretKey:  string(secretKey),
                        SecretName: string(secretName),
                }
                // GetSecretToken uses request as a cache key to cache secret lookup. Since multiple
                // triggers execute concurrently in separate goroutines, this cache is not very effective
                // for this use case
                secretToken, err := sg.Get(ctx, string(secretNS), secretRef)
                if err != nil </span><span class="cov8" title="1">{
                        return types.NewErr("failed to find secret '%#v' in compareSecret: %w", *secretRef, err)
                }</span>
                <span class="cov8" title="1">return types.Bool(subtle.ConstantTimeCompare(secretToken, []byte(compareString)) == 1)</span>
        }
}

func parseJSONString(val ref.Val) ref.Val <span class="cov8" title="1">{
        str := val.(types.String)
        decodedVal := map[string]interface{}{}
        err := json.Unmarshal([]byte(str), &amp;decodedVal)
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to decode '%v' in parseJSON: %w", str, err)
        }</span>
        <span class="cov8" title="1">r, err := types.NewRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to create a new registry in parseJSON: %w", err)
        }</span>

        <span class="cov8" title="1">return types.NewDynamicMap(r, decodedVal)</span>
}

func parseYAMLString(val ref.Val) ref.Val <span class="cov8" title="1">{
        str := val.(types.String)
        decodedVal := map[string]interface{}{}
        err := yaml.Unmarshal([]byte(str), &amp;decodedVal)
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to decode '%v' in parseYAML: %w", str, err)
        }</span>
        <span class="cov8" title="1">r, err := types.NewRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to create a new registry in parseJSON: %w", err)
        }</span>
        <span class="cov8" title="1">return types.NewDynamicMap(r, decodedVal)</span>
}

func parseURLString(val ref.Val) ref.Val <span class="cov8" title="1">{
        str := val.(types.String)
        parsed, err := url.Parse(string(str))
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to decode '%v' in parseURL: %w", str, err)
        }</span>
        <span class="cov8" title="1">r, err := types.NewRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to create a new registry in parseJSON: %w", err)
        }</span>
        <span class="cov8" title="1">return types.NewDynamicMap(r, urlToMap(parsed))</span>
}

func marshalJSON(val ref.Val) ref.Val <span class="cov8" title="1">{
        var typeDesc reflect.Type

        switch val.Type() </span>{
        case types.MapType:<span class="cov8" title="1">
                typeDesc = mapType</span>
        case types.ListType:<span class="cov8" title="1">
                typeDesc = listType</span>
        default:<span class="cov0" title="0">
                return types.ValOrErr(val, "unexpected type '%v' passed to marshalJSON", val.Type())</span>
        }

        <span class="cov8" title="1">nativeVal, err := val.ConvertToNative(typeDesc)
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to convert to native: %w", err)
        }</span>

        <span class="cov8" title="1">marshaledVal, err := json.Marshal(nativeVal)
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to marshal to json: %w", err)
        }</span>

        <span class="cov8" title="1">return types.String(marshaledVal)</span>
}

func listLast(val ref.Val) ref.Val <span class="cov8" title="1">{
        l := val.(traits.Lister)
        sz := l.Size().Value().(int64)

        if sz == 0 </span><span class="cov8" title="1">{
                return types.NullValue
        }</span>

        <span class="cov8" title="1">return l.Get(types.Int(sz - 1))</span>
}

func listFirst(val ref.Val) ref.Val <span class="cov8" title="1">{
        l := val.(traits.Lister)
        sz := l.Size().Value().(int64)

        if sz == 0 </span><span class="cov8" title="1">{
                return types.NullValue
        }</span>

        <span class="cov8" title="1">return l.Get(types.Int(0))</span>
}

func translateString(vals ...ref.Val) ref.Val <span class="cov8" title="1">{
        regstr, ok := vals[1].(types.String)
        if !ok </span><span class="cov0" title="0">{
                return types.ValOrErr(regstr, "unexpected type '%v' used in translate", vals[1].Type())
        }</span>

        <span class="cov8" title="1">src, ok := vals[0].(types.String)
        if !ok </span><span class="cov0" title="0">{
                return types.ValOrErr(src, "unexpected type '%v' used in translate", vals[0].Type())
        }</span>

        <span class="cov8" title="1">repl, ok := vals[2].(types.String)
        if !ok </span><span class="cov0" title="0">{
                return types.ValOrErr(repl, "unexpected type '%v' used in translate", vals[2].Type())
        }</span>

        <span class="cov8" title="1">re, err := regexp.Compile(string(regstr))
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to parse regular expression for translation: %w", err)
        }</span>

        <span class="cov8" title="1">return types.String(re.ReplaceAllString(string(src), string(repl)))</span>
}

func max(x, y types.Int) types.Int <span class="cov8" title="1">{ //nolint: revive
        switch x.Compare(y) </span>{
        case types.IntNegOne:<span class="cov8" title="1">
                return x</span>
        case types.IntOne:<span class="cov8" title="1">
                return y</span>
        default:<span class="cov8" title="1">
                return x</span>
        }
}

func urlToMap(u *url.URL) map[string]interface{} <span class="cov8" title="1">{
        // This doesn't return the RawPath.
        m := map[string]interface{}{
                "scheme":       u.Scheme,
                "host":         u.Host,
                "path":         u.Path,
                "rawQuery":     u.RawQuery,
                "fragment":     u.Fragment,
                "queryStrings": u.Query(),
                "query":        flatten(u.Query()),
        }
        if u.User != nil </span><span class="cov8" title="1">{
                pass, _ := u.User.Password()
                m["auth"] = map[string]string{
                        "username": u.User.Username(),
                        "password": pass,
                }
        }</span>
        <span class="cov8" title="1">return m</span>
}

func flatten(uv url.Values) map[string]string <span class="cov8" title="1">{
        r := map[string]string{}
        for k, v := range uv </span><span class="cov8" title="1">{
                r[k] = strings.Join(v, ",")
        }</span>
        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file181" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "regexp"
        "strings"

        gh "github.com/google/go-github/v31/github"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "golang.org/x/oauth2"
        "google.golang.org/grpc/codes"
        "gopkg.in/yaml.v2"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

const pullRequest = "pull_request"

var acceptedEventTypes = []string{pullRequest, "push"}

type testURLKey string

const (
        changedFilesExtensionsKey            = "changed_files"
        testURL                   testURLKey = "TESTURL"
        OKToTestCommentRegexp                = `(^|\n)\/ok-to-test(\r\n|\r|\n|$)`
)

// In a pull request, these are the only two events that should trigger a PipelineRun/TaskRun
var ownersEventTypes = []string{pullRequest, "issue_comment"}

// ErrInvalidContentType is returned when the content-type is not a JSON body.
var ErrInvalidContentType = errors.New("form parameter encoding not supported, please change the hook to send JSON payloads")

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

type payloadDetails struct {
        PrNumber     int
        Owner        string
        Repository   string
        ChangedFiles string
}

type OwnersPayloadDetails struct {
        PrNumber         int
        Sender           string
        Owner            string
        Repository       string
        IssueCommentBody string
}

type OwnersConfig struct {
        Approvers []string `json:"approvers,omitempty"`
        Reviewers []string `json:"reviewers,omitempty"`
}

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        SecretRef *triggersv1.SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes      []string        `json:"eventTypes,omitempty"`
        AddChangedFiles AddChangedFiles `json:"addChangedFiles,omitempty"`
        GithubOwners    Owners          `json:"githubOwners,omitempty"`
}

type CheckType string

const (
        // Set the checkType to orgMembers to allow org members to submit or comment on PR to proceed
        OrgMembers CheckType = "orgMembers"
        // Set the checkType to repoMembers to allow repo members to submit or comment on PR to proceed
        RepoMembers CheckType = "repoMembers"
        // Set the checkType to all if both repo members or org members can submit or comment on PR to proceed
        All CheckType = "all"
        // Set the checkType to none if neither of repo members or org members can not submit or comment on PR to proceed
        None CheckType = "none"
)

type Owners struct {
        Enabled bool `json:"enabled,omitempty"`
        // This param/variable is required for private repos or when checkType is set to orgMembers or repoMembers or all
        PersonalAccessToken *triggersv1.SecretRef `json:"personalAccessToken,omitempty"`
        // Set the value to one of the supported values (orgMembers, repoMembers, both, none)
        CheckType CheckType `json:"checkType,omitempty"`
}

type AddChangedFiles struct {
        Enabled             bool                  `json:"enabled,omitempty"`
        PersonalAccessToken *triggersv1.SecretRef `json:"personalAccessToken,omitempty"`
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        headers := interceptors.Canonical(r.Header)
        if v := headers.Get("Content-Type"); v == "application/x-www-form-urlencoded" </span><span class="cov8" title="1">{
                return interceptors.Fail(codes.InvalidArgument, ErrInvalidContentType.Error())
        }</span>

        <span class="cov8" title="1">p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">actualEvent := headers.Get("X-Github-Event")

        // Check if the event type is in the allow-list
        if p.EventTypes != nil </span><span class="cov8" title="1">{
                isAllowed := false
                for _, allowedEvent := range p.EventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                isAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isAllowed </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "event type %s is not allowed", actualEvent)
                }</span>
        }

        // Next validate secrets
        <span class="cov8" title="1">if p.SecretRef != nil </span><span class="cov8" title="1">{
                // Check the secret to see if it is empty
                if p.SecretRef.SecretKey == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "github interceptor secretRef.secretKey is empty")
                }</span>
                <span class="cov8" title="1">header := headers.Get("X-Hub-Signature-256")
                if header == "" </span><span class="cov8" title="1">{
                        header = headers.Get("X-Hub-Signature")
                }</span>
                <span class="cov8" title="1">if header == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "Must set X-Hub-Signature-256 or X-Hub-Signature header")
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
                secretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                <span class="cov8" title="1">if err := gh.ValidateSignature(header, []byte(r.Body), secretToken); err != nil </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, err.Error())
                }</span>
        }

        <span class="cov8" title="1">if p.AddChangedFiles.Enabled </span><span class="cov8" title="1">{
                shouldAddChangedFiles := false
                for _, allowedEvent := range acceptedEventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                shouldAddChangedFiles = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !shouldAddChangedFiles </span><span class="cov8" title="1">{
                        return &amp;triggersv1.InterceptorResponse{
                                Continue: true,
                        }
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">secretToken, err := w.getGithubTokenSecret(ctx, r, p)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                <span class="cov8" title="1">payload, err := parseBodyForChangedFiles(r.Body, actualEvent)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error parsing body: %v", err)
                }</span>

                <span class="cov8" title="1">var changedFiles string
                if actualEvent == pullRequest </span><span class="cov8" title="1">{
                        changedFiles, err = getChangedFilesFromPr(ctx, payload, headers.Get("X-Github-Enterprise-Host"), secretToken)
                        if err != nil </span><span class="cov0" title="0">{
                                return interceptors.Failf(codes.FailedPrecondition, "error getting changed files: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        changedFiles = payload.ChangedFiles
                }</span>

                <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                        Extensions: map[string]interface{}{
                                changedFilesExtensionsKey: changedFiles,
                        },
                        Continue: true,
                }</span>
        }

        // For event types pull_request, issue_comment check github owners approval is required
        // User can specify both event type or any one of them
        <span class="cov8" title="1">if p.GithubOwners.Enabled </span><span class="cov8" title="1">{
                ownerCheckAllowed := false
                for _, allowedEvent := range ownersEventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                ownerCheckAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !ownerCheckAllowed </span><span class="cov0" title="0">{
                        return &amp;triggersv1.InterceptorResponse{
                                Continue: true,
                        }
                }</span>
                <span class="cov8" title="1">ghToken, err := w.getPersonalAccessTokenSecret(ctx, r, p)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting github token: %v", err)
                }</span>
                <span class="cov8" title="1">if ghToken == "" &amp;&amp; (p.GithubOwners.CheckType != "none") </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "checkType is set to check org or repo members but no personalAccessToken was supplied")
                }</span>
                // The X-Github-Enterprise-Host header only exists when the webhook comes from a github enterprise
                // server and is left empty for regular hosted Github
                <span class="cov8" title="1">enterpriseBaseURL := headers.Get("X-Github-Enterprise-Host")
                client, err := makeClient(ctx, enterpriseBaseURL, ghToken)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error making client: %v", err)
                }</span>
                <span class="cov8" title="1">payload, err := parseBodyForOwners(r.Body, actualEvent)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error parsing body: %v", err)
                }</span>
                <span class="cov8" title="1">allowed, err := checkOwnershipAndMembership(ctx, payload, p, client)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error checking owner verification: %v", err)
                }</span>

                <span class="cov8" title="1">if allowed &amp;&amp; actualEvent == pullRequest </span><span class="cov8" title="1">{
                        return &amp;triggersv1.InterceptorResponse{
                                Continue: true,
                        }
                }</span>

                <span class="cov8" title="1">commentAllowed, err := okToTestFromAnOwner(ctx, payload, p, client)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error checking comments for verification: %v", err)
                }</span>
                <span class="cov8" title="1">if !commentAllowed </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "owners check requirements not met")
                }</span>
        }

        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue: true,
        }</span>
}

func (w *InterceptorImpl) getGithubTokenSecret(ctx context.Context, r *triggersv1.InterceptorRequest, p InterceptorParams) (string, error) <span class="cov8" title="1">{
        if p.AddChangedFiles.PersonalAccessToken == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if p.AddChangedFiles.PersonalAccessToken.SecretKey == "" </span><span class="cov8" title="1">{
                return "", errors.New("github interceptor githubToken.secretKey is empty")
        }</span>
        <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
        secretToken, err := w.SecretGetter.Get(ctx, ns, p.AddChangedFiles.PersonalAccessToken)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(secretToken), nil</span>
}

func parseBodyForChangedFiles(body string, eventType string) (payloadDetails, error) <span class="cov8" title="1">{
        results := payloadDetails{}
        if body == "" </span><span class="cov8" title="1">{
                return results, errors.New("body is empty")
        }</span>

        <span class="cov8" title="1">var jsonMap map[string]interface{}
        err := json.Unmarshal([]byte(body), &amp;jsonMap)
        if err != nil </span><span class="cov8" title="1">{
                return results, err
        }</span>

        <span class="cov8" title="1">var prNum int
        _, ok := jsonMap["number"]
        if ok </span><span class="cov8" title="1">{
                prNum = int(jsonMap["number"].(float64))
        }</span> else<span class="cov8" title="1"> {
                if eventType == pullRequest </span><span class="cov8" title="1">{
                        return results, errors.New("pull_request body missing 'number' field")
                }</span>
                <span class="cov8" title="1">prNum = -1</span>
        }

        <span class="cov8" title="1">repoSection, ok := jsonMap["repository"].(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository' field")
        }</span>

        <span class="cov8" title="1">fullName, ok := repoSection["full_name"].(string)
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository.full_name' field")
        }</span>

        <span class="cov8" title="1">changedFiles := []string{}

        commitsSection, ok := jsonMap["commits"].([]interface{})
        if ok </span><span class="cov8" title="1">{
                for _, commit := range commitsSection </span><span class="cov8" title="1">{
                        addedFiles, ok := commit.(map[string]interface{})["added"].([]interface{})
                        if !ok </span><span class="cov8" title="1">{
                                return results, errors.New("payload body missing 'commits.*.added' field")
                        }</span>

                        <span class="cov8" title="1">modifiedFiles, ok := commit.(map[string]interface{})["modified"].([]interface{})
                        if !ok </span><span class="cov8" title="1">{
                                return results, errors.New("payload body missing 'commits.*.modified' field")
                        }</span>

                        <span class="cov8" title="1">removedFiles, ok := commit.(map[string]interface{})["removed"].([]interface{})
                        if !ok </span><span class="cov8" title="1">{
                                return results, errors.New("payload body missing 'commits.*.removed' field")
                        }</span>
                        <span class="cov8" title="1">for _, fileName := range addedFiles </span><span class="cov8" title="1">{
                                changedFiles = append(changedFiles, fmt.Sprintf("%v", fileName))
                        }</span>

                        <span class="cov8" title="1">for _, fileName := range modifiedFiles </span><span class="cov8" title="1">{
                                changedFiles = append(changedFiles, fmt.Sprintf("%v", fileName))
                        }</span>

                        <span class="cov8" title="1">for _, fileName := range removedFiles </span><span class="cov8" title="1">{
                                changedFiles = append(changedFiles, fmt.Sprintf("%v", fileName))
                        }</span>
                }
        }

        <span class="cov8" title="1">results = payloadDetails{
                PrNumber:     prNum,
                Owner:        strings.Split(fullName, "/")[0],
                Repository:   strings.Split(fullName, "/")[1],
                ChangedFiles: strings.Join(changedFiles, ","),
        }
        return results, nil</span>
}

func getChangedFilesFromPr(ctx context.Context, payload payloadDetails, enterpriseBaseURL string, token string) (string, error) <span class="cov8" title="1">{
        changedFiles := []string{}

        client, err := makeClient(ctx, enterpriseBaseURL, token)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">opt := &amp;gh.ListOptions{PerPage: 100}
        for </span><span class="cov8" title="1">{
                files, resp, err := client.PullRequests.ListFiles(ctx, payload.Owner, payload.Repository, payload.PrNumber, opt)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                        changedFiles = append(changedFiles, *file.Filename)
                }</span>

                <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">opt.Page = resp.NextPage</span>
        }

        <span class="cov8" title="1">return strings.Join(changedFiles, ","), nil</span>
}

func makeClient(ctx context.Context, enterpriseBaseURL string, token string) (*gh.Client, error) <span class="cov8" title="1">{
        var httpClient *http.Client
        var client *gh.Client
        var err error

        if token != "" </span><span class="cov8" title="1">{
                tokenSource := oauth2.StaticTokenSource(
                        &amp;oauth2.Token{AccessToken: token},
                )
                httpClient = oauth2.NewClient(ctx, tokenSource)
        }</span> else<span class="cov8" title="1"> {
                httpClient = nil
        }</span>

        <span class="cov8" title="1">testingURL := ""
        if ctx.Value(testURL) != nil </span><span class="cov8" title="1">{
                testingURL = fmt.Sprintf("%v", ctx.Value(testURL))
        }</span>

        <span class="cov8" title="1">if enterpriseBaseURL != "" || testingURL != "" </span><span class="cov8" title="1">{
                enterpriseBaseURL = "https://" + enterpriseBaseURL
                if testingURL != "" </span><span class="cov8" title="1">{
                        enterpriseBaseURL = testingURL
                }</span>

                <span class="cov8" title="1">client, err = gh.NewEnterpriseClient(enterpriseBaseURL, enterpriseBaseURL, httpClient)
                if err != nil </span><span class="cov0" title="0">{
                        return client, err
                }</span>
        } else<span class="cov8" title="1"> {
                client = gh.NewClient(httpClient)
        }</span>
        <span class="cov8" title="1">return client, nil</span>
}

func (w *InterceptorImpl) getPersonalAccessTokenSecret(ctx context.Context, r *triggersv1.InterceptorRequest, p InterceptorParams) (string, error) <span class="cov8" title="1">{
        if p.GithubOwners.PersonalAccessToken == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if p.GithubOwners.PersonalAccessToken.SecretKey == "" </span><span class="cov8" title="1">{
                return "", errors.New("github interceptor personalAccessToken.secretKey is empty")
        }</span>
        <span class="cov8" title="1">if r.Context == nil </span><span class="cov8" title="1">{
                return "", errors.New("no request context passed")
        }</span>
        <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
        secretToken, err := w.SecretGetter.Get(ctx, ns, p.GithubOwners.PersonalAccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(secretToken), nil</span>
}

func okToTestFromAnOwner(ctx context.Context, payload OwnersPayloadDetails, p InterceptorParams, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        if MatchRegexp(OKToTestCommentRegexp, payload.IssueCommentBody) </span><span class="cov8" title="1">{
                allowed, err := checkOwnershipAndMembership(ctx, payload, p, client)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

func checkOwnershipAndMembership(ctx context.Context, payload OwnersPayloadDetails, p InterceptorParams, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        if p.GithubOwners.CheckType == "orgMembers" || p.GithubOwners.CheckType == "all" </span><span class="cov8" title="1">{
                isUserMemberOrg, err := checkSenderOrgMembership(ctx, payload, client)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if isUserMemberOrg </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">if p.GithubOwners.CheckType == "repoMembers" || p.GithubOwners.CheckType == "all" </span><span class="cov8" title="1">{
                checkSenderRepoMembership, err := checkSenderRepoMembership(ctx, payload, client)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if checkSenderRepoMembership </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">ownerContent, err := getContentFromOwners(ctx, "OWNERS", payload, client)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "404") </span><span class="cov8" title="1">{
                        // no owner file, skipping
                        return false, nil
                }</span>
                <span class="cov8" title="1">return false, err</span>
        }

        <span class="cov8" title="1">return userInOwnerFile(ownerContent, payload.Sender)</span>
}

func checkSenderOrgMembership(ctx context.Context, payload OwnersPayloadDetails, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        users, resp, err := client.Organizations.ListMembers(ctx, payload.Owner, &amp;gh.ListMembersOptions{
                PublicOnly: true, // we can't list private member in a org
        })
        if resp != nil &amp;&amp; resp.Response.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, user := range users </span><span class="cov8" title="1">{
                login := *user.Login
                if login == payload.Sender </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

func checkSenderRepoMembership(ctx context.Context, payload OwnersPayloadDetails, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        users, _, err := client.Repositories.ListCollaborators(ctx, payload.Owner, payload.Repository, &amp;gh.ListCollaboratorsOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, user := range users </span><span class="cov8" title="1">{
                login := *user.Login
                if login == payload.Sender </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

func getContentFromOwners(ctx context.Context, path string, payload OwnersPayloadDetails, client *gh.Client) (string, error) <span class="cov8" title="1">{
        fileContent, directoryContent, _, err := client.Repositories.GetContents(ctx, payload.Owner, payload.Repository, path, &amp;gh.RepositoryContentGetOptions{})

        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if directoryContent != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("referenced file inside the Github Repository %s is a directory", path)
        }</span>

        <span class="cov8" title="1">fileData, err := fileContent.GetContent()

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fileData, nil</span>
}

func userInOwnerFile(ownerContent, sender string) (bool, error) <span class="cov8" title="1">{
        oc := OwnersConfig{}
        err := yaml.Unmarshal([]byte(ownerContent), &amp;oc)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, owner := range append(oc.Approvers, oc.Reviewers...) </span><span class="cov8" title="1">{
                if strings.EqualFold(owner, sender) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

func MatchRegexp(reg, comment string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(reg)
        return string(re.Find([]byte(comment))) != ""
}</span>

func parseBodyForOwners(body string, eventType string) (OwnersPayloadDetails, error) <span class="cov8" title="1">{
        results := OwnersPayloadDetails{}
        if body == "" </span><span class="cov8" title="1">{
                return results, errors.New("payload body is empty")
        }</span>
        <span class="cov8" title="1">var jsonMap map[string]interface{}
        err := json.Unmarshal([]byte(body), &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return results, err
        }</span>

        <span class="cov8" title="1">var prNum int
        if eventType == pullRequest </span><span class="cov8" title="1">{
                _, ok := jsonMap["number"]
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("pull_request body missing 'number' field")
                }</span>
                <span class="cov8" title="1">prNum = int(jsonMap["number"].(float64))</span>
        } else<span class="cov8" title="1"> {
                prNum = -1
        }</span>

        <span class="cov8" title="1">var issueCommentBody string
        if eventType == "issue_comment" </span><span class="cov8" title="1">{
                issueSection, ok := jsonMap["issue"].(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("issue_comment body missing 'issue' section")
                }</span>
                <span class="cov8" title="1">_, ok = issueSection["number"]
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("'number' field missing in the issue section of issue_comment body")
                }</span>
                <span class="cov8" title="1">prNum = int(issueSection["number"].(float64))

                issueCommentBodySection, ok := jsonMap["comment"].(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("issue_comment body missing 'comment' section")
                }</span>
                <span class="cov8" title="1">_, ok = issueCommentBodySection["body"]
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("'body' field missing in the comment section of issue_comment body")
                }</span>
                <span class="cov8" title="1">issueCommentBody = issueCommentBodySection["body"].(string)</span>
        } else<span class="cov8" title="1"> {
                issueCommentBody = ""
        }</span>

        <span class="cov8" title="1">repoSection, ok := jsonMap["repository"].(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository' field")
        }</span>

        <span class="cov8" title="1">fullName, ok := repoSection["full_name"].(string)
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository.full_name' field")
        }</span>

        <span class="cov8" title="1">senderSection, ok := jsonMap["sender"].(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'sender' field")
        }</span>
        <span class="cov8" title="1">prSender, _ := senderSection["login"].(string)

        results = OwnersPayloadDetails{
                PrNumber:         prNum,
                Sender:           prSender,
                Owner:            strings.Split(fullName, "/")[0],
                Repository:       strings.Split(fullName, "/")[1],
                IssueCommentBody: issueCommentBody,
        }

        return results, nil</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitlab

import (
        "context"
        "crypto/subtle"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "google.golang.org/grpc/codes"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        SecretRef *triggersv1.SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">headers := interceptors.Canonical(r.Header)

        // Check if the event type is in the allow-list
        if p.EventTypes != nil </span><span class="cov8" title="1">{
                actualEvent := headers.Get("X-Gitlab-Event")
                isAllowed := false
                for _, allowedEvent := range p.EventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                isAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isAllowed </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "event type %s is not allowed", actualEvent)
                }</span>
        }

        // Next validate secrets
        <span class="cov8" title="1">if p.SecretRef != nil </span><span class="cov8" title="1">{
                // Check the secret to see if it is empty
                if p.SecretRef.SecretKey == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "gitlab interceptor secretRef.secretKey is empty")
                }</span>
                <span class="cov8" title="1">header := headers.Get("X-Gitlab-Token")
                if header == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.InvalidArgument, "no X-Gitlab-Token header set")
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
                secretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                // Make sure to use a constant time comparison here.
                <span class="cov8" title="1">if subtle.ConstantTimeCompare([]byte(header), secretToken) == 0 </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.InvalidArgument, "Invalid X-GitLab-Token")
                }</span>
        }
        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue: true,
        }</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptors

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "google.golang.org/grpc/codes"
        "knative.dev/pkg/apis"
)

const (
        CoreInterceptorsHost = "tekton-triggers-core-interceptors"
        ContentType          = "application/json"
)

// Interceptor is the interface that all interceptors implement.
type Interceptor interface {
        ExecuteTrigger(req *http.Request) (*http.Response, error)
}

// GetInterceptorParams returns InterceptorParams for the current interceptors
func GetInterceptorParams(i *triggersv1beta1.EventInterceptor) map[string]interface{} <span class="cov8" title="1">{
        ip := map[string]interface{}{}
        switch </span>{
        case i.Webhook != nil:<span class="cov8" title="1">
                // WebHook headers are of type map[string][]string.
                // Use old style for now. Upgrade later.
                if i.Webhook != nil </span><span class="cov8" title="1">{
                        ip["objectRef"] = i.Webhook.ObjectRef
                        ip["header"] = i.Webhook.Header
                }</span>
        case i.Params != nil:<span class="cov8" title="1">
                for _, p := range i.Params </span><span class="cov8" title="1">{
                        ip[p.Name] = p.Value
                }</span>
        }
        <span class="cov8" title="1">return ip</span>
}

// Fail constructs a InterceptorResponse that should not continue further processing.
func Fail(c codes.Code, msg string) *triggersv1beta1.InterceptorResponse <span class="cov8" title="1">{
        return &amp;triggersv1beta1.InterceptorResponse{
                Continue: false,
                Status: triggersv1beta1.Status{
                        Code:    c,
                        Message: msg,
                },
        }
}</span>

// Failf constructs a InterceptorResponse that should not continue further processing.
func Failf(c codes.Code, format string, a ...interface{}) *triggersv1beta1.InterceptorResponse <span class="cov8" title="1">{
        return Fail(c, fmt.Sprintf(format, a...))
}</span>

// Canonical updates the map keys to use the Canonical name
func Canonical(h map[string][]string) http.Header <span class="cov8" title="1">{
        c := map[string][]string{}
        for k, v := range h </span><span class="cov8" title="1">{
                c[http.CanonicalHeaderKey(k)] = v
        }</span>
        <span class="cov8" title="1">return http.Header(c)</span>
}

// UnmarshalParams unmarshalls the passed in InterceptorParams into the provided param struct
func UnmarshalParams(ip map[string]interface{}, p interface{}) error <span class="cov8" title="1">{
        b, err := json.Marshal(ip)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to marshal json: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;p); err != nil </span><span class="cov0" title="0">{
                // Should never happen since Unmarshall only returns err if json is invalid which we already check above
                return fmt.Errorf("invalid json: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type InterceptorGetter func(name string) (*triggersv1alpha1.ClusterInterceptor, error)

// ResolveToURL finds an Interceptor's URL.
func ResolveToURL(getter InterceptorGetter, name string) (*apis.URL, error) <span class="cov8" title="1">{
        ic, err := getter(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", name, err)
        }</span>
        <span class="cov8" title="1">if addr := ic.Status.Address; addr != nil </span><span class="cov8" title="1">{
                if addr.URL != nil </span><span class="cov8" title="1">{
                        return addr.URL, nil
                }</span>
        }
        // If the status does not have a URL, try to generate it from the Spec.
        <span class="cov8" title="1">return ic.ResolveAddress()</span>
}

func Execute(ctx context.Context, client *http.Client, req *triggersv1beta1.InterceptorRequest, url string) (*triggersv1beta1.InterceptorResponse, error) <span class="cov8" title="1">{
        b, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // TODO: Seed context with timeouts
        <span class="cov8" title="1">r, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(b))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r.Header.Set("Content-Type", ContentType)

        res, err := client.Do(r)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if res.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                // TODO: error type for easier checking. wrap in status.Errorf?
                return nil, fmt.Errorf("interceptor response was not 200: %v", string(body))
        }</span>
        <span class="cov8" title="1">iresp := triggersv1beta1.InterceptorResponse{}
        if err := json.Unmarshal(body, &amp;iresp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;iresp, nil</span>
}
</pre>
		
		<pre class="file" id="file184" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptors

import (
        "context"
        "fmt"
        "time"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/cache"
        corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
)

const (
        // cacheSize is the size of the LRU secrets cache
        cacheSize = 1024
        // ttl is the time to live for a cache entry
        ttl = 5 * time.Second
)

type SecretGetter interface {
        Get(ctx context.Context, triggerNS string, sr *triggersv1beta1.SecretRef) ([]byte, error)
}

type kubeclientSecretGetter struct {
        getter corev1.SecretsGetter
        cache  *cache.LRUExpireCache
        ttl    time.Duration
}

type cacheKey struct {
        triggerNS string
        sr        triggersv1beta1.SecretRef
}

func DefaultSecretGetter(getter corev1.SecretsGetter) SecretGetter <span class="cov8" title="1">{
        return &amp;kubeclientSecretGetter{
                getter: getter,
                cache:  cache.NewLRUExpireCache(cacheSize),
                ttl:    ttl,
        }
}</span>

// Get queries Kubernetes for the given secret reference. We use this function
// to resolve secret material like GitHub webhook secrets, and call it once for every
// trigger that references it.
//
// As we may have many triggers that all use the same secret, we cache the secret values
// in the request cache.
func (g *kubeclientSecretGetter) Get(ctx context.Context, triggerNS string, sr *triggersv1beta1.SecretRef) ([]byte, error) <span class="cov8" title="1">{
        key := cacheKey{
                triggerNS: triggerNS,
                sr:        *sr,
        }
        val, ok := g.cache.Get(key)
        if ok </span><span class="cov8" title="1">{
                return val.([]byte), nil
        }</span>
        <span class="cov8" title="1">secret, err := g.getter.Secrets(triggerNS).Get(ctx, sr.SecretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">secretValue, ok := secret.Data[sr.SecretKey]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot find %s key in secret %s/%s", sr.SecretKey, triggerNS, sr.SecretName)
        }</span>
        <span class="cov8" title="1">g.cache.Add(key, secretValue, g.ttl)
        return secretValue, nil</span>
}
</pre>
		
		<pre class="file" id="file185" style="display: none">package server

import (
        "bytes"
        "context"
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "encoding/pem"
        "errors"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "github.com/tektoncd/triggers/pkg/interceptors/bitbucket"
        "github.com/tektoncd/triggers/pkg/interceptors/cel"
        "github.com/tektoncd/triggers/pkg/interceptors/github"
        "github.com/tektoncd/triggers/pkg/interceptors/gitlab"
        "github.com/tektoncd/triggers/pkg/interceptors/slack"
        "go.uber.org/zap"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
        secretInformer "knative.dev/pkg/client/injection/kube/informers/core/v1/secret"
        "knative.dev/pkg/system"
        certresources "knative.dev/pkg/webhook/certificates/resources"
)

const (
        Century                 = 100 * 365 * 24 * time.Hour
        interceptorTLSSecretKey = "INTERCEPTOR_TLS_SECRET_NAME"
        interceptorTLSSvcKey    = "INTERCEPTOR_TLS_SVC_NAME"
)

type keypairReloader struct {
        caCertData     []byte
        serverCertData []byte
}

type Server struct {
        Logger       *zap.SugaredLogger
        interceptors map[string]triggersv1.InterceptorInterface
}

// RegisterInterceptor sets up the interceptor to be served at the specfied path
func (is *Server) RegisterInterceptor(path string, interceptor triggersv1.InterceptorInterface) <span class="cov8" title="1">{
        if is.interceptors == nil </span><span class="cov8" title="1">{
                is.interceptors = map[string]triggersv1.InterceptorInterface{}
        }</span>
        <span class="cov8" title="1">is.interceptors[path] = interceptor</span>
}

func NewWithCoreInterceptors(sg interceptors.SecretGetter, logger *zap.SugaredLogger) (*Server, error) <span class="cov8" title="1">{
        i := map[string]triggersv1.InterceptorInterface{
                "bitbucket": bitbucket.NewInterceptor(sg),
                "cel":       cel.NewInterceptor(sg),
                "github":    github.NewInterceptor(sg),
                "gitlab":    gitlab.NewInterceptor(sg),
                "slack":     slack.NewInterceptor(sg),
        }

        for k, v := range i </span><span class="cov8" title="1">{
                if v == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("interceptor %s failed to initialize", k)
                }</span>
        }
        <span class="cov8" title="1">s := Server{
                Logger:       logger,
                interceptors: i,
        }
        return &amp;s, nil</span>
}

func (is *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        b, err := is.ExecuteInterceptor(r)
        if err != nil </span><span class="cov8" title="1">{
                </span><span class="cov8" title="1">{
                        var e Error
                        switch </span>{
                        case errors.As(err, &amp;e):<span class="cov8" title="1">
                                is.Logger.Infof("HTTP %d - %s", e.Status(), e)
                                http.Error(w, e.Error(), e.Status())</span>
                        default:<span class="cov0" title="0">
                                is.Logger.Errorf("Non Status Error: %s", err)
                                http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)</span>
                        }
                }
        }
        <span class="cov8" title="1">w.Header().Add("Content-Type", "application/json")
        if _, err := w.Write(b); err != nil </span><span class="cov0" title="0">{
                is.Logger.Errorf("failed to write response: %s", err)
        }</span>
}

// Error represents a handler error. It provides methods for a HTTP status
// code and embeds the built-in error interface.
type Error interface {
        error
        Status() int
}

// HTTPError represents an error with an associated HTTP status code.
type HTTPError struct {
        Code int
        Err  error
}

// Allows HTTPError to satisfy the error interface.
func (se HTTPError) Error() string <span class="cov8" title="1">{
        return se.Err.Error()
}</span>

// Returns our HTTP status code.
func (se HTTPError) Status() int <span class="cov8" title="1">{
        return se.Code
}</span>

func badRequest(err error) HTTPError <span class="cov8" title="1">{
        return HTTPError{Code: http.StatusBadRequest, Err: err}
}</span>

func internal(err error) HTTPError <span class="cov0" title="0">{
        return HTTPError{Code: http.StatusInternalServerError, Err: err}
}</span>

func (is *Server) ExecuteInterceptor(r *http.Request) ([]byte, error) <span class="cov8" title="1">{
        var ii triggersv1.InterceptorInterface

        // Find correct interceptor
        ii, ok := is.interceptors[strings.TrimPrefix(strings.ToLower(r.URL.Path), "/")]
        if !ok </span><span class="cov8" title="1">{
                return nil, badRequest(errors.New("path did not match any interceptors"))
        }</span>

        // Create a context
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        var body bytes.Buffer
        defer r.Body.Close()
        if _, err := io.Copy(&amp;body, r.Body); err != nil </span><span class="cov0" title="0">{
                return nil, internal(fmt.Errorf("failed to read body: %w", err))
        }</span>
        <span class="cov8" title="1">var ireq triggersv1.InterceptorRequest
        if err := json.Unmarshal(body.Bytes(), &amp;ireq); err != nil </span><span class="cov8" title="1">{
                return nil, badRequest(fmt.Errorf("failed to parse body as InterceptorRequest: %w", err))
        }</span>
        <span class="cov8" title="1">is.Logger.Debugf("Interceptor Request is: %+v", ireq)
        iresp := ii.Process(ctx, &amp;ireq)
        is.Logger.Infof("Interceptor response is: %+v", iresp)
        respBytes, err := json.Marshal(iresp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, internal(err)
        }</span>
        <span class="cov8" title="1">return respBytes, nil</span>
}

func CreateAndValidateCerts(ctx context.Context, coreV1Interface corev1.CoreV1Interface, logger *zap.SugaredLogger, service *Server, tc triggersv1alpha1.TriggersV1alpha1Interface) <span class="cov8" title="1">{
        serverCert, caCert, err := createCerts(ctx, coreV1Interface, time.Now().Add(Century), logger, false)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if err := service.listAndUpdateClusterInterceptorCRD(ctx, tc, caCert); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // After creating certificates using CreateCerts lets validate validity of created certificates
        <span class="cov8" title="1">service.checkCertValidity(ctx, serverCert, caCert, coreV1Interface, logger, tc, time.Minute)</span>
}

func createCerts(ctx context.Context, coreV1Interface corev1.CoreV1Interface, noAfter time.Time,
        logger *zap.SugaredLogger, certsExpire bool) ([]byte, []byte, error) <span class="cov8" title="1">{
        interceptorSvcName := os.Getenv(interceptorTLSSvcKey)
        interceptorSecretName := os.Getenv(interceptorTLSSecretKey)
        namespace := system.Namespace()

        secret, err := coreV1Interface.Secrets(namespace).Get(ctx, interceptorSecretName, metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // The secret should be created explicitly by a higher-level system
                        // that's responsible for install/updates.  We simply populate the
                        // secret information.
                        logger.Infof("secret %s is missing", interceptorSecretName)
                        return []byte{}, []byte{}, err
                }</span>
                <span class="cov0" title="0">logger.Infof("error accessing certificate secret %q: %v", interceptorSecretName, err)
                return []byte{}, []byte{}, err</span>
        }

        // checking the secret data existence, if secret exist and certs are not expired just return those instead of recreating.
        <span class="cov8" title="1">if !certsExpire </span><span class="cov8" title="1">{
                if serverKeyVal, ok := secret.Data[certresources.ServerKey]; ok </span><span class="cov8" title="1">{
                        if serverCertVal, ok := secret.Data[certresources.ServerCert]; ok </span><span class="cov8" title="1">{
                                if caCertVal, ok := secret.Data[certresources.CACert]; ok </span><span class="cov8" title="1">{
                                        if string(serverKeyVal) != "" &amp;&amp; string(serverCertVal) != "" &amp;&amp; string(caCertVal) != "" </span><span class="cov8" title="1">{
                                                return secret.Data[certresources.ServerCert], secret.Data[certresources.CACert], nil
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">serverKey, serverCert, caCert, err := certresources.CreateCerts(ctx, interceptorSvcName, namespace, noAfter)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to create certs : %v", err)
                return []byte{}, []byte{}, err
        }</span>

        <span class="cov8" title="1">secret.Data = map[string][]byte{
                certresources.ServerKey:  serverKey,
                certresources.ServerCert: serverCert,
                certresources.CACert:     caCert,
        }
        if _, err = coreV1Interface.Secrets(namespace).Update(ctx, secret, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to update secret : %v", err)
                return []byte{}, []byte{}, err
        }</span>

        <span class="cov8" title="1">return serverCert, caCert, nil</span>
}

// updateCRDWithCaCert updates clusterinterceptor crd caBundle with caCert
func (is *Server) updateCRDWithCaCert(ctx context.Context, triggersV1Alpha1 triggersv1alpha1.TriggersV1alpha1Interface,
        ci []v1alpha1.ClusterInterceptor, caCert []byte) error <span class="cov8" title="1">{
        for i := range ci </span><span class="cov8" title="1">{
                if _, ok := is.interceptors[ci[i].Name]; ok </span><span class="cov8" title="1">{
                        if bytes.Equal(ci[i].Spec.ClientConfig.CaBundle, []byte{}) || !bytes.Equal(ci[i].Spec.ClientConfig.CaBundle, caCert) </span><span class="cov8" title="1">{
                                ci[i].Spec.ClientConfig.CaBundle = caCert
                                if _, err := triggersV1Alpha1.ClusterInterceptors().Update(ctx, &amp;ci[i], metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (is *Server) checkCertValidity(ctx context.Context, serverCert, caCert []byte, coreV1Interface corev1.CoreV1Interface,
        logger *zap.SugaredLogger, tc triggersv1alpha1.TriggersV1alpha1Interface, tickerTime time.Duration) <span class="cov8" title="1">{
        result := &amp;keypairReloader{
                caCertData:     caCert,
                serverCertData: serverCert,
        }

        ticker := time.NewTicker(tickerTime)
        var (
                cert *x509.Certificate
                err  error
        )

        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        &lt;-ticker.C
                        // Check the expiration date of the certificate to see if it needs to be updated
                        roots := x509.NewCertPool()
                        ok := roots.AppendCertsFromPEM(result.caCertData)
                        if !ok </span><span class="cov0" title="0">{
                                logger.Error("failed to parse root certificate")
                        }</span>
                        <span class="cov8" title="1">block, _ := pem.Decode(result.serverCertData)
                        if block == nil </span><span class="cov0" title="0">{
                                logger.Error("failed to parse certificate PEM")
                        }</span> else<span class="cov8" title="1"> {
                                cert, err = x509.ParseCertificate(block.Bytes)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("failed to parse certificate: %v", err.Error())
                                }</span>
                        }

                        <span class="cov8" title="1">opts := x509.VerifyOptions{
                                Roots: roots,
                        }

                        if _, err := cert.Verify(opts); err != nil </span><span class="cov8" title="1">{
                                logger.Errorf("failed to verify certificate: %v", err.Error())

                                serverCertNew, caCertNew, err := createCerts(ctx, coreV1Interface, time.Now().Add(Century), logger, true)
                                if err != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("failed to create certs %v", err)
                                }</span>

                                <span class="cov8" title="1">result = &amp;keypairReloader{
                                        caCertData:     caCertNew,
                                        serverCertData: serverCertNew,
                                }
                                if err := is.listAndUpdateClusterInterceptorCRD(ctx, tc, caCertNew); err != nil </span><span class="cov0" title="0">{
                                        logger.Error(err.Error())
                                }</span>
                        }
                }
        }()
}

func (is *Server) listAndUpdateClusterInterceptorCRD(ctx context.Context, tc triggersv1alpha1.TriggersV1alpha1Interface, caCert []byte) error <span class="cov8" title="1">{
        clusterInterceptorList, err := tc.ClusterInterceptors().List(ctx, metav1.ListOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return is.updateCRDWithCaCert(ctx, tc, clusterInterceptorList.Items, caCert)</span>
}

func GetTLSData(ctx context.Context, logger *zap.SugaredLogger) (*tls.Certificate, error) <span class="cov8" title="1">{
        secret, err := secretInformer.Get(ctx).Lister().Secrets(system.Namespace()).Get(os.Getenv(interceptorTLSSecretKey))
        if err != nil </span><span class="cov8" title="1">{
                logger.Errorf("failed to fetch secret %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">serverKey, ok := secret.Data[certresources.ServerKey]
        if !ok </span><span class="cov8" title="1">{
                logger.Warn("server key missing")
                return nil, errors.New("server key missing")
        }</span>
        <span class="cov8" title="1">serverCert, ok := secret.Data[certresources.ServerCert]
        if !ok </span><span class="cov8" title="1">{
                logger.Warn("server cert missing")
                return nil, errors.New("server cert missing")
        }</span>
        <span class="cov8" title="1">cert, err := tls.X509KeyPair(serverCert, serverKey)
        return &amp;cert, err</span>
}

func UpdateCACertToClusterInterceptorCRD(ctx context.Context, service *Server, tc triggersv1alpha1.TriggersV1alpha1Interface, logger *zap.SugaredLogger, timer time.Duration) <span class="cov8" title="1">{
        interceptorSecretName := os.Getenv(interceptorTLSSecretKey)
        ticker := time.NewTicker(timer)
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        &lt;-ticker.C
                        secret, err := secretInformer.Get(ctx).Lister().Secrets(system.Namespace()).Get(interceptorSecretName)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("failed to fetch secret %v", err)
                                return
                        }</span>
                        <span class="cov8" title="1">caCert, ok := secret.Data[certresources.CACert]
                        if !ok </span><span class="cov0" title="0">{
                                logger.Warn("CACert key missing")
                                return
                        }</span>
                        <span class="cov8" title="1">if err := service.listAndUpdateClusterInterceptorCRD(ctx, tc, caCert); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }()
}
</pre>
		
		<pre class="file" id="file186" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package slack

import (
        "context"
        "encoding/json"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "google.golang.org/grpc/codes"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

// Interceptor parses all the requests fields from the slack form-data request
// and adds them to the extension
// revive:disable:unused-parameter
func (*InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        headers := interceptors.Canonical(r.Header)

        // validate slack headers
        if v := headers.Get("Content-Type"); v != "application/x-www-form-urlencoded" </span><span class="cov8" title="1">{
                return interceptors.Fail(codes.InvalidArgument, "missing header in payload: ContentType application/x-www-form-urlencoded")
        }</span>

        <span class="cov8" title="1">if s := headers.Get("X-Slack-Signature"); s == "" </span><span class="cov8" title="1">{
                return interceptors.Fail(codes.InvalidArgument, "missing header in payload: ContentType application/x-www-form-urlencoded")
        }</span>

        // get requests fields
        <span class="cov8" title="1">var payload map[string][]string
        if err := json.Unmarshal([]byte(r.Body), &amp;payload); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to unmarshl slack payload: %v", err)
        }</span>

        // get requests fields
        <span class="cov8" title="1">p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        // validate RequestedFields exists
        <span class="cov8" title="1">if p.RequestedFields == nil </span><span class="cov0" title="0">{
                return interceptors.Fail(codes.NotFound, "missing requested field definition")
        }</span>

        // extract required fields values
        <span class="cov8" title="1">extensions := make(map[string]interface{})

        for _, field := range p.RequestedFields </span><span class="cov8" title="1">{
                if value, ok := payload[field]; ok </span><span class="cov8" title="1">{
                        extensions[field] = value
                }</span> else<span class="cov0" title="0"> {
                        return interceptors.Failf(codes.NotFound, "requested field does not exists in payload %v", payload)
                }</span>
        }
        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue:   true,
                Extensions: extensions,
        }</span>
}

// revive:enable:unused-parameter

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

type InterceptorParams struct {
        // the Requested fields to be extracted from data form

        // +listType=atomic
        RequestedFields []string `json:"requestedFields,omitempty"`
}
</pre>
		
		<pre class="file" id="file187" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package webhook

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"

        "go.uber.org/zap"
)

const (
        // Timeout for outgoing requests to interceptor services
        interceptorTimeout = 5 * time.Second
        // the incoming request URL is passed through to the webhook in this header.
        webhookURLHeader = "Eventlistener-Request-Url"
)

type Interceptor struct {
        HTTPClient       *http.Client
        TriggerNamespace string
        Logger           *zap.SugaredLogger
        Webhook          *triggersv1.WebhookInterceptor
}

func NewInterceptor(wh *triggersv1.WebhookInterceptor, c *http.Client, ns string, l *zap.SugaredLogger) interceptors.Interceptor <span class="cov8" title="1">{
        timeoutClient := &amp;http.Client{
                Transport: c.Transport,
                Timeout:   interceptorTimeout,
        }
        return &amp;Interceptor{
                HTTPClient:       timeoutClient,
                TriggerNamespace: ns,
                Logger:           l,
                Webhook:          wh,
        }
}</span>

func (w *Interceptor) ExecuteTrigger(request *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        u, err := getURI(w.Webhook, w.TriggerNamespace) // TODO: Cache this result or do this on initialization
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request.Header.Set(webhookURLHeader, request.URL.String())
        request.URL = u
        request.Host = u.Host
        addInterceptorHeaders(request.Header, w.Webhook.Header)

        resp, err := w.HTTPClient.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                respBody, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, errors.New("failed to parse response body")
                }</span>
                <span class="cov8" title="1">return resp, fmt.Errorf("request rejected; status: %s; message: %s", resp.Status, respBody)</span>
        }
        <span class="cov8" title="1">return resp, err</span>
}

// getURI retrieves the ObjectReference to URI.
func getURI(webhook *triggersv1.WebhookInterceptor, ns string) (*url.URL, error) <span class="cov8" title="1">{
        // TODO: This should work for any Addressable.
        // Use something like https://github.com/knative/eventing-contrib/blob/7c0fc5cfa8bd44da0767d9e7b250264ea6eb7d8d/pkg/controller/sinks/sinks.go#L32
        switch </span>{
        case webhook.URL != nil:<span class="cov8" title="1">
                return webhook.URL.URL(), nil</span>
        case webhook.ObjectRef.Kind == "Service" &amp;&amp; webhook.ObjectRef.APIVersion == "v1":<span class="cov8" title="1">
                // TODO: Also assuming port 80 and http here. Use DNS/or the env vars?
                if webhook.ObjectRef.Namespace != "" </span><span class="cov8" title="1">{
                        ns = webhook.ObjectRef.Namespace
                }</span>
                <span class="cov8" title="1">return url.Parse(fmt.Sprintf("http://%s.%s.svc/", webhook.ObjectRef.Name, ns))</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("invalid objRef")</span>
        }
}

func addInterceptorHeaders(header http.Header, headerParams []pipelinev1.Param) <span class="cov8" title="1">{
        // This clobbers any matching headers
        for _, param := range headerParams </span><span class="cov8" title="1">{
                if param.Value.Type == pipelinev1.ParamTypeString </span><span class="cov8" title="1">{
                        header.Set(param.Name, param.Value.StringVal)
                }</span> else<span class="cov8" title="1"> {
                        header.Del(param.Name)
                        for _, v := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                                header.Add(param.Name, v)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file188" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package attributekey

import (
        "fmt"

        "go.opentelemetry.io/otel/attribute"
)

type ValueType interface {
        string | bool | int64 | int | float64 |
                []string | []bool | []int64 | []int | []float64
}

type (
        Type[T ValueType] string
        String            = Type[string]
        Bool              = Type[bool]
        Int               = Type[int]
        Int64             = Type[int64]
        Float64           = Type[float64]
)

func (key Type[T]) With(val T) attribute.KeyValue <span class="cov8" title="1">{
        k := string(key)

        switch v := any(val).(type) </span>{
        case string:<span class="cov8" title="1">
                return attribute.String(k, v)</span>
        case bool:<span class="cov8" title="1">
                return attribute.Bool(k, v)</span>
        case int64:<span class="cov8" title="1">
                return attribute.Int64(k, v)</span>
        case int:<span class="cov8" title="1">
                return attribute.Int(k, v)</span>
        case float64:<span class="cov8" title="1">
                return attribute.Float64(k, v)</span>
        case []string:<span class="cov8" title="1">
                return attribute.StringSlice(k, v)</span>
        case []bool:<span class="cov8" title="1">
                return attribute.BoolSlice(k, v)</span>
        case []int64:<span class="cov8" title="1">
                return attribute.Int64Slice(k, v)</span>
        case []int:<span class="cov8" title="1">
                return attribute.IntSlice(k, v)</span>
        case []float64:<span class="cov8" title="1">
                return attribute.Float64Slice(k, v)</span>
        default:<span class="cov0" title="0">
                // note - this can't happen due to type constraints
                panic(fmt.Sprintf("unsupported attribute type: %T", v))</span>
        }
}
</pre>
		
		<pre class="file" id="file189" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package observability

import (
        "context"

        "github.com/tektoncd/triggers/pkg/observability/metrics"
        "github.com/tektoncd/triggers/pkg/observability/runtime"
        "github.com/tektoncd/triggers/pkg/observability/tracing"
)

type (
        TracingConfig = tracing.Config
        MetricsConfig = metrics.Config
        RuntimeConfig = runtime.Config
)

type Config struct {
        Tracing TracingConfig `json:"tracing"`
        Metrics MetricsConfig `json:"metrics"`
        Runtime RuntimeConfig `json:"runtime"`
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Tracing: tracing.DefaultConfig(),
                Metrics: metrics.DefaultConfig(),
                Runtime: runtime.DefaultConfig(),
        }
}</span>

func NewFromMap(m map[string]string) (*Config, error) <span class="cov8" title="1">{
        var err error
        c := DefaultConfig()

        if c.Tracing, err = tracing.NewFromMap(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if c.Metrics, err = metrics.NewFromMap(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if c.Runtime, err = runtime.NewFromMap(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

type cfgKey struct{}

// WithConfig associates a observability configuration with the context.
func WithConfig(ctx context.Context, cfg *Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, cfgKey{}, cfg)
}</span>

// GetConfig gets the observability config from the provided context.
func GetConfig(ctx context.Context) *Config <span class="cov8" title="1">{
        untyped := ctx.Value(cfgKey{})
        if untyped == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return untyped.(*Config)</span>
}
</pre>
		
		<pre class="file" id="file190" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package configmap

import (
        "cmp"
        "os"

        "github.com/tektoncd/triggers/pkg/observability"
        corev1 "k8s.io/api/core/v1"
)

const (
        // The env var name for config-observability
        configMapNameEnv = "CONFIG_OBSERVABILITY_NAME"
        DefaultName      = "config-observability"
)

func Name() string <span class="cov8" title="1">{
        return cmp.Or(os.Getenv(configMapNameEnv), DefaultName)
}</span>

func Parse(c *corev1.ConfigMap) (*observability.Config, error) <span class="cov8" title="1">{
        return observability.NewFromMap(c.Data)
}</span>
</pre>
		
		<pre class="file" id="file191" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "fmt"
        "time"
)

const (
        ProtocolGRPC         = "grpc"
        ProtocolHTTPProtobuf = "http/protobuf"
        ProtocolPrometheus   = "prometheus"
        ProtocolNone         = "none"
)

// Config provides a unified observability configuration which can be used to
// manage Knative observability behavior.  Typically, this is extracted from a
// Kubernetes ConfigMap during application startup, and accessed via the
// GetConfig() method.
type Config struct {
        Protocol       string        `json:"protocol,omitempty"`
        Endpoint       string        `json:"endpoint,omitempty"`
        ExportInterval time.Duration `json:"exportInterval,omitempty"`
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        switch c.Protocol </span>{
        case ProtocolGRPC, ProtocolHTTPProtobuf:<span class="cov0" title="0">
                if c.Endpoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("endpoint should be set when protocol is %q", c.Protocol)
                }</span>
        case ProtocolNone:<span class="cov0" title="0">
                if c.Endpoint != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("endpoint should not be set when protocol is %q", c.Protocol)
                }</span>
        case ProtocolPrometheus:<span class="cov0" title="0"></span>
                // Endpoint is not required, but can be used to indicate listen port
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported protocol %q", c.Protocol)</span>
        }

        <span class="cov0" title="0">if c.ExportInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("export interval %q should be greater than zero", c.ExportInterval)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DefaultConfig returns a configuration with default values set.
func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Protocol: ProtocolNone,
        }
}</span>

// NewFromMap unpacks flat configuration values from a ConfigMap into
// the configuration used by different observability modules.
func NewFromMap(m map[string]string) (Config, error) <span class="cov0" title="0">{
        return NewFromMapWithPrefix("", m)
}</span>

func NewFromMapWithPrefix(prefix string, m map[string]string) (Config, error) <span class="cov0" title="0">{
        c := DefaultConfig()

        if val, ok := m[prefix+"metrics-protocol"]; ok </span><span class="cov0" title="0">{
                c.Protocol = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"metrics-endpoint"]; ok </span><span class="cov0" title="0">{
                c.Endpoint = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"metrics-export-interval"]; ok </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(val); err != nil </span><span class="cov0" title="0">{
                        return c, fmt.Errorf("invalid duration %q: %w", val, err)
                }</span> else<span class="cov0" title="0"> {
                        c.ExportInterval = duration
                }</span>
        }

        <span class="cov0" title="0">return c, c.Validate()</span>
}
</pre>
		
		<pre class="file" id="file192" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"
        "errors"

        "go.opentelemetry.io/otel/metric"
        "go.opentelemetry.io/otel/metric/noop"
)

type shutdownFunc func(ctx context.Context) error

func noopFunc(context.Context) error <span class="cov0" title="0">{ return nil }</span>

type MeterProvider struct {
        metric.MeterProvider
        shutdown []shutdownFunc
}

func (m *MeterProvider) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        var errs []error
        for _, shutdown := range m.shutdown </span><span class="cov0" title="0">{
                if err := shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov0" title="0">return errors.Join(errs...)</span>
}

func NewMeterProvider(
        ctx context.Context,
        cfg Config,
) (*MeterProvider, error) <span class="cov0" title="0">{
        if cfg.Protocol == ProtocolNone </span><span class="cov0" title="0">{
                return &amp;MeterProvider{MeterProvider: noop.NewMeterProvider()}, nil
        }</span>

        // For now, return a noop provider
        // In a full implementation, you would configure the appropriate provider
        // based on the protocol (gRPC, HTTP, Prometheus)
        <span class="cov0" title="0">return &amp;MeterProvider{
                MeterProvider: noop.NewMeterProvider(),
                shutdown:      []shutdownFunc{noopFunc},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resource

import (
        "os"
)

const otelServiceNameKey = "OTEL_SERVICE_NAME"

// Default returns a default service name for OpenTelemetry resource.
//
// It will return:
// - The provided service name, or
// - OTEL_SERVICE_NAME environment variable if set
func Default(serviceName string) string <span class="cov8" title="1">{
        // If the OTEL_SERVICE_NAME is set then let this override
        // our own serviceName
        if name := os.Getenv(otelServiceNameKey); name != "" </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return serviceName</span>
}
</pre>
		
		<pre class="file" id="file194" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package runtime

import (
        "fmt"
        "time"
)

const (
        ProfilingEnabled  = "enabled"
        ProfilingDisabled = "disabled"
)

type Config struct {
        Profiling      string        `json:"profiling,omitempty"`
        ExportInterval time.Duration `json:"exportInterval,omitempty"`
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        switch c.Profiling </span>{
        case ProfilingEnabled, ProfilingDisabled:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported profile setting %q", c.Profiling)</span>
        }

        // ExportInterval == 0 =&gt; OTel will use a default value
        <span class="cov0" title="0">if c.ExportInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("export interval %q should be greater than zero", c.ExportInterval)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Config) ProfilingEnabled() bool <span class="cov0" title="0">{
        return c.Profiling == ProfilingEnabled
}</span>

func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Profiling: ProfilingDisabled,
                // same as OTel runtime.DefaultMinimumReadMemStatsInterval
                ExportInterval: 15 * time.Second,
        }
}</span>

func NewFromMap(m map[string]string) (Config, error) <span class="cov0" title="0">{
        c := DefaultConfig()

        if val, ok := m["runtime-profiling"]; ok </span><span class="cov0" title="0">{
                c.Profiling = val
        }</span>
        <span class="cov0" title="0">if val, ok := m["runtime-export-interval"]; ok </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(val); err != nil </span><span class="cov0" title="0">{
                        return c, fmt.Errorf("invalid duration %q: %w", val, err)
                }</span> else<span class="cov0" title="0"> {
                        c.ExportInterval = duration
                }</span>
        }

        <span class="cov0" title="0">return c, c.Validate()</span>
}
</pre>
		
		<pre class="file" id="file195" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tracing

import (
        "errors"
        "fmt"
)

const (
        ProtocolGRPC         = "grpc"
        ProtocolHTTPProtobuf = "http/protobuf"
        ProtocolNone         = "none"
        ProtocolStdout       = "stdout"
)

type Config struct {
        Protocol     string  `json:"protocol,omitempty"`
        Endpoint     string  `json:"endpoint,omitempty"`
        SamplingRate float64 `json:"samplingRate,omitempty"`
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        switch c.Protocol </span>{
        case ProtocolGRPC, ProtocolHTTPProtobuf:<span class="cov0" title="0">
                if c.Endpoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("endpoint should be set for protocol %q", c.Protocol)
                }</span>
        case ProtocolNone, ProtocolStdout:<span class="cov0" title="0">
                if c.Endpoint != "" </span><span class="cov0" title="0">{
                        return errors.New("endpoint should not be set when protocol is 'none'")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported protocol %q", c.Protocol)</span>
        }

        <span class="cov0" title="0">if c.SamplingRate &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("sampling rate %f should be greater or equal to zero", c.SamplingRate)
        }</span> else<span class="cov0" title="0"> if c.SamplingRate &gt; 1.0 </span><span class="cov0" title="0">{
                return fmt.Errorf("sampling rate %f should be less than or equal to one", c.SamplingRate)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Protocol: ProtocolNone,
        }
}</span>

func NewFromMap(m map[string]string) (Config, error) <span class="cov0" title="0">{
        return NewFromMapWithPrefix("", m)
}</span>

func NewFromMapWithPrefix(prefix string, m map[string]string) (Config, error) <span class="cov0" title="0">{
        c := DefaultConfig()

        if val, ok := m[prefix+"tracing-protocol"]; ok </span><span class="cov0" title="0">{
                c.Protocol = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"tracing-endpoint"]; ok </span><span class="cov0" title="0">{
                c.Endpoint = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"tracing-sampling-rate"]; ok </span><span class="cov0" title="0">{
                if rate, err := parseFloat64(val); err != nil </span><span class="cov0" title="0">{
                        return c, fmt.Errorf("invalid sampling rate %q: %w", val, err)
                }</span> else<span class="cov0" title="0"> {
                        c.SamplingRate = rate
                }</span>
        }

        <span class="cov0" title="0">return c, c.Validate()</span>
}

func parseFloat64(s string) (float64, error) <span class="cov0" title="0">{
        // Simple float64 parsing - in a real implementation you might want more robust parsing
        var f float64
        _, err := fmt.Sscanf(s, "%f", &amp;f)
        return f, err
}</span>
</pre>
		
		<pre class="file" id="file196" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package clusterinterceptor

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        interceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor"
        v1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const ControllerName = "ClusterInterceptor"

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
}

var (
        // Check that our Reconciler implements interceptorreconciler.Interface
        _ interceptorreconciler.Interface = (*Reconciler)(nil)
)

func (r *Reconciler) ReconcileKind(ctx context.Context, it *v1alpha1.ClusterInterceptor) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if it.Status.Address == nil </span><span class="cov8" title="1">{ // Initialize Address if needed
                it.Status.Address = &amp;v1.Addressable{}
        }</span>
        <span class="cov8" title="1">if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{ // Set defaults
                it.SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">url, err := it.ResolveAddress()
        logger.Debugf("Resolved Address is %s", url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">it.Status.Address.URL = url
        return nil</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package clusterinterceptor

import (
        "context"

        clusterinterceptorinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        clusterinterceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

func NewController() func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, _ configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                clusterInterceptorInformer := clusterinterceptorinformer.Get(ctx)
                reconciler := &amp;Reconciler{}

                impl := clusterinterceptorreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options </span><span class="cov0" title="0">{
                        return controller.Options{
                                AgentName: ControllerName,
                        }
                }</span>)

                <span class="cov0" title="0">if _, err := clusterInterceptorInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register ClusterInterceptor informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file198" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package eventlistener

import (
        "context"

        cfg "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersclient "github.com/tektoncd/triggers/pkg/client/injection/client"
        eventlistenerinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        eventlistenerreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener"
        dynamicduck "github.com/tektoncd/triggers/pkg/dynamic"
        "github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources"
        "github.com/tektoncd/triggers/pkg/reconciler/metrics"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/tools/cache"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        duckinformer "knative.dev/pkg/client/injection/ducks/duck/v1/podspecable"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        filtereddeployinformer "knative.dev/pkg/client/injection/kube/informers/apps/v1/deployment/filtered"
        filteredserviceinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/service/filtered"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection/clients/dynamicclient"
        "knative.dev/pkg/logging"
)

// NewController creates a new instance of an EventListener controller.
func NewController(config resources.Config) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                dynamicclientset := dynamicclient.Get(ctx)
                kubeclientset := kubeclient.Get(ctx)
                triggersclientset := triggersclient.Get(ctx)
                eventListenerInformer := eventlistenerinformer.Get(ctx)
                deploymentInformer := filtereddeployinformer.Get(ctx, labels.FormatLabels(resources.DefaultStaticResourceLabels))
                serviceInformer := filteredserviceinformer.Get(ctx, labels.FormatLabels(resources.DefaultStaticResourceLabels))

                reconciler := &amp;Reconciler{
                        DynamicClientSet:  dynamicclientset,
                        KubeClientSet:     kubeclientset,
                        TriggersClientSet: triggersclientset,
                        deploymentLister:  deploymentInformer.Lister(),
                        serviceLister:     serviceInformer.Lister(),
                        configAcc:         reconcilersource.WatchConfigurations(ctx, "eventlistener", cmw),
                        config:            config,
                        Metrics:           metrics.Get(ctx),
                }

                impl := eventlistenerreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        configStore := cfg.NewStore(logger.Named("config-store"))
                        configStore.WatchConfigs(cmw)
                        return controller.Options{
                                AgentName:   ControllerName,
                                ConfigStore: configStore,
                        }
                }</span>)

                <span class="cov8" title="1">reconciler.podspecableTracker = dynamicduck.NewListableTracker(ctx, duckinformer.Get, impl)

                if _, err := eventListenerInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register EventListener informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := deploymentInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1beta1.EventListener{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Deployment informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := serviceInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1beta1.EventListener{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Service informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file199" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package eventlistener

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        eventlistenerreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener"
        dynamicduck "github.com/tektoncd/triggers/pkg/dynamic"
        "github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources"
        "github.com/tektoncd/triggers/pkg/reconciler/metrics"
        "golang.org/x/xerrors"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        appsv1lister "k8s.io/client-go/listers/apps/v1"
        corev1lister "k8s.io/client-go/listers/core/v1"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        // ControllerName defines the name for EventListener Controller
        ControllerName = "EventListener"
        // eventListenerServicePortName defines service port name for EventListener Service
        eventListenerServicePortName = "http-listener"
        // eventListenerServiceTLSPortName defines service TLS port name for EventListener Service
        eventListenerServiceTLSPortName = "https-listener"
        // eventListenerMetricsPortName defines the metrics port name by the EventListener Container
        eventListenerMetricsPortName = "http-metrics"
        // eventListenerContainerPort defines service port for EventListener Service
        eventListenerContainerPort = 8080
        // eventListenerMetricsPort defines metrics port for EventListener Service
        eventListenerMetricsPort = 9000
        // GeneratedResourcePrefix is the name prefix for resources generated in the
        // EventListener reconciler
        GeneratedResourcePrefix = "el"
)

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
        DynamicClientSet dynamic.Interface

        // KubeClientSet allows us to talk to the k8s for core APIs
        KubeClientSet kubernetes.Interface

        // TriggersClientSet allows us to configure triggers objects
        TriggersClientSet triggersclientset.Interface

        // listers index properties about resources
        deploymentLister appsv1lister.DeploymentLister
        serviceLister    corev1lister.ServiceLister

        // config accessor for observability/logging/tracing
        configAcc reconcilersource.ConfigAccessor

        // config is the configuration options that the Reconciler accepts.
        config             resources.Config
        podspecableTracker dynamicduck.ListableTracker
        onlyOnce           sync.Once

        // Metrics Recorder config
        Metrics *metrics.Recorder
}

var (
        // Check that our Reconciler implements eventlistenerreconciler.Interface
        _ eventlistenerreconciler.Interface = (*Reconciler)(nil)
)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, el *v1beta1.EventListener) pkgreconciler.Event <span class="cov8" title="1">{
        // Initial reconciliation
        el.Status.InitializeConditions()
        el.Status.Configuration.GeneratedResourceName = fmt.Sprintf("%s-%s", GeneratedResourcePrefix, el.Name)

        // We may be reading a version of the object that was stored at an older version
        // and may not have had all of the assumed default specified.
        el.SetDefaults(contexts.WithUpgradeViaDefaulting(ctx))

        cfg := config.FromContextOrDefaults(ctx)

        if el.Spec.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                return r.reconcileCustomObject(ctx, el, cfg)
        }</span>
        <span class="cov8" title="1">deploymentReconcileError := r.reconcileDeployment(ctx, el, cfg)
        serviceReconcileError := r.reconcileService(ctx, el)
        if el.Spec.Resources.CustomResource == nil </span><span class="cov8" title="1">{
                el.Status.SetReadyCondition()
        }</span>
        <span class="cov8" title="1">if len(el.Finalizers) &gt; 0 </span><span class="cov8" title="1">{
                // TODO(dibyom): Remove this in a future release once we are sure no one is using pre v0.16 resources
                r.removeFinalizer(ctx, el)
        }</span>

        <span class="cov8" title="1">return wrapError(serviceReconcileError, deploymentReconcileError)</span>
}

func (r *Reconciler) reconcileService(ctx context.Context, el *v1beta1.EventListener) error <span class="cov8" title="1">{
        service := resources.MakeService(ctx, el, r.config)

        existingService, err := r.serviceLister.Services(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName)
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                el.Status.SetExistsCondition(v1beta1.ServiceExists, nil)
                el.Status.SetAddress(resources.ListenerHostname(el, r.config))

                // Copy over output spec fields.
                service.Spec.ClusterIP = existingService.Spec.ClusterIP

                // Copy any assigned NodePorts
                if service.Spec.Type == corev1.ServiceTypeNodePort &amp;&amp;
                        existingService.Spec.Type == corev1.ServiceTypeNodePort </span><span class="cov8" title="1">{
                        for i := range service.Spec.Ports </span><span class="cov8" title="1">{
                                if i &gt;= len(existingService.Spec.Ports) </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov8" title="1">service.Spec.Ports[i].NodePort = existingService.Spec.Ports[i].NodePort</span>
                        }
                }
                // Preserve user-added annotations.
                <span class="cov8" title="1">if len(existingService.Annotations) &gt; 0 </span><span class="cov8" title="1">{
                        service.Annotations = kmeta.UnionMaps(service.Annotations, existingService.Annotations)
                }</span>

                <span class="cov8" title="1">if !equality.Semantic.DeepEqual(existingService.Spec, service.Spec) ||
                        !equality.Semantic.DeepEqual(existingService.Labels, service.Labels) ||
                        !equality.Semantic.DeepEqual(existingService.Annotations, service.Annotations) </span><span class="cov8" title="1">{
                        existingService = existingService.DeepCopy() // Don't modify the lister cache
                        existingService.Labels = service.Labels
                        existingService.Annotations = service.Annotations
                        existingService.Spec = service.Spec
                        if updated, err := r.KubeClientSet.CoreV1().Services(el.Namespace).Update(ctx, existingService, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("Error updating EventListener Service: %s", err)
                                return err
                        }</span> else<span class="cov8" title="1"> if existingService.ResourceVersion != updated.ResourceVersion </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Infof("Updated EventListener Service %s in Namespace %s", existingService.Namespace, el.Namespace)
                        }</span>
                }

        case errors.IsNotFound(err):<span class="cov8" title="1">
                // Create the EventListener Service
                _, err = r.KubeClientSet.CoreV1().Services(el.Namespace).Create(ctx, service, metav1.CreateOptions{})
                el.Status.SetExistsCondition(v1beta1.ServiceExists, err)
                if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Errorf("Error creating EventListener Service: %s", err)
                        return err
                }</span>
                <span class="cov8" title="1">el.Status.SetAddress(resources.ListenerHostname(el, r.config))
                logging.FromContext(ctx).Infof("Created EventListener Service %s in Namespace %s", service.Name, el.Namespace)</span>

        default:<span class="cov0" title="0">
                logging.FromContext(ctx).Error(err)
                return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) reconcileDeployment(ctx context.Context, el *v1beta1.EventListener, cfg *config.Config) error <span class="cov8" title="1">{
        deployment, err := resources.MakeDeployment(ctx, el, r.configAcc, r.config, cfg)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Error(err)
                return err
        }</span>

        <span class="cov8" title="1">existingDeployment, err := r.deploymentLister.Deployments(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName)
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                // TODO(mattmoor): Should this delete stuff for the CustomObject?  That path deletes Deployments,
                // so it seems asymmetrical for this path to not.

                el.Status.SetDeploymentConditions(existingDeployment.Status.Conditions)
                el.Status.SetExistsCondition(v1beta1.DeploymentExists, nil)

                // If the scale of the deployment is unspecified, then persist the current
                // scale of what is deployed.  This allows users to use HPA to automatically
                // (or manually themselves) scale the underlying deployment.
                if deployment.Spec.Replicas == nil </span><span class="cov8" title="1">{
                        deployment.Spec.Replicas = existingDeployment.Spec.Replicas
                }</span>
                // Preserve user-added annotations.
                <span class="cov8" title="1">if len(existingDeployment.Annotations) &gt; 0 </span><span class="cov8" title="1">{
                        deployment.Annotations = kmeta.UnionMaps(deployment.Annotations, existingDeployment.Annotations)
                }</span>

                <span class="cov8" title="1">if !equality.Semantic.DeepEqual(existingDeployment.Spec, deployment.Spec) ||
                        !equality.Semantic.DeepEqual(existingDeployment.Labels, deployment.Labels) ||
                        !equality.Semantic.DeepEqual(existingDeployment.Annotations, deployment.Annotations) </span><span class="cov8" title="1">{
                        existingDeployment = existingDeployment.DeepCopy() // Don't modify the lister cache
                        existingDeployment.Labels = deployment.Labels
                        existingDeployment.Annotations = deployment.Annotations
                        existingDeployment.Spec = deployment.Spec
                        // If the spec/labels/annotations of what we want and got are different, then
                        // issue an Update.  They may differ due to things like defaulting, so the
                        // Update may not change anything, so only log if the ResourceVersion changes.
                        if updated, err := r.KubeClientSet.AppsV1().Deployments(el.Namespace).Update(ctx, existingDeployment, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("Error updating EventListener Deployment: %s", err)
                                return err
                        }</span> else<span class="cov8" title="1"> if existingDeployment.ResourceVersion != updated.ResourceVersion </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Infof("Updated EventListener Deployment %s in Namespace %s", existingDeployment.Name, el.Namespace)
                        }</span>
                }

        case errors.IsNotFound(err):<span class="cov8" title="1">
                // Create the EventListener Deployment
                deployment, err = r.KubeClientSet.AppsV1().Deployments(el.Namespace).Create(ctx, deployment, metav1.CreateOptions{})
                el.Status.SetExistsCondition(v1beta1.DeploymentExists, err)
                if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Errorf("Error creating EventListener Deployment: %s", err)
                        return err
                }</span>
                <span class="cov8" title="1">el.Status.SetDeploymentConditions(deployment.Status.Conditions)
                logging.FromContext(ctx).Infof("Created EventListener Deployment %s in Namespace %s", deployment.Name, el.Namespace)</span>

        default:<span class="cov0" title="0">
                logging.FromContext(ctx).Error(err)
                return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) reconcileCustomObject(ctx context.Context, el *v1beta1.EventListener, cfg *config.Config) error <span class="cov8" title="1">{
        data, err := resources.MakeCustomObject(ctx, el, r.configAcc, r.config, cfg)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("unable to construct custom object", err)
                return err
        }</span>

        <span class="cov8" title="1">gvr, _ := meta.UnsafeGuessKindToResource(data.GetObjectKind().GroupVersionKind())

        // TODO(mattmoor): Consider replacing this with duck.InformerFactory, it actually has a bug where
        // the podspecableTracker can only service a single GVR, despite multiple EventListener objects
        // being able to specify unique resource types (yikes).
        var watchError error
        r.onlyOnce.Do(func() </span><span class="cov8" title="1">{
                watchError = r.podspecableTracker.WatchOnDynamicObject(ctx, gvr)
        }</span>)
        <span class="cov8" title="1">if watchError != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("failed to watch on created custom object", watchError)
                return watchError
        }</span>

        // TODO(mattmoor): We should look into using duck.InformerFactory to have this be a lister fetch.
        <span class="cov8" title="1">existingCustomObject, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Get(ctx, data.GetName(), metav1.GetOptions{})
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                // Clean up any Deployments that may have existed for this listener.
                if _, err := r.deploymentLister.Deployments(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName); err == nil </span><span class="cov8" title="1">{
                        if err := r.KubeClientSet.AppsV1().Deployments(el.Namespace).Delete(ctx, el.Status.Configuration.GeneratedResourceName,
                                metav1.DeleteOptions{}); err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err = r.KubeClientSet.CoreV1().Services(el.Namespace).Delete(ctx, el.Status.Configuration.GeneratedResourceName,
                                metav1.DeleteOptions{}); err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">var updated bool
                // Preserve any externally added annotations
                data.SetAnnotations(kmeta.UnionMaps(data.GetAnnotations(), existingCustomObject.GetAnnotations()))

                if !equality.Semantic.DeepEqual(data.GetLabels(), existingCustomObject.GetLabels()) ||
                        !equality.Semantic.DeepEqual(data.GetAnnotations(), existingCustomObject.GetAnnotations()) </span><span class="cov8" title="1">{
                        // Don't modify informer copy
                        existingCustomObject = existingCustomObject.DeepCopy()
                        existingCustomObject.SetLabels(data.GetLabels())
                        existingCustomObject.SetAnnotations(data.GetAnnotations())

                        updated = true
                }</span>

                <span class="cov8" title="1">if !equality.Semantic.DeepEqual(data.Object["spec"], existingCustomObject.Object["spec"]) </span><span class="cov8" title="1">{
                        diffExist, existingObject, err := resources.UpdateCustomObject(data, existingCustomObject)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // To avoid un necessary marshalling when there is no updates.
                        <span class="cov8" title="1">if diffExist </span><span class="cov8" title="1">{
                                existingMarshaledData, err := json.Marshal(existingObject)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.FromContext(ctx).Errorf("failed to marshal custom object: %v", err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">existingCustomObject = new(unstructured.Unstructured)
                                if err := existingCustomObject.UnmarshalJSON(existingMarshaledData); err != nil </span><span class="cov0" title="0">{
                                        logging.FromContext(ctx).Errorf("failed to unmarshal to unstructured object: %v", err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">updated = diffExist</span>
                        }
                }
                <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                        updatedData, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Update(ctx, existingCustomObject, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("error updating to eventListener custom object: %v", err)
                                return err
                        }</span> else<span class="cov8" title="1"> if data.GetResourceVersion() != updatedData.GetResourceVersion() </span><span class="cov8" title="1">{
                                logging.FromContext(ctx).Infof("Updated EventListener Custom Object %s in Namespace %s", data.GetName(), el.Namespace)
                        }</span>
                }

                // TODO(mattmoor): Consider replacing this stuff with the "addressable resolver"
                // from knative.dev/pkg, which is purpose built for this kind of thing.
                <span class="cov8" title="1">customConditions, url, err := dynamicduck.GetConditions(existingCustomObject)
                if customConditions == nil </span><span class="cov8" title="1">{
                        // No status in the created object, it is weird but let's not fail
                        logging.FromContext(ctx).Warn("empty status for the created custom object")
                        return nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, cond := range customConditions </span><span class="cov0" title="0">{
                        if cond.Type == apis.ConditionReady </span><span class="cov0" title="0">{
                                if cond.Status != corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        logging.FromContext(ctx).Warnf("custom object is not yet ready because %s", cond.Message)
                                        return fmt.Errorf("custom object is not yet ready because %s", cond.Message)
                                }</span>
                        }
                }
                <span class="cov0" title="0">el.Status.SetConditionsForDynamicObjects(customConditions)
                if url != nil </span><span class="cov0" title="0">{
                        el.Status.SetAddress(strings.Split(fmt.Sprintf("%v", url), "//")[1])
                }</span>

        case errors.IsNotFound(err):<span class="cov8" title="1">
                createDynamicObject, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Create(ctx, data, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Errorf("Error creating EventListener Dynamic object: ", err)
                        return err
                }</span>
                <span class="cov8" title="1">logging.FromContext(ctx).Infof("Created EventListener Deployment %s in Namespace %s", createDynamicObject.GetName(), el.Namespace)</span>

        default:<span class="cov0" title="0">
                logging.FromContext(ctx).Error(err)
                return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) removeFinalizer(ctx context.Context, el *v1beta1.EventListener) <span class="cov8" title="1">{
        // We used to need Finalizers in older versions of Triggers.
        // They are not necessary anymore so let's remove them from any old EventListener objects
        for i, f := range el.Finalizers </span><span class="cov8" title="1">{
                if f == "eventlisteners.triggers.tekton.dev" </span><span class="cov8" title="1">{
                        el.Finalizers = append(el.Finalizers[:i], el.Finalizers[i+1:]...)
                        _, err := r.TriggersClientSet.TriggersV1beta1().EventListeners(el.Namespace).Update(ctx, el, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("failed to update EventListener to remove finalizer: %v", err)
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
}

// wrapError wraps errors together. If one of the errors is nil, the other is
// returned.
func wrapError(err1, err2 error) error <span class="cov8" title="1">{
        if err1 == nil </span><span class="cov8" title="1">{
                return err2
        }</span>
        <span class="cov8" title="1">if err2 == nil </span><span class="cov8" title="1">{
                return err1
        }</span>
        <span class="cov8" title="1">return xerrors.Errorf("%s : %s", err1.Error(), err2.Error())</span>
}
</pre>
		
		<pre class="file" id="file200" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

var (
        // DefaultImage is the image used by default.
        DefaultImage = "override-with-el:latest"
        // DefaultPort is the port used by default.
        DefaultPort = 8080
        // DefaultSetSecurityContext is the SetSecurityContext value used by default.
        DefaultSetSecurityContext = true
        // DefaultSetReadOnlyRootFilesystem is the SetReadOnlyRootFilesystem value used by default.
        DefaultSetReadOnlyRootFilesystem = true
        // DefaultEventListenerEvent is the EventListenerEvent value used by default.
        DefaultEventListenerEvent = "disable"
        // DefaultReadTimeout is the ReadTimeout used by default.
        DefaultReadTimeout = int64(5)
        // DefaultWriteTimeout is the WriteTimeout used by default.
        DefaultWriteTimeout = int64(40)
        // DefaultIdleTimeout is the IdleTimeout used by default.
        DefaultIdleTimeout = int64(30)
        // DefaultTimeOutHandler is the TimeOutHandler timeout used by default.
        DefaultTimeOutHandler = int64(5)
        // DefaultPeriodSeconds is the PeriodSeconds used by default.
        DefaultPeriodSeconds = 10
        // DefaultFailureThreshold is the FailureThreshold used by default.
        DefaultFailureThreshold = 3
        // DefaultHTTPClientReadTimeOut is the HTTPClient ReadTimeOut used by default.
        DefaultHTTPClientReadTimeOut = int64(30)
        // DefaultHTTPClientKeepAlive is the HTTPClient KeepAlive used by default
        DefaultHTTPClientKeepAlive = int64(30)
        // DefaultHTTPClientTLSHandshakeTimeout is the HTTPClient TLS Handshake timeout used by default
        DefaultHTTPClientTLSHandshakeTimeout = int64(10)
        // DefaultHTTPClientResponseHeaderTimeout is the HTTPClient Response Header Timeout
        DefaultHTTPClientResponseHeaderTimeout = int64(10)
        // DefaultHTTPClientExpectContinueTimeout is the HTTPClient Expect Continue Timeout
        DefaultHTTPClientExpectContinueTimeout = int64(1)
        // DefaultStaticResourceLabels are the StaticResourceLabels used by default.
        DefaultStaticResourceLabels = map[string]string{
                "app.kubernetes.io/managed-by": "EventListener",
                "app.kubernetes.io/part-of":    "Triggers",
        }
        // DefaultSystemNamespace is the default system namespace used.
        DefaultSystemNamespace = "tekton-pipelines"
)

type Config struct {
        // Image defines the container that we use to run in the EventListener Pods.
        Image *string
        // Port defines the port for the EventListener to listen on.
        Port *int
        // SetSecurityContext defines if the security context is set.
        SetSecurityContext *bool
        // SetReadOnlyRootFilesystem defines the value for readOnlyRootFilesystem
        SetReadOnlyRootFilesystem *bool
        // SetEventListenerEvent defines to enable or disable of emitting events for EventListener.
        SetEventListenerEvent *string
        // ReadTimeOut defines the read timeout for EventListener Server.
        ReadTimeOut *int64
        // WriteTimeOut defines the write timeout for EventListener Server.
        WriteTimeOut *int64
        // IdleTimeOut defines the read timeout for EventListener Server.
        IdleTimeOut *int64
        // TimeOutHandler defines the timeout for Timeout Handler of EventListener Server.
        TimeOutHandler *int64
        // HTTPClientReadTimeOut defines the Read timeout for HTTP Client
        HTTPClientReadTimeOut *int64
        // HTTPClientKeepAlive defines the Keep Alive for HTTP Client
        HTTPClientKeepAlive *int64
        // HTTPClientTLSHandshakeTimeout defines the Handshake timeout for HTTP Client
        HTTPClientTLSHandshakeTimeout *int64
        // HTTPClientResponseHeaderTimeout defines the Response Header timeout for HTTP Client
        HTTPClientResponseHeaderTimeout *int64
        // HTTPClientExpectContinueTimeout defines the Expect timeout for HTTP Client
        HTTPClientExpectContinueTimeout *int64
        // PeriodSeconds defines Period Seconds for the EventListener Liveness and Readiness Probes.
        PeriodSeconds *int
        // FailureThreshold defines the Failure Threshold for the EventListener Liveness and Readiness Probes.
        FailureThreshold *int
        // StaticResourceLabels is a map with all the labels that should be on all resources generated by the EventListener.
        StaticResourceLabels map[string]string
        // SystemNamespace is the namespace where the reconciler is deployed.
        SystemNamespace string
}

type ConfigOption func(d *Config)

// MakeConfig is a helper to build a config that is consumed by an EventListener.
// It generates a default Config for the EventListener without any flags set and accepts functions for modification.
func MakeConfig(ops ...ConfigOption) *Config <span class="cov8" title="1">{
        c := &amp;Config{
                Image:                           &amp;DefaultImage,
                Port:                            &amp;DefaultPort,
                SetSecurityContext:              &amp;DefaultSetSecurityContext,
                SetEventListenerEvent:           &amp;DefaultEventListenerEvent,
                SetReadOnlyRootFilesystem:       &amp;DefaultSetReadOnlyRootFilesystem,
                ReadTimeOut:                     &amp;DefaultReadTimeout,
                WriteTimeOut:                    &amp;DefaultWriteTimeout,
                IdleTimeOut:                     &amp;DefaultIdleTimeout,
                TimeOutHandler:                  &amp;DefaultTimeOutHandler,
                HTTPClientReadTimeOut:           &amp;DefaultHTTPClientReadTimeOut,
                HTTPClientKeepAlive:             &amp;DefaultHTTPClientKeepAlive,
                HTTPClientTLSHandshakeTimeout:   &amp;DefaultHTTPClientTLSHandshakeTimeout,
                HTTPClientResponseHeaderTimeout: &amp;DefaultHTTPClientResponseHeaderTimeout,
                HTTPClientExpectContinueTimeout: &amp;DefaultHTTPClientExpectContinueTimeout,
                PeriodSeconds:                   &amp;DefaultPeriodSeconds,
                FailureThreshold:                &amp;DefaultFailureThreshold,

                StaticResourceLabels: DefaultStaticResourceLabels,
                SystemNamespace:      DefaultSystemNamespace,
        }

        for _, op := range ops </span><span class="cov8" title="1">{
                op(c)
        }</span>
        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file201" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "strconv"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        corev1 "k8s.io/api/core/v1"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        "knative.dev/pkg/ptr"
)

type ContainerOption func(*corev1.Container)

func MakeContainer(el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config, opts ...ContainerOption) corev1.Container <span class="cov8" title="1">{
        isMultiNS := false
        if len(el.Spec.NamespaceSelector.MatchNames) != 0 </span><span class="cov8" title="1">{
                isMultiNS = true
        }</span>
        <span class="cov8" title="1">for _, triggerGroup := range el.Spec.TriggerGroups </span><span class="cov8" title="1">{
                if len(triggerGroup.TriggerSelector.NamespaceSelector.MatchNames) != 0 </span><span class="cov8" title="1">{
                        isMultiNS = true
                        break</span>
                }
        }

        <span class="cov8" title="1">payloadValidation := true
        if value, ok := el.GetAnnotations()[triggers.PayloadValidationAnnotation]; ok </span><span class="cov8" title="1">{
                if value == "false" </span><span class="cov8" title="1">{
                        payloadValidation = false
                }</span>
        }

        <span class="cov8" title="1">ev := configAcc.ToEnvVars()

        var containerSecurityContext *corev1.SecurityContext
        if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                if len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 </span><span class="cov8" title="1">{
                        if *c.SetSecurityContext </span><span class="cov8" title="1">{
                                containerSecurityContext = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].SecurityContext
                        }</span>
                }
        }
        <span class="cov8" title="1">if *c.SetSecurityContext &amp;&amp; containerSecurityContext == nil </span><span class="cov8" title="1">{
                containerSecurityContext = &amp;corev1.SecurityContext{
                        AllowPrivilegeEscalation: ptr.Bool(false),
                        Capabilities: &amp;corev1.Capabilities{
                                Drop: []corev1.Capability{"ALL"},
                        },
                        RunAsNonRoot: ptr.Bool(cfg.Defaults.DefaultRunAsNonRoot),
                        SeccompProfile: &amp;corev1.SeccompProfile{
                                Type: corev1.SeccompProfileTypeRuntimeDefault,
                        },
                }

                if *c.SetReadOnlyRootFilesystem </span><span class="cov8" title="1">{
                        containerSecurityContext.ReadOnlyRootFilesystem = ptr.Bool(true)
                }</span>
                <span class="cov8" title="1">if !cfg.Defaults.IsDefaultRunAsUserEmpty </span><span class="cov8" title="1">{
                        containerSecurityContext.RunAsUser = ptr.Int64(cfg.Defaults.DefaultRunAsUser)
                }</span>
                <span class="cov8" title="1">if !cfg.Defaults.IsDefaultRunAsGroupEmpty </span><span class="cov8" title="1">{
                        containerSecurityContext.RunAsGroup = ptr.Int64(cfg.Defaults.DefaultRunAsGroup)
                }</span>
        }

        <span class="cov8" title="1">container := corev1.Container{
                Name:  "event-listener",
                Image: *c.Image,
                Ports: []corev1.ContainerPort{{
                        ContainerPort: int32(eventListenerContainerPort),
                        Protocol:      corev1.ProtocolTCP,
                }},
                Args: []string{
                        "--el-name=" + el.Name,
                        "--el-namespace=" + el.Namespace,
                        "--port=" + strconv.Itoa(eventListenerContainerPort),
                        "--readtimeout=" + strconv.FormatInt(*c.ReadTimeOut, 10),
                        "--writetimeout=" + strconv.FormatInt(*c.WriteTimeOut, 10),
                        "--idletimeout=" + strconv.FormatInt(*c.IdleTimeOut, 10),
                        "--timeouthandler=" + strconv.FormatInt(*c.TimeOutHandler, 10),
                        "--httpclient-readtimeout=" + strconv.FormatInt(*c.HTTPClientReadTimeOut, 10),
                        "--httpclient-keep-alive=" + strconv.FormatInt(*c.HTTPClientKeepAlive, 10),
                        "--httpclient-tlshandshaketimeout=" + strconv.FormatInt(*c.HTTPClientTLSHandshakeTimeout, 10),
                        "--httpclient-responseheadertimeout=" + strconv.FormatInt(*c.HTTPClientResponseHeaderTimeout, 10),
                        "--httpclient-expectcontinuetimeout=" + strconv.FormatInt(*c.HTTPClientExpectContinueTimeout, 10),
                        "--is-multi-ns=" + strconv.FormatBool(isMultiNS),
                        "--payload-validation=" + strconv.FormatBool(payloadValidation),
                        "--cloudevent-uri=" + el.Spec.CloudEventURI,
                },
                Env: append(ev, []corev1.EnvVar{{
                        Name:  "NAMESPACE",
                        Value: el.Namespace,
                }, {
                        Name:  "NAME",
                        Value: el.Name,
                }, {
                        Name:  "EL_EVENT",
                        Value: *c.SetEventListenerEvent,
                }, {
                        Name:  "K_SINK_TIMEOUT",
                        Value: strconv.FormatInt(*c.TimeOutHandler, 10),
                }}...),
                SecurityContext: containerSecurityContext,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;container)
        }</span>

        <span class="cov8" title="1">return container</span>
}
</pre>
		
		<pre class="file" id="file202" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "bytes"
        "context"
        "encoding/json"
        "os"
        "reflect"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/kmeta"
)

func MakeCustomObject(ctx context.Context, el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        original := &amp;duckv1.WithPod{}
        decoder := json.NewDecoder(bytes.NewBuffer(el.Spec.Resources.CustomResource.Raw))
        if err := decoder.Decode(&amp;original); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">customObjectData := original.DeepCopy()

        namespace := original.GetNamespace()
        // Default the resource creation to the EventListenerNamespace if not found in the resource object
        if namespace == "" </span><span class="cov8" title="1">{
                namespace = el.GetNamespace()
        }</span>

        <span class="cov8" title="1">container := MakeContainer(el, configAcc, c, cfg, func(c *corev1.Container) </span><span class="cov8" title="1">{
                // handle env and resources for custom object
                if len(original.Spec.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                        c.Env = append(c.Env, original.Spec.Template.Spec.Containers[0].Env...)
                        c.Resources = original.Spec.Template.Spec.Containers[0].Resources
                }</span>

                <span class="cov8" title="1">c.Env = append(c.Env, corev1.EnvVar{
                        Name: "SYSTEM_NAMESPACE",
                        // Cannot use FieldRef here because Knative Serving mask that field under feature gate
                        // https://github.com/knative/serving/blob/master/pkg/apis/config/features.go#L48
                        Value: el.Namespace,
                }, corev1.EnvVar{
                        // METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint
                        // env METRICS_PROMETHEUS_PORT set by controller
                        Name:  "METRICS_PROMETHEUS_PORT",
                        Value: os.Getenv("METRICS_PROMETHEUS_PORT"),
                }, corev1.EnvVar{
                        // KUBERNETES_MIN_VERSION overrides the Min version of k8s required
                        Name:  "KUBERNETES_MIN_VERSION",
                        Value: os.Getenv("KUBERNETES_MIN_VERSION"),
                })

                c.ReadinessProbe = &amp;corev1.Probe{
                        ProbeHandler: corev1.ProbeHandler{
                                HTTPGet: &amp;corev1.HTTPGetAction{
                                        Path:   "/live",
                                        Scheme: corev1.URISchemeHTTP,
                                },
                        },
                        SuccessThreshold: 1,
                }</span>
        })

        <span class="cov8" title="1">podlabels := kmeta.UnionMaps(FilterLabels(ctx, el.Labels), GenerateLabels(el.Name, c.StaticResourceLabels))

        podlabels = kmeta.UnionMaps(podlabels, customObjectData.Labels)

        original.Labels = podlabels
        original.Annotations = customObjectData.Annotations
        original.Spec.Template.ObjectMeta = metav1.ObjectMeta{
                Name:        customObjectData.Spec.Template.Name,
                Labels:      customObjectData.Spec.Template.Labels,
                Annotations: customObjectData.Spec.Template.Annotations,
        }
        original.Spec.Template.Spec = corev1.PodSpec{
                Tolerations:               customObjectData.Spec.Template.Spec.Tolerations,
                NodeSelector:              customObjectData.Spec.Template.Spec.NodeSelector,
                ServiceAccountName:        customObjectData.Spec.Template.Spec.ServiceAccountName,
                Containers:                []corev1.Container{container},
                Affinity:                  customObjectData.Spec.Template.Spec.Affinity,
                TopologySpreadConstraints: customObjectData.Spec.Template.Spec.TopologySpreadConstraints,
        }
        marshaledData, err := json.Marshal(original)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">data := new(unstructured.Unstructured)
        if err := data.UnmarshalJSON(marshaledData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if data.GetName() == "" </span><span class="cov8" title="1">{
                data.SetName(el.Status.Configuration.GeneratedResourceName)
        }</span>
        <span class="cov8" title="1">data.SetNamespace(namespace)
        data.SetOwnerReferences([]metav1.OwnerReference{*kmeta.NewControllerRef(el)})

        return data, nil</span>
}

func UpdateCustomObject(originalData, updatedCustomObject *unstructured.Unstructured) (bool, *duckv1.WithPod, error) <span class="cov8" title="1">{
        updated := false
        originalObject := &amp;duckv1.WithPod{}
        existingObject := &amp;duckv1.WithPod{}
        data, e := originalData.MarshalJSON()
        if e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>
        <span class="cov8" title="1">if e := json.Unmarshal(data, &amp;originalObject); e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>
        <span class="cov8" title="1">updatedData, e := updatedCustomObject.MarshalJSON()
        if e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>
        <span class="cov8" title="1">if e := json.Unmarshal(updatedData, &amp;existingObject); e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>

        // custom resource except few spec fields from user
        // added below checks in order to avoid unwanted updates on all spec changes.
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Name, originalObject.Spec.Template.Name) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Name = originalObject.Spec.Template.Name
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Labels, originalObject.Spec.Template.Labels) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Labels = originalObject.Spec.Template.Labels
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Annotations, originalObject.Spec.Template.Annotations) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Annotations = originalObject.Spec.Template.Annotations
                updated = true
        }</span>
        <span class="cov8" title="1">if existingObject.Spec.Template.Spec.ServiceAccountName != originalObject.Spec.Template.Spec.ServiceAccountName </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.ServiceAccountName = originalObject.Spec.Template.Spec.ServiceAccountName
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Tolerations, originalObject.Spec.Template.Spec.Tolerations) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.Tolerations = originalObject.Spec.Template.Spec.Tolerations
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.NodeSelector, originalObject.Spec.Template.Spec.NodeSelector) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.NodeSelector = originalObject.Spec.Template.Spec.NodeSelector
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Affinity, originalObject.Spec.Template.Spec.Affinity) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.Affinity = originalObject.Spec.Template.Spec.Affinity
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.TopologySpreadConstraints, originalObject.Spec.Template.Spec.TopologySpreadConstraints) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.TopologySpreadConstraints = originalObject.Spec.Template.Spec.TopologySpreadConstraints
                updated = true
        }</span>
        <span class="cov8" title="1">if len(existingObject.Spec.Template.Spec.Containers) == 0 ||
                len(existingObject.Spec.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.Containers = originalObject.Spec.Template.Spec.Containers
                updated = true
        }</span> else<span class="cov8" title="1"> {
                if existingObject.Spec.Template.Spec.Containers[0].Name != originalObject.Spec.Template.Spec.Containers[0].Name </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Name = originalObject.Spec.Template.Spec.Containers[0].Name
                        updated = true
                }</span>
                <span class="cov8" title="1">if existingObject.Spec.Template.Spec.Containers[0].Image != originalObject.Spec.Template.Spec.Containers[0].Image </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Image = originalObject.Spec.Template.Spec.Containers[0].Image
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Ports, originalObject.Spec.Template.Spec.Containers[0].Ports) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Ports = originalObject.Spec.Template.Spec.Containers[0].Ports
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Args, originalObject.Spec.Template.Spec.Containers[0].Args) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Args = originalObject.Spec.Template.Spec.Containers[0].Args
                        updated = true
                }</span>
                <span class="cov8" title="1">if existingObject.Spec.Template.Spec.Containers[0].Command != nil </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Command = nil
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Resources, originalObject.Spec.Template.Spec.Containers[0].Resources) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Resources = originalObject.Spec.Template.Spec.Containers[0].Resources
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Env, originalObject.Spec.Template.Spec.Containers[0].Env) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Env = originalObject.Spec.Template.Spec.Containers[0].Env
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].ReadinessProbe, originalObject.Spec.Template.Spec.Containers[0].ReadinessProbe) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].ReadinessProbe = originalObject.Spec.Template.Spec.Containers[0].ReadinessProbe
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].VolumeMounts, originalObject.Spec.Template.Spec.Containers[0].VolumeMounts) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].VolumeMounts = originalObject.Spec.Template.Spec.Containers[0].VolumeMounts
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Volumes, originalObject.Spec.Template.Spec.Volumes) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Volumes = originalObject.Spec.Template.Spec.Volumes
                        updated = true
                }</span>
        }

        <span class="cov8" title="1">return updated, existingObject, nil</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "os"
        "strconv"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/ptr"
)

const (
        TriggersMetricsDomain = "tekton.dev/triggers"
)

var (
        baseSecurityPolicy = &amp;corev1.PodSecurityContext{
                RunAsNonRoot: ptr.Bool(true),
                SeccompProfile: &amp;corev1.SeccompProfile{
                        Type: corev1.SeccompProfileTypeRuntimeDefault,
                },
        }
)

func getStrongerSecurityPolicy(cfg *config.Config) *corev1.PodSecurityContext <span class="cov8" title="1">{
        securityContext := baseSecurityPolicy
        if !cfg.Defaults.IsDefaultRunAsUserEmpty </span><span class="cov8" title="1">{
                securityContext.RunAsUser = ptr.Int64(cfg.Defaults.DefaultRunAsUser)
        }</span>

        <span class="cov8" title="1">if !cfg.Defaults.IsDefaultRunAsGroupEmpty </span><span class="cov8" title="1">{
                securityContext.RunAsGroup = ptr.Int64(cfg.Defaults.DefaultRunAsGroup)
        }</span>

        <span class="cov8" title="1">if !cfg.Defaults.IsDefaultFsGroupEmpty </span><span class="cov8" title="1">{
                securityContext.FSGroup = ptr.Int64(cfg.Defaults.DefaultFSGroup)
        }</span>

        <span class="cov8" title="1">return securityContext</span>
}

func MakeDeployment(ctx context.Context, el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config) (*appsv1.Deployment, error) <span class="cov8" title="1">{
        opt, err := addDeploymentBits(el, c)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">container := MakeContainer(el, configAcc, c, cfg, opt, addCertsForSecureConnection(c))

        filteredLabels := FilterLabels(ctx, el.Labels)

        var (
                podlabels                 = kmeta.UnionMaps(filteredLabels, GenerateLabels(el.Name, c.StaticResourceLabels))
                serviceAccountName        = el.Spec.ServiceAccountName
                replicas                  *int32
                vol                       []corev1.Volume
                tolerations               []corev1.Toleration
                nodeSelector, annotations map[string]string
                affinity                  *corev1.Affinity
                topologySpreadConstraints []corev1.TopologySpreadConstraint
                imagePullSecrets          []corev1.LocalObjectReference
        )

        for _, v := range container.Env </span><span class="cov8" title="1">{
                // If TLS related env are set then mount secret volume which will be used while starting the eventlistener.
                if v.Name == "TLS_CERT" </span><span class="cov8" title="1">{
                        vol = append(vol, corev1.Volume{
                                Name: "https-connection",
                                VolumeSource: corev1.VolumeSource{
                                        Secret: &amp;corev1.SecretVolumeSource{
                                                SecretName: v.ValueFrom.SecretKeyRef.Name,
                                        },
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">var securityContext *corev1.PodSecurityContext
        if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                if el.Spec.Resources.KubernetesResource.Replicas != nil </span><span class="cov8" title="1">{
                        replicas = el.Spec.Resources.KubernetesResource.Replicas
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.Tolerations) != 0 </span><span class="cov8" title="1">{
                        tolerations = el.Spec.Resources.KubernetesResource.Template.Spec.Tolerations
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.NodeSelector) != 0 </span><span class="cov8" title="1">{
                        nodeSelector = el.Spec.Resources.KubernetesResource.Template.Spec.NodeSelector
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.ImagePullSecrets) != 0 </span><span class="cov0" title="0">{
                        imagePullSecrets = el.Spec.Resources.KubernetesResource.Template.Spec.ImagePullSecrets
                }</span>
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource.Template.Spec.ServiceAccountName != "" </span><span class="cov8" title="1">{
                        serviceAccountName = el.Spec.Resources.KubernetesResource.Template.Spec.ServiceAccountName
                }</span>
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource.Template.Spec.Affinity != nil </span><span class="cov8" title="1">{
                        affinity = el.Spec.Resources.KubernetesResource.Template.Spec.Affinity
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.TopologySpreadConstraints) != 0 </span><span class="cov8" title="1">{
                        topologySpreadConstraints = el.Spec.Resources.KubernetesResource.Template.Spec.TopologySpreadConstraints
                }</span>
                <span class="cov8" title="1">annotations = el.Spec.Resources.KubernetesResource.Template.Annotations
                podlabels = kmeta.UnionMaps(podlabels, el.Spec.Resources.KubernetesResource.Template.Labels)
                if *c.SetSecurityContext </span><span class="cov8" title="1">{
                        securityContext = el.Spec.Resources.KubernetesResource.Template.Spec.SecurityContext
                }</span>
        }

        <span class="cov8" title="1">if *c.SetSecurityContext &amp;&amp; securityContext == nil </span><span class="cov8" title="1">{
                securityContext = getStrongerSecurityPolicy(cfg)
        }</span>

        <span class="cov8" title="1">return &amp;appsv1.Deployment{
                ObjectMeta: ObjectMeta(el, filteredLabels, c.StaticResourceLabels),
                Spec: appsv1.DeploymentSpec{
                        Replicas: replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: GenerateLabels(el.Name, c.StaticResourceLabels),
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels:      podlabels,
                                        Annotations: annotations,
                                },
                                Spec: corev1.PodSpec{
                                        ImagePullSecrets:          imagePullSecrets,
                                        Tolerations:               tolerations,
                                        NodeSelector:              nodeSelector,
                                        ServiceAccountName:        serviceAccountName,
                                        Containers:                []corev1.Container{container},
                                        Volumes:                   vol,
                                        SecurityContext:           securityContext,
                                        Affinity:                  affinity,
                                        TopologySpreadConstraints: topologySpreadConstraints,
                                },
                        },
                },
        }, nil</span>
}

// revive:disable:unused-parameter

func addDeploymentBits(el *v1beta1.EventListener, c Config) (ContainerOption, error) <span class="cov8" title="1">{
        // METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint
        // env METRICS_PROMETHEUS_PORT set by controller
        metricsPort, err := strconv.ParseInt(os.Getenv("METRICS_PROMETHEUS_PORT"), 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return func(container *corev1.Container) </span><span class="cov8" title="1">{
                if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                        if len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 </span><span class="cov8" title="1">{
                                container.Resources = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Resources
                                container.Env = append(container.Env, el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env...)
                                container.ReadinessProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].ReadinessProbe
                                container.LivenessProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].LivenessProbe
                                container.StartupProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].StartupProbe
                        }</span>
                }
                <span class="cov8" title="1">container.Ports = append(container.Ports, corev1.ContainerPort{
                        ContainerPort: int32(metricsPort), //nolint: gosec
                        Protocol:      corev1.ProtocolTCP,
                })

                container.Env = append(container.Env, corev1.EnvVar{
                        Name: "SYSTEM_NAMESPACE",
                        ValueFrom: &amp;corev1.EnvVarSource{
                                FieldRef: &amp;corev1.ObjectFieldSelector{
                                        APIVersion: "v1",
                                        FieldPath:  "metadata.namespace",
                                }},
                }, corev1.EnvVar{
                        // METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint
                        // env METRICS_PROMETHEUS_PORT set by controller
                        Name:  "METRICS_PROMETHEUS_PORT",
                        Value: os.Getenv("METRICS_PROMETHEUS_PORT"),
                }, corev1.EnvVar{
                        // KUBERNETES_MIN_VERSION overrides the min k8s version required to run EL.
                        Name:  "KUBERNETES_MIN_VERSION",
                        Value: os.Getenv("KUBERNETES_MIN_VERSION"),
                })</span>
        }, nil
}

func addCertsForSecureConnection(c Config) ContainerOption <span class="cov8" title="1">{
        return func(container *corev1.Container) </span><span class="cov8" title="1">{
                var elCert, elKey string
                certEnv := map[string]*corev1.EnvVarSource{}
                for i := range container.Env </span><span class="cov8" title="1">{
                        certEnv[container.Env[i].Name] = container.Env[i].ValueFrom
                }</span>
                <span class="cov8" title="1">var scheme corev1.URIScheme
                if v, ok := certEnv["TLS_CERT"]; ok </span><span class="cov8" title="1">{
                        elCert = "/etc/triggers/tls/" + v.SecretKeyRef.Key
                }</span> else<span class="cov8" title="1"> {
                        elCert = ""
                }</span>
                <span class="cov8" title="1">if v, ok := certEnv["TLS_KEY"]; ok </span><span class="cov8" title="1">{
                        elKey = "/etc/triggers/tls/" + v.SecretKeyRef.Key
                }</span> else<span class="cov8" title="1"> {
                        elKey = ""
                }</span>

                <span class="cov8" title="1">if elCert != "" &amp;&amp; elKey != "" </span><span class="cov8" title="1">{
                        scheme = corev1.URISchemeHTTPS
                        container.VolumeMounts = append(container.VolumeMounts, corev1.VolumeMount{
                                Name:      "https-connection",
                                ReadOnly:  true,
                                MountPath: "/etc/triggers/tls",
                        })
                }</span> else<span class="cov8" title="1"> {
                        scheme = corev1.URISchemeHTTP
                }</span>
                <span class="cov8" title="1">if container.LivenessProbe == nil </span><span class="cov8" title="1">{
                        container.LivenessProbe = &amp;corev1.Probe{
                                ProbeHandler: corev1.ProbeHandler{
                                        HTTPGet: &amp;corev1.HTTPGetAction{
                                                Path:   "/live",
                                                Scheme: scheme,
                                                Port:   intstr.FromInt(eventListenerContainerPort),
                                        },
                                },
                                PeriodSeconds:    int32(*c.PeriodSeconds),    //nolint: gosec
                                FailureThreshold: int32(*c.FailureThreshold), //nolint: gosec
                        }
                }</span>
                <span class="cov8" title="1">if container.ReadinessProbe == nil </span><span class="cov8" title="1">{
                        container.ReadinessProbe = &amp;corev1.Probe{
                                ProbeHandler: corev1.ProbeHandler{
                                        HTTPGet: &amp;corev1.HTTPGetAction{
                                                Path:   "/live",
                                                Scheme: scheme,
                                                Port:   intstr.FromInt(eventListenerContainerPort),
                                        },
                                },
                                PeriodSeconds:    int32(*c.PeriodSeconds),    //nolint: gosec
                                FailureThreshold: int32(*c.FailureThreshold), //nolint: gosec
                        }
                }</span>
                <span class="cov8" title="1">container.Args = append(container.Args, "--tls-cert="+elCert, "--tls-key="+elKey)</span>
        }
}
</pre>
		
		<pre class="file" id="file204" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "regexp"

        "github.com/tektoncd/triggers/pkg/apis/config"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/kmeta"

        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

// ObjectMeta generates the object meta that should be used by all
// resources generated by the EventListener reconciler
func ObjectMeta(el *v1beta1.EventListener, filteredElLabels, staticResourceLabels map[string]string) metav1.ObjectMeta <span class="cov8" title="1">{
        return metav1.ObjectMeta{
                Namespace:       el.Namespace,
                Name:            el.Status.Configuration.GeneratedResourceName,
                OwnerReferences: []metav1.OwnerReference{*kmeta.NewControllerRef(el)},
                Labels:          kmeta.UnionMaps(filteredElLabels, GenerateLabels(el.Name, staticResourceLabels)),
                Annotations:     el.Annotations,
        }
}</span>

// GenerateLabels generates the labels to be used on all generated resources.
func GenerateLabels(eventListenerName string, staticResourceLabels map[string]string) map[string]string <span class="cov8" title="1">{
        resourceLabels := kmeta.CopyMap(staticResourceLabels)
        resourceLabels["eventlistener"] = eventListenerName
        return resourceLabels
}</span>

// FilterLabels filters label based on regex pattern defined in
// feature-flag `labels-exclusion-pattern`
func FilterLabels(ctx context.Context, labels map[string]string) map[string]string <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)

        if len(labels) == 0 || cfg.FeatureFlags.LabelsExclusionPattern == "" </span><span class="cov8" title="1">{
                return labels
        }</span>

        <span class="cov8" title="1">filteredLabels := make(map[string]string)
        r := regexp.MustCompile(cfg.FeatureFlags.LabelsExclusionPattern)

        for key, value := range labels </span><span class="cov8" title="1">{
                if !r.MatchString(key) </span><span class="cov8" title="1">{
                        filteredLabels[key] = value
                }</span>
        }

        <span class="cov8" title="1">return filteredLabels</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
        "knative.dev/pkg/network"
)

const (
        // eventListenerServicePortName defines service port name for EventListener Service
        eventListenerServicePortName = "http-listener"
        // eventListenerServiceTLSPortName defines service TLS port name for EventListener Service
        eventListenerServiceTLSPortName = "https-listener"
        // eventListenerMetricsPortName defines the metrics port name by the EventListener Container
        eventListenerMetricsPortName = "http-metrics"
        // eventListenerContainerPort defines service port for EventListener Service
        eventListenerContainerPort = 8080
        // eventListenerMetricsPort defines metrics port for EventListener Service
        eventListenerMetricsPort = 9000
)

var metricsPort = corev1.ServicePort{
        Name:     eventListenerMetricsPortName,
        Protocol: corev1.ProtocolTCP,
        Port:     int32(9000),
        TargetPort: intstr.IntOrString{
                IntVal: int32(eventListenerMetricsPort),
        },
}

func MakeService(ctx context.Context, el *v1beta1.EventListener, c Config) *corev1.Service <span class="cov8" title="1">{
        // for backward compatibility with original behavior
        var (
                serviceType corev1.ServiceType
                servicePort corev1.ServicePort
        )
        if el.Spec.Resources.KubernetesResource != nil &amp;&amp; el.Spec.Resources.KubernetesResource.ServiceType != "" </span><span class="cov8" title="1">{
                serviceType = el.Spec.Resources.KubernetesResource.ServiceType
        }</span>
        <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource != nil &amp;&amp; el.Spec.Resources.KubernetesResource.ServicePort != nil </span><span class="cov8" title="1">{
                port := int(*el.Spec.Resources.KubernetesResource.ServicePort)
                c.Port = &amp;port
        }</span>

        <span class="cov8" title="1">servicePort = ServicePort(el, c)

        svc := &amp;corev1.Service{
                ObjectMeta: ObjectMeta(el, FilterLabels(ctx, el.Labels), c.StaticResourceLabels),
                Spec: corev1.ServiceSpec{
                        Selector: GenerateLabels(el.Name, c.StaticResourceLabels),
                        Type:     serviceType,
                        Ports:    []corev1.ServicePort{servicePort, metricsPort}},
        }

        if el.Spec.Resources.KubernetesResource != nil &amp;&amp; el.Spec.Resources.KubernetesResource.ServiceLoadBalancerClass != nil </span><span class="cov8" title="1">{
                svc.Spec.LoadBalancerClass = el.Spec.Resources.KubernetesResource.ServiceLoadBalancerClass
        }</span>

        <span class="cov8" title="1">return svc</span>
}

func ServicePort(el *v1beta1.EventListener, c Config) corev1.ServicePort <span class="cov8" title="1">{
        var elCert, elKey string

        nodePort := int32(0)
        servicePortName := eventListenerServicePortName
        servicePort := *c.Port

        certEnv := map[string]*corev1.EnvVarSource{}
        if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                if len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 </span><span class="cov8" title="1">{
                        for i := range el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env </span><span class="cov8" title="1">{
                                certEnv[el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env[i].Name] =
                                        el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env[i].ValueFrom
                        }</span>
                }
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource.ServicePort != nil </span><span class="cov8" title="1">{
                        servicePort = int(*el.Spec.Resources.KubernetesResource.ServicePort)
                        if el.Spec.Resources.KubernetesResource.ServiceType == corev1.ServiceTypeNodePort </span><span class="cov8" title="1">{
                                nodePort = *el.Spec.Resources.KubernetesResource.ServicePort
                        }</span>
                }
        }

        <span class="cov8" title="1">if v, ok := certEnv["TLS_CERT"]; ok </span><span class="cov8" title="1">{
                elCert = v.SecretKeyRef.Key
        }</span> else<span class="cov8" title="1"> {
                elCert = ""
        }</span>
        <span class="cov8" title="1">if v, ok := certEnv["TLS_KEY"]; ok </span><span class="cov8" title="1">{
                elKey = v.SecretKeyRef.Key
        }</span> else<span class="cov8" title="1"> {
                elKey = ""
        }</span>

        <span class="cov8" title="1">if elCert != "" &amp;&amp; elKey != "" </span><span class="cov8" title="1">{
                servicePortName = eventListenerServiceTLSPortName
                if *c.Port == DefaultPort </span><span class="cov8" title="1">{
                        // We return port 8443 if TLS is enabled and the default HTTP port is set.
                        // This effectively makes 8443 the default HTTPS port unless a user explicitly sets a different port.
                        servicePort = 8443
                }</span>
        }

        <span class="cov8" title="1">svc := corev1.ServicePort{
                Name:     servicePortName,
                Protocol: corev1.ProtocolTCP,
                Port:     int32(servicePort), //nolint: gosec
                TargetPort: intstr.IntOrString{
                        IntVal: int32(eventListenerContainerPort),
                },
                NodePort: nodePort,
        }

        return svc</span>
}

// ListenerHostname returns the intended hostname for the EventListener service.
func ListenerHostname(el *v1beta1.EventListener, c Config) string <span class="cov8" title="1">{
        sp := ServicePort(el, c)
        return network.GetServiceHostname(el.Status.Configuration.GeneratedResourceName, el.Namespace) + fmt.Sprintf(":%d", sp.Port)
}</span>
</pre>
		
		<pre class="file" id="file206" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package events

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
)

const (
        // TriggerProcessingStartedV1 is sent for Sink Triggers when a trigger is started
        TriggerProcessingStartedV1 = "dev.tekton.event.triggers.started.v1"
        // TriggerProcessingSuccessfulV1 is sent for Sink Triggers when a trigger is successful
        TriggerProcessingSuccessfulV1 = "dev.tekton.event.triggers.successful.v1"
        // TriggerProcessingFailedEventV1 is sent for Sink Triggers when we fail to process trigger
        TriggerProcessingFailedV1 = "dev.tekton.event.triggers.failed.v1"
        // TriggerProcessingDoneV1 is sent for Sink Triggers when we are done
        // with eventlistener handler
        TriggerProcessingDoneV1 = "dev.tekton.event.triggers.done.v1"
        // EventAccepted is sent as response for CloudEvent compliant providers
        EventAccepted = "dev.tekton.event.triggers.accepted.v1"
)

// Emit emits events for object
// Supported events are k8s events.
func Emit(recorder record.EventRecorder, eventType string, object runtime.Object, err error) <span class="cov0" title="0">{
        sendKubernetesEvents(recorder, eventType, object, err)
}</span>

func sendKubernetesEvents(c record.EventRecorder, eventType string, object runtime.Object, err error) <span class="cov8" title="1">{
        switch err </span>{
        case nil:<span class="cov8" title="1">
                if eventType == TriggerProcessingFailedV1 </span><span class="cov0" title="0">{
                        c.Event(object, corev1.EventTypeWarning, eventType, "")
                }</span> else<span class="cov8" title="1"> {
                        c.Event(object, corev1.EventTypeNormal, eventType, "")
                }</span>
        default:<span class="cov8" title="1">
                c.Event(object, corev1.EventTypeWarning, eventType, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file207" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptor

import (
        "context"

        interceptorinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor"
        interceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

func NewController() func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, _ configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                interceptorInformer := interceptorinformer.Get(ctx)
                reconciler := &amp;Reconciler{}

                impl := interceptorreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options </span><span class="cov0" title="0">{
                        return controller.Options{
                                AgentName: ControllerName,
                        }
                }</span>)

                <span class="cov0" title="0">if _, err := interceptorInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Interceptor informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file208" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptor

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        interceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor"
        v1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const ControllerName = "Interceptor"

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
}

var (
        // Check that our Reconciler implements interceptorreconciler.Interface
        _ interceptorreconciler.Interface = (*Reconciler)(nil)
)

func (r *Reconciler) ReconcileKind(ctx context.Context, it *v1alpha1.Interceptor) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if it.Status.Address == nil </span><span class="cov8" title="1">{ // Initialize Address if needed
                it.Status.Address = &amp;v1.Addressable{}
        }</span>
        <span class="cov8" title="1">if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{ // Set defaults
                it.SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">url, err := it.ResolveAddress()
        logger.Debugf("Resolved Address is %s", url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">it.Status.Address.URL = url
        return nil</span>
}
</pre>
		
		<pre class="file" id="file209" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"

        ciInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        ctbInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding"
        elInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        tbInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding"
        ttInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return WithClient(ctx) }</span>)
        <span class="cov8" title="1">injection.Default.RegisterInformer(WithInformer)</span>
}

// RecorderKey is used for associating the Recorder inside the context.Context.
type RecorderKey struct{}

func WithClient(ctx context.Context) context.Context <span class="cov8" title="1">{
        rec, err := NewRecorder(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Failed to create trigger metrics recorder %v", err)
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, RecorderKey{}, rec)</span>
}

// Get extracts the pipelinerunmetrics.Recorder from the context.
func Get(ctx context.Context) *Recorder <span class="cov8" title="1">{
        untyped := ctx.Value(RecorderKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic("Unable to fetch *metrics.Recorder from context.")
        }</span>
        <span class="cov8" title="1">return untyped.(*Recorder)</span>
}

type recorderInformer struct {
        ctx     context.Context //nolint:containedctx
        metrics *Recorder
        listers
}

// InformerKey is used for associating the Informer inside the context.Context.
type InformerKey struct{}

func WithInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        return ctx, &amp;recorderInformer{
                ctx:     ctx,
                metrics: Get(ctx),
                listers: listers{
                        el:  elInformer.Get(ctx).Lister(),
                        ctb: ctbInformer.Get(ctx).Lister(),
                        tb:  tbInformer.Get(ctx).Lister(),
                        tt:  ttInformer.Get(ctx).Lister(),
                        ci:  ciInformer.Get(ctx).Lister(),
                },
        }
}</span>

var _ controller.Informer = (*recorderInformer)(nil)

func (ri *recorderInformer) Run(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        // Turn the stopCh into a context for reporting metrics.
        ctx, cancel := context.WithCancel(ri.ctx)
        go func() </span><span class="cov0" title="0">{
                &lt;-stopCh
                cancel()
        }</span>()

        <span class="cov0" title="0">go ri.metrics.ReportCountMetrics(ctx, ri.listers)</span>
}

func (ri *recorderInformer) HasSynced() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file210" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"
        "sync"
        "time"

        "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "k8s.io/apimachinery/pkg/labels"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/metrics"
)

var (
        elMetricsName = "eventlistener_count"
        elCount       = stats.Float64(elMetricsName,
                "number of eventlistener",
                stats.UnitDimensionless)
        elCountView *view.View

        tbMetricsName = "triggerbinding_count"
        tbCount       = stats.Float64(tbMetricsName,
                "number of triggerbinding",
                stats.UnitDimensionless)
        tbCountView *view.View

        ctbMetricsName = "clustertriggerbinding_count"
        ctbCount       = stats.Float64(ctbMetricsName,
                "number of clustertriggerbinding",
                stats.UnitDimensionless)
        ctbCountView *view.View

        ttMetricsName = "triggertemplate_count"
        ttCount       = stats.Float64(ttMetricsName,
                "number of triggertemplate",
                stats.UnitDimensionless)
        ttCountView *view.View

        ciMetricsName = "clusterinterceptor_count"
        ciCount       = stats.Float64(ciMetricsName,
                "number of clusterinterceptor",
                stats.UnitDimensionless)
        ciCountView *view.View
)

type listers struct {
        el  v1beta1.EventListenerLister
        ctb v1beta1.ClusterTriggerBindingLister
        tb  v1beta1.TriggerBindingLister
        tt  v1beta1.TriggerTemplateLister
        ci  v1alpha1.ClusterInterceptorLister
}

// Recorder holds information for Trigger metrics
type Recorder struct {
        initialized     bool
        ReportingPeriod time.Duration
}

// We cannot register the view multiple times, so NewRecorder lazily
// initializes this singleton and returns the same recorder across any
// subsequent invocations.
var (
        once        sync.Once
        r           *Recorder
        recorderErr error //nolint:errname
)

// revive:disable:unused-parameter

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder(ctx context.Context) (*Recorder, error) <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                r = &amp;Recorder{
                        initialized: true,
                        // Default to reporting metrics every 60s.
                        ReportingPeriod: 60 * time.Second,
                }

                recorderErr = viewRegister()
                if recorderErr != nil </span><span class="cov0" title="0">{
                        r.initialized = false
                        return
                }</span>
        })

        <span class="cov8" title="1">return r, recorderErr</span>
}

func viewRegister() error <span class="cov8" title="1">{
        elCountView = &amp;view.View{
                Description: elCount.Description(),
                Measure:     elCount,
                Aggregation: view.LastValue(),
        }

        tbCountView = &amp;view.View{
                Description: tbCount.Description(),
                Measure:     tbCount,
                Aggregation: view.LastValue(),
        }

        ctbCountView = &amp;view.View{
                Description: ctbCount.Description(),
                Measure:     ctbCount,
                Aggregation: view.LastValue(),
        }

        ttCountView = &amp;view.View{
                Description: ttCount.Description(),
                Measure:     ttCount,
                Aggregation: view.LastValue(),
        }

        ciCountView = &amp;view.View{
                Description: ciCount.Description(),
                Measure:     ciCount,
                Aggregation: view.LastValue(),
        }

        return view.Register(
                elCountView,
                tbCountView,
                ctbCountView,
                ttCountView,
                ciCountView,
        )
}</span>

func (r *Recorder) ReportCountMetrics(ctx context.Context, li listers) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // When the context is cancelled, stop reporting.
                        return</span>

                case &lt;-time.After(r.ReportingPeriod):<span class="cov0" title="0">
                        r.CountMetrics(ctx, li)</span>
                }
        }
}

func (r *Recorder) CountMetrics(ctx context.Context, li listers) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        el, err := li.el.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for eventlisteners: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(el)
                r.countMetrics(ctx, float64(count), elCount)
        }</span>
        <span class="cov8" title="1">ci, err := li.ci.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for clusterinterceptor: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(ci)
                r.countMetrics(ctx, float64(count), ciCount)
        }</span>
        <span class="cov8" title="1">tb, err := li.tb.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for triggerbindings : %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(tb)
                r.countMetrics(ctx, float64(count), tbCount)
        }</span>
        <span class="cov8" title="1">ctb, err := li.ctb.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for clustertriggerbindings: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(ctb)
                r.countMetrics(ctx, float64(count), ctbCount)
        }</span>
        <span class="cov8" title="1">tt, err := li.tt.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for triggertemplates: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(tt)
                r.countMetrics(ctx, float64(count), ttCount)
        }</span>
}

func (r *Recorder) countMetrics(ctx context.Context, count float64, measure *stats.Float64Measure) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        if !r.initialized </span><span class="cov8" title="1">{
                logger.Errorf("ignoring the metrics recording for %s, failed to initialize the metrics recorder", measure.Description())
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, measure.M(count))</span>
}
</pre>
		
		<pre class="file" id="file211" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/tektoncd/triggers/pkg/apis/triggers"
        kerrors "k8s.io/apimachinery/pkg/api/errors"

        "k8s.io/client-go/dynamic"

        "go.uber.org/zap"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        discoveryclient "k8s.io/client-go/discovery"
)

// findAPIResource returns the APIResource definition using the discovery client c.
func findAPIResource(apiVersion, kind string, c discoveryclient.ServerResourcesInterface) (*metav1.APIResource, error) <span class="cov8" title="1">{
        resourceList, err := c.ServerResourcesForGroupVersion(apiVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting kubernetes server resources for apiVersion %s: %w", apiVersion, err)
        }</span>
        <span class="cov8" title="1">for i := range resourceList.APIResources </span><span class="cov8" title="1">{
                r := &amp;resourceList.APIResources[i]
                if r.Kind != kind </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Resolve GroupVersion from parent list to have consistent resource identifiers.
                <span class="cov8" title="1">if r.Version == "" || r.Group == "" </span><span class="cov8" title="1">{
                        gv, err := schema.ParseGroupVersion(resourceList.GroupVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing GroupVersion: %w", err)
                        }</span>
                        <span class="cov8" title="1">r.Group = gv.Group
                        r.Version = gv.Version</span>
                }
                <span class="cov8" title="1">return r, nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("error could not find resource with apiVersion %s and kind %s", apiVersion, kind)</span>
}

// Create uses the kubeClient to create the resource defined in the
// TriggerResourceTemplate and returns any errors with this process
func Create(logger *zap.SugaredLogger, rt json.RawMessage, triggerName, eventID, elName, elNamespace string, c discoveryclient.ServerResourcesInterface, dc dynamic.Interface) error <span class="cov8" title="1">{
        // Assume the TriggerResourceTemplate is valid (it has an apiVersion and Kind)
        data := new(unstructured.Unstructured)
        if err := data.UnmarshalJSON(rt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't unmarshal json from the TriggerTemplate: %w", err)
        }</span>

        <span class="cov8" title="1">data, err := addLabels(data, map[string]string{
                triggers.EventListenerLabelKey: elName,
                triggers.EventIDLabelKey:       eventID,
                triggers.TriggerLabelKey:       triggerName,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">namespace := data.GetNamespace()
        // Default the resource creation to the EventListenerNamespace if not found in the resource template
        if namespace == "" </span><span class="cov8" title="1">{
                namespace = elNamespace
        }</span>

        // Resolve resource kind to the underlying API Resource type.
        <span class="cov8" title="1">apiResource, err := findAPIResource(data.GetAPIVersion(), data.GetKind(), c)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't find API resource for json: %w", err)
        }</span>

        <span class="cov8" title="1">name := data.GetName()
        if name == "" </span><span class="cov0" title="0">{
                name = data.GetGenerateName()
        }</span>
        <span class="cov8" title="1">logger.Infof("Generating resource: kind: %s, name: %s", apiResource, name)

        gvr := schema.GroupVersionResource{
                Group:    apiResource.Group,
                Version:  apiResource.Version,
                Resource: apiResource.Name,
        }

        logger.Infof("For event ID %q creating resource %v", eventID, gvr)

        if _, err := dc.Resource(gvr).Namespace(namespace).Create(context.Background(), data, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                if kerrors.IsUnauthorized(err) || kerrors.IsForbidden(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("couldn't create resource with group version kind %q: %w", gvr, err)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// addLabels adds autogenerated Tekton labels to created resources.
func addLabels(us *unstructured.Unstructured, labelsToAdd map[string]string) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        labels, _, err := unstructured.NestedStringMap(us.Object, "metadata", "labels")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if labels == nil </span><span class="cov8" title="1">{
                labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">for k, v := range labelsToAdd </span><span class="cov8" title="1">{
                l := fmt.Sprintf("%s/%s", triggers.GroupName, strings.TrimLeft(k, "/"))
                labels[l] = v
        }</span>

        <span class="cov8" title="1">us.SetLabels(labels)
        return us, nil</span>
}
</pre>
		
		<pre class="file" id="file212" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "fmt"

        "go.uber.org/zap"
        discoveryclient "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
)

// AuthOverride is an interface that constructs a discovery client for the ServerResourceInterface
// and a dynamic client for the Tekton Resources, using the token provide as the bearer token in the
// REST config used to build those client.  The other non-credential related parameters for the
// REST client used are copied from the in cluster config of the event sink.
type AuthOverride interface {
        OverrideAuthentication(sa string,
                namespace string,
                log *zap.SugaredLogger,
                defaultDiscoveryClient discoveryclient.ServerResourcesInterface,
                defaultDynamicClient dynamic.Interface) (discoveryClient discoveryclient.ServerResourcesInterface,
                dynamicClient dynamic.Interface,
                err error)
}

type DefaultAuthOverride struct {
}

func (r DefaultAuthOverride) OverrideAuthentication(sa string,
        namespace string,
        log *zap.SugaredLogger,
        defaultDiscoverClient discoveryclient.ServerResourcesInterface,
        defaultDynamicClient dynamic.Interface) (discoveryClient discoveryclient.ServerResourcesInterface,
        dynamicClient dynamic.Interface,
        err error) <span class="cov0" title="0">{
        dynamicClient = defaultDynamicClient
        discoveryClient = defaultDiscoverClient
        clusterConfig, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("overrideAuthentication: problem getting in cluster config: %#v\n", err)
                return
        }</span>
        <span class="cov0" title="0">clusterConfig.Impersonate = rest.ImpersonationConfig{
                UserName: fmt.Sprintf("system:serviceaccount:%s:%s", namespace, sa),
        }
        dynamicClient, err = dynamic.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("overrideAuthentication: problem getting dynamic client set: %#v\n", err)
                return
        }</span>
        <span class="cov0" title="0">kubeClient, err := kubernetes.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("overrideAuthentication: problem getting kube client: %#v\n", err)
                return
        }</span>
        <span class="cov0" title="0">discoveryClient = kubeClient.Discovery()

        return</span>
}
</pre>
		
		<pre class="file" id="file213" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "fmt"
        "time"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "go.uber.org/zap"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

// CEClient matches the `Client` interface from github.com/cloudevents/sdk-go/v2/cloudevents
type CEClient cloudevents.Client

// Resource structure defines parameters needed to send cloudEvents
type Resource struct {
        EventID   string
        EventType string
        TargetURI string
        Client    CEClient
        Logger    *zap.SugaredLogger
        Data      []byte
        EL        triggersv1.EventListener
}

// SendCloudEvents is used by the EventListener to send cloud events status of
// trigger processing
func (r Resource) SendCloudEvents() <span class="cov8" title="1">{
        logger := r.Logger.With(zap.String("trigger", r.EL.Name))

        event := cloudevents.NewEvent()
        event.SetID(r.EventID)
        event.SetSubject(r.EL.Name + " processing " + r.EventID)
        gvk := r.EL.GetObjectKind().GroupVersionKind()
        source := fmt.Sprintf("/apis/%s/%s/namespaces/%s/%s/%s",
                gvk.Group,
                gvk.Version,
                r.EL.Namespace,
                gvk.Kind,
                r.EL.Name)
        event.SetSource(source)
        event.SetType(r.EventType)

        if err := event.SetData(cloudevents.ApplicationJSON, r.Data); err != nil </span><span class="cov0" title="0">{
                logger.With(zap.Error(err)).Error("failed to set cloudevent data.")
                return
        }</span>

        // Send the event.
        <span class="cov8" title="1">result := r.Client.Send(cloudevents.ContextWithTarget(cloudevents.ContextWithRetriesExponentialBackoff(context.Background(), 10*time.Millisecond, 10), r.TargetURI), event)

        if !cloudevents.IsACK(result) </span><span class="cov0" title="0">{
                logger.With(zap.Error(result)).Error("failed to send cloudevent.")
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file214" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "net/http"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{
                return withCloudEventClient(ctx)
        }</span>)
}

// CECKey is used to associate the CloudEventClient inside the context.Context
type CECKey struct{}

func withCloudEventClient(ctx context.Context) context.Context <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // When KeepAlive is enabled the connections are not reused - see
        // Bug https://github.com/tektoncd/pipeline/issues/3190. This causes the
        // number of connections to keep growing, even if when we limit max idle
        // connections in the transport.
        // TODO(afrittoli) Re-enable keep alive and ensure connections are reused
        // See feature https://github.com/tektoncd/pipeline/issues/3204
        var useOnceTransport http.RoundTripper = &amp;http.Transport{
                DisableKeepAlives: true,
        }

        p, err := cloudevents.NewHTTP(cloudevents.WithRoundTripper(useOnceTransport))
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Error creating the cloudevents http protocol: %s", err)
        }</span>

        <span class="cov0" title="0">cloudEventClient, err := cloudevents.NewClient(p, cloudevents.WithUUIDs(), cloudevents.WithTimeNow())
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Error creating the cloudevents client: %s", err)
        }</span>

        <span class="cov0" title="0">return context.WithValue(ctx, CECKey{}, cloudEventClient)</span>
}

// Get extracts the cloudEventClient client from the context.
func Get(ctx context.Context) CEClient <span class="cov0" title="0">{
        untyped := ctx.Value(CECKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf(
                        "Unable to fetch client from context.")
                return nil
        }</span>
        <span class="cov0" title="0">return untyped.(CEClient)</span>
}

// ToContext adds the cloud events client to the context
func ToContext(ctx context.Context, cec CEClient) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, CECKey{}, cec)
}</span>
</pre>
		
		<pre class="file" id="file215" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "context"
        "flag"
        "time"

        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        "github.com/tektoncd/triggers/pkg/sink/cloudevent"
        "golang.org/x/xerrors"
        discoveryclient "k8s.io/client-go/discovery"
        kubeclientset "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        restclient "k8s.io/client-go/rest"
)

const (
        // Flag definitions
        name        = "el-name"
        elNamespace = "el-namespace"
        port        = "port"
        isMultiNS   = "is-multi-ns"
)

var (
        nameFlag = flag.String("el-name", "",
                "The name of the EventListener resource for this sink.")
        namespaceFlag = flag.String("el-namespace", "",
                "The namespace of the EventListener resource for this sink.")
        portFlag = flag.String("port", "",
                "The port for the EventListener sink to listen on.")
        elReadTimeOut = flag.Int64("readtimeout", 5,
                "The read timeout for EventListener Server.")
        elWriteTimeOut = flag.Int64("writetimeout", 40,
                "The write timeout for EventListener Server.")
        elIdleTimeOut = flag.Int64("idletimeout", 30,
                "The idle timeout for EventListener Server.")
        elTimeOutHandler = flag.Int64("timeouthandler", 5,
                "The timeout for Timeout Handler of EventListener Server.")
        elHTTPClientReadTimeOut = flag.Int64("httpclient-readtimeout", 30,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientKeepAlive = flag.Int64("httpclient-keep-alive", 30,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientTLSHandshakeTimeout = flag.Int64("httpclient-tlshandshaketimeout", 10,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientResponseHeaderTimeout = flag.Int64("httpclient-responseheadertimeout", 10,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientExpectContinueTimeout = flag.Int64("httpclient-expectcontinuetimeout", 1,
                "The HTTP Client read timeout for EventListener Server.")
        isMultiNSFlag = flag.Bool("is-multi-ns", false,
                "Whether EventListener serve Multiple NS.")
        tlsCertFlag = flag.String("tls-cert", "",
                "The filename for the TLS certificate.")
        tlsKeyFlag = flag.String("tls-key", "",
                "The filename for the TLS key.")
        payloadValidation = flag.Bool("payload-validation", true,
                "Whether to disable payload validation or not.")
        cloudEventURI = flag.String("cloudevent-uri", "", "uri for cloudevent")
)

// Args define the arguments for Sink.
type Args struct {
        // ElName is the EventListener name.
        ElName string
        // ElNamespace is the EventListener namespace.
        ElNamespace string
        // Port is the port the Sink should listen on.
        Port string
        // ELReadTimeOut defines the read timeout for EventListener Server
        ELReadTimeOut time.Duration
        // ELWriteTimeOut defines the write timeout for EventListener Server
        ELWriteTimeOut time.Duration
        // ELIdleTimeOut defines the read timeout for EventListener Server
        ELIdleTimeOut time.Duration
        // ELTimeOutHandler defines the timeout for Timeout Handler of EventListener Server
        ELTimeOutHandler time.Duration
        // ElHTTPClientReadTimeOut defines the Read timeout for HTTP Client
        ElHTTPClientReadTimeOut time.Duration
        // ElHTTPClientKeepAlive defines the Keep Alive for HTTP Client
        ElHTTPClientKeepAlive time.Duration
        // ElTLSHandshakeTimeout defines the Handshake timeout for HTTP Client
        ElHTTPClientTLSHandshakeTimeout time.Duration
        // ElResponseHeaderTimeout defines the Response Header timeout for HTTP Client
        ElHTTPClientResponseHeaderTimeout time.Duration
        // ElExpectContinueTimeout defines the Expect timeout for HTTP Client
        ElHTTPClientExpectContinueTimeout time.Duration
        // IsMultiNS determines whether el functions as namespaced or clustered
        IsMultiNS bool
        // Key defines the filename for tls Key.
        Key string
        // Cert defines the filename for tls Cert.
        Cert string
        // PayloadValidation defines whether to validate payload or not
        PayloadValidation bool
        // CloudEventURI refers to the location where cloudevent data need to be send
        CloudEventURI string
}

// Clients define the set of client dependencies Sink requires.
type Clients struct {
        DiscoveryClient discoveryclient.DiscoveryInterface
        RESTClient      restclient.Interface
        TriggersClient  triggersclientset.Interface
        K8sClient       *kubeclientset.Clientset
        CEClient        cloudevent.CEClient
}

// GetArgs returns the flagged Args
func GetArgs() (Args, error) <span class="cov8" title="1">{
        flag.Parse()
        if *nameFlag == "" </span><span class="cov8" title="1">{
                return Args{}, xerrors.Errorf("-%s arg not found", name)
        }</span>
        <span class="cov8" title="1">if *namespaceFlag == "" </span><span class="cov8" title="1">{
                return Args{}, xerrors.Errorf("-%s arg not found", elNamespace)
        }</span>
        <span class="cov8" title="1">if *portFlag == "" </span><span class="cov8" title="1">{
                return Args{}, xerrors.Errorf("-%s arg not found", port)
        }</span>

        <span class="cov8" title="1">return Args{
                ElName:                            *nameFlag,
                ElNamespace:                       *namespaceFlag,
                Port:                              *portFlag,
                IsMultiNS:                         *isMultiNSFlag,
                PayloadValidation:                 *payloadValidation,
                ELReadTimeOut:                     time.Duration(*elReadTimeOut),
                ELWriteTimeOut:                    time.Duration(*elWriteTimeOut),
                ELIdleTimeOut:                     time.Duration(*elIdleTimeOut),
                ELTimeOutHandler:                  time.Duration(*elTimeOutHandler),
                ElHTTPClientReadTimeOut:           time.Duration(*elHTTPClientReadTimeOut),
                ElHTTPClientKeepAlive:             time.Duration(*elHTTPClientKeepAlive),
                ElHTTPClientTLSHandshakeTimeout:   time.Duration(*elHTTPClientTLSHandshakeTimeout),
                ElHTTPClientResponseHeaderTimeout: time.Duration(*elHTTPClientResponseHeaderTimeout),
                ElHTTPClientExpectContinueTimeout: time.Duration(*elHTTPClientExpectContinueTimeout),
                Cert:                              *tlsCertFlag,
                Key:                               *tlsKeyFlag,
                CloudEventURI:                     *cloudEventURI,
        }, nil</span>
}

// ConfigureClients returns the kubernetes and triggers clientsets
func ConfigureClients(ctx context.Context, clusterConfig *rest.Config) (Clients, error) <span class="cov0" title="0">{
        kubeClient, err := kubeclientset.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                return Clients{}, xerrors.Errorf("Failed to create KubeClient: %s", err)
        }</span>
        <span class="cov0" title="0">triggersClient, err := triggersclientset.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                return Clients{}, xerrors.Errorf("Failed to create TriggersClient: %s", err)
        }</span>
        <span class="cov0" title="0">ceClient := cloudevent.Get(ctx)
        return Clients{
                DiscoveryClient: kubeClient.Discovery(),
                RESTClient:      kubeClient.RESTClient(),
                TriggersClient:  triggersClient,
                K8sClient:       kubeClient,
                CEClient:        ceClient,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file216" style="display: none">package sink

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "time"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "knative.dev/pkg/metrics"
)

var (
        elDuration = stats.Float64(
                "http_duration_seconds",
                "The eventlistener HTTP request duration",
                stats.UnitDimensionless)
        elDistribution = view.Distribution(metrics.BucketsNBy10(0.001, 5)...)
        eventRcdCount  = stats.Float64("event_received_count",
                "number of events received by sink",
                stats.UnitDimensionless)
        triggeredResources = stats.Int64("triggered_resources", "Count of the number of triggered eventlistener resources", stats.UnitDimensionless)
)

const (
        failTag    = "failed"
        successTag = "succeeded"
)

// NewRecorder creates a new metrics recorder instance
// to log the TaskRun related metrics
func NewRecorder() (*Recorder, error) <span class="cov8" title="1">{
        r := &amp;Recorder{
                initialized: true,

                // Default to reporting metrics every 30s.
                ReportingPeriod: 30 * time.Second,
        }

        status, err := tag.NewKey("status")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r.status = status
        kind, err := tag.NewKey("kind")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r.kind = kind

        err = view.Register(
                &amp;view.View{
                        Description: elDuration.Description(),
                        Measure:     elDuration,
                        Aggregation: elDistribution,
                },
                &amp;view.View{
                        Description: triggeredResources.Description(),
                        Measure:     triggeredResources,
                        Aggregation: view.Count(),
                        TagKeys:     []tag.Key{r.kind},
                },
                &amp;view.View{
                        Description: eventRcdCount.Description(),
                        Measure:     eventRcdCount,
                        Aggregation: view.Count(),
                        TagKeys:     []tag.Key{r.status},
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to register eventlistener metrics: %s", err)
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (s *Sink) NewMetricsRecorderInterceptor() MetricsInterceptor <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) </span><span class="cov8" title="1">{
                recorder := &amp;StatusRecorder{
                        ResponseWriter: w,
                        Status:         200,
                }
                startTime := time.Now()
                defer func() </span><span class="cov8" title="1">{
                        endTime := time.Now()
                        elapsed := endTime.Sub(startTime)
                        // Log the consumed time
                        go s.recordDurationMetrics(recorder, elapsed)
                }</span>()
                <span class="cov8" title="1">next(recorder, r)</span>
        }
}

func (s *Sink) recordDurationMetrics(w *StatusRecorder, elapsed time.Duration) <span class="cov8" title="1">{
        duration := elapsed.Seconds()
        s.Logger.Debugw("event listener request completed", "status", w.Status, "duration", duration)
        ctx, err := tag.New(
                context.Background(),
        )

        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warnf("failed to create tag for http metric request: %w", err)
                return
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, elDuration.M(duration))</span>
}

func (s *Sink) recordCountMetrics(status string) <span class="cov8" title="1">{
        s.Logger.Debugw("event listener request", "status", status)
        ctx, err := tag.New(
                context.Background(),
                tag.Insert(s.Recorder.status, status),
        )

        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warnf("failed to create tag for metric event_received_count: %w", err)
                return
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, eventRcdCount.M(1))</span>
}

func (s *Sink) recordResourceCreation(resources []json.RawMessage) <span class="cov8" title="1">{
        for _, rt := range resources </span><span class="cov8" title="1">{
                // Assume the TriggerResourceTemplate is valid (it has an apiVersion and Kind)
                data := new(unstructured.Unstructured)
                if err := data.UnmarshalJSON(rt); err != nil </span><span class="cov0" title="0">{
                        s.Logger.Warnf("couldn't unmarshal json from the TriggerTemplate: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">ctx, err := tag.New(context.Background(), tag.Insert(s.Recorder.kind, data.GetKind()))
                if err != nil </span><span class="cov0" title="0">{
                        s.Logger.Warnf("failed to create tag for resource creation: %w", err)
                        continue</span>
                }

                <span class="cov8" title="1">metrics.Record(ctx, triggeredResources.M(1))</span>
        }
}

type Recorder struct {
        initialized bool

        status tag.Key
        kind   tag.Key

        ReportingPeriod time.Duration
}

type StatusRecorder struct {
        http.ResponseWriter
        Status int
}

func (r *StatusRecorder) WriteHeader(status int) <span class="cov8" title="1">{
        r.Status = status
        r.ResponseWriter.WriteHeader(status)
}</span>

// MetricsInterceptor intercepts an HTTP handler invocation, it is passed both response writer and request
// which after interception can be passed onto the handler function.
type MetricsInterceptor func(http.ResponseWriter, *http.Request, http.HandlerFunc)

// MetricsHandlerFunc builds on top of http.Handler, and exposes API to intercept with MetricsInterceptor.
// This allows building complex long chains without complicated struct manipulation
type MetricsHandler struct {
        Handler http.Handler
}

// Intercept returns back a continuation that will call the handler func to intercept
// the continuation call.
func (cont *MetricsHandler) Intercept(mw MetricsInterceptor) http.HandlerFunc <span class="cov8" title="1">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                mw(writer, request, cont.Handler.ServeHTTP)
        }</span>
}
</pre>
		
		<pre class="file" id="file217" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        net "net/url"
        "os"
        "sync"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/cloudevents/sdk-go/v2/binding"
        cehttp "github.com/cloudevents/sdk-go/v2/protocol/http"
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        listersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        listers "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "github.com/tektoncd/triggers/pkg/interceptors/webhook"
        "github.com/tektoncd/triggers/pkg/reconciler/events"
        "github.com/tektoncd/triggers/pkg/resources"
        "github.com/tektoncd/triggers/pkg/sink/cloudevent"
        "github.com/tektoncd/triggers/pkg/template"
        "github.com/tidwall/sjson"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        discoveryclient "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/record"
        "knative.dev/pkg/apis"
        v1 "knative.dev/pkg/apis/duck/v1"
)

// Sink defines the sink resource for processing incoming events for the
// EventListener.
type Sink struct {
        KubeClientSet          kubernetes.Interface
        TriggersClient         triggersclientset.Interface
        DiscoveryClient        discoveryclient.ServerResourcesInterface
        DynamicClient          dynamic.Interface
        HTTPClient             *http.Client
        CEClient               cloudevent.CEClient
        EventListenerName      string
        EventListenerNamespace string
        Logger                 *zap.SugaredLogger
        Recorder               *Recorder
        Auth                   AuthOverride
        PayloadValidation      bool
        CloudEventURI          string
        // WGProcessTriggers keeps track of triggers or triggerGroups currently being processed
        // Currently only used in tests to wait for all triggers to finish processing
        WGProcessTriggers *sync.WaitGroup
        EventRecorder     record.EventRecorder

        // listers index properties about resources
        EventListenerLister         listers.EventListenerLister
        TriggerLister               listers.TriggerLister
        TriggerBindingLister        listers.TriggerBindingLister
        ClusterTriggerBindingLister listers.ClusterTriggerBindingLister
        TriggerTemplateLister       listers.TriggerTemplateLister
        ClusterInterceptorLister    listersv1alpha1.ClusterInterceptorLister
        InterceptorLister           listersv1alpha1.InterceptorLister
}

// Response defines the HTTP body that the Sink responds to events with.
type Response struct {
        // EventListener is the name of the eventListener.
        // Deprecated: use EventListenerUID instead.
        EventListener string `json:"eventListener"`
        // Namespace is the namespace that the eventListener is running in.
        // Deprecated: use EventListenerUID instead.
        Namespace string `json:"namespace,omitempty"`
        // EventListenerUID is the UID of the EventListener
        EventListenerUID string `json:"eventListenerUID"`
        // EventID is a uniqueID that gets assigned to each incoming request
        EventID string `json:"eventID,omitempty"`
        // ErrorMessage gives message about Error which occurs during event processing
        ErrorMessage string `json:"errorMessage,omitempty"`
}

func (r Sink) emitEvents(recorder record.EventRecorder, el *triggersv1.EventListener, eventType string, err error) <span class="cov8" title="1">{
        if os.Getenv("EL_EVENT") == "enable" </span><span class="cov0" title="0">{
                events.Emit(recorder, eventType, el, err)
        }</span>
}

// HandleEvent processes an incoming HTTP event for the event listener.
func (r Sink) HandleEvent(response http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        log := r.Logger.With(
                zap.String("eventlistener", r.EventListenerName),
                zap.String("namespace", r.EventListenerNamespace),
        )
        eventID := template.UUID()
        log = log.With(zap.String(triggers.EventIDLabelKey, eventID))

        elTemp := triggersv1.EventListener{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "EventListener",
                        APIVersion: "v1beta1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      r.EventListenerName,
                        Namespace: r.EventListenerNamespace,
                },
                Spec: triggersv1.EventListenerSpec{
                        Resources: triggersv1.Resources{
                                KubernetesResource: &amp;triggersv1.KubernetesResource{
                                        WithPodSpec: v1.WithPodSpec{
                                                Template: v1.PodSpecable{
                                                        Spec: corev1.PodSpec{
                                                                Containers: []corev1.Container{{
                                                                        // enabled by default for temporary EL
                                                                        Env: []corev1.EnvVar{{
                                                                                Name:  "EL_EVENT",
                                                                                Value: "true",
                                                                        }},
                                                                }},
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        r.emitEvents(r.EventRecorder, &amp;elTemp, events.TriggerProcessingStartedV1, nil)
        r.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingStartedV1)

        event, err := io.ReadAll(request.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error reading event body: %s", err)
                r.recordCountMetrics(failTag)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, &amp;elTemp, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>

        <span class="cov8" title="1">el, err := r.EventListenerLister.EventListeners(r.EventListenerNamespace).Get(r.EventListenerName)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("Error getting EventListener %s in Namespace %s: %s", r.EventListenerName, r.EventListenerNamespace, err)
                r.recordCountMetrics(failTag)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, &amp;elTemp, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>

        <span class="cov8" title="1">elUID := string(el.GetUID())
        log = log.With(zap.String("eventlistenerUID", elUID))

        log = log.With(zap.String(triggers.EventIDLabelKey, eventID))
        log.Debugf("handling event with path %s, payload: %s and header: %v", request.URL.Path, string(event), request.Header)
        trItems, err := r.selectTriggers(el.Spec.NamespaceSelector, el.Spec.LabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Errorf("unable to select configured mergedTriggers: %s", err)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>

        // Process any ungroupedTriggers
        <span class="cov8" title="1">mergedTriggers, err := r.merge(el.Spec.Triggers, trItems)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error merging triggers: %s", err)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>
        <span class="cov8" title="1">r.WGProcessTriggers.Add(len(mergedTriggers))
        for _, t := range mergedTriggers </span><span class="cov8" title="1">{
                go func(t triggersv1.Trigger) </span><span class="cov8" title="1">{
                        defer r.WGProcessTriggers.Done()
                        localRequest := request.Clone(request.Context())
                        emptyExtensions := make(map[string]interface{})
                        r.processTrigger(t, el, localRequest, event, eventID, log, emptyExtensions)
                }</span>(*t)
        }

        // Process grouped triggers
        <span class="cov8" title="1">for _, group := range el.Spec.TriggerGroups </span><span class="cov8" title="1">{
                r.WGProcessTriggers.Add(1)
                go func(g triggersv1.EventListenerTriggerGroup) </span><span class="cov8" title="1">{
                        defer r.WGProcessTriggers.Done()
                        localRequest := request.Clone(request.Context())
                        r.processTriggerGroups(g, el, localRequest, event, eventID, log, r.WGProcessTriggers)
                }</span>(group)
        }

        <span class="cov8" title="1">r.recordCountMetrics(successTag)

        body := Response{
                EventListener:    r.EventListenerName,
                EventListenerUID: elUID,
                Namespace:        r.EventListenerNamespace,
                EventID:          eventID,
        }

        msg := cehttp.NewMessageFromHttpRequest(request)
        if encoding := msg.ReadEncoding(); encoding == binding.EncodingUnknown </span><span class="cov8" title="1">{
                response.WriteHeader(http.StatusAccepted)
                response.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(response).Encode(body); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to write back sink response: %v", err)
                        r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                        r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                }</span>
        } else<span class="cov8" title="1"> {
                responseEvent := cloudevents.NewEvent()
                responseEvent.SetID(eventID)
                responseEvent.SetType(events.EventAccepted)
                responseEvent.SetSubject(r.EventListenerNamespace + "." + r.EventListenerName + " accepted " + eventID)
                responseEvent.SetSource(r.EventListenerName) // We need to change this like in SendCloudEvents

                _ = responseEvent.SetData(cloudevents.ApplicationJSON, body)

                eventResponse := binding.ToMessage(&amp;responseEvent)
                defer func() </span><span class="cov8" title="1">{
                        if err := eventResponse.Finish(nil); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to close cloud event sink response: %v", err)
                        }</span>
                }()

                <span class="cov8" title="1">if err := cehttp.WriteResponseWriter(request.Context(), eventResponse, http.StatusAccepted, response); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to write back cloud event sink response: %v", err)
                        r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                        r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                }</span>
        }
        <span class="cov8" title="1">r.emitEvents(r.EventRecorder, el, events.TriggerProcessingDoneV1, nil)
        r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingDoneV1)</span>
}

func (r Sink) sendCloudEvents(headers http.Header, el triggersv1.EventListener, eventID, eventType string) <span class="cov8" title="1">{
        data, err := json.Marshal(headers)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Errorf("Error marshaling request Headers to json: %s", err)
                return
        }</span>

        // If no cloudEventURI, then don't try to sendCloudEvents
        <span class="cov8" title="1">if r.CloudEventURI == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">resource := cloudevent.Resource{
                EventID:   eventID,
                EventType: eventType,
                TargetURI: r.CloudEventURI,
                Client:    r.CEClient,
                Logger:    r.Logger,
                Data:      data,
                EL:        el,
        }

        go resource.SendCloudEvents()</span>
}

func (r Sink) merge(et []triggersv1.EventListenerTrigger, trItems []*triggersv1.Trigger) ([]*triggersv1.Trigger, error) <span class="cov8" title="1">{
        triggers := trItems
        for _, t := range et </span><span class="cov8" title="1">{
                switch </span>{
                case t.Template == nil &amp;&amp; t.TriggerRef != "":<span class="cov8" title="1">
                        trig, err := r.TriggerLister.Triggers(r.EventListenerNamespace).Get(t.TriggerRef)
                        if err != nil </span><span class="cov8" title="1">{
                                r.Logger.Errorf("Error getting Trigger %s in Namespace %s: %s", t.TriggerRef, r.EventListenerNamespace, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">triggers = append(triggers, trig)</span>
                case t.Template != nil:<span class="cov8" title="1">
                        triggers = append(triggers, &amp;triggersv1.Trigger{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      t.Name,
                                        Namespace: r.EventListenerNamespace},
                                Spec: triggersv1.TriggerSpec{
                                        ServiceAccountName: t.ServiceAccountName,
                                        Bindings:           t.Bindings,
                                        Template:           *t.Template,
                                        Interceptors:       t.Interceptors,
                                },
                        })</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("EventListenerTrigger not defined")</span>
                }
        }
        <span class="cov8" title="1">return triggers, nil</span>
}

func (r Sink) processTriggerGroups(g triggersv1.EventListenerTriggerGroup, el *triggersv1.EventListener, request *http.Request, event []byte, eventID string, eventLog *zap.SugaredLogger, wg *sync.WaitGroup) <span class="cov8" title="1">{
        log := eventLog.With(zap.String(triggers.TriggerGroupLabelKey, g.Name))

        extensions := map[string]interface{}{}
        payload, header, resp, err := r.ExecuteInterceptors(g.Interceptors, request, event, log, eventID, fmt.Sprintf("namespaces/%s/triggerGroups/%s", r.EventListenerNamespace, g.Name), r.EventListenerNamespace, extensions)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>
        <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                if resp.Extensions != nil </span><span class="cov8" title="1">{
                        for k, v := range resp.Extensions </span><span class="cov8" title="1">{
                                extensions[k] = v
                        }</span>
                }
                <span class="cov8" title="1">if !resp.Continue </span><span class="cov0" title="0">{
                        eventLog.Debugf("interceptor stopped trigger processing: %v", resp.Status.Err())
                        return
                }</span>
        }

        <span class="cov8" title="1">trItems, err := r.selectTriggers(g.TriggerSelector.NamespaceSelector, g.TriggerSelector.LabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a new HTTP request that contains the body and header from any interceptors in the TriggerGroup
        // This request will be passed on to the triggers in this group
        <span class="cov8" title="1">triggerReq := request.Clone(request.Context())
        triggerReq.Header = header
        triggerReq.Body = io.NopCloser(bytes.NewBuffer(payload))

        wg.Add(len(trItems))
        for _, t := range trItems </span><span class="cov8" title="1">{
                go func(t triggersv1.Trigger) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        // TODO(dibyom): We might be able to get away with only cloning if necessary
                        // i.e. if there are interceptors and iff those interceptors will modify the body/header (i.e. webhook)
                        localRequest := triggerReq.Clone(triggerReq.Context())
                        r.processTrigger(t, el, localRequest, event, eventID, log, extensions)
                }</span>(*t)
        }
}

func (r Sink) selectTriggers(namespaceSelector triggersv1.NamespaceSelector, labelSelector *metav1.LabelSelector) ([]*triggersv1.Trigger, error) <span class="cov8" title="1">{
        var trItems []*triggersv1.Trigger
        var err error
        targetLabels := labels.Everything()
        if labelSelector != nil </span><span class="cov8" title="1">{
                targetLabels, err = metav1.LabelSelectorAsSelector(labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        r.Logger.Errorf("failed to create label selector: %v", err)
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">var triggerFunc func() ([]*triggersv1.Trigger, error)
        switch </span>{
        case len(namespaceSelector.MatchNames) == 1 &amp;&amp; namespaceSelector.MatchNames[0] == "*":<span class="cov0" title="0">
                triggerFunc = func() ([]*triggersv1.Trigger, error) </span><span class="cov0" title="0">{
                        return r.TriggerLister.List(targetLabels)
                }</span>
        case len(namespaceSelector.MatchNames) != 0:<span class="cov8" title="1">
                triggerFunc = func() ([]*triggersv1.Trigger, error) </span><span class="cov8" title="1">{
                        var trList []*triggersv1.Trigger
                        for _, v := range namespaceSelector.MatchNames </span><span class="cov8" title="1">{
                                trNsList, err := r.TriggerLister.Triggers(v).List(targetLabels)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">trList = append(trList, trNsList...)</span>
                        }
                        <span class="cov8" title="1">return trList, nil</span>
                }
        case len(namespaceSelector.MatchNames) == 0:<span class="cov8" title="1">
                if labelSelector != nil </span><span class="cov8" title="1">{
                        triggerFunc = func() ([]*triggersv1.Trigger, error) </span><span class="cov8" title="1">{
                                return r.TriggerLister.Triggers(r.EventListenerNamespace).List(targetLabels)
                        }</span>
                }
        }
        <span class="cov8" title="1">if triggerFunc == nil </span><span class="cov8" title="1">{
                return trItems, nil
        }</span>
        <span class="cov8" title="1">trList, err := triggerFunc()
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Errorf("Error getting Triggers: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">trItems = append(trItems, trList...)

        return trItems, nil</span>
}

func (r Sink) processTrigger(t triggersv1.Trigger, el *triggersv1.EventListener, request *http.Request, event []byte, eventID string, eventLog *zap.SugaredLogger, extensions map[string]interface{}) <span class="cov8" title="1">{
        log := eventLog.With(zap.String(triggers.TriggerLabelKey, t.Name))

        finalPayload, header, iresp, err := r.ExecuteTriggerInterceptors(t, request, event, log, eventID, extensions)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>

        <span class="cov8" title="1">if iresp != nil </span><span class="cov8" title="1">{
                if !iresp.Continue </span><span class="cov0" title="0">{
                        log.Debugf("interceptor stopped trigger processing: %v", iresp.Status.Err())
                        return
                }</span>
        }

        <span class="cov8" title="1">rt, err := template.ResolveTrigger(t,
                r.TriggerBindingLister.TriggerBindings(t.Namespace).Get,
                r.ClusterTriggerBindingLister.Get,
                r.TriggerTemplateLister.TriggerTemplates(t.Namespace).Get)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>
        <span class="cov8" title="1">if iresp != nil &amp;&amp; iresp.Extensions != nil </span><span class="cov8" title="1">{
                extensions = iresp.Extensions
        }</span>
        <span class="cov8" title="1">params, err := template.ResolveParams(rt, finalPayload, header, extensions, template.NewTriggerContext(eventID))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>

        <span class="cov8" title="1">log.Infof("ResolvedParams : %+v", params)
        resources := template.ResolveResources(rt.TriggerTemplate, params)

        if err := r.CreateResources(t.Namespace, t.Spec.ServiceAccountName, resources, t.Name, eventID, log); err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>
        <span class="cov8" title="1">go r.recordResourceCreation(resources)
        r.emitEvents(r.EventRecorder, el, events.TriggerProcessingSuccessfulV1, nil)
        r.sendCloudEvents(request.Header, *el, eventID, events.TriggerProcessingSuccessfulV1)</span>
}

func (r Sink) ExecuteTriggerInterceptors(t triggersv1.Trigger, in *http.Request, event []byte, log *zap.SugaredLogger, eventID string, extensions map[string]interface{}) ([]byte, http.Header, *triggersv1.InterceptorResponse, error) <span class="cov8" title="1">{
        return r.ExecuteInterceptors(t.Spec.Interceptors, in, event, log, eventID, fmt.Sprintf("namespaces/%s/triggers/%s", t.Namespace, t.Name), t.Namespace, extensions)
}</span>

// ExecuteInterceptor executes all interceptors for the Trigger and returns back the body, header, and InterceptorResponse to use.
// When TEP-0022 is fully implemented, this function will only return the InterceptorResponse and error.
func (r Sink) ExecuteInterceptors(trInt []*triggersv1.TriggerInterceptor, in *http.Request, event []byte, log *zap.SugaredLogger, eventID string, triggerID string, namespace string, extensions map[string]interface{}) ([]byte, http.Header, *triggersv1.InterceptorResponse, error) <span class="cov8" title="1">{
        if len(trInt) == 0 </span><span class="cov8" title="1">{
                return event, in.Header, nil, nil
        }</span>

        // request is the request sent to the interceptors in the chain. Each interceptor can set the InterceptorParams field
        // or add to the Extensions
        <span class="cov8" title="1">request := triggersv1.InterceptorRequest{
                Body:       string(event),
                Header:     in.Header.Clone(),
                Extensions: make(map[string]interface{}),
                Context: &amp;triggersv1.TriggerContext{
                        EventURL: in.URL.String(),
                        EventID:  eventID,
                        // t.Name might not be fully accurate until we get rid of triggers inlined within EventListener
                        TriggerID: triggerID,
                },
        }
        for k, v := range extensions </span><span class="cov8" title="1">{
                request.Extensions[k] = v
        }</span>

        // check if string is urlencoded
        // Parse the query string into a map
        <span class="cov8" title="1">parsedQuery, _ := net.ParseQuery(request.Body)

        // parse form-data payload
        if v := in.Header.Get("Content-Type"); v == "application/x-www-form-urlencoded" &amp;&amp; len(parsedQuery) &gt; 1 </span><span class="cov0" title="0">{
                // Convert the map into a JSON string
                jsonString, err := json.Marshal(parsedQuery)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Error converting map to JSON:", err)
                        return nil, nil, nil, err
                }</span>
                <span class="cov0" title="0">request.Body = string(jsonString)</span>
        }
        // request is the request sent to the interceptors in the chain. Each interceptor can set the InterceptorParams field
        // or add to the Extensions

        <span class="cov8" title="1">for _, i := range trInt </span><span class="cov8" title="1">{
                if i.Webhook != nil </span><span class="cov8" title="1">{ // Old style interceptor
                        body, err := extendBodyWithExtensions([]byte(request.Body), request.Extensions)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("could not merge extensions with body: %w", err)
                        }</span>
                        <span class="cov8" title="1">req := &amp;http.Request{
                                Method: http.MethodPost,
                                Header: request.Header,
                                URL:    in.URL,
                                Body:   io.NopCloser(bytes.NewBuffer(body)),
                        }
                        interceptor := webhook.NewInterceptor(i.Webhook, r.HTTPClient, namespace, log)
                        res, err := interceptor.ExecuteTrigger(req)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, nil, nil, err
                        }</span>

                        <span class="cov8" title="1">payload, err := io.ReadAll(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("error reading webhook interceptor response body: %w", err)
                        }</span>
                        <span class="cov8" title="1">defer res.Body.Close()
                        // Set the next request to be the output of the last response to enable
                        // request chaining.
                        request.Header = res.Header.Clone()
                        request.Body = string(payload)
                        continue</span>
                }
                <span class="cov8" title="1">request.InterceptorParams = interceptors.GetInterceptorParams(i)

                var url *apis.URL
                if i.Ref.Kind == triggersv1.ClusterInterceptorKind </span><span class="cov8" title="1">{
                        ic, err := r.ClusterInterceptorLister.Get(i.GetName())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if ic.Status.Address != nil &amp;&amp; ic.Status.Address.URL != nil </span><span class="cov0" title="0">{
                                url = ic.Status.Address.URL
                        }</span> else<span class="cov8" title="1"> if url, err = ic.ResolveAddress(); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("could not resolve clusterinterceptor URL: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i.Ref.Kind == triggersv1.NamespacedInterceptorKind </span><span class="cov8" title="1">{
                        if r.InterceptorLister == nil </span><span class="cov0" title="0">{
                                r.Logger.Debugf("nil lister")
                        }</span>
                        <span class="cov8" title="1">ic, err := r.InterceptorLister.Interceptors(r.EventListenerNamespace).Get(i.GetName())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if addr := ic.Status.Address; addr != nil &amp;&amp; addr.URL != nil </span><span class="cov0" title="0">{
                                url = addr.URL
                        }</span> else<span class="cov8" title="1"> if url, err = ic.ResolveAddress(); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("could not resolve nameSpacedinterceptor URL: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">interceptorResponse, err := interceptors.Execute(context.Background(), r.HTTPClient, &amp;request, url.String())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>
                <span class="cov8" title="1">if !interceptorResponse.Continue </span><span class="cov8" title="1">{
                        return nil, nil, interceptorResponse, nil
                }</span>

                <span class="cov8" title="1">if interceptorResponse.Extensions != nil </span><span class="cov8" title="1">{
                        // Merge any extensions and pass it on to the next request in the chain
                        for k, v := range interceptorResponse.Extensions </span><span class="cov8" title="1">{
                                request.Extensions[k] = v
                        }</span>
                }

                // Clear interceptorParams for the next interceptor in chain
                <span class="cov8" title="1">request.InterceptorParams = map[string]interface{}{}</span>
        }

        <span class="cov8" title="1">return []byte(request.Body), request.Header, &amp;triggersv1.InterceptorResponse{
                Continue:   true,
                Extensions: request.Extensions,
        }, nil</span>
}

func (r Sink) CreateResources(triggerNS, sa string, res []json.RawMessage, triggerName, eventID string, log *zap.SugaredLogger) error <span class="cov8" title="1">{
        discoveryClient := r.DiscoveryClient
        dynamicClient := r.DynamicClient
        var err error
        if len(sa) &gt; 0 </span><span class="cov0" title="0">{
                // So at start up the discovery and dynamic clients are created using the in cluster config
                // of this pod (i.e. using the credentials of the serviceaccount associated with the EventListener)

                // However, we also have a ServiceAccountName reference with each EventListenerTrigger to allow
                // for more fine grained authorization control around the resources we create below.
                discoveryClient, dynamicClient, err = r.Auth.OverrideAuthentication(sa, triggerNS, log, r.DiscoveryClient, r.DynamicClient)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("problem cloning rest config: %#v", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, rr := range res </span><span class="cov8" title="1">{
                if err := resources.Create(r.Logger, rr, triggerName, eventID, r.EventListenerName, triggerNS, discoveryClient, dynamicClient); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("problem creating obj: %#v", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// extendBodyWithExtensions merges the extensions into the given body.
func extendBodyWithExtensions(body []byte, extensions map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        for k, v := range extensions </span><span class="cov8" title="1">{
                vb, err := json.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal value to JSON: %w", err)
                }</span>
                <span class="cov8" title="1">body, err = sjson.SetRawBytes(body, "extensions."+k, vb)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to sjson extensions to body: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return body, nil</span>
}
</pre>
		
		<pre class="file" id="file218" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

func (r Sink) IsValidPayload(eventHandler http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                payload, err := io.ReadAll(request.Body)
                request.Body = io.NopCloser(bytes.NewBuffer(payload))
                if err != nil </span><span class="cov0" title="0">{
                        r.recordCountMetrics(failTag)
                        r.Logger.Errorf("Error reading event body: %s", err)
                        response.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">if r.PayloadValidation </span><span class="cov8" title="1">{
                        var event map[string]interface{}
                        if err := json.Unmarshal(payload, &amp;event); err != nil </span><span class="cov8" title="1">{
                                errMsg := fmt.Sprintf("Invalid event body format : %s", err)
                                r.recordCountMetrics(failTag)
                                r.Logger.Error(errMsg)
                                response.WriteHeader(http.StatusBadRequest)
                                response.Header().Set("Content-Type", "application/json")
                                body := Response{
                                        EventListener: r.EventListenerName,
                                        Namespace:     r.EventListenerNamespace,
                                        ErrorMessage:  errMsg,
                                }
                                if err := json.NewEncoder(response).Encode(body); err != nil </span><span class="cov0" title="0">{
                                        r.Logger.Errorf("failed to write back sink response: %v", err)
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }
                }
                <span class="cov8" title="1">eventHandler.ServeHTTP(response, request)</span>
        })
}
</pre>
		
		<pre class="file" id="file219" style="display: none">package system

import "os"

const (
        DefaultNamespace      = "tekton-pipelines"
        SystemNamespaceEnvVar = "SYSTEM_NAMESPACE"
)

// GetNamespace holds the K8s namespace where our system components run.
func GetNamespace() string <span class="cov0" title="0">{
        systemNamespace := os.Getenv(SystemNamespaceEnvVar)
        if systemNamespace == "" </span><span class="cov0" title="0">{
                return DefaultNamespace
        }</span>
        <span class="cov0" title="0">return systemNamespace</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

const (
        // OldEscapeAnnotation is used to determine whether or not a TriggerTemplate
        // should retain the old "replace quotes with backslack quote" behaviour
        // when templating in params.
        //
        // This can be removed when this functionality is no-longer needed.
        OldEscapeAnnotation = "triggers.tekton.dev/old-escape-quotes"
)

type TriggerContext struct {
        EventID string `json:"eventID"`
}

func NewTriggerContext(eventID string) TriggerContext <span class="cov8" title="1">{
        return TriggerContext{EventID: eventID}
}</span>

// ResolveParams takes given triggerbindings and produces the resulting
// resource params.
func ResolveParams(rt ResolvedTrigger, body []byte, header http.Header, extensions map[string]interface{}, triggerContext TriggerContext) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        var ttParams []triggersv1.ParamSpec
        if rt.TriggerTemplate != nil </span><span class="cov8" title="1">{
                ttParams = rt.TriggerTemplate.Spec.Params
        }</span>

        <span class="cov8" title="1">out, err := applyEventValuesToParams(rt.BindingParams, body, header, extensions, ttParams, triggerContext)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ApplyEventValuesToParams: %w", err)
        }</span>

        <span class="cov8" title="1">return out, nil</span>
}

// ResolveResources resolves a templated resource by replacing params with their values.
func ResolveResources(template *triggersv1.TriggerTemplate, params []triggersv1.Param) []json.RawMessage <span class="cov8" title="1">{
        resources := make([]json.RawMessage, len(template.Spec.ResourceTemplates))
        uid := UUID()

        oldEscape := metav1.HasAnnotation(template.ObjectMeta, OldEscapeAnnotation)

        for i := range template.Spec.ResourceTemplates </span><span class="cov8" title="1">{
                resources[i] = applyParamsToResourceTemplate(params, template.Spec.ResourceTemplates[i].RawExtension.Raw, oldEscape)
                resources[i] = applyUIDToResourceTemplate(resources[i], uid)
        }</span>
        <span class="cov8" title="1">return resources</span>
}

// event represents a HTTP event that Triggers processes
type event struct {
        Header     map[string]string      `json:"header"`
        Body       interface{}            `json:"body"`
        Extensions map[string]interface{} `json:"extensions"`
        Context    TriggerContext         `json:"context"`
}

// newEvent returns a new Event from HTTP headers and body
func newEvent(body []byte, headers http.Header, extensions map[string]interface{}, triggerContext TriggerContext) (*event, error) <span class="cov8" title="1">{
        var data interface{}
        if len(body) &gt; 0 </span><span class="cov8" title="1">{
                if err := json.Unmarshal(body, &amp;data); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal request body: %w", err)
                }</span>
        }
        <span class="cov8" title="1">joinedHeaders := make(map[string]string, len(headers))
        for k, v := range headers </span><span class="cov8" title="1">{
                joinedHeaders[k] = strings.Join(v, ",")
        }</span>

        <span class="cov8" title="1">return &amp;event{
                Header:     joinedHeaders,
                Body:       data,
                Extensions: extensions,
                Context:    triggerContext,
        }, nil</span>
}

// applyEventValuesToParams returns a slice of Params with the JSONPath variables replaced
// with values from the event body, headers, and extensions.
func applyEventValuesToParams(params []triggersv1.Param, body []byte, header http.Header, extensions map[string]interface{},
        defaults []triggersv1.ParamSpec,
        triggerContext TriggerContext) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        event, err := newEvent(body, header, extensions, triggerContext)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        <span class="cov8" title="1">allParamsMap := map[string]string{}
        for _, paramSpec := range defaults </span><span class="cov8" title="1">{
                if paramSpec.Default != nil </span><span class="cov8" title="1">{
                        allParamsMap[paramSpec.Name] = *paramSpec.Default
                }</span>
        }

        <span class="cov8" title="1">for _, p := range params </span><span class="cov8" title="1">{
                pValue := p.Value
                // Find all expressions wrapped in $() from the value
                expressions, originals := findTektonExpressions(pValue)
                for i, expr := range expressions </span><span class="cov8" title="1">{
                        val, err := parseJSONPath(event, expr)
                        if defaults != nil &amp;&amp; err != nil </span><span class="cov8" title="1">{
                                // if the header or body was not supplied or was malformed, go with a default if it exists
                                v, ok := allParamsMap[p.Name]
                                if ok </span><span class="cov8" title="1">{
                                        val = v
                                        err = nil
                                }</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to replace JSONPath value for param %s: %s: %w", p.Name, p.Value, err)
                        }</span>
                        <span class="cov8" title="1">pValue = strings.ReplaceAll(pValue, originals[i], val)</span>
                }
                <span class="cov8" title="1">allParamsMap[p.Name] = pValue</span>
        }
        <span class="cov8" title="1">return convertParamMapToArray(allParamsMap), nil</span>
}
</pre>
		
		<pre class="file" id="file221" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/textproto"
        "reflect"
        "regexp"
        "strings"

        "k8s.io/client-go/util/jsonpath"
)

var (
        // tektonVar captures strings that are enclosed in $()
        tektonVar = regexp.MustCompile(`\$\(?([^\)]+)\)`)

        // jsonRegexp is a regular expression for JSONPath expressions
        // with or without the enclosing {} and the leading . inside the curly
        // braces e.g.  'a.b' or '.a.b' or '{a.b}' or '{.a.b}'
        jsonRegexp = regexp.MustCompile(`^\{\.?([^{}]+)\}$|^\.?([^{}]+)$`)
)

// parseJSONPath extracts a subset of the given JSON input
// using the provided JSONPath expression.
func parseJSONPath(input interface{}, expr string) (string, error) <span class="cov8" title="1">{
        j := jsonpath.New("").AllowMissingKeys(false)
        buf := new(bytes.Buffer)

        // First turn the expression into fully valid JSONPath
        expr, err := tektonJSONPathExpression(expr)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if err := j.Parse(expr); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">fullResults, err := j.FindResults(input)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, r := range fullResults </span><span class="cov8" title="1">{
                if err := printResults(buf, r); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov8" title="1">return buf.String(), nil</span>
}

// PrintResults writes the results into writer
func printResults(wr io.Writer, values []reflect.Value) error <span class="cov8" title="1">{
        results, err := getResults(values)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting values for jsonpath results: %w", err)
        }</span>

        <span class="cov8" title="1">if _, err := wr.Write(results); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getResults(values []reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        if len(values) == 1 </span><span class="cov8" title="1">{
                v := values[0]
                t := reflect.TypeOf(v.Interface())
                switch </span>{
                case t == nil:<span class="cov8" title="1">
                        return []byte("null"), nil</span>
                case t.Kind() == reflect.String:<span class="cov8" title="1">
                        b, err := json.Marshal(v.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unable to marshal string value %v: %w", v, err)
                        }</span>
                        // A valid json string is surrounded by quotation marks; we are using this function to
                        // create a representation of the json value that can be embedded in a CRD definition and
                        // we want to leave it up to the user if they want the surrounding quotation marks or not.
                        <span class="cov8" title="1">return b[1 : len(b)-1], nil</span>
                default:<span class="cov8" title="1">
                        return json.Marshal(v.Interface())</span>
                }
        }

        // More than one result - we need to return a JSON array response
        <span class="cov8" title="1">results := []interface{}{}
        for _, r := range values </span><span class="cov8" title="1">{
                t := reflect.TypeOf(r.Interface())
                if t == nil </span><span class="cov8" title="1">{
                        results = append(results, nil)
                }</span> else<span class="cov8" title="1"> {
                        // No special case for string here unlike above since its going to be part of a JSON array
                        results = append(results, r.Interface())
                }</span>
        }
        <span class="cov8" title="1">return json.Marshal(results)</span>
}

// tektonJSONPathExpression returns a valid JSONPath expression. It accepts
// a "RelaxedJSONPath" expression that is wrapped in the Tekton variable
// interpolation syntax i.e. $(). RelaxedJSONPath expressions can optionally
// omit the leading curly braces '{}' and '.'
func tektonJSONPathExpression(expr string) (string, error) <span class="cov8" title="1">{
        if !isTektonExpr(expr) </span><span class="cov8" title="1">{
                return "", errors.New("expression not wrapped in $()")
        }</span>
        <span class="cov8" title="1">unwrapped := strings.TrimSuffix(strings.TrimPrefix(expr, "$("), ")")
        return relaxedJSONPathExpression(unwrapped)</span>
}

// RelaxedJSONPathExpression attempts to be flexible with JSONPath expressions, it accepts:
//   - metadata.name (no leading '.' or curly braces '{...}'
//   - {metadata.name} (no leading '.')
//   - .metadata.name (no curly braces '{...}')
//   - {.metadata.name} (complete expression)
//
// And transforms them all into a valid jsonpath expression:
//
//        {.metadata.name}
//
// This function has been copied as-is from
// https://github.com/kubernetes/kubectl/blob/c273777957bd657233cf867892fb061a6498dab8/pkg/cmd/get/customcolumn.go#L47
func relaxedJSONPathExpression(pathExpression string) (string, error) <span class="cov8" title="1">{
        if len(pathExpression) == 0 </span><span class="cov8" title="1">{
                return pathExpression, nil
        }</span>
        <span class="cov8" title="1">submatches := jsonRegexp.FindStringSubmatch(pathExpression)
        if submatches == nil </span><span class="cov8" title="1">{
                return "", errors.New("unexpected path string, expected a 'name1.name2' or '.name1.name2' or '{name1.name2}' or '{.name1.name2}'")
        }</span>
        <span class="cov8" title="1">if len(submatches) != 3 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unexpected submatch list: %v", submatches)
        }</span>
        <span class="cov8" title="1">var fieldSpec string
        if len(submatches[1]) != 0 </span><span class="cov8" title="1">{
                fieldSpec = submatches[1]
        }</span> else<span class="cov8" title="1"> {
                fieldSpec = submatches[2]
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("{.%s}", fieldSpec), nil</span>
}

// IsTektonExpr returns true if the expr is wrapped in $()
func isTektonExpr(expr string) bool <span class="cov8" title="1">{
        return tektonVar.MatchString(expr)
}</span>

// findTektonExpressions searches for and returns a slice of
// all substrings that are wrapped in $()
// substring with "header." is converted with CanonicalMIMEHeaderKey in the first array
// the second array has the original substrings
func findTektonExpressions(in string) ([]string, []string) <span class="cov8" title="1">{
        results := []string{}
        originals := []string{}

        // No expressions to return
        if !strings.Contains(in, "$(") </span><span class="cov8" title="1">{
                return results, originals
        }</span>
        // Splits string on $( to find potential Tekton expressions
        <span class="cov8" title="1">maybeExpressions := strings.Split(in, "$(")
        for _, e := range maybeExpressions[1:] </span><span class="cov8" title="1">{ // Split always returns at least one element
                // Iterate until we find the first unbalanced )
                numOpenBrackets := 0
                for i, ch := range e </span><span class="cov8" title="1">{
                        switch ch </span>{
                        case '(':<span class="cov8" title="1">
                                numOpenBrackets++</span>
                        case ')':<span class="cov8" title="1">
                                numOpenBrackets--
                                if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                        raw := e[:i]
                                        originals = append(originals, fmt.Sprintf("$(%s)", raw))
                                        if strings.Index(raw, "header.") == 0 </span><span class="cov8" title="1">{
                                                raw = "header." + textproto.CanonicalMIMEHeaderKey(raw[len("header."):])
                                        }</span>
                                        <span class="cov8" title="1">results = append(results, fmt.Sprintf("$(%s)", raw))</span>
                                }
                        default:<span class="cov8" title="1">
                                continue</span>
                        }
                        <span class="cov8" title="1">if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return results, originals</span>
}
</pre>
		
		<pre class="file" id="file222" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "bytes"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/google/uuid"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// uidMatch determines the uid variable within the resource template
var uidMatch = []byte(`$(uid)`)

// ResolvedTrigger contains the dereferenced TriggerBindings and
// TriggerTemplate after resolving the k8s ObjectRef.
type ResolvedTrigger struct {
        TriggerBindings        []*triggersv1.TriggerBinding
        ClusterTriggerBindings []*triggersv1.ClusterTriggerBinding
        TriggerTemplate        *triggersv1.TriggerTemplate
        BindingParams          []triggersv1.Param
}

type getTriggerBinding func(name string) (*triggersv1.TriggerBinding, error)
type getTriggerTemplate func(name string) (*triggersv1.TriggerTemplate, error)
type getClusterTriggerBinding func(name string) (*triggersv1.ClusterTriggerBinding, error)

// ResolveTrigger takes in a trigger containing object refs to bindings and
// templates and resolves them to their underlying values.
func ResolveTrigger(trigger triggersv1.Trigger, getTB getTriggerBinding, getCTB getClusterTriggerBinding, getTT getTriggerTemplate) (ResolvedTrigger, error) <span class="cov8" title="1">{
        bp, err := resolveBindingsToParams(trigger.Spec.Bindings, getTB, getCTB)
        if err != nil </span><span class="cov8" title="1">{
                return ResolvedTrigger{}, fmt.Errorf("failed to resolve bindings: %w", err)
        }</span>

        <span class="cov8" title="1">var resolvedTT *triggersv1.TriggerTemplate
        if trigger.Spec.Template.Spec != nil </span><span class="cov8" title="1">{
                resolvedTT = &amp;triggersv1.TriggerTemplate{
                        ObjectMeta: metav1.ObjectMeta{}, // Unused. TODO: Just return Specs from here.
                        Spec:       *trigger.Spec.Template.Spec,
                }
        }</span> else<span class="cov8" title="1"> {
                var ttName string
                if trigger.Spec.Template.Ref != nil </span><span class="cov8" title="1">{
                        ttName = *trigger.Spec.Template.Ref
                }</span>
                <span class="cov8" title="1">resolvedTT, err = getTT(ttName)
                if err != nil </span><span class="cov8" title="1">{
                        return ResolvedTrigger{}, fmt.Errorf("error getting TriggerTemplate %s: %w", ttName, err)
                }</span>
        }

        <span class="cov8" title="1">return ResolvedTrigger{TriggerTemplate: resolvedTT, BindingParams: bp}, nil</span>
}

// resolveBindingsToParams takes in both embedded bindings and references and returns a list of resolved Param values.ResolveBindingsToParams
func resolveBindingsToParams(bindings []*triggersv1.TriggerSpecBinding, getTB getTriggerBinding, getCTB getClusterTriggerBinding) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        bindingParams := []triggersv1.Param{}
        for _, b := range bindings </span><span class="cov8" title="1">{
                switch </span>{
                case b.Name != "" &amp;&amp; b.Value != nil:<span class="cov8" title="1">
                        bindingParams = append(bindingParams, triggersv1.Param{
                                Name:  b.Name,
                                Value: *b.Value,
                        })</span>

                case b.Ref != "" &amp;&amp; b.Kind == triggersv1.ClusterTriggerBindingKind:<span class="cov8" title="1">
                        ctb, err := getCTB(b.Ref)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error getting ClusterTriggerBinding %s: %w", b.Name, err)
                        }</span>
                        <span class="cov8" title="1">bindingParams = append(bindingParams, ctb.Spec.Params...)</span>

                case b.Ref != "":<span class="cov8" title="1"> // if no kind is set, assume NamespacedTriggerBinding
                        tb, err := getTB(b.Ref)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error getting TriggerBinding %s: %w", b.Name, err)
                        }</span>
                        <span class="cov8" title="1">bindingParams = append(bindingParams, tb.Spec.Params...)</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("invalid binding: %v", b)</span>
                }
        }

        // Check for duplicate params
        <span class="cov8" title="1">seen := make(map[string]bool, len(bindingParams))
        for _, p := range bindingParams </span><span class="cov8" title="1">{
                if seen[p.Name] </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("duplicate param name: %s", p.Name)
                }</span>
                <span class="cov8" title="1">seen[p.Name] = true</span>
        }
        <span class="cov8" title="1">return bindingParams, nil</span>
}

// applyParamsToResourceTemplate returns the TriggerResourceTemplate with the
// param values substituted for all matching param variables in the template
func applyParamsToResourceTemplate(params []triggersv1.Param, rt json.RawMessage, oldEscape bool) json.RawMessage <span class="cov8" title="1">{
        // Assume the params are valid
        for _, param := range params </span><span class="cov8" title="1">{
                rt = applyParamToResourceTemplate(param, rt, oldEscape)
        }</span>
        <span class="cov8" title="1">return rt</span>
}

// applyParamToResourceTemplate returns the TriggerResourceTemplate with the
// param value substituted for all matching param variables in the template
func applyParamToResourceTemplate(param triggersv1.Param, rt json.RawMessage, oldEscape bool) json.RawMessage <span class="cov8" title="1">{
        // Assume the param is valid
        paramVariable := fmt.Sprintf("$(tt.params.%s)", param.Name)
        // Escape quotes so that JSON strings can be appended to regular strings.
        // See #257 for discussion on this behavior.
        if oldEscape </span><span class="cov8" title="1">{
                paramValue := strings.ReplaceAll(param.Value, `"`, `\"`)
                return bytes.ReplaceAll(rt, []byte(paramVariable), []byte(paramValue))
        }</span>
        <span class="cov8" title="1">return bytes.ReplaceAll(rt, []byte(paramVariable), []byte(param.Value))</span>
}

// UUID generates a Universally Unique IDentifier following RFC 4122.
var UUID = func() string <span class="cov8" title="1">{ return uuid.New().String() }</span>

// applyUIDToResourceTemplate returns the TriggerResourceTemplate after uid replacement
// The same uid should be used per trigger to properly address resources throughout the TriggerTemplate.
func applyUIDToResourceTemplate(rt json.RawMessage, uid string) json.RawMessage <span class="cov8" title="1">{
        return bytes.ReplaceAll(rt, uidMatch, []byte(uid))
}</span>

func convertParamMapToArray(paramMap map[string]string) []triggersv1.Param <span class="cov8" title="1">{
        params := []triggersv1.Param{}
        for name, value := range paramMap </span><span class="cov8" title="1">{
                params = append(params, triggersv1.Param{Name: name, Value: value})
        }</span>
        <span class="cov8" title="1">return params</span>
}

// mergeBindingParams merges params across multiple bindings.
func mergeBindingParams(bindings []*triggersv1.TriggerBinding, clusterbindings []*triggersv1.ClusterTriggerBinding) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        params := []triggersv1.Param{}
        for _, b := range bindings </span><span class="cov8" title="1">{
                params = append(params, b.Spec.Params...)
        }</span>
        <span class="cov8" title="1">for _, cb := range clusterbindings </span><span class="cov8" title="1">{
                params = append(params, cb.Spec.Params...)
        }</span>
        <span class="cov8" title="1">seen := make(map[string]bool, len(params))
        for _, p := range params </span><span class="cov8" title="1">{
                if seen[p.Name] </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("duplicate param name: %s", p.Name)
                }</span>
                <span class="cov8" title="1">seen[p.Name] = true</span>
        }
        <span class="cov8" title="1">return params, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
