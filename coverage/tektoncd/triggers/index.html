
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>webhook-interceptors: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/tektoncd/triggers/examples/v1alpha1/webhook-interceptors/main.go (0.0%)</option>
				
				<option value="file1">github.com/tektoncd/triggers/pkg/adapter/adapter.go (24.1%)</option>
				
				<option value="file2">github.com/tektoncd/triggers/pkg/apis/config/default.go (87.8%)</option>
				
				<option value="file3">github.com/tektoncd/triggers/pkg/apis/config/feature_flags.go (100.0%)</option>
				
				<option value="file4">github.com/tektoncd/triggers/pkg/apis/config/store.go (95.0%)</option>
				
				<option value="file5">github.com/tektoncd/triggers/pkg/apis/triggers/contexts/contexts.go (0.0%)</option>
				
				<option value="file6">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_interceptor_defaults.go (0.0%)</option>
				
				<option value="file7">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_interceptor_types.go (100.0%)</option>
				
				<option value="file8">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_interceptor_validation.go (100.0%)</option>
				
				<option value="file9">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file10">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_trigger_binding_types.go (0.0%)</option>
				
				<option value="file11">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/cluster_trigger_binding_validation.go (80.0%)</option>
				
				<option value="file12">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/event_listener_defaults.go (87.5%)</option>
				
				<option value="file13">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/event_listener_types.go (81.2%)</option>
				
				<option value="file14">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/event_listener_validation.go (97.2%)</option>
				
				<option value="file15">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/interceptor_defaults.go (0.0%)</option>
				
				<option value="file16">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/interceptor_types.go (90.9%)</option>
				
				<option value="file17">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/interceptor_validation.go (100.0%)</option>
				
				<option value="file18">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/register.go (60.0%)</option>
				
				<option value="file19">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file20">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_binding_types.go (0.0%)</option>
				
				<option value="file21">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_binding_validation.go (100.0%)</option>
				
				<option value="file22">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_defaults.go (83.3%)</option>
				
				<option value="file23">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_template_defaults.go (0.0%)</option>
				
				<option value="file24">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_template_validation.go (100.0%)</option>
				
				<option value="file25">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_types.go (77.6%)</option>
				
				<option value="file26">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_types_convert.go (71.4%)</option>
				
				<option value="file27">github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1/trigger_validation.go (94.3%)</option>
				
				<option value="file28">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/cluster_trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file29">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/cluster_trigger_binding_types.go (0.0%)</option>
				
				<option value="file30">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/cluster_trigger_binding_validation.go (50.0%)</option>
				
				<option value="file31">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/event_listener_defaults.go (100.0%)</option>
				
				<option value="file32">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/event_listener_types.go (81.2%)</option>
				
				<option value="file33">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/event_listener_validation.go (97.4%)</option>
				
				<option value="file34">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/interceptor_types.go (66.7%)</option>
				
				<option value="file35">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/register.go (60.0%)</option>
				
				<option value="file36">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_binding_defaults.go (0.0%)</option>
				
				<option value="file37">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_binding_types.go (0.0%)</option>
				
				<option value="file38">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_binding_validation.go (97.1%)</option>
				
				<option value="file39">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_defaults.go (100.0%)</option>
				
				<option value="file40">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_template_defaults.go (0.0%)</option>
				
				<option value="file41">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_template_validation.go (96.6%)</option>
				
				<option value="file42">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_types.go (100.0%)</option>
				
				<option value="file43">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_types_convert.go (71.4%)</option>
				
				<option value="file44">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/trigger_validation.go (94.0%)</option>
				
				<option value="file45">github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1/version_validation.go (100.0%)</option>
				
				<option value="file46">github.com/tektoncd/triggers/pkg/apis/triggers/validation.go (100.0%)</option>
				
				<option value="file47">github.com/tektoncd/triggers/pkg/bootstrap/bootstrap.go (0.0%)</option>
				
				<option value="file48">github.com/tektoncd/triggers/pkg/bootstrap/file_helper.go (0.0%)</option>
				
				<option value="file49">github.com/tektoncd/triggers/pkg/bootstrap/github.go (5.3%)</option>
				
				<option value="file50">github.com/tektoncd/triggers/pkg/bootstrap/installer.go (17.5%)</option>
				
				<option value="file51">github.com/tektoncd/triggers/pkg/bootstrap/rbac.go (0.0%)</option>
				
				<option value="file52">github.com/tektoncd/triggers/pkg/bootstrap/templates.go (0.0%)</option>
				
				<option value="file53">github.com/tektoncd/triggers/pkg/dynamic/custom_reconcile.go (86.7%)</option>
				
				<option value="file54">github.com/tektoncd/triggers/pkg/dynamic/dynamic.go (0.0%)</option>
				
				<option value="file55">github.com/tektoncd/triggers/pkg/interceptors/bitbucket/bitbucket.go (89.7%)</option>
				
				<option value="file56">github.com/tektoncd/triggers/pkg/interceptors/cel/cel.go (88.2%)</option>
				
				<option value="file57">github.com/tektoncd/triggers/pkg/interceptors/cel/triggers.go (88.2%)</option>
				
				<option value="file58">github.com/tektoncd/triggers/pkg/interceptors/github/github.go (92.6%)</option>
				
				<option value="file59">github.com/tektoncd/triggers/pkg/interceptors/gitlab/gitlab.go (89.7%)</option>
				
				<option value="file60">github.com/tektoncd/triggers/pkg/interceptors/interceptors.go (89.4%)</option>
				
				<option value="file61">github.com/tektoncd/triggers/pkg/interceptors/secret_getter.go (84.6%)</option>
				
				<option value="file62">github.com/tektoncd/triggers/pkg/interceptors/slack/slack.go (80.0%)</option>
				
				<option value="file63">github.com/tektoncd/triggers/pkg/interceptors/webhook/webhook.go (90.0%)</option>
				
				<option value="file64">github.com/tektoncd/triggers/pkg/observability/attributekey/key.go (92.3%)</option>
				
				<option value="file65">github.com/tektoncd/triggers/pkg/observability/config.go (80.0%)</option>
				
				<option value="file66">github.com/tektoncd/triggers/pkg/observability/configmap/parse.go (100.0%)</option>
				
				<option value="file67">github.com/tektoncd/triggers/pkg/observability/metrics/config.go (0.0%)</option>
				
				<option value="file68">github.com/tektoncd/triggers/pkg/observability/metrics/provider.go (0.0%)</option>
				
				<option value="file69">github.com/tektoncd/triggers/pkg/observability/resource/default.go (100.0%)</option>
				
				<option value="file70">github.com/tektoncd/triggers/pkg/observability/runtime/config.go (0.0%)</option>
				
				<option value="file71">github.com/tektoncd/triggers/pkg/observability/tracing/config.go (0.0%)</option>
				
				<option value="file72">github.com/tektoncd/triggers/pkg/reconciler/clusterinterceptor/clusterinterceptor.go (90.9%)</option>
				
				<option value="file73">github.com/tektoncd/triggers/pkg/reconciler/clusterinterceptor/controller.go (0.0%)</option>
				
				<option value="file74">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/controller.go (85.7%)</option>
				
				<option value="file75">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/eventlistener.go (71.5%)</option>
				
				<option value="file76">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/config.go (100.0%)</option>
				
				<option value="file77">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/container.go (100.0%)</option>
				
				<option value="file78">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/custom.go (94.1%)</option>
				
				<option value="file79">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/deployment.go (98.6%)</option>
				
				<option value="file80">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/meta.go (100.0%)</option>
				
				<option value="file81">github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources/service.go (100.0%)</option>
				
				<option value="file82">github.com/tektoncd/triggers/pkg/reconciler/events/event.go (66.7%)</option>
				
				<option value="file83">github.com/tektoncd/triggers/pkg/reconciler/interceptor/controller.go (0.0%)</option>
				
				<option value="file84">github.com/tektoncd/triggers/pkg/reconciler/interceptor/interceptor.go (90.9%)</option>
				
				<option value="file85">github.com/tektoncd/triggers/pkg/reconciler/metrics/injection.go (44.4%)</option>
				
				<option value="file86">github.com/tektoncd/triggers/pkg/reconciler/metrics/metrics.go (76.6%)</option>
				
				<option value="file87">github.com/tektoncd/triggers/pkg/resources/create.go (81.2%)</option>
				
				<option value="file88">github.com/tektoncd/triggers/pkg/sink/auth_override.go (0.0%)</option>
				
				<option value="file89">github.com/tektoncd/triggers/pkg/sink/cloudevent/cloudevent.go (73.3%)</option>
				
				<option value="file90">github.com/tektoncd/triggers/pkg/sink/cloudevent/cloudeventclient.go (5.9%)</option>
				
				<option value="file91">github.com/tektoncd/triggers/pkg/sink/initialization.go (50.0%)</option>
				
				<option value="file92">github.com/tektoncd/triggers/pkg/sink/metrics.go (77.1%)</option>
				
				<option value="file93">github.com/tektoncd/triggers/pkg/sink/sink.go (71.6%)</option>
				
				<option value="file94">github.com/tektoncd/triggers/pkg/sink/validate_payload.go (76.2%)</option>
				
				<option value="file95">github.com/tektoncd/triggers/pkg/system/system.go (0.0%)</option>
				
				<option value="file96">github.com/tektoncd/triggers/pkg/template/event.go (100.0%)</option>
				
				<option value="file97">github.com/tektoncd/triggers/pkg/template/jsonpath.go (93.3%)</option>
				
				<option value="file98">github.com/tektoncd/triggers/pkg/template/resource.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 Copyright 2019 The Tekton Authors

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

package main

import (
        "fmt"
        "log"
        "net/http"
        "os"

        "github.com/google/go-github/v31/github"
)

const (
        // Environment variable containing GitHub secret token
        envSecret = "GITHUB_SECRET_TOKEN"
)

func main() <span class="cov0" title="0">{
        secretToken := os.Getenv(envSecret)
        if secretToken == "" </span><span class="cov0" title="0">{
                log.Fatalf("No secret token given")
        }</span>

        <span class="cov0" title="0">http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) </span><span class="cov0" title="0">{
                // TODO: We should probably send over the EL eventID as a X-Tekton-Event-Id header as well
                payload, err := github.ValidatePayload(request, []byte(secretToken))
                id := github.DeliveryID(request)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error handling GitHub Event with delivery ID %s : %q", id, err)
                        http.Error(writer, fmt.Sprint(err), http.StatusBadRequest)
                }</span>
                <span class="cov0" title="0">log.Printf("Handling GitHub Event with delivery ID: %s; Payload: %s", id, payload)
                n, err := writer.Write(payload)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to write response for GitHub event ID: %s. Bytes writted: %d. Error: %q", id, n, err)
                }</span>
        })

        <span class="cov0" title="0">log.Fatal(http.ListenAndServe(fmt.Sprintf(":%d", 8080), nil))</span> //nolint:gosec
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package adapter

import (
        "bytes"
        "context"
        "crypto/tls"
        "crypto/x509"
        "errors"
        "fmt"
        "net"
        "net/http"
        "sync"
        "time"

        clusterinterceptorsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        interceptorsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor"
        clustertriggerbindingsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding"
        eventlistenerinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        triggersinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger"
        triggerbindingsinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding"
        triggertemplatesinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme"
        "github.com/tektoncd/triggers/pkg/sink"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/apimachinery/pkg/watch"
        v1 "k8s.io/client-go/kubernetes/typed/core/v1"
        "k8s.io/client-go/tools/record"
        "knative.dev/eventing/pkg/adapter/v2"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection/clients/dynamicclient"
        "knative.dev/pkg/logging"
)

type envConfig struct {
        adapter.EnvConfig
}

func NewEnvConfig() adapter.EnvConfigAccessor <span class="cov0" title="0">{
        return &amp;envConfig{}
}</span>

var (
        interval = 10 * time.Second
        timeout  = 1 * time.Minute
)

// sinker implements the adapter for an event listener.
type sinker struct {
        Logger    *zap.SugaredLogger
        Namespace string

        Args     sink.Args
        Clients  sink.Clients
        Recorder *sink.Recorder

        injCtx context.Context //nolint:containedctx
}

var _ adapter.Adapter = (*sinker)(nil)

func (s *sinker) createRecorder(ctx context.Context, agentName string) record.EventRecorder <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        recorder := controller.GetEventRecorder(ctx)
        if recorder == nil </span><span class="cov0" title="0">{
                // Create event broadcaster
                logger.Debug("Creating event broadcaster")
                eventBroadcaster := record.NewBroadcaster()
                watches := []watch.Interface{
                        eventBroadcaster.StartLogging(logger.Named("event-broadcaster").Infof),
                        eventBroadcaster.StartRecordingToSink(
                                &amp;v1.EventSinkImpl{Interface: s.Clients.K8sClient.CoreV1().Events("")}),
                }

                recorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})
                go func() </span><span class="cov0" title="0">{
                        &lt;-ctx.Done()
                        for _, w := range watches </span><span class="cov0" title="0">{
                                w.Stop()
                        }</span>
                }()
        }

        <span class="cov0" title="0">return recorder</span>
}

func (s *sinker) getHTTPClient() (*http.Client, error) <span class="cov8" title="1">{
        var tlsConfig *tls.Config

        certPool := x509.NewCertPool()

        err := s.getCertFromInterceptor(certPool)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;http.Client{}, fmt.Errorf("Timed out waiting on CaBundle to available for clusterInterceptor: %w", err)
        }</span>

        // running go routine here to add/update certPool if there is new or change in caCert bundle.
        // caCert changes if certs expired, if someone adds new ClusterInterceptor with caBundle
        <span class="cov0" title="0">ticker := time.NewTicker(time.Minute)
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        &lt;-ticker.C
                        if err := s.getCertFromInterceptor(certPool); err != nil </span><span class="cov0" title="0">{
                                s.Logger.Fatalf("Timed out waiting on CaBundle to available for clusterInterceptor: %v", err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">tlsConfig = &amp;tls.Config{
                RootCAs:    certPool,
                MinVersion: tls.VersionTLS12, // Added MinVersion to avoid  G402: TLS MinVersion too low. (gosec)
        }
        return &amp;http.Client{
                Transport: &amp;http.Transport{
                        TLSClientConfig: tlsConfig,
                        Dial: (&amp;net.Dialer{
                                Timeout:   s.Args.ElHTTPClientReadTimeOut * time.Second, //nolint:durationcheck
                                KeepAlive: s.Args.ElHTTPClientKeepAlive * time.Second,   //nolint:durationcheck
                        }).Dial,
                        TLSHandshakeTimeout:   s.Args.ElHTTPClientTLSHandshakeTimeout * time.Second,         //nolint:durationcheck
                        ResponseHeaderTimeout: s.Args.ElHTTPClientResponseHeaderTimeout * time.Second,       //nolint:durationcheck
                        ExpectContinueTimeout: s.Args.ElHTTPClientExpectContinueTimeout * time.Second}}, nil</span> //nolint:durationcheck
}

func (s *sinker) getCertFromInterceptor(certPool *x509.CertPool) error <span class="cov8" title="1">{
        var (
                caCert     []byte
                count      int
                httpsCILen int
        )
        ctx := context.Background()
        if err := wait.PollUntilContextTimeout(ctx, interval, timeout, true, func(_ context.Context) (bool, error) </span><span class="cov8" title="1">{
                clusterInterceptorList, err := clusterinterceptorsinformer.Get(s.injCtx).Lister().List(labels.NewSelector()) //nolint:contextcheck
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">for i := range clusterInterceptorList </span><span class="cov8" title="1">{
                        if v, k := clusterInterceptorList[i].Labels["server/type"]; k &amp;&amp; v == "https" </span><span class="cov8" title="1">{
                                httpsCILen++
                                if !bytes.Equal(clusterInterceptorList[i].Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov8" title="1">{
                                        caCert = clusterInterceptorList[i].Spec.ClientConfig.CaBundle
                                        if ok := certPool.AppendCertsFromPEM(caCert); !ok </span><span class="cov8" title="1">{
                                                return false, fmt.Errorf("unable to parse cert from %s", caCert)
                                        }</span>
                                        <span class="cov0" title="0">count++</span>
                                }
                        }
                }

                <span class="cov8" title="1">if httpsCILen == 0 || httpsCILen != count </span><span class="cov8" title="1">{
                        return false, errors.New("empty caBundle in clusterInterceptor spec")
                }</span>

                <span class="cov0" title="0">httpsCILen = 0
                count = 0

                interceptorList, err := interceptorsinformer.Get(s.injCtx).Lister().Interceptors(s.Namespace).List(labels.Everything()) //nolint:contextcheck
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">for i := range interceptorList </span><span class="cov0" title="0">{
                        if v, k := interceptorList[i].Labels["server/type"]; k &amp;&amp; v == "https" </span><span class="cov0" title="0">{
                                httpsCILen++
                                if !bytes.Equal(interceptorList[i].Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov0" title="0">{
                                        caCert = interceptorList[i].Spec.ClientConfig.CaBundle
                                        if ok := certPool.AppendCertsFromPEM(caCert); !ok </span><span class="cov0" title="0">{
                                                return false, fmt.Errorf("unable to parse cert from %s", caCert)
                                        }</span>
                                        <span class="cov0" title="0">count++</span>
                                }
                        }
                }
                <span class="cov0" title="0">if httpsCILen != count </span><span class="cov0" title="0">{
                        return false, errors.New("empty caBundle in interceptor spec")
                }</span>

                <span class="cov0" title="0">return true, nil</span>
        }); err != nil <span class="cov8" title="1">{
                return fmt.Errorf("Timed out waiting on CaBundle to available for Interceptor: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *sinker) Start(ctx context.Context) error <span class="cov0" title="0">{
        clientObj, err := s.getHTTPClient()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Create EventListener Sink

        <span class="cov0" title="0">dynamicClient := dynamicclient.Get(ctx)

        r := sink.Sink{
                KubeClientSet:          kubeclient.Get(ctx),
                DiscoveryClient:        s.Clients.DiscoveryClient,
                DynamicClient:          dynamicClient,
                TriggersClient:         s.Clients.TriggersClient,
                HTTPClient:             clientObj,
                CEClient:               s.Clients.CEClient,
                EventListenerName:      s.Args.ElName,
                EventListenerNamespace: s.Args.ElNamespace,
                PayloadValidation:      s.Args.PayloadValidation,
                Logger:                 s.Logger,
                Recorder:               s.Recorder,
                CloudEventURI:          s.Args.CloudEventURI,
                Auth:                   sink.DefaultAuthOverride{},
                WGProcessTriggers:      &amp;sync.WaitGroup{},
                EventRecorder:          s.createRecorder(s.injCtx, "EventListener"), //nolint:contextcheck

                // Register all the listers we'll need
                EventListenerLister:         eventlistenerinformer.Get(s.injCtx).Lister(),          //nolint:contextcheck
                TriggerLister:               triggersinformer.Get(s.injCtx).Lister(),               //nolint:contextcheck
                TriggerBindingLister:        triggerbindingsinformer.Get(s.injCtx).Lister(),        //nolint:contextcheck
                ClusterTriggerBindingLister: clustertriggerbindingsinformer.Get(s.injCtx).Lister(), //nolint:contextcheck
                TriggerTemplateLister:       triggertemplatesinformer.Get(s.injCtx).Lister(),       //nolint:contextcheck
                ClusterInterceptorLister:    clusterinterceptorsinformer.Get(s.injCtx).Lister(),    //nolint:contextcheck
                InterceptorLister:           interceptorsinformer.Get(s.injCtx).Lister(),           //nolint:contextcheck
        }

        mux := http.NewServeMux()
        eventHandler := http.HandlerFunc(r.HandleEvent)
        metricsRecorder := &amp;sink.MetricsHandler{Handler: r.IsValidPayload(eventHandler)}

        mux.HandleFunc("/", metricsRecorder.Intercept(r.NewMetricsRecorderInterceptor()))

        // For handling Liveness Probe
        // TODO(dibyom): Livness, metrics etc. should be on a separate port
        mux.HandleFunc("/live", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                fmt.Fprint(w, "ok")
        }</span>)

        <span class="cov0" title="0">srv := &amp;http.Server{
                Addr:              ":" + s.Args.Port,
                ReadHeaderTimeout: s.Args.ELReadTimeOut * time.Second,  //nolint:durationcheck
                ReadTimeout:       s.Args.ELReadTimeOut * time.Second,  //nolint:durationcheck
                WriteTimeout:      s.Args.ELWriteTimeOut * time.Second, //nolint:durationcheck
                IdleTimeout:       s.Args.ELIdleTimeOut * time.Second,  //nolint:durationcheck
                Handler: http.TimeoutHandler(mux,
                        s.Args.ELTimeOutHandler*time.Second, "EventListener Timeout!\n"), //nolint:durationcheck
        }

        if s.Args.Cert == "" &amp;&amp; s.Args.Key == "" </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov0" title="0"> {
                if err := srv.ListenAndServeTLS(s.Args.Cert, s.Args.Key); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func New(sinkArgs sink.Args, sinkClients sink.Clients, recorder *sink.Recorder) adapter.AdapterConstructor <span class="cov0" title="0">{
        return func(ctx context.Context, processed adapter.EnvConfigAccessor, _ cloudevents.Client) adapter.Adapter </span><span class="cov0" title="0">{
                env := processed.(*envConfig)
                logger := logging.FromContext(ctx)

                return &amp;sinker{
                        Logger:    logger,
                        Namespace: env.Namespace,
                        Args:      sinkArgs,
                        Clients:   sinkClients,
                        Recorder:  recorder,
                        injCtx:    ctx,
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "strconv"

        corev1 "k8s.io/api/core/v1"
)

const (
        defaultServiceAccountKey   = "default-service-account"
        DefaultRunAsUserKey        = "default-run-as-user"
        DefaultRunAsGroupKey       = "default-run-as-group"
        DefaultFSGroupKey          = "default-fs-group"
        defaultRunAsNonRootKey     = "default-run-as-non-root"
        DefaultServiceAccountValue = "default"
        defaultRunAsUserValue      = 65532
        defaultRunAsGroupValue     = 65532
        defaultFsGroupValue        = 65532
        defaultRunAsNonRootValue   = true
)

// Defaults holds the default configurations
// +k8s:deepcopy-gen=true
type Defaults struct {
        DefaultServiceAccount string
        DefaultRunAsUser      int64
        DefaultRunAsGroup     int64
        DefaultFSGroup        int64
        DefaultRunAsNonRoot   bool
        // These three fields are used to decide whether to configure
        // runAsUser, runAsGroup and fsGroup within a Security Context Constraint (SCC).
        IsDefaultRunAsUserEmpty  bool
        IsDefaultRunAsGroupEmpty bool
        IsDefaultFsGroupEmpty    bool
}

// GetDefaultsConfigName returns the name of the configmap containing all
// defined defaults.
func GetDefaultsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_DEFAULTS_NAME"); e != "" </span><span class="cov0" title="0">{
                return e
        }</span>
        <span class="cov8" title="1">return "config-defaults-triggers"</span>
}

// Equals returns true if two Configs are identical
func (cfg *Defaults) Equals(other *Defaults) bool <span class="cov8" title="1">{
        if cfg == nil &amp;&amp; other == nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if cfg == nil || other == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return other.DefaultServiceAccount == cfg.DefaultServiceAccount &amp;&amp;
                other.DefaultRunAsUser == cfg.DefaultRunAsUser &amp;&amp;
                other.DefaultRunAsGroup == cfg.DefaultRunAsGroup &amp;&amp;
                other.DefaultFSGroup == cfg.DefaultFSGroup &amp;&amp;
                other.DefaultRunAsNonRoot == cfg.DefaultRunAsNonRoot</span>
}

// NewDefaultsFromMap returns a Config given a map corresponding to a ConfigMap
func NewDefaultsFromMap(cfgMap map[string]string) (*Defaults, error) <span class="cov8" title="1">{
        tc := Defaults{
                DefaultServiceAccount: DefaultServiceAccountValue,
                DefaultRunAsUser:      defaultRunAsUserValue,
                DefaultRunAsGroup:     defaultRunAsGroupValue,
                DefaultFSGroup:        defaultFsGroupValue,
                DefaultRunAsNonRoot:   defaultRunAsNonRootValue,
        }

        if defaultServiceAccount, ok := cfgMap[defaultServiceAccountKey]; ok </span><span class="cov8" title="1">{
                tc.DefaultServiceAccount = defaultServiceAccount
        }</span>

        <span class="cov8" title="1">if defaultRunAsUser, ok := cfgMap[DefaultRunAsUserKey]; ok </span><span class="cov8" title="1">{
                if defaultRunAsUser != "" </span><span class="cov8" title="1">{
                        runAsUser, err := strconv.ParseInt(defaultRunAsUser, 10, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing runAsUser config %q", defaultRunAsUser)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultRunAsUser = runAsUser</span>
                } else<span class="cov8" title="1"> {
                        // if runAsUser is "" don't set runAsUser in SCC
                        tc.IsDefaultRunAsUserEmpty = true
                }</span>
        }

        <span class="cov8" title="1">if defaultRunAsGroup, ok := cfgMap[DefaultRunAsGroupKey]; ok </span><span class="cov8" title="1">{
                if defaultRunAsGroup != "" </span><span class="cov8" title="1">{
                        runAsGroup, err := strconv.ParseInt(defaultRunAsGroup, 10, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing runAsGroup config %q", defaultRunAsGroup)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultRunAsGroup = runAsGroup</span>
                } else<span class="cov8" title="1"> {
                        // if runAsGroup is "" don't set runAsGroup in SCC
                        tc.IsDefaultRunAsGroupEmpty = true
                }</span>
        }

        <span class="cov8" title="1">if defaultFsGroup, ok := cfgMap[DefaultFSGroupKey]; ok </span><span class="cov8" title="1">{
                if defaultFsGroup != "" </span><span class="cov8" title="1">{
                        fsGroup, err := strconv.ParseInt(defaultFsGroup, 10, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing fsGroup config %q", defaultFsGroup)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultFSGroup = fsGroup</span>
                } else<span class="cov8" title="1"> {
                        // if fsGroup is "" don't set fsGroup in SCC
                        tc.IsDefaultFsGroupEmpty = true
                }</span>
        }

        <span class="cov8" title="1">if defaultRunAsNonRoot, ok := cfgMap[defaultRunAsNonRootKey]; ok </span><span class="cov8" title="1">{
                if defaultRunAsNonRoot != "" </span><span class="cov8" title="1">{
                        runAsNonRoot, err := strconv.ParseBool(defaultRunAsNonRoot)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed parsing runAsNonRoot config %q", defaultRunAsNonRoot)
                        }</span>
                        <span class="cov8" title="1">tc.DefaultRunAsNonRoot = runAsNonRoot</span>
                } else<span class="cov8" title="1"> {
                        // if "" value is provided via configmap set back to default value which is true
                        tc.DefaultRunAsNonRoot = defaultRunAsNonRootValue
                }</span>
        }

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// NewDefaultsFromConfigMap returns a Config for the given configmap
func NewDefaultsFromConfigMap(config *corev1.ConfigMap) (*Defaults, error) <span class="cov8" title="1">{
        return NewDefaultsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "fmt"
        "os"
        "regexp"
        "strings"

        corev1 "k8s.io/api/core/v1"
)

const (
        StableAPIFieldValue    = "stable"
        AlphaAPIFieldValue     = "alpha"
        enableAPIFieldsKey     = "enable-api-fields"
        DefaultEnableAPIFields = StableAPIFieldValue

        labelsExclusionPattern = "labels-exclusion-pattern"
)

// FeatureFlags holds the features configurations
// +k8s:deepcopy-gen=true
type FeatureFlags struct {
        // EnableAPIFields determines which gated features are enabled.
        // Acceptable values are "stable" or "alpha". Defaults to "stable"
        EnableAPIFields string
        // LabelsExclusionPattern determines the regex pattern to use to exclude
        // labels being propagated to resources created by the EventListener
        LabelsExclusionPattern string
}

// GetFeatureFlagsConfigName returns the name of the configmap containing all
// feature flags.
func GetFeatureFlagsConfigName() string <span class="cov8" title="1">{
        if e := os.Getenv("CONFIG_FEATURE_FLAGS_NAME"); e != "" </span><span class="cov8" title="1">{
                return e
        }</span>
        <span class="cov8" title="1">return "feature-flags-triggers"</span>
}

// NewFeatureFlagsFromMap returns a Config given a map corresponding to a ConfigMap
func NewFeatureFlagsFromMap(cfgMap map[string]string) (*FeatureFlags, error) <span class="cov8" title="1">{
        tc := FeatureFlags{}
        var err error
        if tc.EnableAPIFields, err = getEnabledAPI(cfgMap); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if tc.LabelsExclusionPattern, err = getLabelsExclusionPattern(cfgMap); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tc, nil</span>
}

// getLabelsExclusionPattern gets the "labels-exclusion-pattern" flag based on the content of a given map.
// If the feature gate is not defined then we ignore it, if the pattern is not
// valid regex then we return error
func getLabelsExclusionPattern(cfgMap map[string]string) (string, error) <span class="cov8" title="1">{
        if pattern, ok := cfgMap[labelsExclusionPattern]; ok </span><span class="cov8" title="1">{
                if _, err := regexp.Compile(pattern); err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("invalid value for feature flag %q: %q", labelsExclusionPattern, pattern)
                }</span>
                <span class="cov8" title="1">return pattern, nil</span>
        }

        <span class="cov8" title="1">return "", nil</span>
}

// getEnabledAPI gets the "enable-api-fields" flag based on the content of a given map.
// If the feature gate is invalid or missing then an error is returned.
func getEnabledAPI(cfgMap map[string]string) (string, error) <span class="cov8" title="1">{
        value := DefaultEnableAPIFields
        if cfg, ok := cfgMap[enableAPIFieldsKey]; ok </span><span class="cov8" title="1">{
                value = strings.ToLower(cfg)
        }</span>
        <span class="cov8" title="1">if value != AlphaAPIFieldValue &amp;&amp; value != StableAPIFieldValue </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid value for feature flag %q: %q", enableAPIFieldsKey, value)
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

// NewFeatureFlagsFromConfigMap returns a Config for the given configmap
func NewFeatureFlagsFromConfigMap(config *corev1.ConfigMap) (*FeatureFlags, error) <span class="cov8" title="1">{
        return NewFeatureFlagsFromMap(config.Data)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package config

import (
        "context"

        "knative.dev/pkg/configmap"
)

type cfgKey struct{}

// Config holds the collection of configurations that we attach to contexts.
// +k8s:deepcopy-gen=false
type Config struct {
        Defaults     *Defaults
        FeatureFlags *FeatureFlags
}

// FromContext extracts a Config from the provided context.
func FromContext(ctx context.Context) *Config <span class="cov8" title="1">{
        x, ok := ctx.Value(cfgKey{}).(*Config)
        if ok </span><span class="cov8" title="1">{
                return x
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// FromContextOrDefaults is like FromContext, but when no Config is attached it
// returns a Config populated with the defaults for each of the Config fields.
func FromContextOrDefaults(ctx context.Context) *Config <span class="cov8" title="1">{
        if cfg := FromContext(ctx); cfg != nil </span><span class="cov8" title="1">{
                return cfg
        }</span>
        <span class="cov8" title="1">defaults, _ := NewDefaultsFromMap(map[string]string{})
        featureFlags, _ := NewFeatureFlagsFromMap(map[string]string{})
        return &amp;Config{
                Defaults:     defaults,
                FeatureFlags: featureFlags,
        }</span>
}

// ToContext attaches the provided Config to the provided context, returning the
// new context with the Config attached.
func ToContext(ctx context.Context, c *Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, cfgKey{}, c)
}</span>

// Store is a typed wrapper around configmap.Untyped store to handle our configmaps.
// +k8s:deepcopy-gen=false
type Store struct {
        *configmap.UntypedStore
}

// NewStore creates a new store of Configs and optionally calls functions when ConfigMaps are updated.
func NewStore(logger configmap.Logger, onAfterStore ...func(name string, value interface{})) *Store <span class="cov8" title="1">{
        store := &amp;Store{
                UntypedStore: configmap.NewUntypedStore(
                        "defaults/features/artifacts",
                        logger,
                        configmap.Constructors{
                                GetFeatureFlagsConfigName(): NewFeatureFlagsFromConfigMap,
                                GetDefaultsConfigName():     NewDefaultsFromConfigMap,
                        },
                        onAfterStore...,
                ),
        }

        return store
}</span>

// ToContext attaches the current Config state to the provided context.
func (s *Store) ToContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        return ToContext(ctx, s.Load())
}</span>

// Load creates a Config from the current config state of the Store.
func (s *Store) Load() *Config <span class="cov8" title="1">{
        defaults := s.UntypedLoad(GetDefaultsConfigName())
        if defaults == nil </span><span class="cov0" title="0">{
                defaults, _ = NewDefaultsFromMap(map[string]string{})
        }</span>
        <span class="cov8" title="1">featureFlags := s.UntypedLoad(GetFeatureFlagsConfigName())
        if featureFlags == nil </span><span class="cov8" title="1">{
                featureFlags, _ = NewFeatureFlagsFromMap(map[string]string{})
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                Defaults:     defaults.(*Defaults).DeepCopy(),
                FeatureFlags: featureFlags.(*FeatureFlags).DeepCopy(),
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package contexts

import "context"

// upgradeViaDefaultingKey is used as the key in a context.Context.
// This variable doesn't really matter, so it can be a total random name.
// Setting this key indicates that default values for a resource should be
// updated to new values. This is used to ensure non breaking updates when
// a default value of a resource changes or when a field is removed.
type upgradeViaDefaultingKey struct{}

// WithUpgradeViaDefaulting sets the upgradeViaDefaultingKey on the context
// indicating that default values for a resource should be updated to new values.
func WithUpgradeViaDefaulting(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, upgradeViaDefaultingKey{}, struct{}{})
}</span>

// IsUpgradeViaDefaulting checks if the upgradeViaDefaultingKey is set on
// the context.
func IsUpgradeViaDefaulting(ctx context.Context) bool <span class="cov0" title="0">{
        return ctx.Value(upgradeViaDefaultingKey{}) != nil
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

// SetDefaults sets the defaults on the object.
func (it *ClusterInterceptor) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, ok := it.GetLabels()["server/type"]; !ok </span><span class="cov0" title="0">{
                // if server type is not set its assumed that running server is http
                it.Labels = map[string]string{
                        "server/type": "http",
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "bytes"
        "errors"
        "fmt"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// Check that EventListener may be validated and defaulted.
var _ apis.Validatable = (*ClusterInterceptor)(nil)
var _ apis.Defaultable = (*ClusterInterceptor)(nil)

// +genclient
// +genclient:nonNamespaced
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
// ClusterInterceptor describes a pluggable interceptor including configuration
// such as the fields it accepts and its deployment address. The type is based on
// the Validating/MutatingWebhookConfiguration types for configuring AdmissionWebhooks
type ClusterInterceptor struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec ClusterInterceptorSpec `json:"spec"`
        // +optional
        Status ClusterInterceptorStatus `json:"status"`
}

// ClusterInterceptorSpec describes the Spec for an ClusterInterceptor
type ClusterInterceptorSpec struct {
        ClientConfig ClientConfig `json:"clientConfig"`
}

// ClusterInterceptorStatus holds the status of the ClusterInterceptor
// +k8s:deepcopy-gen=true
type ClusterInterceptorStatus struct {
        duckv1.Status `json:",inline"`

        // ClusterInterceptor is Addressable and exposes the URL where the Interceptor is running
        duckv1.AddressStatus `json:",inline"`
}

// ClientConfig describes how a client can communicate with the Interceptor
type ClientConfig struct {
        // CaBundle is a PEM encoded CA bundle which will be used to validate the clusterinterceptor server certificate
        CaBundle []byte `json:"caBundle,omitempty"`
        // URL is a fully formed URL pointing to the interceptor
        // Mutually exclusive with Service
        URL *apis.URL `json:"url,omitempty"`

        // Service is a reference to a Service object where the interceptor is running
        // Mutually exclusive with URL
        Service *ServiceReference `json:"service,omitempty"`
}

var (
        defaultHTTPSPort = int32(8443)
        defaultHTTPPort  = int32(80)
)

// ServiceReference is a reference to a Service object
// with an optional path
type ServiceReference struct {
        // Name is the name of the service
        Name string `json:"name"`

        // Namespace is the namespace of the service
        Namespace string `json:"namespace"`

        // Path is an optional URL path
        // +optional
        Path string `json:"path,omitempty"`

        // Port is a valid port number
        Port *int32 `json:"port,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// ClusterInterceptorList contains a list of ClusterInterceptor
// We don't use this but it's required for certain codegen features.
type ClusterInterceptorList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ClusterInterceptor `json:"items"`
}

var ErrNilURL = errors.New("interceptor URL was nil")

// ResolveAddress returns the URL where the interceptor is running using its clientConfig
func (it *ClusterInterceptor) ResolveAddress() (*apis.URL, error) <span class="cov8" title="1">{
        if url := it.Spec.ClientConfig.URL; url != nil </span><span class="cov8" title="1">{
                return url, nil
        }</span>
        <span class="cov8" title="1">svc := it.Spec.ClientConfig.Service
        if svc == nil </span><span class="cov8" title="1">{
                return nil, ErrNilURL
        }</span>
        <span class="cov8" title="1">var (
                port *int32
                url  *apis.URL
        )

        if svc.Port != nil </span><span class="cov8" title="1">{
                port = svc.Port
        }</span>

        <span class="cov8" title="1">if bytes.Equal(it.Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov8" title="1">{
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPPort
                }</span>
                <span class="cov8" title="1">url = formURL("http", svc, port)</span>
        } else<span class="cov8" title="1"> {
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPSPort
                }</span>
                <span class="cov8" title="1">url = formURL("https", svc, port)</span>
        }
        <span class="cov8" title="1">return url, nil</span>
}

func formURL(scheme string, svc *ServiceReference, port *int32) *apis.URL <span class="cov8" title="1">{
        return &amp;apis.URL{
                Scheme: scheme,
                Host:   fmt.Sprintf("%s.%s.svc:%d", svc.Name, svc.Namespace, *port),
                Path:   svc.Path,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/apis"
)

// Validate ClusterInterceptor
func (it *ClusterInterceptor) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return it.Spec.validate(ctx)</span>
}

// revive:disable:unused-parameter

func (s *ClusterInterceptorSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.ClientConfig.URL != nil &amp;&amp; s.ClientConfig.Service != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("spec.clientConfig.url", "spec.clientConfig.service"))
        }</span>
        <span class="cov8" title="1">if svc := s.ClientConfig.Service; svc != nil </span><span class="cov8" title="1">{
                if svc.Namespace == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.namespace"))
                }</span>
                <span class="cov8" title="1">if svc.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.name"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes ClusterTriggerBinding ctb with its default values.
func (ctb *ClusterTriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that ClusterTriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*ClusterTriggerBinding)(nil)
var _ apis.Defaultable = (*ClusterTriggerBinding)(nil)

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// ClusterTriggerBinding is a TriggerBinding with a cluster scope.
// ClusterTriggerBindings are used to represent TriggerBindings that
// should be publicly addressable from any namespace in the cluster.
type ClusterTriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the desired state of the ClusterTriggerBinding from the client
        // +optional
        Spec TriggerBindingSpec `json:"spec,omitempty"`

        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ClusterTriggerBindingList contains a list of ClusterTriggerBinding
type ClusterTriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ClusterTriggerBinding `json:"items"`
}

func (ctb *ClusterTriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return ctb.Spec
}</span>

func (ctb *ClusterTriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return ctb.ObjectMeta
}</span>

func (ctb *ClusterTriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return ctb.DeepCopy()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "knative.dev/pkg/apis"
)

func (ctb *ClusterTriggerBinding) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := validate.ObjectMetadata(ctb.GetObjectMeta()); err != nil </span><span class="cov0" title="0">{
                return err.ViaField("metadata")
        }</span>
        <span class="cov8" title="1">return ctb.Spec.Validate(ctx)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "knative.dev/pkg/logging"
)

// SetDefaults sets the defaults on the object.
func (el *EventListener) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                defaultSA := cfg.Defaults.DefaultServiceAccount
                if el.Spec.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                        el.Spec.ServiceAccountName = defaultSA
                }</span>
                // set defaults
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                        if el.Spec.Resources.KubernetesResource.Replicas != nil &amp;&amp; *el.Spec.Resources.KubernetesResource.Replicas == 0 </span><span class="cov8" title="1">{
                                *el.Spec.Resources.KubernetesResource.Replicas = 1
                        }</span>
                }

                <span class="cov8" title="1">for i, t := range el.Spec.Triggers </span><span class="cov8" title="1">{
                        triggerSpecBindingArray(el.Spec.Triggers[i].Bindings).defaultBindings()
                        for _, ti := range t.Interceptors </span><span class="cov8" title="1">{
                                if ti != nil </span><span class="cov8" title="1">{
                                        ti.defaultInterceptorKind()
                                        if err := ti.updateCoreInterceptors(); err != nil </span><span class="cov0" title="0">{
                                                // The err only happens due to malformed JSON and should never really happen
                                                // We can't return an error here, so print out the error
                                                logger := logging.FromContext(ctx)
                                                logger.Errorf("failed to setDefaults for trigger: %s; err: %s", t.Name, err)
                                        }</span>
                                }
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "fmt"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        duckv1alpha1 "knative.dev/pkg/apis/duck/v1alpha1"
        "knative.dev/pkg/apis/duck/v1beta1"
        "knative.dev/pkg/kmeta"
)

// Check that EventListener may be validated and defaulted.
var _ apis.Validatable = (*EventListener)(nil)
var _ apis.Defaultable = (*EventListener)(nil)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// EventListener exposes a service to accept HTTP event payloads.
//
// +k8s:openapi-gen=true
type EventListener struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the EventListener from the client
        // +optional
        Spec EventListenerSpec `json:"spec"`
        // +optional
        Status EventListenerStatus `json:"status,omitempty"`
}

var _ kmeta.OwnerRefable = (*EventListener)(nil)

// EventListenerSpec defines the desired state of the EventListener, represented
// by a list of Triggers.
type EventListenerSpec struct {
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
        // +listType=atomic
        Triggers          []EventListenerTrigger `json:"triggers"`
        NamespaceSelector NamespaceSelector      `json:"namespaceSelector,omitempty"`
        LabelSelector     *metav1.LabelSelector  `json:"labelSelector,omitempty"`
        Resources         Resources              `json:"resources,omitempty"`
}

type Resources struct {
        KubernetesResource *KubernetesResource `json:"kubernetesResource,omitempty"`
        CustomResource     *CustomResource     `json:"customResource,omitempty"`
}

type CustomResource struct {
        runtime.RawExtension `json:",inline"`
}

type KubernetesResource struct {
        Replicas           *int32             `json:"replicas,omitempty"`
        ServiceType        corev1.ServiceType `json:"serviceType,omitempty"`
        duckv1.WithPodSpec `json:"spec,omitempty"`
}

// EventListenerTrigger represents a connection between TriggerBinding, Params,
// and TriggerTemplate; TriggerBinding provides extracted values for
// TriggerTemplate to then create resources from. TriggerRef can also be
// provided instead of TriggerBinding, Interceptors and TriggerTemplate
type EventListenerTrigger struct {
        // +listType=atomic
        Bindings   []*EventListenerBinding `json:"bindings,omitempty"`
        Template   *EventListenerTemplate  `json:"template,omitempty"`
        TriggerRef string                  `json:"triggerRef,omitempty"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*EventInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // more granular authorization for
        // who is allowed to utilize the associated pipeline
        // vs. defaulting to whatever permissions are associated
        // with the entire EventListener and associated sink facilitates
        // multi-tenant model based scenarios
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

// EventInterceptor provides a hook to intercept and pre-process events
type EventInterceptor = TriggerInterceptor

// SecretRef contains the information required to reference a single secret string
// This is needed because the other secretRef types are not cross-namespace and do not
// actually contain the "SecretName" field, which allows us to access a single secret value.
type SecretRef struct {
        SecretKey  string `json:"secretKey,omitempty"`
        SecretName string `json:"secretName,omitempty"`
}

// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBindingresource.
type EventListenerBinding = TriggerSpecBinding

// EventListenerTemplate refers to a particular TriggerTemplate resource.
type EventListenerTemplate = TriggerSpecTemplate

// EventListenerList contains a list of TriggerBinding
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type EventListenerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []EventListener `json:"items"`
}

// EventListenerStatus holds the status of the EventListener
// +k8s:deepcopy-gen=true
type EventListenerStatus struct {
        duckv1.Status `json:",inline"`

        // EventListener is Addressable. It currently exposes the service DNS
        // address of the EventListener sink
        duckv1alpha1.AddressStatus `json:",inline"`

        // Configuration stores configuration for the EventListener service
        Configuration EventListenerConfig `json:"configuration"`
}

// EventListenerConfig stores configuration for resources generated by the
// EventListener
type EventListenerConfig struct {
        // GeneratedResourceName is the name given to all resources reconciled by
        // the EventListener
        GeneratedResourceName string `json:"generatedName"`
}

// NamespaceSelector is a selector for selecting either all namespaces or a
// list of namespaces.
// +k8s:openapi-gen=true
type NamespaceSelector struct {
        // List of namespace names.
        // +listType=atomic
        MatchNames []string `json:"matchNames,omitempty"`
}

// The conditions that are internally resolved by the EventListener reconciler
const (
        // ServiceExists is the ConditionType set on the EventListener, which
        // specifies Service existence.
        ServiceExists apis.ConditionType = "Service"
        // DeploymentExists is the ConditionType set on the EventListener, which
        // specifies Deployment existence.
        DeploymentExists apis.ConditionType = "Deployment"
)

// Check that EventListener may be validated and defaulted.
// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.
type TriggerBindingKind string

const (
        // NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.
        NamespacedTriggerBindingKind TriggerBindingKind = "TriggerBinding"
        // ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.
        ClusterTriggerBindingKind TriggerBindingKind = "ClusterTriggerBinding"
)

var eventListenerCondSet = apis.NewLivingConditionSet(
        ServiceExists,
        DeploymentExists,
)

// GetGroupVersionKind implements kmeta.OwnerRefable
func (el *EventListener) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("EventListener")
}</span>

// GetCondition returns the Condition matching the given type.
func (els *EventListenerStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return eventListenerCondSet.Manage(els).GetCondition(t)
}</span>

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary. This is a local change and needs to be persisted to the
// K8s API elsewhere.
func (els *EventListenerStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                // TODO: Should the ConditionManager be set somewhere?
                eventListenerCondSet.Manage(els).SetCondition(*newCond)
        }</span>
}

func (els *EventListenerStatus) SetReadyCondition() <span class="cov8" title="1">{
        for _, ct := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionType(appsv1.DeploymentProgressing),
                apis.ConditionType(appsv1.DeploymentAvailable)} </span><span class="cov8" title="1">{
                if sc := els.GetCondition(ct); sc != nil </span><span class="cov8" title="1">{
                        if sc.Status != corev1.ConditionTrue </span><span class="cov8" title="1">{
                                els.SetCondition(&amp;apis.Condition{
                                        Type:    apis.ConditionReady,
                                        Status:  corev1.ConditionFalse,
                                        Message: fmt.Sprintf("Condition %s has status: %s with message: %s", sc.Type, sc.Status, sc.Message),
                                })
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetDeploymentConditions sets the Deployment conditions on the EventListener,
// which is a reflection of the actual Deployment status.
func (els *EventListenerStatus) SetDeploymentConditions(deploymentConditions []appsv1.DeploymentCondition) <span class="cov8" title="1">{
        // Manually remove the DeploymentReplicaFailure condition since it does
        // not always exist and would stay around otherwise
        replicaFailureIndex := -1
        for i := range els.Conditions </span><span class="cov8" title="1">{
                if els.Conditions[i].Type == apis.ConditionType(appsv1.DeploymentReplicaFailure) </span><span class="cov8" title="1">{
                        replicaFailureIndex = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if replicaFailureIndex != -1 </span><span class="cov8" title="1">{
                els.Conditions = append(els.Conditions[:replicaFailureIndex], els.Conditions[replicaFailureIndex+1:]...)
        }</span>
        <span class="cov8" title="1">for _, cond := range deploymentConditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionType(cond.Type),
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>
}

func (els *EventListenerStatus) SetConditionsForDynamicObjects(conditions v1beta1.Conditions) <span class="cov8" title="1">{
        for _, cond := range conditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond.Type,
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>

        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetExistsCondition simplifies setting the exists conditions on the
// EventListenerStatus.
func (els *EventListenerStatus) SetExistsCondition(cond apis.ConditionType, err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionFalse,
                        Message: err.Error(),
                })
        }</span> else<span class="cov8" title="1"> {
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionTrue,
                        Message: fmt.Sprintf("%s exists", cond),
                })
        }</span>
}

// InitializeConditions will set all conditions in eventListenerCondSet to false
// for the EventListener. This does not use the InitializeCondition() provided
// by the conditionsImpl to avoid setting the happy condition. This is a local
// change and needs to be persisted to the K8s API elsewhere.
func (els *EventListenerStatus) InitializeConditions() <span class="cov8" title="1">{
        for _, condition := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionReady,
        } </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:   condition,
                        Status: corev1.ConditionFalse,
                })
        }</span>
}

// SetAddress sets the address (as part of Addressable contract) and marks the correct condition.
func (els *EventListenerStatus) SetAddress(hostname string) <span class="cov0" title="0">{
        if els.Address == nil </span><span class="cov0" title="0">{
                els.Address = &amp;duckv1alpha1.Addressable{}
        }</span>
        <span class="cov0" title="0">if hostname != "" </span><span class="cov0" title="0">{
                els.Address.URL = &amp;apis.URL{
                        Scheme: "http",
                        Host:   hostname,
                }
        }</span> else<span class="cov0" title="0"> {
                els.Address.URL = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/triggers"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        reservedEnvVars = sets.NewString(
                "TLS_CERT",
                "TLS_KEY",
        )
)

var _ resourcesemantics.VerbLimited = (*EventListener)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (e *EventListener) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate EventListener.
func (e *EventListener) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var errs *apis.FieldError
        if len(e.ObjectMeta.Name) &gt; 60 </span><span class="cov8" title="1">{
                // Since `el-` is added as the prefix of EventListener services, the name of EventListener must be no more than 60 characters long.
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("eventListener name '%s' must be no more than 60 characters long", e.ObjectMeta.Name), "metadata.name"))
        }</span>

        <span class="cov8" title="1">if len(e.ObjectMeta.Annotations) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(triggers.ValidateAnnotations(e.ObjectMeta.Annotations))
        }</span>

        <span class="cov8" title="1">return errs.Also(e.Spec.validate(ctx))</span>
}

func (s *EventListenerSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.LabelSelector == nil &amp;&amp; len(s.NamespaceSelector.MatchNames) == 0 &amp;&amp; len(s.Triggers) == 0 </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf("spec.labelSelector", "spec.namespaceSelector", "spec.triggers")
        }</span>

        <span class="cov8" title="1">for i, trigger := range s.Triggers </span><span class="cov8" title="1">{
                errs = errs.Also(trigger.validate(ctx).ViaField(fmt.Sprintf("spec.triggers[%d]", i)))
        }</span>

        // Both Kubernetes and Custom resource can't be present at the same time
        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil &amp;&amp; s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf("spec.resources.kubernetesResource", "spec.resources.customResource")
        }</span>

        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateKubernetesObject(s.Resources.KubernetesResource).ViaField("spec.resources.kubernetesResource"))
        }</span>

        <span class="cov8" title="1">if s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateCustomObject(s.Resources.CustomResource).ViaField("spec.resources.customResource"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateCustomObject(customData *CustomResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        orig := duckv1.WithPod{}
        decoder := json.NewDecoder(bytes.NewBuffer(customData.RawExtension.Raw))

        if err := decoder.Decode(&amp;orig); err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(err, "spec"))
        }</span>

        <span class="cov8" title="1">if len(orig.Spec.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec,
                *podSpecMask(&amp;orig.Spec.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Spec.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec.Containers[0],
                        *containerFieldMaskForCustomResource(&amp;orig.Spec.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Spec.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateKubernetesObject(orig *KubernetesResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        if orig.Replicas != nil </span><span class="cov8" title="1">{
                if *orig.Replicas &lt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(*orig.Replicas, "spec.replicas"))
                }</span>
        }
        <span class="cov8" title="1">if len(orig.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec,
                *podSpecMask(&amp;orig.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec.Containers[0],
                        *containerFieldMaskForKubernetes(&amp;orig.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateEnv(envVars []corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        var (
                count    = 0
                envValue string
        )
        for i, env := range envVars </span><span class="cov8" title="1">{
                errs = errs.Also(validateEnvVar(env).ViaIndex(i))
                if reservedEnvVars.Has(env.Name) </span><span class="cov8" title="1">{
                        count++
                        envValue = env.Name
                }</span>
        }
        // This is to make sure both TLS_CERT and TLS_KEY is set for tls connection
        <span class="cov8" title="1">if count == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "Expected env's are TLS_CERT and TLS_KEY, but got only one env " + envValue,
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateEnvVar(env corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(apis.CheckDisallowedFields(env, *envVarMask(&amp;env)))

        return errs.Also(validateEnvValueFrom(env.ValueFrom).ViaField("valueFrom"))
}</span>

func validateEnvValueFrom(source *corev1.EnvVarSource) *apis.FieldError <span class="cov8" title="1">{
        if source == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apis.CheckDisallowedFields(*source, *envVarSourceMask(source))</span>
}

// envVarSourceMask performs a _shallow_ copy of the Kubernetes EnvVarSource object to a new
// Kubernetes EnvVarSource object bringing over only the fields allowed in the Triggers EventListener API.
func envVarSourceMask(in *corev1.EnvVarSource) *corev1.EnvVarSource <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVarSource)
        // Allowed fields
        out.SecretKeyRef = in.SecretKeyRef

        // Disallowed fields
        out.ConfigMapKeyRef = nil
        out.FieldRef = nil
        out.ResourceFieldRef = nil

        return out</span>
}

// envVarMask performs a _shallow_ copy of the Kubernetes EnvVar object to a new
// Kubernetes EnvVar object bringing over only the fields allowed in the Triggers EventListener API.
func envVarMask(in *corev1.EnvVar) *corev1.EnvVar <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVar)
        // Allowed fields
        out.Name = in.Name
        out.ValueFrom = in.ValueFrom

        // Disallowed fields
        out.Value = ""

        return out</span>
}

func containerFieldMaskForKubernetes(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        out.LivenessProbe = in.LivenessProbe
        out.ReadinessProbe = in.ReadinessProbe
        out.StartupProbe = in.StartupProbe
        return containerFieldMask(out)
}</span>

func containerFieldMaskForCustomResource(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        return containerFieldMask(out)
}</span>

func containerFieldMask(out *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        // Disallowed fields
        // This list clarifies which all container attributes are not allowed.
        out.Name = ""
        out.Image = ""
        out.Args = nil
        out.Ports = nil
        out.Command = nil
        out.VolumeMounts = nil
        out.ImagePullPolicy = ""
        out.Lifecycle = nil
        out.Stdin = false
        out.StdinOnce = false
        out.TerminationMessagePath = ""
        out.TerminationMessagePolicy = ""
        out.WorkingDir = ""
        out.TTY = false
        out.VolumeDevices = nil
        out.EnvFrom = nil

        return out
}</span>

// podSpecMask performs a _shallow_ copy of the Kubernetes PodSpec object to a new
// Kubernetes PodSpec object bringing over only the fields allowed in the Triggers EvenListener.
func podSpecMask(in *corev1.PodSpec) *corev1.PodSpec <span class="cov8" title="1">{
        out := new(corev1.PodSpec)

        // Allowed fields
        out.ServiceAccountName = in.ServiceAccountName
        out.Containers = in.Containers
        out.Tolerations = in.Tolerations
        out.NodeSelector = in.NodeSelector

        // Disallowed fields
        // This list clarifies which all podspec fields are not allowed.
        out.Volumes = nil
        out.EnableServiceLinks = nil
        out.ImagePullSecrets = nil
        out.InitContainers = nil
        out.RestartPolicy = ""
        out.TerminationGracePeriodSeconds = nil
        out.ActiveDeadlineSeconds = nil
        out.DNSPolicy = ""
        out.AutomountServiceAccountToken = nil
        out.NodeName = ""
        out.HostNetwork = false
        out.HostPID = false
        out.HostIPC = false
        out.ShareProcessNamespace = nil
        out.SecurityContext = nil
        out.Hostname = ""
        out.Subdomain = ""
        out.SchedulerName = ""
        out.HostAliases = nil
        out.PriorityClassName = ""
        out.Priority = nil
        out.DNSConfig = nil
        out.ReadinessGates = nil
        out.RuntimeClassName = nil
        out.Affinity = nil
        out.TopologySpreadConstraints = nil

        return out
}</span>

func (t *EventListenerTrigger) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if t.Template == nil &amp;&amp; t.TriggerRef == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("template", "triggerRef"))
        }</span>

        <span class="cov8" title="1">if t.TriggerRef != "" &amp;&amp; (t.Template != nil || t.Bindings != nil || t.Interceptors != nil) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("triggerRef", "template or bindings or interceptors"))
        }</span>

        // Validate optional Bindings
        <span class="cov8" title="1">errs = errs.Also(triggerSpecBindingArray(t.Bindings).validate(ctx))
        if t.Template != nil </span><span class="cov8" title="1">{
                // Validate required TriggerTemplate
                errs = errs.Also(t.Template.validate(ctx))
        }</span>

        // Validate optional Interceptors
        <span class="cov8" title="1">for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                // No continuation if provided interceptor is nil.
                if interceptor == nil </span><span class="cov8" title="1">{
                        return errs.Also(apis.ErrInvalidValue(fmt.Sprintf("interceptor '%v' must be a valid value", interceptor), fmt.Sprintf("interceptors[%d]", i)))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))</span>
        }

        // The trigger name is added as a label value for 'tekton.dev/trigger' so it must follow the k8s label guidelines:
        // https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
        <span class="cov8" title="1">if err := validation.IsValidLabelValue(t.Name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("trigger name '%s' must be a valid label value", t.Name), "name"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

// SetDefaults sets the defaults on the object.
func (it *Interceptor) SetDefaults(ctx context.Context) <span class="cov0" title="0">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, ok := it.GetLabels()["server/type"]; !ok </span><span class="cov0" title="0">{
                // if server type is not set its assumed that running server is http
                it.Labels = map[string]string{
                        "server/type": "http",
                }
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package v1alpha1

import (
        "bytes"
        "context"
        "fmt"
        "strings"

        "google.golang.org/grpc/codes"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
)

// Check that Interceptor may be validated and defaulted.
var _ apis.Validatable = (*Interceptor)(nil)
var _ apis.Defaultable = (*Interceptor)(nil)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
// Interceptor describes a pluggable interceptor including configuration
// such as the fields it accepts and its deployment address. The type is based on
// the Validating/MutatingWebhookConfiguration types for configuring AdmissionWebhooks
type Interceptor struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        Spec InterceptorSpec `json:"spec"`
        // +optional
        Status InterceptorStatus `json:"status"`
}

// InterceptorSpec describes the Spec for an Interceptor
type InterceptorSpec struct {
        ClientConfig ClientConfig `json:"clientConfig"`
}

// InterceptorStatus holds the status of the Interceptor
// +k8s:deepcopy-gen=true
type InterceptorStatus struct {
        duckv1.Status `json:",inline"`

        // Interceptor is Addressable and exposes the URL where the Interceptor is running
        duckv1.AddressStatus `json:",inline"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// InterceptorList contains a list of Interceptor
// We don't use this but it's required for certain codegen features.
type InterceptorList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Interceptor `json:"items"`
}

// ResolveAddress returns the URL where the interceptor is running using its clientConfig
func (it *Interceptor) ResolveAddress() (*apis.URL, error) <span class="cov8" title="1">{
        if url := it.Spec.ClientConfig.URL; url != nil </span><span class="cov8" title="1">{
                return url, nil
        }</span>
        <span class="cov8" title="1">svc := it.Spec.ClientConfig.Service
        if svc == nil </span><span class="cov8" title="1">{
                return nil, ErrNilURL
        }</span>
        <span class="cov8" title="1">var (
                port *int32
                url  *apis.URL
        )

        if svc.Port != nil </span><span class="cov8" title="1">{
                port = svc.Port
        }</span>

        <span class="cov8" title="1">if bytes.Equal(it.Spec.ClientConfig.CaBundle, []byte{}) </span><span class="cov8" title="1">{
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPPort
                }</span>
                <span class="cov8" title="1">url = formURL("http", svc, port)</span>
        } else<span class="cov8" title="1"> {
                if port == nil </span><span class="cov8" title="1">{
                        port = &amp;defaultHTTPSPort
                }</span>
                <span class="cov8" title="1">url = formURL("https", svc, port)</span>
        }
        <span class="cov8" title="1">return url, nil</span>
}

type InterceptorInterface interface {
        // Process executes the given InterceptorRequest. Simply getting a non-nil InterceptorResponse back is not sufficient
        // to determine if the interceptor processing was successful. Instead use the InterceptorResponse.Status.Continue to
        // see if processing should continue and InterceptorResponse.Status.Code to distinguish between the kinds of errors
        // (i.e user errors vs system errors)
        Process(ctx context.Context, r *InterceptorRequest) *InterceptorResponse
}

// Do not generate DeepCopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorRequest struct {
        // Body is the incoming HTTP event body. We use a "string" representation of the JSON body
        // in order to preserve the body exactly as it was sent (including spaces etc.). This is necessary
        // for some interceptors e.g. GitHub for validating the body with a signature. While []byte can also
        // store an exact representation of the body, `json.Marshal` will compact []byte to a base64 encoded
        // string which means that we will lose the spaces any time we marshal this struct.
        Body string `json:"body,omitempty"`

        // Header are the headers for the incoming HTTP event
        Header map[string][]string `json:"header,omitempty"`

        // Extensions are extra values that are added by previous interceptors in a chain
        Extensions map[string]interface{} `json:"extensions,omitempty"`

        // InterceptorParams are the user specified params for interceptor in the Trigger
        InterceptorParams map[string]interface{} `json:"interceptor_params,omitempty"`

        // Context contains additional metadata about the event being processed
        Context *TriggerContext `json:"context"`
}

type TriggerContext struct {
        // EventURL is the URL of the incoming event
        EventURL string `json:"event_url,omitempty"`
        // EventID is a unique ID assigned by Triggers to each event
        EventID string `json:"event_id,omitempty"`
        // TriggerID is of the form namespace/$ns/triggers/$name
        TriggerID string `json:"trigger_id,omitempty"`
}

// Do not generate Deepcopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorResponse struct {
        // Extensions are additional fields that is added to the interceptor event.
        Extensions map[string]interface{} `json:"extensions,omitempty"`
        // Continue indicates if the EventListener should continue processing the Trigger or not
        Continue bool `json:"continue"` // Don't add omitempty -- it  will remove the continue field when the value is false.
        // Status is an Error status containing details on any interceptor processing errors
        Status Status `json:"status"`
}

type Status struct {
        // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
        Code codes.Code `json:"code,omitempty"`
        // A developer-facing error message, which should be in English.
        Message string `json:"message,omitempty"`
}

func (s Status) Err() StatusError <span class="cov0" title="0">{
        return StatusError{s: s}
}</span>

type StatusError struct {
        s Status
}

func (s StatusError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("rpc error: code = %s desc = %s", s.s.Code, s.s.Message)
}</span>

func ParseTriggerID(triggerID string) (namespace, name string) <span class="cov8" title="1">{
        splits := strings.Split(triggerID, "/")
        if len(splits) != 4 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return splits[1], splits[3]</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "knative.dev/pkg/apis"
)

// Validate Interceptor
func (it *Interceptor) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return it.Spec.validate(ctx)</span>
}

// revive:disable:unused-parameter

func (s *InterceptorSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.ClientConfig.URL != nil &amp;&amp; s.ClientConfig.Service != nil </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("spec.clientConfig.url", "spec.clientConfig.service"))
        }</span>
        <span class="cov8" title="1">if svc := s.ClientConfig.Service; svc != nil </span><span class="cov8" title="1">{
                if svc.Namespace == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.namespace"))
                }</span>
                <span class="cov8" title="1">if svc.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("spec.clientConfig.service.name"))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: triggers.GroupName, Version: "v1alpha1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;ClusterInterceptor{},
                &amp;ClusterInterceptorList{},
                &amp;ClusterTriggerBinding{},
                &amp;ClusterTriggerBindingList{},
                &amp;EventListener{},
                &amp;EventListenerList{},
                &amp;Interceptor{},
                &amp;InterceptorList{},
                &amp;TriggerBinding{},
                &amp;TriggerBindingList{},
                &amp;TriggerTemplate{},
                &amp;TriggerTemplateList{},
                &amp;Trigger{},
                &amp;TriggerList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerBinding tb with its default values.
func (tb *TriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that TriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*TriggerBinding)(nil)
var _ apis.Defaultable = (*TriggerBinding)(nil)

func (tb *TriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return tb.Spec
}</span>

func (tb *TriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return tb.ObjectMeta
}</span>

func (tb *TriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return tb.DeepCopy()
}</span>

// TriggerBindingSpec defines the desired state of the TriggerBinding.
type TriggerBindingSpec struct {
        // Params defines the parameter mapping from the given input event.
        // +listType=atomic
        Params []Param `json:"params,omitempty"`
}

// TriggerBindingStatus defines the observed state of TriggerBinding.
type TriggerBindingStatus struct{}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBinding defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type TriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the TriggerBinding
        // +optional
        Spec TriggerBindingSpec `json:"spec"`
        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBindingList contains a list of TriggerBindings.
// We don't use this but it's required for certain codegen features.
type TriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TriggerBinding `json:"items"`
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

// Validate TriggerBinding.
func (tb *TriggerBinding) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">errs = validate.ObjectMetadata(tb.GetObjectMeta()).ViaField("metadata")
        return errs.Also(tb.Spec.Validate(ctx).ViaField("spec"))</span>
}

// revive:disable:unused-parameter

// Validate TriggerBindingSpec.
func (s *TriggerBindingSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerBindingSpec{}) </span><span class="cov8" title="1">{
                return errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">return errs.Also(validateParams(s.Params).ViaField("params"))</span>
}

func validateParams(params []Param) *apis.FieldError <span class="cov8" title="1">{
        // Ensure there aren't multiple params with the same name.
        seen := sets.NewString()
        for i, param := range params </span><span class="cov8" title="1">{
                if seen.Has(param.Name) </span><span class="cov8" title="1">{
                        return apis.ErrMultipleOneOf(fmt.Sprintf("[%d].name", i))
                }</span>
                <span class="cov8" title="1">seen.Insert(param.Name)
                errs := validateParamValue(param.Value).ViaField(fmt.Sprintf("[%d]", i))
                if errs != nil </span><span class="cov8" title="1">{
                        return errs
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateParamValue(in string) *apis.FieldError <span class="cov8" title="1">{
        if !strings.Contains(in, "$(") </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Splits string on $( to find potential Tekton expressions
        <span class="cov8" title="1">maybeExpressions := strings.Split(in, "$(")
        terminated := true
        for _, e := range maybeExpressions[1:] </span><span class="cov8" title="1">{ // Split always returns at least one element
                // Iterate until we find the first unbalanced )
                numOpenBrackets := 0
                if !terminated </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(in, "value")
                }</span>
                <span class="cov8" title="1">terminated = false
                for _, ch := range e </span><span class="cov8" title="1">{
                        switch ch </span>{
                        case '(':<span class="cov8" title="1">
                                numOpenBrackets++</span>
                        case ')':<span class="cov8" title="1">
                                numOpenBrackets--
                                if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                        terminated = true
                                }</span>
                        default:<span class="cov8" title="1">
                                continue</span>
                        }
                        <span class="cov8" title="1">if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                terminated = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "knative.dev/pkg/logging"
)

type triggerSpecBindingArray []*TriggerSpecBinding

// SetDefaults sets the defaults on the object.
func (t *Trigger) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">triggerSpecBindingArray(t.Spec.Bindings).defaultBindings()
        for _, ti := range t.Spec.Interceptors </span><span class="cov8" title="1">{
                ti.defaultInterceptorKind()
                if err := ti.updateCoreInterceptors(); err != nil </span><span class="cov0" title="0">{
                        // The err only happens due to malformed JSON and should never really happen
                        // We can't return an error here, so print out the error
                        logger := logging.FromContext(ctx)
                        logger.Errorf("failed to setDefaults for trigger: %s; err: %s", t.Name, err)
                }</span>
        }
}

// set default TriggerBinding kind for Bindings in TriggerSpec
func (t triggerSpecBindingArray) defaultBindings() <span class="cov8" title="1">{
        if len(t) &gt; 0 </span><span class="cov8" title="1">{
                for _, b := range t </span><span class="cov8" title="1">{
                        if b.Kind == "" </span><span class="cov8" title="1">{
                                b.Kind = NamespacedTriggerBindingKind
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerTemplate with default values.
func (tt *TriggerTemplate) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "fmt"
        "regexp"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
)

// paramsRegexp captures TriggerTemplate parameter names $(tt.params.NAME)
var paramsRegexp = regexp.MustCompile(`\$\(tt.params.(?P&lt;var&gt;[_a-zA-Z][_a-zA-Z0-9.-]*)\)`)

// revive:disable:unused-parameter

// Validate validates a TriggerTemplate.
func (t *TriggerTemplate) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))</span>
}

// Validate validates a TriggerTemplateSpec.
func (s *TriggerTemplateSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerTemplateSpec{}) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">if len(s.ResourceTemplates) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("resourcetemplates"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateResourceTemplates(s.ResourceTemplates).ViaField("resourcetemplates"))
        errs = errs.Also(verifyParamDeclarations(s.Params, s.ResourceTemplates).ViaField("resourcetemplates"))
        return errs</span>
}

func validateResourceTemplates(templates []TriggerResourceTemplate) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, trt := range templates </span><span class="cov8" title="1">{
                data := new(unstructured.Unstructured)
                if err := data.UnmarshalJSON(trt.Raw); err != nil </span><span class="cov8" title="1">{
                        // a missing kind makes the unmarshalling throw an error
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].kind", i)))
                }</span>

                <span class="cov8" title="1">if data.GetAPIVersion() == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].apiVersion", i)))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Verify every param in the ResourceTemplates is declared with a ParamSpec
func verifyParamDeclarations(params []ParamSpec, templates []TriggerResourceTemplate) *apis.FieldError <span class="cov8" title="1">{
        declaredParamNames := sets.NewString()
        for _, param := range params </span><span class="cov8" title="1">{
                declaredParamNames.Insert(param.Name)
        }</span>
        <span class="cov8" title="1">for i, template := range templates </span><span class="cov8" title="1">{
                // Get all params in the template $(tt.params.NAME)
                templateParams := paramsRegexp.FindAllSubmatch(template.RawExtension.Raw, -1)
                for _, templateParam := range templateParams </span><span class="cov8" title="1">{
                        templateParamName := string(templateParam[1])
                        if !declaredParamNames.Has(templateParamName) </span><span class="cov8" title="1">{
                                fieldErr := apis.ErrInvalidValue(
                                        fmt.Sprintf("undeclared param '$(tt.params.%s)'", templateParamName),
                                        fmt.Sprintf("[%d]", i),
                                )
                                fieldErr.Details = fmt.Sprintf("'$(tt.params.%s)' must be declared in spec.params", templateParamName)
                                return fieldErr
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "encoding/json"
        "fmt"

        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// TriggerSpec represents a connection between TriggerSpecBinding,
// and TriggerSpecTemplate; TriggerSpecBinding provides extracted values for
// TriggerSpecTemplate to then create resources from.
type TriggerSpec struct {
        // +listType=atomic
        Bindings []*TriggerSpecBinding `json:"bindings"`
        Template TriggerSpecTemplate   `json:"template"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*TriggerInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // Unlike EventListeners, this should be scoped to the same namespace
        // as the Trigger itself
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

type TriggerSpecTemplate struct {
        Ref        *string              `json:"ref,omitempty"`
        APIVersion string               `json:"apiversion,omitempty"`
        Spec       *TriggerTemplateSpec `json:"spec,omitempty"`
}

type TriggerSpecBinding struct {
        // Name is the name of the binding param
        // Mutually exclusive with Ref
        Name string `json:"name,omitempty"`
        // Value is the value of the binding param. Can contain JSONPath
        // Has to be pointer since "" is a valid value
        // Required if Name is also specified.
        Value *string `json:"value,omitempty"`

        // Ref is a reference to a TriggerBinding kind.
        // Mutually exclusive with Name
        Ref string `json:"ref,omitempty"`

        // Kind can only be provided if Ref is also provided. Defaults to TriggerBinding
        Kind TriggerBindingKind `json:"kind,omitempty"`

        // APIVersion of the binding ref
        APIVersion string `json:"apiversion,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Trigger defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type Trigger struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the Trigger
        // +optional
        Spec TriggerSpec `json:"spec"`
}

// TriggerInterceptor provides a hook to intercept and pre-process events
type TriggerInterceptor struct {
        // Optional name to identify the current interceptor configuration
        Name *string `json:"name,omitempty"`
        // Ref refers to the Interceptor to use
        Ref InterceptorRef `json:"ref"`
        // Params are the params to send to the interceptor
        // +listType=atomic
        Params []InterceptorParams `json:"params,omitempty"`

        // WebhookInterceptor refers to an old style webhook interceptor service
        Webhook *WebhookInterceptor `json:"webhook,omitempty"`

        // Deprecated old fields below
        DeprecatedGitHub    *GitHubInterceptor    `json:"github,omitempty"`
        DeprecatedGitLab    *GitLabInterceptor    `json:"gitlab,omitempty"`
        DeprecatedCEL       *CELInterceptor       `json:"cel,omitempty"`
        DeprecatedBitbucket *BitbucketInterceptor `json:"bitbucket,omitempty"`
}

// InterceptorParams defines a key-value pair that can be passed on an interceptor
type InterceptorParams struct {
        Name  string               `json:"name"`
        Value apiextensionsv1.JSON `json:"value"`
}

// InterceptorRef provides a Reference to a ClusterInterceptor
type InterceptorRef struct {
        // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        Name string `json:"name,omitempty"`
        // InterceptorKind indicates the kind of the Interceptor, namespaced or cluster scoped.
        // +optional
        Kind InterceptorKind `json:"kind,omitempty"`
        // API version of the referent
        // +optional
        APIVersion string `json:"apiVersion,omitempty"`
}

// InterceptorKind defines the type of Interceptor used by the Trigger.
type InterceptorKind string

const (
        // ClusterInterceptorKind indicates that Interceptor type has a cluster scope.
        ClusterInterceptorKind InterceptorKind = "ClusterInterceptor"
        // NamespacedInterceptorKind indicated that interceptor has a namespaced scope
        NamespacedInterceptorKind InterceptorKind = "NamespacedInterceptor"
)

func (ti *TriggerInterceptor) defaultInterceptorKind() <span class="cov8" title="1">{
        if ti.Ref.Kind == "" </span><span class="cov8" title="1">{
                ti.Ref.Kind = ClusterInterceptorKind
        }</span>
}

func (ti *TriggerInterceptor) updateCoreInterceptors() error <span class="cov8" title="1">{
        if ti == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if ti.Ref.Name != "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ti.Ref.Name = ti.GetName()
        ti.Params = []InterceptorParams{}
        switch ti.Ref.Name </span>{
        case "bitbucket":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "secretRef", ti.DeprecatedBitbucket.SecretRef); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "eventTypes", ti.DeprecatedBitbucket.EventTypes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedBitbucket = nil</span>
        case "gitlab":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "secretRef", ti.DeprecatedGitLab.SecretRef); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "eventTypes", ti.DeprecatedGitLab.EventTypes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedGitLab = nil</span>
        case "github":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "secretRef", ti.DeprecatedGitHub.SecretRef); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "eventTypes", ti.DeprecatedGitHub.EventTypes); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedGitHub = nil</span>
        case "cel":<span class="cov8" title="1">
                if err := addToParams(&amp;ti.Params, "filter", ti.DeprecatedCEL.Filter); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := addToParams(&amp;ti.Params, "overlays", ti.DeprecatedCEL.Overlays); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">ti.DeprecatedCEL = nil</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func addToParams(params *[]InterceptorParams, name string, val interface{}) error <span class="cov8" title="1">{
        if val == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">v, err := toV1JSON(val)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*params = append(*params, InterceptorParams{
                Name:  name,
                Value: v,
        })
        return nil</span>
}

func toV1JSON(v interface{}) (apiextensionsv1.JSON, error) <span class="cov8" title="1">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return apiextensionsv1.JSON{}, fmt.Errorf("json.Marshal() failed: %w", err)
        }</span>
        <span class="cov8" title="1">return apiextensionsv1.JSON{
                Raw: b,
        }, nil</span>
}

// GetName returns the name for the given interceptor
func (ti *TriggerInterceptor) GetName() string <span class="cov8" title="1">{
        // This is temporary until we implement #869
        name := ""
        switch </span>{
        case ti.Ref.Name != "":<span class="cov8" title="1">
                name = ti.Ref.Name</span>
        case ti.DeprecatedBitbucket != nil:<span class="cov8" title="1">
                name = "bitbucket"</span>
        case ti.DeprecatedCEL != nil:<span class="cov8" title="1">
                name = "cel"</span>
        case ti.DeprecatedGitHub != nil:<span class="cov8" title="1">
                name = "github"</span>
        case ti.DeprecatedGitLab != nil:<span class="cov8" title="1">
                name = "gitlab"</span>
        }
        <span class="cov8" title="1">return name</span>
}

// WebhookInterceptor provides a webhook to intercept and pre-process events
type WebhookInterceptor struct {
        // ObjectRef is a reference to an object that will resolve to a cluster DNS
        // name to use as the EventInterceptor. Either objectRef or url can be specified
        // +optional
        ObjectRef *corev1.ObjectReference `json:"objectRef,omitempty"`
        // +optional
        URL *apis.URL `json:"url,omitempty"`
        // Header is a group of key-value pairs that can be appended to the
        // interceptor request headers. This allows the interceptor to make
        // decisions specific to an EventListenerTrigger.
        // +listType=atomic
        Header []v1beta1.Param `json:"header,omitempty"`
}

// BitbucketInterceptor provides a webhook to intercept and pre-process events
type BitbucketInterceptor struct {
        SecretRef *SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

// GitHubInterceptor provides a webhook to intercept and pre-process events
type GitHubInterceptor struct {
        SecretRef *SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

// GitLabInterceptor provides a webhook to intercept and pre-process events
type GitLabInterceptor struct {
        SecretRef *SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

// CELInterceptor provides a webhook to intercept and pre-process events
type CELInterceptor struct {
        Filter string `json:"filter,omitempty"`
        // +listType=atomic
        Overlays []CELOverlay `json:"overlays,omitempty"`
}

// CELOverlay provides a way to modify the request body using DeprecatedCEL expressions
type CELOverlay struct {
        Key        string `json:"key,omitempty"`
        Expression string `json:"expression,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerList contains a list of Triggers.
// We don't use this but it's required for certain codegen features.
type TriggerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Trigger `json:"items"`
}
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "encoding/json"
)

// ToEventListenerTrigger converts a TriggerSpec into an EventListenerTrigger.
// This is primarily for compatibility between CRD and non-CRD types so that
// underlying libraries can reuse existing code.
func ToEventListenerTrigger(in TriggerSpec) (EventListenerTrigger, error) <span class="cov8" title="1">{
        var out EventListenerTrigger

        // Use json Marshalling in order to be field agnostic. Since TriggerSpec
        // is a subset of the existing EventListenerTrigger type, and should always
        // contain the same field labels, this should be safe to do.
        b, err := json.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;out); err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1alpha1

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        "github.com/google/cel-go/cel"
        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        "knative.dev/pkg/apis"
)

// Validate validates a Trigger
func (t *Trigger) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))</span>
}

func (t *TriggerSpec) validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // Validate optional Bindings
        errs := triggerSpecBindingArray(t.Bindings).validate(ctx)
        // Validate required TriggerTemplate
        errs = errs.Also(t.Template.validate(ctx))

        // Validate optional Interceptors
        for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// revive:disable:unused-parameter

func (t TriggerSpecTemplate) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Optional explicit match
        if t.APIVersion != "" </span><span class="cov8" title="1">{
                if t.APIVersion != "v1alpha1" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "template.apiVersion"))
                }</span>
        }

        <span class="cov8" title="1">switch </span>{
        case t.Spec != nil &amp;&amp; t.Ref != nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMultipleOneOf("template.spec", "template.ref"))</span>
        case t.Spec == nil &amp;&amp; t.Ref == nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingOneOf("template.spec", "template.ref"))</span>
        case t.Spec != nil:<span class="cov8" title="1">
                errs = errs.Also(t.Spec.validate(ctx))</span>
        case t.Ref == nil || *t.Ref == "":<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("template.ref"))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

func (t triggerSpecBindingArray) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, b := range t </span><span class="cov8" title="1">{
                switch </span>{
                case b.Ref != "":<span class="cov8" title="1">
                        switch </span>{
                        case b.Name != "":<span class="cov8" title="1"> // Cannot specify both Ref and Name
                                errs = errs.Also(apis.ErrMultipleOneOf(fmt.Sprintf("bindings[%d].Ref", i), fmt.Sprintf("bindings[%d].Name", i)))</span>
                        case b.Kind != NamespacedTriggerBindingKind &amp;&amp; b.Kind != ClusterTriggerBindingKind:<span class="cov8" title="1"> // Kind must be valid
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), fmt.Sprintf("bindings[%d].kind", i)))</span>
                        }
                case b.Name != "":<span class="cov8" title="1">
                        if b.Value == nil </span><span class="cov8" title="1">{ // Value is mandatory if Name is specified
                                errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("bindings[%d].Value", i)))
                        }</span>
                default:<span class="cov8" title="1">
                        errs = errs.Also(apis.ErrMissingOneOf(fmt.Sprintf("bindings[%d].Ref", i), fmt.Sprintf("bindings[%d].Spec", i), fmt.Sprintf("bindings[%d].Name", i)))</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func (i *TriggerInterceptor) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if i.Webhook == nil &amp;&amp; i.DeprecatedGitHub == nil &amp;&amp; i.DeprecatedGitLab == nil &amp;&amp; i.DeprecatedCEL == nil &amp;&amp; i.DeprecatedBitbucket == nil </span><span class="cov8" title="1">{
                if i.Ref.Name == "" </span><span class="cov8" title="1">{ // Check to see if Interceptor referenced using Ref
                        errs = errs.Also(apis.ErrMissingField("interceptor"))
                }</span>
        }

        // Enforce oneof
        <span class="cov8" title="1">numSet := 0
        if i.Webhook != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>
        <span class="cov8" title="1">if i.DeprecatedGitHub != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>
        <span class="cov8" title="1">if i.DeprecatedGitLab != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>
        <span class="cov8" title="1">if i.DeprecatedBitbucket != nil </span><span class="cov8" title="1">{
                numSet++
        }</span>

        <span class="cov8" title="1">if numSet &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("interceptor.webhook", "interceptor.github", "interceptor.gitlab"))
        }</span>

        <span class="cov8" title="1">if i.Webhook != nil </span><span class="cov8" title="1">{
                if i.Webhook.ObjectRef == nil || i.Webhook.ObjectRef.Name == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef"))
                }</span>
                <span class="cov8" title="1">w := i.Webhook
                if w.ObjectRef.Kind != "Service" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), "interceptor.webhook.objectRef.kind"))
                }</span>

                // Optional explicit match
                <span class="cov8" title="1">if w.ObjectRef.APIVersion != "v1" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "interceptor.webhook.objectRef.apiVersion"))
                }</span>

                <span class="cov8" title="1">for i, header := range w.Header </span><span class="cov8" title="1">{
                        // Enforce non-empty canonical header keys
                        if len(header.Name) == 0 || http.CanonicalHeaderKey(header.Name) != header.Name </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header name"), fmt.Sprintf("interceptor.webhook.header[%d].name", i)))
                        }</span>
                        // Enforce non-empty header values
                        <span class="cov8" title="1">if header.Value.Type == pipelinev1.ParamTypeString </span><span class="cov8" title="1">{
                                if len(header.Value.StringVal) == 0 </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                                }</span>
                        } else<span class="cov0" title="0"> if len(header.Value.ArrayVal) == 0 </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                        }</span>
                }
        }

        <span class="cov8" title="1">if i.DeprecatedCEL != nil </span><span class="cov8" title="1">{
                if i.DeprecatedCEL.Filter == "" &amp;&amp; len(i.DeprecatedCEL.Overlays) == 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMultipleOneOf("cel.filter", "cel.overlays"))
                }</span>
                <span class="cov8" title="1">env, err := cel.NewEnv()
                if err != nil </span><span class="cov0" title="0">{
                        errs = errs.Also(apis.ErrInvalidValue(fmt.Errorf("failed to create a DeprecatedCEL env: %w", err), "cel.filter"))
                }</span>
                <span class="cov8" title="1">if i.DeprecatedCEL.Filter != "" </span><span class="cov8" title="1">{
                        if _, issues := env.Parse(i.DeprecatedCEL.Filter); issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Errorf("failed to parse the DeprecatedCEL filter: %w", issues.Err()), "cel.filter"))
                        }</span>
                }
                <span class="cov8" title="1">for _, v := range i.DeprecatedCEL.Overlays </span><span class="cov8" title="1">{
                        if _, issues := env.Parse(v.Expression); issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(fmt.Errorf("failed to parse the DeprecatedCEL overlay: %w", issues.Err()), "cel.overlay"))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes ClusterTriggerBinding ctb with its default values.
func (ctb *ClusterTriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that ClusterTriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*ClusterTriggerBinding)(nil)
var _ apis.Defaultable = (*ClusterTriggerBinding)(nil)

// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true

// ClusterTriggerBinding is a TriggerBinding with a cluster scope.
// ClusterTriggerBindings are used to represent TriggerBindings that
// should be publicly addressable from any namespace in the cluster.
type ClusterTriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`

        // Spec holds the desired state of the ClusterTriggerBinding from the client
        // +optional
        Spec TriggerBindingSpec `json:"spec,omitempty"`

        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// ClusterTriggerBindingList contains a list of ClusterTriggerBinding
type ClusterTriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []ClusterTriggerBinding `json:"items"`
}

func (ctb *ClusterTriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return ctb.Spec
}</span>

func (ctb *ClusterTriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return ctb.ObjectMeta
}</span>

func (ctb *ClusterTriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return ctb.DeepCopy()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ resourcesemantics.VerbLimited = (*ClusterTriggerBinding)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (ctb *ClusterTriggerBinding) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

func (ctb *ClusterTriggerBinding) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        if err := validate.ObjectMetadata(ctb.GetObjectMeta()); err != nil </span><span class="cov0" title="0">{
                return err.ViaField("metadata")
        }</span>
        <span class="cov8" title="1">return ctb.Spec.Validate(ctx)</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

// SetDefaults sets the defaults on the object.
func (el *EventListener) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)
        if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                defaultSA := cfg.Defaults.DefaultServiceAccount
                // set defaults
                if el.Spec.ServiceAccountName == "" &amp;&amp; defaultSA != "" </span><span class="cov8" title="1">{
                        el.Spec.ServiceAccountName = defaultSA
                }</span>

                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                        if el.Spec.Resources.KubernetesResource.Replicas != nil &amp;&amp; *el.Spec.Resources.KubernetesResource.Replicas == 0 </span><span class="cov8" title="1">{
                                *el.Spec.Resources.KubernetesResource.Replicas = 1
                        }</span>
                }

                <span class="cov8" title="1">for i, t := range el.Spec.Triggers </span><span class="cov8" title="1">{
                        triggerSpecBindingArray(el.Spec.Triggers[i].Bindings).defaultBindings()
                        for _, ti := range t.Interceptors </span><span class="cov8" title="1">{
                                if ti != nil </span><span class="cov8" title="1">{
                                        ti.defaultInterceptorKind()
                                }</span>
                        }
                }

                <span class="cov8" title="1">for _, tg := range el.Spec.TriggerGroups </span><span class="cov8" title="1">{
                        for _, ti := range tg.Interceptors </span><span class="cov8" title="1">{
                                if ti != nil </span><span class="cov8" title="1">{
                                        ti.defaultInterceptorKind()
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "fmt"

        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/apis/duck/v1beta1"
        "knative.dev/pkg/kmeta"
)

// Check that EventListener may be validated and defaulted.
var _ apis.Validatable = (*EventListener)(nil)
var _ apis.Defaultable = (*EventListener)(nil)

// +genclient
// +genreconciler:krshapedlogic=false
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// EventListener exposes a service to accept HTTP event payloads.
//
// +k8s:openapi-gen=true
type EventListener struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the EventListener from the client
        // +optional
        Spec EventListenerSpec `json:"spec"`
        // +optional
        Status EventListenerStatus `json:"status,omitempty"`
}

var _ kmeta.OwnerRefable = (*EventListener)(nil)

// EventListenerSpec defines the desired state of the EventListener, represented
// by a list of Triggers.
type EventListenerSpec struct {
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
        // +listType=atomic
        Triggers []EventListenerTrigger `json:"triggers,omitempty"`
        // Trigger groups allow for centralized processing of an interceptor chain
        // +listType=atomic
        TriggerGroups     []EventListenerTriggerGroup `json:"triggerGroups,omitempty"`
        NamespaceSelector NamespaceSelector           `json:"namespaceSelector,omitempty"`
        LabelSelector     *metav1.LabelSelector       `json:"labelSelector,omitempty"`
        Resources         Resources                   `json:"resources,omitempty"`
        CloudEventURI     string                      `json:"cloudEventURI,omitempty"`
}

type Resources struct {
        KubernetesResource *KubernetesResource `json:"kubernetesResource,omitempty"`
        CustomResource     *CustomResource     `json:"customResource,omitempty"`
}

type CustomResource struct {
        runtime.RawExtension `json:",inline"`
}

type KubernetesResource struct {
        Replicas                 *int32             `json:"replicas,omitempty"`
        ServiceType              corev1.ServiceType `json:"serviceType,omitempty"`
        ServicePort              *int32             `json:"servicePort,omitempty"`
        ServiceLoadBalancerClass *string            `json:"serviceLoadBalancerClass,omitempty"`
        duckv1.WithPodSpec       `json:"spec,omitempty"`
}

// EventListenerTrigger represents a connection between TriggerBinding, Params,
// and TriggerTemplate; TriggerBinding provides extracted values for
// TriggerTemplate to then create resources from. TriggerRef can also be
// provided instead of TriggerBinding, Interceptors and TriggerTemplate
type EventListenerTrigger struct {
        // +listType=atomic
        Bindings   []*EventListenerBinding `json:"bindings,omitempty"`
        Template   *EventListenerTemplate  `json:"template,omitempty"`
        TriggerRef string                  `json:"triggerRef,omitempty"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*EventInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // more granular authorization for
        // who is allowed to utilize the associated pipeline
        // vs. defaulting to whatever permissions are associated
        // with the entire EventListener and associated sink facilitates
        // multi-tenant model based scenarios
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

// EventListenerTriggerGroup defines a group of Triggers that share a common set of interceptors
type EventListenerTriggerGroup struct {
        Name string `json:"name"`
        // +listType=atomic
        Interceptors    []*TriggerInterceptor        `json:"interceptors"`
        TriggerSelector EventListenerTriggerSelector `json:"triggerSelector"`
}

// EventListenerTriggerSelector  defines ways to select a group of triggers using their metadata
type EventListenerTriggerSelector struct {
        NamespaceSelector NamespaceSelector     `json:"namespaceSelector,omitempty"`
        LabelSelector     *metav1.LabelSelector `json:"labelSelector,omitempty"`
}

// EventInterceptor provides a hook to intercept and pre-process events
type EventInterceptor = TriggerInterceptor

// SecretRef contains the information required to reference a single secret string
// This is needed because the other secretRef types are not cross-namespace and do not
// actually contain the "SecretName" field, which allows us to access a single secret value.
type SecretRef struct {
        SecretKey  string `json:"secretKey,omitempty"`
        SecretName string `json:"secretName,omitempty"`
}

// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBinding resource.
type EventListenerBinding = TriggerSpecBinding

// EventListenerTemplate refers to a particular TriggerTemplate resource.
type EventListenerTemplate = TriggerSpecTemplate

// EventListenerList contains a list of TriggerBinding
//
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
type EventListenerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []EventListener `json:"items"`
}

// EventListenerStatus holds the status of the EventListener
// +k8s:deepcopy-gen=true
type EventListenerStatus struct {
        duckv1.Status `json:",inline"`

        // EventListener is Addressable. It currently exposes the service DNS
        // address of the EventListener sink
        v1beta1.AddressStatus `json:",inline"`

        // Configuration stores configuration for the EventListener service
        Configuration EventListenerConfig `json:"configuration"`
}

// EventListenerConfig stores configuration for resources generated by the
// EventListener
type EventListenerConfig struct {
        // GeneratedResourceName is the name given to all resources reconciled by
        // the EventListener
        GeneratedResourceName string `json:"generatedName"`
}

// NamespaceSelector is a selector for selecting either all namespaces or a
// list of namespaces.
// +k8s:openapi-gen=true
type NamespaceSelector struct {
        // List of namespace names.
        // +listType=atomic
        MatchNames []string `json:"matchNames,omitempty"`
}

// The conditions that are internally resolved by the EventListener reconciler
const (
        // ServiceExists is the ConditionType set on the EventListener, which
        // specifies Service existence.
        ServiceExists apis.ConditionType = "Service"
        // DeploymentExists is the ConditionType set on the EventListener, which
        // specifies Deployment existence.
        DeploymentExists apis.ConditionType = "Deployment"
)

// Check that EventListener may be validated and defaulted.
// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.
type TriggerBindingKind string

const (
        // NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.
        NamespacedTriggerBindingKind TriggerBindingKind = "TriggerBinding"
        // ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.
        ClusterTriggerBindingKind TriggerBindingKind = "ClusterTriggerBinding"
)

var eventListenerCondSet = apis.NewLivingConditionSet(
        ServiceExists,
        DeploymentExists,
)

// GetGroupVersionKind implements kmeta.OwnerRefable
func (el *EventListener) GetGroupVersionKind() schema.GroupVersionKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind("EventListener")
}</span>

// GetCondition returns the Condition matching the given type.
func (els *EventListenerStatus) GetCondition(t apis.ConditionType) *apis.Condition <span class="cov8" title="1">{
        return eventListenerCondSet.Manage(els).GetCondition(t)
}</span>

// SetCondition sets the condition, unsetting previous conditions with the same
// type as necessary. This is a local change and needs to be persisted to the
// K8s API elsewhere.
func (els *EventListenerStatus) SetCondition(newCond *apis.Condition) <span class="cov8" title="1">{
        if newCond != nil </span><span class="cov8" title="1">{
                // TODO: Should the ConditionManager be set somewhere?
                eventListenerCondSet.Manage(els).SetCondition(*newCond)
        }</span>
}

func (els *EventListenerStatus) SetReadyCondition() <span class="cov8" title="1">{
        for _, ct := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionType(appsv1.DeploymentProgressing),
                apis.ConditionType(appsv1.DeploymentAvailable)} </span><span class="cov8" title="1">{
                if sc := els.GetCondition(ct); sc != nil </span><span class="cov8" title="1">{
                        if sc.Status != corev1.ConditionTrue </span><span class="cov8" title="1">{
                                els.SetCondition(&amp;apis.Condition{
                                        Type:    apis.ConditionReady,
                                        Status:  corev1.ConditionFalse,
                                        Message: fmt.Sprintf("Condition %s has status: %s with message: %s", sc.Type, sc.Status, sc.Message),
                                })
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetDeploymentConditions sets the Deployment conditions on the EventListener,
// which is a reflection of the actual Deployment status.
func (els *EventListenerStatus) SetDeploymentConditions(deploymentConditions []appsv1.DeploymentCondition) <span class="cov8" title="1">{
        // Manually remove the DeploymentReplicaFailure condition since it does
        // not always exist and would stay around otherwise
        replicaFailureIndex := -1
        for i := range els.Conditions </span><span class="cov8" title="1">{
                if els.Conditions[i].Type == apis.ConditionType(appsv1.DeploymentReplicaFailure) </span><span class="cov8" title="1">{
                        replicaFailureIndex = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if replicaFailureIndex != -1 </span><span class="cov8" title="1">{
                els.Conditions = append(els.Conditions[:replicaFailureIndex], els.Conditions[replicaFailureIndex+1:]...)
        }</span>
        <span class="cov8" title="1">for _, cond := range deploymentConditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    apis.ConditionType(cond.Type),
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>
}

func (els *EventListenerStatus) SetConditionsForDynamicObjects(conditions v1beta1.Conditions) <span class="cov8" title="1">{
        for _, cond := range conditions </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond.Type,
                        Status:  cond.Status,
                        Reason:  cond.Reason,
                        Message: cond.Message,
                })
        }</span>

        <span class="cov8" title="1">els.SetCondition(&amp;apis.Condition{
                Type:    apis.ConditionReady,
                Status:  corev1.ConditionTrue,
                Message: "EventListener is ready",
        })</span>
}

// SetExistsCondition simplifies setting the exists conditions on the
// EventListenerStatus.
func (els *EventListenerStatus) SetExistsCondition(cond apis.ConditionType, err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionFalse,
                        Message: err.Error(),
                })
        }</span> else<span class="cov8" title="1"> {
                els.SetCondition(&amp;apis.Condition{
                        Type:    cond,
                        Status:  corev1.ConditionTrue,
                        Message: fmt.Sprintf("%s exists", cond),
                })
        }</span>
}

// InitializeConditions will set all conditions in eventListenerCondSet to false
// for the EventListener. This does not use the InitializeCondition() provided
// by the conditionsImpl to avoid setting the happy condition. This is a local
// change and needs to be persisted to the K8s API elsewhere.
func (els *EventListenerStatus) InitializeConditions() <span class="cov8" title="1">{
        for _, condition := range []apis.ConditionType{
                ServiceExists,
                DeploymentExists,
                apis.ConditionReady,
        } </span><span class="cov8" title="1">{
                els.SetCondition(&amp;apis.Condition{
                        Type:   condition,
                        Status: corev1.ConditionFalse,
                })
        }</span>
}

// SetAddress sets the address (as part of Addressable contract) and marks the correct condition.
func (els *EventListenerStatus) SetAddress(hostname string) <span class="cov0" title="0">{
        if els.Address == nil </span><span class="cov0" title="0">{
                els.Address = &amp;v1beta1.Addressable{}
        }</span>
        <span class="cov0" title="0">if hostname != "" </span><span class="cov0" title="0">{
                els.Address.URL = &amp;apis.URL{
                        Scheme: "http",
                        Host:   hostname,
                }
        }</span> else<span class="cov0" title="0"> {
                els.Address.URL = nil
        }</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/triggers"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/sets"
        "k8s.io/apimachinery/pkg/util/validation"
        "knative.dev/pkg/apis"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var (
        reservedEnvVars = sets.NewString(
                "TLS_CERT",
                "TLS_KEY",
        )
)

var _ resourcesemantics.VerbLimited = (*EventListener)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (e *EventListener) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// revive:disable:unused-parameter

// Validate EventListener.
func (e *EventListener) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError
        if len(e.ObjectMeta.Name) &gt; 60 </span><span class="cov8" title="1">{
                // Since `el-` is added as the prefix of EventListener services, the name of EventListener must be no more than 60 characters long.
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("eventListener name '%s' must be no more than 60 characters long", e.ObjectMeta.Name), "metadata.name"))
        }</span>

        <span class="cov8" title="1">if len(e.GetObjectMeta().GetAnnotations()) != 0 </span><span class="cov8" title="1">{
                errs = errs.Also(triggers.ValidateAnnotations(e.GetObjectMeta().GetAnnotations()))
        }</span>

        <span class="cov8" title="1">return errs.Also(e.Spec.validate(ctx))</span>
}

func (s *EventListenerSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if s.LabelSelector == nil &amp;&amp; len(s.NamespaceSelector.MatchNames) == 0 &amp;&amp; len(s.TriggerGroups) == 0 &amp;&amp; len(s.Triggers) == 0 </span><span class="cov8" title="1">{
                return apis.ErrMissingOneOf("spec.labelSelector", "spec.namespaceSelector", "spec.triggerGroups", "spec.triggers")
        }</span>

        <span class="cov8" title="1">for i, trigger := range s.Triggers </span><span class="cov8" title="1">{
                errs = errs.Also(trigger.validate(ctx).ViaField(fmt.Sprintf("spec.triggers[%d]", i)))
        }</span>

        // Both Kubernetes and Custom resource can't be present at the same time
        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil &amp;&amp; s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                return apis.ErrMultipleOneOf("spec.resources.kubernetesResource", "spec.resources.customResource")
        }</span>

        <span class="cov8" title="1">if s.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateKubernetesObject(s.Resources.KubernetesResource).ViaField("spec.resources.kubernetesResource"))
        }</span>

        <span class="cov8" title="1">if s.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                errs = errs.Also(validateCustomObject(s.Resources.CustomResource).ViaField("spec.resources.customResource"))
        }</span>

        <span class="cov8" title="1">if len(s.TriggerGroups) &gt; 0 </span><span class="cov8" title="1">{
                for i, group := range s.TriggerGroups </span><span class="cov8" title="1">{
                        errs = errs.Also(group.validate(ctx).ViaField(fmt.Sprintf("spec.triggerGroups[%d]", i)))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

func (g *EventListenerTriggerGroup) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if g.TriggerSelector.LabelSelector == nil &amp;&amp; len(g.TriggerSelector.NamespaceSelector.MatchNames) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("triggerSelector.labelSelector", "triggerSelector.namespaceSelector"))
        }</span>
        <span class="cov8" title="1">if len(g.Interceptors) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("interceptors"))
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateCustomObject(customData *CustomResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        orig := duckv1.WithPod{}
        decoder := json.NewDecoder(bytes.NewBuffer(customData.RawExtension.Raw))

        if err := decoder.Decode(&amp;orig); err != nil </span><span class="cov0" title="0">{
                errs = errs.Also(apis.ErrInvalidValue(err, "spec"))
        }</span>

        <span class="cov8" title="1">if len(orig.Spec.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec,
                *podSpecMask(&amp;orig.Spec.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Spec.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec.Containers[0],
                        *containerFieldMaskForCustomResource(&amp;orig.Spec.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Spec.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateKubernetesObject(orig *KubernetesResource) (errs *apis.FieldError) <span class="cov8" title="1">{
        if orig.Replicas != nil </span><span class="cov8" title="1">{
                if *orig.Replicas &lt; 0 </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(*orig.Replicas, "spec.replicas"))
                }</span>
        }
        <span class="cov8" title="1">if len(orig.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("containers").ViaField("spec.template.spec"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec,
                *podSpecMask(&amp;orig.Template.Spec)).ViaField("spec.template.spec"))

        // bounded by condition because containers fields are optional so there is a chance that containers can be nil.
        if len(orig.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec.Containers[0],
                        *containerFieldMaskForKubernetes(&amp;orig.Template.Spec.Containers[0])).ViaField("spec.template.spec.containers[0]"))
                // validate env
                errs = errs.Also(validateEnv(orig.Template.Spec.Containers[0].Env).ViaField("spec.template.spec.containers[0].env"))
        }</span>

        <span class="cov8" title="1">if orig.ServiceLoadBalancerClass != nil &amp;&amp; orig.ServiceType != corev1.ServiceTypeLoadBalancer </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(*orig.ServiceLoadBalancerClass, "serviceLoadBalancerClass", "ServiceLoadBalancerClass is only needed for LoadBalancer service type"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func validateEnv(envVars []corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        var (
                count    = 0
                envValue string
        )
        for i, env := range envVars </span><span class="cov8" title="1">{
                errs = errs.Also(validateEnvVar(env).ViaIndex(i))
                if reservedEnvVars.Has(env.Name) </span><span class="cov8" title="1">{
                        count++
                        envValue = env.Name
                }</span>
        }
        // This is to make sure both TLS_CERT and TLS_KEY is set for tls connection
        <span class="cov8" title="1">if count == 1 </span><span class="cov8" title="1">{
                errs = errs.Also(&amp;apis.FieldError{
                        Message: "Expected env's are TLS_CERT and TLS_KEY, but got only one env " + envValue,
                })
        }</span>
        <span class="cov8" title="1">return errs</span>
}

func validateEnvVar(env corev1.EnvVar) (errs *apis.FieldError) <span class="cov8" title="1">{
        errs = errs.Also(apis.CheckDisallowedFields(env, *envVarMask(&amp;env)))

        return errs.Also(validateEnvValueFrom(env.ValueFrom).ViaField("valueFrom"))
}</span>

func validateEnvValueFrom(source *corev1.EnvVarSource) *apis.FieldError <span class="cov8" title="1">{
        if source == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return apis.CheckDisallowedFields(*source, *envVarSourceMask(source))</span>
}

// envVarSourceMask performs a _shallow_ copy of the Kubernetes EnvVarSource object to a new
// Kubernetes EnvVarSource object bringing over only the fields allowed in the Triggers EventListener API.
func envVarSourceMask(in *corev1.EnvVarSource) *corev1.EnvVarSource <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVarSource)
        // Allowed fields
        out.SecretKeyRef = in.SecretKeyRef

        // Disallowed fields
        out.ConfigMapKeyRef = nil
        out.FieldRef = nil
        out.ResourceFieldRef = nil

        return out</span>
}

// envVarMask performs a _shallow_ copy of the Kubernetes EnvVar object to a new
// Kubernetes EnvVar object bringing over only the fields allowed in the Triggers EventListener API.
func envVarMask(in *corev1.EnvVar) *corev1.EnvVar <span class="cov8" title="1">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">out := new(corev1.EnvVar)
        // Allowed fields
        out.Name = in.Name
        out.ValueFrom = in.ValueFrom

        // Disallowed fields
        out.Value = ""

        return out</span>
}

func containerFieldMaskForKubernetes(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        out.LivenessProbe = in.LivenessProbe
        out.ReadinessProbe = in.ReadinessProbe
        out.StartupProbe = in.StartupProbe
        out.SecurityContext = in.SecurityContext
        return containerFieldMask(out)
}</span>

func containerFieldMaskForCustomResource(in *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        out := new(corev1.Container)
        out.Resources = in.Resources
        out.Env = in.Env
        out.SecurityContext = in.SecurityContext
        return containerFieldMask(out)
}</span>

func containerFieldMask(out *corev1.Container) *corev1.Container <span class="cov8" title="1">{
        // Disallowed fields
        // This list clarifies which all container attributes are not allowed.
        out.Name = ""
        out.Image = ""
        out.Args = nil
        out.Ports = nil
        out.Command = nil
        out.VolumeMounts = nil
        out.ImagePullPolicy = ""
        out.Lifecycle = nil
        out.Stdin = false
        out.StdinOnce = false
        out.TerminationMessagePath = ""
        out.TerminationMessagePolicy = ""
        out.WorkingDir = ""
        out.TTY = false
        out.VolumeDevices = nil
        out.EnvFrom = nil

        return out
}</span>

// podSpecMask performs a _shallow_ copy of the Kubernetes PodSpec object to a new
// Kubernetes PodSpec object bringing over only the fields allowed in the Triggers EvenListener.
func podSpecMask(in *corev1.PodSpec) *corev1.PodSpec <span class="cov8" title="1">{
        out := new(corev1.PodSpec)

        // Allowed fields
        out.ServiceAccountName = in.ServiceAccountName
        out.Containers = in.Containers
        out.Tolerations = in.Tolerations
        out.NodeSelector = in.NodeSelector
        out.Affinity = in.Affinity
        out.TopologySpreadConstraints = in.TopologySpreadConstraints
        out.ImagePullSecrets = in.ImagePullSecrets
        out.SecurityContext = in.SecurityContext

        // Disallowed fields
        // This list clarifies which all podspec fields are not allowed.
        out.Volumes = nil
        out.EnableServiceLinks = nil
        out.InitContainers = nil
        out.RestartPolicy = ""
        out.TerminationGracePeriodSeconds = nil
        out.ActiveDeadlineSeconds = nil
        out.DNSPolicy = ""
        out.AutomountServiceAccountToken = nil
        out.NodeName = ""
        out.HostNetwork = false
        out.HostPID = false
        out.HostIPC = false
        out.ShareProcessNamespace = nil
        out.Hostname = ""
        out.Subdomain = ""
        out.SchedulerName = ""
        out.HostAliases = nil
        out.PriorityClassName = ""
        out.Priority = nil
        out.DNSConfig = nil
        out.ReadinessGates = nil
        out.RuntimeClassName = nil

        return out
}</span>

func (t *EventListenerTrigger) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if t.Template == nil &amp;&amp; t.TriggerRef == "" </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingOneOf("template", "triggerRef"))
        }</span>

        <span class="cov8" title="1">if t.TriggerRef != "" &amp;&amp; (t.Template != nil || t.Bindings != nil || t.Interceptors != nil) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMultipleOneOf("triggerRef", "template or bindings or interceptors"))
        }</span>

        // Validate optional Bindings
        <span class="cov8" title="1">errs = errs.Also(triggerSpecBindingArray(t.Bindings).validate(ctx))
        if t.Template != nil </span><span class="cov8" title="1">{
                // Validate required TriggerTemplate
                errs = errs.Also(t.Template.validate(ctx))
        }</span>

        // Validate optional Interceptors
        <span class="cov8" title="1">for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                // No continuation if provided interceptor is nil.
                if interceptor == nil </span><span class="cov8" title="1">{
                        return errs.Also(apis.ErrInvalidValue(fmt.Sprintf("interceptor '%v' must be a valid value", interceptor), fmt.Sprintf("interceptors[%d]", i)))
                }</span>
                <span class="cov8" title="1">errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))</span>
        }

        // The trigger name is added as a label value for 'tekton.dev/trigger' so it must follow the k8s label guidelines:
        // https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
        <span class="cov8" title="1">if err := validation.IsValidLabelValue(t.Name); len(err) &gt; 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf("trigger name '%s' must be a valid label value", t.Name), "name"))
        }</span>

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "google.golang.org/grpc/codes"
)

type InterceptorInterface interface {
        // Process executes the given InterceptorRequest. Simply getting a non-nil InterceptorResponse back is not sufficient
        // to determine if the interceptor processing was successful. Instead use the InterceptorResponse.Status.Continue to
        // see if processing should continue and InterceptorResponse.Status.Code to distinguish between the kinds of errors
        // (i.e user errors vs system errors)
        Process(ctx context.Context, r *InterceptorRequest) *InterceptorResponse
}

// Do not generate DeepCopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorRequest struct {
        // Body is the incoming HTTP event body. We use a "string" representation of the JSON body
        // in order to preserve the body exactly as it was sent (including spaces etc.). This is necessary
        // for some interceptors e.g. GitHub for validating the body with a signature. While []byte can also
        // store an exact representation of the body, `json.Marshal` will compact []byte to a base64 encoded
        // string which means that we will lose the spaces any time we marshal this struct.
        Body string `json:"body,omitempty"`

        // Header are the headers for the incoming HTTP event
        Header map[string][]string `json:"header,omitempty"`

        // Extensions are extra values that are added by previous interceptors in a chain
        Extensions map[string]interface{} `json:"extensions,omitempty"`

        // InterceptorParams are the user specified params for interceptor in the Trigger
        InterceptorParams map[string]interface{} `json:"interceptor_params,omitempty"`

        // Context contains additional metadata about the event being processed
        Context *TriggerContext `json:"context"`
}

type TriggerContext struct {
        // EventURL is the URL of the incoming event
        EventURL string `json:"event_url,omitempty"`
        // EventID is a unique ID assigned by Triggers to each event
        EventID string `json:"event_id,omitempty"`
        // TriggerID is of the form namespace/$ns/triggers/$name
        TriggerID string `json:"trigger_id,omitempty"`
}

// Do not generate Deepcopy(). See #827
// +k8s:deepcopy-gen=false
type InterceptorResponse struct {
        // Extensions are additional fields that is added to the interceptor event.
        Extensions map[string]interface{} `json:"extensions,omitempty"`
        // Continue indicates if the EventListener should continue processing the Trigger or not
        Continue bool `json:"continue"` // Don't add omitempty -- it  will remove the continue field when the value is false.
        // Status is an Error status containing details on any interceptor processing errors
        Status Status `json:"status"`
}

type Status struct {
        // The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].
        Code codes.Code `json:"code,omitempty"`
        // A developer-facing error message, which should be in English.
        Message string `json:"message,omitempty"`
}

func (s Status) Err() StatusError <span class="cov0" title="0">{
        return StatusError{s: s}
}</span>

type StatusError struct {
        s Status
}

func (s StatusError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("rpc error: code = %s desc = %s", s.s.Code, s.s.Message)
}</span>

func ParseTriggerID(triggerID string) (namespace, name string) <span class="cov8" title="1">{
        splits := strings.Split(triggerID, "/")
        if len(splits) != 4 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return splits[1], splits[3]</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/runtime/schema"
)

// SchemeGroupVersion is group version used to register these objects
var SchemeGroupVersion = schema.GroupVersion{Group: triggers.GroupName, Version: "v1beta1"}

// Kind takes an unqualified kind and returns back a Group qualified GroupKind
func Kind(kind string) schema.GroupKind <span class="cov0" title="0">{
        return SchemeGroupVersion.WithKind(kind).GroupKind()
}</span>

// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource <span class="cov0" title="0">{
        return SchemeGroupVersion.WithResource(resource).GroupResource()
}</span>

var (
        schemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)

        // AddToScheme adds Build types to the scheme.
        AddToScheme = schemeBuilder.AddToScheme
)

// Adds the list of known types to Scheme.
func addKnownTypes(scheme *runtime.Scheme) error <span class="cov8" title="1">{
        scheme.AddKnownTypes(SchemeGroupVersion,
                &amp;ClusterTriggerBinding{},
                &amp;ClusterTriggerBindingList{},
                &amp;EventListener{},
                &amp;EventListenerList{},
                &amp;TriggerBinding{},
                &amp;TriggerBindingList{},
                &amp;TriggerTemplate{},
                &amp;TriggerTemplateList{},
                &amp;Trigger{},
                &amp;TriggerList{},
        )
        metav1.AddToGroupVersion(scheme, SchemeGroupVersion)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerBinding tb with its default values.
func (tb *TriggerBinding) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// Check that TriggerBinding may be validated and defaulted.
var _ apis.Validatable = (*TriggerBinding)(nil)
var _ apis.Defaultable = (*TriggerBinding)(nil)

func (tb *TriggerBinding) TriggerBindingSpec() TriggerBindingSpec <span class="cov0" title="0">{
        return tb.Spec
}</span>

func (tb *TriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta <span class="cov0" title="0">{
        return tb.ObjectMeta
}</span>

func (tb *TriggerBinding) Copy() TriggerBindingInterface <span class="cov0" title="0">{
        return tb.DeepCopy()
}</span>

// TriggerBindingSpec defines the desired state of the TriggerBinding.
type TriggerBindingSpec struct {
        // Params defines the parameter mapping from the given input event.
        // +listType=atomic
        Params []Param `json:"params,omitempty"`
}

// TriggerBindingStatus defines the observed state of TriggerBinding.
type TriggerBindingStatus struct{}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBinding defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type TriggerBinding struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the TriggerBinding
        // +optional
        Spec TriggerBindingSpec `json:"spec"`
        // +optional
        Status TriggerBindingStatus `json:"status,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerBindingList contains a list of TriggerBindings.
// We don't use this but it's required for certain codegen features.
type TriggerBindingList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []TriggerBinding `json:"items"`
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "strings"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ resourcesemantics.VerbLimited = (*TriggerBinding)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (tb *TriggerBinding) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate TriggerBinding.
func (tb *TriggerBinding) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(tb.GetObjectMeta()).ViaField("metadata")
        return errs.Also(tb.Spec.Validate(ctx).ViaField("spec"))
}</span>

// revive:disable:unused-parameter

// Validate TriggerBindingSpec.
func (s *TriggerBindingSpec) Validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerBindingSpec{}) </span><span class="cov8" title="1">{
                return errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">return errs.Also(validateParams(s.Params).ViaField("params"))</span>
}

func validateParams(params []Param) *apis.FieldError <span class="cov8" title="1">{
        // Ensure there aren't multiple params with the same name.
        seen := sets.NewString()
        for i, param := range params </span><span class="cov8" title="1">{
                if seen.Has(param.Name) </span><span class="cov8" title="1">{
                        return apis.ErrMultipleOneOf(fmt.Sprintf("[%d].name", i))
                }</span>
                <span class="cov8" title="1">seen.Insert(param.Name)
                errs := validateParamValue(param.Value).ViaField(fmt.Sprintf("[%d]", i))
                if errs != nil </span><span class="cov8" title="1">{
                        return errs
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateParamValue(in string) *apis.FieldError <span class="cov8" title="1">{
        if !strings.Contains(in, "$(") </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Splits string on $( to find potential Tekton expressions
        <span class="cov8" title="1">maybeExpressions := strings.Split(in, "$(")
        terminated := true
        for _, e := range maybeExpressions[1:] </span><span class="cov8" title="1">{ // Split always returns at least one element
                // Iterate until we find the first unbalanced )
                numOpenBrackets := 0
                if !terminated </span><span class="cov8" title="1">{
                        return apis.ErrInvalidValue(in, "value")
                }</span>
                <span class="cov8" title="1">terminated = false
                for _, ch := range e </span><span class="cov8" title="1">{
                        switch ch </span>{
                        case '(':<span class="cov8" title="1">
                                numOpenBrackets++</span>
                        case ')':<span class="cov8" title="1">
                                numOpenBrackets--
                                if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                        terminated = true
                                }</span>
                        default:<span class="cov8" title="1">
                                continue</span>
                        }
                        <span class="cov8" title="1">if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                terminated = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
)

type triggerSpecBindingArray []*TriggerSpecBinding

// SetDefaults sets the defaults on the object.
func (t *Trigger) SetDefaults(ctx context.Context) <span class="cov8" title="1">{
        if !contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">triggerSpecBindingArray(t.Spec.Bindings).defaultBindings()
        for _, ti := range t.Spec.Interceptors </span><span class="cov8" title="1">{
                ti.defaultInterceptorKind()
        }</span>
}

// set default TriggerBinding kind for Bindings in TriggerSpec
func (t triggerSpecBindingArray) defaultBindings() <span class="cov8" title="1">{
        if len(t) &gt; 0 </span><span class="cov8" title="1">{
                for _, b := range t </span><span class="cov8" title="1">{
                        if b.Kind == "" </span><span class="cov8" title="1">{
                                b.Kind = NamespacedTriggerBindingKind
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
)

// revive:disable:unused-parameter

// SetDefaults initializes TriggerTemplate with default values.
func (tt *TriggerTemplate) SetDefaults(ctx context.Context) {<span class="cov0" title="0">}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"
        "regexp"

        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/util/sets"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

// paramsRegexp captures TriggerTemplate parameter names $(tt.params.NAME)
var paramsRegexp = regexp.MustCompile(`\$\(tt.params.(?P&lt;var&gt;[_a-zA-Z][_a-zA-Z0-9.-]*)\)`)

var _ resourcesemantics.VerbLimited = (*TriggerTemplate)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (t *TriggerTemplate) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate validates a TriggerTemplate.
func (t *TriggerTemplate) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))
}</span>

// revive:disable:unused-parameter

// Validate validates a TriggerTemplateSpec.
func (s *TriggerTemplateSpec) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if equality.Semantic.DeepEqual(s, &amp;TriggerTemplateSpec{}) </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField(apis.CurrentField))
        }</span>
        <span class="cov8" title="1">if len(s.ResourceTemplates) == 0 </span><span class="cov8" title="1">{
                errs = errs.Also(apis.ErrMissingField("resourcetemplates"))
        }</span>
        <span class="cov8" title="1">errs = errs.Also(validateResourceTemplates(s.ResourceTemplates).ViaField("resourcetemplates"))
        errs = errs.Also(verifyParamDeclarations(s.Params, s.ResourceTemplates).ViaField("resourcetemplates"))
        return errs</span>
}

func validateResourceTemplates(templates []TriggerResourceTemplate) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, trt := range templates </span><span class="cov8" title="1">{
                data := new(unstructured.Unstructured)
                if err := data.UnmarshalJSON(trt.Raw); err != nil </span><span class="cov8" title="1">{
                        // a missing kind makes the unmarshalling throw an error
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].kind", i)))
                }</span>

                <span class="cov8" title="1">if data.GetAPIVersion() == "" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("[%d].apiVersion", i)))
                }</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// Verify every param in the ResourceTemplates is declared with a ParamSpec
func verifyParamDeclarations(params []ParamSpec, templates []TriggerResourceTemplate) *apis.FieldError <span class="cov8" title="1">{
        declaredParamNames := sets.NewString()
        for _, param := range params </span><span class="cov8" title="1">{
                declaredParamNames.Insert(param.Name)
        }</span>
        <span class="cov8" title="1">for i, template := range templates </span><span class="cov8" title="1">{
                // Get all params in the template $(tt.params.NAME)
                templateParams := paramsRegexp.FindAllSubmatch(template.RawExtension.Raw, -1)
                for _, templateParam := range templateParams </span><span class="cov8" title="1">{
                        templateParamName := string(templateParam[1])
                        if !declaredParamNames.Has(templateParamName) </span><span class="cov8" title="1">{
                                fieldErr := apis.ErrInvalidValue(
                                        fmt.Sprintf("undeclared param '$(tt.params.%s)'", templateParamName),
                                        fmt.Sprintf("[%d]", i),
                                )
                                fieldErr.Details = fmt.Sprintf("'$(tt.params.%s)' must be declared in spec.params", templateParamName)
                                return fieldErr
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        corev1 "k8s.io/api/core/v1"
        apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/apis"
)

// TriggerSpec represents a connection between TriggerSpecBinding,
// and TriggerSpecTemplate; TriggerSpecBinding provides extracted values for
// TriggerSpecTemplate to then create resources from.
type TriggerSpec struct {
        // +listType=atomic
        Bindings []*TriggerSpecBinding `json:"bindings"`
        Template TriggerSpecTemplate   `json:"template"`
        // +optional
        Name string `json:"name,omitempty"`
        // +listType=atomic
        Interceptors []*TriggerInterceptor `json:"interceptors,omitempty"`
        // ServiceAccountName optionally associates credentials with each trigger;
        // Unlike EventListeners, this should be scoped to the same namespace
        // as the Trigger itself
        // +optional
        ServiceAccountName string `json:"serviceAccountName,omitempty"`
}

type TriggerSpecTemplate struct {
        Ref        *string              `json:"ref,omitempty"`
        APIVersion string               `json:"apiversion,omitempty"`
        Spec       *TriggerTemplateSpec `json:"spec,omitempty"`
}

type TriggerSpecBinding struct {
        // Name is the name of the binding param
        // Mutually exclusive with Ref
        Name string `json:"name,omitempty"`
        // Value is the value of the binding param. Can contain JSONPath
        // Has to be pointer since "" is a valid value
        // Required if Name is also specified.
        Value *string `json:"value,omitempty"`

        // Ref is a reference to a TriggerBinding kind.
        // Mutually exclusive with Name
        Ref string `json:"ref,omitempty"`

        // Kind can only be provided if Ref is also provided. Defaults to TriggerBinding
        Kind TriggerBindingKind `json:"kind,omitempty"`

        // APIVersion of the binding ref
        APIVersion string `json:"apiversion,omitempty"`
}

// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// Trigger defines a mapping of an input event to parameters. This is used
// to extract information from events to be passed to TriggerTemplates within a
// Trigger.
// +k8s:openapi-gen=true
type Trigger struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty"`
        // Spec holds the desired state of the Trigger
        // +optional
        Spec TriggerSpec `json:"spec"`
}

// TriggerInterceptor provides a hook to intercept and pre-process events
type TriggerInterceptor struct {
        // Optional name to identify the current interceptor configuration
        Name *string `json:"name,omitempty"`
        // Ref refers to the Interceptor to use
        Ref InterceptorRef `json:"ref"`
        // Params are the params to send to the interceptor
        // +listType=atomic
        Params []InterceptorParams `json:"params,omitempty"`

        // WebhookInterceptor refers to an old style webhook interceptor service
        Webhook *WebhookInterceptor `json:"webhook,omitempty"`
}

// InterceptorParams defines a key-value pair that can be passed on an interceptor
type InterceptorParams struct {
        Name  string               `json:"name"`
        Value apiextensionsv1.JSON `json:"value"`
}

// InterceptorRef provides a Reference to a ClusterInterceptor
type InterceptorRef struct {
        // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
        Name string `json:"name,omitempty"`
        // InterceptorKind indicates the kind of the Interceptor, namespaced or cluster scoped.
        // +optional
        Kind InterceptorKind `json:"kind,omitempty"`
        // API version of the referent
        // +optional
        APIVersion string `json:"apiVersion,omitempty"`
}

// InterceptorKind defines the type of Interceptor used by the Trigger.
type InterceptorKind string

const (
        // ClusterInterceptorKind indicates that Interceptor type has a cluster scope.
        ClusterInterceptorKind InterceptorKind = "ClusterInterceptor"
        // NamespacedInterceptorKind indicates that Interceptor type has a namespace scope.
        NamespacedInterceptorKind InterceptorKind = "NamespacedInterceptor"
)

func (ti *TriggerInterceptor) defaultInterceptorKind() <span class="cov8" title="1">{
        if ti.Ref.Kind == "" </span><span class="cov8" title="1">{
                ti.Ref.Kind = ClusterInterceptorKind
        }</span>
}

// GetName returns the name for the given interceptor
func (ti *TriggerInterceptor) GetName() string <span class="cov8" title="1">{
        if ti.Ref.Name != "" </span><span class="cov8" title="1">{
                return ti.Ref.Name
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// WebhookInterceptor provides a webhook to intercept and pre-process events
type WebhookInterceptor struct {
        // ObjectRef is a reference to an object that will resolve to a cluster DNS
        // name to use as the EventInterceptor. Either objectRef or url can be specified
        // +optional
        ObjectRef *corev1.ObjectReference `json:"objectRef,omitempty"`
        // +optional
        URL *apis.URL `json:"url,omitempty"`
        // Header is a group of key-value pairs that can be appended to the
        // interceptor request headers. This allows the interceptor to make
        // decisions specific to an EventListenerTrigger.
        // +listType=atomic
        Header []v1beta1.Param `json:"header,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

// TriggerList contains a list of Triggers.
// We don't use this but it's required for certain codegen features.
type TriggerList struct {
        metav1.TypeMeta `json:",inline"`
        // +optional
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []Trigger `json:"items"`
}
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "encoding/json"
)

// ToEventListenerTrigger converts a TriggerSpec into an EventListenerTrigger.
// This is primarily for compatibility between CRD and non-CRD types so that
// underlying libraries can reuse existing code.
func ToEventListenerTrigger(in TriggerSpec) (EventListenerTrigger, error) <span class="cov8" title="1">{
        var out EventListenerTrigger

        // Use json Marshalling in order to be field agnostic. Since TriggerSpec
        // is a subset of the existing EventListenerTrigger type, and should always
        // contain the same field labels, this should be safe to do.
        b, err := json.Marshal(in)
        if err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;out); err != nil </span><span class="cov0" title="0">{
                return out, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "errors"
        "fmt"
        "net/http"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/pipeline/pkg/apis/validate"
        admissionregistrationv1 "k8s.io/api/admissionregistration/v1"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/webhook/resourcesemantics"
)

var _ resourcesemantics.VerbLimited = (*Trigger)(nil)

// SupportedVerbs returns the operations that validation should be called for
func (t *Trigger) SupportedVerbs() []admissionregistrationv1.OperationType <span class="cov0" title="0">{
        return []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}
}</span>

// Validate validates a Trigger
func (t *Trigger) Validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        errs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField("metadata")
        return errs.Also(t.Spec.validate(ctx).ViaField("spec"))
}</span>

func (t *TriggerSpec) validate(ctx context.Context) *apis.FieldError <span class="cov8" title="1">{
        // Validate optional Bindings
        errs := triggerSpecBindingArray(t.Bindings).validate(ctx)
        // Validate required TriggerTemplate
        errs = errs.Also(t.Template.validate(ctx))

        // Validate optional Interceptors
        for i, interceptor := range t.Interceptors </span><span class="cov8" title="1">{
                errs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf("interceptors[%d]", i)))
        }</span>

        <span class="cov8" title="1">return errs</span>
}

func (t TriggerSpecTemplate) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        // Optional explicit match
        if t.APIVersion != "" </span><span class="cov8" title="1">{
                if t.APIVersion != "v1alpha1" &amp;&amp; t.APIVersion != "v1beta1" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "template.apiVersion"))
                }</span>
        }

        <span class="cov8" title="1">switch </span>{
        case t.Spec != nil &amp;&amp; t.Ref != nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMultipleOneOf("template.spec", "template.ref"))</span>
        case t.Spec == nil &amp;&amp; t.Ref == nil:<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingOneOf("template.spec", "template.ref"))</span>
        case t.Spec != nil:<span class="cov8" title="1">
                errs = errs.Also(t.Spec.validate(ctx))</span>
        case t.Ref == nil || *t.Ref == "":<span class="cov8" title="1">
                errs = errs.Also(apis.ErrMissingField("template.ref"))</span>
        }
        <span class="cov8" title="1">return errs</span>
}

// revive:disable:unused-parameter

func (t triggerSpecBindingArray) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        for i, b := range t </span><span class="cov8" title="1">{
                switch </span>{
                case b.Ref != "":<span class="cov8" title="1">
                        switch </span>{
                        case b.Name != "":<span class="cov8" title="1"> // Cannot specify both Ref and Name
                                errs = errs.Also(apis.ErrMultipleOneOf(fmt.Sprintf("bindings[%d].ref", i), fmt.Sprintf("bindings[%d].name", i)))</span>
                        case b.Kind != NamespacedTriggerBindingKind &amp;&amp; b.Kind != ClusterTriggerBindingKind:<span class="cov8" title="1"> // Kind must be valid
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), fmt.Sprintf("bindings[%d].kind", i)))</span>
                        }
                case b.Name != "":<span class="cov8" title="1">
                        if b.Value == nil </span><span class="cov8" title="1">{ // Value is mandatory if Name is specified
                                errs = errs.Also(apis.ErrMissingField(fmt.Sprintf("bindings[%d].value", i)))
                        }</span>
                default:<span class="cov8" title="1">
                        errs = errs.Also(apis.ErrMissingOneOf(fmt.Sprintf("bindings[%d].ref", i), fmt.Sprintf("bindings[%d].spec", i), fmt.Sprintf("bindings[%d].name", i)))</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}

func (i *TriggerInterceptor) validate(ctx context.Context) (errs *apis.FieldError) <span class="cov8" title="1">{
        if i.Webhook == nil </span><span class="cov8" title="1">{
                if i.Ref.Name == "" </span><span class="cov8" title="1">{ // Check to see if Interceptor referenced using Ref
                        errs = errs.Also(apis.ErrMissingField("interceptor"))
                }</span>
        }

        <span class="cov8" title="1">if i.Webhook != nil </span><span class="cov8" title="1">{ // TODO: This should be an error?
                w := i.Webhook
                if i.Webhook.ObjectRef == nil </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef"))
                }</span> else<span class="cov8" title="1"> {
                        if w.ObjectRef.Kind == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef.kind"))
                        }</span> else<span class="cov8" title="1"> if w.ObjectRef.Kind != "Service" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid kind"), "interceptor.webhook.objectRef.kind"))
                        }</span>

                        // Optional explicit match
                        <span class="cov8" title="1">if w.ObjectRef.APIVersion == "" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrMissingField("interceptor.webhook.objectRef.apiVersion"))
                        }</span> else<span class="cov8" title="1"> if w.ObjectRef.APIVersion != "v1" </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid apiVersion"), "interceptor.webhook.objectRef.apiVersion"))
                        }</span>
                }

                <span class="cov8" title="1">for i, header := range w.Header </span><span class="cov8" title="1">{
                        // Enforce non-empty canonical header keys
                        if len(header.Name) == 0 || http.CanonicalHeaderKey(header.Name) != header.Name </span><span class="cov8" title="1">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header name"), fmt.Sprintf("interceptor.webhook.header[%d].name", i)))
                        }</span>
                        // Enforce non-empty header values
                        <span class="cov8" title="1">if header.Value.Type == pipelinev1.ParamTypeString </span><span class="cov8" title="1">{
                                if len(header.Value.StringVal) == 0 </span><span class="cov8" title="1">{
                                        errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                                }</span>
                        } else<span class="cov0" title="0"> if len(header.Value.ArrayVal) == 0 </span><span class="cov0" title="0">{
                                errs = errs.Also(apis.ErrInvalidValue(errors.New("invalid header value"), fmt.Sprintf("interceptor.webhook.header[%d].value", i)))
                        }</span>
                }
        }
        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1beta1

import (
        "context"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "knative.dev/pkg/apis"
)

// ValidateEnabledAPIFields checks that the enable-api-fields feature gate is set
// to the wantVersion value and, if not, returns an error stating which feature
// is dependent on the version and what the current version actually is.
func ValidateEnabledAPIFields(ctx context.Context, featureName, wantVersion string) *apis.FieldError <span class="cov8" title="1">{
        if apis.IsInDelete(ctx) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">currentVersion := config.FromContextOrDefaults(ctx).FeatureFlags.EnableAPIFields
        if currentVersion != wantVersion </span><span class="cov8" title="1">{
                var errs *apis.FieldError
                message := fmt.Sprintf(`%s requires "enable-api-fields" feature gate to be %q but it is %q`, featureName, wantVersion, currentVersion)
                return errs.Also(apis.ErrGeneric(message))
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package triggers

import (
        "knative.dev/pkg/apis"
)

const (
        PayloadValidationAnnotation = "tekton.dev/payload-validation"
)

func ValidateAnnotations(annotations map[string]string) *apis.FieldError <span class="cov8" title="1">{
        var errs *apis.FieldError

        if value, ok := annotations[PayloadValidationAnnotation]; ok </span><span class="cov8" title="1">{
                if value != "true" &amp;&amp; value != "false" </span><span class="cov8" title="1">{
                        errs = errs.Also(apis.ErrInvalidValue(PayloadValidationAnnotation+" annotation must have value 'true' or 'false'", "metadata.annotations"))
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bootstrap

import (
        "context"
        "fmt"

        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        "k8s.io/client-go/kubernetes"
)

type Bootstrapper struct {
        config           *Config
        kubeClient       kubernetes.Interface
        triggersClient   triggersclientset.Interface
        installer        *Installer
        rbacManager      *RBACManager
        templatesManager *TemplatesManager
        githubManager    *GitHubManager
}

// New creates a new bootstrapper
func New(config *Config) (*Bootstrapper, error) <span class="cov0" title="0">{
        var (
                kubeClient     kubernetes.Interface
                triggersClient triggersclientset.Interface
                err            error
        )
        kubeClient, err = kubernetes.NewForConfig(config.KubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create kubernetes client: %w", err)
        }</span>

        <span class="cov0" title="0">triggersClient, err = triggersclientset.NewForConfig(config.KubeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create triggers client: %w", err)
        }</span>

        // Create component managers
        <span class="cov0" title="0">installer := NewInstaller(kubeClient, config)
        rbacManager := NewRBACManager(kubeClient, config)
        templatesManager := NewTemplatesManager(triggersClient, config)
        githubManager := NewGitHubManager(config)

        return &amp;Bootstrapper{
                config:           config,
                kubeClient:       kubeClient,
                triggersClient:   triggersClient,
                installer:        installer,
                rbacManager:      rbacManager,
                templatesManager: templatesManager,
                githubManager:    githubManager,
        }, nil</span>
}

// Run executes the bootstrap process
func (b *Bootstrapper) Run(ctx context.Context) error <span class="cov0" title="0">{
        // Check and install Tekton Pipelines
        if err := b.installer.InstallTektonPipelines(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ensure pipelines: %w", err)
        }</span>

        // Install Tekton Triggers
        <span class="cov0" title="0">if err := b.installer.InstallTriggers(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install triggers: %w", err)
        }</span>

        // Create/verify namespace
        <span class="cov0" title="0">if err := b.rbacManager.CreateNamespace(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create namespace: %w", err)
        }</span>

        // Set up RBAC
        <span class="cov0" title="0">if err := b.rbacManager.SetupRBAC(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup RBAC: %w", err)
        }</span>

        // Create Trigger resources (EventListener, TriggerTemplate, TriggerBinding)
        <span class="cov0" title="0">if err := b.templatesManager.CreateTriggerResources(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create trigger resources: %w", err)
        }</span>

        // Create examples (Pipeline)
        <span class="cov0" title="0">if err := b.templatesManager.CreateExamples(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create examples: %w", err)
        }</span>

        // Check existing webhooks
        <span class="cov0" title="0">if b.config.GitHubToken != "" </span><span class="cov0" title="0">{
                if err := b.githubManager.SetupWebhook(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to setup webhook: %w", err)
                }</span>
        }
        <span class="cov0" title="0">if err := b.rbacManager.CreateWebhookSecret(ctx, b.githubManager.GetWebhookSecret()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create webhook secret: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bootstrap

import (
        "context"
        "fmt"
        "io"
        "net/http"
        "os"
        "os/exec"
        "path/filepath"
)

const (
        githubBaseURL = "https://raw.githubusercontent.com/tektoncd/triggers/main"
)

func applyFileFromGitHub(filePath string) error <span class="cov0" title="0">{
        ctx := context.Background()
        // Download from GitHub
        githubURL := fmt.Sprintf("%s/%s", githubBaseURL, filePath)

        // Create temporary file
        tmpFile, err := os.CreateTemp("", filepath.Base(filePath)+"-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tmpFile.Name()) // Always clean up

        // Download content
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, githubURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download %s: %w", githubURL, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download %s: HTTP %d", githubURL, resp.StatusCode)
        }</span>

        // Write to temp file
        <span class="cov0" title="0">if _, err = io.Copy(tmpFile, resp.Body); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write downloaded content: %w", err)
        }</span>
        <span class="cov0" title="0">tmpFile.Close()

        // Apply with kubectl
        // #nosec G204 -- kubectl is a known binary, tmpFile.Name() is a controlled temp file path
        cmd := exec.Command("kubectl", "apply", "-f", tmpFile.Name(), "-n", "getting-started")
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubectl apply failed for %s: %w\nOutput: %s", filePath, err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bootstrap

import (
        "bytes"
        "context"
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "strings"
)

type GitHubManager struct {
        config *Config
        client *http.Client
}

func NewGitHubManager(config *Config) *GitHubManager <span class="cov8" title="1">{
        return &amp;GitHubManager{
                config: config,
                client: &amp;http.Client{},
        }
}</span>

// WebhookPayload represents the GitHub webhook payload
type WebhookPayload struct {
        Name   string        `json:"name"`
        Config WebhookConfig `json:"config"`
        Events []string      `json:"events"`
        Active bool          `json:"active"`
}

// WebhookConfig represents webhook configuration
type WebhookConfig struct {
        URL         string `json:"url"`
        ContentType string `json:"content_type"`
        Secret      string `json:"secret,omitempty"`
        InsecureSSL string `json:"insecure_ssl"`
}

// SetupWebhook creates a GitHub webhook for the repository
func (g *GitHubManager) SetupWebhook(ctx context.Context) error <span class="cov0" title="0">{
        // Generate webhook secret
        secret := g.config.WebhookSecret
        if secret == "" </span><span class="cov0" title="0">{
                var err error
                secret, err = generateWebhookSecret()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate webhook secret: %w", err)
                }</span>
                <span class="cov0" title="0">g.config.WebhookSecret = secret</span>
        }

        // Create webhook
        <span class="cov0" title="0">webhookURL := fmt.Sprintf("https://%s/hooks", g.config.PublicDomain)

        payload := WebhookPayload{
                Name: "web",
                Config: WebhookConfig{
                        URL:         webhookURL,
                        ContentType: "json",
                        Secret:      secret,
                        InsecureSSL: "0", // Always use SSL in production
                },
                Events: []string{"push", "pull_request"},
                Active: true,
        }

        if err := g.createWebhook(ctx, payload); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create webhook: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// createWebhook makes the API call to create the webhook
func (g *GitHubManager) createWebhook(ctx context.Context, payload WebhookPayload) error <span class="cov0" title="0">{
        jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("https://api.github.com/repos/%s/hooks", g.config.GitHubRepo)
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "token "+g.config.GitHubToken)
        req.Header.Set("Accept", "application/vnd.github.v3+json")
        req.Header.Set("Content-Type", "application/json")

        resp, err := g.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                body, _ := io.ReadAll(resp.Body)
                if resp.StatusCode == http.StatusUnprocessableEntity &amp;&amp; strings.Contains(string(body), "Hook already exists") </span><span class="cov0" title="0">{
                        return errors.New("webhook already exists")
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("GitHub API error: %s - %s", resp.Status, string(body))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// generateWebhookSecret generates a secure random webhook secret
func generateWebhookSecret() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// GetWebhookSecret returns the webhook secret for storing in Kubernetes
func (g *GitHubManager) GetWebhookSecret() string <span class="cov8" title="1">{
        return g.config.WebhookSecret
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bootstrap

import (
        "context"
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "os/exec"
        "time"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/wait"
        "k8s.io/client-go/kubernetes"
)

type Installer struct {
        kubeClient      kubernetes.Interface
        config          *Config
        tektonNamespace string
}

func NewInstaller(kubeClient kubernetes.Interface, config *Config) *Installer <span class="cov8" title="1">{
        return &amp;Installer{
                kubeClient:      kubeClient,
                config:          config,
                tektonNamespace: "",
        }
}</span>

func (i *Installer) getTektonNamespace(ctx context.Context) string <span class="cov8" title="1">{
        if i.tektonNamespace != "" </span><span class="cov8" title="1">{
                return i.tektonNamespace
        }</span>

        <span class="cov8" title="1">namespaces := []string{
                "openshift-pipelines",
                "tekton-pipelines",
        }

        for _, ns := range namespaces </span><span class="cov8" title="1">{
                _, err := i.kubeClient.AppsV1().Deployments(ns).Get(ctx, "tekton-pipelines-controller", metav1.GetOptions{})
                if err == nil </span><span class="cov8" title="1">{
                        i.tektonNamespace = ns
                        log.Printf("Tekton Pipelines is installed in %s namespace.", ns)
                        return i.tektonNamespace
                }</span>
        }

        // Default to tekton-pipelines if not found
        <span class="cov8" title="1">i.tektonNamespace = "tekton-pipelines"
        return i.tektonNamespace</span>
}

// common helper for polling
func (i *Installer) pollUntilReady(ctx context.Context, timeout time.Duration, condition wait.ConditionWithContextFunc) error <span class="cov0" title="0">{
        deadline := time.Now().Add(timeout)
        ctx, cancel := context.WithDeadline(ctx, deadline)
        defer cancel()

        return wait.PollUntilContextTimeout(ctx, 5*time.Second, timeout, true, condition)
}</span>

// waitForNamespace waits for a namespace to exist and ready
func (i *Installer) waitForNamespace(ctx context.Context, namespace string, timeout time.Duration) error <span class="cov0" title="0">{
        if i.kubeClient == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return i.pollUntilReady(ctx, timeout, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                ns, err := i.kubeClient.CoreV1().Namespaces().Get(ctx, namespace, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }

                // Check if namespace is ready
                <span class="cov0" title="0">if ns.Status.Phase != "Active" </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">return true, nil</span>
        })
}

// waitForDeployment waits for a deployment to ready
func (i *Installer) waitForDeployment(ctx context.Context, namespace, name string, timeout time.Duration) error <span class="cov0" title="0">{
        if i.kubeClient == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return i.pollUntilReady(ctx, timeout, func(ctx context.Context) (bool, error) </span><span class="cov0" title="0">{
                deployment, err := i.kubeClient.AppsV1().Deployments(namespace).Get(ctx, name, metav1.GetOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                        <span class="cov0" title="0">return false, err</span>
                }

                // Check if deployment is ready
                <span class="cov0" title="0">if deployment.Status.ReadyReplicas == 0 || deployment.Status.ReadyReplicas &lt; *deployment.Spec.Replicas </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                <span class="cov0" title="0">return true, nil</span>
        })
}

// InstallTriggers installs Tekton Triggers CRDs and controllers
func (i *Installer) InstallTriggers(ctx context.Context) error <span class="cov0" title="0">{
        // Check if Triggers is already installed
        if i.isTriggersInstalled(ctx) </span><span class="cov0" title="0">{
                log.Println("Tekton Triggers is installed and running.")
                return nil
        }</span>
        <span class="cov0" title="0">if err := i.downloadAndApplyTriggers(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install Triggers: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Waiting for Tekton Triggers to be ready...")
        return i.waitForTriggersReady(ctx)</span>
}

func (i *Installer) isTriggersInstalled(ctx context.Context) bool <span class="cov8" title="1">{
        if i.kubeClient == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">ns := i.getTektonNamespace(ctx)
        deployment, err := i.kubeClient.AppsV1().Deployments(ns).Get(ctx, "tekton-triggers-controller", metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return deployment.Status.ReadyReplicas &gt; 0</span>
}

// waitForTriggersReady waits for Tekton Triggers components to be ready
func (i *Installer) waitForTriggersReady(ctx context.Context) error <span class="cov0" title="0">{
        ns := i.getTektonNamespace(ctx)
        if err := i.waitForNamespace(ctx, ns, 2*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout waiting for %s namespace: %w", ns, err)
        }</span>

        // Wait for Triggers controller deployment to be ready
        <span class="cov0" title="0">if err := i.waitForDeployment(ctx, ns, "tekton-triggers-controller", 3*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout waiting for tekton-triggers-controller: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Tekton Triggers is ready!")
        return nil</span>
}

// InstallTektonPipelines installs Tekton Pipelines if requested and not present
func (i *Installer) InstallTektonPipelines(ctx context.Context) error <span class="cov0" title="0">{
        if !i.config.InstallDeps </span><span class="cov0" title="0">{
                // Check if Pipelines is installed, it's required for Triggers
                if !i.isPipelinesInstalled(ctx) </span><span class="cov0" title="0">{
                        return errors.New("tekton Pipelines is not installed and is required for Triggers")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if i.isPipelinesInstalled(ctx) </span><span class="cov0" title="0">{
                log.Println("Tekton Pipelines is installed and running.")
                return nil
        }</span>

        <span class="cov0" title="0">if err := i.downloadAndApplyPipelines(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install Pipelines: %w", err)
        }</span>

        // Wait for Pipelines to be ready before continuing
        <span class="cov0" title="0">log.Println("Waiting for Pipelines to be ready, this may take a minute or two...")
        if err := i.waitForPipelinesReady(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to wait for Pipelines: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Tekton Pipelines is ready!")
        return nil</span>
}

// isPipelinesInstalled checks if Tekton Pipelines is installed and ready
func (i *Installer) isPipelinesInstalled(ctx context.Context) bool <span class="cov8" title="1">{
        if i.kubeClient == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">ns := i.getTektonNamespace(ctx)
        deployment, err := i.kubeClient.AppsV1().Deployments(ns).Get(ctx, "tekton-pipelines-controller", metav1.GetOptions{})
        if err != nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return deployment.Status.ReadyReplicas &gt; 0</span>
}

func (i *Installer) downloadAndApplyTriggers(ctx context.Context) error <span class="cov0" title="0">{
        triggersURL := "https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml"
        interceptorsURL := "https://storage.googleapis.com/tekton-releases/triggers/latest/interceptors.yaml"

        if err := i.downloadAndApplyManifest(ctx, triggersURL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply triggers manifest: %w", err)
        }</span>

        <span class="cov0" title="0">if err := i.downloadAndApplyManifest(ctx, interceptorsURL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply interceptors manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (i *Installer) downloadAndApplyPipelines(ctx context.Context) error <span class="cov0" title="0">{
        pipelinesURL := "https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml"

        if err := i.downloadAndApplyManifest(ctx, pipelinesURL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply pipelines manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// downloadAndApplyManifest downloads a YAML manifest from URL and applies it to the cluster
func (i *Installer) downloadAndApplyManifest(ctx context.Context, url string) error <span class="cov0" title="0">{
        // Download the manifest
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download manifest: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download manifest: HTTP %d", resp.StatusCode)
        }</span>

        // Read the YAML content
        <span class="cov0" title="0">yamlContent, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read manifest: %w", err)
        }</span>

        // Apply the manifest using kubectl-like logic
        <span class="cov0" title="0">if err := i.applyYAMLManifest(ctx, yamlContent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// applyYAMLManifest applies a multi-document YAML manifest
func (i *Installer) applyYAMLManifest(ctx context.Context, yamlContent []byte) error <span class="cov0" title="0">{
        if err := i.applyManifestViaKubectl(ctx, yamlContent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply manifest: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// applyManifestViaKubectl applies YAML using kubectl apply
func (i *Installer) applyManifestViaKubectl(ctx context.Context, yamlContent []byte) error <span class="cov0" title="0">{
        // Write YAML to temporary file
        tmpFile, err := os.CreateTemp("", "tekton-manifest-*.yaml")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create temp file: %w", err)
        }</span>
        <span class="cov0" title="0">defer os.Remove(tmpFile.Name())
        defer tmpFile.Close()

        if _, err := tmpFile.Write(yamlContent); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write manifest: %w", err)
        }</span>
        <span class="cov0" title="0">tmpFile.Close()

        kubeconfigFlag := ""
        if i.config.KubeConfig != nil </span><span class="cov0" title="0">{
                kubeconfigFlag = "--kubeconfig=" + os.Getenv("HOME") + "/.kube/config"
        }</span>

        // #nosec G204 -- kubectl is a known binary, tmpFile.Name() is a controlled temp file path
        <span class="cov0" title="0">cmd := exec.CommandContext(ctx, "kubectl", "apply", "-f", tmpFile.Name())
        if kubeconfigFlag != "" </span><span class="cov0" title="0">{
                // #nosec G204 -- kubectl is a known binary, tmpFile.Name() is a controlled temp file path
                cmd = exec.CommandContext(ctx, "kubectl", kubeconfigFlag, "apply", "-f", tmpFile.Name())
        }</span>

        <span class="cov0" title="0">output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("kubectl apply failed: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// waitForPipelinesReady waits for Tekton Pipelines to be fully ready
func (i *Installer) waitForPipelinesReady(ctx context.Context) error <span class="cov0" title="0">{
        ns := i.getTektonNamespace(ctx)

        // Wait for the Tekton namespace
        if err := i.waitForNamespace(ctx, ns, 2*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout waiting for %s namespace: %w", ns, err)
        }</span>

        // Wait for Pipelines controller deployment to be ready
        <span class="cov0" title="0">if err := i.waitForDeployment(ctx, ns, "tekton-pipelines-controller", 5*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout waiting for tekton-pipelines-controller: %w", err)
        }</span>

        // Wait for webhook deployment to be ready
        <span class="cov0" title="0">if err := i.waitForDeployment(ctx, ns, "tekton-pipelines-webhook", 3*time.Minute); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("timeout waiting for tekton-pipelines-webhook: %w", err)
        }</span>

        // buffer for webhook service to be fully responsive
        <span class="cov0" title="0">time.Sleep(10 * time.Second)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bootstrap

import (
        "context"
        "fmt"

        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/client-go/kubernetes"
)

type RBACManager struct {
        kubeClient kubernetes.Interface
        config     *Config
}

func NewRBACManager(kubeClient kubernetes.Interface, config *Config) *RBACManager <span class="cov0" title="0">{
        return &amp;RBACManager{
                kubeClient: kubeClient,
                config:     config,
        }
}</span>

// CreateNamespace creates the target namespace if it doesn't exist
func (r *RBACManager) CreateNamespace(ctx context.Context) error <span class="cov0" title="0">{
        ns := &amp;corev1.Namespace{
                ObjectMeta: metav1.ObjectMeta{
                        Name: r.config.Namespace,
                        Labels: map[string]string{
                                "app.kubernetes.io/part-of": "tekton-triggers",
                                "tekton.dev/bootstrap":      "true",
                        },
                },
        }

        _, err := r.kubeClient.CoreV1().Namespaces().Create(ctx, ns, metav1.CreateOptions{})
        if apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create namespace: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetupRBAC creates necessary service accounts, roles, and bindings
func (r *RBACManager) SetupRBAC(ctx context.Context) error <span class="cov0" title="0">{
        // Apply admin-role.yaml (ServiceAccount + RoleBinding + ClusterRoleBinding)
        if err := r.applyGettingStartedRBAC(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Apply webhook-role.yaml (Role + ServiceAccount + RoleBinding for webhook tasks)
        <span class="cov0" title="0">if err := r.applyWebhookRBAC(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// applyGettingStartedRBAC applies the admin-role.yaml from getting-started docs
func (r *RBACManager) applyGettingStartedRBAC(ctx context.Context) error <span class="cov0" title="0">{
        if err := applyFileFromGitHub("docs/getting-started/rbac/admin-role.yaml"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply admin-role.yaml: %w", err)
        }</span>

        <span class="cov0" title="0">if err := applyFileFromGitHub("docs/getting-started/rbac/clusterrolebinding.yaml"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply clusterrolebinding.yaml: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// applyWebhookRBAC applies webhook-role.yaml from getting-started docs
func (r *RBACManager) applyWebhookRBAC(ctx context.Context) error <span class="cov0" title="0">{
        if err := applyFileFromGitHub("docs/getting-started/rbac/webhook-role.yaml"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply webhook-role.yaml: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateWebhookSecret creates a Kubernetes secret for webhook authentication
func (r *RBACManager) CreateWebhookSecret(ctx context.Context, webhookSecret string) error <span class="cov0" title="0">{
        secret := &amp;corev1.Secret{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      "github-webhook-secret",
                        Namespace: r.config.Namespace,
                        Labels: map[string]string{
                                "app.kubernetes.io/part-of": "tekton-triggers",
                                "tekton.dev/bootstrap":      "true",
                        },
                },
                Type: corev1.SecretTypeOpaque,
                Data: map[string][]byte{
                        "webhook-secret": []byte(webhookSecret),
                },
        }

        _, err := r.kubeClient.CoreV1().Secrets(r.config.Namespace).Create(ctx, secret, metav1.CreateOptions{})
        if apierrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create webhook secret: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
Copyright 2025 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bootstrap

import (
        "context"
        "fmt"

        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
)

// TemplatesManager handles creation of Trigger templates and resources
type TemplatesManager struct {
        triggersClient triggersclientset.Interface
        config         *Config
}

// NewTemplatesManager creates a new templates manager
func NewTemplatesManager(triggersClient triggersclientset.Interface, config *Config) *TemplatesManager <span class="cov0" title="0">{
        return &amp;TemplatesManager{
                triggersClient: triggersClient,
                config:         config,
        }
}</span>

// CreateTriggerResources creates Trigger resources from getting-started docs
func (t *TemplatesManager) CreateTriggerResources(ctx context.Context) error <span class="cov0" title="0">{
        return t.applyGettingStartedTriggers(ctx)
}</span>

// CreateExamples creates the Pipeline from getting-started docs
func (t *TemplatesManager) CreateExamples(ctx context.Context) error <span class="cov0" title="0">{
        return t.applyGettingStartedPipeline(ctx)
}</span>

// applyGettingStartedTriggers applies triggers.yaml from getting-started docs
func (t *TemplatesManager) applyGettingStartedTriggers(ctx context.Context) error <span class="cov0" title="0">{
        if err := applyFileFromGitHub("docs/getting-started/triggers.yaml"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply triggers.yaml: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// applyGettingStartedPipeline applies pipeline.yaml from getting-started docs
func (t *TemplatesManager) applyGettingStartedPipeline(ctx context.Context) error <span class="cov0" title="0">{
        if err := applyFileFromGitHub("docs/getting-started/pipeline.yaml"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply pipeline.yaml: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package dynamic

import (
        "encoding/json"

        logger "github.com/sirupsen/logrus"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "knative.dev/pkg/apis/duck/v1beta1"
)

func GetConditions(existingData *unstructured.Unstructured) (v1beta1.Conditions, interface{}, error) <span class="cov8" title="1">{
        statusData, ok, err := unstructured.NestedMap(existingData.Object, "status")
        if !ok || err != nil </span><span class="cov8" title="1">{
                // No status in the created object, it is weird but let's not fail
                logger.Warn("empty status for the created custom object")
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">conditionData, ok, err := unstructured.NestedFieldCopy(statusData, "conditions")
        if !ok || err != nil </span><span class="cov8" title="1">{
                // No conditions in the created object, it is weird but let's not fail
                logger.Warn("empty status conditions for the created custom object")
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">cMarshalledData, err := json.Marshal(conditionData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">var customConditions v1beta1.Conditions
        if err = json.Unmarshal(cMarshalledData, &amp;customConditions); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return customConditions, statusData["url"], nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package dynamic

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/client-go/tools/cache"
        "knative.dev/pkg/apis/duck"
        "knative.dev/pkg/controller"
)

type ListableTracker interface {
        WatchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error
}

type listableTracker struct {
        informerFactory duck.InformerFactory
        impl            *controller.Impl
}

// NewListableTracker creates a new ListableTracker, backed by a TypedInformerFactory.
func NewListableTracker(ctx context.Context, getter func(ctx context.Context) duck.InformerFactory, impl *controller.Impl) ListableTracker <span class="cov0" title="0">{
        return &amp;listableTracker{
                informerFactory: getter(ctx),
                impl:            impl,
        }
}</span>

func (t *listableTracker) WatchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error <span class="cov0" title="0">{
        return t.watchOnDynamicObject(ctx, gvr)
}</span>

func (t *listableTracker) watchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error <span class="cov0" title="0">{
        shInformer, _, err := t.informerFactory.Get(ctx, gvr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, err = shInformer.AddEventHandler(cache.FilteringResourceEventHandler{
                FilterFunc: controller.FilterController(&amp;v1beta1.EventListener{}),
                Handler:    controller.HandleAll(t.impl.EnqueueControllerOf),
        })
        return err</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package bitbucket

import (
        "context"
        "net/http"

        gh "github.com/google/go-github/v31/github"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "google.golang.org/grpc/codes"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        SecretRef *triggersv1.SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">headers := interceptors.Canonical(r.Header)

        // Check if the event type is in the allow-list
        if p.EventTypes != nil </span><span class="cov8" title="1">{
                actualEvent := http.Header(r.Header).Get("X-Event-Key")
                isAllowed := false
                for _, allowedEvent := range p.EventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                isAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isAllowed </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "event type %s is not allowed", actualEvent)
                }</span>
        }

        // Next validate secrets if set
        <span class="cov8" title="1">if p.SecretRef != nil </span><span class="cov8" title="1">{
                // Check the secret to see if it is empty
                if p.SecretRef.SecretKey == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "bitbucket interceptor secretRef.secretKey is empty")
                }</span>
                <span class="cov8" title="1">header := headers.Get("X-Hub-Signature")
                if header == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.InvalidArgument, "no X-Hub-Signature header set")
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
                secretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                <span class="cov8" title="1">if err := gh.ValidateSignature(header, []byte(r.Body), secretToken); err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error validating signature: %s", err.Error())
                }</span>
        }

        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue: true,
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cel

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "reflect"

        "github.com/tektoncd/triggers/pkg/interceptors"

        structpb "github.com/golang/protobuf/ptypes/struct"
        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/decls"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
        "github.com/google/cel-go/common/types/traits"
        celext "github.com/google/cel-go/ext"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tidwall/sjson"
        "google.golang.org/grpc/codes"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

// InterceptorImpl implements a CEL based interceptor that uses CEL expressions
// against the incoming body and headers to match, if the expression returns
// a true value, then the interception is "successful".
type InterceptorImpl struct {
        SecretGetter     interceptors.SecretGetter
        CEL              *InterceptorParams
        TriggerNamespace string
}

var (
        structType = reflect.TypeOf(&amp;structpb.Value{})
        listType   = reflect.TypeOf(&amp;structpb.ListValue{})
        mapType    = reflect.TypeOf(&amp;structpb.Struct{})
)

// NewInterceptor creates a prepopulated Interceptor.
func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        Filter string `json:"filter,omitempty"`
        // +listType=atomic
        Overlays []Overlay `json:"overlays,omitempty"`
}

// Overlay provides a way to modify the request body using CEL expressions
type Overlay struct {
        Key        string `json:"key,omitempty"`
        Expression string `json:"expression,omitempty"`
}

func evaluate(expr string, env *cel.Env, data map[string]interface{}) (ref.Val, error) <span class="cov8" title="1">{
        parsed, issues := env.Parse(expr)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse expression %#v: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">checked, issues := env.Check(parsed)
        if issues != nil &amp;&amp; issues.Err() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expression %#v check failed: %w", expr, issues.Err())
        }</span>

        <span class="cov8" title="1">prg, err := env.Program(checked, cel.EvalOptions(cel.OptOptimize))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("expression %#v failed to create a Program: %w", expr, err)
        }</span>

        <span class="cov8" title="1">out, _, err := prg.Eval(data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("expression %#v failed to evaluate: %w", expr, err)
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func makeCelEnv(ctx context.Context, ns string, sg interceptors.SecretGetter) (*cel.Env, error) <span class="cov8" title="1">{
        mapStrDyn := types.NewMapType(types.StringType, types.DynType)

        return cel.NewEnv(
                Triggers(ctx, ns, sg),
                celext.Strings(),
                celext.Encoders(),
                celext.Sets(),
                celext.Lists(),
                celext.Math(),
                cel.VariableDecls(
                        decls.NewVariable("body", mapStrDyn),
                        decls.NewVariable("header", mapStrDyn),
                        decls.NewVariable("extensions", mapStrDyn),
                        decls.NewVariable("requestURL", types.StringType),
                ))
}</span>

func makeEvalContext(body []byte, h http.Header, url string, extensions map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        var jsonMap map[string]interface{}
        err := json.Unmarshal(body, &amp;jsonMap)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse the body as JSON: %w", err)
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{
                "body":       jsonMap,
                "header":     h,
                "requestURL": url,
                "extensions": extensions,
        }, nil</span>
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">if r.Context == nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.InvalidArgument, "no request context passed")
        }</span>

        <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
        env, err := makeCelEnv(ctx, ns, w.SecretGetter)
        if err != nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.Internal, "error creating cel environment: %v", err)
        }</span>

        <span class="cov8" title="1">var payload = []byte(`{}`)
        if r.Body != "" </span><span class="cov8" title="1">{
                payload = []byte(r.Body)
        }</span>

        <span class="cov8" title="1">evalContext, err := makeEvalContext(payload, r.Header, r.Context.EventURL, r.Extensions)
        if err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "error making the evaluation context: %v", err)
        }</span>

        <span class="cov8" title="1">if p.Filter != "" </span><span class="cov8" title="1">{
                out, err := evaluate(p.Filter, env, evalContext)

                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "error evaluating cel expression: %v", err)
                }</span>

                <span class="cov8" title="1">if out != types.True </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "expression %s did not return true", p.Filter)
                }</span>
        }

        // Empty JSON body bytes.
        // We use []byte instead of map[string]interface{} to allow ovewriting keys using sjson.
        <span class="cov8" title="1">var extensions []byte
        for _, u := range p.Overlays </span><span class="cov8" title="1">{
                val, err := evaluate(u.Expression, env, evalContext)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "error evaluating cel expression: %v", err)
                }</span>

                <span class="cov8" title="1">var raw interface{}
                var b []byte

                switch val.(type) </span>{
                // this causes types.Bytes to be rendered as a Base64 string this is
                // because the Go JSON Encoder encodes []bytes this way, see
                // https://golang.org/pkg/encoding/json/#Marshal
                //
                // An alternative might be to return " + val + " for types.Bytes to
                // simulate the JSON encoding.
                case types.String, types.Bytes:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(structType)
                        if err == nil </span><span class="cov8" title="1">{
                                b, err = raw.(*structpb.Value).MarshalJSON()
                        }</span>
                case types.Double, types.Int:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(structType)
                        if err == nil </span><span class="cov8" title="1">{
                                b, err = raw.(*structpb.Value).MarshalJSON()
                        }</span>
                case traits.Lister:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(listType)
                        if err == nil </span><span class="cov8" title="1">{
                                s, err := protojson.Marshal(raw.(proto.Message))
                                if err == nil </span><span class="cov8" title="1">{
                                        b = s
                                }</span>
                        }
                case traits.Mapper:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(mapType)
                        if err == nil </span><span class="cov8" title="1">{
                                s, err := protojson.Marshal(raw.(proto.Message))
                                if err == nil </span><span class="cov8" title="1">{
                                        b = s
                                }</span>
                        }
                case types.Bool:<span class="cov8" title="1">
                        raw, err = val.ConvertToNative(structType)
                        if err == nil </span><span class="cov8" title="1">{
                                b, err = json.Marshal(raw.(*structpb.Value).GetBoolValue())
                        }</span>
                default:<span class="cov0" title="0">
                        raw, err = val.ConvertToNative(reflect.TypeOf([]byte{}))
                        if err == nil </span><span class="cov0" title="0">{
                                b = raw.([]byte)
                        }</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.Internal, "failed to convert overlay result to type: %v", err)
                }</span>

                // TODO: For backwards compatibility, consider also merging and returning the body back?
                <span class="cov8" title="1">if extensions == nil </span><span class="cov8" title="1">{
                        extensions = []byte("{}")
                }</span>
                <span class="cov8" title="1">extensions, err = sjson.SetRawBytes(extensions, u.Key, b)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.Internal, "failed to sjson for key '%s' to '%s': %v", u.Key, val, err)
                }</span>
        }

        <span class="cov8" title="1">if extensions == nil </span><span class="cov8" title="1">{
                return &amp;triggersv1.InterceptorResponse{
                        Continue: true,
                }
        }</span>

        <span class="cov8" title="1">extensionsMap := map[string]interface{}{}
        if err := json.Unmarshal(extensions, &amp;extensionsMap); err != nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.Internal, "failed to unmarshal extensions into map: %v", err)
        }</span>
        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue:   true,
                Extensions: extensionsMap,
        }</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package cel

import (
        "context"
        "crypto/subtle"
        "encoding/json"
        "net/http"
        "net/url"
        "reflect"
        "regexp"
        "strings"

        "github.com/google/cel-go/cel"
        "github.com/google/cel-go/common/types"
        "github.com/google/cel-go/common/types/ref"
        "github.com/google/cel-go/common/types/traits"
        "github.com/google/cel-go/interpreter/functions"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "sigs.k8s.io/yaml"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

// Triggers returns a cel.EnvOption to configure extended functions for
// Tekton CEL interceptor expressions.
//
// match
//
// Returns true if the specified provided header matches the provided string
// key.
//
// It is case insensitive; the header is canonicalised using the rules described
// here https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
//
//     &lt;header&gt;.match(&lt;string&gt;, &lt;string&gt;) -&gt; &lt;bool&gt;
//
// Examples:
//
//     header.match('X-Github-Event', 'push')
//
// canonical
//
// Can only be applied to the `header` key in the CEL expression context.
//
// Gets the first value associated with the given key. If there are no values
// associated with the key, returns "".
//
// It is case insensitive; the header is canonicalised using the rules described
// here https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey
//
//     &lt;header&gt;.canonical(&lt;string&gt;) -&gt; &lt;string&gt;
//
// Examples:
//
//     header.canonical('X-Github-Event') // returns 'push'
//
// truncate
//
// Returns a truncated copy of the string, at the given position.
//
// If the requested length is longer than the actual length, then the string
// will be returned unchanged.
//
//     &lt;string&gt;.truncate(&lt;int&gt;) -&gt; &lt;string&gt;
//
// Examples:
//
//     body.request.sha.truncate(7) // returns truncated string
//
// compareSecret
//
// Returns true if the string matches the value from a Kubernetes secret with
// the provided key, secret-name, namespace combination.
//
//     &lt;string&gt;.compareSecret(&lt;string&gt;, &lt;string&gt;, &lt;string&gt;) -&gt; &lt;bool&gt;
//
// Examples:
//
//     header.canonical('X-Secret-Token').compareSecret('key', 'secret-name', 'namespace')
//
// There is also an alternative compareSecret which accepts two parameters
//
// Returns true if the string matches the value from a Kubernetes secret with
// the provided key, secret-name combination, this default to the namespace the
// event-listener is in.
//
//     &lt;string&gt;.compareSecret(&lt;string&gt;, &lt;string&gt;) -&gt; &lt;bool&gt;
//
// Examples:
//
//     header.canonical('X-Secret-Token').compareSecret('key', 'secret-name')
//
// parseJSON
//
// Parses a string into a map of strings to dynamic values.
//
//     &lt;string&gt;.parseJSON() -&gt; map&lt;string, dyn&gt;
//
// Examples:
//
//     body.field.parseJSON().item
//
// parseURL
//
// Parses a URL (in the form of a string) into a map with keys representing the
// elements of the URL.
//
//     &lt;string&gt;.parseURL() -&gt; map&lt;string, dyn&gt;
//
// Examples:
//
//     'https://example.com/testing'.parseURL().host == 'example.com'
//
// parseYAML
//
// Parses a YAML string into a map of strings to dynamic values
//
//                 &lt;string&gt;.parseYAML() -&gt; map&lt;string, dyn&gt;
//
// Examples:
//
//                 body.field.parseYAML().item
//
// marshalJSON
//
// Returns the JSON encoding of 'jsonObjectOrList'.
//
//                 &lt;jsonObjectOrList&gt;.marshalJSON() -&gt; &lt;string&gt;
//
// Examples:
//
//                 body.jsonObjectOrList.marshalJSON()

// translate
//
// translate returns a copy of src, replacing matches of the with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.
//
//                 &lt;string&gt;.translate(string, string) -&gt; &lt;string&gt;
//
// Examples:
//
//                 "this is $aN INvalid5string ".replace("[^a-z0-9]+", "") == "thisisaninvalid5string"

// Triggers creates and returns a new cel.Lib with the triggers extensions.
func Triggers(ctx context.Context, ns string, sg interceptors.SecretGetter) cel.EnvOption <span class="cov8" title="1">{
        return cel.Lib(triggersLib{ctx: ctx, defaultNS: ns, secretGetter: sg})
}</span>

type triggersLib struct {
        ctx          context.Context //nolint:containedctx
        defaultNS    string
        secretGetter interceptors.SecretGetter
}

func (t triggersLib) CompileOptions() []cel.EnvOption <span class="cov8" title="1">{
        mapStrDyn := cel.MapType(cel.StringType, cel.DynType)
        listStrDyn := cel.ListType(cel.DynType)
        return []cel.EnvOption{
                cel.Function("match",
                        cel.MemberOverload("match_map_string_string", []*cel.Type{mapStrDyn, cel.StringType, cel.StringType}, cel.BoolType,
                                cel.FunctionBinding(matchHeader))),
                cel.Function("canonical",
                        cel.MemberOverload("canonical_map_string", []*cel.Type{mapStrDyn, cel.StringType}, cel.StringType,
                                cel.BinaryBinding(canonicalHeader))),
                cel.Function("truncate",
                        cel.MemberOverload("truncate_string_uint", []*cel.Type{cel.StringType, cel.IntType}, cel.StringType,
                                cel.BinaryBinding(truncateString))),
                cel.Function("compareSecret",
                        cel.MemberOverload("compareSecret_string_string_string", []*cel.Type{cel.StringType, cel.StringType, cel.StringType, cel.StringType}, cel.BoolType,
                                cel.FunctionBinding(makeCompareSecret(t.ctx, t.defaultNS, t.secretGetter))),
                        cel.MemberOverload("compareSecret_string_string", []*cel.Type{cel.StringType, cel.StringType, cel.StringType}, cel.BoolType,
                                cel.FunctionBinding(makeCompareSecret(t.ctx, t.defaultNS, t.secretGetter)))),
                cel.Function("parseJSON",
                        cel.MemberOverload("parseJSON_string", []*cel.Type{cel.StringType}, mapStrDyn,
                                cel.UnaryBinding(parseJSONString))),
                cel.Function("parseYAML",
                        cel.MemberOverload("parseYAML_string", []*cel.Type{cel.StringType}, mapStrDyn,
                                cel.UnaryBinding(parseYAMLString))),
                cel.Function("parseURL",
                        cel.MemberOverload("parseURL_string", []*cel.Type{cel.StringType}, mapStrDyn,
                                cel.UnaryBinding(parseURLString))),
                cel.Function("marshalJSON",
                        cel.MemberOverload("marshalJSON_map", []*cel.Type{mapStrDyn}, cel.StringType,
                                cel.UnaryBinding(marshalJSON)),
                        cel.MemberOverload("marshalJSON_list", []*cel.Type{listStrDyn}, cel.StringType,
                                cel.UnaryBinding(marshalJSON))),
                cel.Function("last",
                        cel.MemberOverload("last_list", []*cel.Type{listStrDyn}, cel.DynType,
                                cel.UnaryBinding(listLast))),
                cel.Function("first",
                        cel.MemberOverload("first_list", []*cel.Type{listStrDyn}, cel.DynType,
                                cel.UnaryBinding(listFirst))),
                cel.Function("translate",
                        cel.MemberOverload("translate_string_string", []*cel.Type{cel.StringType, cel.StringType, cel.StringType}, cel.StringType,
                                cel.FunctionBinding(translateString))),
        }
}</span>

func (t triggersLib) ProgramOptions() []cel.ProgramOption <span class="cov8" title="1">{
        return []cel.ProgramOption{}
}</span>

func matchHeader(vals ...ref.Val) ref.Val <span class="cov8" title="1">{
        h, err := vals[0].ConvertToNative(reflect.TypeOf(http.Header{}))
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to convert to http.Header: %w", err)
        }</span>

        <span class="cov8" title="1">key := vals[1].(types.String)
        val := vals[2].(types.String)
        return types.Bool(h.(http.Header).Get(string(key)) == string(val))</span>
}

func truncateString(lhs, rhs ref.Val) ref.Val <span class="cov8" title="1">{
        str := lhs.(types.String)
        n := rhs.(types.Int)
        return str[:max(n, types.Int(len(str)))]
}</span>

func canonicalHeader(lhs, rhs ref.Val) ref.Val <span class="cov8" title="1">{
        h, err := lhs.ConvertToNative(reflect.TypeOf(http.Header{}))
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to convert to http.Header: %w", err)
        }</span>

        <span class="cov8" title="1">key := rhs.(types.String)
        return types.String(h.(http.Header).Get(string(key)))</span>
}

// makeCompareSecret creates and returns a functions.FunctionOp that wraps the
// ns and client in a closure with a function that can compare the string.
func makeCompareSecret(ctx context.Context, defaultNS string, sg interceptors.SecretGetter) functions.FunctionOp <span class="cov8" title="1">{
        return func(vals ...ref.Val) ref.Val </span><span class="cov8" title="1">{
                var ok bool
                compareString, ok := vals[0].(types.String)
                if !ok </span><span class="cov0" title="0">{
                        return types.ValOrErr(compareString, "unexpected type '%v' passed to compareSecret", vals[0].Type())
                }</span>

                <span class="cov8" title="1">secretNS := types.String(defaultNS)

                secretName, ok := vals[2].(types.String)
                if !ok </span><span class="cov0" title="0">{
                        return types.ValOrErr(secretName, "unexpected type '%v' passed to compareSecret", vals[2].Type())
                }</span>

                <span class="cov8" title="1">secretKey, ok := vals[1].(types.String)
                if !ok </span><span class="cov0" title="0">{
                        return types.ValOrErr(secretKey, "unexpected type '%v' passed to compareSecret", vals[3].Type())
                }</span>

                <span class="cov8" title="1">secretRef := &amp;triggersv1.SecretRef{
                        SecretKey:  string(secretKey),
                        SecretName: string(secretName),
                }
                // GetSecretToken uses request as a cache key to cache secret lookup. Since multiple
                // triggers execute concurrently in separate goroutines, this cache is not very effective
                // for this use case
                secretToken, err := sg.Get(ctx, string(secretNS), secretRef)
                if err != nil </span><span class="cov8" title="1">{
                        return types.NewErr("failed to find secret '%#v' in compareSecret: %w", *secretRef, err)
                }</span>
                <span class="cov8" title="1">return types.Bool(subtle.ConstantTimeCompare(secretToken, []byte(compareString)) == 1)</span>
        }
}

func parseJSONString(val ref.Val) ref.Val <span class="cov8" title="1">{
        str := val.(types.String)
        decodedVal := map[string]interface{}{}
        err := json.Unmarshal([]byte(str), &amp;decodedVal)
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to decode '%v' in parseJSON: %w", str, err)
        }</span>
        <span class="cov8" title="1">r, err := types.NewRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to create a new registry in parseJSON: %w", err)
        }</span>

        <span class="cov8" title="1">return types.NewDynamicMap(r, decodedVal)</span>
}

func parseYAMLString(val ref.Val) ref.Val <span class="cov8" title="1">{
        str := val.(types.String)
        decodedVal := map[string]interface{}{}
        err := yaml.Unmarshal([]byte(str), &amp;decodedVal)
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to decode '%v' in parseYAML: %w", str, err)
        }</span>
        <span class="cov8" title="1">r, err := types.NewRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to create a new registry in parseJSON: %w", err)
        }</span>
        <span class="cov8" title="1">return types.NewDynamicMap(r, decodedVal)</span>
}

func parseURLString(val ref.Val) ref.Val <span class="cov8" title="1">{
        str := val.(types.String)
        parsed, err := url.Parse(string(str))
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to decode '%v' in parseURL: %w", str, err)
        }</span>
        <span class="cov8" title="1">r, err := types.NewRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to create a new registry in parseJSON: %w", err)
        }</span>
        <span class="cov8" title="1">return types.NewDynamicMap(r, urlToMap(parsed))</span>
}

func marshalJSON(val ref.Val) ref.Val <span class="cov8" title="1">{
        var typeDesc reflect.Type

        switch val.Type() </span>{
        case types.MapType:<span class="cov8" title="1">
                typeDesc = mapType</span>
        case types.ListType:<span class="cov8" title="1">
                typeDesc = listType</span>
        default:<span class="cov0" title="0">
                return types.ValOrErr(val, "unexpected type '%v' passed to marshalJSON", val.Type())</span>
        }

        <span class="cov8" title="1">nativeVal, err := val.ConvertToNative(typeDesc)
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to convert to native: %w", err)
        }</span>

        <span class="cov8" title="1">marshaledVal, err := json.Marshal(nativeVal)
        if err != nil </span><span class="cov0" title="0">{
                return types.NewErr("failed to marshal to json: %w", err)
        }</span>

        <span class="cov8" title="1">return types.String(marshaledVal)</span>
}

func listLast(val ref.Val) ref.Val <span class="cov8" title="1">{
        l := val.(traits.Lister)
        sz := l.Size().Value().(int64)

        if sz == 0 </span><span class="cov8" title="1">{
                return types.NullValue
        }</span>

        <span class="cov8" title="1">return l.Get(types.Int(sz - 1))</span>
}

func listFirst(val ref.Val) ref.Val <span class="cov8" title="1">{
        l := val.(traits.Lister)
        sz := l.Size().Value().(int64)

        if sz == 0 </span><span class="cov8" title="1">{
                return types.NullValue
        }</span>

        <span class="cov8" title="1">return l.Get(types.Int(0))</span>
}

func translateString(vals ...ref.Val) ref.Val <span class="cov8" title="1">{
        regstr, ok := vals[1].(types.String)
        if !ok </span><span class="cov0" title="0">{
                return types.ValOrErr(regstr, "unexpected type '%v' used in translate", vals[1].Type())
        }</span>

        <span class="cov8" title="1">src, ok := vals[0].(types.String)
        if !ok </span><span class="cov0" title="0">{
                return types.ValOrErr(src, "unexpected type '%v' used in translate", vals[0].Type())
        }</span>

        <span class="cov8" title="1">repl, ok := vals[2].(types.String)
        if !ok </span><span class="cov0" title="0">{
                return types.ValOrErr(repl, "unexpected type '%v' used in translate", vals[2].Type())
        }</span>

        <span class="cov8" title="1">re, err := regexp.Compile(string(regstr))
        if err != nil </span><span class="cov8" title="1">{
                return types.NewErr("failed to parse regular expression for translation: %w", err)
        }</span>

        <span class="cov8" title="1">return types.String(re.ReplaceAllString(string(src), string(repl)))</span>
}

func max(x, y types.Int) types.Int <span class="cov8" title="1">{ //nolint: revive
        switch x.Compare(y) </span>{
        case types.IntNegOne:<span class="cov8" title="1">
                return x</span>
        case types.IntOne:<span class="cov8" title="1">
                return y</span>
        default:<span class="cov8" title="1">
                return x</span>
        }
}

func urlToMap(u *url.URL) map[string]interface{} <span class="cov8" title="1">{
        // This doesn't return the RawPath.
        m := map[string]interface{}{
                "scheme":       u.Scheme,
                "host":         u.Host,
                "path":         u.Path,
                "rawQuery":     u.RawQuery,
                "fragment":     u.Fragment,
                "queryStrings": u.Query(),
                "query":        flatten(u.Query()),
        }
        if u.User != nil </span><span class="cov8" title="1">{
                pass, _ := u.User.Password()
                m["auth"] = map[string]string{
                        "username": u.User.Username(),
                        "password": pass,
                }
        }</span>
        <span class="cov8" title="1">return m</span>
}

func flatten(uv url.Values) map[string]string <span class="cov8" title="1">{
        r := map[string]string{}
        for k, v := range uv </span><span class="cov8" title="1">{
                r[k] = strings.Join(v, ",")
        }</span>
        <span class="cov8" title="1">return r</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package github

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "regexp"
        "strings"

        gh "github.com/google/go-github/v31/github"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "golang.org/x/oauth2"
        "google.golang.org/grpc/codes"
        "gopkg.in/yaml.v2"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

const pullRequest = "pull_request"

var acceptedEventTypes = []string{pullRequest, "push"}

type testURLKey string

const (
        changedFilesExtensionsKey            = "changed_files"
        testURL                   testURLKey = "TESTURL"
        OKToTestCommentRegexp                = `(^|\n)\/ok-to-test(\r\n|\r|\n|$)`
)

// In a pull request, these are the only two events that should trigger a PipelineRun/TaskRun
var ownersEventTypes = []string{pullRequest, "issue_comment"}

// ErrInvalidContentType is returned when the content-type is not a JSON body.
var ErrInvalidContentType = errors.New("form parameter encoding not supported, please change the hook to send JSON payloads")

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

type payloadDetails struct {
        PrNumber     int
        Owner        string
        Repository   string
        ChangedFiles string
}

type OwnersPayloadDetails struct {
        PrNumber         int
        Sender           string
        Owner            string
        Repository       string
        IssueCommentBody string
}

type OwnersConfig struct {
        Approvers []string `json:"approvers,omitempty"`
        Reviewers []string `json:"reviewers,omitempty"`
}

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        SecretRef *triggersv1.SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes      []string        `json:"eventTypes,omitempty"`
        AddChangedFiles AddChangedFiles `json:"addChangedFiles,omitempty"`
        GithubOwners    Owners          `json:"githubOwners,omitempty"`
}

type CheckType string

const (
        // Set the checkType to orgMembers to allow org members to submit or comment on PR to proceed
        OrgMembers CheckType = "orgMembers"
        // Set the checkType to repoMembers to allow repo members to submit or comment on PR to proceed
        RepoMembers CheckType = "repoMembers"
        // Set the checkType to all if both repo members or org members can submit or comment on PR to proceed
        All CheckType = "all"
        // Set the checkType to none if neither of repo members or org members can not submit or comment on PR to proceed
        None CheckType = "none"
)

type Owners struct {
        Enabled bool `json:"enabled,omitempty"`
        // This param/variable is required for private repos or when checkType is set to orgMembers or repoMembers or all
        PersonalAccessToken *triggersv1.SecretRef `json:"personalAccessToken,omitempty"`
        // Set the value to one of the supported values (orgMembers, repoMembers, both, none)
        CheckType CheckType `json:"checkType,omitempty"`
}

type AddChangedFiles struct {
        Enabled             bool                  `json:"enabled,omitempty"`
        PersonalAccessToken *triggersv1.SecretRef `json:"personalAccessToken,omitempty"`
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        headers := interceptors.Canonical(r.Header)
        if v := headers.Get("Content-Type"); v == "application/x-www-form-urlencoded" </span><span class="cov8" title="1">{
                return interceptors.Fail(codes.InvalidArgument, ErrInvalidContentType.Error())
        }</span>

        <span class="cov8" title="1">p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">actualEvent := headers.Get("X-Github-Event")

        // Check if the event type is in the allow-list
        if p.EventTypes != nil </span><span class="cov8" title="1">{
                isAllowed := false
                for _, allowedEvent := range p.EventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                isAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isAllowed </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "event type %s is not allowed", actualEvent)
                }</span>
        }

        // Next validate secrets
        <span class="cov8" title="1">if p.SecretRef != nil </span><span class="cov8" title="1">{
                // Check the secret to see if it is empty
                if p.SecretRef.SecretKey == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "github interceptor secretRef.secretKey is empty")
                }</span>
                <span class="cov8" title="1">header := headers.Get("X-Hub-Signature-256")
                if header == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "no X-Hub-Signature-256 header set")
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
                secretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                <span class="cov8" title="1">if err := gh.ValidateSignature(header, []byte(r.Body), secretToken); err != nil </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, err.Error())
                }</span>
        }

        <span class="cov8" title="1">if p.AddChangedFiles.Enabled </span><span class="cov8" title="1">{
                shouldAddChangedFiles := false
                for _, allowedEvent := range acceptedEventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                shouldAddChangedFiles = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !shouldAddChangedFiles </span><span class="cov8" title="1">{
                        return &amp;triggersv1.InterceptorResponse{
                                Continue: true,
                        }
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">secretToken, err := w.getGithubTokenSecret(ctx, r, p)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                <span class="cov8" title="1">payload, err := parseBodyForChangedFiles(r.Body, actualEvent)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error parsing body: %v", err)
                }</span>

                <span class="cov8" title="1">var changedFiles string
                if actualEvent == pullRequest </span><span class="cov8" title="1">{
                        changedFiles, err = getChangedFilesFromPr(ctx, payload, headers.Get("X-Github-Enterprise-Host"), secretToken)
                        if err != nil </span><span class="cov0" title="0">{
                                return interceptors.Failf(codes.FailedPrecondition, "error getting changed files: %v", err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        changedFiles = payload.ChangedFiles
                }</span>

                <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                        Extensions: map[string]interface{}{
                                changedFilesExtensionsKey: changedFiles,
                        },
                        Continue: true,
                }</span>
        }

        // For event types pull_request, issue_comment check github owners approval is required
        // User can specify both event type or any one of them
        <span class="cov8" title="1">if p.GithubOwners.Enabled </span><span class="cov8" title="1">{
                ownerCheckAllowed := false
                for _, allowedEvent := range ownersEventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                ownerCheckAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !ownerCheckAllowed </span><span class="cov0" title="0">{
                        return &amp;triggersv1.InterceptorResponse{
                                Continue: true,
                        }
                }</span>
                <span class="cov8" title="1">ghToken, err := w.getPersonalAccessTokenSecret(ctx, r, p)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting github token: %v", err)
                }</span>
                <span class="cov8" title="1">if ghToken == "" &amp;&amp; (p.GithubOwners.CheckType != "none") </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "checkType is set to check org or repo members but no personalAccessToken was supplied")
                }</span>
                // The X-Github-Enterprise-Host header only exists when the webhook comes from a github enterprise
                // server and is left empty for regular hosted Github
                <span class="cov8" title="1">enterpriseBaseURL := headers.Get("X-Github-Enterprise-Host")
                client, err := makeClient(ctx, enterpriseBaseURL, ghToken)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error making client: %v", err)
                }</span>
                <span class="cov8" title="1">payload, err := parseBodyForOwners(r.Body, actualEvent)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error parsing body: %v", err)
                }</span>
                <span class="cov8" title="1">allowed, err := checkOwnershipAndMembership(ctx, payload, p, client)
                if err != nil </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "error checking owner verification: %v", err)
                }</span>

                <span class="cov8" title="1">if allowed &amp;&amp; actualEvent == pullRequest </span><span class="cov8" title="1">{
                        return &amp;triggersv1.InterceptorResponse{
                                Continue: true,
                        }
                }</span>

                <span class="cov8" title="1">commentAllowed, err := okToTestFromAnOwner(ctx, payload, p, client)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error checking comments for verification: %v", err)
                }</span>
                <span class="cov8" title="1">if !commentAllowed </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "owners check requirements not met")
                }</span>
        }

        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue: true,
        }</span>
}

func (w *InterceptorImpl) getGithubTokenSecret(ctx context.Context, r *triggersv1.InterceptorRequest, p InterceptorParams) (string, error) <span class="cov8" title="1">{
        if p.AddChangedFiles.PersonalAccessToken == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if p.AddChangedFiles.PersonalAccessToken.SecretKey == "" </span><span class="cov8" title="1">{
                return "", errors.New("github interceptor githubToken.secretKey is empty")
        }</span>
        <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
        secretToken, err := w.SecretGetter.Get(ctx, ns, p.AddChangedFiles.PersonalAccessToken)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(secretToken), nil</span>
}

func parseBodyForChangedFiles(body string, eventType string) (payloadDetails, error) <span class="cov8" title="1">{
        results := payloadDetails{}
        if body == "" </span><span class="cov8" title="1">{
                return results, errors.New("body is empty")
        }</span>

        <span class="cov8" title="1">var jsonMap map[string]interface{}
        err := json.Unmarshal([]byte(body), &amp;jsonMap)
        if err != nil </span><span class="cov8" title="1">{
                return results, err
        }</span>

        <span class="cov8" title="1">var prNum int
        _, ok := jsonMap["number"]
        if ok </span><span class="cov8" title="1">{
                prNum = int(jsonMap["number"].(float64))
        }</span> else<span class="cov8" title="1"> {
                if eventType == pullRequest </span><span class="cov8" title="1">{
                        return results, errors.New("pull_request body missing 'number' field")
                }</span>
                <span class="cov8" title="1">prNum = -1</span>
        }

        <span class="cov8" title="1">repoSection, ok := jsonMap["repository"].(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository' field")
        }</span>

        <span class="cov8" title="1">fullName, ok := repoSection["full_name"].(string)
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository.full_name' field")
        }</span>

        <span class="cov8" title="1">changedFiles := []string{}

        commitsSection, ok := jsonMap["commits"].([]interface{})
        if ok </span><span class="cov8" title="1">{
                for _, commit := range commitsSection </span><span class="cov8" title="1">{
                        addedFiles, ok := commit.(map[string]interface{})["added"].([]interface{})
                        if !ok </span><span class="cov8" title="1">{
                                return results, errors.New("payload body missing 'commits.*.added' field")
                        }</span>

                        <span class="cov8" title="1">modifiedFiles, ok := commit.(map[string]interface{})["modified"].([]interface{})
                        if !ok </span><span class="cov8" title="1">{
                                return results, errors.New("payload body missing 'commits.*.modified' field")
                        }</span>

                        <span class="cov8" title="1">removedFiles, ok := commit.(map[string]interface{})["removed"].([]interface{})
                        if !ok </span><span class="cov8" title="1">{
                                return results, errors.New("payload body missing 'commits.*.removed' field")
                        }</span>
                        <span class="cov8" title="1">for _, fileName := range addedFiles </span><span class="cov8" title="1">{
                                changedFiles = append(changedFiles, fmt.Sprintf("%v", fileName))
                        }</span>

                        <span class="cov8" title="1">for _, fileName := range modifiedFiles </span><span class="cov8" title="1">{
                                changedFiles = append(changedFiles, fmt.Sprintf("%v", fileName))
                        }</span>

                        <span class="cov8" title="1">for _, fileName := range removedFiles </span><span class="cov8" title="1">{
                                changedFiles = append(changedFiles, fmt.Sprintf("%v", fileName))
                        }</span>
                }
        }

        <span class="cov8" title="1">results = payloadDetails{
                PrNumber:     prNum,
                Owner:        strings.Split(fullName, "/")[0],
                Repository:   strings.Split(fullName, "/")[1],
                ChangedFiles: strings.Join(changedFiles, ","),
        }
        return results, nil</span>
}

func getChangedFilesFromPr(ctx context.Context, payload payloadDetails, enterpriseBaseURL string, token string) (string, error) <span class="cov8" title="1">{
        changedFiles := []string{}

        client, err := makeClient(ctx, enterpriseBaseURL, token)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">opt := &amp;gh.ListOptions{PerPage: 100}
        for </span><span class="cov8" title="1">{
                files, resp, err := client.PullRequests.ListFiles(ctx, payload.Owner, payload.Repository, payload.PrNumber, opt)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                        changedFiles = append(changedFiles, *file.Filename)
                }</span>

                <span class="cov8" title="1">if resp.NextPage == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">opt.Page = resp.NextPage</span>
        }

        <span class="cov8" title="1">return strings.Join(changedFiles, ","), nil</span>
}

func makeClient(ctx context.Context, enterpriseBaseURL string, token string) (*gh.Client, error) <span class="cov8" title="1">{
        var httpClient *http.Client
        var client *gh.Client
        var err error

        if token != "" </span><span class="cov8" title="1">{
                tokenSource := oauth2.StaticTokenSource(
                        &amp;oauth2.Token{AccessToken: token},
                )
                httpClient = oauth2.NewClient(ctx, tokenSource)
        }</span> else<span class="cov8" title="1"> {
                httpClient = nil
        }</span>

        <span class="cov8" title="1">testingURL := ""
        if ctx.Value(testURL) != nil </span><span class="cov8" title="1">{
                testingURL = fmt.Sprintf("%v", ctx.Value(testURL))
        }</span>

        <span class="cov8" title="1">if enterpriseBaseURL != "" || testingURL != "" </span><span class="cov8" title="1">{
                enterpriseBaseURL = "https://" + enterpriseBaseURL
                if testingURL != "" </span><span class="cov8" title="1">{
                        enterpriseBaseURL = testingURL
                }</span>

                <span class="cov8" title="1">client, err = gh.NewEnterpriseClient(enterpriseBaseURL, enterpriseBaseURL, httpClient)
                if err != nil </span><span class="cov0" title="0">{
                        return client, err
                }</span>
        } else<span class="cov8" title="1"> {
                client = gh.NewClient(httpClient)
        }</span>
        <span class="cov8" title="1">return client, nil</span>
}

func (w *InterceptorImpl) getPersonalAccessTokenSecret(ctx context.Context, r *triggersv1.InterceptorRequest, p InterceptorParams) (string, error) <span class="cov8" title="1">{
        if p.GithubOwners.PersonalAccessToken == nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov8" title="1">if p.GithubOwners.PersonalAccessToken.SecretKey == "" </span><span class="cov8" title="1">{
                return "", errors.New("github interceptor personalAccessToken.secretKey is empty")
        }</span>
        <span class="cov8" title="1">if r.Context == nil </span><span class="cov8" title="1">{
                return "", errors.New("no request context passed")
        }</span>
        <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
        secretToken, err := w.SecretGetter.Get(ctx, ns, p.GithubOwners.PersonalAccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(secretToken), nil</span>
}

func okToTestFromAnOwner(ctx context.Context, payload OwnersPayloadDetails, p InterceptorParams, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        if MatchRegexp(OKToTestCommentRegexp, payload.IssueCommentBody) </span><span class="cov8" title="1">{
                allowed, err := checkOwnershipAndMembership(ctx, payload, p, client)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if allowed </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

func checkOwnershipAndMembership(ctx context.Context, payload OwnersPayloadDetails, p InterceptorParams, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        if p.GithubOwners.CheckType == "orgMembers" || p.GithubOwners.CheckType == "all" </span><span class="cov8" title="1">{
                isUserMemberOrg, err := checkSenderOrgMembership(ctx, payload, client)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if isUserMemberOrg </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">if p.GithubOwners.CheckType == "repoMembers" || p.GithubOwners.CheckType == "all" </span><span class="cov8" title="1">{
                checkSenderRepoMembership, err := checkSenderRepoMembership(ctx, payload, client)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">if checkSenderRepoMembership </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">ownerContent, err := getContentFromOwners(ctx, "OWNERS", payload, client)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "404") </span><span class="cov8" title="1">{
                        // no owner file, skipping
                        return false, nil
                }</span>
                <span class="cov8" title="1">return false, err</span>
        }

        <span class="cov8" title="1">return userInOwnerFile(ownerContent, payload.Sender)</span>
}

func checkSenderOrgMembership(ctx context.Context, payload OwnersPayloadDetails, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        users, resp, err := client.Organizations.ListMembers(ctx, payload.Owner, &amp;gh.ListMembersOptions{
                PublicOnly: true, // we can't list private member in a org
        })
        if resp != nil &amp;&amp; resp.Response.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">for _, user := range users </span><span class="cov8" title="1">{
                login := *user.Login
                if login == payload.Sender </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

func checkSenderRepoMembership(ctx context.Context, payload OwnersPayloadDetails, client *gh.Client) (bool, error) <span class="cov8" title="1">{
        users, _, err := client.Repositories.ListCollaborators(ctx, payload.Owner, payload.Repository, &amp;gh.ListCollaboratorsOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, user := range users </span><span class="cov8" title="1">{
                login := *user.Login
                if login == payload.Sender </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

func getContentFromOwners(ctx context.Context, path string, payload OwnersPayloadDetails, client *gh.Client) (string, error) <span class="cov8" title="1">{
        fileContent, directoryContent, _, err := client.Repositories.GetContents(ctx, payload.Owner, payload.Repository, path, &amp;gh.RepositoryContentGetOptions{})

        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if directoryContent != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("referenced file inside the Github Repository %s is a directory", path)
        }</span>

        <span class="cov8" title="1">fileData, err := fileContent.GetContent()

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fileData, nil</span>
}

func userInOwnerFile(ownerContent, sender string) (bool, error) <span class="cov8" title="1">{
        oc := OwnersConfig{}
        err := yaml.Unmarshal([]byte(ownerContent), &amp;oc)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">for _, owner := range append(oc.Approvers, oc.Reviewers...) </span><span class="cov8" title="1">{
                if strings.EqualFold(owner, sender) </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

func MatchRegexp(reg, comment string) bool <span class="cov8" title="1">{
        re := regexp.MustCompile(reg)
        return string(re.Find([]byte(comment))) != ""
}</span>

func parseBodyForOwners(body string, eventType string) (OwnersPayloadDetails, error) <span class="cov8" title="1">{
        results := OwnersPayloadDetails{}
        if body == "" </span><span class="cov8" title="1">{
                return results, errors.New("payload body is empty")
        }</span>
        <span class="cov8" title="1">var jsonMap map[string]interface{}
        err := json.Unmarshal([]byte(body), &amp;jsonMap)
        if err != nil </span><span class="cov0" title="0">{
                return results, err
        }</span>

        <span class="cov8" title="1">var prNum int
        if eventType == pullRequest </span><span class="cov8" title="1">{
                _, ok := jsonMap["number"]
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("pull_request body missing 'number' field")
                }</span>
                <span class="cov8" title="1">prNum = int(jsonMap["number"].(float64))</span>
        } else<span class="cov8" title="1"> {
                prNum = -1
        }</span>

        <span class="cov8" title="1">var issueCommentBody string
        if eventType == "issue_comment" </span><span class="cov8" title="1">{
                issueSection, ok := jsonMap["issue"].(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("issue_comment body missing 'issue' section")
                }</span>
                <span class="cov8" title="1">_, ok = issueSection["number"]
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("'number' field missing in the issue section of issue_comment body")
                }</span>
                <span class="cov8" title="1">prNum = int(issueSection["number"].(float64))

                issueCommentBodySection, ok := jsonMap["comment"].(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("issue_comment body missing 'comment' section")
                }</span>
                <span class="cov8" title="1">_, ok = issueCommentBodySection["body"]
                if !ok </span><span class="cov8" title="1">{
                        return results, errors.New("'body' field missing in the comment section of issue_comment body")
                }</span>
                <span class="cov8" title="1">issueCommentBody = issueCommentBodySection["body"].(string)</span>
        } else<span class="cov8" title="1"> {
                issueCommentBody = ""
        }</span>

        <span class="cov8" title="1">repoSection, ok := jsonMap["repository"].(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository' field")
        }</span>

        <span class="cov8" title="1">fullName, ok := repoSection["full_name"].(string)
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'repository.full_name' field")
        }</span>

        <span class="cov8" title="1">senderSection, ok := jsonMap["sender"].(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return results, errors.New("payload body missing 'sender' field")
        }</span>
        <span class="cov8" title="1">prSender, _ := senderSection["login"].(string)

        results = OwnersPayloadDetails{
                PrNumber:         prNum,
                Sender:           prSender,
                Owner:            strings.Split(fullName, "/")[0],
                Repository:       strings.Split(fullName, "/")[1],
                IssueCommentBody: issueCommentBody,
        }

        return results, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package gitlab

import (
        "context"
        "crypto/subtle"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "google.golang.org/grpc/codes"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

// InterceptorParams provides a webhook to intercept and pre-process events
type InterceptorParams struct {
        SecretRef *triggersv1.SecretRef `json:"secretRef,omitempty"`
        // +listType=atomic
        EventTypes []string `json:"eventTypes,omitempty"`
}

func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        <span class="cov8" title="1">headers := interceptors.Canonical(r.Header)

        // Check if the event type is in the allow-list
        if p.EventTypes != nil </span><span class="cov8" title="1">{
                actualEvent := headers.Get("X-Gitlab-Event")
                isAllowed := false
                for _, allowedEvent := range p.EventTypes </span><span class="cov8" title="1">{
                        if actualEvent == allowedEvent </span><span class="cov8" title="1">{
                                isAllowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !isAllowed </span><span class="cov8" title="1">{
                        return interceptors.Failf(codes.FailedPrecondition, "event type %s is not allowed", actualEvent)
                }</span>
        }

        // Next validate secrets
        <span class="cov8" title="1">if p.SecretRef != nil </span><span class="cov8" title="1">{
                // Check the secret to see if it is empty
                if p.SecretRef.SecretKey == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.FailedPrecondition, "gitlab interceptor secretRef.secretKey is empty")
                }</span>
                <span class="cov8" title="1">header := headers.Get("X-Gitlab-Token")
                if header == "" </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.InvalidArgument, "no X-Gitlab-Token header set")
                }</span>

                <span class="cov8" title="1">if r.Context == nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.InvalidArgument, "no request context passed")
                }</span>

                <span class="cov8" title="1">ns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)
                secretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)
                if err != nil </span><span class="cov0" title="0">{
                        return interceptors.Failf(codes.FailedPrecondition, "error getting secret: %v", err)
                }</span>

                // Make sure to use a constant time comparison here.
                <span class="cov8" title="1">if subtle.ConstantTimeCompare([]byte(header), secretToken) == 0 </span><span class="cov8" title="1">{
                        return interceptors.Fail(codes.InvalidArgument, "Invalid X-GitLab-Token")
                }</span>
        }
        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue: true,
        }</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptors

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"

        triggersv1alpha1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "google.golang.org/grpc/codes"
        "knative.dev/pkg/apis"
)

const (
        CoreInterceptorsHost = "tekton-triggers-core-interceptors"
        ContentType          = "application/json"
)

// Interceptor is the interface that all interceptors implement.
type Interceptor interface {
        ExecuteTrigger(req *http.Request) (*http.Response, error)
}

// GetInterceptorParams returns InterceptorParams for the current interceptors
func GetInterceptorParams(i *triggersv1beta1.EventInterceptor) map[string]interface{} <span class="cov8" title="1">{
        ip := map[string]interface{}{}
        switch </span>{
        case i.Webhook != nil:<span class="cov8" title="1">
                // WebHook headers are of type map[string][]string.
                // Use old style for now. Upgrade later.
                if i.Webhook != nil </span><span class="cov8" title="1">{
                        ip["objectRef"] = i.Webhook.ObjectRef
                        ip["header"] = i.Webhook.Header
                }</span>
        case i.Params != nil:<span class="cov8" title="1">
                for _, p := range i.Params </span><span class="cov8" title="1">{
                        ip[p.Name] = p.Value
                }</span>
        }
        <span class="cov8" title="1">return ip</span>
}

// Fail constructs a InterceptorResponse that should not continue further processing.
func Fail(c codes.Code, msg string) *triggersv1beta1.InterceptorResponse <span class="cov8" title="1">{
        return &amp;triggersv1beta1.InterceptorResponse{
                Continue: false,
                Status: triggersv1beta1.Status{
                        Code:    c,
                        Message: msg,
                },
        }
}</span>

// Failf constructs a InterceptorResponse that should not continue further processing.
func Failf(c codes.Code, format string, a ...interface{}) *triggersv1beta1.InterceptorResponse <span class="cov8" title="1">{
        return Fail(c, fmt.Sprintf(format, a...))
}</span>

// Canonical updates the map keys to use the Canonical name
func Canonical(h map[string][]string) http.Header <span class="cov8" title="1">{
        c := map[string][]string{}
        for k, v := range h </span><span class="cov8" title="1">{
                c[http.CanonicalHeaderKey(k)] = v
        }</span>
        <span class="cov8" title="1">return http.Header(c)</span>
}

// UnmarshalParams unmarshalls the passed in InterceptorParams into the provided param struct
func UnmarshalParams(ip map[string]interface{}, p interface{}) error <span class="cov8" title="1">{
        b, err := json.Marshal(ip)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to marshal json: %w", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(b, &amp;p); err != nil </span><span class="cov0" title="0">{
                // Should never happen since Unmarshall only returns err if json is invalid which we already check above
                return fmt.Errorf("invalid json: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type InterceptorGetter func(name string) (*triggersv1alpha1.ClusterInterceptor, error)

// ResolveToURL finds an Interceptor's URL.
func ResolveToURL(getter InterceptorGetter, name string) (*apis.URL, error) <span class="cov8" title="1">{
        ic, err := getter(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", name, err)
        }</span>
        <span class="cov8" title="1">if addr := ic.Status.Address; addr != nil </span><span class="cov8" title="1">{
                if addr.URL != nil </span><span class="cov8" title="1">{
                        return addr.URL, nil
                }</span>
        }
        // If the status does not have a URL, try to generate it from the Spec.
        <span class="cov8" title="1">return ic.ResolveAddress()</span>
}

func Execute(ctx context.Context, client *http.Client, req *triggersv1beta1.InterceptorRequest, url string) (*triggersv1beta1.InterceptorResponse, error) <span class="cov8" title="1">{
        b, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // TODO: Seed context with timeouts
        <span class="cov8" title="1">r, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(b))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r.Header.Set("Content-Type", ContentType)

        res, err := client.Do(r)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">body, err := io.ReadAll(res.Body)
        defer res.Body.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if res.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                // TODO: error type for easier checking. wrap in status.Errorf?
                return nil, fmt.Errorf("interceptor response was not 200: %v", string(body))
        }</span>
        <span class="cov8" title="1">iresp := triggersv1beta1.InterceptorResponse{}
        if err := json.Unmarshal(body, &amp;iresp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;iresp, nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptors

import (
        "context"
        "fmt"
        "time"

        triggersv1beta1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/cache"
        corev1 "k8s.io/client-go/kubernetes/typed/core/v1"
)

const (
        // cacheSize is the size of the LRU secrets cache
        cacheSize = 1024
        // ttl is the time to live for a cache entry
        ttl = 5 * time.Second
)

type SecretGetter interface {
        Get(ctx context.Context, triggerNS string, sr *triggersv1beta1.SecretRef) ([]byte, error)
}

type kubeclientSecretGetter struct {
        getter corev1.SecretsGetter
        cache  *cache.LRUExpireCache
        ttl    time.Duration
}

type cacheKey struct {
        triggerNS string
        sr        triggersv1beta1.SecretRef
}

func DefaultSecretGetter(getter corev1.SecretsGetter) SecretGetter <span class="cov8" title="1">{
        return &amp;kubeclientSecretGetter{
                getter: getter,
                cache:  cache.NewLRUExpireCache(cacheSize),
                ttl:    ttl,
        }
}</span>

// Get queries Kubernetes for the given secret reference. We use this function
// to resolve secret material like GitHub webhook secrets, and call it once for every
// trigger that references it.
//
// As we may have many triggers that all use the same secret, we cache the secret values
// in the request cache.
func (g *kubeclientSecretGetter) Get(ctx context.Context, triggerNS string, sr *triggersv1beta1.SecretRef) ([]byte, error) <span class="cov8" title="1">{
        key := cacheKey{
                triggerNS: triggerNS,
                sr:        *sr,
        }
        val, ok := g.cache.Get(key)
        if ok </span><span class="cov8" title="1">{
                return val.([]byte), nil
        }</span>
        <span class="cov8" title="1">secret, err := g.getter.Secrets(triggerNS).Get(ctx, sr.SecretName, metav1.GetOptions{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">secretValue, ok := secret.Data[sr.SecretKey]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot find %s key in secret %s/%s", sr.SecretKey, triggerNS, sr.SecretName)
        }</span>
        <span class="cov8" title="1">g.cache.Add(key, secretValue, g.ttl)
        return secretValue, nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package slack

import (
        "context"
        "encoding/json"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "google.golang.org/grpc/codes"
)

var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)

type InterceptorImpl struct {
        SecretGetter interceptors.SecretGetter
}

// Interceptor parses all the requests fields from the slack form-data request
// and adds them to the extension
// revive:disable:unused-parameter
func (*InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse <span class="cov8" title="1">{
        headers := interceptors.Canonical(r.Header)

        // validate slack headers
        if v := headers.Get("Content-Type"); v != "application/x-www-form-urlencoded" </span><span class="cov8" title="1">{
                return interceptors.Fail(codes.InvalidArgument, "missing header in payload: ContentType application/x-www-form-urlencoded")
        }</span>

        <span class="cov8" title="1">if s := headers.Get("X-Slack-Signature"); s == "" </span><span class="cov8" title="1">{
                return interceptors.Fail(codes.InvalidArgument, "missing header in payload: ContentType application/x-www-form-urlencoded")
        }</span>

        // get requests fields
        <span class="cov8" title="1">var payload map[string][]string
        if err := json.Unmarshal([]byte(r.Body), &amp;payload); err != nil </span><span class="cov8" title="1">{
                return interceptors.Failf(codes.InvalidArgument, "failed to unmarshl slack payload: %v", err)
        }</span>

        // get requests fields
        <span class="cov8" title="1">p := InterceptorParams{}
        if err := interceptors.UnmarshalParams(r.InterceptorParams, &amp;p); err != nil </span><span class="cov0" title="0">{
                return interceptors.Failf(codes.InvalidArgument, "failed to parse interceptor params: %v", err)
        }</span>

        // validate RequestedFields exists
        <span class="cov8" title="1">if p.RequestedFields == nil </span><span class="cov0" title="0">{
                return interceptors.Fail(codes.NotFound, "missing requested field definition")
        }</span>

        // extract required fields values
        <span class="cov8" title="1">extensions := make(map[string]interface{})

        for _, field := range p.RequestedFields </span><span class="cov8" title="1">{
                if value, ok := payload[field]; ok </span><span class="cov8" title="1">{
                        extensions[field] = value
                }</span> else<span class="cov0" title="0"> {
                        return interceptors.Failf(codes.NotFound, "requested field does not exists in payload %v", payload)
                }</span>
        }
        <span class="cov8" title="1">return &amp;triggersv1.InterceptorResponse{
                Continue:   true,
                Extensions: extensions,
        }</span>
}

// revive:enable:unused-parameter

func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl <span class="cov0" title="0">{
        return &amp;InterceptorImpl{
                SecretGetter: sg,
        }
}</span>

type InterceptorParams struct {
        // the Requested fields to be extracted from data form

        // +listType=atomic
        RequestedFields []string `json:"requestedFields,omitempty"`
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package webhook

import (
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "time"

        pipelinev1 "github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"

        "go.uber.org/zap"
)

const (
        // Timeout for outgoing requests to interceptor services
        interceptorTimeout = 5 * time.Second
        // the incoming request URL is passed through to the webhook in this header.
        webhookURLHeader = "Eventlistener-Request-Url"
)

type Interceptor struct {
        HTTPClient       *http.Client
        TriggerNamespace string
        Logger           *zap.SugaredLogger
        Webhook          *triggersv1.WebhookInterceptor
}

func NewInterceptor(wh *triggersv1.WebhookInterceptor, c *http.Client, ns string, l *zap.SugaredLogger) interceptors.Interceptor <span class="cov8" title="1">{
        timeoutClient := &amp;http.Client{
                Transport: c.Transport,
                Timeout:   interceptorTimeout,
        }
        return &amp;Interceptor{
                HTTPClient:       timeoutClient,
                TriggerNamespace: ns,
                Logger:           l,
                Webhook:          wh,
        }
}</span>

func (w *Interceptor) ExecuteTrigger(request *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        u, err := getURI(w.Webhook, w.TriggerNamespace) // TODO: Cache this result or do this on initialization
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">request.Header.Set(webhookURLHeader, request.URL.String())
        request.URL = u
        request.Host = u.Host
        addInterceptorHeaders(request.Header, w.Webhook.Header)

        resp, err := w.HTTPClient.Do(request)
        if err != nil </span><span class="cov0" title="0">{
                return resp, err
        }</span>
        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                respBody, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, errors.New("failed to parse response body")
                }</span>
                <span class="cov8" title="1">return resp, fmt.Errorf("request rejected; status: %s; message: %s", resp.Status, respBody)</span>
        }
        <span class="cov8" title="1">return resp, err</span>
}

// getURI retrieves the ObjectReference to URI.
func getURI(webhook *triggersv1.WebhookInterceptor, ns string) (*url.URL, error) <span class="cov8" title="1">{
        // TODO: This should work for any Addressable.
        // Use something like https://github.com/knative/eventing-contrib/blob/7c0fc5cfa8bd44da0767d9e7b250264ea6eb7d8d/pkg/controller/sinks/sinks.go#L32
        switch </span>{
        case webhook.URL != nil:<span class="cov8" title="1">
                return webhook.URL.URL(), nil</span>
        case webhook.ObjectRef.Kind == "Service" &amp;&amp; webhook.ObjectRef.APIVersion == "v1":<span class="cov8" title="1">
                // TODO: Also assuming port 80 and http here. Use DNS/or the env vars?
                if webhook.ObjectRef.Namespace != "" </span><span class="cov8" title="1">{
                        ns = webhook.ObjectRef.Namespace
                }</span>
                <span class="cov8" title="1">return url.Parse(fmt.Sprintf("http://%s.%s.svc/", webhook.ObjectRef.Name, ns))</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("invalid objRef")</span>
        }
}

func addInterceptorHeaders(header http.Header, headerParams []pipelinev1.Param) <span class="cov8" title="1">{
        // This clobbers any matching headers
        for _, param := range headerParams </span><span class="cov8" title="1">{
                if param.Value.Type == pipelinev1.ParamTypeString </span><span class="cov8" title="1">{
                        header.Set(param.Name, param.Value.StringVal)
                }</span> else<span class="cov8" title="1"> {
                        header.Del(param.Name)
                        for _, v := range param.Value.ArrayVal </span><span class="cov8" title="1">{
                                header.Add(param.Name, v)
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file64" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package attributekey

import (
        "fmt"

        "go.opentelemetry.io/otel/attribute"
)

type ValueType interface {
        string | bool | int64 | int | float64 |
                []string | []bool | []int64 | []int | []float64
}

type (
        Type[T ValueType] string
        String            = Type[string]
        Bool              = Type[bool]
        Int               = Type[int]
        Int64             = Type[int64]
        Float64           = Type[float64]
)

func (key Type[T]) With(val T) attribute.KeyValue <span class="cov8" title="1">{
        k := string(key)

        switch v := any(val).(type) </span>{
        case string:<span class="cov8" title="1">
                return attribute.String(k, v)</span>
        case bool:<span class="cov8" title="1">
                return attribute.Bool(k, v)</span>
        case int64:<span class="cov8" title="1">
                return attribute.Int64(k, v)</span>
        case int:<span class="cov8" title="1">
                return attribute.Int(k, v)</span>
        case float64:<span class="cov8" title="1">
                return attribute.Float64(k, v)</span>
        case []string:<span class="cov8" title="1">
                return attribute.StringSlice(k, v)</span>
        case []bool:<span class="cov8" title="1">
                return attribute.BoolSlice(k, v)</span>
        case []int64:<span class="cov8" title="1">
                return attribute.Int64Slice(k, v)</span>
        case []int:<span class="cov8" title="1">
                return attribute.IntSlice(k, v)</span>
        case []float64:<span class="cov8" title="1">
                return attribute.Float64Slice(k, v)</span>
        default:<span class="cov0" title="0">
                // note - this can't happen due to type constraints
                panic(fmt.Sprintf("unsupported attribute type: %T", v))</span>
        }
}
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package observability

import (
        "context"

        "github.com/tektoncd/triggers/pkg/observability/metrics"
        "github.com/tektoncd/triggers/pkg/observability/runtime"
        "github.com/tektoncd/triggers/pkg/observability/tracing"
)

type (
        TracingConfig = tracing.Config
        MetricsConfig = metrics.Config
        RuntimeConfig = runtime.Config
)

type Config struct {
        Tracing TracingConfig `json:"tracing"`
        Metrics MetricsConfig `json:"metrics"`
        Runtime RuntimeConfig `json:"runtime"`
}

func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Tracing: tracing.DefaultConfig(),
                Metrics: metrics.DefaultConfig(),
                Runtime: runtime.DefaultConfig(),
        }
}</span>

func NewFromMap(m map[string]string) (*Config, error) <span class="cov8" title="1">{
        var err error
        c := DefaultConfig()

        if c.Tracing, err = tracing.NewFromMap(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if c.Metrics, err = metrics.NewFromMap(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if c.Runtime, err = runtime.NewFromMap(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

type cfgKey struct{}

// WithConfig associates a observability configuration with the context.
func WithConfig(ctx context.Context, cfg *Config) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, cfgKey{}, cfg)
}</span>

// GetConfig gets the observability config from the provided context.
func GetConfig(ctx context.Context) *Config <span class="cov8" title="1">{
        untyped := ctx.Value(cfgKey{})
        if untyped == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return untyped.(*Config)</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package configmap

import (
        "cmp"
        "os"

        "github.com/tektoncd/triggers/pkg/observability"
        corev1 "k8s.io/api/core/v1"
)

const (
        // The env var name for config-observability
        configMapNameEnv = "CONFIG_OBSERVABILITY_NAME"
        DefaultName      = "config-observability"
)

func Name() string <span class="cov8" title="1">{
        return cmp.Or(os.Getenv(configMapNameEnv), DefaultName)
}</span>

func Parse(c *corev1.ConfigMap) (*observability.Config, error) <span class="cov8" title="1">{
        return observability.NewFromMap(c.Data)
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "fmt"
        "time"
)

const (
        ProtocolGRPC         = "grpc"
        ProtocolHTTPProtobuf = "http/protobuf"
        ProtocolPrometheus   = "prometheus"
        ProtocolNone         = "none"
)

// Config provides a unified observability configuration which can be used to
// manage Knative observability behavior.  Typically, this is extracted from a
// Kubernetes ConfigMap during application startup, and accessed via the
// GetConfig() method.
type Config struct {
        Protocol       string        `json:"protocol,omitempty"`
        Endpoint       string        `json:"endpoint,omitempty"`
        ExportInterval time.Duration `json:"exportInterval,omitempty"`
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        switch c.Protocol </span>{
        case ProtocolGRPC, ProtocolHTTPProtobuf:<span class="cov0" title="0">
                if c.Endpoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("endpoint should be set when protocol is %q", c.Protocol)
                }</span>
        case ProtocolNone:<span class="cov0" title="0">
                if c.Endpoint != "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("endpoint should not be set when protocol is %q", c.Protocol)
                }</span>
        case ProtocolPrometheus:<span class="cov0" title="0"></span>
                // Endpoint is not required, but can be used to indicate listen port
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported protocol %q", c.Protocol)</span>
        }

        <span class="cov0" title="0">if c.ExportInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("export interval %q should be greater than zero", c.ExportInterval)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DefaultConfig returns a configuration with default values set.
func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Protocol: ProtocolNone,
        }
}</span>

// NewFromMap unpacks flat configuration values from a ConfigMap into
// the configuration used by different observability modules.
func NewFromMap(m map[string]string) (Config, error) <span class="cov0" title="0">{
        return NewFromMapWithPrefix("", m)
}</span>

func NewFromMapWithPrefix(prefix string, m map[string]string) (Config, error) <span class="cov0" title="0">{
        c := DefaultConfig()

        if val, ok := m[prefix+"metrics-protocol"]; ok </span><span class="cov0" title="0">{
                c.Protocol = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"metrics-endpoint"]; ok </span><span class="cov0" title="0">{
                c.Endpoint = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"metrics-export-interval"]; ok </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(val); err != nil </span><span class="cov0" title="0">{
                        return c, fmt.Errorf("invalid duration %q: %w", val, err)
                }</span> else<span class="cov0" title="0"> {
                        c.ExportInterval = duration
                }</span>
        }

        <span class="cov0" title="0">return c, c.Validate()</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"
        "errors"

        "go.opentelemetry.io/otel/metric"
        "go.opentelemetry.io/otel/metric/noop"
)

type shutdownFunc func(ctx context.Context) error

func noopFunc(context.Context) error <span class="cov0" title="0">{ return nil }</span>

type MeterProvider struct {
        metric.MeterProvider
        shutdown []shutdownFunc
}

func (m *MeterProvider) Shutdown(ctx context.Context) error <span class="cov0" title="0">{
        var errs []error
        for _, shutdown := range m.shutdown </span><span class="cov0" title="0">{
                if err := shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }
        <span class="cov0" title="0">return errors.Join(errs...)</span>
}

func NewMeterProvider(
        ctx context.Context,
        cfg Config,
) (*MeterProvider, error) <span class="cov0" title="0">{
        if cfg.Protocol == ProtocolNone </span><span class="cov0" title="0">{
                return &amp;MeterProvider{MeterProvider: noop.NewMeterProvider()}, nil
        }</span>

        // For now, return a noop provider
        // In a full implementation, you would configure the appropriate provider
        // based on the protocol (gRPC, HTTP, Prometheus)
        <span class="cov0" title="0">return &amp;MeterProvider{
                MeterProvider: noop.NewMeterProvider(),
                shutdown:      []shutdownFunc{noopFunc},
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resource

import (
        "os"
)

const otelServiceNameKey = "OTEL_SERVICE_NAME"

// Default returns a default service name for OpenTelemetry resource.
//
// It will return:
// - The provided service name, or
// - OTEL_SERVICE_NAME environment variable if set
func Default(serviceName string) string <span class="cov8" title="1">{
        // If the OTEL_SERVICE_NAME is set then let this override
        // our own serviceName
        if name := os.Getenv(otelServiceNameKey); name != "" </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return serviceName</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package runtime

import (
        "fmt"
        "time"
)

const (
        ProfilingEnabled  = "enabled"
        ProfilingDisabled = "disabled"
)

type Config struct {
        Profiling      string        `json:"profiling,omitempty"`
        ExportInterval time.Duration `json:"exportInterval,omitempty"`
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        switch c.Profiling </span>{
        case ProfilingEnabled, ProfilingDisabled:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported profile setting %q", c.Profiling)</span>
        }

        // ExportInterval == 0 =&gt; OTel will use a default value
        <span class="cov0" title="0">if c.ExportInterval &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("export interval %q should be greater than zero", c.ExportInterval)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c *Config) ProfilingEnabled() bool <span class="cov0" title="0">{
        return c.Profiling == ProfilingEnabled
}</span>

func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Profiling: ProfilingDisabled,
                // same as OTel runtime.DefaultMinimumReadMemStatsInterval
                ExportInterval: 15 * time.Second,
        }
}</span>

func NewFromMap(m map[string]string) (Config, error) <span class="cov0" title="0">{
        c := DefaultConfig()

        if val, ok := m["runtime-profiling"]; ok </span><span class="cov0" title="0">{
                c.Profiling = val
        }</span>
        <span class="cov0" title="0">if val, ok := m["runtime-export-interval"]; ok </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(val); err != nil </span><span class="cov0" title="0">{
                        return c, fmt.Errorf("invalid duration %q: %w", val, err)
                }</span> else<span class="cov0" title="0"> {
                        c.ExportInterval = duration
                }</span>
        }

        <span class="cov0" title="0">return c, c.Validate()</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
Copyright 2025 The Knative Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package tracing

import (
        "errors"
        "fmt"
)

const (
        ProtocolGRPC         = "grpc"
        ProtocolHTTPProtobuf = "http/protobuf"
        ProtocolNone         = "none"
        ProtocolStdout       = "stdout"
)

type Config struct {
        Protocol     string  `json:"protocol,omitempty"`
        Endpoint     string  `json:"endpoint,omitempty"`
        SamplingRate float64 `json:"samplingRate,omitempty"`
}

func (c *Config) Validate() error <span class="cov0" title="0">{
        switch c.Protocol </span>{
        case ProtocolGRPC, ProtocolHTTPProtobuf:<span class="cov0" title="0">
                if c.Endpoint == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("endpoint should be set for protocol %q", c.Protocol)
                }</span>
        case ProtocolNone, ProtocolStdout:<span class="cov0" title="0">
                if c.Endpoint != "" </span><span class="cov0" title="0">{
                        return errors.New("endpoint should not be set when protocol is 'none'")
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported protocol %q", c.Protocol)</span>
        }

        <span class="cov0" title="0">if c.SamplingRate &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("sampling rate %f should be greater or equal to zero", c.SamplingRate)
        }</span> else<span class="cov0" title="0"> if c.SamplingRate &gt; 1.0 </span><span class="cov0" title="0">{
                return fmt.Errorf("sampling rate %f should be less than or equal to one", c.SamplingRate)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func DefaultConfig() Config <span class="cov0" title="0">{
        return Config{
                Protocol: ProtocolNone,
        }
}</span>

func NewFromMap(m map[string]string) (Config, error) <span class="cov0" title="0">{
        return NewFromMapWithPrefix("", m)
}</span>

func NewFromMapWithPrefix(prefix string, m map[string]string) (Config, error) <span class="cov0" title="0">{
        c := DefaultConfig()

        if val, ok := m[prefix+"tracing-protocol"]; ok </span><span class="cov0" title="0">{
                c.Protocol = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"tracing-endpoint"]; ok </span><span class="cov0" title="0">{
                c.Endpoint = val
        }</span>
        <span class="cov0" title="0">if val, ok := m[prefix+"tracing-sampling-rate"]; ok </span><span class="cov0" title="0">{
                if rate, err := parseFloat64(val); err != nil </span><span class="cov0" title="0">{
                        return c, fmt.Errorf("invalid sampling rate %q: %w", val, err)
                }</span> else<span class="cov0" title="0"> {
                        c.SamplingRate = rate
                }</span>
        }

        <span class="cov0" title="0">return c, c.Validate()</span>
}

func parseFloat64(s string) (float64, error) <span class="cov0" title="0">{
        // Simple float64 parsing - in a real implementation you might want more robust parsing
        var f float64
        _, err := fmt.Sscanf(s, "%f", &amp;f)
        return f, err
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package clusterinterceptor

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        interceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor"
        v1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const ControllerName = "ClusterInterceptor"

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
}

var (
        // Check that our Reconciler implements interceptorreconciler.Interface
        _ interceptorreconciler.Interface = (*Reconciler)(nil)
)

func (r *Reconciler) ReconcileKind(ctx context.Context, it *v1alpha1.ClusterInterceptor) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if it.Status.Address == nil </span><span class="cov8" title="1">{ // Initialize Address if needed
                it.Status.Address = &amp;v1.Addressable{}
        }</span>
        <span class="cov8" title="1">if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{ // Set defaults
                it.SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">url, err := it.ResolveAddress()
        logger.Debugf("Resolved Address is %s", url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">it.Status.Address.URL = url
        return nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package clusterinterceptor

import (
        "context"

        clusterinterceptorinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        clusterinterceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

func NewController() func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, _ configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                clusterInterceptorInformer := clusterinterceptorinformer.Get(ctx)
                reconciler := &amp;Reconciler{}

                impl := clusterinterceptorreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options </span><span class="cov0" title="0">{
                        return controller.Options{
                                AgentName: ControllerName,
                        }
                }</span>)

                <span class="cov0" title="0">if _, err := clusterInterceptorInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register ClusterInterceptor informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package eventlistener

import (
        "context"

        cfg "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersclient "github.com/tektoncd/triggers/pkg/client/injection/client"
        eventlistenerinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        eventlistenerreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener"
        dynamicduck "github.com/tektoncd/triggers/pkg/dynamic"
        "github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources"
        "github.com/tektoncd/triggers/pkg/reconciler/metrics"
        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/client-go/tools/cache"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        duckinformer "knative.dev/pkg/client/injection/ducks/duck/v1/podspecable"
        kubeclient "knative.dev/pkg/client/injection/kube/client"
        filtereddeployinformer "knative.dev/pkg/client/injection/kube/informers/apps/v1/deployment/filtered"
        filteredserviceinformer "knative.dev/pkg/client/injection/kube/informers/core/v1/service/filtered"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection/clients/dynamicclient"
        "knative.dev/pkg/logging"
)

// NewController creates a new instance of an EventListener controller.
func NewController(config resources.Config) func(context.Context, configmap.Watcher) *controller.Impl <span class="cov8" title="1">{
        return func(ctx context.Context, cmw configmap.Watcher) *controller.Impl </span><span class="cov8" title="1">{
                logger := logging.FromContext(ctx)
                dynamicclientset := dynamicclient.Get(ctx)
                kubeclientset := kubeclient.Get(ctx)
                triggersclientset := triggersclient.Get(ctx)
                eventListenerInformer := eventlistenerinformer.Get(ctx)
                deploymentInformer := filtereddeployinformer.Get(ctx, labels.FormatLabels(resources.DefaultStaticResourceLabels))
                serviceInformer := filteredserviceinformer.Get(ctx, labels.FormatLabels(resources.DefaultStaticResourceLabels))

                reconciler := &amp;Reconciler{
                        DynamicClientSet:  dynamicclientset,
                        KubeClientSet:     kubeclientset,
                        TriggersClientSet: triggersclientset,
                        deploymentLister:  deploymentInformer.Lister(),
                        serviceLister:     serviceInformer.Lister(),
                        configAcc:         reconcilersource.WatchConfigurations(ctx, "eventlistener", cmw),
                        config:            config,
                        Metrics:           metrics.Get(ctx),
                }

                impl := eventlistenerreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options </span><span class="cov8" title="1">{
                        configStore := cfg.NewStore(logger.Named("config-store"))
                        configStore.WatchConfigs(cmw)
                        return controller.Options{
                                AgentName:   ControllerName,
                                ConfigStore: configStore,
                        }
                }</span>)

                <span class="cov8" title="1">reconciler.podspecableTracker = dynamicduck.NewListableTracker(ctx, duckinformer.Get, impl)

                if _, err := eventListenerInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register EventListener informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := deploymentInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1beta1.EventListener{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Deployment informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">if _, err := serviceInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{
                        FilterFunc: controller.FilterController(&amp;v1beta1.EventListener{}),
                        Handler:    controller.HandleAll(impl.EnqueueControllerOf),
                }); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Service informer event handler: %w", err)
                }</span>

                <span class="cov8" title="1">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package eventlistener

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "sync"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        eventlistenerreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener"
        dynamicduck "github.com/tektoncd/triggers/pkg/dynamic"
        "github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources"
        "github.com/tektoncd/triggers/pkg/reconciler/metrics"
        "golang.org/x/xerrors"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/equality"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/api/meta"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        appsv1lister "k8s.io/client-go/listers/apps/v1"
        corev1lister "k8s.io/client-go/listers/core/v1"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        "knative.dev/pkg/apis"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const (
        // ControllerName defines the name for EventListener Controller
        ControllerName = "EventListener"
        // eventListenerServicePortName defines service port name for EventListener Service
        eventListenerServicePortName = "http-listener"
        // eventListenerServiceTLSPortName defines service TLS port name for EventListener Service
        eventListenerServiceTLSPortName = "https-listener"
        // eventListenerMetricsPortName defines the metrics port name by the EventListener Container
        eventListenerMetricsPortName = "http-metrics"
        // eventListenerContainerPort defines service port for EventListener Service
        eventListenerContainerPort = 8080
        // eventListenerMetricsPort defines metrics port for EventListener Service
        eventListenerMetricsPort = 9000
        // GeneratedResourcePrefix is the name prefix for resources generated in the
        // EventListener reconciler
        GeneratedResourcePrefix = "el"
)

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
        DynamicClientSet dynamic.Interface

        // KubeClientSet allows us to talk to the k8s for core APIs
        KubeClientSet kubernetes.Interface

        // TriggersClientSet allows us to configure triggers objects
        TriggersClientSet triggersclientset.Interface

        // listers index properties about resources
        deploymentLister appsv1lister.DeploymentLister
        serviceLister    corev1lister.ServiceLister

        // config accessor for observability/logging/tracing
        configAcc reconcilersource.ConfigAccessor

        // config is the configuration options that the Reconciler accepts.
        config             resources.Config
        podspecableTracker dynamicduck.ListableTracker
        onlyOnce           sync.Once

        // Metrics Recorder config
        Metrics *metrics.Recorder
}

var (
        // Check that our Reconciler implements eventlistenerreconciler.Interface
        _ eventlistenerreconciler.Interface = (*Reconciler)(nil)
)

// ReconcileKind compares the actual state with the desired, and attempts to
// converge the two.
func (r *Reconciler) ReconcileKind(ctx context.Context, el *v1beta1.EventListener) pkgreconciler.Event <span class="cov8" title="1">{
        // Initial reconciliation
        el.Status.InitializeConditions()
        el.Status.Configuration.GeneratedResourceName = fmt.Sprintf("%s-%s", GeneratedResourcePrefix, el.Name)

        // We may be reading a version of the object that was stored at an older version
        // and may not have had all of the assumed default specified.
        el.SetDefaults(contexts.WithUpgradeViaDefaulting(ctx))

        cfg := config.FromContextOrDefaults(ctx)

        if el.Spec.Resources.CustomResource != nil </span><span class="cov8" title="1">{
                return r.reconcileCustomObject(ctx, el, cfg)
        }</span>
        <span class="cov8" title="1">deploymentReconcileError := r.reconcileDeployment(ctx, el, cfg)
        serviceReconcileError := r.reconcileService(ctx, el)
        if el.Spec.Resources.CustomResource == nil </span><span class="cov8" title="1">{
                el.Status.SetReadyCondition()
        }</span>
        <span class="cov8" title="1">if len(el.Finalizers) &gt; 0 </span><span class="cov8" title="1">{
                // TODO(dibyom): Remove this in a future release once we are sure no one is using pre v0.16 resources
                r.removeFinalizer(ctx, el)
        }</span>

        <span class="cov8" title="1">return wrapError(serviceReconcileError, deploymentReconcileError)</span>
}

func (r *Reconciler) reconcileService(ctx context.Context, el *v1beta1.EventListener) error <span class="cov8" title="1">{
        service := resources.MakeService(ctx, el, r.config)

        existingService, err := r.serviceLister.Services(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName)
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                el.Status.SetExistsCondition(v1beta1.ServiceExists, nil)
                el.Status.SetAddress(resources.ListenerHostname(el, r.config))

                // Copy over output spec fields.
                service.Spec.ClusterIP = existingService.Spec.ClusterIP

                // Copy any assigned NodePorts
                if service.Spec.Type == corev1.ServiceTypeNodePort &amp;&amp;
                        existingService.Spec.Type == corev1.ServiceTypeNodePort </span><span class="cov8" title="1">{
                        for i := range service.Spec.Ports </span><span class="cov8" title="1">{
                                if i &gt;= len(existingService.Spec.Ports) </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov8" title="1">service.Spec.Ports[i].NodePort = existingService.Spec.Ports[i].NodePort</span>
                        }
                }
                // Preserve user-added annotations.
                <span class="cov8" title="1">if len(existingService.Annotations) &gt; 0 </span><span class="cov8" title="1">{
                        service.Annotations = kmeta.UnionMaps(service.Annotations, existingService.Annotations)
                }</span>

                <span class="cov8" title="1">if !equality.Semantic.DeepEqual(existingService.Spec, service.Spec) ||
                        !equality.Semantic.DeepEqual(existingService.Labels, service.Labels) ||
                        !equality.Semantic.DeepEqual(existingService.Annotations, service.Annotations) </span><span class="cov8" title="1">{
                        existingService = existingService.DeepCopy() // Don't modify the lister cache
                        existingService.Labels = service.Labels
                        existingService.Annotations = service.Annotations
                        existingService.Spec = service.Spec
                        if updated, err := r.KubeClientSet.CoreV1().Services(el.Namespace).Update(ctx, existingService, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("Error updating EventListener Service: %s", err)
                                return err
                        }</span> else<span class="cov8" title="1"> if existingService.ResourceVersion != updated.ResourceVersion </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Infof("Updated EventListener Service %s in Namespace %s", existingService.Namespace, el.Namespace)
                        }</span>
                }

        case errors.IsNotFound(err):<span class="cov8" title="1">
                // Create the EventListener Service
                _, err = r.KubeClientSet.CoreV1().Services(el.Namespace).Create(ctx, service, metav1.CreateOptions{})
                el.Status.SetExistsCondition(v1beta1.ServiceExists, err)
                if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Errorf("Error creating EventListener Service: %s", err)
                        return err
                }</span>
                <span class="cov8" title="1">el.Status.SetAddress(resources.ListenerHostname(el, r.config))
                logging.FromContext(ctx).Infof("Created EventListener Service %s in Namespace %s", service.Name, el.Namespace)</span>

        default:<span class="cov0" title="0">
                logging.FromContext(ctx).Error(err)
                return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) reconcileDeployment(ctx context.Context, el *v1beta1.EventListener, cfg *config.Config) error <span class="cov8" title="1">{
        deployment, err := resources.MakeDeployment(ctx, el, r.configAcc, r.config, cfg)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Error(err)
                return err
        }</span>

        <span class="cov8" title="1">existingDeployment, err := r.deploymentLister.Deployments(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName)
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                // TODO(mattmoor): Should this delete stuff for the CustomObject?  That path deletes Deployments,
                // so it seems asymmetrical for this path to not.

                el.Status.SetDeploymentConditions(existingDeployment.Status.Conditions)
                el.Status.SetExistsCondition(v1beta1.DeploymentExists, nil)

                // If the scale of the deployment is unspecified, then persist the current
                // scale of what is deployed.  This allows users to use HPA to automatically
                // (or manually themselves) scale the underlying deployment.
                if deployment.Spec.Replicas == nil </span><span class="cov8" title="1">{
                        deployment.Spec.Replicas = existingDeployment.Spec.Replicas
                }</span>
                // Preserve user-added annotations.
                <span class="cov8" title="1">if len(existingDeployment.Annotations) &gt; 0 </span><span class="cov8" title="1">{
                        deployment.Annotations = kmeta.UnionMaps(deployment.Annotations, existingDeployment.Annotations)
                }</span>

                <span class="cov8" title="1">if !equality.Semantic.DeepEqual(existingDeployment.Spec, deployment.Spec) ||
                        !equality.Semantic.DeepEqual(existingDeployment.Labels, deployment.Labels) ||
                        !equality.Semantic.DeepEqual(existingDeployment.Annotations, deployment.Annotations) </span><span class="cov8" title="1">{
                        existingDeployment = existingDeployment.DeepCopy() // Don't modify the lister cache
                        existingDeployment.Labels = deployment.Labels
                        existingDeployment.Annotations = deployment.Annotations
                        existingDeployment.Spec = deployment.Spec
                        // If the spec/labels/annotations of what we want and got are different, then
                        // issue an Update.  They may differ due to things like defaulting, so the
                        // Update may not change anything, so only log if the ResourceVersion changes.
                        if updated, err := r.KubeClientSet.AppsV1().Deployments(el.Namespace).Update(ctx, existingDeployment, metav1.UpdateOptions{}); err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("Error updating EventListener Deployment: %s", err)
                                return err
                        }</span> else<span class="cov8" title="1"> if existingDeployment.ResourceVersion != updated.ResourceVersion </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Infof("Updated EventListener Deployment %s in Namespace %s", existingDeployment.Name, el.Namespace)
                        }</span>
                }

        case errors.IsNotFound(err):<span class="cov8" title="1">
                // Create the EventListener Deployment
                deployment, err = r.KubeClientSet.AppsV1().Deployments(el.Namespace).Create(ctx, deployment, metav1.CreateOptions{})
                el.Status.SetExistsCondition(v1beta1.DeploymentExists, err)
                if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Errorf("Error creating EventListener Deployment: %s", err)
                        return err
                }</span>
                <span class="cov8" title="1">el.Status.SetDeploymentConditions(deployment.Status.Conditions)
                logging.FromContext(ctx).Infof("Created EventListener Deployment %s in Namespace %s", deployment.Name, el.Namespace)</span>

        default:<span class="cov0" title="0">
                logging.FromContext(ctx).Error(err)
                return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) reconcileCustomObject(ctx context.Context, el *v1beta1.EventListener, cfg *config.Config) error <span class="cov8" title="1">{
        data, err := resources.MakeCustomObject(ctx, el, r.configAcc, r.config, cfg)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("unable to construct custom object", err)
                return err
        }</span>

        <span class="cov8" title="1">gvr, _ := meta.UnsafeGuessKindToResource(data.GetObjectKind().GroupVersionKind())

        // TODO(mattmoor): Consider replacing this with duck.InformerFactory, it actually has a bug where
        // the podspecableTracker can only service a single GVR, despite multiple EventListener objects
        // being able to specify unique resource types (yikes).
        var watchError error
        r.onlyOnce.Do(func() </span><span class="cov8" title="1">{
                watchError = r.podspecableTracker.WatchOnDynamicObject(ctx, gvr)
        }</span>)
        <span class="cov8" title="1">if watchError != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("failed to watch on created custom object", watchError)
                return watchError
        }</span>

        // TODO(mattmoor): We should look into using duck.InformerFactory to have this be a lister fetch.
        <span class="cov8" title="1">existingCustomObject, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Get(ctx, data.GetName(), metav1.GetOptions{})
        switch </span>{
        case err == nil:<span class="cov8" title="1">
                // Clean up any Deployments that may have existed for this listener.
                if _, err := r.deploymentLister.Deployments(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName); err == nil </span><span class="cov8" title="1">{
                        if err := r.KubeClientSet.AppsV1().Deployments(el.Namespace).Delete(ctx, el.Status.Configuration.GeneratedResourceName,
                                metav1.DeleteOptions{}); err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if err = r.KubeClientSet.CoreV1().Services(el.Namespace).Delete(ctx, el.Status.Configuration.GeneratedResourceName,
                                metav1.DeleteOptions{}); err != nil &amp;&amp; !errors.IsNotFound(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">var updated bool
                // Preserve any externally added annotations
                data.SetAnnotations(kmeta.UnionMaps(data.GetAnnotations(), existingCustomObject.GetAnnotations()))

                if !equality.Semantic.DeepEqual(data.GetLabels(), existingCustomObject.GetLabels()) ||
                        !equality.Semantic.DeepEqual(data.GetAnnotations(), existingCustomObject.GetAnnotations()) </span><span class="cov8" title="1">{
                        // Don't modify informer copy
                        existingCustomObject = existingCustomObject.DeepCopy()
                        existingCustomObject.SetLabels(data.GetLabels())
                        existingCustomObject.SetAnnotations(data.GetAnnotations())

                        updated = true
                }</span>

                <span class="cov8" title="1">if !equality.Semantic.DeepEqual(data.Object["spec"], existingCustomObject.Object["spec"]) </span><span class="cov8" title="1">{
                        diffExist, existingObject, err := resources.UpdateCustomObject(data, existingCustomObject)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // To avoid un necessary marshalling when there is no updates.
                        <span class="cov8" title="1">if diffExist </span><span class="cov8" title="1">{
                                existingMarshaledData, err := json.Marshal(existingObject)
                                if err != nil </span><span class="cov0" title="0">{
                                        logging.FromContext(ctx).Errorf("failed to marshal custom object: %v", err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">existingCustomObject = new(unstructured.Unstructured)
                                if err := existingCustomObject.UnmarshalJSON(existingMarshaledData); err != nil </span><span class="cov0" title="0">{
                                        logging.FromContext(ctx).Errorf("failed to unmarshal to unstructured object: %v", err)
                                        return err
                                }</span>
                                <span class="cov8" title="1">updated = diffExist</span>
                        }
                }
                <span class="cov8" title="1">if updated </span><span class="cov8" title="1">{
                        updatedData, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Update(ctx, existingCustomObject, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("error updating to eventListener custom object: %v", err)
                                return err
                        }</span> else<span class="cov8" title="1"> if data.GetResourceVersion() != updatedData.GetResourceVersion() </span><span class="cov8" title="1">{
                                logging.FromContext(ctx).Infof("Updated EventListener Custom Object %s in Namespace %s", data.GetName(), el.Namespace)
                        }</span>
                }

                // TODO(mattmoor): Consider replacing this stuff with the "addressable resolver"
                // from knative.dev/pkg, which is purpose built for this kind of thing.
                <span class="cov8" title="1">customConditions, url, err := dynamicduck.GetConditions(existingCustomObject)
                if customConditions == nil </span><span class="cov8" title="1">{
                        // No status in the created object, it is weird but let's not fail
                        logging.FromContext(ctx).Warn("empty status for the created custom object")
                        return nil
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, cond := range customConditions </span><span class="cov0" title="0">{
                        if cond.Type == apis.ConditionReady </span><span class="cov0" title="0">{
                                if cond.Status != corev1.ConditionTrue </span><span class="cov0" title="0">{
                                        logging.FromContext(ctx).Warnf("custom object is not yet ready because %s", cond.Message)
                                        return fmt.Errorf("custom object is not yet ready because %s", cond.Message)
                                }</span>
                        }
                }
                <span class="cov0" title="0">el.Status.SetConditionsForDynamicObjects(customConditions)
                if url != nil </span><span class="cov0" title="0">{
                        el.Status.SetAddress(strings.Split(fmt.Sprintf("%v", url), "//")[1])
                }</span>

        case errors.IsNotFound(err):<span class="cov8" title="1">
                createDynamicObject, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Create(ctx, data, metav1.CreateOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Errorf("Error creating EventListener Dynamic object: ", err)
                        return err
                }</span>
                <span class="cov8" title="1">logging.FromContext(ctx).Infof("Created EventListener Deployment %s in Namespace %s", createDynamicObject.GetName(), el.Namespace)</span>

        default:<span class="cov0" title="0">
                logging.FromContext(ctx).Error(err)
                return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Reconciler) removeFinalizer(ctx context.Context, el *v1beta1.EventListener) <span class="cov8" title="1">{
        // We used to need Finalizers in older versions of Triggers.
        // They are not necessary anymore so let's remove them from any old EventListener objects
        for i, f := range el.Finalizers </span><span class="cov8" title="1">{
                if f == "eventlisteners.triggers.tekton.dev" </span><span class="cov8" title="1">{
                        el.Finalizers = append(el.Finalizers[:i], el.Finalizers[i+1:]...)
                        _, err := r.TriggersClientSet.TriggersV1beta1().EventListeners(el.Namespace).Update(ctx, el, metav1.UpdateOptions{})
                        if err != nil </span><span class="cov0" title="0">{
                                logging.FromContext(ctx).Errorf("failed to update EventListener to remove finalizer: %v", err)
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
}

// wrapError wraps errors together. If one of the errors is nil, the other is
// returned.
func wrapError(err1, err2 error) error <span class="cov8" title="1">{
        if err1 == nil </span><span class="cov8" title="1">{
                return err2
        }</span>
        <span class="cov8" title="1">if err2 == nil </span><span class="cov8" title="1">{
                return err1
        }</span>
        <span class="cov8" title="1">return xerrors.Errorf("%s : %s", err1.Error(), err2.Error())</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

var (
        // DefaultImage is the image used by default.
        DefaultImage = "override-with-el:latest"
        // DefaultPort is the port used by default.
        DefaultPort = 8080
        // DefaultSetSecurityContext is the SetSecurityContext value used by default.
        DefaultSetSecurityContext = true
        // DefaultSetReadOnlyRootFilesystem is the SetReadOnlyRootFilesystem value used by default.
        DefaultSetReadOnlyRootFilesystem = true
        // DefaultEventListenerEvent is the EventListenerEvent value used by default.
        DefaultEventListenerEvent = "disable"
        // DefaultReadTimeout is the ReadTimeout used by default.
        DefaultReadTimeout = int64(5)
        // DefaultWriteTimeout is the WriteTimeout used by default.
        DefaultWriteTimeout = int64(40)
        // DefaultIdleTimeout is the IdleTimeout used by default.
        DefaultIdleTimeout = int64(30)
        // DefaultTimeOutHandler is the TimeOutHandler timeout used by default.
        DefaultTimeOutHandler = int64(5)
        // DefaultPeriodSeconds is the PeriodSeconds used by default.
        DefaultPeriodSeconds = 10
        // DefaultFailureThreshold is the FailureThreshold used by default.
        DefaultFailureThreshold = 3
        // DefaultHTTPClientReadTimeOut is the HTTPClient ReadTimeOut used by default.
        DefaultHTTPClientReadTimeOut = int64(30)
        // DefaultHTTPClientKeepAlive is the HTTPClient KeepAlive used by default
        DefaultHTTPClientKeepAlive = int64(30)
        // DefaultHTTPClientTLSHandshakeTimeout is the HTTPClient TLS Handshake timeout used by default
        DefaultHTTPClientTLSHandshakeTimeout = int64(10)
        // DefaultHTTPClientResponseHeaderTimeout is the HTTPClient Response Header Timeout
        DefaultHTTPClientResponseHeaderTimeout = int64(10)
        // DefaultHTTPClientExpectContinueTimeout is the HTTPClient Expect Continue Timeout
        DefaultHTTPClientExpectContinueTimeout = int64(1)
        // DefaultStaticResourceLabels are the StaticResourceLabels used by default.
        DefaultStaticResourceLabels = map[string]string{
                "app.kubernetes.io/managed-by": "EventListener",
                "app.kubernetes.io/part-of":    "Triggers",
        }
        // DefaultSystemNamespace is the default system namespace used.
        DefaultSystemNamespace = "tekton-pipelines"
)

type Config struct {
        // Image defines the container that we use to run in the EventListener Pods.
        Image *string
        // Port defines the port for the EventListener to listen on.
        Port *int
        // SetSecurityContext defines if the security context is set.
        SetSecurityContext *bool
        // SetReadOnlyRootFilesystem defines the value for readOnlyRootFilesystem
        SetReadOnlyRootFilesystem *bool
        // SetEventListenerEvent defines to enable or disable of emitting events for EventListener.
        SetEventListenerEvent *string
        // ReadTimeOut defines the read timeout for EventListener Server.
        ReadTimeOut *int64
        // WriteTimeOut defines the write timeout for EventListener Server.
        WriteTimeOut *int64
        // IdleTimeOut defines the read timeout for EventListener Server.
        IdleTimeOut *int64
        // TimeOutHandler defines the timeout for Timeout Handler of EventListener Server.
        TimeOutHandler *int64
        // HTTPClientReadTimeOut defines the Read timeout for HTTP Client
        HTTPClientReadTimeOut *int64
        // HTTPClientKeepAlive defines the Keep Alive for HTTP Client
        HTTPClientKeepAlive *int64
        // HTTPClientTLSHandshakeTimeout defines the Handshake timeout for HTTP Client
        HTTPClientTLSHandshakeTimeout *int64
        // HTTPClientResponseHeaderTimeout defines the Response Header timeout for HTTP Client
        HTTPClientResponseHeaderTimeout *int64
        // HTTPClientExpectContinueTimeout defines the Expect timeout for HTTP Client
        HTTPClientExpectContinueTimeout *int64
        // PeriodSeconds defines Period Seconds for the EventListener Liveness and Readiness Probes.
        PeriodSeconds *int
        // FailureThreshold defines the Failure Threshold for the EventListener Liveness and Readiness Probes.
        FailureThreshold *int
        // StaticResourceLabels is a map with all the labels that should be on all resources generated by the EventListener.
        StaticResourceLabels map[string]string
        // SystemNamespace is the namespace where the reconciler is deployed.
        SystemNamespace string
}

type ConfigOption func(d *Config)

// MakeConfig is a helper to build a config that is consumed by an EventListener.
// It generates a default Config for the EventListener without any flags set and accepts functions for modification.
func MakeConfig(ops ...ConfigOption) *Config <span class="cov8" title="1">{
        c := &amp;Config{
                Image:                           &amp;DefaultImage,
                Port:                            &amp;DefaultPort,
                SetSecurityContext:              &amp;DefaultSetSecurityContext,
                SetEventListenerEvent:           &amp;DefaultEventListenerEvent,
                SetReadOnlyRootFilesystem:       &amp;DefaultSetReadOnlyRootFilesystem,
                ReadTimeOut:                     &amp;DefaultReadTimeout,
                WriteTimeOut:                    &amp;DefaultWriteTimeout,
                IdleTimeOut:                     &amp;DefaultIdleTimeout,
                TimeOutHandler:                  &amp;DefaultTimeOutHandler,
                HTTPClientReadTimeOut:           &amp;DefaultHTTPClientReadTimeOut,
                HTTPClientKeepAlive:             &amp;DefaultHTTPClientKeepAlive,
                HTTPClientTLSHandshakeTimeout:   &amp;DefaultHTTPClientTLSHandshakeTimeout,
                HTTPClientResponseHeaderTimeout: &amp;DefaultHTTPClientResponseHeaderTimeout,
                HTTPClientExpectContinueTimeout: &amp;DefaultHTTPClientExpectContinueTimeout,
                PeriodSeconds:                   &amp;DefaultPeriodSeconds,
                FailureThreshold:                &amp;DefaultFailureThreshold,

                StaticResourceLabels: DefaultStaticResourceLabels,
                SystemNamespace:      DefaultSystemNamespace,
        }

        for _, op := range ops </span><span class="cov8" title="1">{
                op(c)
        }</span>
        <span class="cov8" title="1">return c</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "strconv"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        corev1 "k8s.io/api/core/v1"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        "knative.dev/pkg/ptr"
)

type ContainerOption func(*corev1.Container)

func MakeContainer(el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config, opts ...ContainerOption) corev1.Container <span class="cov8" title="1">{
        isMultiNS := false
        if len(el.Spec.NamespaceSelector.MatchNames) != 0 </span><span class="cov8" title="1">{
                isMultiNS = true
        }</span>
        <span class="cov8" title="1">for _, triggerGroup := range el.Spec.TriggerGroups </span><span class="cov8" title="1">{
                if len(triggerGroup.TriggerSelector.NamespaceSelector.MatchNames) != 0 </span><span class="cov8" title="1">{
                        isMultiNS = true
                        break</span>
                }
        }

        <span class="cov8" title="1">payloadValidation := true
        if value, ok := el.GetAnnotations()[triggers.PayloadValidationAnnotation]; ok </span><span class="cov8" title="1">{
                if value == "false" </span><span class="cov8" title="1">{
                        payloadValidation = false
                }</span>
        }

        <span class="cov8" title="1">ev := configAcc.ToEnvVars()

        var containerSecurityContext *corev1.SecurityContext
        if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                if len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 </span><span class="cov8" title="1">{
                        if *c.SetSecurityContext </span><span class="cov8" title="1">{
                                containerSecurityContext = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].SecurityContext
                        }</span>
                }
        }
        <span class="cov8" title="1">if *c.SetSecurityContext &amp;&amp; containerSecurityContext == nil </span><span class="cov8" title="1">{
                containerSecurityContext = &amp;corev1.SecurityContext{
                        AllowPrivilegeEscalation: ptr.Bool(false),
                        Capabilities: &amp;corev1.Capabilities{
                                Drop: []corev1.Capability{"ALL"},
                        },
                        RunAsNonRoot: ptr.Bool(cfg.Defaults.DefaultRunAsNonRoot),
                        SeccompProfile: &amp;corev1.SeccompProfile{
                                Type: corev1.SeccompProfileTypeRuntimeDefault,
                        },
                }

                if *c.SetReadOnlyRootFilesystem </span><span class="cov8" title="1">{
                        containerSecurityContext.ReadOnlyRootFilesystem = ptr.Bool(true)
                }</span>
                <span class="cov8" title="1">if !cfg.Defaults.IsDefaultRunAsUserEmpty </span><span class="cov8" title="1">{
                        containerSecurityContext.RunAsUser = ptr.Int64(cfg.Defaults.DefaultRunAsUser)
                }</span>
                <span class="cov8" title="1">if !cfg.Defaults.IsDefaultRunAsGroupEmpty </span><span class="cov8" title="1">{
                        containerSecurityContext.RunAsGroup = ptr.Int64(cfg.Defaults.DefaultRunAsGroup)
                }</span>
        }

        <span class="cov8" title="1">container := corev1.Container{
                Name:  "event-listener",
                Image: *c.Image,
                Ports: []corev1.ContainerPort{{
                        ContainerPort: int32(eventListenerContainerPort),
                        Protocol:      corev1.ProtocolTCP,
                }},
                Args: []string{
                        "--el-name=" + el.Name,
                        "--el-namespace=" + el.Namespace,
                        "--port=" + strconv.Itoa(eventListenerContainerPort),
                        "--readtimeout=" + strconv.FormatInt(*c.ReadTimeOut, 10),
                        "--writetimeout=" + strconv.FormatInt(*c.WriteTimeOut, 10),
                        "--idletimeout=" + strconv.FormatInt(*c.IdleTimeOut, 10),
                        "--timeouthandler=" + strconv.FormatInt(*c.TimeOutHandler, 10),
                        "--httpclient-readtimeout=" + strconv.FormatInt(*c.HTTPClientReadTimeOut, 10),
                        "--httpclient-keep-alive=" + strconv.FormatInt(*c.HTTPClientKeepAlive, 10),
                        "--httpclient-tlshandshaketimeout=" + strconv.FormatInt(*c.HTTPClientTLSHandshakeTimeout, 10),
                        "--httpclient-responseheadertimeout=" + strconv.FormatInt(*c.HTTPClientResponseHeaderTimeout, 10),
                        "--httpclient-expectcontinuetimeout=" + strconv.FormatInt(*c.HTTPClientExpectContinueTimeout, 10),
                        "--is-multi-ns=" + strconv.FormatBool(isMultiNS),
                        "--payload-validation=" + strconv.FormatBool(payloadValidation),
                        "--cloudevent-uri=" + el.Spec.CloudEventURI,
                },
                Env: append(ev, []corev1.EnvVar{{
                        Name:  "NAMESPACE",
                        Value: el.Namespace,
                }, {
                        Name:  "NAME",
                        Value: el.Name,
                }, {
                        Name:  "EL_EVENT",
                        Value: *c.SetEventListenerEvent,
                }, {
                        Name:  "K_SINK_TIMEOUT",
                        Value: strconv.FormatInt(*c.TimeOutHandler, 10),
                }}...),
                SecurityContext: containerSecurityContext,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(&amp;container)
        }</span>

        <span class="cov8" title="1">return container</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "bytes"
        "context"
        "encoding/json"
        "os"
        "reflect"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        duckv1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/kmeta"
)

func MakeCustomObject(ctx context.Context, el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        original := &amp;duckv1.WithPod{}
        decoder := json.NewDecoder(bytes.NewBuffer(el.Spec.Resources.CustomResource.Raw))
        if err := decoder.Decode(&amp;original); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">customObjectData := original.DeepCopy()

        namespace := original.GetNamespace()
        // Default the resource creation to the EventListenerNamespace if not found in the resource object
        if namespace == "" </span><span class="cov8" title="1">{
                namespace = el.GetNamespace()
        }</span>

        <span class="cov8" title="1">container := MakeContainer(el, configAcc, c, cfg, func(c *corev1.Container) </span><span class="cov8" title="1">{
                // handle env and resources for custom object
                if len(original.Spec.Template.Spec.Containers) == 1 </span><span class="cov8" title="1">{
                        c.Env = append(c.Env, original.Spec.Template.Spec.Containers[0].Env...)
                        c.Resources = original.Spec.Template.Spec.Containers[0].Resources
                }</span>

                <span class="cov8" title="1">c.Env = append(c.Env, corev1.EnvVar{
                        Name: "SYSTEM_NAMESPACE",
                        // Cannot use FieldRef here because Knative Serving mask that field under feature gate
                        // https://github.com/knative/serving/blob/master/pkg/apis/config/features.go#L48
                        Value: el.Namespace,
                }, corev1.EnvVar{
                        // METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint
                        // env METRICS_PROMETHEUS_PORT set by controller
                        Name:  "METRICS_PROMETHEUS_PORT",
                        Value: os.Getenv("METRICS_PROMETHEUS_PORT"),
                }, corev1.EnvVar{
                        // KUBERNETES_MIN_VERSION overrides the Min version of k8s required
                        Name:  "KUBERNETES_MIN_VERSION",
                        Value: os.Getenv("KUBERNETES_MIN_VERSION"),
                })

                c.ReadinessProbe = &amp;corev1.Probe{
                        ProbeHandler: corev1.ProbeHandler{
                                HTTPGet: &amp;corev1.HTTPGetAction{
                                        Path:   "/live",
                                        Scheme: corev1.URISchemeHTTP,
                                },
                        },
                        SuccessThreshold: 1,
                }</span>
        })

        <span class="cov8" title="1">podlabels := kmeta.UnionMaps(FilterLabels(ctx, el.Labels), GenerateLabels(el.Name, c.StaticResourceLabels))

        podlabels = kmeta.UnionMaps(podlabels, customObjectData.Labels)

        original.Labels = podlabels
        original.Annotations = customObjectData.Annotations
        original.Spec.Template.ObjectMeta = metav1.ObjectMeta{
                Name:        customObjectData.Spec.Template.Name,
                Labels:      customObjectData.Spec.Template.Labels,
                Annotations: customObjectData.Spec.Template.Annotations,
        }
        original.Spec.Template.Spec = corev1.PodSpec{
                Tolerations:               customObjectData.Spec.Template.Spec.Tolerations,
                NodeSelector:              customObjectData.Spec.Template.Spec.NodeSelector,
                ServiceAccountName:        customObjectData.Spec.Template.Spec.ServiceAccountName,
                Containers:                []corev1.Container{container},
                Affinity:                  customObjectData.Spec.Template.Spec.Affinity,
                TopologySpreadConstraints: customObjectData.Spec.Template.Spec.TopologySpreadConstraints,
        }
        marshaledData, err := json.Marshal(original)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">data := new(unstructured.Unstructured)
        if err := data.UnmarshalJSON(marshaledData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if data.GetName() == "" </span><span class="cov8" title="1">{
                data.SetName(el.Status.Configuration.GeneratedResourceName)
        }</span>
        <span class="cov8" title="1">data.SetNamespace(namespace)
        data.SetOwnerReferences([]metav1.OwnerReference{*kmeta.NewControllerRef(el)})

        return data, nil</span>
}

func UpdateCustomObject(originalData, updatedCustomObject *unstructured.Unstructured) (bool, *duckv1.WithPod, error) <span class="cov8" title="1">{
        updated := false
        originalObject := &amp;duckv1.WithPod{}
        existingObject := &amp;duckv1.WithPod{}
        data, e := originalData.MarshalJSON()
        if e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>
        <span class="cov8" title="1">if e := json.Unmarshal(data, &amp;originalObject); e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>
        <span class="cov8" title="1">updatedData, e := updatedCustomObject.MarshalJSON()
        if e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>
        <span class="cov8" title="1">if e := json.Unmarshal(updatedData, &amp;existingObject); e != nil </span><span class="cov0" title="0">{
                return false, nil, e
        }</span>

        // custom resource except few spec fields from user
        // added below checks in order to avoid unwanted updates on all spec changes.
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Name, originalObject.Spec.Template.Name) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Name = originalObject.Spec.Template.Name
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Labels, originalObject.Spec.Template.Labels) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Labels = originalObject.Spec.Template.Labels
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Annotations, originalObject.Spec.Template.Annotations) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Annotations = originalObject.Spec.Template.Annotations
                updated = true
        }</span>
        <span class="cov8" title="1">if existingObject.Spec.Template.Spec.ServiceAccountName != originalObject.Spec.Template.Spec.ServiceAccountName </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.ServiceAccountName = originalObject.Spec.Template.Spec.ServiceAccountName
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Tolerations, originalObject.Spec.Template.Spec.Tolerations) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.Tolerations = originalObject.Spec.Template.Spec.Tolerations
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.NodeSelector, originalObject.Spec.Template.Spec.NodeSelector) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.NodeSelector = originalObject.Spec.Template.Spec.NodeSelector
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Affinity, originalObject.Spec.Template.Spec.Affinity) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.Affinity = originalObject.Spec.Template.Spec.Affinity
                updated = true
        }</span>
        <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.TopologySpreadConstraints, originalObject.Spec.Template.Spec.TopologySpreadConstraints) </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.TopologySpreadConstraints = originalObject.Spec.Template.Spec.TopologySpreadConstraints
                updated = true
        }</span>
        <span class="cov8" title="1">if len(existingObject.Spec.Template.Spec.Containers) == 0 ||
                len(existingObject.Spec.Template.Spec.Containers) &gt; 1 </span><span class="cov8" title="1">{
                existingObject.Spec.Template.Spec.Containers = originalObject.Spec.Template.Spec.Containers
                updated = true
        }</span> else<span class="cov8" title="1"> {
                if existingObject.Spec.Template.Spec.Containers[0].Name != originalObject.Spec.Template.Spec.Containers[0].Name </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Name = originalObject.Spec.Template.Spec.Containers[0].Name
                        updated = true
                }</span>
                <span class="cov8" title="1">if existingObject.Spec.Template.Spec.Containers[0].Image != originalObject.Spec.Template.Spec.Containers[0].Image </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Image = originalObject.Spec.Template.Spec.Containers[0].Image
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Ports, originalObject.Spec.Template.Spec.Containers[0].Ports) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Ports = originalObject.Spec.Template.Spec.Containers[0].Ports
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Args, originalObject.Spec.Template.Spec.Containers[0].Args) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Args = originalObject.Spec.Template.Spec.Containers[0].Args
                        updated = true
                }</span>
                <span class="cov8" title="1">if existingObject.Spec.Template.Spec.Containers[0].Command != nil </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Command = nil
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Resources, originalObject.Spec.Template.Spec.Containers[0].Resources) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Resources = originalObject.Spec.Template.Spec.Containers[0].Resources
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Env, originalObject.Spec.Template.Spec.Containers[0].Env) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].Env = originalObject.Spec.Template.Spec.Containers[0].Env
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].ReadinessProbe, originalObject.Spec.Template.Spec.Containers[0].ReadinessProbe) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].ReadinessProbe = originalObject.Spec.Template.Spec.Containers[0].ReadinessProbe
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].VolumeMounts, originalObject.Spec.Template.Spec.Containers[0].VolumeMounts) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Containers[0].VolumeMounts = originalObject.Spec.Template.Spec.Containers[0].VolumeMounts
                        updated = true
                }</span>
                <span class="cov8" title="1">if !reflect.DeepEqual(existingObject.Spec.Template.Spec.Volumes, originalObject.Spec.Template.Spec.Volumes) </span><span class="cov8" title="1">{
                        existingObject.Spec.Template.Spec.Volumes = originalObject.Spec.Template.Spec.Volumes
                        updated = true
                }</span>
        }

        <span class="cov8" title="1">return updated, existingObject, nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "os"
        "strconv"

        "github.com/tektoncd/triggers/pkg/apis/config"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
        reconcilersource "knative.dev/eventing/pkg/reconciler/source"
        "knative.dev/pkg/kmeta"
        "knative.dev/pkg/ptr"
)

const (
        TriggersMetricsDomain = "tekton.dev/triggers"
)

var (
        baseSecurityPolicy = &amp;corev1.PodSecurityContext{
                RunAsNonRoot: ptr.Bool(true),
                SeccompProfile: &amp;corev1.SeccompProfile{
                        Type: corev1.SeccompProfileTypeRuntimeDefault,
                },
        }
)

func getStrongerSecurityPolicy(cfg *config.Config) *corev1.PodSecurityContext <span class="cov8" title="1">{
        securityContext := baseSecurityPolicy
        if !cfg.Defaults.IsDefaultRunAsUserEmpty </span><span class="cov8" title="1">{
                securityContext.RunAsUser = ptr.Int64(cfg.Defaults.DefaultRunAsUser)
        }</span>

        <span class="cov8" title="1">if !cfg.Defaults.IsDefaultRunAsGroupEmpty </span><span class="cov8" title="1">{
                securityContext.RunAsGroup = ptr.Int64(cfg.Defaults.DefaultRunAsGroup)
        }</span>

        <span class="cov8" title="1">if !cfg.Defaults.IsDefaultFsGroupEmpty </span><span class="cov8" title="1">{
                securityContext.FSGroup = ptr.Int64(cfg.Defaults.DefaultFSGroup)
        }</span>

        <span class="cov8" title="1">return securityContext</span>
}

func MakeDeployment(ctx context.Context, el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config) (*appsv1.Deployment, error) <span class="cov8" title="1">{
        opt, err := addDeploymentBits(el, c)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">container := MakeContainer(el, configAcc, c, cfg, opt, addCertsForSecureConnection(c))

        filteredLabels := FilterLabels(ctx, el.Labels)

        var (
                podlabels                 = kmeta.UnionMaps(filteredLabels, GenerateLabels(el.Name, c.StaticResourceLabels))
                serviceAccountName        = el.Spec.ServiceAccountName
                replicas                  *int32
                vol                       []corev1.Volume
                tolerations               []corev1.Toleration
                nodeSelector, annotations map[string]string
                affinity                  *corev1.Affinity
                topologySpreadConstraints []corev1.TopologySpreadConstraint
                imagePullSecrets          []corev1.LocalObjectReference
        )

        for _, v := range container.Env </span><span class="cov8" title="1">{
                // If TLS related env are set then mount secret volume which will be used while starting the eventlistener.
                if v.Name == "TLS_CERT" </span><span class="cov8" title="1">{
                        vol = append(vol, corev1.Volume{
                                Name: "https-connection",
                                VolumeSource: corev1.VolumeSource{
                                        Secret: &amp;corev1.SecretVolumeSource{
                                                SecretName: v.ValueFrom.SecretKeyRef.Name,
                                        },
                                },
                        })
                }</span>
        }

        <span class="cov8" title="1">var securityContext *corev1.PodSecurityContext
        if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                if el.Spec.Resources.KubernetesResource.Replicas != nil </span><span class="cov8" title="1">{
                        replicas = el.Spec.Resources.KubernetesResource.Replicas
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.Tolerations) != 0 </span><span class="cov8" title="1">{
                        tolerations = el.Spec.Resources.KubernetesResource.Template.Spec.Tolerations
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.NodeSelector) != 0 </span><span class="cov8" title="1">{
                        nodeSelector = el.Spec.Resources.KubernetesResource.Template.Spec.NodeSelector
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.ImagePullSecrets) != 0 </span><span class="cov0" title="0">{
                        imagePullSecrets = el.Spec.Resources.KubernetesResource.Template.Spec.ImagePullSecrets
                }</span>
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource.Template.Spec.ServiceAccountName != "" </span><span class="cov8" title="1">{
                        serviceAccountName = el.Spec.Resources.KubernetesResource.Template.Spec.ServiceAccountName
                }</span>
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource.Template.Spec.Affinity != nil </span><span class="cov8" title="1">{
                        affinity = el.Spec.Resources.KubernetesResource.Template.Spec.Affinity
                }</span>
                <span class="cov8" title="1">if len(el.Spec.Resources.KubernetesResource.Template.Spec.TopologySpreadConstraints) != 0 </span><span class="cov8" title="1">{
                        topologySpreadConstraints = el.Spec.Resources.KubernetesResource.Template.Spec.TopologySpreadConstraints
                }</span>
                <span class="cov8" title="1">annotations = el.Spec.Resources.KubernetesResource.Template.Annotations
                podlabels = kmeta.UnionMaps(podlabels, el.Spec.Resources.KubernetesResource.Template.Labels)
                if *c.SetSecurityContext </span><span class="cov8" title="1">{
                        securityContext = el.Spec.Resources.KubernetesResource.Template.Spec.SecurityContext
                }</span>
        }

        <span class="cov8" title="1">if *c.SetSecurityContext &amp;&amp; securityContext == nil </span><span class="cov8" title="1">{
                securityContext = getStrongerSecurityPolicy(cfg)
        }</span>

        <span class="cov8" title="1">return &amp;appsv1.Deployment{
                ObjectMeta: ObjectMeta(el, filteredLabels, c.StaticResourceLabels),
                Spec: appsv1.DeploymentSpec{
                        Replicas: replicas,
                        Selector: &amp;metav1.LabelSelector{
                                MatchLabels: GenerateLabels(el.Name, c.StaticResourceLabels),
                        },
                        Template: corev1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels:      podlabels,
                                        Annotations: annotations,
                                },
                                Spec: corev1.PodSpec{
                                        ImagePullSecrets:          imagePullSecrets,
                                        Tolerations:               tolerations,
                                        NodeSelector:              nodeSelector,
                                        ServiceAccountName:        serviceAccountName,
                                        Containers:                []corev1.Container{container},
                                        Volumes:                   vol,
                                        SecurityContext:           securityContext,
                                        Affinity:                  affinity,
                                        TopologySpreadConstraints: topologySpreadConstraints,
                                },
                        },
                },
        }, nil</span>
}

// revive:disable:unused-parameter

func addDeploymentBits(el *v1beta1.EventListener, c Config) (ContainerOption, error) <span class="cov8" title="1">{
        // METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint
        // env METRICS_PROMETHEUS_PORT set by controller
        metricsPort, err := strconv.ParseInt(os.Getenv("METRICS_PROMETHEUS_PORT"), 10, 32)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return func(container *corev1.Container) </span><span class="cov8" title="1">{
                if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                        if len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 </span><span class="cov8" title="1">{
                                container.Resources = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Resources
                                container.Env = append(container.Env, el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env...)
                                container.ReadinessProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].ReadinessProbe
                                container.LivenessProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].LivenessProbe
                                container.StartupProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].StartupProbe
                        }</span>
                }
                <span class="cov8" title="1">container.Ports = append(container.Ports, corev1.ContainerPort{
                        ContainerPort: int32(metricsPort), //nolint: gosec
                        Protocol:      corev1.ProtocolTCP,
                })

                container.Env = append(container.Env, corev1.EnvVar{
                        Name: "SYSTEM_NAMESPACE",
                        ValueFrom: &amp;corev1.EnvVarSource{
                                FieldRef: &amp;corev1.ObjectFieldSelector{
                                        APIVersion: "v1",
                                        FieldPath:  "metadata.namespace",
                                }},
                }, corev1.EnvVar{
                        // METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint
                        // env METRICS_PROMETHEUS_PORT set by controller
                        Name:  "METRICS_PROMETHEUS_PORT",
                        Value: os.Getenv("METRICS_PROMETHEUS_PORT"),
                }, corev1.EnvVar{
                        // KUBERNETES_MIN_VERSION overrides the min k8s version required to run EL.
                        Name:  "KUBERNETES_MIN_VERSION",
                        Value: os.Getenv("KUBERNETES_MIN_VERSION"),
                })</span>
        }, nil
}

func addCertsForSecureConnection(c Config) ContainerOption <span class="cov8" title="1">{
        return func(container *corev1.Container) </span><span class="cov8" title="1">{
                var elCert, elKey string
                certEnv := map[string]*corev1.EnvVarSource{}
                for i := range container.Env </span><span class="cov8" title="1">{
                        certEnv[container.Env[i].Name] = container.Env[i].ValueFrom
                }</span>
                <span class="cov8" title="1">var scheme corev1.URIScheme
                if v, ok := certEnv["TLS_CERT"]; ok </span><span class="cov8" title="1">{
                        elCert = "/etc/triggers/tls/" + v.SecretKeyRef.Key
                }</span> else<span class="cov8" title="1"> {
                        elCert = ""
                }</span>
                <span class="cov8" title="1">if v, ok := certEnv["TLS_KEY"]; ok </span><span class="cov8" title="1">{
                        elKey = "/etc/triggers/tls/" + v.SecretKeyRef.Key
                }</span> else<span class="cov8" title="1"> {
                        elKey = ""
                }</span>

                <span class="cov8" title="1">if elCert != "" &amp;&amp; elKey != "" </span><span class="cov8" title="1">{
                        scheme = corev1.URISchemeHTTPS
                        container.VolumeMounts = append(container.VolumeMounts, corev1.VolumeMount{
                                Name:      "https-connection",
                                ReadOnly:  true,
                                MountPath: "/etc/triggers/tls",
                        })
                }</span> else<span class="cov8" title="1"> {
                        scheme = corev1.URISchemeHTTP
                }</span>
                <span class="cov8" title="1">if container.LivenessProbe == nil </span><span class="cov8" title="1">{
                        container.LivenessProbe = &amp;corev1.Probe{
                                ProbeHandler: corev1.ProbeHandler{
                                        HTTPGet: &amp;corev1.HTTPGetAction{
                                                Path:   "/live",
                                                Scheme: scheme,
                                                Port:   intstr.FromInt(eventListenerContainerPort),
                                        },
                                },
                                PeriodSeconds:    int32(*c.PeriodSeconds),    //nolint: gosec
                                FailureThreshold: int32(*c.FailureThreshold), //nolint: gosec
                        }
                }</span>
                <span class="cov8" title="1">if container.ReadinessProbe == nil </span><span class="cov8" title="1">{
                        container.ReadinessProbe = &amp;corev1.Probe{
                                ProbeHandler: corev1.ProbeHandler{
                                        HTTPGet: &amp;corev1.HTTPGetAction{
                                                Path:   "/live",
                                                Scheme: scheme,
                                                Port:   intstr.FromInt(eventListenerContainerPort),
                                        },
                                },
                                PeriodSeconds:    int32(*c.PeriodSeconds),    //nolint: gosec
                                FailureThreshold: int32(*c.FailureThreshold), //nolint: gosec
                        }
                }</span>
                <span class="cov8" title="1">container.Args = append(container.Args, "--tls-cert="+elCert, "--tls-key="+elKey)</span>
        }
}
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "regexp"

        "github.com/tektoncd/triggers/pkg/apis/config"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "knative.dev/pkg/kmeta"

        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

// ObjectMeta generates the object meta that should be used by all
// resources generated by the EventListener reconciler
func ObjectMeta(el *v1beta1.EventListener, filteredElLabels, staticResourceLabels map[string]string) metav1.ObjectMeta <span class="cov8" title="1">{
        return metav1.ObjectMeta{
                Namespace:       el.Namespace,
                Name:            el.Status.Configuration.GeneratedResourceName,
                OwnerReferences: []metav1.OwnerReference{*kmeta.NewControllerRef(el)},
                Labels:          kmeta.UnionMaps(filteredElLabels, GenerateLabels(el.Name, staticResourceLabels)),
                Annotations:     el.Annotations,
        }
}</span>

// GenerateLabels generates the labels to be used on all generated resources.
func GenerateLabels(eventListenerName string, staticResourceLabels map[string]string) map[string]string <span class="cov8" title="1">{
        resourceLabels := kmeta.CopyMap(staticResourceLabels)
        resourceLabels["eventlistener"] = eventListenerName
        return resourceLabels
}</span>

// FilterLabels filters label based on regex pattern defined in
// feature-flag `labels-exclusion-pattern`
func FilterLabels(ctx context.Context, labels map[string]string) map[string]string <span class="cov8" title="1">{
        cfg := config.FromContextOrDefaults(ctx)

        if len(labels) == 0 || cfg.FeatureFlags.LabelsExclusionPattern == "" </span><span class="cov8" title="1">{
                return labels
        }</span>

        <span class="cov8" title="1">filteredLabels := make(map[string]string)
        r := regexp.MustCompile(cfg.FeatureFlags.LabelsExclusionPattern)

        for key, value := range labels </span><span class="cov8" title="1">{
                if !r.MatchString(key) </span><span class="cov8" title="1">{
                        filteredLabels[key] = value
                }</span>
        }

        <span class="cov8" title="1">return filteredLabels</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "fmt"

        "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/util/intstr"
        "knative.dev/pkg/network"
)

const (
        // eventListenerServicePortName defines service port name for EventListener Service
        eventListenerServicePortName = "http-listener"
        // eventListenerServiceTLSPortName defines service TLS port name for EventListener Service
        eventListenerServiceTLSPortName = "https-listener"
        // eventListenerMetricsPortName defines the metrics port name by the EventListener Container
        eventListenerMetricsPortName = "http-metrics"
        // eventListenerContainerPort defines service port for EventListener Service
        eventListenerContainerPort = 8080
        // eventListenerMetricsPort defines metrics port for EventListener Service
        eventListenerMetricsPort = 9000
)

var metricsPort = corev1.ServicePort{
        Name:     eventListenerMetricsPortName,
        Protocol: corev1.ProtocolTCP,
        Port:     int32(9000),
        TargetPort: intstr.IntOrString{
                IntVal: int32(eventListenerMetricsPort),
        },
}

func MakeService(ctx context.Context, el *v1beta1.EventListener, c Config) *corev1.Service <span class="cov8" title="1">{
        // for backward compatibility with original behavior
        var (
                serviceType corev1.ServiceType
                servicePort corev1.ServicePort
        )
        if el.Spec.Resources.KubernetesResource != nil &amp;&amp; el.Spec.Resources.KubernetesResource.ServiceType != "" </span><span class="cov8" title="1">{
                serviceType = el.Spec.Resources.KubernetesResource.ServiceType
        }</span>
        <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource != nil &amp;&amp; el.Spec.Resources.KubernetesResource.ServicePort != nil </span><span class="cov8" title="1">{
                port := int(*el.Spec.Resources.KubernetesResource.ServicePort)
                c.Port = &amp;port
        }</span>

        <span class="cov8" title="1">servicePort = ServicePort(el, c)

        svc := &amp;corev1.Service{
                ObjectMeta: ObjectMeta(el, FilterLabels(ctx, el.Labels), c.StaticResourceLabels),
                Spec: corev1.ServiceSpec{
                        Selector: GenerateLabels(el.Name, c.StaticResourceLabels),
                        Type:     serviceType,
                        Ports:    []corev1.ServicePort{servicePort, metricsPort}},
        }

        if el.Spec.Resources.KubernetesResource != nil &amp;&amp; el.Spec.Resources.KubernetesResource.ServiceLoadBalancerClass != nil </span><span class="cov8" title="1">{
                svc.Spec.LoadBalancerClass = el.Spec.Resources.KubernetesResource.ServiceLoadBalancerClass
        }</span>

        <span class="cov8" title="1">return svc</span>
}

func ServicePort(el *v1beta1.EventListener, c Config) corev1.ServicePort <span class="cov8" title="1">{
        var elCert, elKey string

        nodePort := int32(0)
        servicePortName := eventListenerServicePortName
        servicePort := *c.Port

        certEnv := map[string]*corev1.EnvVarSource{}
        if el.Spec.Resources.KubernetesResource != nil </span><span class="cov8" title="1">{
                if len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 </span><span class="cov8" title="1">{
                        for i := range el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env </span><span class="cov8" title="1">{
                                certEnv[el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env[i].Name] =
                                        el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env[i].ValueFrom
                        }</span>
                }
                <span class="cov8" title="1">if el.Spec.Resources.KubernetesResource.ServicePort != nil </span><span class="cov8" title="1">{
                        servicePort = int(*el.Spec.Resources.KubernetesResource.ServicePort)
                        if el.Spec.Resources.KubernetesResource.ServiceType == corev1.ServiceTypeNodePort </span><span class="cov8" title="1">{
                                nodePort = *el.Spec.Resources.KubernetesResource.ServicePort
                        }</span>
                }
        }

        <span class="cov8" title="1">if v, ok := certEnv["TLS_CERT"]; ok </span><span class="cov8" title="1">{
                elCert = v.SecretKeyRef.Key
        }</span> else<span class="cov8" title="1"> {
                elCert = ""
        }</span>
        <span class="cov8" title="1">if v, ok := certEnv["TLS_KEY"]; ok </span><span class="cov8" title="1">{
                elKey = v.SecretKeyRef.Key
        }</span> else<span class="cov8" title="1"> {
                elKey = ""
        }</span>

        <span class="cov8" title="1">if elCert != "" &amp;&amp; elKey != "" </span><span class="cov8" title="1">{
                servicePortName = eventListenerServiceTLSPortName
                if *c.Port == DefaultPort </span><span class="cov8" title="1">{
                        // We return port 8443 if TLS is enabled and the default HTTP port is set.
                        // This effectively makes 8443 the default HTTPS port unless a user explicitly sets a different port.
                        servicePort = 8443
                }</span>
        }

        <span class="cov8" title="1">svc := corev1.ServicePort{
                Name:     servicePortName,
                Protocol: corev1.ProtocolTCP,
                Port:     int32(servicePort), //nolint: gosec
                TargetPort: intstr.IntOrString{
                        IntVal: int32(eventListenerContainerPort),
                },
                NodePort: nodePort,
        }

        return svc</span>
}

// ListenerHostname returns the intended hostname for the EventListener service.
func ListenerHostname(el *v1beta1.EventListener, c Config) string <span class="cov8" title="1">{
        sp := ServicePort(el, c)
        return network.GetServiceHostname(el.Status.Configuration.GeneratedResourceName, el.Namespace) + fmt.Sprintf(":%d", sp.Port)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package events

import (
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/client-go/tools/record"
)

const (
        // TriggerProcessingStartedV1 is sent for Sink Triggers when a trigger is started
        TriggerProcessingStartedV1 = "dev.tekton.event.triggers.started.v1"
        // TriggerProcessingSuccessfulV1 is sent for Sink Triggers when a trigger is successful
        TriggerProcessingSuccessfulV1 = "dev.tekton.event.triggers.successful.v1"
        // TriggerProcessingFailedEventV1 is sent for Sink Triggers when we fail to process trigger
        TriggerProcessingFailedV1 = "dev.tekton.event.triggers.failed.v1"
        // TriggerProcessingDoneV1 is sent for Sink Triggers when we are done
        // with eventlistener handler
        TriggerProcessingDoneV1 = "dev.tekton.event.triggers.done.v1"
        // EventAccepted is sent as response for CloudEvent compliant providers
        EventAccepted = "dev.tekton.event.triggers.accepted.v1"
)

// Emit emits events for object
// Supported events are k8s events.
func Emit(recorder record.EventRecorder, eventType string, object runtime.Object, err error) <span class="cov0" title="0">{
        sendKubernetesEvents(recorder, eventType, object, err)
}</span>

func sendKubernetesEvents(c record.EventRecorder, eventType string, object runtime.Object, err error) <span class="cov8" title="1">{
        switch err </span>{
        case nil:<span class="cov8" title="1">
                if eventType == TriggerProcessingFailedV1 </span><span class="cov0" title="0">{
                        c.Event(object, corev1.EventTypeWarning, eventType, "")
                }</span> else<span class="cov8" title="1"> {
                        c.Event(object, corev1.EventTypeNormal, eventType, "")
                }</span>
        default:<span class="cov8" title="1">
                c.Event(object, corev1.EventTypeWarning, eventType, err.Error())</span>
        }
}
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptor

import (
        "context"

        interceptorinformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor"
        interceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor"
        "knative.dev/pkg/configmap"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/logging"
)

func NewController() func(context.Context, configmap.Watcher) *controller.Impl <span class="cov0" title="0">{
        return func(ctx context.Context, _ configmap.Watcher) *controller.Impl </span><span class="cov0" title="0">{
                interceptorInformer := interceptorinformer.Get(ctx)
                reconciler := &amp;Reconciler{}

                impl := interceptorreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options </span><span class="cov0" title="0">{
                        return controller.Options{
                                AgentName: ControllerName,
                        }
                }</span>)

                <span class="cov0" title="0">if _, err := interceptorInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil </span><span class="cov0" title="0">{
                        logging.FromContext(ctx).Panicf("Couldn't register Interceptor informer event handler: %w", err)
                }</span>

                <span class="cov0" title="0">return impl</span>
        }
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package interceptor

import (
        "context"

        "github.com/tektoncd/triggers/pkg/apis/triggers/contexts"
        "github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1"
        interceptorreconciler "github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor"
        v1 "knative.dev/pkg/apis/duck/v1"
        "knative.dev/pkg/logging"
        pkgreconciler "knative.dev/pkg/reconciler"
)

const ControllerName = "Interceptor"

// Reconciler implements controller.Reconciler for Configuration resources.
type Reconciler struct {
}

var (
        // Check that our Reconciler implements interceptorreconciler.Interface
        _ interceptorreconciler.Interface = (*Reconciler)(nil)
)

func (r *Reconciler) ReconcileKind(ctx context.Context, it *v1alpha1.Interceptor) pkgreconciler.Event <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)
        if it.Status.Address == nil </span><span class="cov8" title="1">{ // Initialize Address if needed
                it.Status.Address = &amp;v1.Addressable{}
        }</span>
        <span class="cov8" title="1">if contexts.IsUpgradeViaDefaulting(ctx) </span><span class="cov8" title="1">{ // Set defaults
                it.SetDefaults(ctx)
        }</span>
        <span class="cov8" title="1">url, err := it.ResolveAddress()
        logger.Debugf("Resolved Address is %s", url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">it.Status.Address.URL = url
        return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"

        ciInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor"
        ctbInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding"
        elInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener"
        tbInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding"
        ttInformer "github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/controller"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{ return WithClient(ctx) }</span>)
        <span class="cov8" title="1">injection.Default.RegisterInformer(WithInformer)</span>
}

// RecorderKey is used for associating the Recorder inside the context.Context.
type RecorderKey struct{}

func WithClient(ctx context.Context) context.Context <span class="cov8" title="1">{
        rec, err := NewRecorder(ctx)
        if err != nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf("Failed to create trigger metrics recorder %v", err)
        }</span>
        <span class="cov8" title="1">return context.WithValue(ctx, RecorderKey{}, rec)</span>
}

// Get extracts the pipelinerunmetrics.Recorder from the context.
func Get(ctx context.Context) *Recorder <span class="cov8" title="1">{
        untyped := ctx.Value(RecorderKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Panic("Unable to fetch *metrics.Recorder from context.")
        }</span>
        <span class="cov8" title="1">return untyped.(*Recorder)</span>
}

type recorderInformer struct {
        ctx     context.Context //nolint:containedctx
        metrics *Recorder
        listers
}

// InformerKey is used for associating the Informer inside the context.Context.
type InformerKey struct{}

func WithInformer(ctx context.Context) (context.Context, controller.Informer) <span class="cov0" title="0">{
        return ctx, &amp;recorderInformer{
                ctx:     ctx,
                metrics: Get(ctx),
                listers: listers{
                        el:  elInformer.Get(ctx).Lister(),
                        ctb: ctbInformer.Get(ctx).Lister(),
                        tb:  tbInformer.Get(ctx).Lister(),
                        tt:  ttInformer.Get(ctx).Lister(),
                        ci:  ciInformer.Get(ctx).Lister(),
                },
        }
}</span>

var _ controller.Informer = (*recorderInformer)(nil)

func (ri *recorderInformer) Run(stopCh &lt;-chan struct{}) <span class="cov0" title="0">{
        // Turn the stopCh into a context for reporting metrics.
        ctx, cancel := context.WithCancel(ri.ctx)
        go func() </span><span class="cov0" title="0">{
                &lt;-stopCh
                cancel()
        }</span>()

        <span class="cov0" title="0">go ri.metrics.ReportCountMetrics(ctx, ri.listers)</span>
}

func (ri *recorderInformer) HasSynced() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package metrics

import (
        "context"
        "sync"
        "time"

        "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "k8s.io/apimachinery/pkg/labels"
        "knative.dev/pkg/logging"
        "knative.dev/pkg/metrics"
)

var (
        elMetricsName = "eventlistener_count"
        elCount       = stats.Float64(elMetricsName,
                "number of eventlistener",
                stats.UnitDimensionless)
        elCountView *view.View

        tbMetricsName = "triggerbinding_count"
        tbCount       = stats.Float64(tbMetricsName,
                "number of triggerbinding",
                stats.UnitDimensionless)
        tbCountView *view.View

        ctbMetricsName = "clustertriggerbinding_count"
        ctbCount       = stats.Float64(ctbMetricsName,
                "number of clustertriggerbinding",
                stats.UnitDimensionless)
        ctbCountView *view.View

        ttMetricsName = "triggertemplate_count"
        ttCount       = stats.Float64(ttMetricsName,
                "number of triggertemplate",
                stats.UnitDimensionless)
        ttCountView *view.View

        ciMetricsName = "clusterinterceptor_count"
        ciCount       = stats.Float64(ciMetricsName,
                "number of clusterinterceptor",
                stats.UnitDimensionless)
        ciCountView *view.View
)

type listers struct {
        el  v1beta1.EventListenerLister
        ctb v1beta1.ClusterTriggerBindingLister
        tb  v1beta1.TriggerBindingLister
        tt  v1beta1.TriggerTemplateLister
        ci  v1alpha1.ClusterInterceptorLister
}

// Recorder holds information for Trigger metrics
type Recorder struct {
        initialized     bool
        ReportingPeriod time.Duration
}

// We cannot register the view multiple times, so NewRecorder lazily
// initializes this singleton and returns the same recorder across any
// subsequent invocations.
var (
        once        sync.Once
        r           *Recorder
        recorderErr error //nolint:errname
)

// revive:disable:unused-parameter

// NewRecorder creates a new metrics recorder instance
// to log the PipelineRun related metrics
func NewRecorder(ctx context.Context) (*Recorder, error) <span class="cov8" title="1">{
        once.Do(func() </span><span class="cov8" title="1">{
                r = &amp;Recorder{
                        initialized: true,
                        // Default to reporting metrics every 60s.
                        ReportingPeriod: 60 * time.Second,
                }

                recorderErr = viewRegister()
                if recorderErr != nil </span><span class="cov0" title="0">{
                        r.initialized = false
                        return
                }</span>
        })

        <span class="cov8" title="1">return r, recorderErr</span>
}

func viewRegister() error <span class="cov8" title="1">{
        elCountView = &amp;view.View{
                Description: elCount.Description(),
                Measure:     elCount,
                Aggregation: view.LastValue(),
        }

        tbCountView = &amp;view.View{
                Description: tbCount.Description(),
                Measure:     tbCount,
                Aggregation: view.LastValue(),
        }

        ctbCountView = &amp;view.View{
                Description: ctbCount.Description(),
                Measure:     ctbCount,
                Aggregation: view.LastValue(),
        }

        ttCountView = &amp;view.View{
                Description: ttCount.Description(),
                Measure:     ttCount,
                Aggregation: view.LastValue(),
        }

        ciCountView = &amp;view.View{
                Description: ciCount.Description(),
                Measure:     ciCount,
                Aggregation: view.LastValue(),
        }

        return view.Register(
                elCountView,
                tbCountView,
                ctbCountView,
                ttCountView,
                ciCountView,
        )
}</span>

func (r *Recorder) ReportCountMetrics(ctx context.Context, li listers) <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // When the context is cancelled, stop reporting.
                        return</span>

                case &lt;-time.After(r.ReportingPeriod):<span class="cov0" title="0">
                        r.CountMetrics(ctx, li)</span>
                }
        }
}

func (r *Recorder) CountMetrics(ctx context.Context, li listers) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        el, err := li.el.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for eventlisteners: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(el)
                r.countMetrics(ctx, float64(count), elCount)
        }</span>
        <span class="cov8" title="1">ci, err := li.ci.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for clusterinterceptor: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(ci)
                r.countMetrics(ctx, float64(count), ciCount)
        }</span>
        <span class="cov8" title="1">tb, err := li.tb.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for triggerbindings : %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(tb)
                r.countMetrics(ctx, float64(count), tbCount)
        }</span>
        <span class="cov8" title="1">ctb, err := li.ctb.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for clustertriggerbindings: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(ctb)
                r.countMetrics(ctx, float64(count), ctbCount)
        }</span>
        <span class="cov8" title="1">tt, err := li.tt.List(labels.Everything())
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error reporting trigger metrics for triggertemplates: %v", err)
        }</span> else<span class="cov8" title="1"> {
                count := len(tt)
                r.countMetrics(ctx, float64(count), ttCount)
        }</span>
}

func (r *Recorder) countMetrics(ctx context.Context, count float64, measure *stats.Float64Measure) <span class="cov8" title="1">{
        logger := logging.FromContext(ctx)

        if !r.initialized </span><span class="cov8" title="1">{
                logger.Errorf("ignoring the metrics recording for %s, failed to initialize the metrics recorder", measure.Description())
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, measure.M(count))</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package resources

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/tektoncd/triggers/pkg/apis/triggers"
        kerrors "k8s.io/apimachinery/pkg/api/errors"

        "k8s.io/client-go/dynamic"

        "go.uber.org/zap"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "k8s.io/apimachinery/pkg/runtime/schema"
        discoveryclient "k8s.io/client-go/discovery"
)

// findAPIResource returns the APIResource definition using the discovery client c.
func findAPIResource(apiVersion, kind string, c discoveryclient.ServerResourcesInterface) (*metav1.APIResource, error) <span class="cov8" title="1">{
        resourceList, err := c.ServerResourcesForGroupVersion(apiVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("error getting kubernetes server resources for apiVersion %s: %w", apiVersion, err)
        }</span>
        <span class="cov8" title="1">for i := range resourceList.APIResources </span><span class="cov8" title="1">{
                r := &amp;resourceList.APIResources[i]
                if r.Kind != kind </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Resolve GroupVersion from parent list to have consistent resource identifiers.
                <span class="cov8" title="1">if r.Version == "" || r.Group == "" </span><span class="cov8" title="1">{
                        gv, err := schema.ParseGroupVersion(resourceList.GroupVersion)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("error parsing GroupVersion: %w", err)
                        }</span>
                        <span class="cov8" title="1">r.Group = gv.Group
                        r.Version = gv.Version</span>
                }
                <span class="cov8" title="1">return r, nil</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("error could not find resource with apiVersion %s and kind %s", apiVersion, kind)</span>
}

// Create uses the kubeClient to create the resource defined in the
// TriggerResourceTemplate and returns any errors with this process
func Create(logger *zap.SugaredLogger, rt json.RawMessage, triggerName, eventID, elName, elNamespace string, c discoveryclient.ServerResourcesInterface, dc dynamic.Interface) error <span class="cov8" title="1">{
        // Assume the TriggerResourceTemplate is valid (it has an apiVersion and Kind)
        data := new(unstructured.Unstructured)
        if err := data.UnmarshalJSON(rt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't unmarshal json from the TriggerTemplate: %w", err)
        }</span>

        <span class="cov8" title="1">data, err := addLabels(data, map[string]string{
                triggers.EventListenerLabelKey: elName,
                triggers.EventIDLabelKey:       eventID,
                triggers.TriggerLabelKey:       triggerName,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">namespace := data.GetNamespace()
        // Default the resource creation to the EventListenerNamespace if not found in the resource template
        if namespace == "" </span><span class="cov8" title="1">{
                namespace = elNamespace
        }</span>

        // Resolve resource kind to the underlying API Resource type.
        <span class="cov8" title="1">apiResource, err := findAPIResource(data.GetAPIVersion(), data.GetKind(), c)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("couldn't find API resource for json: %w", err)
        }</span>

        <span class="cov8" title="1">name := data.GetName()
        if name == "" </span><span class="cov0" title="0">{
                name = data.GetGenerateName()
        }</span>
        <span class="cov8" title="1">logger.Infof("Generating resource: kind: %s, name: %s", apiResource, name)

        gvr := schema.GroupVersionResource{
                Group:    apiResource.Group,
                Version:  apiResource.Version,
                Resource: apiResource.Name,
        }

        logger.Infof("For event ID %q creating resource %v", eventID, gvr)

        if _, err := dc.Resource(gvr).Namespace(namespace).Create(context.Background(), data, metav1.CreateOptions{}); err != nil </span><span class="cov0" title="0">{
                if kerrors.IsUnauthorized(err) || kerrors.IsForbidden(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("couldn't create resource with group version kind %q: %w", gvr, err)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// addLabels adds autogenerated Tekton labels to created resources.
func addLabels(us *unstructured.Unstructured, labelsToAdd map[string]string) (*unstructured.Unstructured, error) <span class="cov8" title="1">{
        labels, _, err := unstructured.NestedStringMap(us.Object, "metadata", "labels")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if labels == nil </span><span class="cov8" title="1">{
                labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">for k, v := range labelsToAdd </span><span class="cov8" title="1">{
                l := fmt.Sprintf("%s/%s", triggers.GroupName, strings.TrimLeft(k, "/"))
                labels[l] = v
        }</span>

        <span class="cov8" title="1">us.SetLabels(labels)
        return us, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
Copyright 2020 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "fmt"

        "go.uber.org/zap"
        discoveryclient "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
)

// AuthOverride is an interface that constructs a discovery client for the ServerResourceInterface
// and a dynamic client for the Tekton Resources, using the token provide as the bearer token in the
// REST config used to build those client.  The other non-credential related parameters for the
// REST client used are copied from the in cluster config of the event sink.
type AuthOverride interface {
        OverrideAuthentication(sa string,
                namespace string,
                log *zap.SugaredLogger,
                defaultDiscoveryClient discoveryclient.ServerResourcesInterface,
                defaultDynamicClient dynamic.Interface) (discoveryClient discoveryclient.ServerResourcesInterface,
                dynamicClient dynamic.Interface,
                err error)
}

type DefaultAuthOverride struct {
}

func (r DefaultAuthOverride) OverrideAuthentication(sa string,
        namespace string,
        log *zap.SugaredLogger,
        defaultDiscoverClient discoveryclient.ServerResourcesInterface,
        defaultDynamicClient dynamic.Interface) (discoveryClient discoveryclient.ServerResourcesInterface,
        dynamicClient dynamic.Interface,
        err error) <span class="cov0" title="0">{
        dynamicClient = defaultDynamicClient
        discoveryClient = defaultDiscoverClient
        clusterConfig, err := rest.InClusterConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("overrideAuthentication: problem getting in cluster config: %#v\n", err)
                return
        }</span>
        <span class="cov0" title="0">clusterConfig.Impersonate = rest.ImpersonationConfig{
                UserName: fmt.Sprintf("system:serviceaccount:%s:%s", namespace, sa),
        }
        dynamicClient, err = dynamic.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("overrideAuthentication: problem getting dynamic client set: %#v\n", err)
                return
        }</span>
        <span class="cov0" title="0">kubeClient, err := kubernetes.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("overrideAuthentication: problem getting kube client: %#v\n", err)
                return
        }</span>
        <span class="cov0" title="0">discoveryClient = kubeClient.Discovery()

        return</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
Copyright 2022 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "fmt"
        "time"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "go.uber.org/zap"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

// CEClient matches the `Client` interface from github.com/cloudevents/sdk-go/v2/cloudevents
type CEClient cloudevents.Client

// Resource structure defines parameters needed to send cloudEvents
type Resource struct {
        EventID   string
        EventType string
        TargetURI string
        Client    CEClient
        Logger    *zap.SugaredLogger
        Data      []byte
        EL        triggersv1.EventListener
}

// SendCloudEvents is used by the EventListener to send cloud events status of
// trigger processing
func (r Resource) SendCloudEvents() <span class="cov8" title="1">{
        logger := r.Logger.With(zap.String("trigger", r.EL.Name))

        event := cloudevents.NewEvent()
        event.SetID(r.EventID)
        event.SetSubject(r.EL.Name + " processing " + r.EventID)
        gvk := r.EL.GetObjectKind().GroupVersionKind()
        source := fmt.Sprintf("/apis/%s/%s/namespaces/%s/%s/%s",
                gvk.Group,
                gvk.Version,
                r.EL.Namespace,
                gvk.Kind,
                r.EL.Name)
        event.SetSource(source)
        event.SetType(r.EventType)

        if err := event.SetData(cloudevents.ApplicationJSON, r.Data); err != nil </span><span class="cov0" title="0">{
                logger.With(zap.Error(err)).Error("failed to set cloudevent data.")
                return
        }</span>

        // Send the event.
        <span class="cov8" title="1">result := r.Client.Send(cloudevents.ContextWithTarget(cloudevents.ContextWithRetriesExponentialBackoff(context.Background(), 10*time.Millisecond, 10), r.TargetURI), event)

        if !cloudevents.IsACK(result) </span><span class="cov0" title="0">{
                logger.With(zap.Error(result)).Error("failed to send cloudevent.")
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cloudevent

import (
        "context"
        "net/http"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "k8s.io/client-go/rest"
        "knative.dev/pkg/injection"
        "knative.dev/pkg/logging"
)

func init() <span class="cov8" title="1">{
        injection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context </span><span class="cov0" title="0">{
                return withCloudEventClient(ctx)
        }</span>)
}

// CECKey is used to associate the CloudEventClient inside the context.Context
type CECKey struct{}

func withCloudEventClient(ctx context.Context) context.Context <span class="cov0" title="0">{
        logger := logging.FromContext(ctx)

        // When KeepAlive is enabled the connections are not reused - see
        // Bug https://github.com/tektoncd/pipeline/issues/3190. This causes the
        // number of connections to keep growing, even if when we limit max idle
        // connections in the transport.
        // TODO(afrittoli) Re-enable keep alive and ensure connections are reused
        // See feature https://github.com/tektoncd/pipeline/issues/3204
        var useOnceTransport http.RoundTripper = &amp;http.Transport{
                DisableKeepAlives: true,
        }

        p, err := cloudevents.NewHTTP(cloudevents.WithRoundTripper(useOnceTransport))
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Error creating the cloudevents http protocol: %s", err)
        }</span>

        <span class="cov0" title="0">cloudEventClient, err := cloudevents.NewClient(p, cloudevents.WithUUIDs(), cloudevents.WithTimeNow())
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicf("Error creating the cloudevents client: %s", err)
        }</span>

        <span class="cov0" title="0">return context.WithValue(ctx, CECKey{}, cloudEventClient)</span>
}

// Get extracts the cloudEventClient client from the context.
func Get(ctx context.Context) CEClient <span class="cov0" title="0">{
        untyped := ctx.Value(CECKey{})
        if untyped == nil </span><span class="cov0" title="0">{
                logging.FromContext(ctx).Errorf(
                        "Unable to fetch client from context.")
                return nil
        }</span>
        <span class="cov0" title="0">return untyped.(CEClient)</span>
}

// ToContext adds the cloud events client to the context
func ToContext(ctx context.Context, cec CEClient) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, CECKey{}, cec)
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "context"
        "flag"
        "time"

        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        "github.com/tektoncd/triggers/pkg/sink/cloudevent"
        "golang.org/x/xerrors"
        discoveryclient "k8s.io/client-go/discovery"
        kubeclientset "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/rest"
        restclient "k8s.io/client-go/rest"
)

const (
        // Flag definitions
        name        = "el-name"
        elNamespace = "el-namespace"
        port        = "port"
        isMultiNS   = "is-multi-ns"
)

var (
        nameFlag = flag.String("el-name", "",
                "The name of the EventListener resource for this sink.")
        namespaceFlag = flag.String("el-namespace", "",
                "The namespace of the EventListener resource for this sink.")
        portFlag = flag.String("port", "",
                "The port for the EventListener sink to listen on.")
        elReadTimeOut = flag.Int64("readtimeout", 5,
                "The read timeout for EventListener Server.")
        elWriteTimeOut = flag.Int64("writetimeout", 40,
                "The write timeout for EventListener Server.")
        elIdleTimeOut = flag.Int64("idletimeout", 30,
                "The idle timeout for EventListener Server.")
        elTimeOutHandler = flag.Int64("timeouthandler", 5,
                "The timeout for Timeout Handler of EventListener Server.")
        elHTTPClientReadTimeOut = flag.Int64("httpclient-readtimeout", 30,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientKeepAlive = flag.Int64("httpclient-keep-alive", 30,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientTLSHandshakeTimeout = flag.Int64("httpclient-tlshandshaketimeout", 10,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientResponseHeaderTimeout = flag.Int64("httpclient-responseheadertimeout", 10,
                "The HTTP Client read timeout for EventListener Server.")
        elHTTPClientExpectContinueTimeout = flag.Int64("httpclient-expectcontinuetimeout", 1,
                "The HTTP Client read timeout for EventListener Server.")
        isMultiNSFlag = flag.Bool("is-multi-ns", false,
                "Whether EventListener serve Multiple NS.")
        tlsCertFlag = flag.String("tls-cert", "",
                "The filename for the TLS certificate.")
        tlsKeyFlag = flag.String("tls-key", "",
                "The filename for the TLS key.")
        payloadValidation = flag.Bool("payload-validation", true,
                "Whether to disable payload validation or not.")
        cloudEventURI = flag.String("cloudevent-uri", "", "uri for cloudevent")
)

// Args define the arguments for Sink.
type Args struct {
        // ElName is the EventListener name.
        ElName string
        // ElNamespace is the EventListener namespace.
        ElNamespace string
        // Port is the port the Sink should listen on.
        Port string
        // ELReadTimeOut defines the read timeout for EventListener Server
        ELReadTimeOut time.Duration
        // ELWriteTimeOut defines the write timeout for EventListener Server
        ELWriteTimeOut time.Duration
        // ELIdleTimeOut defines the read timeout for EventListener Server
        ELIdleTimeOut time.Duration
        // ELTimeOutHandler defines the timeout for Timeout Handler of EventListener Server
        ELTimeOutHandler time.Duration
        // ElHTTPClientReadTimeOut defines the Read timeout for HTTP Client
        ElHTTPClientReadTimeOut time.Duration
        // ElHTTPClientKeepAlive defines the Keep Alive for HTTP Client
        ElHTTPClientKeepAlive time.Duration
        // ElTLSHandshakeTimeout defines the Handshake timeout for HTTP Client
        ElHTTPClientTLSHandshakeTimeout time.Duration
        // ElResponseHeaderTimeout defines the Response Header timeout for HTTP Client
        ElHTTPClientResponseHeaderTimeout time.Duration
        // ElExpectContinueTimeout defines the Expect timeout for HTTP Client
        ElHTTPClientExpectContinueTimeout time.Duration
        // IsMultiNS determines whether el functions as namespaced or clustered
        IsMultiNS bool
        // Key defines the filename for tls Key.
        Key string
        // Cert defines the filename for tls Cert.
        Cert string
        // PayloadValidation defines whether to validate payload or not
        PayloadValidation bool
        // CloudEventURI refers to the location where cloudevent data need to be send
        CloudEventURI string
}

// Clients define the set of client dependencies Sink requires.
type Clients struct {
        DiscoveryClient discoveryclient.DiscoveryInterface
        RESTClient      restclient.Interface
        TriggersClient  triggersclientset.Interface
        K8sClient       *kubeclientset.Clientset
        CEClient        cloudevent.CEClient
}

// GetArgs returns the flagged Args
func GetArgs() (Args, error) <span class="cov8" title="1">{
        flag.Parse()
        if *nameFlag == "" </span><span class="cov8" title="1">{
                return Args{}, xerrors.Errorf("-%s arg not found", name)
        }</span>
        <span class="cov8" title="1">if *namespaceFlag == "" </span><span class="cov8" title="1">{
                return Args{}, xerrors.Errorf("-%s arg not found", elNamespace)
        }</span>
        <span class="cov8" title="1">if *portFlag == "" </span><span class="cov8" title="1">{
                return Args{}, xerrors.Errorf("-%s arg not found", port)
        }</span>

        <span class="cov8" title="1">return Args{
                ElName:                            *nameFlag,
                ElNamespace:                       *namespaceFlag,
                Port:                              *portFlag,
                IsMultiNS:                         *isMultiNSFlag,
                PayloadValidation:                 *payloadValidation,
                ELReadTimeOut:                     time.Duration(*elReadTimeOut),
                ELWriteTimeOut:                    time.Duration(*elWriteTimeOut),
                ELIdleTimeOut:                     time.Duration(*elIdleTimeOut),
                ELTimeOutHandler:                  time.Duration(*elTimeOutHandler),
                ElHTTPClientReadTimeOut:           time.Duration(*elHTTPClientReadTimeOut),
                ElHTTPClientKeepAlive:             time.Duration(*elHTTPClientKeepAlive),
                ElHTTPClientTLSHandshakeTimeout:   time.Duration(*elHTTPClientTLSHandshakeTimeout),
                ElHTTPClientResponseHeaderTimeout: time.Duration(*elHTTPClientResponseHeaderTimeout),
                ElHTTPClientExpectContinueTimeout: time.Duration(*elHTTPClientExpectContinueTimeout),
                Cert:                              *tlsCertFlag,
                Key:                               *tlsKeyFlag,
                CloudEventURI:                     *cloudEventURI,
        }, nil</span>
}

// ConfigureClients returns the kubernetes and triggers clientsets
func ConfigureClients(ctx context.Context, clusterConfig *rest.Config) (Clients, error) <span class="cov0" title="0">{
        kubeClient, err := kubeclientset.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                return Clients{}, xerrors.Errorf("Failed to create KubeClient: %s", err)
        }</span>
        <span class="cov0" title="0">triggersClient, err := triggersclientset.NewForConfig(clusterConfig)
        if err != nil </span><span class="cov0" title="0">{
                return Clients{}, xerrors.Errorf("Failed to create TriggersClient: %s", err)
        }</span>
        <span class="cov0" title="0">ceClient := cloudevent.Get(ctx)
        return Clients{
                DiscoveryClient: kubeClient.Discovery(),
                RESTClient:      kubeClient.RESTClient(),
                TriggersClient:  triggersClient,
                K8sClient:       kubeClient,
                CEClient:        ceClient,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package sink

import (
        "context"
        "encoding/json"
        "log"
        "net/http"
        "time"

        "go.opencensus.io/stats"
        "go.opencensus.io/stats/view"
        "go.opencensus.io/tag"
        "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
        "knative.dev/pkg/metrics"
)

var (
        elDuration = stats.Float64(
                "http_duration_seconds",
                "The eventlistener HTTP request duration",
                stats.UnitDimensionless)
        elDistribution = view.Distribution(metrics.BucketsNBy10(0.001, 5)...)
        eventRcdCount  = stats.Float64("event_received_count",
                "number of events received by sink",
                stats.UnitDimensionless)
        triggeredResources = stats.Int64("triggered_resources", "Count of the number of triggered eventlistener resources", stats.UnitDimensionless)
)

const (
        failTag    = "failed"
        successTag = "succeeded"
)

// NewRecorder creates a new metrics recorder instance
// to log the TaskRun related metrics
func NewRecorder() (*Recorder, error) <span class="cov8" title="1">{
        r := &amp;Recorder{
                initialized: true,

                // Default to reporting metrics every 30s.
                ReportingPeriod: 30 * time.Second,
        }

        status, err := tag.NewKey("status")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r.status = status
        kind, err := tag.NewKey("kind")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r.kind = kind

        err = view.Register(
                &amp;view.View{
                        Description: elDuration.Description(),
                        Measure:     elDuration,
                        Aggregation: elDistribution,
                },
                &amp;view.View{
                        Description: triggeredResources.Description(),
                        Measure:     triggeredResources,
                        Aggregation: view.Count(),
                        TagKeys:     []tag.Key{r.kind},
                },
                &amp;view.View{
                        Description: eventRcdCount.Description(),
                        Measure:     eventRcdCount,
                        Aggregation: view.Count(),
                        TagKeys:     []tag.Key{r.status},
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("unable to register eventlistener metrics: %s", err)
        }</span>
        <span class="cov8" title="1">return r, nil</span>
}

func (s *Sink) NewMetricsRecorderInterceptor() MetricsInterceptor <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) </span><span class="cov8" title="1">{
                recorder := &amp;StatusRecorder{
                        ResponseWriter: w,
                        Status:         200,
                }
                startTime := time.Now()
                defer func() </span><span class="cov8" title="1">{
                        endTime := time.Now()
                        elapsed := endTime.Sub(startTime)
                        // Log the consumed time
                        go s.recordDurationMetrics(recorder, elapsed)
                }</span>()
                <span class="cov8" title="1">next(recorder, r)</span>
        }
}

func (s *Sink) recordDurationMetrics(w *StatusRecorder, elapsed time.Duration) <span class="cov8" title="1">{
        duration := elapsed.Seconds()
        s.Logger.Debugw("event listener request completed", "status", w.Status, "duration", duration)
        ctx, err := tag.New(
                context.Background(),
        )

        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warnf("failed to create tag for http metric request: %w", err)
                return
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, elDuration.M(duration))</span>
}

func (s *Sink) recordCountMetrics(status string) <span class="cov8" title="1">{
        s.Logger.Debugw("event listener request", "status", status)
        ctx, err := tag.New(
                context.Background(),
                tag.Insert(s.Recorder.status, status),
        )

        if err != nil </span><span class="cov0" title="0">{
                s.Logger.Warnf("failed to create tag for metric event_received_count: %w", err)
                return
        }</span>

        <span class="cov8" title="1">metrics.Record(ctx, eventRcdCount.M(1))</span>
}

func (s *Sink) recordResourceCreation(resources []json.RawMessage) <span class="cov8" title="1">{
        for _, rt := range resources </span><span class="cov8" title="1">{
                // Assume the TriggerResourceTemplate is valid (it has an apiVersion and Kind)
                data := new(unstructured.Unstructured)
                if err := data.UnmarshalJSON(rt); err != nil </span><span class="cov0" title="0">{
                        s.Logger.Warnf("couldn't unmarshal json from the TriggerTemplate: %v", err)
                        continue</span>
                }
                <span class="cov8" title="1">ctx, err := tag.New(context.Background(), tag.Insert(s.Recorder.kind, data.GetKind()))
                if err != nil </span><span class="cov0" title="0">{
                        s.Logger.Warnf("failed to create tag for resource creation: %w", err)
                        continue</span>
                }

                <span class="cov8" title="1">metrics.Record(ctx, triggeredResources.M(1))</span>
        }
}

type Recorder struct {
        initialized bool

        status tag.Key
        kind   tag.Key

        ReportingPeriod time.Duration
}

type StatusRecorder struct {
        http.ResponseWriter
        Status int
}

func (r *StatusRecorder) WriteHeader(status int) <span class="cov8" title="1">{
        r.Status = status
        r.ResponseWriter.WriteHeader(status)
}</span>

// MetricsInterceptor intercepts an HTTP handler invocation, it is passed both response writer and request
// which after interception can be passed onto the handler function.
type MetricsInterceptor func(http.ResponseWriter, *http.Request, http.HandlerFunc)

// MetricsHandlerFunc builds on top of http.Handler, and exposes API to intercept with MetricsInterceptor.
// This allows building complex long chains without complicated struct manipulation
type MetricsHandler struct {
        Handler http.Handler
}

// Intercept returns back a continuation that will call the handler func to intercept
// the continuation call.
func (cont *MetricsHandler) Intercept(mw MetricsInterceptor) http.HandlerFunc <span class="cov8" title="1">{
        return func(writer http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                mw(writer, request, cont.Handler.ServeHTTP)
        }</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        net "net/url"
        "os"
        "sync"

        cloudevents "github.com/cloudevents/sdk-go/v2"
        "github.com/cloudevents/sdk-go/v2/binding"
        cehttp "github.com/cloudevents/sdk-go/v2/protocol/http"
        "github.com/tektoncd/triggers/pkg/apis/triggers"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        triggersclientset "github.com/tektoncd/triggers/pkg/client/clientset/versioned"
        listersv1alpha1 "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1"
        listers "github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1"
        "github.com/tektoncd/triggers/pkg/interceptors"
        "github.com/tektoncd/triggers/pkg/interceptors/webhook"
        "github.com/tektoncd/triggers/pkg/reconciler/events"
        "github.com/tektoncd/triggers/pkg/resources"
        "github.com/tektoncd/triggers/pkg/sink/cloudevent"
        "github.com/tektoncd/triggers/pkg/template"
        "github.com/tidwall/sjson"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/labels"
        discoveryclient "k8s.io/client-go/discovery"
        "k8s.io/client-go/dynamic"
        "k8s.io/client-go/kubernetes"
        "k8s.io/client-go/tools/record"
        "knative.dev/pkg/apis"
        v1 "knative.dev/pkg/apis/duck/v1"
)

// Sink defines the sink resource for processing incoming events for the
// EventListener.
type Sink struct {
        KubeClientSet          kubernetes.Interface
        TriggersClient         triggersclientset.Interface
        DiscoveryClient        discoveryclient.ServerResourcesInterface
        DynamicClient          dynamic.Interface
        HTTPClient             *http.Client
        CEClient               cloudevent.CEClient
        EventListenerName      string
        EventListenerNamespace string
        Logger                 *zap.SugaredLogger
        Recorder               *Recorder
        Auth                   AuthOverride
        PayloadValidation      bool
        CloudEventURI          string
        // WGProcessTriggers keeps track of triggers or triggerGroups currently being processed
        // Currently only used in tests to wait for all triggers to finish processing
        WGProcessTriggers *sync.WaitGroup
        EventRecorder     record.EventRecorder

        // listers index properties about resources
        EventListenerLister         listers.EventListenerLister
        TriggerLister               listers.TriggerLister
        TriggerBindingLister        listers.TriggerBindingLister
        ClusterTriggerBindingLister listers.ClusterTriggerBindingLister
        TriggerTemplateLister       listers.TriggerTemplateLister
        ClusterInterceptorLister    listersv1alpha1.ClusterInterceptorLister
        InterceptorLister           listersv1alpha1.InterceptorLister
}

// Response defines the HTTP body that the Sink responds to events with.
type Response struct {
        // EventListener is the name of the eventListener.
        // Deprecated: use EventListenerUID instead.
        EventListener string `json:"eventListener"`
        // Namespace is the namespace that the eventListener is running in.
        // Deprecated: use EventListenerUID instead.
        Namespace string `json:"namespace,omitempty"`
        // EventListenerUID is the UID of the EventListener
        EventListenerUID string `json:"eventListenerUID"`
        // EventID is a uniqueID that gets assigned to each incoming request
        EventID string `json:"eventID,omitempty"`
        // ErrorMessage gives message about Error which occurs during event processing
        ErrorMessage string `json:"errorMessage,omitempty"`
}

func (r Sink) emitEvents(recorder record.EventRecorder, el *triggersv1.EventListener, eventType string, err error) <span class="cov8" title="1">{
        if os.Getenv("EL_EVENT") == "enable" </span><span class="cov0" title="0">{
                events.Emit(recorder, eventType, el, err)
        }</span>
}

// HandleEvent processes an incoming HTTP event for the event listener.
func (r Sink) HandleEvent(response http.ResponseWriter, request *http.Request) <span class="cov8" title="1">{
        log := r.Logger.With(
                zap.String("eventlistener", r.EventListenerName),
                zap.String("namespace", r.EventListenerNamespace),
        )
        eventID := template.UUID()
        log = log.With(zap.String(triggers.EventIDLabelKey, eventID))

        elTemp := triggersv1.EventListener{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "EventListener",
                        APIVersion: "v1beta1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      r.EventListenerName,
                        Namespace: r.EventListenerNamespace,
                },
                Spec: triggersv1.EventListenerSpec{
                        Resources: triggersv1.Resources{
                                KubernetesResource: &amp;triggersv1.KubernetesResource{
                                        WithPodSpec: v1.WithPodSpec{
                                                Template: v1.PodSpecable{
                                                        Spec: corev1.PodSpec{
                                                                Containers: []corev1.Container{{
                                                                        // enabled by default for temporary EL
                                                                        Env: []corev1.EnvVar{{
                                                                                Name:  "EL_EVENT",
                                                                                Value: "true",
                                                                        }},
                                                                }},
                                                        },
                                                },
                                        },
                                },
                        },
                },
        }

        r.emitEvents(r.EventRecorder, &amp;elTemp, events.TriggerProcessingStartedV1, nil)
        r.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingStartedV1)

        event, err := io.ReadAll(request.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("Error reading event body: %s", err)
                r.recordCountMetrics(failTag)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, &amp;elTemp, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>

        <span class="cov8" title="1">el, err := r.EventListenerLister.EventListeners(r.EventListenerNamespace).Get(r.EventListenerName)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("Error getting EventListener %s in Namespace %s: %s", r.EventListenerName, r.EventListenerNamespace, err)
                r.recordCountMetrics(failTag)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, &amp;elTemp, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>

        <span class="cov8" title="1">elUID := string(el.GetUID())
        log = log.With(zap.String("eventlistenerUID", elUID))

        log = log.With(zap.String(triggers.EventIDLabelKey, eventID))
        log.Debugf("handling event with path %s, payload: %s and header: %v", request.URL.Path, string(event), request.Header)
        trItems, err := r.selectTriggers(el.Spec.NamespaceSelector, el.Spec.LabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Errorf("unable to select configured mergedTriggers: %s", err)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>

        // Process any ungroupedTriggers
        <span class="cov8" title="1">mergedTriggers, err := r.merge(el.Spec.Triggers, trItems)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("error merging triggers: %s", err)
                response.WriteHeader(http.StatusInternalServerError)
                r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                return
        }</span>
        <span class="cov8" title="1">r.WGProcessTriggers.Add(len(mergedTriggers))
        for _, t := range mergedTriggers </span><span class="cov8" title="1">{
                go func(t triggersv1.Trigger) </span><span class="cov8" title="1">{
                        defer r.WGProcessTriggers.Done()
                        localRequest := request.Clone(request.Context())
                        emptyExtensions := make(map[string]interface{})
                        r.processTrigger(t, el, localRequest, event, eventID, log, emptyExtensions)
                }</span>(*t)
        }

        // Process grouped triggers
        <span class="cov8" title="1">for _, group := range el.Spec.TriggerGroups </span><span class="cov8" title="1">{
                r.WGProcessTriggers.Add(1)
                go func(g triggersv1.EventListenerTriggerGroup) </span><span class="cov8" title="1">{
                        defer r.WGProcessTriggers.Done()
                        localRequest := request.Clone(request.Context())
                        r.processTriggerGroups(g, el, localRequest, event, eventID, log, r.WGProcessTriggers)
                }</span>(group)
        }

        <span class="cov8" title="1">r.recordCountMetrics(successTag)

        body := Response{
                EventListener:    r.EventListenerName,
                EventListenerUID: elUID,
                Namespace:        r.EventListenerNamespace,
                EventID:          eventID,
        }

        msg := cehttp.NewMessageFromHttpRequest(request)
        if encoding := msg.ReadEncoding(); encoding == binding.EncodingUnknown </span><span class="cov8" title="1">{
                response.WriteHeader(http.StatusAccepted)
                response.Header().Set("Content-Type", "application/json")
                if err := json.NewEncoder(response).Encode(body); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to write back sink response: %v", err)
                        r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                        r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                }</span>
        } else<span class="cov8" title="1"> {
                responseEvent := cloudevents.NewEvent()
                responseEvent.SetID(eventID)
                responseEvent.SetType(events.EventAccepted)
                responseEvent.SetSubject(r.EventListenerNamespace + "." + r.EventListenerName + " accepted " + eventID)
                responseEvent.SetSource(r.EventListenerName) // We need to change this like in SendCloudEvents

                _ = responseEvent.SetData(cloudevents.ApplicationJSON, body)

                eventResponse := binding.ToMessage(&amp;responseEvent)
                defer func() </span><span class="cov8" title="1">{
                        if err := eventResponse.Finish(nil); err != nil </span><span class="cov0" title="0">{
                                log.Errorf("failed to close cloud event sink response: %v", err)
                        }</span>
                }()

                <span class="cov8" title="1">if err := cehttp.WriteResponseWriter(request.Context(), eventResponse, http.StatusAccepted, response); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("failed to write back cloud event sink response: %v", err)
                        r.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)
                        r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)
                }</span>
        }
        <span class="cov8" title="1">r.emitEvents(r.EventRecorder, el, events.TriggerProcessingDoneV1, nil)
        r.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingDoneV1)</span>
}

func (r Sink) sendCloudEvents(headers http.Header, el triggersv1.EventListener, eventID, eventType string) <span class="cov8" title="1">{
        data, err := json.Marshal(headers)
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Errorf("Error marshaling request Headers to json: %s", err)
                return
        }</span>

        // If no cloudEventURI, then don't try to sendCloudEvents
        <span class="cov8" title="1">if r.CloudEventURI == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">resource := cloudevent.Resource{
                EventID:   eventID,
                EventType: eventType,
                TargetURI: r.CloudEventURI,
                Client:    r.CEClient,
                Logger:    r.Logger,
                Data:      data,
                EL:        el,
        }

        go resource.SendCloudEvents()</span>
}

func (r Sink) merge(et []triggersv1.EventListenerTrigger, trItems []*triggersv1.Trigger) ([]*triggersv1.Trigger, error) <span class="cov8" title="1">{
        triggers := trItems
        for _, t := range et </span><span class="cov8" title="1">{
                switch </span>{
                case t.Template == nil &amp;&amp; t.TriggerRef != "":<span class="cov8" title="1">
                        trig, err := r.TriggerLister.Triggers(r.EventListenerNamespace).Get(t.TriggerRef)
                        if err != nil </span><span class="cov8" title="1">{
                                r.Logger.Errorf("Error getting Trigger %s in Namespace %s: %s", t.TriggerRef, r.EventListenerNamespace, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">triggers = append(triggers, trig)</span>
                case t.Template != nil:<span class="cov8" title="1">
                        triggers = append(triggers, &amp;triggersv1.Trigger{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      t.Name,
                                        Namespace: r.EventListenerNamespace},
                                Spec: triggersv1.TriggerSpec{
                                        ServiceAccountName: t.ServiceAccountName,
                                        Bindings:           t.Bindings,
                                        Template:           *t.Template,
                                        Interceptors:       t.Interceptors,
                                },
                        })</span>
                default:<span class="cov0" title="0">
                        return nil, errors.New("EventListenerTrigger not defined")</span>
                }
        }
        <span class="cov8" title="1">return triggers, nil</span>
}

func (r Sink) processTriggerGroups(g triggersv1.EventListenerTriggerGroup, el *triggersv1.EventListener, request *http.Request, event []byte, eventID string, eventLog *zap.SugaredLogger, wg *sync.WaitGroup) <span class="cov8" title="1">{
        log := eventLog.With(zap.String(triggers.TriggerGroupLabelKey, g.Name))

        extensions := map[string]interface{}{}
        payload, header, resp, err := r.ExecuteInterceptors(g.Interceptors, request, event, log, eventID, fmt.Sprintf("namespaces/%s/triggerGroups/%s", r.EventListenerNamespace, g.Name), r.EventListenerNamespace, extensions)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>
        <span class="cov8" title="1">if resp != nil </span><span class="cov8" title="1">{
                if resp.Extensions != nil </span><span class="cov8" title="1">{
                        for k, v := range resp.Extensions </span><span class="cov8" title="1">{
                                extensions[k] = v
                        }</span>
                }
                <span class="cov8" title="1">if !resp.Continue </span><span class="cov0" title="0">{
                        eventLog.Debugf("interceptor stopped trigger processing: %v", resp.Status.Err())
                        return
                }</span>
        }

        <span class="cov8" title="1">trItems, err := r.selectTriggers(g.TriggerSelector.NamespaceSelector, g.TriggerSelector.LabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Create a new HTTP request that contains the body and header from any interceptors in the TriggerGroup
        // This request will be passed on to the triggers in this group
        <span class="cov8" title="1">triggerReq := request.Clone(request.Context())
        triggerReq.Header = header
        triggerReq.Body = io.NopCloser(bytes.NewBuffer(payload))

        wg.Add(len(trItems))
        for _, t := range trItems </span><span class="cov8" title="1">{
                go func(t triggersv1.Trigger) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        // TODO(dibyom): We might be able to get away with only cloning if necessary
                        // i.e. if there are interceptors and iff those interceptors will modify the body/header (i.e. webhook)
                        localRequest := triggerReq.Clone(triggerReq.Context())
                        r.processTrigger(t, el, localRequest, event, eventID, log, extensions)
                }</span>(*t)
        }
}

func (r Sink) selectTriggers(namespaceSelector triggersv1.NamespaceSelector, labelSelector *metav1.LabelSelector) ([]*triggersv1.Trigger, error) <span class="cov8" title="1">{
        var trItems []*triggersv1.Trigger
        var err error
        targetLabels := labels.Everything()
        if labelSelector != nil </span><span class="cov8" title="1">{
                targetLabels, err = metav1.LabelSelectorAsSelector(labelSelector)
                if err != nil </span><span class="cov0" title="0">{
                        r.Logger.Errorf("failed to create label selector: %v", err)
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">var triggerFunc func() ([]*triggersv1.Trigger, error)
        switch </span>{
        case len(namespaceSelector.MatchNames) == 1 &amp;&amp; namespaceSelector.MatchNames[0] == "*":<span class="cov0" title="0">
                triggerFunc = func() ([]*triggersv1.Trigger, error) </span><span class="cov0" title="0">{
                        return r.TriggerLister.List(targetLabels)
                }</span>
        case len(namespaceSelector.MatchNames) != 0:<span class="cov8" title="1">
                triggerFunc = func() ([]*triggersv1.Trigger, error) </span><span class="cov8" title="1">{
                        var trList []*triggersv1.Trigger
                        for _, v := range namespaceSelector.MatchNames </span><span class="cov8" title="1">{
                                trNsList, err := r.TriggerLister.Triggers(v).List(targetLabels)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">trList = append(trList, trNsList...)</span>
                        }
                        <span class="cov8" title="1">return trList, nil</span>
                }
        case len(namespaceSelector.MatchNames) == 0:<span class="cov8" title="1">
                if labelSelector != nil </span><span class="cov8" title="1">{
                        triggerFunc = func() ([]*triggersv1.Trigger, error) </span><span class="cov8" title="1">{
                                return r.TriggerLister.Triggers(r.EventListenerNamespace).List(targetLabels)
                        }</span>
                }
        }
        <span class="cov8" title="1">if triggerFunc == nil </span><span class="cov8" title="1">{
                return trItems, nil
        }</span>
        <span class="cov8" title="1">trList, err := triggerFunc()
        if err != nil </span><span class="cov0" title="0">{
                r.Logger.Errorf("Error getting Triggers: %v", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">trItems = append(trItems, trList...)

        return trItems, nil</span>
}

func (r Sink) processTrigger(t triggersv1.Trigger, el *triggersv1.EventListener, request *http.Request, event []byte, eventID string, eventLog *zap.SugaredLogger, extensions map[string]interface{}) <span class="cov8" title="1">{
        log := eventLog.With(zap.String(triggers.TriggerLabelKey, t.Name))

        finalPayload, header, iresp, err := r.ExecuteTriggerInterceptors(t, request, event, log, eventID, extensions)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>

        <span class="cov8" title="1">if iresp != nil </span><span class="cov8" title="1">{
                if !iresp.Continue </span><span class="cov0" title="0">{
                        log.Debugf("interceptor stopped trigger processing: %v", iresp.Status.Err())
                        return
                }</span>
        }

        <span class="cov8" title="1">rt, err := template.ResolveTrigger(t,
                r.TriggerBindingLister.TriggerBindings(t.Namespace).Get,
                r.ClusterTriggerBindingLister.Get,
                r.TriggerTemplateLister.TriggerTemplates(t.Namespace).Get)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>
        <span class="cov8" title="1">if iresp != nil &amp;&amp; iresp.Extensions != nil </span><span class="cov8" title="1">{
                extensions = iresp.Extensions
        }</span>
        <span class="cov8" title="1">params, err := template.ResolveParams(rt, finalPayload, header, extensions, template.NewTriggerContext(eventID))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>

        <span class="cov8" title="1">log.Infof("ResolvedParams : %+v", params)
        resources := template.ResolveResources(rt.TriggerTemplate, params)

        if err := r.CreateResources(t.Namespace, t.Spec.ServiceAccountName, resources, t.Name, eventID, log); err != nil </span><span class="cov0" title="0">{
                log.Error(err)
                return
        }</span>
        <span class="cov8" title="1">go r.recordResourceCreation(resources)
        r.emitEvents(r.EventRecorder, el, events.TriggerProcessingSuccessfulV1, nil)
        r.sendCloudEvents(request.Header, *el, eventID, events.TriggerProcessingSuccessfulV1)</span>
}

func (r Sink) ExecuteTriggerInterceptors(t triggersv1.Trigger, in *http.Request, event []byte, log *zap.SugaredLogger, eventID string, extensions map[string]interface{}) ([]byte, http.Header, *triggersv1.InterceptorResponse, error) <span class="cov8" title="1">{
        return r.ExecuteInterceptors(t.Spec.Interceptors, in, event, log, eventID, fmt.Sprintf("namespaces/%s/triggers/%s", t.Namespace, t.Name), t.Namespace, extensions)
}</span>

// ExecuteInterceptor executes all interceptors for the Trigger and returns back the body, header, and InterceptorResponse to use.
// When TEP-0022 is fully implemented, this function will only return the InterceptorResponse and error.
func (r Sink) ExecuteInterceptors(trInt []*triggersv1.TriggerInterceptor, in *http.Request, event []byte, log *zap.SugaredLogger, eventID string, triggerID string, namespace string, extensions map[string]interface{}) ([]byte, http.Header, *triggersv1.InterceptorResponse, error) <span class="cov8" title="1">{
        if len(trInt) == 0 </span><span class="cov8" title="1">{
                return event, in.Header, nil, nil
        }</span>

        // request is the request sent to the interceptors in the chain. Each interceptor can set the InterceptorParams field
        // or add to the Extensions
        <span class="cov8" title="1">request := triggersv1.InterceptorRequest{
                Body:       string(event),
                Header:     in.Header.Clone(),
                Extensions: make(map[string]interface{}),
                Context: &amp;triggersv1.TriggerContext{
                        EventURL: in.URL.String(),
                        EventID:  eventID,
                        // t.Name might not be fully accurate until we get rid of triggers inlined within EventListener
                        TriggerID: triggerID,
                },
        }
        for k, v := range extensions </span><span class="cov8" title="1">{
                request.Extensions[k] = v
        }</span>

        // check if string is urlencoded
        // Parse the query string into a map
        <span class="cov8" title="1">parsedQuery, _ := net.ParseQuery(request.Body)

        // parse form-data payload
        if v := in.Header.Get("Content-Type"); v == "application/x-www-form-urlencoded" &amp;&amp; len(parsedQuery) &gt; 1 </span><span class="cov0" title="0">{
                // Convert the map into a JSON string
                jsonString, err := json.Marshal(parsedQuery)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Error converting map to JSON:", err)
                        return nil, nil, nil, err
                }</span>
                <span class="cov0" title="0">request.Body = string(jsonString)</span>
        }
        // request is the request sent to the interceptors in the chain. Each interceptor can set the InterceptorParams field
        // or add to the Extensions

        <span class="cov8" title="1">for _, i := range trInt </span><span class="cov8" title="1">{
                if i.Webhook != nil </span><span class="cov8" title="1">{ // Old style interceptor
                        body, err := extendBodyWithExtensions([]byte(request.Body), request.Extensions)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("could not merge extensions with body: %w", err)
                        }</span>
                        <span class="cov8" title="1">req := &amp;http.Request{
                                Method: http.MethodPost,
                                Header: request.Header,
                                URL:    in.URL,
                                Body:   io.NopCloser(bytes.NewBuffer(body)),
                        }
                        interceptor := webhook.NewInterceptor(i.Webhook, r.HTTPClient, namespace, log)
                        res, err := interceptor.ExecuteTrigger(req)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, nil, nil, err
                        }</span>

                        <span class="cov8" title="1">payload, err := io.ReadAll(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("error reading webhook interceptor response body: %w", err)
                        }</span>
                        <span class="cov8" title="1">defer res.Body.Close()
                        // Set the next request to be the output of the last response to enable
                        // request chaining.
                        request.Header = res.Header.Clone()
                        request.Body = string(payload)
                        continue</span>
                }
                <span class="cov8" title="1">request.InterceptorParams = interceptors.GetInterceptorParams(i)

                var url *apis.URL
                if i.Ref.Kind == triggersv1.ClusterInterceptorKind </span><span class="cov8" title="1">{
                        ic, err := r.ClusterInterceptorLister.Get(i.GetName())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if ic.Status.Address != nil &amp;&amp; ic.Status.Address.URL != nil </span><span class="cov0" title="0">{
                                url = ic.Status.Address.URL
                        }</span> else<span class="cov8" title="1"> if url, err = ic.ResolveAddress(); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("could not resolve clusterinterceptor URL: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if i.Ref.Kind == triggersv1.NamespacedInterceptorKind </span><span class="cov8" title="1">{
                        if r.InterceptorLister == nil </span><span class="cov0" title="0">{
                                r.Logger.Debugf("nil lister")
                        }</span>
                        <span class="cov8" title="1">ic, err := r.InterceptorLister.Interceptors(r.EventListenerNamespace).Get(i.GetName())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if addr := ic.Status.Address; addr != nil &amp;&amp; addr.URL != nil </span><span class="cov0" title="0">{
                                url = addr.URL
                        }</span> else<span class="cov8" title="1"> if url, err = ic.ResolveAddress(); err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("url resolution failed for interceptor %s with: %w", i.GetName(), err)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, nil, fmt.Errorf("could not resolve nameSpacedinterceptor URL: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">interceptorResponse, err := interceptors.Execute(context.Background(), r.HTTPClient, &amp;request, url.String())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, err
                }</span>
                <span class="cov8" title="1">if !interceptorResponse.Continue </span><span class="cov8" title="1">{
                        return nil, nil, interceptorResponse, nil
                }</span>

                <span class="cov8" title="1">if interceptorResponse.Extensions != nil </span><span class="cov8" title="1">{
                        // Merge any extensions and pass it on to the next request in the chain
                        for k, v := range interceptorResponse.Extensions </span><span class="cov8" title="1">{
                                request.Extensions[k] = v
                        }</span>
                }

                // Clear interceptorParams for the next interceptor in chain
                <span class="cov8" title="1">request.InterceptorParams = map[string]interface{}{}</span>
        }

        <span class="cov8" title="1">return []byte(request.Body), request.Header, &amp;triggersv1.InterceptorResponse{
                Continue:   true,
                Extensions: request.Extensions,
        }, nil</span>
}

func (r Sink) CreateResources(triggerNS, sa string, res []json.RawMessage, triggerName, eventID string, log *zap.SugaredLogger) error <span class="cov8" title="1">{
        discoveryClient := r.DiscoveryClient
        dynamicClient := r.DynamicClient
        var err error
        if len(sa) &gt; 0 </span><span class="cov0" title="0">{
                // So at start up the discovery and dynamic clients are created using the in cluster config
                // of this pod (i.e. using the credentials of the serviceaccount associated with the EventListener)

                // However, we also have a ServiceAccountName reference with each EventListenerTrigger to allow
                // for more fine grained authorization control around the resources we create below.
                discoveryClient, dynamicClient, err = r.Auth.OverrideAuthentication(sa, triggerNS, log, r.DiscoveryClient, r.DynamicClient)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("problem cloning rest config: %#v", err)
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, rr := range res </span><span class="cov8" title="1">{
                if err := resources.Create(r.Logger, rr, triggerName, eventID, r.EventListenerName, triggerNS, discoveryClient, dynamicClient); err != nil </span><span class="cov0" title="0">{
                        log.Errorf("problem creating obj: %#v", err)
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// extendBodyWithExtensions merges the extensions into the given body.
func extendBodyWithExtensions(body []byte, extensions map[string]interface{}) ([]byte, error) <span class="cov8" title="1">{
        for k, v := range extensions </span><span class="cov8" title="1">{
                vb, err := json.Marshal(v)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal value to JSON: %w", err)
                }</span>
                <span class="cov8" title="1">body, err = sjson.SetRawBytes(body, "extensions."+k, vb)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to sjson extensions to body: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return body, nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">/*
Copyright 2021 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package sink

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

func (r Sink) IsValidPayload(eventHandler http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) </span><span class="cov8" title="1">{
                payload, err := io.ReadAll(request.Body)
                request.Body = io.NopCloser(bytes.NewBuffer(payload))
                if err != nil </span><span class="cov0" title="0">{
                        r.recordCountMetrics(failTag)
                        r.Logger.Errorf("Error reading event body: %s", err)
                        response.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov8" title="1">if r.PayloadValidation </span><span class="cov8" title="1">{
                        var event map[string]interface{}
                        if err := json.Unmarshal(payload, &amp;event); err != nil </span><span class="cov8" title="1">{
                                errMsg := fmt.Sprintf("Invalid event body format : %s", err)
                                r.recordCountMetrics(failTag)
                                r.Logger.Error(errMsg)
                                response.WriteHeader(http.StatusBadRequest)
                                response.Header().Set("Content-Type", "application/json")
                                body := Response{
                                        EventListener: r.EventListenerName,
                                        Namespace:     r.EventListenerNamespace,
                                        ErrorMessage:  errMsg,
                                }
                                if err := json.NewEncoder(response).Encode(body); err != nil </span><span class="cov0" title="0">{
                                        r.Logger.Errorf("failed to write back sink response: %v", err)
                                }</span>
                                <span class="cov8" title="1">return</span>
                        }
                }
                <span class="cov8" title="1">eventHandler.ServeHTTP(response, request)</span>
        })
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package system

import "os"

const (
        DefaultNamespace      = "tekton-pipelines"
        SystemNamespaceEnvVar = "SYSTEM_NAMESPACE"
)

// GetNamespace holds the K8s namespace where our system components run.
func GetNamespace() string <span class="cov0" title="0">{
        systemNamespace := os.Getenv(SystemNamespaceEnvVar)
        if systemNamespace == "" </span><span class="cov0" title="0">{
                return DefaultNamespace
        }</span>
        <span class="cov0" title="0">return systemNamespace</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
)

const (
        // OldEscapeAnnotation is used to determine whether or not a TriggerTemplate
        // should retain the old "replace quotes with backslack quote" behaviour
        // when templating in params.
        //
        // This can be removed when this functionality is no-longer needed.
        OldEscapeAnnotation = "triggers.tekton.dev/old-escape-quotes"
)

type TriggerContext struct {
        EventID string `json:"eventID"`
}

func NewTriggerContext(eventID string) TriggerContext <span class="cov8" title="1">{
        return TriggerContext{EventID: eventID}
}</span>

// ResolveParams takes given triggerbindings and produces the resulting
// resource params.
func ResolveParams(rt ResolvedTrigger, body []byte, header http.Header, extensions map[string]interface{}, triggerContext TriggerContext) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        var ttParams []triggersv1.ParamSpec
        if rt.TriggerTemplate != nil </span><span class="cov8" title="1">{
                ttParams = rt.TriggerTemplate.Spec.Params
        }</span>

        <span class="cov8" title="1">out, err := applyEventValuesToParams(rt.BindingParams, body, header, extensions, ttParams, triggerContext)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ApplyEventValuesToParams: %w", err)
        }</span>

        <span class="cov8" title="1">return out, nil</span>
}

// ResolveResources resolves a templated resource by replacing params with their values.
func ResolveResources(template *triggersv1.TriggerTemplate, params []triggersv1.Param) []json.RawMessage <span class="cov8" title="1">{
        resources := make([]json.RawMessage, len(template.Spec.ResourceTemplates))
        uid := UUID()

        oldEscape := metav1.HasAnnotation(template.ObjectMeta, OldEscapeAnnotation)

        for i := range template.Spec.ResourceTemplates </span><span class="cov8" title="1">{
                resources[i] = applyParamsToResourceTemplate(params, template.Spec.ResourceTemplates[i].RawExtension.Raw, oldEscape)
                resources[i] = applyUIDToResourceTemplate(resources[i], uid)
        }</span>
        <span class="cov8" title="1">return resources</span>
}

// event represents a HTTP event that Triggers processes
type event struct {
        Header     map[string]string      `json:"header"`
        Body       interface{}            `json:"body"`
        Extensions map[string]interface{} `json:"extensions"`
        Context    TriggerContext         `json:"context"`
}

// newEvent returns a new Event from HTTP headers and body
func newEvent(body []byte, headers http.Header, extensions map[string]interface{}, triggerContext TriggerContext) (*event, error) <span class="cov8" title="1">{
        var data interface{}
        if len(body) &gt; 0 </span><span class="cov8" title="1">{
                if err := json.Unmarshal(body, &amp;data); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to unmarshal request body: %w", err)
                }</span>
        }
        <span class="cov8" title="1">joinedHeaders := make(map[string]string, len(headers))
        for k, v := range headers </span><span class="cov8" title="1">{
                joinedHeaders[k] = strings.Join(v, ",")
        }</span>

        <span class="cov8" title="1">return &amp;event{
                Header:     joinedHeaders,
                Body:       data,
                Extensions: extensions,
                Context:    triggerContext,
        }, nil</span>
}

// applyEventValuesToParams returns a slice of Params with the JSONPath variables replaced
// with values from the event body, headers, and extensions.
func applyEventValuesToParams(params []triggersv1.Param, body []byte, header http.Header, extensions map[string]interface{},
        defaults []triggersv1.ParamSpec,
        triggerContext TriggerContext) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        event, err := newEvent(body, header, extensions, triggerContext)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to marshal event: %w", err)
        }</span>

        <span class="cov8" title="1">allParamsMap := map[string]string{}
        for _, paramSpec := range defaults </span><span class="cov8" title="1">{
                if paramSpec.Default != nil </span><span class="cov8" title="1">{
                        allParamsMap[paramSpec.Name] = *paramSpec.Default
                }</span>
        }

        <span class="cov8" title="1">for _, p := range params </span><span class="cov8" title="1">{
                pValue := p.Value
                // Find all expressions wrapped in $() from the value
                expressions, originals := findTektonExpressions(pValue)
                for i, expr := range expressions </span><span class="cov8" title="1">{
                        val, err := parseJSONPath(event, expr)
                        if defaults != nil &amp;&amp; err != nil </span><span class="cov8" title="1">{
                                // if the header or body was not supplied or was malformed, go with a default if it exists
                                v, ok := allParamsMap[p.Name]
                                if ok </span><span class="cov8" title="1">{
                                        val = v
                                        err = nil
                                }</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to replace JSONPath value for param %s: %s: %w", p.Name, p.Value, err)
                        }</span>
                        <span class="cov8" title="1">pValue = strings.ReplaceAll(pValue, originals[i], val)</span>
                }
                <span class="cov8" title="1">allParamsMap[p.Name] = pValue</span>
        }
        <span class="cov8" title="1">return convertParamMapToArray(allParamsMap), nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/textproto"
        "reflect"
        "regexp"
        "strings"

        "k8s.io/client-go/util/jsonpath"
)

var (
        // tektonVar captures strings that are enclosed in $()
        tektonVar = regexp.MustCompile(`\$\(?([^\)]+)\)`)

        // jsonRegexp is a regular expression for JSONPath expressions
        // with or without the enclosing {} and the leading . inside the curly
        // braces e.g.  'a.b' or '.a.b' or '{a.b}' or '{.a.b}'
        jsonRegexp = regexp.MustCompile(`^\{\.?([^{}]+)\}$|^\.?([^{}]+)$`)
)

// parseJSONPath extracts a subset of the given JSON input
// using the provided JSONPath expression.
func parseJSONPath(input interface{}, expr string) (string, error) <span class="cov8" title="1">{
        j := jsonpath.New("").AllowMissingKeys(false)
        buf := new(bytes.Buffer)

        // First turn the expression into fully valid JSONPath
        expr, err := tektonJSONPathExpression(expr)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if err := j.Parse(expr); err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">fullResults, err := j.FindResults(input)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, r := range fullResults </span><span class="cov8" title="1">{
                if err := printResults(buf, r); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov8" title="1">return buf.String(), nil</span>
}

// PrintResults writes the results into writer
func printResults(wr io.Writer, values []reflect.Value) error <span class="cov8" title="1">{
        results, err := getResults(values)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error getting values for jsonpath results: %w", err)
        }</span>

        <span class="cov8" title="1">if _, err := wr.Write(results); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getResults(values []reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        if len(values) == 1 </span><span class="cov8" title="1">{
                v := values[0]
                t := reflect.TypeOf(v.Interface())
                switch </span>{
                case t == nil:<span class="cov8" title="1">
                        return []byte("null"), nil</span>
                case t.Kind() == reflect.String:<span class="cov8" title="1">
                        b, err := json.Marshal(v.Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unable to marshal string value %v: %w", v, err)
                        }</span>
                        // A valid json string is surrounded by quotation marks; we are using this function to
                        // create a representation of the json value that can be embedded in a CRD definition and
                        // we want to leave it up to the user if they want the surrounding quotation marks or not.
                        <span class="cov8" title="1">return b[1 : len(b)-1], nil</span>
                default:<span class="cov8" title="1">
                        return json.Marshal(v.Interface())</span>
                }
        }

        // More than one result - we need to return a JSON array response
        <span class="cov8" title="1">results := []interface{}{}
        for _, r := range values </span><span class="cov8" title="1">{
                t := reflect.TypeOf(r.Interface())
                if t == nil </span><span class="cov8" title="1">{
                        results = append(results, nil)
                }</span> else<span class="cov8" title="1"> {
                        // No special case for string here unlike above since its going to be part of a JSON array
                        results = append(results, r.Interface())
                }</span>
        }
        <span class="cov8" title="1">return json.Marshal(results)</span>
}

// tektonJSONPathExpression returns a valid JSONPath expression. It accepts
// a "RelaxedJSONPath" expression that is wrapped in the Tekton variable
// interpolation syntax i.e. $(). RelaxedJSONPath expressions can optionally
// omit the leading curly braces '{}' and '.'
func tektonJSONPathExpression(expr string) (string, error) <span class="cov8" title="1">{
        if !isTektonExpr(expr) </span><span class="cov8" title="1">{
                return "", errors.New("expression not wrapped in $()")
        }</span>
        <span class="cov8" title="1">unwrapped := strings.TrimSuffix(strings.TrimPrefix(expr, "$("), ")")
        return relaxedJSONPathExpression(unwrapped)</span>
}

// RelaxedJSONPathExpression attempts to be flexible with JSONPath expressions, it accepts:
//   - metadata.name (no leading '.' or curly braces '{...}'
//   - {metadata.name} (no leading '.')
//   - .metadata.name (no curly braces '{...}')
//   - {.metadata.name} (complete expression)
//
// And transforms them all into a valid jsonpath expression:
//
//        {.metadata.name}
//
// This function has been copied as-is from
// https://github.com/kubernetes/kubectl/blob/c273777957bd657233cf867892fb061a6498dab8/pkg/cmd/get/customcolumn.go#L47
func relaxedJSONPathExpression(pathExpression string) (string, error) <span class="cov8" title="1">{
        if len(pathExpression) == 0 </span><span class="cov8" title="1">{
                return pathExpression, nil
        }</span>
        <span class="cov8" title="1">submatches := jsonRegexp.FindStringSubmatch(pathExpression)
        if submatches == nil </span><span class="cov8" title="1">{
                return "", errors.New("unexpected path string, expected a 'name1.name2' or '.name1.name2' or '{name1.name2}' or '{.name1.name2}'")
        }</span>
        <span class="cov8" title="1">if len(submatches) != 3 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unexpected submatch list: %v", submatches)
        }</span>
        <span class="cov8" title="1">var fieldSpec string
        if len(submatches[1]) != 0 </span><span class="cov8" title="1">{
                fieldSpec = submatches[1]
        }</span> else<span class="cov8" title="1"> {
                fieldSpec = submatches[2]
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("{.%s}", fieldSpec), nil</span>
}

// IsTektonExpr returns true if the expr is wrapped in $()
func isTektonExpr(expr string) bool <span class="cov8" title="1">{
        return tektonVar.MatchString(expr)
}</span>

// findTektonExpressions searches for and returns a slice of
// all substrings that are wrapped in $()
// substring with "header." is converted with CanonicalMIMEHeaderKey in the first array
// the second array has the original substrings
func findTektonExpressions(in string) ([]string, []string) <span class="cov8" title="1">{
        results := []string{}
        originals := []string{}

        // No expressions to return
        if !strings.Contains(in, "$(") </span><span class="cov8" title="1">{
                return results, originals
        }</span>
        // Splits string on $( to find potential Tekton expressions
        <span class="cov8" title="1">maybeExpressions := strings.Split(in, "$(")
        for _, e := range maybeExpressions[1:] </span><span class="cov8" title="1">{ // Split always returns at least one element
                // Iterate until we find the first unbalanced )
                numOpenBrackets := 0
                for i, ch := range e </span><span class="cov8" title="1">{
                        switch ch </span>{
                        case '(':<span class="cov8" title="1">
                                numOpenBrackets++</span>
                        case ')':<span class="cov8" title="1">
                                numOpenBrackets--
                                if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                        raw := e[:i]
                                        originals = append(originals, fmt.Sprintf("$(%s)", raw))
                                        if strings.Index(raw, "header.") == 0 </span><span class="cov8" title="1">{
                                                raw = "header." + textproto.CanonicalMIMEHeaderKey(raw[len("header."):])
                                        }</span>
                                        <span class="cov8" title="1">results = append(results, fmt.Sprintf("$(%s)", raw))</span>
                                }
                        default:<span class="cov8" title="1">
                                continue</span>
                        }
                        <span class="cov8" title="1">if numOpenBrackets &lt; 0 </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return results, originals</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
Copyright 2019 The Tekton Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package template

import (
        "bytes"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/google/uuid"
        triggersv1 "github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// uidMatch determines the uid variable within the resource template
var uidMatch = []byte(`$(uid)`)

// ResolvedTrigger contains the dereferenced TriggerBindings and
// TriggerTemplate after resolving the k8s ObjectRef.
type ResolvedTrigger struct {
        TriggerBindings        []*triggersv1.TriggerBinding
        ClusterTriggerBindings []*triggersv1.ClusterTriggerBinding
        TriggerTemplate        *triggersv1.TriggerTemplate
        BindingParams          []triggersv1.Param
}

type getTriggerBinding func(name string) (*triggersv1.TriggerBinding, error)
type getTriggerTemplate func(name string) (*triggersv1.TriggerTemplate, error)
type getClusterTriggerBinding func(name string) (*triggersv1.ClusterTriggerBinding, error)

// ResolveTrigger takes in a trigger containing object refs to bindings and
// templates and resolves them to their underlying values.
func ResolveTrigger(trigger triggersv1.Trigger, getTB getTriggerBinding, getCTB getClusterTriggerBinding, getTT getTriggerTemplate) (ResolvedTrigger, error) <span class="cov8" title="1">{
        bp, err := resolveBindingsToParams(trigger.Spec.Bindings, getTB, getCTB)
        if err != nil </span><span class="cov8" title="1">{
                return ResolvedTrigger{}, fmt.Errorf("failed to resolve bindings: %w", err)
        }</span>

        <span class="cov8" title="1">var resolvedTT *triggersv1.TriggerTemplate
        if trigger.Spec.Template.Spec != nil </span><span class="cov8" title="1">{
                resolvedTT = &amp;triggersv1.TriggerTemplate{
                        ObjectMeta: metav1.ObjectMeta{}, // Unused. TODO: Just return Specs from here.
                        Spec:       *trigger.Spec.Template.Spec,
                }
        }</span> else<span class="cov8" title="1"> {
                var ttName string
                if trigger.Spec.Template.Ref != nil </span><span class="cov8" title="1">{
                        ttName = *trigger.Spec.Template.Ref
                }</span>
                <span class="cov8" title="1">resolvedTT, err = getTT(ttName)
                if err != nil </span><span class="cov8" title="1">{
                        return ResolvedTrigger{}, fmt.Errorf("error getting TriggerTemplate %s: %w", ttName, err)
                }</span>
        }

        <span class="cov8" title="1">return ResolvedTrigger{TriggerTemplate: resolvedTT, BindingParams: bp}, nil</span>
}

// resolveBindingsToParams takes in both embedded bindings and references and returns a list of resolved Param values.ResolveBindingsToParams
func resolveBindingsToParams(bindings []*triggersv1.TriggerSpecBinding, getTB getTriggerBinding, getCTB getClusterTriggerBinding) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        bindingParams := []triggersv1.Param{}
        for _, b := range bindings </span><span class="cov8" title="1">{
                switch </span>{
                case b.Name != "" &amp;&amp; b.Value != nil:<span class="cov8" title="1">
                        bindingParams = append(bindingParams, triggersv1.Param{
                                Name:  b.Name,
                                Value: *b.Value,
                        })</span>

                case b.Ref != "" &amp;&amp; b.Kind == triggersv1.ClusterTriggerBindingKind:<span class="cov8" title="1">
                        ctb, err := getCTB(b.Ref)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error getting ClusterTriggerBinding %s: %w", b.Name, err)
                        }</span>
                        <span class="cov8" title="1">bindingParams = append(bindingParams, ctb.Spec.Params...)</span>

                case b.Ref != "":<span class="cov8" title="1"> // if no kind is set, assume NamespacedTriggerBinding
                        tb, err := getTB(b.Ref)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("error getting TriggerBinding %s: %w", b.Name, err)
                        }</span>
                        <span class="cov8" title="1">bindingParams = append(bindingParams, tb.Spec.Params...)</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("invalid binding: %v", b)</span>
                }
        }

        // Check for duplicate params
        <span class="cov8" title="1">seen := make(map[string]bool, len(bindingParams))
        for _, p := range bindingParams </span><span class="cov8" title="1">{
                if seen[p.Name] </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("duplicate param name: %s", p.Name)
                }</span>
                <span class="cov8" title="1">seen[p.Name] = true</span>
        }
        <span class="cov8" title="1">return bindingParams, nil</span>
}

// escapeTektonVariables escapes Tekton variable syntax in parameter values
// to prevent them from being interpreted as actual variable references.
// It replaces $( with $$( which tells Tekton to treat it as literal text.
func escapeTektonVariables(value string) string <span class="cov8" title="1">{
        // Escape $( to $$( to prevent Tekton from interpreting it as a variable reference
        // This handles patterns like $(tasks.xxx), $(params.xxx), $(results.xxx), etc.
        return strings.ReplaceAll(value, "$(", "$$(")
}</span>

// applyParamsToResourceTemplate returns the TriggerResourceTemplate with the
// param values substituted for all matching param variables in the template
func applyParamsToResourceTemplate(params []triggersv1.Param, rt json.RawMessage, oldEscape bool) json.RawMessage <span class="cov8" title="1">{
        // Assume the params are valid
        for _, param := range params </span><span class="cov8" title="1">{
                rt = applyParamToResourceTemplate(param, rt, oldEscape)
        }</span>
        <span class="cov8" title="1">return rt</span>
}

// applyParamToResourceTemplate returns the TriggerResourceTemplate with the
// param value substituted for all matching param variables in the template
func applyParamToResourceTemplate(param triggersv1.Param, rt json.RawMessage, oldEscape bool) json.RawMessage <span class="cov8" title="1">{
        // Assume the param is valid
        paramVariable := fmt.Sprintf("$(tt.params.%s)", param.Name)
        // Escape quotes so that JSON strings can be appended to regular strings.
        // See #257 for discussion on this behavior.
        paramValue := param.Value
        if oldEscape </span><span class="cov8" title="1">{
                paramValue = strings.ReplaceAll(paramValue, `"`, `\"`)
        }</span>
        // Escape Tekton variable syntax to prevent validation errors
        // when parameter values contain literal $(tasks.*) or similar patterns
        <span class="cov8" title="1">paramValue = escapeTektonVariables(paramValue)
        return bytes.ReplaceAll(rt, []byte(paramVariable), []byte(paramValue))</span>
}

// UUID generates a Universally Unique IDentifier following RFC 4122.
var UUID = func() string <span class="cov8" title="1">{ return uuid.New().String() }</span>

// applyUIDToResourceTemplate returns the TriggerResourceTemplate after uid replacement
// The same uid should be used per trigger to properly address resources throughout the TriggerTemplate.
func applyUIDToResourceTemplate(rt json.RawMessage, uid string) json.RawMessage <span class="cov8" title="1">{
        return bytes.ReplaceAll(rt, uidMatch, []byte(uid))
}</span>

func convertParamMapToArray(paramMap map[string]string) []triggersv1.Param <span class="cov8" title="1">{
        params := []triggersv1.Param{}
        for name, value := range paramMap </span><span class="cov8" title="1">{
                params = append(params, triggersv1.Param{Name: name, Value: value})
        }</span>
        <span class="cov8" title="1">return params</span>
}

// mergeBindingParams merges params across multiple bindings.
func mergeBindingParams(bindings []*triggersv1.TriggerBinding, clusterbindings []*triggersv1.ClusterTriggerBinding) ([]triggersv1.Param, error) <span class="cov8" title="1">{
        params := []triggersv1.Param{}
        for _, b := range bindings </span><span class="cov8" title="1">{
                params = append(params, b.Spec.Params...)
        }</span>
        <span class="cov8" title="1">for _, cb := range clusterbindings </span><span class="cov8" title="1">{
                params = append(params, cb.Spec.Params...)
        }</span>
        <span class="cov8" title="1">seen := make(map[string]bool, len(params))
        for _, p := range params </span><span class="cov8" title="1">{
                if seen[p.Name] </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("duplicate param name: %s", p.Name)
                }</span>
                <span class="cov8" title="1">seen[p.Name] = true</span>
        }
        <span class="cov8" title="1">return params, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
