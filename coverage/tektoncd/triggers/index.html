<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coverage Report</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
    <style>
      :root {
  --sidebar-width: 280px;
  --topbar-height: 48px;
  --line-height: 20px;
  --font-mono: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
}

[data-theme="dark"] {
  --bg: #1e1e1e;
  --bg-secondary: #252526;
  --bg-tertiary: #2d2d2d;
  --text: #d4d4d4;
  --text-muted: #808080;
  --border: #3c3c3c;
  --covered: rgba(35, 134, 54, 0.25);
  --covered-gutter: #238636;
  --uncovered: rgba(218, 54, 51, 0.25);
  --uncovered-gutter: #da3633;
  --highlight: #264f78;
  --highlight-match: #613214;
  --accent: #569cd6;
  --hover: #2a2d2e;
}

[data-theme="light"] {
  --bg: #ffffff;
  --bg-secondary: #f3f3f3;
  --bg-tertiary: #e8e8e8;
  --text: #24292f;
  --text-muted: #656d76;
  --border: #d0d7de;
  --covered: rgba(35, 134, 54, 0.15);
  --covered-gutter: #1a7f37;
  --uncovered: rgba(218, 54, 51, 0.15);
  --uncovered-gutter: #cf222e;
  --highlight: #ddf4ff;
  --highlight-match: #fff8c5;
  --accent: #0969da;
  --hover: #f6f8fa;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
  font-size: 14px;
  background: var(--bg);
  color: var(--text);
}

#app {
  display: grid;
  grid-template-columns: var(--sidebar-width) 1fr;
  height: 100%;
}

/* Sidebar */
#sidebar {
  display: flex;
  flex-direction: column;
  background: var(--bg-secondary);
  border-right: 1px solid var(--border);
  overflow: hidden;
}

#sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
}

/* Logo link */
#logo-link {
  text-decoration: none;
  color: inherit;
  display: block;
}

#logo-link:hover #logo-container {
  opacity: 0.8;
}

#logo-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
  transition: opacity 0.15s ease;
}

#logo-container .github-icon {
  flex-shrink: 0;
  color: var(--text-muted);
  transition: color 0.15s ease;
}

#logo-link:hover .github-icon {
  color: var(--accent);
}

#logo {
  flex-shrink: 0;
  width: 32px;
  height: 32px;
}

#logo-text {
  flex: 1;
  min-width: 0;
}

#sidebar-header h1 {
  font-size: 16px;
  font-weight: 600;
  margin: 0;
  line-height: 1.2;
}

#tagline {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-muted);
  margin: 2px 0 0 0;
  line-height: 1.3;
}

#summary {
  font-size: 13px;
  color: var(--text-muted);
}

#summary .percent {
  font-weight: 600;
  color: var(--text);
}

#search-box {
  padding: 8px 16px;
  border-bottom: 1px solid var(--border);
}

#search-input {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 13px;
}

#search-input:focus {
  outline: none;
  border-color: var(--accent);
}

/* Sort controls */
#sort-controls {
  display: flex;
  gap: 0;
  margin: 8px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  overflow: hidden;
}

.sort-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 6px 8px;
  background: var(--bg-secondary);
  color: var(--text);
  border: none;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.2s, color 0.2s;
}

.sort-btn:hover {
  background: var(--hover);
}

.sort-btn.active {
  background: var(--accent);
  color: #fff;
}

.sort-btn .icon {
  font-weight: 600;
}

.sort-btn .label {
  font-size: 11px;
}

/* Coverage badges for directories */
.coverage-badge {
  margin-left: auto;
  padding-left: 8px;
  font-size: 11px;
  color: var(--text-muted);
  font-weight: 500;
  font-family: var(--font-mono);
}

#file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
}

/* Sidebar footer */
#sidebar-footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  font-size: 12px;
  text-align: center;
}

#sidebar-footer a {
  color: var(--text-muted);
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

#sidebar-footer a:hover {
  color: var(--accent);
  text-decoration: underline;
}

#sidebar-footer .github-icon {
  flex-shrink: 0;
}

.tree-node {
  cursor: pointer;
  user-select: none;
}

.tree-item {
  display: flex;
  align-items: center;
  padding: 4px 16px;
  gap: 6px;
  white-space: nowrap;
}

.tree-item:hover {
  background: var(--hover);
}

.tree-item.selected {
  background: var(--highlight);
}

.tree-item .icon {
  width: 16px;
  text-align: center;
  font-size: 12px;
  color: var(--text-muted);
}

.tree-item .name {
  font-size: 13px;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  min-width: 0;
}

.tree-children {
  display: none;
}

.tree-node.expanded > .tree-children {
  display: block;
}

.tree-children .tree-item {
  padding-left: calc(16px + var(--depth, 0) * 16px);
}

.tree-node.hidden {
  display: none;
}

/* Canvas */
#canvas {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

#topbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: var(--topbar-height);
  padding: 0 16px;
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  gap: 16px;
}

#file-path {
  font-size: 13px;
  font-family: var(--font-mono);
  color: var(--text-muted);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#topbar-actions {
  display: flex;
  align-items: center;
  gap: 12px;
}

#in-file-search {
  display: flex;
  align-items: center;
  gap: 8px;
}

#content-search {
  width: 180px;
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  font-size: 12px;
}

#content-search:focus {
  outline: none;
  border-color: var(--accent);
}

#match-info {
  font-size: 12px;
  color: var(--text-muted);
  min-width: 60px;
}

#prev-match, #next-match {
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 10px;
}

#prev-match:hover, #next-match:hover {
  background: var(--hover);
}

#theme-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 16px;
}

#theme-toggle:hover {
  background: var(--hover);
}

#syntax-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-family: var(--font-mono);
}

#syntax-toggle:hover {
  background: var(--hover);
}

#syntax-toggle.active {
  background: var(--accent);
  color: #fff;
  border-color: var(--accent);
}

#help-toggle {
  padding: 6px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--bg);
  color: var(--text);
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
}

#help-toggle:hover {
  background: var(--hover);
}

/* Override highlight.js to use theme-aware colors */
.hljs { background: transparent !important; }

[data-theme="dark"] .hljs-keyword { color: #569cd6; }
[data-theme="dark"] .hljs-type { color: #4ec9b0; }
[data-theme="dark"] .hljs-string { color: #ce9178; }
[data-theme="dark"] .hljs-number { color: #b5cea8; }
[data-theme="dark"] .hljs-comment { color: #6a9955; }
[data-theme="dark"] .hljs-built_in { color: #dcdcaa; }
[data-theme="dark"] .hljs-literal { color: #569cd6; }
[data-theme="dark"] .hljs-function { color: #dcdcaa; }

[data-theme="light"] .hljs-keyword { color: #0000ff; }
[data-theme="light"] .hljs-type { color: #267f99; }
[data-theme="light"] .hljs-string { color: #a31515; }
[data-theme="light"] .hljs-number { color: #098658; }
[data-theme="light"] .hljs-comment { color: #008000; }
[data-theme="light"] .hljs-built_in { color: #795e26; }
[data-theme="light"] .hljs-literal { color: #0000ff; }
[data-theme="light"] .hljs-function { color: #795e26; }

/* Viewport */
#viewport {
  flex: 1;
  overflow: auto;
  background: var(--bg);
  outline: none;
}

#viewport::-webkit-scrollbar {
  width: 14px;
  height: 14px;
}

#viewport::-webkit-scrollbar-track {
  background: var(--bg);
}

#viewport::-webkit-scrollbar-thumb {
  background: var(--border);
  border: 3px solid var(--bg);
  border-radius: 7px;
}

#viewport::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

.code-container {
  display: table;
  min-width: 100%;
  font-family: var(--font-mono);
  font-size: 13px;
  line-height: var(--line-height);
}

.code-line {
  display: table-row;
}

.code-line:hover {
  background: var(--hover);
}

.code-line.covered {
  background: var(--covered);
}

.code-line.uncovered {
  background: var(--uncovered);
}

.code-line.covered:hover {
  background: var(--covered);
}

.code-line.uncovered:hover {
  background: var(--uncovered);
}

.gutter {
  display: table-cell;
  width: 4px;
  min-width: 4px;
}

.code-line.covered .gutter {
  background: var(--covered-gutter);
}

.code-line.uncovered .gutter {
  background: var(--uncovered-gutter);
}

.line-number {
  display: table-cell;
  width: 50px;
  min-width: 50px;
  padding: 0 12px 0 8px;
  text-align: right;
  color: var(--text-muted);
  user-select: none;
  vertical-align: top;
}

.line-content {
  display: table-cell;
  padding-right: 16px;
  white-space: pre;
  tab-size: 4;
}

.match-highlight {
  background: var(--highlight-match);
  border-radius: 2px;
}

.current-match {
  background: var(--accent);
  color: #fff;
}

/* Empty state */
.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-muted);
  gap: 8px;
}

.empty-state .icon {
  font-size: 48px;
  opacity: 0.5;
}

/* Scrollbar for file tree */
#file-tree::-webkit-scrollbar {
  width: 8px;
}

#file-tree::-webkit-scrollbar-track {
  background: transparent;
}

#file-tree::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 4px;
}

#file-tree::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Help modal */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 24px;
  max-width: 400px;
  width: 90%;
}

.modal-content h2 {
  margin-bottom: 16px;
  font-size: 18px;
}

.modal-content dl {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 8px 16px;
}

.modal-content dt {
  font-family: var(--font-mono);
  background: var(--bg-tertiary);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
}

.modal-content dd {
  color: var(--text-muted);
}

.modal-content button {
  margin-top: 20px;
  padding: 8px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--accent);
  color: #fff;
  cursor: pointer;
  width: 100%;
}

/* Selected line range (multi-line selection) */
.code-line.selected-line {
  background-color: var(--highlight);
}

.code-line.selected-line.covered {
  background-color: var(--highlight);
}

.code-line.selected-line.uncovered {
  background-color: var(--highlight);
}

/* Line number click indicator */
.line-number {
  cursor: pointer;
}

.line-number:hover {
  color: var(--accent);
}

    </style>
  </head>
  <body data-theme="dark">
    <div id="app">
      <aside id="sidebar">
        <div id="sidebar-header">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            id="logo-link"
            target="_blank"
            rel="noopener"
          >
            <div id="logo-container">
              <svg id="logo" viewBox="0 0 32 32" width="32" height="32">
                <defs>
                  <linearGradient
                    id="logoGradient"
                    x1="0%"
                    y1="0%"
                    x2="100%"
                    y2="100%"
                  >
                    <stop
                      offset="0%"
                      style="stop-color: var(--accent); stop-opacity: 1"
                    />
                    <stop
                      offset="100%"
                      style="stop-color: var(--accent); stop-opacity: 0.7"
                    />
                  </linearGradient>
                </defs>
                
                <circle
                  cx="16"
                  cy="16"
                  r="14"
                  fill="none"
                  stroke="url(#logoGradient)"
                  stroke-width="2"
                  opacity="0.3"
                />
                
                <path
                  d="M 10 17 L 14 21 L 22 11"
                  fill="none"
                  stroke="var(--accent)"
                  stroke-width="2.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                />
                
                <circle
                  cx="24"
                  cy="10"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
                <circle
                  cx="26"
                  cy="12"
                  r="1.5"
                  fill="var(--accent)"
                  opacity="0.6"
                />
              </svg>
              <div id="logo-text">
                <h1>GO Coverage</h1>
                <div id="tagline">A better HTML Go Coverage</div>
              </div>
            </div>
          </a>
          <div id="summary"></div>
        </div>
        <div id="search-box">
          <input type="text" id="search-input" placeholder="Search files..." />
        </div>
        <div id="sort-controls">
          <button
            class="sort-btn active"
            data-sort="name"
            title="Sort alphabetically"
          >
            <span class="icon">Aâ†’Z</span>
            <span class="label">Name</span>
          </button>
          <button
            class="sort-btn"
            data-sort="coverage"
            title="Sort by coverage percentage"
          >
            <span class="icon">%</span>
            <span class="label">Coverage</span>
          </button>
        </div>
        <div id="file-tree"></div>
        <footer id="sidebar-footer">
          <a
            href="https://github.com/chmouel/go-better-html-coverage"
            target="_blank"
            rel="noopener"
          >
            <svg
              class="github-icon"
              viewBox="0 0 16 16"
              width="14"
              height="14"
              fill="currentColor"
            >
              <path
                d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"
              />
            </svg>
            chmouel/go-better-html-coverage
          </a>
        </footer>
      </aside>
      <main id="canvas">
        <header id="topbar">
          <div id="file-path"></div>
          <div id="topbar-actions">
            <div id="in-file-search">
              <input
                type="text"
                id="content-search"
                placeholder="Search in file..."
              />
              <span id="match-info"></span>
              <button id="prev-match" title="Previous match">&#9650;</button>
              <button id="next-match" title="Next match">&#9660;</button>
            </div>
            <button id="syntax-toggle" title="Toggle syntax highlighting">
              &lt;/&gt;
            </button>
            <button id="theme-toggle" title="Toggle theme">&#9788;</button>
            <button id="help-toggle" title="Keyboard shortcuts">?</button>
          </div>
        </header>
        <div id="viewport" tabindex="-1"></div>
      </main>
      <div id="help-modal" class="modal hidden">
        <div class="modal-content">
          <h2>Keyboard Shortcuts</h2>
          <dl>
            <dt>Ctrl+P</dt>
            <dd>Focus file search</dd>
            <dt>Ctrl+F</dt>
            <dd>Search in file</dd>
            <dt>Enter</dt>
            <dd>Next match</dd>
            <dt>Shift+Enter</dt>
            <dd>Previous match</dd>
            <dt>?</dt>
            <dd>Show this help</dd>
            <dt>Esc</dt>
            <dd>Close modal</dd>
          </dl>
          <h2>Permalinks</h2>
          <dl>
            <dt>Click line</dt>
            <dd>Select line, update URL</dd>
            <dt>Shift+Click</dt>
            <dd>Select line range</dd>
          </dl>
          <button id="close-help">Close</button>
        </div>
      </div>
    </div>
    <script>
      window.COVERAGE_DATA = {"files":[{"id":0,"path":"examples/v1alpha1/webhook-interceptors/main.go","lines":["/*"," Copyright 2019 The Tekton Authors",""," Licensed under the Apache License, Version 2.0 (the \"License\");"," you may not use this file except in compliance with the License."," You may obtain a copy of the License at","","     http://www.apache.org/licenses/LICENSE-2.0",""," Unless required by applicable law or agreed to in writing, software"," distributed under the License is distributed on an \"AS IS\" BASIS,"," WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."," See the License for the specific language governing permissions and"," limitations under the License.","*/","","package main","","import (","\t\"fmt\"","\t\"log\"","\t\"net/http\"","\t\"os\"","","\t\"github.com/google/go-github/v31/github\"",")","","const (","\t// Environment variable containing GitHub secret token","\tenvSecret = \"GITHUB_SECRET_TOKEN\"",")","","func main() {","\tsecretToken := os.Getenv(envSecret)","\tif secretToken == \"\" {","\t\tlog.Fatalf(\"No secret token given\")","\t}","","\thttp.HandleFunc(\"/\", func(writer http.ResponseWriter, request *http.Request) {","\t\t// TODO: We should probably send over the EL eventID as a X-Tekton-Event-Id header as well","\t\tpayload, err := github.ValidatePayload(request, []byte(secretToken))","\t\tid := github.DeliveryID(request)","\t\tif err != nil {","\t\t\tlog.Printf(\"Error handling GitHub Event with delivery ID %s : %q\", id, err)","\t\t\thttp.Error(writer, fmt.Sprint(err), http.StatusBadRequest)","\t\t}","\t\tlog.Printf(\"Handling GitHub Event with delivery ID: %s; Payload: %s\", id, payload)","\t\tn, err := writer.Write(payload)","\t\tif err != nil {","\t\t\tlog.Printf(\"Failed to write response for GitHub event ID: %s. Bytes writted: %d. Error: %q\", id, n, err)","\t\t}","\t})","","\tlog.Fatal(http.ListenAndServe(fmt.Sprintf(\":%d\", 8080), nil)) //nolint:gosec","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0]},{"id":1,"path":"pkg/adapter/adapter.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package adapter","","import (","\t\"bytes\"","\t\"context\"","\t\"crypto/tls\"","\t\"crypto/x509\"","\t\"errors\"","\t\"fmt\"","\t\"net\"","\t\"net/http\"","\t\"sync\"","\t\"time\"","","\tclusterinterceptorsinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor\"","\tinterceptorsinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor\"","\tclustertriggerbindingsinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding\"","\teventlistenerinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener\"","\ttriggersinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/trigger\"","\ttriggerbindingsinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding\"","\ttriggertemplatesinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate\"","","\tcloudevents \"github.com/cloudevents/sdk-go/v2\"","\t\"github.com/tektoncd/triggers/pkg/client/clientset/versioned/scheme\"","\t\"github.com/tektoncd/triggers/pkg/sink\"","\t\"go.uber.org/zap\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/apimachinery/pkg/util/wait\"","\t\"k8s.io/apimachinery/pkg/watch\"","\tv1 \"k8s.io/client-go/kubernetes/typed/core/v1\"","\t\"k8s.io/client-go/tools/record\"","\t\"knative.dev/eventing/pkg/adapter/v2\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection/clients/dynamicclient\"","\t\"knative.dev/pkg/logging\"",")","","type envConfig struct {","\tadapter.EnvConfig","}","","func NewEnvConfig() adapter.EnvConfigAccessor {","\treturn \u0026envConfig{}","}","","var (","\tinterval = 10 * time.Second","\ttimeout  = 1 * time.Minute",")","","// sinker implements the adapter for an event listener.","type sinker struct {","\tLogger    *zap.SugaredLogger","\tNamespace string","","\tArgs     sink.Args","\tClients  sink.Clients","\tRecorder *sink.Recorder","","\tinjCtx context.Context //nolint:containedctx","}","","var _ adapter.Adapter = (*sinker)(nil)","","func (s *sinker) createRecorder(ctx context.Context, agentName string) record.EventRecorder {","\tlogger := logging.FromContext(ctx)","","\trecorder := controller.GetEventRecorder(ctx)","\tif recorder == nil {","\t\t// Create event broadcaster","\t\tlogger.Debug(\"Creating event broadcaster\")","\t\teventBroadcaster := record.NewBroadcaster()","\t\twatches := []watch.Interface{","\t\t\teventBroadcaster.StartLogging(logger.Named(\"event-broadcaster\").Infof),","\t\t\teventBroadcaster.StartRecordingToSink(","\t\t\t\t\u0026v1.EventSinkImpl{Interface: s.Clients.K8sClient.CoreV1().Events(\"\")}),","\t\t}","","\t\trecorder = eventBroadcaster.NewRecorder(scheme.Scheme, corev1.EventSource{Component: agentName})","\t\tgo func() {","\t\t\t\u003c-ctx.Done()","\t\t\tfor _, w := range watches {","\t\t\t\tw.Stop()","\t\t\t}","\t\t}()","\t}","","\treturn recorder","}","","func (s *sinker) getHTTPClient() (*http.Client, error) {","\tvar tlsConfig *tls.Config","","\tcertPool := x509.NewCertPool()","","\terr := s.getCertFromInterceptor(certPool)","\tif err != nil {","\t\treturn \u0026http.Client{}, fmt.Errorf(\"Timed out waiting on CaBundle to available for clusterInterceptor: %w\", err)","\t}","","\t// running go routine here to add/update certPool if there is new or change in caCert bundle.","\t// caCert changes if certs expired, if someone adds new ClusterInterceptor with caBundle","\tticker := time.NewTicker(time.Minute)","\tgo func() {","\t\tfor {","\t\t\t\u003c-ticker.C","\t\t\tif err := s.getCertFromInterceptor(certPool); err != nil {","\t\t\t\ts.Logger.Fatalf(\"Timed out waiting on CaBundle to available for clusterInterceptor: %v\", err)","\t\t\t}","\t\t}","\t}()","","\ttlsConfig = \u0026tls.Config{","\t\tRootCAs:    certPool,","\t\tMinVersion: tls.VersionTLS12, // Added MinVersion to avoid  G402: TLS MinVersion too low. (gosec)","\t}","\treturn \u0026http.Client{","\t\tTransport: \u0026http.Transport{","\t\t\tTLSClientConfig: tlsConfig,","\t\t\tDial: (\u0026net.Dialer{","\t\t\t\tTimeout:   s.Args.ElHTTPClientReadTimeOut * time.Second, //nolint:durationcheck","\t\t\t\tKeepAlive: s.Args.ElHTTPClientKeepAlive * time.Second,   //nolint:durationcheck","\t\t\t}).Dial,","\t\t\tTLSHandshakeTimeout:   s.Args.ElHTTPClientTLSHandshakeTimeout * time.Second,         //nolint:durationcheck","\t\t\tResponseHeaderTimeout: s.Args.ElHTTPClientResponseHeaderTimeout * time.Second,       //nolint:durationcheck","\t\t\tExpectContinueTimeout: s.Args.ElHTTPClientExpectContinueTimeout * time.Second}}, nil //nolint:durationcheck","}","","func (s *sinker) getCertFromInterceptor(certPool *x509.CertPool) error {","\tvar (","\t\tcaCert     []byte","\t\tcount      int","\t\thttpsCILen int","\t)","\tctx := context.Background()","\tif err := wait.PollUntilContextTimeout(ctx, interval, timeout, true, func(_ context.Context) (bool, error) {","\t\tclusterInterceptorList, err := clusterinterceptorsinformer.Get(s.injCtx).Lister().List(labels.NewSelector()) //nolint:contextcheck","\t\tif err != nil {","\t\t\treturn false, err","\t\t}","","\t\tfor i := range clusterInterceptorList {","\t\t\tif v, k := clusterInterceptorList[i].Labels[\"server/type\"]; k \u0026\u0026 v == \"https\" {","\t\t\t\thttpsCILen++","\t\t\t\tif !bytes.Equal(clusterInterceptorList[i].Spec.ClientConfig.CaBundle, []byte{}) {","\t\t\t\t\tcaCert = clusterInterceptorList[i].Spec.ClientConfig.CaBundle","\t\t\t\t\tif ok := certPool.AppendCertsFromPEM(caCert); !ok {","\t\t\t\t\t\treturn false, fmt.Errorf(\"unable to parse cert from %s\", caCert)","\t\t\t\t\t}","\t\t\t\t\tcount++","\t\t\t\t}","\t\t\t}","\t\t}","","\t\tif httpsCILen == 0 || httpsCILen != count {","\t\t\treturn false, errors.New(\"empty caBundle in clusterInterceptor spec\")","\t\t}","","\t\thttpsCILen = 0","\t\tcount = 0","","\t\tinterceptorList, err := interceptorsinformer.Get(s.injCtx).Lister().Interceptors(s.Namespace).List(labels.Everything()) //nolint:contextcheck","\t\tif err != nil {","\t\t\treturn false, err","\t\t}","","\t\tfor i := range interceptorList {","\t\t\tif v, k := interceptorList[i].Labels[\"server/type\"]; k \u0026\u0026 v == \"https\" {","\t\t\t\thttpsCILen++","\t\t\t\tif !bytes.Equal(interceptorList[i].Spec.ClientConfig.CaBundle, []byte{}) {","\t\t\t\t\tcaCert = interceptorList[i].Spec.ClientConfig.CaBundle","\t\t\t\t\tif ok := certPool.AppendCertsFromPEM(caCert); !ok {","\t\t\t\t\t\treturn false, fmt.Errorf(\"unable to parse cert from %s\", caCert)","\t\t\t\t\t}","\t\t\t\t\tcount++","\t\t\t\t}","\t\t\t}","\t\t}","\t\tif httpsCILen != count {","\t\t\treturn false, errors.New(\"empty caBundle in interceptor spec\")","\t\t}","","\t\treturn true, nil","\t}); err != nil {","\t\treturn fmt.Errorf(\"Timed out waiting on CaBundle to available for Interceptor: %w\", err)","\t}","\treturn nil","}","","func (s *sinker) Start(ctx context.Context) error {","\tclientObj, err := s.getHTTPClient()","\tif err != nil {","\t\treturn err","\t}","\t// Create EventListener Sink","","\tdynamicClient := dynamicclient.Get(ctx)","","\tr := sink.Sink{","\t\tKubeClientSet:          kubeclient.Get(ctx),","\t\tDiscoveryClient:        s.Clients.DiscoveryClient,","\t\tDynamicClient:          dynamicClient,","\t\tTriggersClient:         s.Clients.TriggersClient,","\t\tHTTPClient:             clientObj,","\t\tCEClient:               s.Clients.CEClient,","\t\tEventListenerName:      s.Args.ElName,","\t\tEventListenerNamespace: s.Args.ElNamespace,","\t\tPayloadValidation:      s.Args.PayloadValidation,","\t\tLogger:                 s.Logger,","\t\tRecorder:               s.Recorder,","\t\tCloudEventURI:          s.Args.CloudEventURI,","\t\tAuth:                   sink.DefaultAuthOverride{},","\t\tWGProcessTriggers:      \u0026sync.WaitGroup{},","\t\tEventRecorder:          s.createRecorder(s.injCtx, \"EventListener\"), //nolint:contextcheck","","\t\t// Register all the listers we'll need","\t\tEventListenerLister:         eventlistenerinformer.Get(s.injCtx).Lister(),          //nolint:contextcheck","\t\tTriggerLister:               triggersinformer.Get(s.injCtx).Lister(),               //nolint:contextcheck","\t\tTriggerBindingLister:        triggerbindingsinformer.Get(s.injCtx).Lister(),        //nolint:contextcheck","\t\tClusterTriggerBindingLister: clustertriggerbindingsinformer.Get(s.injCtx).Lister(), //nolint:contextcheck","\t\tTriggerTemplateLister:       triggertemplatesinformer.Get(s.injCtx).Lister(),       //nolint:contextcheck","\t\tClusterInterceptorLister:    clusterinterceptorsinformer.Get(s.injCtx).Lister(),    //nolint:contextcheck","\t\tInterceptorLister:           interceptorsinformer.Get(s.injCtx).Lister(),           //nolint:contextcheck","\t}","","\tmux := http.NewServeMux()","\teventHandler := http.HandlerFunc(r.HandleEvent)","\tmetricsRecorder := \u0026sink.MetricsHandler{Handler: r.IsValidPayload(eventHandler)}","","\tmux.HandleFunc(\"/\", metricsRecorder.Intercept(r.NewMetricsRecorderInterceptor()))","","\t// For handling Liveness Probe","\t// TODO(dibyom): Livness, metrics etc. should be on a separate port","\tmux.HandleFunc(\"/live\", func(w http.ResponseWriter, _ *http.Request) {","\t\tw.WriteHeader(http.StatusOK)","\t\tfmt.Fprint(w, \"ok\")","\t})","","\tsrv := \u0026http.Server{","\t\tAddr:              \":\" + s.Args.Port,","\t\tReadHeaderTimeout: s.Args.ELReadTimeOut * time.Second,  //nolint:durationcheck","\t\tReadTimeout:       s.Args.ELReadTimeOut * time.Second,  //nolint:durationcheck","\t\tWriteTimeout:      s.Args.ELWriteTimeOut * time.Second, //nolint:durationcheck","\t\tIdleTimeout:       s.Args.ELIdleTimeOut * time.Second,  //nolint:durationcheck","\t\tHandler: http.TimeoutHandler(mux,","\t\t\ts.Args.ELTimeOutHandler*time.Second, \"EventListener Timeout!\\n\"), //nolint:durationcheck","\t}","","\tif s.Args.Cert == \"\" \u0026\u0026 s.Args.Key == \"\" {","\t\tif err := srv.ListenAndServe(); err != nil {","\t\t\treturn err","\t\t}","\t} else {","\t\tif err := srv.ListenAndServeTLS(s.Args.Cert, s.Args.Key); err != nil {","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","func New(sinkArgs sink.Args, sinkClients sink.Clients, recorder *sink.Recorder) adapter.AdapterConstructor {","\treturn func(ctx context.Context, processed adapter.EnvConfigAccessor, _ cloudevents.Client) adapter.Adapter {","\t\tenv := processed.(*envConfig)","\t\tlogger := logging.FromContext(ctx)","","\t\treturn \u0026sinker{","\t\t\tLogger:    logger,","\t\t\tNamespace: env.Namespace,","\t\t\tArgs:      sinkArgs,","\t\t\tClients:   sinkClients,","\t\t\tRecorder:  recorder,","\t\t\tinjCtx:    ctx,","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,0,2,2,2,2,2,2,2,2,2,0,0,0,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,1,0,0,0,0,2,2,2,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,2,2,2,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":2,"path":"pkg/apis/config/default.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"fmt\"","\t\"os\"","\t\"strconv\"","","\tcorev1 \"k8s.io/api/core/v1\"",")","","const (","\tdefaultServiceAccountKey   = \"default-service-account\"","\tDefaultRunAsUserKey        = \"default-run-as-user\"","\tDefaultRunAsGroupKey       = \"default-run-as-group\"","\tDefaultFSGroupKey          = \"default-fs-group\"","\tdefaultRunAsNonRootKey     = \"default-run-as-non-root\"","\tDefaultServiceAccountValue = \"default\"","\tdefaultRunAsUserValue      = 65532","\tdefaultRunAsGroupValue     = 65532","\tdefaultFsGroupValue        = 65532","\tdefaultRunAsNonRootValue   = true",")","","// Defaults holds the default configurations","// +k8s:deepcopy-gen=true","type Defaults struct {","\tDefaultServiceAccount string","\tDefaultRunAsUser      int64","\tDefaultRunAsGroup     int64","\tDefaultFSGroup        int64","\tDefaultRunAsNonRoot   bool","\t// These three fields are used to decide whether to configure","\t// runAsUser, runAsGroup and fsGroup within a Security Context Constraint (SCC).","\tIsDefaultRunAsUserEmpty  bool","\tIsDefaultRunAsGroupEmpty bool","\tIsDefaultFsGroupEmpty    bool","}","","// GetDefaultsConfigName returns the name of the configmap containing all","// defined defaults.","func GetDefaultsConfigName() string {","\tif e := os.Getenv(\"CONFIG_DEFAULTS_NAME\"); e != \"\" {","\t\treturn e","\t}","\treturn \"config-defaults-triggers\"","}","","// Equals returns true if two Configs are identical","func (cfg *Defaults) Equals(other *Defaults) bool {","\tif cfg == nil \u0026\u0026 other == nil {","\t\treturn true","\t}","","\tif cfg == nil || other == nil {","\t\treturn false","\t}","","\treturn other.DefaultServiceAccount == cfg.DefaultServiceAccount \u0026\u0026","\t\tother.DefaultRunAsUser == cfg.DefaultRunAsUser \u0026\u0026","\t\tother.DefaultRunAsGroup == cfg.DefaultRunAsGroup \u0026\u0026","\t\tother.DefaultFSGroup == cfg.DefaultFSGroup \u0026\u0026","\t\tother.DefaultRunAsNonRoot == cfg.DefaultRunAsNonRoot","}","","// NewDefaultsFromMap returns a Config given a map corresponding to a ConfigMap","func NewDefaultsFromMap(cfgMap map[string]string) (*Defaults, error) {","\ttc := Defaults{","\t\tDefaultServiceAccount: DefaultServiceAccountValue,","\t\tDefaultRunAsUser:      defaultRunAsUserValue,","\t\tDefaultRunAsGroup:     defaultRunAsGroupValue,","\t\tDefaultFSGroup:        defaultFsGroupValue,","\t\tDefaultRunAsNonRoot:   defaultRunAsNonRootValue,","\t}","","\tif defaultServiceAccount, ok := cfgMap[defaultServiceAccountKey]; ok {","\t\ttc.DefaultServiceAccount = defaultServiceAccount","\t}","","\tif defaultRunAsUser, ok := cfgMap[DefaultRunAsUserKey]; ok {","\t\tif defaultRunAsUser != \"\" {","\t\t\trunAsUser, err := strconv.ParseInt(defaultRunAsUser, 10, 0)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"failed parsing runAsUser config %q\", defaultRunAsUser)","\t\t\t}","\t\t\ttc.DefaultRunAsUser = runAsUser","\t\t} else {","\t\t\t// if runAsUser is \"\" don't set runAsUser in SCC","\t\t\ttc.IsDefaultRunAsUserEmpty = true","\t\t}","\t}","","\tif defaultRunAsGroup, ok := cfgMap[DefaultRunAsGroupKey]; ok {","\t\tif defaultRunAsGroup != \"\" {","\t\t\trunAsGroup, err := strconv.ParseInt(defaultRunAsGroup, 10, 0)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"failed parsing runAsGroup config %q\", defaultRunAsGroup)","\t\t\t}","\t\t\ttc.DefaultRunAsGroup = runAsGroup","\t\t} else {","\t\t\t// if runAsGroup is \"\" don't set runAsGroup in SCC","\t\t\ttc.IsDefaultRunAsGroupEmpty = true","\t\t}","\t}","","\tif defaultFsGroup, ok := cfgMap[DefaultFSGroupKey]; ok {","\t\tif defaultFsGroup != \"\" {","\t\t\tfsGroup, err := strconv.ParseInt(defaultFsGroup, 10, 0)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"failed parsing fsGroup config %q\", defaultFsGroup)","\t\t\t}","\t\t\ttc.DefaultFSGroup = fsGroup","\t\t} else {","\t\t\t// if fsGroup is \"\" don't set fsGroup in SCC","\t\t\ttc.IsDefaultFsGroupEmpty = true","\t\t}","\t}","","\tif defaultRunAsNonRoot, ok := cfgMap[defaultRunAsNonRootKey]; ok {","\t\tif defaultRunAsNonRoot != \"\" {","\t\t\trunAsNonRoot, err := strconv.ParseBool(defaultRunAsNonRoot)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"failed parsing runAsNonRoot config %q\", defaultRunAsNonRoot)","\t\t\t}","\t\t\ttc.DefaultRunAsNonRoot = runAsNonRoot","\t\t} else {","\t\t\t// if \"\" value is provided via configmap set back to default value which is true","\t\t\ttc.DefaultRunAsNonRoot = defaultRunAsNonRootValue","\t\t}","\t}","","\treturn \u0026tc, nil","}","","// NewDefaultsFromConfigMap returns a Config for the given configmap","func NewDefaultsFromConfigMap(config *corev1.ConfigMap) (*Defaults, error) {","\treturn NewDefaultsFromMap(config.Data)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,2,0,0,0,2,2,2,2,0,2,2,2,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,1,1,2,2,2,2,2,0,0,2,2,2,2,1,1,2,2,2,2,2,0,0,2,2,2,2,1,1,2,2,2,2,2,0,0,2,2,2,2,1,1,2,2,2,2,2,0,0,2,0,0,0,2,2,2]},{"id":3,"path":"pkg/apis/config/feature_flags.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"fmt\"","\t\"os\"","\t\"regexp\"","\t\"strings\"","","\tcorev1 \"k8s.io/api/core/v1\"",")","","const (","\tStableAPIFieldValue    = \"stable\"","\tAlphaAPIFieldValue     = \"alpha\"","\tenableAPIFieldsKey     = \"enable-api-fields\"","\tDefaultEnableAPIFields = StableAPIFieldValue","","\tlabelsExclusionPattern = \"labels-exclusion-pattern\"",")","","// FeatureFlags holds the features configurations","// +k8s:deepcopy-gen=true","type FeatureFlags struct {","\t// EnableAPIFields determines which gated features are enabled.","\t// Acceptable values are \"stable\" or \"alpha\". Defaults to \"stable\"","\tEnableAPIFields string","\t// LabelsExclusionPattern determines the regex pattern to use to exclude","\t// labels being propagated to resources created by the EventListener","\tLabelsExclusionPattern string","}","","// GetFeatureFlagsConfigName returns the name of the configmap containing all","// feature flags.","func GetFeatureFlagsConfigName() string {","\tif e := os.Getenv(\"CONFIG_FEATURE_FLAGS_NAME\"); e != \"\" {","\t\treturn e","\t}","\treturn \"feature-flags-triggers\"","}","","// NewFeatureFlagsFromMap returns a Config given a map corresponding to a ConfigMap","func NewFeatureFlagsFromMap(cfgMap map[string]string) (*FeatureFlags, error) {","\ttc := FeatureFlags{}","\tvar err error","\tif tc.EnableAPIFields, err = getEnabledAPI(cfgMap); err != nil {","\t\treturn nil, err","\t}","","\tif tc.LabelsExclusionPattern, err = getLabelsExclusionPattern(cfgMap); err != nil {","\t\treturn nil, err","\t}","","\treturn \u0026tc, nil","}","","// getLabelsExclusionPattern gets the \"labels-exclusion-pattern\" flag based on the content of a given map.","// If the feature gate is not defined then we ignore it, if the pattern is not","// valid regex then we return error","func getLabelsExclusionPattern(cfgMap map[string]string) (string, error) {","\tif pattern, ok := cfgMap[labelsExclusionPattern]; ok {","\t\tif _, err := regexp.Compile(pattern); err != nil {","\t\t\treturn \"\", fmt.Errorf(\"invalid value for feature flag %q: %q\", labelsExclusionPattern, pattern)","\t\t}","\t\treturn pattern, nil","\t}","","\treturn \"\", nil","}","","// getEnabledAPI gets the \"enable-api-fields\" flag based on the content of a given map.","// If the feature gate is invalid or missing then an error is returned.","func getEnabledAPI(cfgMap map[string]string) (string, error) {","\tvalue := DefaultEnableAPIFields","\tif cfg, ok := cfgMap[enableAPIFieldsKey]; ok {","\t\tvalue = strings.ToLower(cfg)","\t}","\tif value != AlphaAPIFieldValue \u0026\u0026 value != StableAPIFieldValue {","\t\treturn \"\", fmt.Errorf(\"invalid value for feature flag %q: %q\", enableAPIFieldsKey, value)","\t}","\treturn value, nil","}","","// NewFeatureFlagsFromConfigMap returns a Config for the given configmap","func NewFeatureFlagsFromConfigMap(config *corev1.ConfigMap) (*FeatureFlags, error) {","\treturn NewFeatureFlagsFromMap(config.Data)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,2,2,2,0,2,0,0,0,0,0,2,2,2,2,2,2,0,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2]},{"id":4,"path":"pkg/apis/config/store.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package config","","import (","\t\"context\"","","\t\"knative.dev/pkg/configmap\"",")","","type cfgKey struct{}","","// Config holds the collection of configurations that we attach to contexts.","// +k8s:deepcopy-gen=false","type Config struct {","\tDefaults     *Defaults","\tFeatureFlags *FeatureFlags","}","","// FromContext extracts a Config from the provided context.","func FromContext(ctx context.Context) *Config {","\tx, ok := ctx.Value(cfgKey{}).(*Config)","\tif ok {","\t\treturn x","\t}","\treturn nil","}","","// FromContextOrDefaults is like FromContext, but when no Config is attached it","// returns a Config populated with the defaults for each of the Config fields.","func FromContextOrDefaults(ctx context.Context) *Config {","\tif cfg := FromContext(ctx); cfg != nil {","\t\treturn cfg","\t}","\tdefaults, _ := NewDefaultsFromMap(map[string]string{})","\tfeatureFlags, _ := NewFeatureFlagsFromMap(map[string]string{})","\treturn \u0026Config{","\t\tDefaults:     defaults,","\t\tFeatureFlags: featureFlags,","\t}","}","","// ToContext attaches the provided Config to the provided context, returning the","// new context with the Config attached.","func ToContext(ctx context.Context, c *Config) context.Context {","\treturn context.WithValue(ctx, cfgKey{}, c)","}","","// Store is a typed wrapper around configmap.Untyped store to handle our configmaps.","// +k8s:deepcopy-gen=false","type Store struct {","\t*configmap.UntypedStore","}","","// NewStore creates a new store of Configs and optionally calls functions when ConfigMaps are updated.","func NewStore(logger configmap.Logger, onAfterStore ...func(name string, value interface{})) *Store {","\tstore := \u0026Store{","\t\tUntypedStore: configmap.NewUntypedStore(","\t\t\t\"defaults/features/artifacts\",","\t\t\tlogger,","\t\t\tconfigmap.Constructors{","\t\t\t\tGetFeatureFlagsConfigName(): NewFeatureFlagsFromConfigMap,","\t\t\t\tGetDefaultsConfigName():     NewDefaultsFromConfigMap,","\t\t\t},","\t\t\tonAfterStore...,","\t\t),","\t}","","\treturn store","}","","// ToContext attaches the current Config state to the provided context.","func (s *Store) ToContext(ctx context.Context) context.Context {","\treturn ToContext(ctx, s.Load())","}","","// Load creates a Config from the current config state of the Store.","func (s *Store) Load() *Config {","\tdefaults := s.UntypedLoad(GetDefaultsConfigName())","\tif defaults == nil {","\t\tdefaults, _ = NewDefaultsFromMap(map[string]string{})","\t}","\tfeatureFlags := s.UntypedLoad(GetFeatureFlagsConfigName())","\tif featureFlags == nil {","\t\tfeatureFlags, _ = NewFeatureFlagsFromMap(map[string]string{})","\t}","","\treturn \u0026Config{","\t\tDefaults:     defaults.(*Defaults).DeepCopy(),","\t\tFeatureFlags: featureFlags.(*FeatureFlags).DeepCopy(),","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,1,1,2,2,2,2,0,2,2,2,2,0]},{"id":5,"path":"pkg/apis/triggers/contexts/contexts.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package contexts","","import \"context\"","","// upgradeViaDefaultingKey is used as the key in a context.Context.","// This variable doesn't really matter, so it can be a total random name.","// Setting this key indicates that default values for a resource should be","// updated to new values. This is used to ensure non breaking updates when","// a default value of a resource changes or when a field is removed.","type upgradeViaDefaultingKey struct{}","","// WithUpgradeViaDefaulting sets the upgradeViaDefaultingKey on the context","// indicating that default values for a resource should be updated to new values.","func WithUpgradeViaDefaulting(ctx context.Context) context.Context {","\treturn context.WithValue(ctx, upgradeViaDefaultingKey{}, struct{}{})","}","","// IsUpgradeViaDefaulting checks if the upgradeViaDefaultingKey is set on","// the context.","func IsUpgradeViaDefaulting(ctx context.Context) bool {","\treturn ctx.Value(upgradeViaDefaultingKey{}) != nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1]},{"id":6,"path":"pkg/apis/triggers/v1alpha1/cluster_interceptor_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"",")","","// SetDefaults sets the defaults on the object.","func (it *ClusterInterceptor) SetDefaults(ctx context.Context) {","\tif !contexts.IsUpgradeViaDefaulting(ctx) {","\t\treturn","\t}","\tif _, ok := it.GetLabels()[\"server/type\"]; !ok {","\t\t// if server type is not set its assumed that running server is http","\t\tit.Labels = map[string]string{","\t\t\t\"server/type\": \"http\",","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":7,"path":"pkg/apis/triggers/v1alpha1/cluster_interceptor_types.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"bytes\"","\t\"errors\"","\t\"fmt\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// Check that EventListener may be validated and defaulted.","var _ apis.Validatable = (*ClusterInterceptor)(nil)","var _ apis.Defaultable = (*ClusterInterceptor)(nil)","","// +genclient","// +genclient:nonNamespaced","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +k8s:openapi-gen=true","// ClusterInterceptor describes a pluggable interceptor including configuration","// such as the fields it accepts and its deployment address. The type is based on","// the Validating/MutatingWebhookConfiguration types for configuring AdmissionWebhooks","type ClusterInterceptor struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec ClusterInterceptorSpec `json:\"spec\"`","\t// +optional","\tStatus ClusterInterceptorStatus `json:\"status\"`","}","","// ClusterInterceptorSpec describes the Spec for an ClusterInterceptor","type ClusterInterceptorSpec struct {","\tClientConfig ClientConfig `json:\"clientConfig\"`","}","","// ClusterInterceptorStatus holds the status of the ClusterInterceptor","// +k8s:deepcopy-gen=true","type ClusterInterceptorStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// ClusterInterceptor is Addressable and exposes the URL where the Interceptor is running","\tduckv1.AddressStatus `json:\",inline\"`","}","","// ClientConfig describes how a client can communicate with the Interceptor","type ClientConfig struct {","\t// CaBundle is a PEM encoded CA bundle which will be used to validate the clusterinterceptor server certificate","\tCaBundle []byte `json:\"caBundle,omitempty\"`","\t// URL is a fully formed URL pointing to the interceptor","\t// Mutually exclusive with Service","\tURL *apis.URL `json:\"url,omitempty\"`","","\t// Service is a reference to a Service object where the interceptor is running","\t// Mutually exclusive with URL","\tService *ServiceReference `json:\"service,omitempty\"`","}","","var (","\tdefaultHTTPSPort = int32(8443)","\tdefaultHTTPPort  = int32(80)",")","","// ServiceReference is a reference to a Service object","// with an optional path","type ServiceReference struct {","\t// Name is the name of the service","\tName string `json:\"name\"`","","\t// Namespace is the namespace of the service","\tNamespace string `json:\"namespace\"`","","\t// Path is an optional URL path","\t// +optional","\tPath string `json:\"path,omitempty\"`","","\t// Port is a valid port number","\tPort *int32 `json:\"port,omitempty\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// ClusterInterceptorList contains a list of ClusterInterceptor","// We don't use this but it's required for certain codegen features.","type ClusterInterceptorList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []ClusterInterceptor `json:\"items\"`","}","","var ErrNilURL = errors.New(\"interceptor URL was nil\")","","// ResolveAddress returns the URL where the interceptor is running using its clientConfig","func (it *ClusterInterceptor) ResolveAddress() (*apis.URL, error) {","\tif url := it.Spec.ClientConfig.URL; url != nil {","\t\treturn url, nil","\t}","\tsvc := it.Spec.ClientConfig.Service","\tif svc == nil {","\t\treturn nil, ErrNilURL","\t}","\tvar (","\t\tport *int32","\t\turl  *apis.URL","\t)","","\tif svc.Port != nil {","\t\tport = svc.Port","\t}","","\tif bytes.Equal(it.Spec.ClientConfig.CaBundle, []byte{}) {","\t\tif port == nil {","\t\t\tport = \u0026defaultHTTPPort","\t\t}","\t\turl = formURL(\"http\", svc, port)","\t} else {","\t\tif port == nil {","\t\t\tport = \u0026defaultHTTPSPort","\t\t}","\t\turl = formURL(\"https\", svc, port)","\t}","\treturn url, nil","}","","func formURL(scheme string, svc *ServiceReference, port *int32) *apis.URL {","\treturn \u0026apis.URL{","\t\tScheme: scheme,","\t\tHost:   fmt.Sprintf(\"%s.%s.svc:%d\", svc.Name, svc.Namespace, *port),","\t\tPath:   svc.Path,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2]},{"id":8,"path":"pkg/apis/triggers/v1alpha1/cluster_interceptor_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"knative.dev/pkg/apis\"",")","","// Validate ClusterInterceptor","func (it *ClusterInterceptor) Validate(ctx context.Context) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","\treturn it.Spec.validate(ctx)","}","","// revive:disable:unused-parameter","","func (s *ClusterInterceptorSpec) validate(ctx context.Context) (errs *apis.FieldError) {","\tif s.ClientConfig.URL != nil \u0026\u0026 s.ClientConfig.Service != nil {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"spec.clientConfig.url\", \"spec.clientConfig.service\"))","\t}","\tif svc := s.ClientConfig.Service; svc != nil {","\t\tif svc.Namespace == \"\" {","\t\t\terrs = errs.Also(apis.ErrMissingField(\"spec.clientConfig.service.namespace\"))","\t\t}","\t\tif svc.Name == \"\" {","\t\t\terrs = errs.Also(apis.ErrMissingField(\"spec.clientConfig.service.name\"))","\t\t}","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,0]},{"id":9,"path":"pkg/apis/triggers/v1alpha1/cluster_trigger_binding_defaults.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"",")","","// revive:disable:unused-parameter","","// SetDefaults initializes ClusterTriggerBinding ctb with its default values.","func (ctb *ClusterTriggerBinding) SetDefaults(ctx context.Context) {}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":10,"path":"pkg/apis/triggers/v1alpha1/cluster_trigger_binding_types.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","// Check that ClusterTriggerBinding may be validated and defaulted.","var _ apis.Validatable = (*ClusterTriggerBinding)(nil)","var _ apis.Defaultable = (*ClusterTriggerBinding)(nil)","","// +genclient","// +genclient:nonNamespaced","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +k8s:openapi-gen=true","","// ClusterTriggerBinding is a TriggerBinding with a cluster scope.","// ClusterTriggerBindings are used to represent TriggerBindings that","// should be publicly addressable from any namespace in the cluster.","type ClusterTriggerBinding struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\t// Spec holds the desired state of the ClusterTriggerBinding from the client","\t// +optional","\tSpec TriggerBindingSpec `json:\"spec,omitempty\"`","","\t// +optional","\tStatus TriggerBindingStatus `json:\"status,omitempty\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// ClusterTriggerBindingList contains a list of ClusterTriggerBinding","type ClusterTriggerBindingList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []ClusterTriggerBinding `json:\"items\"`","}","","func (ctb *ClusterTriggerBinding) TriggerBindingSpec() TriggerBindingSpec {","\treturn ctb.Spec","}","","func (ctb *ClusterTriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta {","\treturn ctb.ObjectMeta","}","","func (ctb *ClusterTriggerBinding) Copy() TriggerBindingInterface {","\treturn ctb.DeepCopy()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1]},{"id":11,"path":"pkg/apis/triggers/v1alpha1/cluster_trigger_binding_validation.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\t\"knative.dev/pkg/apis\"",")","","func (ctb *ClusterTriggerBinding) Validate(ctx context.Context) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tif err := validate.ObjectMetadata(ctb.GetObjectMeta()); err != nil {","\t\treturn err.ViaField(\"metadata\")","\t}","\treturn ctb.Spec.Validate(ctx)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,1,1,2,0]},{"id":12,"path":"pkg/apis/triggers/v1alpha1/event_listener_defaults.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"","\t\"knative.dev/pkg/logging\"",")","","// SetDefaults sets the defaults on the object.","func (el *EventListener) SetDefaults(ctx context.Context) {","\tcfg := config.FromContextOrDefaults(ctx)","\tif contexts.IsUpgradeViaDefaulting(ctx) {","\t\tdefaultSA := cfg.Defaults.DefaultServiceAccount","\t\tif el.Spec.ServiceAccountName == \"\" \u0026\u0026 defaultSA != \"\" {","\t\t\tel.Spec.ServiceAccountName = defaultSA","\t\t}","\t\t// set defaults","\t\tif el.Spec.Resources.KubernetesResource != nil {","\t\t\tif el.Spec.Resources.KubernetesResource.Replicas != nil \u0026\u0026 *el.Spec.Resources.KubernetesResource.Replicas == 0 {","\t\t\t\t*el.Spec.Resources.KubernetesResource.Replicas = 1","\t\t\t}","\t\t}","","\t\tfor i, t := range el.Spec.Triggers {","\t\t\ttriggerSpecBindingArray(el.Spec.Triggers[i].Bindings).defaultBindings()","\t\t\tfor _, ti := range t.Interceptors {","\t\t\t\tif ti != nil {","\t\t\t\t\tti.defaultInterceptorKind()","\t\t\t\t\tif err := ti.updateCoreInterceptors(); err != nil {","\t\t\t\t\t\t// The err only happens due to malformed JSON and should never really happen","\t\t\t\t\t\t// We can't return an error here, so print out the error","\t\t\t\t\t\tlogger := logging.FromContext(ctx)","\t\t\t\t\t\tlogger.Errorf(\"failed to setDefaults for trigger: %s; err: %s\", t.Name, err)","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,0,0,2,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0]},{"id":13,"path":"pkg/apis/triggers/v1alpha1/event_listener_types.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"fmt\"","","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"","\tduckv1alpha1 \"knative.dev/pkg/apis/duck/v1alpha1\"","\t\"knative.dev/pkg/apis/duck/v1beta1\"","\t\"knative.dev/pkg/kmeta\"",")","","// Check that EventListener may be validated and defaulted.","var _ apis.Validatable = (*EventListener)(nil)","var _ apis.Defaultable = (*EventListener)(nil)","","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// EventListener exposes a service to accept HTTP event payloads.","//","// +k8s:openapi-gen=true","type EventListener struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\t// Spec holds the desired state of the EventListener from the client","\t// +optional","\tSpec EventListenerSpec `json:\"spec\"`","\t// +optional","\tStatus EventListenerStatus `json:\"status,omitempty\"`","}","","var _ kmeta.OwnerRefable = (*EventListener)(nil)","","// EventListenerSpec defines the desired state of the EventListener, represented","// by a list of Triggers.","type EventListenerSpec struct {","\tServiceAccountName string `json:\"serviceAccountName,omitempty\"`","\t// +listType=atomic","\tTriggers          []EventListenerTrigger `json:\"triggers\"`","\tNamespaceSelector NamespaceSelector      `json:\"namespaceSelector,omitempty\"`","\tLabelSelector     *metav1.LabelSelector  `json:\"labelSelector,omitempty\"`","\tResources         Resources              `json:\"resources,omitempty\"`","}","","type Resources struct {","\tKubernetesResource *KubernetesResource `json:\"kubernetesResource,omitempty\"`","\tCustomResource     *CustomResource     `json:\"customResource,omitempty\"`","}","","type CustomResource struct {","\truntime.RawExtension `json:\",inline\"`","}","","type KubernetesResource struct {","\tReplicas           *int32             `json:\"replicas,omitempty\"`","\tServiceType        corev1.ServiceType `json:\"serviceType,omitempty\"`","\tduckv1.WithPodSpec `json:\"spec,omitempty\"`","}","","// EventListenerTrigger represents a connection between TriggerBinding, Params,","// and TriggerTemplate; TriggerBinding provides extracted values for","// TriggerTemplate to then create resources from. TriggerRef can also be","// provided instead of TriggerBinding, Interceptors and TriggerTemplate","type EventListenerTrigger struct {","\t// +listType=atomic","\tBindings   []*EventListenerBinding `json:\"bindings,omitempty\"`","\tTemplate   *EventListenerTemplate  `json:\"template,omitempty\"`","\tTriggerRef string                  `json:\"triggerRef,omitempty\"`","\t// +optional","\tName string `json:\"name,omitempty\"`","\t// +listType=atomic","\tInterceptors []*EventInterceptor `json:\"interceptors,omitempty\"`","\t// ServiceAccountName optionally associates credentials with each trigger;","\t// more granular authorization for","\t// who is allowed to utilize the associated pipeline","\t// vs. defaulting to whatever permissions are associated","\t// with the entire EventListener and associated sink facilitates","\t// multi-tenant model based scenarios","\t// +optional","\tServiceAccountName string `json:\"serviceAccountName,omitempty\"`","}","","// EventInterceptor provides a hook to intercept and pre-process events","type EventInterceptor = TriggerInterceptor","","// SecretRef contains the information required to reference a single secret string","// This is needed because the other secretRef types are not cross-namespace and do not","// actually contain the \"SecretName\" field, which allows us to access a single secret value.","type SecretRef struct {","\tSecretKey  string `json:\"secretKey,omitempty\"`","\tSecretName string `json:\"secretName,omitempty\"`","}","","// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBindingresource.","type EventListenerBinding = TriggerSpecBinding","","// EventListenerTemplate refers to a particular TriggerTemplate resource.","type EventListenerTemplate = TriggerSpecTemplate","","// EventListenerList contains a list of TriggerBinding","//","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type EventListenerList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []EventListener `json:\"items\"`","}","","// EventListenerStatus holds the status of the EventListener","// +k8s:deepcopy-gen=true","type EventListenerStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// EventListener is Addressable. It currently exposes the service DNS","\t// address of the EventListener sink","\tduckv1alpha1.AddressStatus `json:\",inline\"`","","\t// Configuration stores configuration for the EventListener service","\tConfiguration EventListenerConfig `json:\"configuration\"`","}","","// EventListenerConfig stores configuration for resources generated by the","// EventListener","type EventListenerConfig struct {","\t// GeneratedResourceName is the name given to all resources reconciled by","\t// the EventListener","\tGeneratedResourceName string `json:\"generatedName\"`","}","","// NamespaceSelector is a selector for selecting either all namespaces or a","// list of namespaces.","// +k8s:openapi-gen=true","type NamespaceSelector struct {","\t// List of namespace names.","\t// +listType=atomic","\tMatchNames []string `json:\"matchNames,omitempty\"`","}","","// The conditions that are internally resolved by the EventListener reconciler","const (","\t// ServiceExists is the ConditionType set on the EventListener, which","\t// specifies Service existence.","\tServiceExists apis.ConditionType = \"Service\"","\t// DeploymentExists is the ConditionType set on the EventListener, which","\t// specifies Deployment existence.","\tDeploymentExists apis.ConditionType = \"Deployment\"",")","","// Check that EventListener may be validated and defaulted.","// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.","type TriggerBindingKind string","","const (","\t// NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.","\tNamespacedTriggerBindingKind TriggerBindingKind = \"TriggerBinding\"","\t// ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.","\tClusterTriggerBindingKind TriggerBindingKind = \"ClusterTriggerBinding\"",")","","var eventListenerCondSet = apis.NewLivingConditionSet(","\tServiceExists,","\tDeploymentExists,",")","","// GetGroupVersionKind implements kmeta.OwnerRefable","func (el *EventListener) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(\"EventListener\")","}","","// GetCondition returns the Condition matching the given type.","func (els *EventListenerStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn eventListenerCondSet.Manage(els).GetCondition(t)","}","","// SetCondition sets the condition, unsetting previous conditions with the same","// type as necessary. This is a local change and needs to be persisted to the","// K8s API elsewhere.","func (els *EventListenerStatus) SetCondition(newCond *apis.Condition) {","\tif newCond != nil {","\t\t// TODO: Should the ConditionManager be set somewhere?","\t\teventListenerCondSet.Manage(els).SetCondition(*newCond)","\t}","}","","func (els *EventListenerStatus) SetReadyCondition() {","\tfor _, ct := range []apis.ConditionType{","\t\tServiceExists,","\t\tDeploymentExists,","\t\tapis.ConditionType(appsv1.DeploymentProgressing),","\t\tapis.ConditionType(appsv1.DeploymentAvailable)} {","\t\tif sc := els.GetCondition(ct); sc != nil {","\t\t\tif sc.Status != corev1.ConditionTrue {","\t\t\t\tels.SetCondition(\u0026apis.Condition{","\t\t\t\t\tType:    apis.ConditionReady,","\t\t\t\t\tStatus:  corev1.ConditionFalse,","\t\t\t\t\tMessage: fmt.Sprintf(\"Condition %s has status: %s with message: %s\", sc.Type, sc.Status, sc.Message),","\t\t\t\t})","\t\t\t\treturn","\t\t\t}","\t\t}","\t}","\tels.SetCondition(\u0026apis.Condition{","\t\tType:    apis.ConditionReady,","\t\tStatus:  corev1.ConditionTrue,","\t\tMessage: \"EventListener is ready\",","\t})","}","","// SetDeploymentConditions sets the Deployment conditions on the EventListener,","// which is a reflection of the actual Deployment status.","func (els *EventListenerStatus) SetDeploymentConditions(deploymentConditions []appsv1.DeploymentCondition) {","\t// Manually remove the DeploymentReplicaFailure condition since it does","\t// not always exist and would stay around otherwise","\treplicaFailureIndex := -1","\tfor i := range els.Conditions {","\t\tif els.Conditions[i].Type == apis.ConditionType(appsv1.DeploymentReplicaFailure) {","\t\t\treplicaFailureIndex = i","\t\t\tbreak","\t\t}","\t}","\tif replicaFailureIndex != -1 {","\t\tels.Conditions = append(els.Conditions[:replicaFailureIndex], els.Conditions[replicaFailureIndex+1:]...)","\t}","\tfor _, cond := range deploymentConditions {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    apis.ConditionType(cond.Type),","\t\t\tStatus:  cond.Status,","\t\t\tReason:  cond.Reason,","\t\t\tMessage: cond.Message,","\t\t})","\t}","}","","func (els *EventListenerStatus) SetConditionsForDynamicObjects(conditions v1beta1.Conditions) {","\tfor _, cond := range conditions {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    cond.Type,","\t\t\tStatus:  cond.Status,","\t\t\tReason:  cond.Reason,","\t\t\tMessage: cond.Message,","\t\t})","\t}","","\tels.SetCondition(\u0026apis.Condition{","\t\tType:    apis.ConditionReady,","\t\tStatus:  corev1.ConditionTrue,","\t\tMessage: \"EventListener is ready\",","\t})","}","","// SetExistsCondition simplifies setting the exists conditions on the","// EventListenerStatus.","func (els *EventListenerStatus) SetExistsCondition(cond apis.ConditionType, err error) {","\tif err != nil {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    cond,","\t\t\tStatus:  corev1.ConditionFalse,","\t\t\tMessage: err.Error(),","\t\t})","\t} else {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    cond,","\t\t\tStatus:  corev1.ConditionTrue,","\t\t\tMessage: fmt.Sprintf(\"%s exists\", cond),","\t\t})","\t}","}","","// InitializeConditions will set all conditions in eventListenerCondSet to false","// for the EventListener. This does not use the InitializeCondition() provided","// by the conditionsImpl to avoid setting the happy condition. This is a local","// change and needs to be persisted to the K8s API elsewhere.","func (els *EventListenerStatus) InitializeConditions() {","\tfor _, condition := range []apis.ConditionType{","\t\tServiceExists,","\t\tDeploymentExists,","\t\tapis.ConditionReady,","\t} {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:   condition,","\t\t\tStatus: corev1.ConditionFalse,","\t\t})","\t}","}","","// SetAddress sets the address (as part of Addressable contract) and marks the correct condition.","func (els *EventListenerStatus) SetAddress(hostname string) {","\tif els.Address == nil {","\t\tels.Address = \u0026duckv1alpha1.Addressable{}","\t}","\tif hostname != \"\" {","\t\tels.Address.URL = \u0026apis.URL{","\t\t\tScheme: \"http\",","\t\t\tHost:   hostname,","\t\t}","\t} else {","\t\tels.Address.URL = nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,2,2,2,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":14,"path":"pkg/apis/triggers/v1alpha1/event_listener_validation.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"k8s.io/apimachinery/pkg/util/validation\"","\t\"knative.dev/pkg/apis\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/webhook/resourcesemantics\"",")","","var (","\treservedEnvVars = sets.NewString(","\t\t\"TLS_CERT\",","\t\t\"TLS_KEY\",","\t)",")","","var _ resourcesemantics.VerbLimited = (*EventListener)(nil)","","// SupportedVerbs returns the operations that validation should be called for","func (e *EventListener) SupportedVerbs() []admissionregistrationv1.OperationType {","\treturn []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}","}","","// Validate EventListener.","func (e *EventListener) Validate(ctx context.Context) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tvar errs *apis.FieldError","\tif len(e.ObjectMeta.Name) \u003e 60 {","\t\t// Since `el-` is added as the prefix of EventListener services, the name of EventListener must be no more than 60 characters long.","\t\terrs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf(\"eventListener name '%s' must be no more than 60 characters long\", e.ObjectMeta.Name), \"metadata.name\"))","\t}","","\tif len(e.ObjectMeta.Annotations) != 0 {","\t\terrs = errs.Also(triggers.ValidateAnnotations(e.ObjectMeta.Annotations))","\t}","","\treturn errs.Also(e.Spec.validate(ctx))","}","","func (s *EventListenerSpec) validate(ctx context.Context) (errs *apis.FieldError) {","\tif s.LabelSelector == nil \u0026\u0026 len(s.NamespaceSelector.MatchNames) == 0 \u0026\u0026 len(s.Triggers) == 0 {","\t\treturn apis.ErrMissingOneOf(\"spec.labelSelector\", \"spec.namespaceSelector\", \"spec.triggers\")","\t}","","\tfor i, trigger := range s.Triggers {","\t\terrs = errs.Also(trigger.validate(ctx).ViaField(fmt.Sprintf(\"spec.triggers[%d]\", i)))","\t}","","\t// Both Kubernetes and Custom resource can't be present at the same time","\tif s.Resources.KubernetesResource != nil \u0026\u0026 s.Resources.CustomResource != nil {","\t\treturn apis.ErrMultipleOneOf(\"spec.resources.kubernetesResource\", \"spec.resources.customResource\")","\t}","","\tif s.Resources.KubernetesResource != nil {","\t\terrs = errs.Also(validateKubernetesObject(s.Resources.KubernetesResource).ViaField(\"spec.resources.kubernetesResource\"))","\t}","","\tif s.Resources.CustomResource != nil {","\t\terrs = errs.Also(validateCustomObject(s.Resources.CustomResource).ViaField(\"spec.resources.customResource\"))","\t}","\treturn errs","}","","func validateCustomObject(customData *CustomResource) (errs *apis.FieldError) {","\torig := duckv1.WithPod{}","\tdecoder := json.NewDecoder(bytes.NewBuffer(customData.RawExtension.Raw))","","\tif err := decoder.Decode(\u0026orig); err != nil {","\t\terrs = errs.Also(apis.ErrInvalidValue(err, \"spec\"))","\t}","","\tif len(orig.Spec.Template.Spec.Containers) \u003e 1 {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"containers\").ViaField(\"spec.template.spec\"))","\t}","\terrs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec,","\t\t*podSpecMask(\u0026orig.Spec.Template.Spec)).ViaField(\"spec.template.spec\"))","","\t// bounded by condition because containers fields are optional so there is a chance that containers can be nil.","\tif len(orig.Spec.Template.Spec.Containers) == 1 {","\t\terrs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec.Containers[0],","\t\t\t*containerFieldMaskForCustomResource(\u0026orig.Spec.Template.Spec.Containers[0])).ViaField(\"spec.template.spec.containers[0]\"))","\t\t// validate env","\t\terrs = errs.Also(validateEnv(orig.Spec.Template.Spec.Containers[0].Env).ViaField(\"spec.template.spec.containers[0].env\"))","\t}","","\treturn errs","}","","func validateKubernetesObject(orig *KubernetesResource) (errs *apis.FieldError) {","\tif orig.Replicas != nil {","\t\tif *orig.Replicas \u003c 0 {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(*orig.Replicas, \"spec.replicas\"))","\t\t}","\t}","\tif len(orig.Template.Spec.Containers) \u003e 1 {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"containers\").ViaField(\"spec.template.spec\"))","\t}","\terrs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec,","\t\t*podSpecMask(\u0026orig.Template.Spec)).ViaField(\"spec.template.spec\"))","","\t// bounded by condition because containers fields are optional so there is a chance that containers can be nil.","\tif len(orig.Template.Spec.Containers) == 1 {","\t\terrs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec.Containers[0],","\t\t\t*containerFieldMaskForKubernetes(\u0026orig.Template.Spec.Containers[0])).ViaField(\"spec.template.spec.containers[0]\"))","\t\t// validate env","\t\terrs = errs.Also(validateEnv(orig.Template.Spec.Containers[0].Env).ViaField(\"spec.template.spec.containers[0].env\"))","\t}","","\treturn errs","}","","func validateEnv(envVars []corev1.EnvVar) (errs *apis.FieldError) {","\tvar (","\t\tcount    = 0","\t\tenvValue string","\t)","\tfor i, env := range envVars {","\t\terrs = errs.Also(validateEnvVar(env).ViaIndex(i))","\t\tif reservedEnvVars.Has(env.Name) {","\t\t\tcount++","\t\t\tenvValue = env.Name","\t\t}","\t}","\t// This is to make sure both TLS_CERT and TLS_KEY is set for tls connection","\tif count == 1 {","\t\terrs = errs.Also(\u0026apis.FieldError{","\t\t\tMessage: \"Expected env's are TLS_CERT and TLS_KEY, but got only one env \" + envValue,","\t\t})","\t}","\treturn errs","}","","func validateEnvVar(env corev1.EnvVar) (errs *apis.FieldError) {","\terrs = errs.Also(apis.CheckDisallowedFields(env, *envVarMask(\u0026env)))","","\treturn errs.Also(validateEnvValueFrom(env.ValueFrom).ViaField(\"valueFrom\"))","}","","func validateEnvValueFrom(source *corev1.EnvVarSource) *apis.FieldError {","\tif source == nil {","\t\treturn nil","\t}","\treturn apis.CheckDisallowedFields(*source, *envVarSourceMask(source))","}","","// envVarSourceMask performs a _shallow_ copy of the Kubernetes EnvVarSource object to a new","// Kubernetes EnvVarSource object bringing over only the fields allowed in the Triggers EventListener API.","func envVarSourceMask(in *corev1.EnvVarSource) *corev1.EnvVarSource {","\tif in == nil {","\t\treturn nil","\t}","\tout := new(corev1.EnvVarSource)","\t// Allowed fields","\tout.SecretKeyRef = in.SecretKeyRef","","\t// Disallowed fields","\tout.ConfigMapKeyRef = nil","\tout.FieldRef = nil","\tout.ResourceFieldRef = nil","","\treturn out","}","","// envVarMask performs a _shallow_ copy of the Kubernetes EnvVar object to a new","// Kubernetes EnvVar object bringing over only the fields allowed in the Triggers EventListener API.","func envVarMask(in *corev1.EnvVar) *corev1.EnvVar {","\tif in == nil {","\t\treturn nil","\t}","\tout := new(corev1.EnvVar)","\t// Allowed fields","\tout.Name = in.Name","\tout.ValueFrom = in.ValueFrom","","\t// Disallowed fields","\tout.Value = \"\"","","\treturn out","}","","func containerFieldMaskForKubernetes(in *corev1.Container) *corev1.Container {","\tout := new(corev1.Container)","\tout.Resources = in.Resources","\tout.Env = in.Env","\tout.LivenessProbe = in.LivenessProbe","\tout.ReadinessProbe = in.ReadinessProbe","\tout.StartupProbe = in.StartupProbe","\treturn containerFieldMask(out)","}","","func containerFieldMaskForCustomResource(in *corev1.Container) *corev1.Container {","\tout := new(corev1.Container)","\tout.Resources = in.Resources","\tout.Env = in.Env","\treturn containerFieldMask(out)","}","","func containerFieldMask(out *corev1.Container) *corev1.Container {","\t// Disallowed fields","\t// This list clarifies which all container attributes are not allowed.","\tout.Name = \"\"","\tout.Image = \"\"","\tout.Args = nil","\tout.Ports = nil","\tout.Command = nil","\tout.VolumeMounts = nil","\tout.ImagePullPolicy = \"\"","\tout.Lifecycle = nil","\tout.Stdin = false","\tout.StdinOnce = false","\tout.TerminationMessagePath = \"\"","\tout.TerminationMessagePolicy = \"\"","\tout.WorkingDir = \"\"","\tout.TTY = false","\tout.VolumeDevices = nil","\tout.EnvFrom = nil","","\treturn out","}","","// podSpecMask performs a _shallow_ copy of the Kubernetes PodSpec object to a new","// Kubernetes PodSpec object bringing over only the fields allowed in the Triggers EvenListener.","func podSpecMask(in *corev1.PodSpec) *corev1.PodSpec {","\tout := new(corev1.PodSpec)","","\t// Allowed fields","\tout.ServiceAccountName = in.ServiceAccountName","\tout.Containers = in.Containers","\tout.Tolerations = in.Tolerations","\tout.NodeSelector = in.NodeSelector","","\t// Disallowed fields","\t// This list clarifies which all podspec fields are not allowed.","\tout.Volumes = nil","\tout.EnableServiceLinks = nil","\tout.ImagePullSecrets = nil","\tout.InitContainers = nil","\tout.RestartPolicy = \"\"","\tout.TerminationGracePeriodSeconds = nil","\tout.ActiveDeadlineSeconds = nil","\tout.DNSPolicy = \"\"","\tout.AutomountServiceAccountToken = nil","\tout.NodeName = \"\"","\tout.HostNetwork = false","\tout.HostPID = false","\tout.HostIPC = false","\tout.ShareProcessNamespace = nil","\tout.SecurityContext = nil","\tout.Hostname = \"\"","\tout.Subdomain = \"\"","\tout.SchedulerName = \"\"","\tout.HostAliases = nil","\tout.PriorityClassName = \"\"","\tout.Priority = nil","\tout.DNSConfig = nil","\tout.ReadinessGates = nil","\tout.RuntimeClassName = nil","\tout.Affinity = nil","\tout.TopologySpreadConstraints = nil","","\treturn out","}","","func (t *EventListenerTrigger) validate(ctx context.Context) (errs *apis.FieldError) {","\tif t.Template == nil \u0026\u0026 t.TriggerRef == \"\" {","\t\terrs = errs.Also(apis.ErrMissingOneOf(\"template\", \"triggerRef\"))","\t}","","\tif t.TriggerRef != \"\" \u0026\u0026 (t.Template != nil || t.Bindings != nil || t.Interceptors != nil) {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"triggerRef\", \"template or bindings or interceptors\"))","\t}","","\t// Validate optional Bindings","\terrs = errs.Also(triggerSpecBindingArray(t.Bindings).validate(ctx))","\tif t.Template != nil {","\t\t// Validate required TriggerTemplate","\t\terrs = errs.Also(t.Template.validate(ctx))","\t}","","\t// Validate optional Interceptors","\tfor i, interceptor := range t.Interceptors {","\t\t// No continuation if provided interceptor is nil.","\t\tif interceptor == nil {","\t\t\treturn errs.Also(apis.ErrInvalidValue(fmt.Sprintf(\"interceptor '%v' must be a valid value\", interceptor), fmt.Sprintf(\"interceptors[%d]\", i)))","\t\t}","\t\terrs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf(\"interceptors[%d]\", i)))","\t}","","\t// The trigger name is added as a label value for 'tekton.dev/trigger' so it must follow the k8s label guidelines:","\t// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set","\tif err := validation.IsValidLabelValue(t.Name); len(err) \u003e 0 {","\t\terrs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf(\"trigger name '%s' must be a valid label value\", t.Name), \"name\"))","\t}","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,2,2,2,2,0,2,2,2,2,2,0,2,2,2,0,2,0,0,2,2,2,2,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,2,0,0,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,0,0,0,0,2,2,1,1,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,1,1,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,0,0,2,2,2,0,2,0]},{"id":15,"path":"pkg/apis/triggers/v1alpha1/interceptor_defaults.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"",")","","// SetDefaults sets the defaults on the object.","func (it *Interceptor) SetDefaults(ctx context.Context) {","\tif !contexts.IsUpgradeViaDefaulting(ctx) {","\t\treturn","\t}","\tif _, ok := it.GetLabels()[\"server/type\"]; !ok {","\t\t// if server type is not set its assumed that running server is http","\t\tit.Labels = map[string]string{","\t\t\t\"server/type\": \"http\",","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":16,"path":"pkg/apis/triggers/v1alpha1/interceptor_types.go","lines":["package v1alpha1","","import (","\t\"bytes\"","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"google.golang.org/grpc/codes\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// Check that Interceptor may be validated and defaulted.","var _ apis.Validatable = (*Interceptor)(nil)","var _ apis.Defaultable = (*Interceptor)(nil)","","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +k8s:openapi-gen=true","// Interceptor describes a pluggable interceptor including configuration","// such as the fields it accepts and its deployment address. The type is based on","// the Validating/MutatingWebhookConfiguration types for configuring AdmissionWebhooks","type Interceptor struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\tSpec InterceptorSpec `json:\"spec\"`","\t// +optional","\tStatus InterceptorStatus `json:\"status\"`","}","","// InterceptorSpec describes the Spec for an Interceptor","type InterceptorSpec struct {","\tClientConfig ClientConfig `json:\"clientConfig\"`","}","","// InterceptorStatus holds the status of the Interceptor","// +k8s:deepcopy-gen=true","type InterceptorStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// Interceptor is Addressable and exposes the URL where the Interceptor is running","\tduckv1.AddressStatus `json:\",inline\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// InterceptorList contains a list of Interceptor","// We don't use this but it's required for certain codegen features.","type InterceptorList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []Interceptor `json:\"items\"`","}","","// ResolveAddress returns the URL where the interceptor is running using its clientConfig","func (it *Interceptor) ResolveAddress() (*apis.URL, error) {","\tif url := it.Spec.ClientConfig.URL; url != nil {","\t\treturn url, nil","\t}","\tsvc := it.Spec.ClientConfig.Service","\tif svc == nil {","\t\treturn nil, ErrNilURL","\t}","\tvar (","\t\tport *int32","\t\turl  *apis.URL","\t)","","\tif svc.Port != nil {","\t\tport = svc.Port","\t}","","\tif bytes.Equal(it.Spec.ClientConfig.CaBundle, []byte{}) {","\t\tif port == nil {","\t\t\tport = \u0026defaultHTTPPort","\t\t}","\t\turl = formURL(\"http\", svc, port)","\t} else {","\t\tif port == nil {","\t\t\tport = \u0026defaultHTTPSPort","\t\t}","\t\turl = formURL(\"https\", svc, port)","\t}","\treturn url, nil","}","","type InterceptorInterface interface {","\t// Process executes the given InterceptorRequest. Simply getting a non-nil InterceptorResponse back is not sufficient","\t// to determine if the interceptor processing was successful. Instead use the InterceptorResponse.Status.Continue to","\t// see if processing should continue and InterceptorResponse.Status.Code to distinguish between the kinds of errors","\t// (i.e user errors vs system errors)","\tProcess(ctx context.Context, r *InterceptorRequest) *InterceptorResponse","}","","// Do not generate DeepCopy(). See #827","// +k8s:deepcopy-gen=false","type InterceptorRequest struct {","\t// Body is the incoming HTTP event body. We use a \"string\" representation of the JSON body","\t// in order to preserve the body exactly as it was sent (including spaces etc.). This is necessary","\t// for some interceptors e.g. GitHub for validating the body with a signature. While []byte can also","\t// store an exact representation of the body, `json.Marshal` will compact []byte to a base64 encoded","\t// string which means that we will lose the spaces any time we marshal this struct.","\tBody string `json:\"body,omitempty\"`","","\t// Header are the headers for the incoming HTTP event","\tHeader map[string][]string `json:\"header,omitempty\"`","","\t// Extensions are extra values that are added by previous interceptors in a chain","\tExtensions map[string]interface{} `json:\"extensions,omitempty\"`","","\t// InterceptorParams are the user specified params for interceptor in the Trigger","\tInterceptorParams map[string]interface{} `json:\"interceptor_params,omitempty\"`","","\t// Context contains additional metadata about the event being processed","\tContext *TriggerContext `json:\"context\"`","}","","type TriggerContext struct {","\t// EventURL is the URL of the incoming event","\tEventURL string `json:\"event_url,omitempty\"`","\t// EventID is a unique ID assigned by Triggers to each event","\tEventID string `json:\"event_id,omitempty\"`","\t// TriggerID is of the form namespace/$ns/triggers/$name","\tTriggerID string `json:\"trigger_id,omitempty\"`","}","","// Do not generate Deepcopy(). See #827","// +k8s:deepcopy-gen=false","type InterceptorResponse struct {","\t// Extensions are additional fields that is added to the interceptor event.","\tExtensions map[string]interface{} `json:\"extensions,omitempty\"`","\t// Continue indicates if the EventListener should continue processing the Trigger or not","\tContinue bool `json:\"continue\"` // Don't add omitempty -- it  will remove the continue field when the value is false.","\t// Status is an Error status containing details on any interceptor processing errors","\tStatus Status `json:\"status\"`","}","","type Status struct {","\t// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].","\tCode codes.Code `json:\"code,omitempty\"`","\t// A developer-facing error message, which should be in English.","\tMessage string `json:\"message,omitempty\"`","}","","func (s Status) Err() StatusError {","\treturn StatusError{s: s}","}","","type StatusError struct {","\ts Status","}","","func (s StatusError) Error() string {","\treturn fmt.Sprintf(\"rpc error: code = %s desc = %s\", s.s.Code, s.s.Message)","}","","func ParseTriggerID(triggerID string) (namespace, name string) {","\tsplits := strings.Split(triggerID, \"/\")","\tif len(splits) != 4 {","\t\treturn","\t}","","\treturn splits[1], splits[3]","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,2,2,2,2,2,0,2,0]},{"id":17,"path":"pkg/apis/triggers/v1alpha1/interceptor_validation.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"knative.dev/pkg/apis\"",")","","// Validate Interceptor","func (it *Interceptor) Validate(ctx context.Context) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","\treturn it.Spec.validate(ctx)","}","","// revive:disable:unused-parameter","","func (s *InterceptorSpec) validate(ctx context.Context) (errs *apis.FieldError) {","\tif s.ClientConfig.URL != nil \u0026\u0026 s.ClientConfig.Service != nil {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"spec.clientConfig.url\", \"spec.clientConfig.service\"))","\t}","\tif svc := s.ClientConfig.Service; svc != nil {","\t\tif svc.Namespace == \"\" {","\t\t\terrs = errs.Also(apis.ErrMissingField(\"spec.clientConfig.service.namespace\"))","\t\t}","\t\tif svc.Name == \"\" {","\t\t\terrs = errs.Also(apis.ErrMissingField(\"spec.clientConfig.service.name\"))","\t\t}","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,0]},{"id":18,"path":"pkg/apis/triggers/v1alpha1/register.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"github.com/tektoncd/triggers/pkg/apis/triggers\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","// SchemeGroupVersion is group version used to register these objects","var SchemeGroupVersion = schema.GroupVersion{Group: triggers.GroupName, Version: \"v1alpha1\"}","","// Kind takes an unqualified kind and returns back a Group qualified GroupKind","func Kind(kind string) schema.GroupKind {","\treturn SchemeGroupVersion.WithKind(kind).GroupKind()","}","","// Resource takes an unqualified resource and returns a Group qualified GroupResource","func Resource(resource string) schema.GroupResource {","\treturn SchemeGroupVersion.WithResource(resource).GroupResource()","}","","var (","\tschemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)","","\t// AddToScheme adds Build types to the scheme.","\tAddToScheme = schemeBuilder.AddToScheme",")","","// Adds the list of known types to Scheme.","func addKnownTypes(scheme *runtime.Scheme) error {","\tscheme.AddKnownTypes(SchemeGroupVersion,","\t\t\u0026ClusterInterceptor{},","\t\t\u0026ClusterInterceptorList{},","\t\t\u0026ClusterTriggerBinding{},","\t\t\u0026ClusterTriggerBindingList{},","\t\t\u0026EventListener{},","\t\t\u0026EventListenerList{},","\t\t\u0026Interceptor{},","\t\t\u0026InterceptorList{},","\t\t\u0026TriggerBinding{},","\t\t\u0026TriggerBindingList{},","\t\t\u0026TriggerTemplate{},","\t\t\u0026TriggerTemplateList{},","\t\t\u0026Trigger{},","\t\t\u0026TriggerList{},","\t)","\tmetav1.AddToGroupVersion(scheme, SchemeGroupVersion)","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]},{"id":19,"path":"pkg/apis/triggers/v1alpha1/trigger_binding_defaults.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"",")","","// revive:disable:unused-parameter","","// SetDefaults initializes TriggerBinding tb with its default values.","func (tb *TriggerBinding) SetDefaults(ctx context.Context) {}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":20,"path":"pkg/apis/triggers/v1alpha1/trigger_binding_types.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","// Check that TriggerBinding may be validated and defaulted.","var _ apis.Validatable = (*TriggerBinding)(nil)","var _ apis.Defaultable = (*TriggerBinding)(nil)","","func (tb *TriggerBinding) TriggerBindingSpec() TriggerBindingSpec {","\treturn tb.Spec","}","","func (tb *TriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta {","\treturn tb.ObjectMeta","}","","func (tb *TriggerBinding) Copy() TriggerBindingInterface {","\treturn tb.DeepCopy()","}","","// TriggerBindingSpec defines the desired state of the TriggerBinding.","type TriggerBindingSpec struct {","\t// Params defines the parameter mapping from the given input event.","\t// +listType=atomic","\tParams []Param `json:\"params,omitempty\"`","}","","// TriggerBindingStatus defines the observed state of TriggerBinding.","type TriggerBindingStatus struct{}","","// +genclient","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// TriggerBinding defines a mapping of an input event to parameters. This is used","// to extract information from events to be passed to TriggerTemplates within a","// Trigger.","// +k8s:openapi-gen=true","type TriggerBinding struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\t// Spec holds the desired state of the TriggerBinding","\t// +optional","\tSpec TriggerBindingSpec `json:\"spec\"`","\t// +optional","\tStatus TriggerBindingStatus `json:\"status,omitempty\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// TriggerBindingList contains a list of TriggerBindings.","// We don't use this but it's required for certain codegen features.","type TriggerBindingList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TriggerBinding `json:\"items\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":21,"path":"pkg/apis/triggers/v1alpha1/trigger_binding_validation.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\t\"k8s.io/apimachinery/pkg/api/equality\"","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"knative.dev/pkg/apis\"",")","","// Validate TriggerBinding.","func (tb *TriggerBinding) Validate(ctx context.Context) (errs *apis.FieldError) {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\terrs = validate.ObjectMetadata(tb.GetObjectMeta()).ViaField(\"metadata\")","\treturn errs.Also(tb.Spec.Validate(ctx).ViaField(\"spec\"))","}","","// revive:disable:unused-parameter","","// Validate TriggerBindingSpec.","func (s *TriggerBindingSpec) Validate(ctx context.Context) (errs *apis.FieldError) {","\tif equality.Semantic.DeepEqual(s, \u0026TriggerBindingSpec{}) {","\t\treturn errs.Also(apis.ErrMissingField(apis.CurrentField))","\t}","\treturn errs.Also(validateParams(s.Params).ViaField(\"params\"))","}","","func validateParams(params []Param) *apis.FieldError {","\t// Ensure there aren't multiple params with the same name.","\tseen := sets.NewString()","\tfor i, param := range params {","\t\tif seen.Has(param.Name) {","\t\t\treturn apis.ErrMultipleOneOf(fmt.Sprintf(\"[%d].name\", i))","\t\t}","\t\tseen.Insert(param.Name)","\t\terrs := validateParamValue(param.Value).ViaField(fmt.Sprintf(\"[%d]\", i))","\t\tif errs != nil {","\t\t\treturn errs","\t\t}","\t}","\treturn nil","}","","func validateParamValue(in string) *apis.FieldError {","\tif !strings.Contains(in, \"$(\") {","\t\treturn nil","\t}","\t// Splits string on $( to find potential Tekton expressions","\tmaybeExpressions := strings.Split(in, \"$(\")","\tterminated := true","\tfor _, e := range maybeExpressions[1:] { // Split always returns at least one element","\t\t// Iterate until we find the first unbalanced )","\t\tnumOpenBrackets := 0","\t\tif !terminated {","\t\t\treturn apis.ErrInvalidValue(in, \"value\")","\t\t}","\t\tterminated = false","\t\tfor _, ch := range e {","\t\t\tswitch ch {","\t\t\tcase '(':","\t\t\t\tnumOpenBrackets++","\t\t\tcase ')':","\t\t\t\tnumOpenBrackets--","\t\t\t\tif numOpenBrackets \u003c 0 {","\t\t\t\t\tterminated = true","\t\t\t\t}","\t\t\tdefault:","\t\t\t\tcontinue","\t\t\t}","\t\t\tif numOpenBrackets \u003c 0 {","\t\t\t\tterminated = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,2,0,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,0,0,2,0]},{"id":22,"path":"pkg/apis/triggers/v1alpha1/trigger_defaults.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"","\t\"knative.dev/pkg/logging\"",")","","type triggerSpecBindingArray []*TriggerSpecBinding","","// SetDefaults sets the defaults on the object.","func (t *Trigger) SetDefaults(ctx context.Context) {","\tif !contexts.IsUpgradeViaDefaulting(ctx) {","\t\treturn","\t}","\ttriggerSpecBindingArray(t.Spec.Bindings).defaultBindings()","\tfor _, ti := range t.Spec.Interceptors {","\t\tti.defaultInterceptorKind()","\t\tif err := ti.updateCoreInterceptors(); err != nil {","\t\t\t// The err only happens due to malformed JSON and should never really happen","\t\t\t// We can't return an error here, so print out the error","\t\t\tlogger := logging.FromContext(ctx)","\t\t\tlogger.Errorf(\"failed to setDefaults for trigger: %s; err: %s\", t.Name, err)","\t\t}","\t}","}","","// set default TriggerBinding kind for Bindings in TriggerSpec","func (t triggerSpecBindingArray) defaultBindings() {","\tif len(t) \u003e 0 {","\t\tfor _, b := range t {","\t\t\tif b.Kind == \"\" {","\t\t\t\tb.Kind = NamespacedTriggerBindingKind","\t\t\t}","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,1,1,1,0,0,0,0,2,2,2,2,2,2,0,0,0]},{"id":23,"path":"pkg/apis/triggers/v1alpha1/trigger_template_defaults.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"",")","","// revive:disable:unused-parameter","","// SetDefaults initializes TriggerTemplate with default values.","func (tt *TriggerTemplate) SetDefaults(ctx context.Context) {}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":24,"path":"pkg/apis/triggers/v1alpha1/trigger_template_validation.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"fmt\"","\t\"regexp\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\t\"k8s.io/apimachinery/pkg/api/equality\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"knative.dev/pkg/apis\"",")","","// paramsRegexp captures TriggerTemplate parameter names $(tt.params.NAME)","var paramsRegexp = regexp.MustCompile(`\\$\\(tt.params.(?P\u003cvar\u003e[_a-zA-Z][_a-zA-Z0-9.-]*)\\)`)","","// revive:disable:unused-parameter","","// Validate validates a TriggerTemplate.","func (t *TriggerTemplate) Validate(ctx context.Context) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\terrs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField(\"metadata\")","\treturn errs.Also(t.Spec.validate(ctx).ViaField(\"spec\"))","}","","// Validate validates a TriggerTemplateSpec.","func (s *TriggerTemplateSpec) validate(ctx context.Context) (errs *apis.FieldError) {","\tif equality.Semantic.DeepEqual(s, \u0026TriggerTemplateSpec{}) {","\t\terrs = errs.Also(apis.ErrMissingField(apis.CurrentField))","\t}","\tif len(s.ResourceTemplates) == 0 {","\t\terrs = errs.Also(apis.ErrMissingField(\"resourcetemplates\"))","\t}","\terrs = errs.Also(validateResourceTemplates(s.ResourceTemplates).ViaField(\"resourcetemplates\"))","\terrs = errs.Also(verifyParamDeclarations(s.Params, s.ResourceTemplates).ViaField(\"resourcetemplates\"))","\treturn errs","}","","func validateResourceTemplates(templates []TriggerResourceTemplate) (errs *apis.FieldError) {","\tfor i, trt := range templates {","\t\tdata := new(unstructured.Unstructured)","\t\tif err := data.UnmarshalJSON(trt.Raw); err != nil {","\t\t\t// a missing kind makes the unmarshalling throw an error","\t\t\terrs = errs.Also(apis.ErrMissingField(fmt.Sprintf(\"[%d].kind\", i)))","\t\t}","","\t\tif data.GetAPIVersion() == \"\" {","\t\t\terrs = errs.Also(apis.ErrMissingField(fmt.Sprintf(\"[%d].apiVersion\", i)))","\t\t}","\t}","\treturn errs","}","","// Verify every param in the ResourceTemplates is declared with a ParamSpec","func verifyParamDeclarations(params []ParamSpec, templates []TriggerResourceTemplate) *apis.FieldError {","\tdeclaredParamNames := sets.NewString()","\tfor _, param := range params {","\t\tdeclaredParamNames.Insert(param.Name)","\t}","\tfor i, template := range templates {","\t\t// Get all params in the template $(tt.params.NAME)","\t\ttemplateParams := paramsRegexp.FindAllSubmatch(template.RawExtension.Raw, -1)","\t\tfor _, templateParam := range templateParams {","\t\t\ttemplateParamName := string(templateParam[1])","\t\t\tif !declaredParamNames.Has(templateParamName) {","\t\t\t\tfieldErr := apis.ErrInvalidValue(","\t\t\t\t\tfmt.Sprintf(\"undeclared param '$(tt.params.%s)'\", templateParamName),","\t\t\t\t\tfmt.Sprintf(\"[%d]\", i),","\t\t\t\t)","\t\t\t\tfieldErr.Details = fmt.Sprintf(\"'$(tt.params.%s)' must be declared in spec.params\", templateParamName)","\t\t\t\treturn fieldErr","\t\t\t}","\t\t}","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,0]},{"id":25,"path":"pkg/apis/triggers/v1alpha1/trigger_types.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"encoding/json\"","\t\"fmt\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tapiextensionsv1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","// TriggerSpec represents a connection between TriggerSpecBinding,","// and TriggerSpecTemplate; TriggerSpecBinding provides extracted values for","// TriggerSpecTemplate to then create resources from.","type TriggerSpec struct {","\t// +listType=atomic","\tBindings []*TriggerSpecBinding `json:\"bindings\"`","\tTemplate TriggerSpecTemplate   `json:\"template\"`","\t// +optional","\tName string `json:\"name,omitempty\"`","\t// +listType=atomic","\tInterceptors []*TriggerInterceptor `json:\"interceptors,omitempty\"`","\t// ServiceAccountName optionally associates credentials with each trigger;","\t// Unlike EventListeners, this should be scoped to the same namespace","\t// as the Trigger itself","\t// +optional","\tServiceAccountName string `json:\"serviceAccountName,omitempty\"`","}","","type TriggerSpecTemplate struct {","\tRef        *string              `json:\"ref,omitempty\"`","\tAPIVersion string               `json:\"apiversion,omitempty\"`","\tSpec       *TriggerTemplateSpec `json:\"spec,omitempty\"`","}","","type TriggerSpecBinding struct {","\t// Name is the name of the binding param","\t// Mutually exclusive with Ref","\tName string `json:\"name,omitempty\"`","\t// Value is the value of the binding param. Can contain JSONPath","\t// Has to be pointer since \"\" is a valid value","\t// Required if Name is also specified.","\tValue *string `json:\"value,omitempty\"`","","\t// Ref is a reference to a TriggerBinding kind.","\t// Mutually exclusive with Name","\tRef string `json:\"ref,omitempty\"`","","\t// Kind can only be provided if Ref is also provided. Defaults to TriggerBinding","\tKind TriggerBindingKind `json:\"kind,omitempty\"`","","\t// APIVersion of the binding ref","\tAPIVersion string `json:\"apiversion,omitempty\"`","}","","// +genclient","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// Trigger defines a mapping of an input event to parameters. This is used","// to extract information from events to be passed to TriggerTemplates within a","// Trigger.","// +k8s:openapi-gen=true","type Trigger struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\t// Spec holds the desired state of the Trigger","\t// +optional","\tSpec TriggerSpec `json:\"spec\"`","}","","// TriggerInterceptor provides a hook to intercept and pre-process events","type TriggerInterceptor struct {","\t// Optional name to identify the current interceptor configuration","\tName *string `json:\"name,omitempty\"`","\t// Ref refers to the Interceptor to use","\tRef InterceptorRef `json:\"ref\"`","\t// Params are the params to send to the interceptor","\t// +listType=atomic","\tParams []InterceptorParams `json:\"params,omitempty\"`","","\t// WebhookInterceptor refers to an old style webhook interceptor service","\tWebhook *WebhookInterceptor `json:\"webhook,omitempty\"`","","\t// Deprecated old fields below","\tDeprecatedGitHub    *GitHubInterceptor    `json:\"github,omitempty\"`","\tDeprecatedGitLab    *GitLabInterceptor    `json:\"gitlab,omitempty\"`","\tDeprecatedCEL       *CELInterceptor       `json:\"cel,omitempty\"`","\tDeprecatedBitbucket *BitbucketInterceptor `json:\"bitbucket,omitempty\"`","}","","// InterceptorParams defines a key-value pair that can be passed on an interceptor","type InterceptorParams struct {","\tName  string               `json:\"name\"`","\tValue apiextensionsv1.JSON `json:\"value\"`","}","","// InterceptorRef provides a Reference to a ClusterInterceptor","type InterceptorRef struct {","\t// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names","\tName string `json:\"name,omitempty\"`","\t// InterceptorKind indicates the kind of the Interceptor, namespaced or cluster scoped.","\t// +optional","\tKind InterceptorKind `json:\"kind,omitempty\"`","\t// API version of the referent","\t// +optional","\tAPIVersion string `json:\"apiVersion,omitempty\"`","}","","// InterceptorKind defines the type of Interceptor used by the Trigger.","type InterceptorKind string","","const (","\t// ClusterInterceptorKind indicates that Interceptor type has a cluster scope.","\tClusterInterceptorKind InterceptorKind = \"ClusterInterceptor\"","\t// NamespacedInterceptorKind indicated that interceptor has a namespaced scope","\tNamespacedInterceptorKind InterceptorKind = \"NamespacedInterceptor\"",")","","func (ti *TriggerInterceptor) defaultInterceptorKind() {","\tif ti.Ref.Kind == \"\" {","\t\tti.Ref.Kind = ClusterInterceptorKind","\t}","}","","func (ti *TriggerInterceptor) updateCoreInterceptors() error {","\tif ti == nil {","\t\treturn nil","\t}","\tif ti.Ref.Name != \"\" {","\t\treturn nil","\t}","\tti.Ref.Name = ti.GetName()","\tti.Params = []InterceptorParams{}","\tswitch ti.Ref.Name {","\tcase \"bitbucket\":","\t\tif err := addToParams(\u0026ti.Params, \"secretRef\", ti.DeprecatedBitbucket.SecretRef); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := addToParams(\u0026ti.Params, \"eventTypes\", ti.DeprecatedBitbucket.EventTypes); err != nil {","\t\t\treturn err","\t\t}","\t\tti.DeprecatedBitbucket = nil","\tcase \"gitlab\":","\t\tif err := addToParams(\u0026ti.Params, \"secretRef\", ti.DeprecatedGitLab.SecretRef); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := addToParams(\u0026ti.Params, \"eventTypes\", ti.DeprecatedGitLab.EventTypes); err != nil {","\t\t\treturn err","\t\t}","\t\tti.DeprecatedGitLab = nil","\tcase \"github\":","\t\tif err := addToParams(\u0026ti.Params, \"secretRef\", ti.DeprecatedGitHub.SecretRef); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := addToParams(\u0026ti.Params, \"eventTypes\", ti.DeprecatedGitHub.EventTypes); err != nil {","\t\t\treturn err","\t\t}","\t\tti.DeprecatedGitHub = nil","\tcase \"cel\":","\t\tif err := addToParams(\u0026ti.Params, \"filter\", ti.DeprecatedCEL.Filter); err != nil {","\t\t\treturn err","\t\t}","\t\tif err := addToParams(\u0026ti.Params, \"overlays\", ti.DeprecatedCEL.Overlays); err != nil {","\t\t\treturn err","\t\t}","\t\tti.DeprecatedCEL = nil","\t}","\treturn nil","}","","func addToParams(params *[]InterceptorParams, name string, val interface{}) error {","\tif val == nil {","\t\treturn nil","\t}","\tv, err := toV1JSON(val)","\tif err != nil {","\t\treturn err","\t}","\t*params = append(*params, InterceptorParams{","\t\tName:  name,","\t\tValue: v,","\t})","\treturn nil","}","","func toV1JSON(v interface{}) (apiextensionsv1.JSON, error) {","\tb, err := json.Marshal(v)","\tif err != nil {","\t\treturn apiextensionsv1.JSON{}, fmt.Errorf(\"json.Marshal() failed: %w\", err)","\t}","\treturn apiextensionsv1.JSON{","\t\tRaw: b,","\t}, nil","}","","// GetName returns the name for the given interceptor","func (ti *TriggerInterceptor) GetName() string {","\t// This is temporary until we implement #869","\tname := \"\"","\tswitch {","\tcase ti.Ref.Name != \"\":","\t\tname = ti.Ref.Name","\tcase ti.DeprecatedBitbucket != nil:","\t\tname = \"bitbucket\"","\tcase ti.DeprecatedCEL != nil:","\t\tname = \"cel\"","\tcase ti.DeprecatedGitHub != nil:","\t\tname = \"github\"","\tcase ti.DeprecatedGitLab != nil:","\t\tname = \"gitlab\"","\t}","\treturn name","}","","// WebhookInterceptor provides a webhook to intercept and pre-process events","type WebhookInterceptor struct {","\t// ObjectRef is a reference to an object that will resolve to a cluster DNS","\t// name to use as the EventInterceptor. Either objectRef or url can be specified","\t// +optional","\tObjectRef *corev1.ObjectReference `json:\"objectRef,omitempty\"`","\t// +optional","\tURL *apis.URL `json:\"url,omitempty\"`","\t// Header is a group of key-value pairs that can be appended to the","\t// interceptor request headers. This allows the interceptor to make","\t// decisions specific to an EventListenerTrigger.","\t// +listType=atomic","\tHeader []v1beta1.Param `json:\"header,omitempty\"`","}","","// BitbucketInterceptor provides a webhook to intercept and pre-process events","type BitbucketInterceptor struct {","\tSecretRef *SecretRef `json:\"secretRef,omitempty\"`","\t// +listType=atomic","\tEventTypes []string `json:\"eventTypes,omitempty\"`","}","","// GitHubInterceptor provides a webhook to intercept and pre-process events","type GitHubInterceptor struct {","\tSecretRef *SecretRef `json:\"secretRef,omitempty\"`","\t// +listType=atomic","\tEventTypes []string `json:\"eventTypes,omitempty\"`","}","","// GitLabInterceptor provides a webhook to intercept and pre-process events","type GitLabInterceptor struct {","\tSecretRef *SecretRef `json:\"secretRef,omitempty\"`","\t// +listType=atomic","\tEventTypes []string `json:\"eventTypes,omitempty\"`","}","","// CELInterceptor provides a webhook to intercept and pre-process events","type CELInterceptor struct {","\tFilter string `json:\"filter,omitempty\"`","\t// +listType=atomic","\tOverlays []CELOverlay `json:\"overlays,omitempty\"`","}","","// CELOverlay provides a way to modify the request body using DeprecatedCEL expressions","type CELOverlay struct {","\tKey        string `json:\"key,omitempty\"`","\tExpression string `json:\"expression,omitempty\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// TriggerList contains a list of Triggers.","// We don't use this but it's required for certain codegen features.","type TriggerList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []Trigger `json:\"items\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,2,2,2,1,1,2,1,1,2,2,2,1,1,2,1,1,2,2,2,1,1,2,1,1,2,0,2,0,0,2,2,1,1,2,2,1,1,2,2,2,2,2,0,0,2,2,2,1,1,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":26,"path":"pkg/apis/triggers/v1alpha1/trigger_types_convert.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"encoding/json\"",")","","// ToEventListenerTrigger converts a TriggerSpec into an EventListenerTrigger.","// This is primarily for compatibility between CRD and non-CRD types so that","// underlying libraries can reuse existing code.","func ToEventListenerTrigger(in TriggerSpec) (EventListenerTrigger, error) {","\tvar out EventListenerTrigger","","\t// Use json Marshalling in order to be field agnostic. Since TriggerSpec","\t// is a subset of the existing EventListenerTrigger type, and should always","\t// contain the same field labels, this should be safe to do.","\tb, err := json.Marshal(in)","\tif err != nil {","\t\treturn out, err","\t}","","\tif err := json.Unmarshal(b, \u0026out); err != nil {","\t\treturn out, err","\t}","\treturn out, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,0,2,1,1,2,0]},{"id":27,"path":"pkg/apis/triggers/v1alpha1/trigger_validation.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1alpha1","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","\t\"net/http\"","","\t\"github.com/google/cel-go/cel\"","\tpipelinev1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\t\"knative.dev/pkg/apis\"",")","","// Validate validates a Trigger","func (t *Trigger) Validate(ctx context.Context) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\terrs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField(\"metadata\")","\treturn errs.Also(t.Spec.validate(ctx).ViaField(\"spec\"))","}","","func (t *TriggerSpec) validate(ctx context.Context) *apis.FieldError {","\t// Validate optional Bindings","\terrs := triggerSpecBindingArray(t.Bindings).validate(ctx)","\t// Validate required TriggerTemplate","\terrs = errs.Also(t.Template.validate(ctx))","","\t// Validate optional Interceptors","\tfor i, interceptor := range t.Interceptors {","\t\terrs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf(\"interceptors[%d]\", i)))","\t}","","\treturn errs","}","","// revive:disable:unused-parameter","","func (t TriggerSpecTemplate) validate(ctx context.Context) (errs *apis.FieldError) {","\t// Optional explicit match","\tif t.APIVersion != \"\" {","\t\tif t.APIVersion != \"v1alpha1\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid apiVersion\"), \"template.apiVersion\"))","\t\t}","\t}","","\tswitch {","\tcase t.Spec != nil \u0026\u0026 t.Ref != nil:","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"template.spec\", \"template.ref\"))","\tcase t.Spec == nil \u0026\u0026 t.Ref == nil:","\t\terrs = errs.Also(apis.ErrMissingOneOf(\"template.spec\", \"template.ref\"))","\tcase t.Spec != nil:","\t\terrs = errs.Also(t.Spec.validate(ctx))","\tcase t.Ref == nil || *t.Ref == \"\":","\t\terrs = errs.Also(apis.ErrMissingField(\"template.ref\"))","\t}","\treturn errs","}","","func (t triggerSpecBindingArray) validate(ctx context.Context) (errs *apis.FieldError) {","\tfor i, b := range t {","\t\tswitch {","\t\tcase b.Ref != \"\":","\t\t\tswitch {","\t\t\tcase b.Name != \"\": // Cannot specify both Ref and Name","\t\t\t\terrs = errs.Also(apis.ErrMultipleOneOf(fmt.Sprintf(\"bindings[%d].Ref\", i), fmt.Sprintf(\"bindings[%d].Name\", i)))","\t\t\tcase b.Kind != NamespacedTriggerBindingKind \u0026\u0026 b.Kind != ClusterTriggerBindingKind: // Kind must be valid","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid kind\"), fmt.Sprintf(\"bindings[%d].kind\", i)))","\t\t\t}","\t\tcase b.Name != \"\":","\t\t\tif b.Value == nil { // Value is mandatory if Name is specified","\t\t\t\terrs = errs.Also(apis.ErrMissingField(fmt.Sprintf(\"bindings[%d].Value\", i)))","\t\t\t}","\t\tdefault:","\t\t\terrs = errs.Also(apis.ErrMissingOneOf(fmt.Sprintf(\"bindings[%d].Ref\", i), fmt.Sprintf(\"bindings[%d].Spec\", i), fmt.Sprintf(\"bindings[%d].Name\", i)))","\t\t}","\t}","\treturn errs","}","","func (i *TriggerInterceptor) validate(ctx context.Context) (errs *apis.FieldError) {","\tif i.Webhook == nil \u0026\u0026 i.DeprecatedGitHub == nil \u0026\u0026 i.DeprecatedGitLab == nil \u0026\u0026 i.DeprecatedCEL == nil \u0026\u0026 i.DeprecatedBitbucket == nil {","\t\tif i.Ref.Name == \"\" { // Check to see if Interceptor referenced using Ref","\t\t\terrs = errs.Also(apis.ErrMissingField(\"interceptor\"))","\t\t}","\t}","","\t// Enforce oneof","\tnumSet := 0","\tif i.Webhook != nil {","\t\tnumSet++","\t}","\tif i.DeprecatedGitHub != nil {","\t\tnumSet++","\t}","\tif i.DeprecatedGitLab != nil {","\t\tnumSet++","\t}","\tif i.DeprecatedBitbucket != nil {","\t\tnumSet++","\t}","","\tif numSet \u003e 1 {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"interceptor.webhook\", \"interceptor.github\", \"interceptor.gitlab\"))","\t}","","\tif i.Webhook != nil {","\t\tif i.Webhook.ObjectRef == nil || i.Webhook.ObjectRef.Name == \"\" {","\t\t\terrs = errs.Also(apis.ErrMissingField(\"interceptor.webhook.objectRef\"))","\t\t}","\t\tw := i.Webhook","\t\tif w.ObjectRef.Kind != \"Service\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid kind\"), \"interceptor.webhook.objectRef.kind\"))","\t\t}","","\t\t// Optional explicit match","\t\tif w.ObjectRef.APIVersion != \"v1\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid apiVersion\"), \"interceptor.webhook.objectRef.apiVersion\"))","\t\t}","","\t\tfor i, header := range w.Header {","\t\t\t// Enforce non-empty canonical header keys","\t\t\tif len(header.Name) == 0 || http.CanonicalHeaderKey(header.Name) != header.Name {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid header name\"), fmt.Sprintf(\"interceptor.webhook.header[%d].name\", i)))","\t\t\t}","\t\t\t// Enforce non-empty header values","\t\t\tif header.Value.Type == pipelinev1.ParamTypeString {","\t\t\t\tif len(header.Value.StringVal) == 0 {","\t\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid header value\"), fmt.Sprintf(\"interceptor.webhook.header[%d].value\", i)))","\t\t\t\t}","\t\t\t} else if len(header.Value.ArrayVal) == 0 {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid header value\"), fmt.Sprintf(\"interceptor.webhook.header[%d].value\", i)))","\t\t\t}","\t\t}","\t}","","\tif i.DeprecatedCEL != nil {","\t\tif i.DeprecatedCEL.Filter == \"\" \u0026\u0026 len(i.DeprecatedCEL.Overlays) == 0 {","\t\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"cel.filter\", \"cel.overlays\"))","\t\t}","\t\tenv, err := cel.NewEnv()","\t\tif err != nil {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(fmt.Errorf(\"failed to create a DeprecatedCEL env: %w\", err), \"cel.filter\"))","\t\t}","\t\tif i.DeprecatedCEL.Filter != \"\" {","\t\t\tif _, issues := env.Parse(i.DeprecatedCEL.Filter); issues != nil \u0026\u0026 issues.Err() != nil {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(fmt.Errorf(\"failed to parse the DeprecatedCEL filter: %w\", issues.Err()), \"cel.filter\"))","\t\t\t}","\t\t}","\t\tfor _, v := range i.DeprecatedCEL.Overlays {","\t\t\tif _, issues := env.Parse(v.Expression); issues != nil \u0026\u0026 issues.Err() != nil {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(fmt.Errorf(\"failed to parse the DeprecatedCEL overlay: %w\", issues.Err()), \"cel.overlay\"))","\t\t\t}","\t\t}","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,2,0,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,2,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,2,2,0,2,2,2,2,1,1,1,0,0,0,2,2,2,2,2,2,1,1,2,2,1,1,0,2,2,2,2,0,0,2,0]},{"id":28,"path":"pkg/apis/triggers/v1beta1/cluster_trigger_binding_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"",")","","// revive:disable:unused-parameter","","// SetDefaults initializes ClusterTriggerBinding ctb with its default values.","func (ctb *ClusterTriggerBinding) SetDefaults(ctx context.Context) {}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":29,"path":"pkg/apis/triggers/v1beta1/cluster_trigger_binding_types.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","// Check that ClusterTriggerBinding may be validated and defaulted.","var _ apis.Validatable = (*ClusterTriggerBinding)(nil)","var _ apis.Defaultable = (*ClusterTriggerBinding)(nil)","","// +genclient","// +genclient:nonNamespaced","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","// +k8s:openapi-gen=true","","// ClusterTriggerBinding is a TriggerBinding with a cluster scope.","// ClusterTriggerBindings are used to represent TriggerBindings that","// should be publicly addressable from any namespace in the cluster.","type ClusterTriggerBinding struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","","\t// Spec holds the desired state of the ClusterTriggerBinding from the client","\t// +optional","\tSpec TriggerBindingSpec `json:\"spec,omitempty\"`","","\t// +optional","\tStatus TriggerBindingStatus `json:\"status,omitempty\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// ClusterTriggerBindingList contains a list of ClusterTriggerBinding","type ClusterTriggerBindingList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []ClusterTriggerBinding `json:\"items\"`","}","","func (ctb *ClusterTriggerBinding) TriggerBindingSpec() TriggerBindingSpec {","\treturn ctb.Spec","}","","func (ctb *ClusterTriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta {","\treturn ctb.ObjectMeta","}","","func (ctb *ClusterTriggerBinding) Copy() TriggerBindingInterface {","\treturn ctb.DeepCopy()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1]},{"id":30,"path":"pkg/apis/triggers/v1beta1/cluster_trigger_binding_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/webhook/resourcesemantics\"",")","","var _ resourcesemantics.VerbLimited = (*ClusterTriggerBinding)(nil)","","// SupportedVerbs returns the operations that validation should be called for","func (ctb *ClusterTriggerBinding) SupportedVerbs() []admissionregistrationv1.OperationType {","\treturn []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}","}","","func (ctb *ClusterTriggerBinding) Validate(ctx context.Context) *apis.FieldError {","\tif err := validate.ObjectMetadata(ctb.GetObjectMeta()); err != nil {","\t\treturn err.ViaField(\"metadata\")","\t}","\treturn ctb.Spec.Validate(ctx)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,1,1,2,0]},{"id":31,"path":"pkg/apis/triggers/v1beta1/event_listener_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"",")","","// SetDefaults sets the defaults on the object.","func (el *EventListener) SetDefaults(ctx context.Context) {","\tcfg := config.FromContextOrDefaults(ctx)","\tif contexts.IsUpgradeViaDefaulting(ctx) {","\t\tdefaultSA := cfg.Defaults.DefaultServiceAccount","\t\t// set defaults","\t\tif el.Spec.ServiceAccountName == \"\" \u0026\u0026 defaultSA != \"\" {","\t\t\tel.Spec.ServiceAccountName = defaultSA","\t\t}","","\t\tif el.Spec.Resources.KubernetesResource != nil {","\t\t\tif el.Spec.Resources.KubernetesResource.Replicas != nil \u0026\u0026 *el.Spec.Resources.KubernetesResource.Replicas == 0 {","\t\t\t\t*el.Spec.Resources.KubernetesResource.Replicas = 1","\t\t\t}","\t\t}","","\t\tfor i, t := range el.Spec.Triggers {","\t\t\ttriggerSpecBindingArray(el.Spec.Triggers[i].Bindings).defaultBindings()","\t\t\tfor _, ti := range t.Interceptors {","\t\t\t\tif ti != nil {","\t\t\t\t\tti.defaultInterceptorKind()","\t\t\t\t}","\t\t\t}","\t\t}","","\t\tfor _, tg := range el.Spec.TriggerGroups {","\t\t\tfor _, ti := range tg.Interceptors {","\t\t\t\tif ti != nil {","\t\t\t\t\tti.defaultInterceptorKind()","\t\t\t\t}","\t\t\t}","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,2,2,2,2,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,0,0,0]},{"id":32,"path":"pkg/apis/triggers/v1beta1/event_listener_types.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"fmt\"","","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"knative.dev/pkg/apis\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/apis/duck/v1beta1\"","\t\"knative.dev/pkg/kmeta\"",")","","// Check that EventListener may be validated and defaulted.","var _ apis.Validatable = (*EventListener)(nil)","var _ apis.Defaultable = (*EventListener)(nil)","","// +genclient","// +genreconciler:krshapedlogic=false","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// EventListener exposes a service to accept HTTP event payloads.","//","// +k8s:openapi-gen=true","type EventListener struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\t// Spec holds the desired state of the EventListener from the client","\t// +optional","\tSpec EventListenerSpec `json:\"spec\"`","\t// +optional","\tStatus EventListenerStatus `json:\"status,omitempty\"`","}","","var _ kmeta.OwnerRefable = (*EventListener)(nil)","","// EventListenerSpec defines the desired state of the EventListener, represented","// by a list of Triggers.","type EventListenerSpec struct {","\tServiceAccountName string `json:\"serviceAccountName,omitempty\"`","\t// +listType=atomic","\tTriggers []EventListenerTrigger `json:\"triggers,omitempty\"`","\t// Trigger groups allow for centralized processing of an interceptor chain","\t// +listType=atomic","\tTriggerGroups     []EventListenerTriggerGroup `json:\"triggerGroups,omitempty\"`","\tNamespaceSelector NamespaceSelector           `json:\"namespaceSelector,omitempty\"`","\tLabelSelector     *metav1.LabelSelector       `json:\"labelSelector,omitempty\"`","\tResources         Resources                   `json:\"resources,omitempty\"`","\tCloudEventURI     string                      `json:\"cloudEventURI,omitempty\"`","}","","type Resources struct {","\tKubernetesResource *KubernetesResource `json:\"kubernetesResource,omitempty\"`","\tCustomResource     *CustomResource     `json:\"customResource,omitempty\"`","}","","type CustomResource struct {","\truntime.RawExtension `json:\",inline\"`","}","","type KubernetesResource struct {","\tReplicas                 *int32             `json:\"replicas,omitempty\"`","\tServiceType              corev1.ServiceType `json:\"serviceType,omitempty\"`","\tServicePort              *int32             `json:\"servicePort,omitempty\"`","\tServiceLoadBalancerClass *string            `json:\"serviceLoadBalancerClass,omitempty\"`","\tduckv1.WithPodSpec       `json:\"spec,omitempty\"`","}","","// EventListenerTrigger represents a connection between TriggerBinding, Params,","// and TriggerTemplate; TriggerBinding provides extracted values for","// TriggerTemplate to then create resources from. TriggerRef can also be","// provided instead of TriggerBinding, Interceptors and TriggerTemplate","type EventListenerTrigger struct {","\t// +listType=atomic","\tBindings   []*EventListenerBinding `json:\"bindings,omitempty\"`","\tTemplate   *EventListenerTemplate  `json:\"template,omitempty\"`","\tTriggerRef string                  `json:\"triggerRef,omitempty\"`","\t// +optional","\tName string `json:\"name,omitempty\"`","\t// +listType=atomic","\tInterceptors []*EventInterceptor `json:\"interceptors,omitempty\"`","\t// ServiceAccountName optionally associates credentials with each trigger;","\t// more granular authorization for","\t// who is allowed to utilize the associated pipeline","\t// vs. defaulting to whatever permissions are associated","\t// with the entire EventListener and associated sink facilitates","\t// multi-tenant model based scenarios","\t// +optional","\tServiceAccountName string `json:\"serviceAccountName,omitempty\"`","}","","// EventListenerTriggerGroup defines a group of Triggers that share a common set of interceptors","type EventListenerTriggerGroup struct {","\tName string `json:\"name\"`","\t// +listType=atomic","\tInterceptors    []*TriggerInterceptor        `json:\"interceptors\"`","\tTriggerSelector EventListenerTriggerSelector `json:\"triggerSelector\"`","}","","// EventListenerTriggerSelector  defines ways to select a group of triggers using their metadata","type EventListenerTriggerSelector struct {","\tNamespaceSelector NamespaceSelector     `json:\"namespaceSelector,omitempty\"`","\tLabelSelector     *metav1.LabelSelector `json:\"labelSelector,omitempty\"`","}","","// EventInterceptor provides a hook to intercept and pre-process events","type EventInterceptor = TriggerInterceptor","","// SecretRef contains the information required to reference a single secret string","// This is needed because the other secretRef types are not cross-namespace and do not","// actually contain the \"SecretName\" field, which allows us to access a single secret value.","type SecretRef struct {","\tSecretKey  string `json:\"secretKey,omitempty\"`","\tSecretName string `json:\"secretName,omitempty\"`","}","","// EventListenerBinding refers to a particular TriggerBinding or ClusterTriggerBinding resource.","type EventListenerBinding = TriggerSpecBinding","","// EventListenerTemplate refers to a particular TriggerTemplate resource.","type EventListenerTemplate = TriggerSpecTemplate","","// EventListenerList contains a list of TriggerBinding","//","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","type EventListenerList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []EventListener `json:\"items\"`","}","","// EventListenerStatus holds the status of the EventListener","// +k8s:deepcopy-gen=true","type EventListenerStatus struct {","\tduckv1.Status `json:\",inline\"`","","\t// EventListener is Addressable. It currently exposes the service DNS","\t// address of the EventListener sink","\tv1beta1.AddressStatus `json:\",inline\"`","","\t// Configuration stores configuration for the EventListener service","\tConfiguration EventListenerConfig `json:\"configuration\"`","}","","// EventListenerConfig stores configuration for resources generated by the","// EventListener","type EventListenerConfig struct {","\t// GeneratedResourceName is the name given to all resources reconciled by","\t// the EventListener","\tGeneratedResourceName string `json:\"generatedName\"`","}","","// NamespaceSelector is a selector for selecting either all namespaces or a","// list of namespaces.","// +k8s:openapi-gen=true","type NamespaceSelector struct {","\t// List of namespace names.","\t// +listType=atomic","\tMatchNames []string `json:\"matchNames,omitempty\"`","}","","// The conditions that are internally resolved by the EventListener reconciler","const (","\t// ServiceExists is the ConditionType set on the EventListener, which","\t// specifies Service existence.","\tServiceExists apis.ConditionType = \"Service\"","\t// DeploymentExists is the ConditionType set on the EventListener, which","\t// specifies Deployment existence.","\tDeploymentExists apis.ConditionType = \"Deployment\"",")","","// Check that EventListener may be validated and defaulted.","// TriggerBindingKind defines the type of TriggerBinding used by the EventListener.","type TriggerBindingKind string","","const (","\t// NamespacedTriggerBindingKind indicates that triggerbinding type has a namespace scope.","\tNamespacedTriggerBindingKind TriggerBindingKind = \"TriggerBinding\"","\t// ClusterTriggerBindingKind indicates that triggerbinding type has a cluster scope.","\tClusterTriggerBindingKind TriggerBindingKind = \"ClusterTriggerBinding\"",")","","var eventListenerCondSet = apis.NewLivingConditionSet(","\tServiceExists,","\tDeploymentExists,",")","","// GetGroupVersionKind implements kmeta.OwnerRefable","func (el *EventListener) GetGroupVersionKind() schema.GroupVersionKind {","\treturn SchemeGroupVersion.WithKind(\"EventListener\")","}","","// GetCondition returns the Condition matching the given type.","func (els *EventListenerStatus) GetCondition(t apis.ConditionType) *apis.Condition {","\treturn eventListenerCondSet.Manage(els).GetCondition(t)","}","","// SetCondition sets the condition, unsetting previous conditions with the same","// type as necessary. This is a local change and needs to be persisted to the","// K8s API elsewhere.","func (els *EventListenerStatus) SetCondition(newCond *apis.Condition) {","\tif newCond != nil {","\t\t// TODO: Should the ConditionManager be set somewhere?","\t\teventListenerCondSet.Manage(els).SetCondition(*newCond)","\t}","}","","func (els *EventListenerStatus) SetReadyCondition() {","\tfor _, ct := range []apis.ConditionType{","\t\tServiceExists,","\t\tDeploymentExists,","\t\tapis.ConditionType(appsv1.DeploymentProgressing),","\t\tapis.ConditionType(appsv1.DeploymentAvailable)} {","\t\tif sc := els.GetCondition(ct); sc != nil {","\t\t\tif sc.Status != corev1.ConditionTrue {","\t\t\t\tels.SetCondition(\u0026apis.Condition{","\t\t\t\t\tType:    apis.ConditionReady,","\t\t\t\t\tStatus:  corev1.ConditionFalse,","\t\t\t\t\tMessage: fmt.Sprintf(\"Condition %s has status: %s with message: %s\", sc.Type, sc.Status, sc.Message),","\t\t\t\t})","\t\t\t\treturn","\t\t\t}","\t\t}","\t}","\tels.SetCondition(\u0026apis.Condition{","\t\tType:    apis.ConditionReady,","\t\tStatus:  corev1.ConditionTrue,","\t\tMessage: \"EventListener is ready\",","\t})","}","","// SetDeploymentConditions sets the Deployment conditions on the EventListener,","// which is a reflection of the actual Deployment status.","func (els *EventListenerStatus) SetDeploymentConditions(deploymentConditions []appsv1.DeploymentCondition) {","\t// Manually remove the DeploymentReplicaFailure condition since it does","\t// not always exist and would stay around otherwise","\treplicaFailureIndex := -1","\tfor i := range els.Conditions {","\t\tif els.Conditions[i].Type == apis.ConditionType(appsv1.DeploymentReplicaFailure) {","\t\t\treplicaFailureIndex = i","\t\t\tbreak","\t\t}","\t}","\tif replicaFailureIndex != -1 {","\t\tels.Conditions = append(els.Conditions[:replicaFailureIndex], els.Conditions[replicaFailureIndex+1:]...)","\t}","\tfor _, cond := range deploymentConditions {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    apis.ConditionType(cond.Type),","\t\t\tStatus:  cond.Status,","\t\t\tReason:  cond.Reason,","\t\t\tMessage: cond.Message,","\t\t})","\t}","}","","func (els *EventListenerStatus) SetConditionsForDynamicObjects(conditions v1beta1.Conditions) {","\tfor _, cond := range conditions {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    cond.Type,","\t\t\tStatus:  cond.Status,","\t\t\tReason:  cond.Reason,","\t\t\tMessage: cond.Message,","\t\t})","\t}","","\tels.SetCondition(\u0026apis.Condition{","\t\tType:    apis.ConditionReady,","\t\tStatus:  corev1.ConditionTrue,","\t\tMessage: \"EventListener is ready\",","\t})","}","","// SetExistsCondition simplifies setting the exists conditions on the","// EventListenerStatus.","func (els *EventListenerStatus) SetExistsCondition(cond apis.ConditionType, err error) {","\tif err != nil {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    cond,","\t\t\tStatus:  corev1.ConditionFalse,","\t\t\tMessage: err.Error(),","\t\t})","\t} else {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:    cond,","\t\t\tStatus:  corev1.ConditionTrue,","\t\t\tMessage: fmt.Sprintf(\"%s exists\", cond),","\t\t})","\t}","}","","// InitializeConditions will set all conditions in eventListenerCondSet to false","// for the EventListener. This does not use the InitializeCondition() provided","// by the conditionsImpl to avoid setting the happy condition. This is a local","// change and needs to be persisted to the K8s API elsewhere.","func (els *EventListenerStatus) InitializeConditions() {","\tfor _, condition := range []apis.ConditionType{","\t\tServiceExists,","\t\tDeploymentExists,","\t\tapis.ConditionReady,","\t} {","\t\tels.SetCondition(\u0026apis.Condition{","\t\t\tType:   condition,","\t\t\tStatus: corev1.ConditionFalse,","\t\t})","\t}","}","","// SetAddress sets the address (as part of Addressable contract) and marks the correct condition.","func (els *EventListenerStatus) SetAddress(hostname string) {","\tif els.Address == nil {","\t\tels.Address = \u0026v1beta1.Addressable{}","\t}","\tif hostname != \"\" {","\t\tels.Address.URL = \u0026apis.URL{","\t\t\tScheme: \"http\",","\t\t\tHost:   hostname,","\t\t}","\t} else {","\t\tels.Address.URL = nil","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,2,2,2,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":33,"path":"pkg/apis/triggers/v1beta1/event_listener_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"k8s.io/apimachinery/pkg/util/validation\"","\t\"knative.dev/pkg/apis\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/webhook/resourcesemantics\"",")","","var (","\treservedEnvVars = sets.NewString(","\t\t\"TLS_CERT\",","\t\t\"TLS_KEY\",","\t)",")","","var _ resourcesemantics.VerbLimited = (*EventListener)(nil)","","// SupportedVerbs returns the operations that validation should be called for","func (e *EventListener) SupportedVerbs() []admissionregistrationv1.OperationType {","\treturn []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}","}","","// revive:disable:unused-parameter","","// Validate EventListener.","func (e *EventListener) Validate(ctx context.Context) *apis.FieldError {","\tvar errs *apis.FieldError","\tif len(e.ObjectMeta.Name) \u003e 60 {","\t\t// Since `el-` is added as the prefix of EventListener services, the name of EventListener must be no more than 60 characters long.","\t\terrs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf(\"eventListener name '%s' must be no more than 60 characters long\", e.ObjectMeta.Name), \"metadata.name\"))","\t}","","\tif len(e.GetObjectMeta().GetAnnotations()) != 0 {","\t\terrs = errs.Also(triggers.ValidateAnnotations(e.GetObjectMeta().GetAnnotations()))","\t}","","\treturn errs.Also(e.Spec.validate(ctx))","}","","func (s *EventListenerSpec) validate(ctx context.Context) (errs *apis.FieldError) {","\tif s.LabelSelector == nil \u0026\u0026 len(s.NamespaceSelector.MatchNames) == 0 \u0026\u0026 len(s.TriggerGroups) == 0 \u0026\u0026 len(s.Triggers) == 0 {","\t\treturn apis.ErrMissingOneOf(\"spec.labelSelector\", \"spec.namespaceSelector\", \"spec.triggerGroups\", \"spec.triggers\")","\t}","","\tfor i, trigger := range s.Triggers {","\t\terrs = errs.Also(trigger.validate(ctx).ViaField(fmt.Sprintf(\"spec.triggers[%d]\", i)))","\t}","","\t// Both Kubernetes and Custom resource can't be present at the same time","\tif s.Resources.KubernetesResource != nil \u0026\u0026 s.Resources.CustomResource != nil {","\t\treturn apis.ErrMultipleOneOf(\"spec.resources.kubernetesResource\", \"spec.resources.customResource\")","\t}","","\tif s.Resources.KubernetesResource != nil {","\t\terrs = errs.Also(validateKubernetesObject(s.Resources.KubernetesResource).ViaField(\"spec.resources.kubernetesResource\"))","\t}","","\tif s.Resources.CustomResource != nil {","\t\terrs = errs.Also(validateCustomObject(s.Resources.CustomResource).ViaField(\"spec.resources.customResource\"))","\t}","","\tif len(s.TriggerGroups) \u003e 0 {","\t\tfor i, group := range s.TriggerGroups {","\t\t\terrs = errs.Also(group.validate(ctx).ViaField(fmt.Sprintf(\"spec.triggerGroups[%d]\", i)))","\t\t}","\t}","","\treturn errs","}","","func (g *EventListenerTriggerGroup) validate(ctx context.Context) (errs *apis.FieldError) {","\tif g.TriggerSelector.LabelSelector == nil \u0026\u0026 len(g.TriggerSelector.NamespaceSelector.MatchNames) == 0 {","\t\terrs = errs.Also(apis.ErrMissingOneOf(\"triggerSelector.labelSelector\", \"triggerSelector.namespaceSelector\"))","\t}","\tif len(g.Interceptors) == 0 {","\t\terrs = errs.Also(apis.ErrMissingField(\"interceptors\"))","\t}","\treturn errs","}","","func validateCustomObject(customData *CustomResource) (errs *apis.FieldError) {","\torig := duckv1.WithPod{}","\tdecoder := json.NewDecoder(bytes.NewBuffer(customData.RawExtension.Raw))","","\tif err := decoder.Decode(\u0026orig); err != nil {","\t\terrs = errs.Also(apis.ErrInvalidValue(err, \"spec\"))","\t}","","\tif len(orig.Spec.Template.Spec.Containers) \u003e 1 {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"containers\").ViaField(\"spec.template.spec\"))","\t}","\terrs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec,","\t\t*podSpecMask(\u0026orig.Spec.Template.Spec)).ViaField(\"spec.template.spec\"))","","\t// bounded by condition because containers fields are optional so there is a chance that containers can be nil.","\tif len(orig.Spec.Template.Spec.Containers) == 1 {","\t\terrs = errs.Also(apis.CheckDisallowedFields(orig.Spec.Template.Spec.Containers[0],","\t\t\t*containerFieldMaskForCustomResource(\u0026orig.Spec.Template.Spec.Containers[0])).ViaField(\"spec.template.spec.containers[0]\"))","\t\t// validate env","\t\terrs = errs.Also(validateEnv(orig.Spec.Template.Spec.Containers[0].Env).ViaField(\"spec.template.spec.containers[0].env\"))","\t}","","\treturn errs","}","","func validateKubernetesObject(orig *KubernetesResource) (errs *apis.FieldError) {","\tif orig.Replicas != nil {","\t\tif *orig.Replicas \u003c 0 {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(*orig.Replicas, \"spec.replicas\"))","\t\t}","\t}","\tif len(orig.Template.Spec.Containers) \u003e 1 {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"containers\").ViaField(\"spec.template.spec\"))","\t}","\terrs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec,","\t\t*podSpecMask(\u0026orig.Template.Spec)).ViaField(\"spec.template.spec\"))","","\t// bounded by condition because containers fields are optional so there is a chance that containers can be nil.","\tif len(orig.Template.Spec.Containers) == 1 {","\t\terrs = errs.Also(apis.CheckDisallowedFields(orig.Template.Spec.Containers[0],","\t\t\t*containerFieldMaskForKubernetes(\u0026orig.Template.Spec.Containers[0])).ViaField(\"spec.template.spec.containers[0]\"))","\t\t// validate env","\t\terrs = errs.Also(validateEnv(orig.Template.Spec.Containers[0].Env).ViaField(\"spec.template.spec.containers[0].env\"))","\t}","","\tif orig.ServiceLoadBalancerClass != nil \u0026\u0026 orig.ServiceType != corev1.ServiceTypeLoadBalancer {","\t\terrs = errs.Also(apis.ErrInvalidValue(*orig.ServiceLoadBalancerClass, \"serviceLoadBalancerClass\", \"ServiceLoadBalancerClass is only needed for LoadBalancer service type\"))","\t}","","\treturn errs","}","","func validateEnv(envVars []corev1.EnvVar) (errs *apis.FieldError) {","\tvar (","\t\tcount    = 0","\t\tenvValue string","\t)","\tfor i, env := range envVars {","\t\terrs = errs.Also(validateEnvVar(env).ViaIndex(i))","\t\tif reservedEnvVars.Has(env.Name) {","\t\t\tcount++","\t\t\tenvValue = env.Name","\t\t}","\t}","\t// This is to make sure both TLS_CERT and TLS_KEY is set for tls connection","\tif count == 1 {","\t\terrs = errs.Also(\u0026apis.FieldError{","\t\t\tMessage: \"Expected env's are TLS_CERT and TLS_KEY, but got only one env \" + envValue,","\t\t})","\t}","\treturn errs","}","","func validateEnvVar(env corev1.EnvVar) (errs *apis.FieldError) {","\terrs = errs.Also(apis.CheckDisallowedFields(env, *envVarMask(\u0026env)))","","\treturn errs.Also(validateEnvValueFrom(env.ValueFrom).ViaField(\"valueFrom\"))","}","","func validateEnvValueFrom(source *corev1.EnvVarSource) *apis.FieldError {","\tif source == nil {","\t\treturn nil","\t}","\treturn apis.CheckDisallowedFields(*source, *envVarSourceMask(source))","}","","// envVarSourceMask performs a _shallow_ copy of the Kubernetes EnvVarSource object to a new","// Kubernetes EnvVarSource object bringing over only the fields allowed in the Triggers EventListener API.","func envVarSourceMask(in *corev1.EnvVarSource) *corev1.EnvVarSource {","\tif in == nil {","\t\treturn nil","\t}","\tout := new(corev1.EnvVarSource)","\t// Allowed fields","\tout.SecretKeyRef = in.SecretKeyRef","","\t// Disallowed fields","\tout.ConfigMapKeyRef = nil","\tout.FieldRef = nil","\tout.ResourceFieldRef = nil","","\treturn out","}","","// envVarMask performs a _shallow_ copy of the Kubernetes EnvVar object to a new","// Kubernetes EnvVar object bringing over only the fields allowed in the Triggers EventListener API.","func envVarMask(in *corev1.EnvVar) *corev1.EnvVar {","\tif in == nil {","\t\treturn nil","\t}","\tout := new(corev1.EnvVar)","\t// Allowed fields","\tout.Name = in.Name","\tout.ValueFrom = in.ValueFrom","","\t// Disallowed fields","\tout.Value = \"\"","","\treturn out","}","","func containerFieldMaskForKubernetes(in *corev1.Container) *corev1.Container {","\tout := new(corev1.Container)","\tout.Resources = in.Resources","\tout.Env = in.Env","\tout.LivenessProbe = in.LivenessProbe","\tout.ReadinessProbe = in.ReadinessProbe","\tout.StartupProbe = in.StartupProbe","\tout.SecurityContext = in.SecurityContext","\treturn containerFieldMask(out)","}","","func containerFieldMaskForCustomResource(in *corev1.Container) *corev1.Container {","\tout := new(corev1.Container)","\tout.Resources = in.Resources","\tout.Env = in.Env","\tout.SecurityContext = in.SecurityContext","\treturn containerFieldMask(out)","}","","func containerFieldMask(out *corev1.Container) *corev1.Container {","\t// Disallowed fields","\t// This list clarifies which all container attributes are not allowed.","\tout.Name = \"\"","\tout.Image = \"\"","\tout.Args = nil","\tout.Ports = nil","\tout.Command = nil","\tout.VolumeMounts = nil","\tout.ImagePullPolicy = \"\"","\tout.Lifecycle = nil","\tout.Stdin = false","\tout.StdinOnce = false","\tout.TerminationMessagePath = \"\"","\tout.TerminationMessagePolicy = \"\"","\tout.WorkingDir = \"\"","\tout.TTY = false","\tout.VolumeDevices = nil","\tout.EnvFrom = nil","","\treturn out","}","","// podSpecMask performs a _shallow_ copy of the Kubernetes PodSpec object to a new","// Kubernetes PodSpec object bringing over only the fields allowed in the Triggers EvenListener.","func podSpecMask(in *corev1.PodSpec) *corev1.PodSpec {","\tout := new(corev1.PodSpec)","","\t// Allowed fields","\tout.ServiceAccountName = in.ServiceAccountName","\tout.Containers = in.Containers","\tout.Tolerations = in.Tolerations","\tout.NodeSelector = in.NodeSelector","\tout.Affinity = in.Affinity","\tout.TopologySpreadConstraints = in.TopologySpreadConstraints","\tout.ImagePullSecrets = in.ImagePullSecrets","\tout.SecurityContext = in.SecurityContext","","\t// Disallowed fields","\t// This list clarifies which all podspec fields are not allowed.","\tout.Volumes = nil","\tout.EnableServiceLinks = nil","\tout.InitContainers = nil","\tout.RestartPolicy = \"\"","\tout.TerminationGracePeriodSeconds = nil","\tout.ActiveDeadlineSeconds = nil","\tout.DNSPolicy = \"\"","\tout.AutomountServiceAccountToken = nil","\tout.NodeName = \"\"","\tout.HostNetwork = false","\tout.HostPID = false","\tout.HostIPC = false","\tout.ShareProcessNamespace = nil","\tout.Hostname = \"\"","\tout.Subdomain = \"\"","\tout.SchedulerName = \"\"","\tout.HostAliases = nil","\tout.PriorityClassName = \"\"","\tout.Priority = nil","\tout.DNSConfig = nil","\tout.ReadinessGates = nil","\tout.RuntimeClassName = nil","","\treturn out","}","","func (t *EventListenerTrigger) validate(ctx context.Context) (errs *apis.FieldError) {","\tif t.Template == nil \u0026\u0026 t.TriggerRef == \"\" {","\t\terrs = errs.Also(apis.ErrMissingOneOf(\"template\", \"triggerRef\"))","\t}","","\tif t.TriggerRef != \"\" \u0026\u0026 (t.Template != nil || t.Bindings != nil || t.Interceptors != nil) {","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"triggerRef\", \"template or bindings or interceptors\"))","\t}","","\t// Validate optional Bindings","\terrs = errs.Also(triggerSpecBindingArray(t.Bindings).validate(ctx))","\tif t.Template != nil {","\t\t// Validate required TriggerTemplate","\t\terrs = errs.Also(t.Template.validate(ctx))","\t}","","\t// Validate optional Interceptors","\tfor i, interceptor := range t.Interceptors {","\t\t// No continuation if provided interceptor is nil.","\t\tif interceptor == nil {","\t\t\treturn errs.Also(apis.ErrInvalidValue(fmt.Sprintf(\"interceptor '%v' must be a valid value\", interceptor), fmt.Sprintf(\"interceptors[%d]\", i)))","\t\t}","\t\terrs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf(\"interceptors[%d]\", i)))","\t}","","\t// The trigger name is added as a label value for 'tekton.dev/trigger' so it must follow the k8s label guidelines:","\t// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set","\tif err := validation.IsValidLabelValue(t.Name); len(err) \u003e 0 {","\t\terrs = errs.Also(apis.ErrInvalidValue(fmt.Sprintf(\"trigger name '%s' must be a valid label value\", t.Name), \"name\"))","\t}","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,2,2,2,2,2,2,0,2,2,2,0,2,0,0,2,2,2,2,0,2,2,2,0,0,2,2,2,0,2,2,2,0,2,2,2,0,2,2,2,2,0,0,2,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,0,0,0,0,2,2,1,1,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,1,1,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,0,0,0,0,2,2,2,0,2,0]},{"id":34,"path":"pkg/apis/triggers/v1beta1/interceptor_types.go","lines":["package v1beta1","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"google.golang.org/grpc/codes\"",")","","type InterceptorInterface interface {","\t// Process executes the given InterceptorRequest. Simply getting a non-nil InterceptorResponse back is not sufficient","\t// to determine if the interceptor processing was successful. Instead use the InterceptorResponse.Status.Continue to","\t// see if processing should continue and InterceptorResponse.Status.Code to distinguish between the kinds of errors","\t// (i.e user errors vs system errors)","\tProcess(ctx context.Context, r *InterceptorRequest) *InterceptorResponse","}","","// Do not generate DeepCopy(). See #827","// +k8s:deepcopy-gen=false","type InterceptorRequest struct {","\t// Body is the incoming HTTP event body. We use a \"string\" representation of the JSON body","\t// in order to preserve the body exactly as it was sent (including spaces etc.). This is necessary","\t// for some interceptors e.g. GitHub for validating the body with a signature. While []byte can also","\t// store an exact representation of the body, `json.Marshal` will compact []byte to a base64 encoded","\t// string which means that we will lose the spaces any time we marshal this struct.","\tBody string `json:\"body,omitempty\"`","","\t// Header are the headers for the incoming HTTP event","\tHeader map[string][]string `json:\"header,omitempty\"`","","\t// Extensions are extra values that are added by previous interceptors in a chain","\tExtensions map[string]interface{} `json:\"extensions,omitempty\"`","","\t// InterceptorParams are the user specified params for interceptor in the Trigger","\tInterceptorParams map[string]interface{} `json:\"interceptor_params,omitempty\"`","","\t// Context contains additional metadata about the event being processed","\tContext *TriggerContext `json:\"context\"`","}","","type TriggerContext struct {","\t// EventURL is the URL of the incoming event","\tEventURL string `json:\"event_url,omitempty\"`","\t// EventID is a unique ID assigned by Triggers to each event","\tEventID string `json:\"event_id,omitempty\"`","\t// TriggerID is of the form namespace/$ns/triggers/$name","\tTriggerID string `json:\"trigger_id,omitempty\"`","}","","// Do not generate Deepcopy(). See #827","// +k8s:deepcopy-gen=false","type InterceptorResponse struct {","\t// Extensions are additional fields that is added to the interceptor event.","\tExtensions map[string]interface{} `json:\"extensions,omitempty\"`","\t// Continue indicates if the EventListener should continue processing the Trigger or not","\tContinue bool `json:\"continue\"` // Don't add omitempty -- it  will remove the continue field when the value is false.","\t// Status is an Error status containing details on any interceptor processing errors","\tStatus Status `json:\"status\"`","}","","type Status struct {","\t// The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code].","\tCode codes.Code `json:\"code,omitempty\"`","\t// A developer-facing error message, which should be in English.","\tMessage string `json:\"message,omitempty\"`","}","","func (s Status) Err() StatusError {","\treturn StatusError{s: s}","}","","type StatusError struct {","\ts Status","}","","func (s StatusError) Error() string {","\treturn fmt.Sprintf(\"rpc error: code = %s desc = %s\", s.s.Code, s.s.Message)","}","","func ParseTriggerID(triggerID string) (namespace, name string) {","\tsplits := strings.Split(triggerID, \"/\")","\tif len(splits) != 4 {","\t\treturn","\t}","","\treturn splits[1], splits[3]","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,1,1,0,2,2,2,2,2,0,2,0]},{"id":35,"path":"pkg/apis/triggers/v1beta1/register.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"github.com/tektoncd/triggers/pkg/apis/triggers\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"",")","","// SchemeGroupVersion is group version used to register these objects","var SchemeGroupVersion = schema.GroupVersion{Group: triggers.GroupName, Version: \"v1beta1\"}","","// Kind takes an unqualified kind and returns back a Group qualified GroupKind","func Kind(kind string) schema.GroupKind {","\treturn SchemeGroupVersion.WithKind(kind).GroupKind()","}","","// Resource takes an unqualified resource and returns a Group qualified GroupResource","func Resource(resource string) schema.GroupResource {","\treturn SchemeGroupVersion.WithResource(resource).GroupResource()","}","","var (","\tschemeBuilder = runtime.NewSchemeBuilder(addKnownTypes)","","\t// AddToScheme adds Build types to the scheme.","\tAddToScheme = schemeBuilder.AddToScheme",")","","// Adds the list of known types to Scheme.","func addKnownTypes(scheme *runtime.Scheme) error {","\tscheme.AddKnownTypes(SchemeGroupVersion,","\t\t\u0026ClusterTriggerBinding{},","\t\t\u0026ClusterTriggerBindingList{},","\t\t\u0026EventListener{},","\t\t\u0026EventListenerList{},","\t\t\u0026TriggerBinding{},","\t\t\u0026TriggerBindingList{},","\t\t\u0026TriggerTemplate{},","\t\t\u0026TriggerTemplateList{},","\t\t\u0026Trigger{},","\t\t\u0026TriggerList{},","\t)","\tmetav1.AddToGroupVersion(scheme, SchemeGroupVersion)","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]},{"id":36,"path":"pkg/apis/triggers/v1beta1/trigger_binding_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"",")","","// revive:disable:unused-parameter","","// SetDefaults initializes TriggerBinding tb with its default values.","func (tb *TriggerBinding) SetDefaults(ctx context.Context) {}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":37,"path":"pkg/apis/triggers/v1beta1/trigger_binding_types.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","// Check that TriggerBinding may be validated and defaulted.","var _ apis.Validatable = (*TriggerBinding)(nil)","var _ apis.Defaultable = (*TriggerBinding)(nil)","","func (tb *TriggerBinding) TriggerBindingSpec() TriggerBindingSpec {","\treturn tb.Spec","}","","func (tb *TriggerBinding) TriggerBindingMetadata() metav1.ObjectMeta {","\treturn tb.ObjectMeta","}","","func (tb *TriggerBinding) Copy() TriggerBindingInterface {","\treturn tb.DeepCopy()","}","","// TriggerBindingSpec defines the desired state of the TriggerBinding.","type TriggerBindingSpec struct {","\t// Params defines the parameter mapping from the given input event.","\t// +listType=atomic","\tParams []Param `json:\"params,omitempty\"`","}","","// TriggerBindingStatus defines the observed state of TriggerBinding.","type TriggerBindingStatus struct{}","","// +genclient","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// TriggerBinding defines a mapping of an input event to parameters. This is used","// to extract information from events to be passed to TriggerTemplates within a","// Trigger.","// +k8s:openapi-gen=true","type TriggerBinding struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\t// Spec holds the desired state of the TriggerBinding","\t// +optional","\tSpec TriggerBindingSpec `json:\"spec\"`","\t// +optional","\tStatus TriggerBindingStatus `json:\"status,omitempty\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// TriggerBindingList contains a list of TriggerBindings.","// We don't use this but it's required for certain codegen features.","type TriggerBindingList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []TriggerBinding `json:\"items\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":38,"path":"pkg/apis/triggers/v1beta1/trigger_binding_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\t\"k8s.io/apimachinery/pkg/api/equality\"","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/webhook/resourcesemantics\"",")","","var _ resourcesemantics.VerbLimited = (*TriggerBinding)(nil)","","// SupportedVerbs returns the operations that validation should be called for","func (tb *TriggerBinding) SupportedVerbs() []admissionregistrationv1.OperationType {","\treturn []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}","}","","// Validate TriggerBinding.","func (tb *TriggerBinding) Validate(ctx context.Context) *apis.FieldError {","\terrs := validate.ObjectMetadata(tb.GetObjectMeta()).ViaField(\"metadata\")","\treturn errs.Also(tb.Spec.Validate(ctx).ViaField(\"spec\"))","}","","// revive:disable:unused-parameter","","// Validate TriggerBindingSpec.","func (s *TriggerBindingSpec) Validate(ctx context.Context) (errs *apis.FieldError) {","\tif equality.Semantic.DeepEqual(s, \u0026TriggerBindingSpec{}) {","\t\treturn errs.Also(apis.ErrMissingField(apis.CurrentField))","\t}","\treturn errs.Also(validateParams(s.Params).ViaField(\"params\"))","}","","func validateParams(params []Param) *apis.FieldError {","\t// Ensure there aren't multiple params with the same name.","\tseen := sets.NewString()","\tfor i, param := range params {","\t\tif seen.Has(param.Name) {","\t\t\treturn apis.ErrMultipleOneOf(fmt.Sprintf(\"[%d].name\", i))","\t\t}","\t\tseen.Insert(param.Name)","\t\terrs := validateParamValue(param.Value).ViaField(fmt.Sprintf(\"[%d]\", i))","\t\tif errs != nil {","\t\t\treturn errs","\t\t}","\t}","\treturn nil","}","","func validateParamValue(in string) *apis.FieldError {","\tif !strings.Contains(in, \"$(\") {","\t\treturn nil","\t}","\t// Splits string on $( to find potential Tekton expressions","\tmaybeExpressions := strings.Split(in, \"$(\")","\tterminated := true","\tfor _, e := range maybeExpressions[1:] { // Split always returns at least one element","\t\t// Iterate until we find the first unbalanced )","\t\tnumOpenBrackets := 0","\t\tif !terminated {","\t\t\treturn apis.ErrInvalidValue(in, \"value\")","\t\t}","\t\tterminated = false","\t\tfor _, ch := range e {","\t\t\tswitch ch {","\t\t\tcase '(':","\t\t\t\tnumOpenBrackets++","\t\t\tcase ')':","\t\t\t\tnumOpenBrackets--","\t\t\t\tif numOpenBrackets \u003c 0 {","\t\t\t\t\tterminated = true","\t\t\t\t}","\t\t\tdefault:","\t\t\t\tcontinue","\t\t\t}","\t\t\tif numOpenBrackets \u003c 0 {","\t\t\t\tterminated = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,2,2,2,2,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,0,0,2,0]},{"id":39,"path":"pkg/apis/triggers/v1beta1/trigger_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"",")","","type triggerSpecBindingArray []*TriggerSpecBinding","","// SetDefaults sets the defaults on the object.","func (t *Trigger) SetDefaults(ctx context.Context) {","\tif !contexts.IsUpgradeViaDefaulting(ctx) {","\t\treturn","\t}","\ttriggerSpecBindingArray(t.Spec.Bindings).defaultBindings()","\tfor _, ti := range t.Spec.Interceptors {","\t\tti.defaultInterceptorKind()","\t}","}","","// set default TriggerBinding kind for Bindings in TriggerSpec","func (t triggerSpecBindingArray) defaultBindings() {","\tif len(t) \u003e 0 {","\t\tfor _, b := range t {","\t\t\tif b.Kind == \"\" {","\t\t\t\tb.Kind = NamespacedTriggerBindingKind","\t\t\t}","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,0]},{"id":40,"path":"pkg/apis/triggers/v1beta1/trigger_template_defaults.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"",")","","// revive:disable:unused-parameter","","// SetDefaults initializes TriggerTemplate with default values.","func (tt *TriggerTemplate) SetDefaults(ctx context.Context) {}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":41,"path":"pkg/apis/triggers/v1beta1/trigger_template_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"","\t\"fmt\"","\t\"regexp\"","","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\t\"k8s.io/apimachinery/pkg/api/equality\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/util/sets\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/webhook/resourcesemantics\"",")","","// paramsRegexp captures TriggerTemplate parameter names $(tt.params.NAME)","var paramsRegexp = regexp.MustCompile(`\\$\\(tt.params.(?P\u003cvar\u003e[_a-zA-Z][_a-zA-Z0-9.-]*)\\)`)","","var _ resourcesemantics.VerbLimited = (*TriggerTemplate)(nil)","","// SupportedVerbs returns the operations that validation should be called for","func (t *TriggerTemplate) SupportedVerbs() []admissionregistrationv1.OperationType {","\treturn []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}","}","","// Validate validates a TriggerTemplate.","func (t *TriggerTemplate) Validate(ctx context.Context) *apis.FieldError {","\terrs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField(\"metadata\")","\treturn errs.Also(t.Spec.validate(ctx).ViaField(\"spec\"))","}","","// revive:disable:unused-parameter","","// Validate validates a TriggerTemplateSpec.","func (s *TriggerTemplateSpec) validate(ctx context.Context) (errs *apis.FieldError) {","\tif equality.Semantic.DeepEqual(s, \u0026TriggerTemplateSpec{}) {","\t\terrs = errs.Also(apis.ErrMissingField(apis.CurrentField))","\t}","\tif len(s.ResourceTemplates) == 0 {","\t\terrs = errs.Also(apis.ErrMissingField(\"resourcetemplates\"))","\t}","\terrs = errs.Also(validateResourceTemplates(s.ResourceTemplates).ViaField(\"resourcetemplates\"))","\terrs = errs.Also(verifyParamDeclarations(s.Params, s.ResourceTemplates).ViaField(\"resourcetemplates\"))","\treturn errs","}","","func validateResourceTemplates(templates []TriggerResourceTemplate) (errs *apis.FieldError) {","\tfor i, trt := range templates {","\t\tdata := new(unstructured.Unstructured)","\t\tif err := data.UnmarshalJSON(trt.Raw); err != nil {","\t\t\t// a missing kind makes the unmarshalling throw an error","\t\t\terrs = errs.Also(apis.ErrMissingField(fmt.Sprintf(\"[%d].kind\", i)))","\t\t}","","\t\tif data.GetAPIVersion() == \"\" {","\t\t\terrs = errs.Also(apis.ErrMissingField(fmt.Sprintf(\"[%d].apiVersion\", i)))","\t\t}","\t}","\treturn errs","}","","// Verify every param in the ResourceTemplates is declared with a ParamSpec","func verifyParamDeclarations(params []ParamSpec, templates []TriggerResourceTemplate) *apis.FieldError {","\tdeclaredParamNames := sets.NewString()","\tfor _, param := range params {","\t\tdeclaredParamNames.Insert(param.Name)","\t}","\tfor i, template := range templates {","\t\t// Get all params in the template $(tt.params.NAME)","\t\ttemplateParams := paramsRegexp.FindAllSubmatch(template.RawExtension.Raw, -1)","\t\tfor _, templateParam := range templateParams {","\t\t\ttemplateParamName := string(templateParam[1])","\t\t\tif !declaredParamNames.Has(templateParamName) {","\t\t\t\tfieldErr := apis.ErrInvalidValue(","\t\t\t\t\tfmt.Sprintf(\"undeclared param '$(tt.params.%s)'\", templateParamName),","\t\t\t\t\tfmt.Sprintf(\"[%d]\", i),","\t\t\t\t)","\t\t\t\tfieldErr.Details = fmt.Sprintf(\"'$(tt.params.%s)' must be declared in spec.params\", templateParamName)","\t\t\t\treturn fieldErr","\t\t\t}","\t\t}","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,0,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,0]},{"id":42,"path":"pkg/apis/triggers/v1beta1/trigger_types.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tapiextensionsv1 \"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/apis\"",")","","// TriggerSpec represents a connection between TriggerSpecBinding,","// and TriggerSpecTemplate; TriggerSpecBinding provides extracted values for","// TriggerSpecTemplate to then create resources from.","type TriggerSpec struct {","\t// +listType=atomic","\tBindings []*TriggerSpecBinding `json:\"bindings\"`","\tTemplate TriggerSpecTemplate   `json:\"template\"`","\t// +optional","\tName string `json:\"name,omitempty\"`","\t// +listType=atomic","\tInterceptors []*TriggerInterceptor `json:\"interceptors,omitempty\"`","\t// ServiceAccountName optionally associates credentials with each trigger;","\t// Unlike EventListeners, this should be scoped to the same namespace","\t// as the Trigger itself","\t// +optional","\tServiceAccountName string `json:\"serviceAccountName,omitempty\"`","}","","type TriggerSpecTemplate struct {","\tRef        *string              `json:\"ref,omitempty\"`","\tAPIVersion string               `json:\"apiversion,omitempty\"`","\tSpec       *TriggerTemplateSpec `json:\"spec,omitempty\"`","}","","type TriggerSpecBinding struct {","\t// Name is the name of the binding param","\t// Mutually exclusive with Ref","\tName string `json:\"name,omitempty\"`","\t// Value is the value of the binding param. Can contain JSONPath","\t// Has to be pointer since \"\" is a valid value","\t// Required if Name is also specified.","\tValue *string `json:\"value,omitempty\"`","","\t// Ref is a reference to a TriggerBinding kind.","\t// Mutually exclusive with Name","\tRef string `json:\"ref,omitempty\"`","","\t// Kind can only be provided if Ref is also provided. Defaults to TriggerBinding","\tKind TriggerBindingKind `json:\"kind,omitempty\"`","","\t// APIVersion of the binding ref","\tAPIVersion string `json:\"apiversion,omitempty\"`","}","","// +genclient","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// Trigger defines a mapping of an input event to parameters. This is used","// to extract information from events to be passed to TriggerTemplates within a","// Trigger.","// +k8s:openapi-gen=true","type Trigger struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ObjectMeta `json:\"metadata,omitempty\"`","\t// Spec holds the desired state of the Trigger","\t// +optional","\tSpec TriggerSpec `json:\"spec\"`","}","","// TriggerInterceptor provides a hook to intercept and pre-process events","type TriggerInterceptor struct {","\t// Optional name to identify the current interceptor configuration","\tName *string `json:\"name,omitempty\"`","\t// Ref refers to the Interceptor to use","\tRef InterceptorRef `json:\"ref\"`","\t// Params are the params to send to the interceptor","\t// +listType=atomic","\tParams []InterceptorParams `json:\"params,omitempty\"`","","\t// WebhookInterceptor refers to an old style webhook interceptor service","\tWebhook *WebhookInterceptor `json:\"webhook,omitempty\"`","}","","// InterceptorParams defines a key-value pair that can be passed on an interceptor","type InterceptorParams struct {","\tName  string               `json:\"name\"`","\tValue apiextensionsv1.JSON `json:\"value\"`","}","","// InterceptorRef provides a Reference to a ClusterInterceptor","type InterceptorRef struct {","\t// Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names","\tName string `json:\"name,omitempty\"`","\t// InterceptorKind indicates the kind of the Interceptor, namespaced or cluster scoped.","\t// +optional","\tKind InterceptorKind `json:\"kind,omitempty\"`","\t// API version of the referent","\t// +optional","\tAPIVersion string `json:\"apiVersion,omitempty\"`","}","","// InterceptorKind defines the type of Interceptor used by the Trigger.","type InterceptorKind string","","const (","\t// ClusterInterceptorKind indicates that Interceptor type has a cluster scope.","\tClusterInterceptorKind InterceptorKind = \"ClusterInterceptor\"","\t// NamespacedInterceptorKind indicates that Interceptor type has a namespace scope.","\tNamespacedInterceptorKind InterceptorKind = \"NamespacedInterceptor\"",")","","func (ti *TriggerInterceptor) defaultInterceptorKind() {","\tif ti.Ref.Kind == \"\" {","\t\tti.Ref.Kind = ClusterInterceptorKind","\t}","}","","// GetName returns the name for the given interceptor","func (ti *TriggerInterceptor) GetName() string {","\tif ti.Ref.Name != \"\" {","\t\treturn ti.Ref.Name","\t}","\treturn \"\"","}","","// WebhookInterceptor provides a webhook to intercept and pre-process events","type WebhookInterceptor struct {","\t// ObjectRef is a reference to an object that will resolve to a cluster DNS","\t// name to use as the EventInterceptor. Either objectRef or url can be specified","\t// +optional","\tObjectRef *corev1.ObjectReference `json:\"objectRef,omitempty\"`","\t// +optional","\tURL *apis.URL `json:\"url,omitempty\"`","\t// Header is a group of key-value pairs that can be appended to the","\t// interceptor request headers. This allows the interceptor to make","\t// decisions specific to an EventListenerTrigger.","\t// +listType=atomic","\tHeader []v1beta1.Param `json:\"header,omitempty\"`","}","","// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object","","// TriggerList contains a list of Triggers.","// We don't use this but it's required for certain codegen features.","type TriggerList struct {","\tmetav1.TypeMeta `json:\",inline\"`","\t// +optional","\tmetav1.ListMeta `json:\"metadata,omitempty\"`","\tItems           []Trigger `json:\"items\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},{"id":43,"path":"pkg/apis/triggers/v1beta1/trigger_types_convert.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"encoding/json\"",")","","// ToEventListenerTrigger converts a TriggerSpec into an EventListenerTrigger.","// This is primarily for compatibility between CRD and non-CRD types so that","// underlying libraries can reuse existing code.","func ToEventListenerTrigger(in TriggerSpec) (EventListenerTrigger, error) {","\tvar out EventListenerTrigger","","\t// Use json Marshalling in order to be field agnostic. Since TriggerSpec","\t// is a subset of the existing EventListenerTrigger type, and should always","\t// contain the same field labels, this should be safe to do.","\tb, err := json.Marshal(in)","\tif err != nil {","\t\treturn out, err","\t}","","\tif err := json.Unmarshal(b, \u0026out); err != nil {","\t\treturn out, err","\t}","\treturn out, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,1,1,0,2,1,1,2,0]},{"id":44,"path":"pkg/apis/triggers/v1beta1/trigger_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","\t\"net/http\"","","\tpipelinev1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\t\"github.com/tektoncd/pipeline/pkg/apis/validate\"","\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/webhook/resourcesemantics\"",")","","var _ resourcesemantics.VerbLimited = (*Trigger)(nil)","","// SupportedVerbs returns the operations that validation should be called for","func (t *Trigger) SupportedVerbs() []admissionregistrationv1.OperationType {","\treturn []admissionregistrationv1.OperationType{admissionregistrationv1.Create, admissionregistrationv1.Update}","}","","// Validate validates a Trigger","func (t *Trigger) Validate(ctx context.Context) *apis.FieldError {","\terrs := validate.ObjectMetadata(t.GetObjectMeta()).ViaField(\"metadata\")","\treturn errs.Also(t.Spec.validate(ctx).ViaField(\"spec\"))","}","","func (t *TriggerSpec) validate(ctx context.Context) *apis.FieldError {","\t// Validate optional Bindings","\terrs := triggerSpecBindingArray(t.Bindings).validate(ctx)","\t// Validate required TriggerTemplate","\terrs = errs.Also(t.Template.validate(ctx))","","\t// Validate optional Interceptors","\tfor i, interceptor := range t.Interceptors {","\t\terrs = errs.Also(interceptor.validate(ctx).ViaField(fmt.Sprintf(\"interceptors[%d]\", i)))","\t}","","\treturn errs","}","","func (t TriggerSpecTemplate) validate(ctx context.Context) (errs *apis.FieldError) {","\t// Optional explicit match","\tif t.APIVersion != \"\" {","\t\tif t.APIVersion != \"v1alpha1\" \u0026\u0026 t.APIVersion != \"v1beta1\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid apiVersion\"), \"template.apiVersion\"))","\t\t}","\t}","","\tswitch {","\tcase t.Spec != nil \u0026\u0026 t.Ref != nil:","\t\terrs = errs.Also(apis.ErrMultipleOneOf(\"template.spec\", \"template.ref\"))","\tcase t.Spec == nil \u0026\u0026 t.Ref == nil:","\t\terrs = errs.Also(apis.ErrMissingOneOf(\"template.spec\", \"template.ref\"))","\tcase t.Spec != nil:","\t\terrs = errs.Also(t.Spec.validate(ctx))","\tcase t.Ref == nil || *t.Ref == \"\":","\t\terrs = errs.Also(apis.ErrMissingField(\"template.ref\"))","\t}","\treturn errs","}","","// revive:disable:unused-parameter","","func (t triggerSpecBindingArray) validate(ctx context.Context) (errs *apis.FieldError) {","\tfor i, b := range t {","\t\tswitch {","\t\tcase b.Ref != \"\":","\t\t\tswitch {","\t\t\tcase b.Name != \"\": // Cannot specify both Ref and Name","\t\t\t\terrs = errs.Also(apis.ErrMultipleOneOf(fmt.Sprintf(\"bindings[%d].ref\", i), fmt.Sprintf(\"bindings[%d].name\", i)))","\t\t\tcase b.Kind != NamespacedTriggerBindingKind \u0026\u0026 b.Kind != ClusterTriggerBindingKind: // Kind must be valid","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid kind\"), fmt.Sprintf(\"bindings[%d].kind\", i)))","\t\t\t}","\t\tcase b.Name != \"\":","\t\t\tif b.Value == nil { // Value is mandatory if Name is specified","\t\t\t\terrs = errs.Also(apis.ErrMissingField(fmt.Sprintf(\"bindings[%d].value\", i)))","\t\t\t}","\t\tdefault:","\t\t\terrs = errs.Also(apis.ErrMissingOneOf(fmt.Sprintf(\"bindings[%d].ref\", i), fmt.Sprintf(\"bindings[%d].spec\", i), fmt.Sprintf(\"bindings[%d].name\", i)))","\t\t}","\t}","\treturn errs","}","","func (i *TriggerInterceptor) validate(ctx context.Context) (errs *apis.FieldError) {","\tif i.Webhook == nil {","\t\tif i.Ref.Name == \"\" { // Check to see if Interceptor referenced using Ref","\t\t\terrs = errs.Also(apis.ErrMissingField(\"interceptor\"))","\t\t}","\t}","","\tif i.Webhook != nil { // TODO: This should be an error?","\t\tw := i.Webhook","\t\tif i.Webhook.ObjectRef == nil {","\t\t\terrs = errs.Also(apis.ErrMissingField(\"interceptor.webhook.objectRef\"))","\t\t} else {","\t\t\tif w.ObjectRef.Kind == \"\" {","\t\t\t\terrs = errs.Also(apis.ErrMissingField(\"interceptor.webhook.objectRef.kind\"))","\t\t\t} else if w.ObjectRef.Kind != \"Service\" {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid kind\"), \"interceptor.webhook.objectRef.kind\"))","\t\t\t}","","\t\t\t// Optional explicit match","\t\t\tif w.ObjectRef.APIVersion == \"\" {","\t\t\t\terrs = errs.Also(apis.ErrMissingField(\"interceptor.webhook.objectRef.apiVersion\"))","\t\t\t} else if w.ObjectRef.APIVersion != \"v1\" {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid apiVersion\"), \"interceptor.webhook.objectRef.apiVersion\"))","\t\t\t}","\t\t}","","\t\tfor i, header := range w.Header {","\t\t\t// Enforce non-empty canonical header keys","\t\t\tif len(header.Name) == 0 || http.CanonicalHeaderKey(header.Name) != header.Name {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid header name\"), fmt.Sprintf(\"interceptor.webhook.header[%d].name\", i)))","\t\t\t}","\t\t\t// Enforce non-empty header values","\t\t\tif header.Value.Type == pipelinev1.ParamTypeString {","\t\t\t\tif len(header.Value.StringVal) == 0 {","\t\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid header value\"), fmt.Sprintf(\"interceptor.webhook.header[%d].value\", i)))","\t\t\t\t}","\t\t\t} else if len(header.Value.ArrayVal) == 0 {","\t\t\t\terrs = errs.Also(apis.ErrInvalidValue(errors.New(\"invalid header value\"), fmt.Sprintf(\"interceptor.webhook.header[%d].value\", i)))","\t\t\t}","\t\t}","\t}","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,0,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,1,1,1,0,0,2,0]},{"id":45,"path":"pkg/apis/triggers/v1beta1/version_validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package v1beta1","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"knative.dev/pkg/apis\"",")","","// ValidateEnabledAPIFields checks that the enable-api-fields feature gate is set","// to the wantVersion value and, if not, returns an error stating which feature","// is dependent on the version and what the current version actually is.","func ValidateEnabledAPIFields(ctx context.Context, featureName, wantVersion string) *apis.FieldError {","\tif apis.IsInDelete(ctx) {","\t\treturn nil","\t}","","\tcurrentVersion := config.FromContextOrDefaults(ctx).FeatureFlags.EnableAPIFields","\tif currentVersion != wantVersion {","\t\tvar errs *apis.FieldError","\t\tmessage := fmt.Sprintf(`%s requires \"enable-api-fields\" feature gate to be %q but it is %q`, featureName, wantVersion, currentVersion)","\t\treturn errs.Also(apis.ErrGeneric(message))","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,2,2,2,2,2,2,2,0]},{"id":46,"path":"pkg/apis/triggers/validation.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package triggers","","import (","\t\"knative.dev/pkg/apis\"",")","","const (","\tPayloadValidationAnnotation = \"tekton.dev/payload-validation\"",")","","func ValidateAnnotations(annotations map[string]string) *apis.FieldError {","\tvar errs *apis.FieldError","","\tif value, ok := annotations[PayloadValidationAnnotation]; ok {","\t\tif value != \"true\" \u0026\u0026 value != \"false\" {","\t\t\terrs = errs.Also(apis.ErrInvalidValue(PayloadValidationAnnotation+\" annotation must have value 'true' or 'false'\", \"metadata.annotations\"))","\t\t}","\t}","","\treturn errs","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,2,0]},{"id":47,"path":"pkg/bootstrap/bootstrap.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package bootstrap","","import (","\t\"context\"","\t\"fmt\"","","\ttriggersclientset \"github.com/tektoncd/triggers/pkg/client/clientset/versioned\"","\t\"k8s.io/client-go/kubernetes\"",")","","type Bootstrapper struct {","\tconfig           *Config","\tkubeClient       kubernetes.Interface","\ttriggersClient   triggersclientset.Interface","\tinstaller        *Installer","\trbacManager      *RBACManager","\ttemplatesManager *TemplatesManager","\tgithubManager    *GitHubManager","}","","// New creates a new bootstrapper","func New(config *Config) (*Bootstrapper, error) {","\tvar (","\t\tkubeClient     kubernetes.Interface","\t\ttriggersClient triggersclientset.Interface","\t\terr            error","\t)","\tkubeClient, err = kubernetes.NewForConfig(config.KubeConfig)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to create kubernetes client: %w\", err)","\t}","","\ttriggersClient, err = triggersclientset.NewForConfig(config.KubeConfig)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to create triggers client: %w\", err)","\t}","","\t// Create component managers","\tinstaller := NewInstaller(kubeClient, config)","\trbacManager := NewRBACManager(kubeClient, config)","\ttemplatesManager := NewTemplatesManager(triggersClient, config)","\tgithubManager := NewGitHubManager(config)","","\treturn \u0026Bootstrapper{","\t\tconfig:           config,","\t\tkubeClient:       kubeClient,","\t\ttriggersClient:   triggersClient,","\t\tinstaller:        installer,","\t\trbacManager:      rbacManager,","\t\ttemplatesManager: templatesManager,","\t\tgithubManager:    githubManager,","\t}, nil","}","","// Run executes the bootstrap process","func (b *Bootstrapper) Run(ctx context.Context) error {","\t// Check and install Tekton Pipelines","\tif err := b.installer.InstallTektonPipelines(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to ensure pipelines: %w\", err)","\t}","","\t// Install Tekton Triggers","\tif err := b.installer.InstallTriggers(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to install triggers: %w\", err)","\t}","","\t// Create/verify namespace","\tif err := b.rbacManager.CreateNamespace(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to create namespace: %w\", err)","\t}","","\t// Set up RBAC","\tif err := b.rbacManager.SetupRBAC(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to setup RBAC: %w\", err)","\t}","","\t// Create Trigger resources (EventListener, TriggerTemplate, TriggerBinding)","\tif err := b.templatesManager.CreateTriggerResources(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to create trigger resources: %w\", err)","\t}","","\t// Create examples (Pipeline)","\tif err := b.templatesManager.CreateExamples(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to create examples: %w\", err)","\t}","","\t// Check existing webhooks","\tif b.config.GitHubToken != \"\" {","\t\tif err := b.githubManager.SetupWebhook(ctx); err != nil {","\t\t\treturn fmt.Errorf(\"failed to setup webhook: %w\", err)","\t\t}","\t}","\tif err := b.rbacManager.CreateWebhookSecret(ctx, b.githubManager.GetWebhookSecret()); err != nil {","\t\treturn fmt.Errorf(\"failed to create webhook secret: %w\", err)","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0]},{"id":48,"path":"pkg/bootstrap/file_helper.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package bootstrap","","import (","\t\"context\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"","\t\"os\"","\t\"os/exec\"","\t\"path/filepath\"",")","","const (","\tgithubBaseURL = \"https://raw.githubusercontent.com/tektoncd/triggers/main\"",")","","func applyFileFromGitHub(filePath string) error {","\tctx := context.Background()","\t// Download from GitHub","\tgithubURL := fmt.Sprintf(\"%s/%s\", githubBaseURL, filePath)","","\t// Create temporary file","\ttmpFile, err := os.CreateTemp(\"\", filepath.Base(filePath)+\"-*.yaml\")","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to create temp file: %w\", err)","\t}","\tdefer os.Remove(tmpFile.Name()) // Always clean up","","\t// Download content","\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, githubURL, nil)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to create request: %w\", err)","\t}","","\tclient := \u0026http.Client{}","\tresp, err := client.Do(req)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to download %s: %w\", githubURL, err)","\t}","\tdefer resp.Body.Close()","","\tif resp.StatusCode != http.StatusOK {","\t\treturn fmt.Errorf(\"failed to download %s: HTTP %d\", githubURL, resp.StatusCode)","\t}","","\t// Write to temp file","\tif _, err = io.Copy(tmpFile, resp.Body); err != nil {","\t\treturn fmt.Errorf(\"failed to write downloaded content: %w\", err)","\t}","\ttmpFile.Close()","","\t// Apply with kubectl","\t// #nosec G204 -- kubectl is a known binary, tmpFile.Name() is a controlled temp file path","\tcmd := exec.Command(\"kubectl\", \"apply\", \"-f\", tmpFile.Name(), \"-n\", \"getting-started\")","\toutput, err := cmd.CombinedOutput()","\tif err != nil {","\t\treturn fmt.Errorf(\"kubectl apply failed for %s: %w\\nOutput: %s\", filePath, err, string(output))","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0]},{"id":49,"path":"pkg/bootstrap/github.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package bootstrap","","import (","\t\"bytes\"","\t\"context\"","\t\"crypto/rand\"","\t\"encoding/hex\"","\t\"encoding/json\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"","\t\"strings\"",")","","type GitHubManager struct {","\tconfig *Config","\tclient *http.Client","}","","func NewGitHubManager(config *Config) *GitHubManager {","\treturn \u0026GitHubManager{","\t\tconfig: config,","\t\tclient: \u0026http.Client{},","\t}","}","","// WebhookPayload represents the GitHub webhook payload","type WebhookPayload struct {","\tName   string        `json:\"name\"`","\tConfig WebhookConfig `json:\"config\"`","\tEvents []string      `json:\"events\"`","\tActive bool          `json:\"active\"`","}","","// WebhookConfig represents webhook configuration","type WebhookConfig struct {","\tURL         string `json:\"url\"`","\tContentType string `json:\"content_type\"`","\tSecret      string `json:\"secret,omitempty\"`","\tInsecureSSL string `json:\"insecure_ssl\"`","}","","// SetupWebhook creates a GitHub webhook for the repository","func (g *GitHubManager) SetupWebhook(ctx context.Context) error {","\t// Generate webhook secret","\tsecret := g.config.WebhookSecret","\tif secret == \"\" {","\t\tvar err error","\t\tsecret, err = generateWebhookSecret()","\t\tif err != nil {","\t\t\treturn fmt.Errorf(\"failed to generate webhook secret: %w\", err)","\t\t}","\t\tg.config.WebhookSecret = secret","\t}","","\t// Create webhook","\twebhookURL := fmt.Sprintf(\"https://%s/hooks\", g.config.PublicDomain)","","\tpayload := WebhookPayload{","\t\tName: \"web\",","\t\tConfig: WebhookConfig{","\t\t\tURL:         webhookURL,","\t\t\tContentType: \"json\",","\t\t\tSecret:      secret,","\t\t\tInsecureSSL: \"0\", // Always use SSL in production","\t\t},","\t\tEvents: []string{\"push\", \"pull_request\"},","\t\tActive: true,","\t}","","\tif err := g.createWebhook(ctx, payload); err != nil {","\t\treturn fmt.Errorf(\"failed to create webhook: %w\", err)","\t}","","\treturn nil","}","","// createWebhook makes the API call to create the webhook","func (g *GitHubManager) createWebhook(ctx context.Context, payload WebhookPayload) error {","\tjsonPayload, err := json.Marshal(payload)","\tif err != nil {","\t\treturn err","\t}","","\turl := fmt.Sprintf(\"https://api.github.com/repos/%s/hooks\", g.config.GitHubRepo)","\treq, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(jsonPayload))","\tif err != nil {","\t\treturn err","\t}","","\treq.Header.Set(\"Authorization\", \"token \"+g.config.GitHubToken)","\treq.Header.Set(\"Accept\", \"application/vnd.github.v3+json\")","\treq.Header.Set(\"Content-Type\", \"application/json\")","","\tresp, err := g.client.Do(req)","\tif err != nil {","\t\treturn err","\t}","\tdefer resp.Body.Close()","","\tif resp.StatusCode != http.StatusCreated {","\t\tbody, _ := io.ReadAll(resp.Body)","\t\tif resp.StatusCode == http.StatusUnprocessableEntity \u0026\u0026 strings.Contains(string(body), \"Hook already exists\") {","\t\t\treturn errors.New(\"webhook already exists\")","\t\t}","\t\treturn fmt.Errorf(\"GitHub API error: %s - %s\", resp.Status, string(body))","\t}","","\treturn nil","}","","// generateWebhookSecret generates a secure random webhook secret","func generateWebhookSecret() (string, error) {","\tbytes := make([]byte, 32)","\tif _, err := rand.Read(bytes); err != nil {","\t\treturn \"\", err","\t}","\treturn hex.EncodeToString(bytes), nil","}","","// GetWebhookSecret returns the webhook secret for storing in Kubernetes","func (g *GitHubManager) GetWebhookSecret() string {","\treturn g.config.WebhookSecret","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,1,1,1,0,0,0,2,2,2]},{"id":50,"path":"pkg/bootstrap/installer.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package bootstrap","","import (","\t\"context\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"log\"","\t\"net/http\"","\t\"os\"","\t\"os/exec\"","\t\"time\"","","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/util/wait\"","\t\"k8s.io/client-go/kubernetes\"",")","","type Installer struct {","\tkubeClient      kubernetes.Interface","\tconfig          *Config","\ttektonNamespace string","}","","func NewInstaller(kubeClient kubernetes.Interface, config *Config) *Installer {","\treturn \u0026Installer{","\t\tkubeClient:      kubeClient,","\t\tconfig:          config,","\t\ttektonNamespace: \"\",","\t}","}","","func (i *Installer) getTektonNamespace(ctx context.Context) string {","\tif i.tektonNamespace != \"\" {","\t\treturn i.tektonNamespace","\t}","","\tnamespaces := []string{","\t\t\"openshift-pipelines\",","\t\t\"tekton-pipelines\",","\t}","","\tfor _, ns := range namespaces {","\t\t_, err := i.kubeClient.AppsV1().Deployments(ns).Get(ctx, \"tekton-pipelines-controller\", metav1.GetOptions{})","\t\tif err == nil {","\t\t\ti.tektonNamespace = ns","\t\t\tlog.Printf(\"Tekton Pipelines is installed in %s namespace.\", ns)","\t\t\treturn i.tektonNamespace","\t\t}","\t}","","\t// Default to tekton-pipelines if not found","\ti.tektonNamespace = \"tekton-pipelines\"","\treturn i.tektonNamespace","}","","// common helper for polling","func (i *Installer) pollUntilReady(ctx context.Context, timeout time.Duration, condition wait.ConditionWithContextFunc) error {","\tdeadline := time.Now().Add(timeout)","\tctx, cancel := context.WithDeadline(ctx, deadline)","\tdefer cancel()","","\treturn wait.PollUntilContextTimeout(ctx, 5*time.Second, timeout, true, condition)","}","","// waitForNamespace waits for a namespace to exist and ready","func (i *Installer) waitForNamespace(ctx context.Context, namespace string, timeout time.Duration) error {","\tif i.kubeClient == nil {","\t\treturn nil","\t}","","\treturn i.pollUntilReady(ctx, timeout, func(ctx context.Context) (bool, error) {","\t\tns, err := i.kubeClient.CoreV1().Namespaces().Get(ctx, namespace, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tif apierrors.IsNotFound(err) {","\t\t\t\treturn false, nil","\t\t\t}","\t\t\treturn false, err","\t\t}","","\t\t// Check if namespace is ready","\t\tif ns.Status.Phase != \"Active\" {","\t\t\treturn false, nil","\t\t}","","\t\treturn true, nil","\t})","}","","// waitForDeployment waits for a deployment to ready","func (i *Installer) waitForDeployment(ctx context.Context, namespace, name string, timeout time.Duration) error {","\tif i.kubeClient == nil {","\t\treturn nil","\t}","","\treturn i.pollUntilReady(ctx, timeout, func(ctx context.Context) (bool, error) {","\t\tdeployment, err := i.kubeClient.AppsV1().Deployments(namespace).Get(ctx, name, metav1.GetOptions{})","\t\tif err != nil {","\t\t\tif apierrors.IsNotFound(err) {","\t\t\t\treturn false, nil","\t\t\t}","\t\t\treturn false, err","\t\t}","","\t\t// Check if deployment is ready","\t\tif deployment.Status.ReadyReplicas == 0 || deployment.Status.ReadyReplicas \u003c *deployment.Spec.Replicas {","\t\t\treturn false, nil","\t\t}","","\t\treturn true, nil","\t})","}","","// InstallTriggers installs Tekton Triggers CRDs and controllers","func (i *Installer) InstallTriggers(ctx context.Context) error {","\t// Check if Triggers is already installed","\tif i.isTriggersInstalled(ctx) {","\t\tlog.Println(\"Tekton Triggers is installed and running.\")","\t\treturn nil","\t}","\tif err := i.downloadAndApplyTriggers(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to install Triggers: %w\", err)","\t}","","\tlog.Println(\"Waiting for Tekton Triggers to be ready...\")","\treturn i.waitForTriggersReady(ctx)","}","","func (i *Installer) isTriggersInstalled(ctx context.Context) bool {","\tif i.kubeClient == nil {","\t\treturn false","\t}","\tns := i.getTektonNamespace(ctx)","\tdeployment, err := i.kubeClient.AppsV1().Deployments(ns).Get(ctx, \"tekton-triggers-controller\", metav1.GetOptions{})","\tif err != nil {","\t\treturn false","\t}","\treturn deployment.Status.ReadyReplicas \u003e 0","}","","// waitForTriggersReady waits for Tekton Triggers components to be ready","func (i *Installer) waitForTriggersReady(ctx context.Context) error {","\tns := i.getTektonNamespace(ctx)","\tif err := i.waitForNamespace(ctx, ns, 2*time.Minute); err != nil {","\t\treturn fmt.Errorf(\"timeout waiting for %s namespace: %w\", ns, err)","\t}","","\t// Wait for Triggers controller deployment to be ready","\tif err := i.waitForDeployment(ctx, ns, \"tekton-triggers-controller\", 3*time.Minute); err != nil {","\t\treturn fmt.Errorf(\"timeout waiting for tekton-triggers-controller: %w\", err)","\t}","","\tlog.Println(\"Tekton Triggers is ready!\")","\treturn nil","}","","// InstallTektonPipelines installs Tekton Pipelines if requested and not present","func (i *Installer) InstallTektonPipelines(ctx context.Context) error {","\tif !i.config.InstallDeps {","\t\t// Check if Pipelines is installed, it's required for Triggers","\t\tif !i.isPipelinesInstalled(ctx) {","\t\t\treturn errors.New(\"tekton Pipelines is not installed and is required for Triggers\")","\t\t}","\t\treturn nil","\t}","","\tif i.isPipelinesInstalled(ctx) {","\t\tlog.Println(\"Tekton Pipelines is installed and running.\")","\t\treturn nil","\t}","","\tif err := i.downloadAndApplyPipelines(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to install Pipelines: %w\", err)","\t}","","\t// Wait for Pipelines to be ready before continuing","\tlog.Println(\"Waiting for Pipelines to be ready, this may take a minute or two...\")","\tif err := i.waitForPipelinesReady(ctx); err != nil {","\t\treturn fmt.Errorf(\"failed to wait for Pipelines: %w\", err)","\t}","","\tlog.Println(\"Tekton Pipelines is ready!\")","\treturn nil","}","","// isPipelinesInstalled checks if Tekton Pipelines is installed and ready","func (i *Installer) isPipelinesInstalled(ctx context.Context) bool {","\tif i.kubeClient == nil {","\t\treturn false","\t}","\tns := i.getTektonNamespace(ctx)","\tdeployment, err := i.kubeClient.AppsV1().Deployments(ns).Get(ctx, \"tekton-pipelines-controller\", metav1.GetOptions{})","\tif err != nil {","\t\treturn false","\t}","\treturn deployment.Status.ReadyReplicas \u003e 0","}","","func (i *Installer) downloadAndApplyTriggers(ctx context.Context) error {","\ttriggersURL := \"https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml\"","\tinterceptorsURL := \"https://storage.googleapis.com/tekton-releases/triggers/latest/interceptors.yaml\"","","\tif err := i.downloadAndApplyManifest(ctx, triggersURL); err != nil {","\t\treturn fmt.Errorf(\"failed to apply triggers manifest: %w\", err)","\t}","","\tif err := i.downloadAndApplyManifest(ctx, interceptorsURL); err != nil {","\t\treturn fmt.Errorf(\"failed to apply interceptors manifest: %w\", err)","\t}","","\treturn nil","}","","func (i *Installer) downloadAndApplyPipelines(ctx context.Context) error {","\tpipelinesURL := \"https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml\"","","\tif err := i.downloadAndApplyManifest(ctx, pipelinesURL); err != nil {","\t\treturn fmt.Errorf(\"failed to apply pipelines manifest: %w\", err)","\t}","","\treturn nil","}","","// downloadAndApplyManifest downloads a YAML manifest from URL and applies it to the cluster","func (i *Installer) downloadAndApplyManifest(ctx context.Context, url string) error {","\t// Download the manifest","\treq, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to create request: %w\", err)","\t}","","\tclient := \u0026http.Client{}","\tresp, err := client.Do(req)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to download manifest: %w\", err)","\t}","\tdefer resp.Body.Close()","","\tif resp.StatusCode != http.StatusOK {","\t\treturn fmt.Errorf(\"failed to download manifest: HTTP %d\", resp.StatusCode)","\t}","","\t// Read the YAML content","\tyamlContent, err := io.ReadAll(resp.Body)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to read manifest: %w\", err)","\t}","","\t// Apply the manifest using kubectl-like logic","\tif err := i.applyYAMLManifest(ctx, yamlContent); err != nil {","\t\treturn fmt.Errorf(\"failed to apply manifest: %w\", err)","\t}","","\treturn nil","}","","// applyYAMLManifest applies a multi-document YAML manifest","func (i *Installer) applyYAMLManifest(ctx context.Context, yamlContent []byte) error {","\tif err := i.applyManifestViaKubectl(ctx, yamlContent); err != nil {","\t\treturn fmt.Errorf(\"failed to apply manifest: %w\", err)","\t}","","\treturn nil","}","","// applyManifestViaKubectl applies YAML using kubectl apply","func (i *Installer) applyManifestViaKubectl(ctx context.Context, yamlContent []byte) error {","\t// Write YAML to temporary file","\ttmpFile, err := os.CreateTemp(\"\", \"tekton-manifest-*.yaml\")","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to create temp file: %w\", err)","\t}","\tdefer os.Remove(tmpFile.Name())","\tdefer tmpFile.Close()","","\tif _, err := tmpFile.Write(yamlContent); err != nil {","\t\treturn fmt.Errorf(\"failed to write manifest: %w\", err)","\t}","\ttmpFile.Close()","","\tkubeconfigFlag := \"\"","\tif i.config.KubeConfig != nil {","\t\tkubeconfigFlag = \"--kubeconfig=\" + os.Getenv(\"HOME\") + \"/.kube/config\"","\t}","","\t// #nosec G204 -- kubectl is a known binary, tmpFile.Name() is a controlled temp file path","\tcmd := exec.CommandContext(ctx, \"kubectl\", \"apply\", \"-f\", tmpFile.Name())","\tif kubeconfigFlag != \"\" {","\t\t// #nosec G204 -- kubectl is a known binary, tmpFile.Name() is a controlled temp file path","\t\tcmd = exec.CommandContext(ctx, \"kubectl\", kubeconfigFlag, \"apply\", \"-f\", tmpFile.Name())","\t}","","\toutput, err := cmd.CombinedOutput()","\tif err != nil {","\t\treturn fmt.Errorf(\"kubectl apply failed: %w\\nOutput: %s\", err, string(output))","\t}","","\treturn nil","}","","// waitForPipelinesReady waits for Tekton Pipelines to be fully ready","func (i *Installer) waitForPipelinesReady(ctx context.Context) error {","\tns := i.getTektonNamespace(ctx)","","\t// Wait for the Tekton namespace","\tif err := i.waitForNamespace(ctx, ns, 2*time.Minute); err != nil {","\t\treturn fmt.Errorf(\"timeout waiting for %s namespace: %w\", ns, err)","\t}","","\t// Wait for Pipelines controller deployment to be ready","\tif err := i.waitForDeployment(ctx, ns, \"tekton-pipelines-controller\", 5*time.Minute); err != nil {","\t\treturn fmt.Errorf(\"timeout waiting for tekton-pipelines-controller: %w\", err)","\t}","","\t// Wait for webhook deployment to be ready","\tif err := i.waitForDeployment(ctx, ns, \"tekton-pipelines-webhook\", 3*time.Minute); err != nil {","\t\treturn fmt.Errorf(\"timeout waiting for tekton-pipelines-webhook: %w\", err)","\t}","","\t// buffer for webhook service to be fully responsive","\ttime.Sleep(10 * time.Second)","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,0,0,2,2,1,1,2,2,2,2,2,2,0,0,0,1,1,1,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,2,2,1,1,2,2,2,2,2,2,0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,0]},{"id":51,"path":"pkg/bootstrap/rbac.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package bootstrap","","import (","\t\"context\"","\t\"fmt\"","","\tcorev1 \"k8s.io/api/core/v1\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/client-go/kubernetes\"",")","","type RBACManager struct {","\tkubeClient kubernetes.Interface","\tconfig     *Config","}","","func NewRBACManager(kubeClient kubernetes.Interface, config *Config) *RBACManager {","\treturn \u0026RBACManager{","\t\tkubeClient: kubeClient,","\t\tconfig:     config,","\t}","}","","// CreateNamespace creates the target namespace if it doesn't exist","func (r *RBACManager) CreateNamespace(ctx context.Context) error {","\tns := \u0026corev1.Namespace{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName: r.config.Namespace,","\t\t\tLabels: map[string]string{","\t\t\t\t\"app.kubernetes.io/part-of\": \"tekton-triggers\",","\t\t\t\t\"tekton.dev/bootstrap\":      \"true\",","\t\t\t},","\t\t},","\t}","","\t_, err := r.kubeClient.CoreV1().Namespaces().Create(ctx, ns, metav1.CreateOptions{})","\tif apierrors.IsAlreadyExists(err) {","\t\treturn nil","\t}","","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to create namespace: %w\", err)","\t}","\treturn nil","}","","// SetupRBAC creates necessary service accounts, roles, and bindings","func (r *RBACManager) SetupRBAC(ctx context.Context) error {","\t// Apply admin-role.yaml (ServiceAccount + RoleBinding + ClusterRoleBinding)","\tif err := r.applyGettingStartedRBAC(ctx); err != nil {","\t\treturn err","\t}","","\t// Apply webhook-role.yaml (Role + ServiceAccount + RoleBinding for webhook tasks)","\tif err := r.applyWebhookRBAC(ctx); err != nil {","\t\treturn err","\t}","","\treturn nil","}","","// applyGettingStartedRBAC applies the admin-role.yaml from getting-started docs","func (r *RBACManager) applyGettingStartedRBAC(ctx context.Context) error {","\tif err := applyFileFromGitHub(\"docs/getting-started/rbac/admin-role.yaml\"); err != nil {","\t\treturn fmt.Errorf(\"failed to apply admin-role.yaml: %w\", err)","\t}","","\tif err := applyFileFromGitHub(\"docs/getting-started/rbac/clusterrolebinding.yaml\"); err != nil {","\t\treturn fmt.Errorf(\"failed to apply clusterrolebinding.yaml: %w\", err)","\t}","\treturn nil","}","","// applyWebhookRBAC applies webhook-role.yaml from getting-started docs","func (r *RBACManager) applyWebhookRBAC(ctx context.Context) error {","\tif err := applyFileFromGitHub(\"docs/getting-started/rbac/webhook-role.yaml\"); err != nil {","\t\treturn fmt.Errorf(\"failed to apply webhook-role.yaml: %w\", err)","\t}","\treturn nil","}","","// CreateWebhookSecret creates a Kubernetes secret for webhook authentication","func (r *RBACManager) CreateWebhookSecret(ctx context.Context, webhookSecret string) error {","\tsecret := \u0026corev1.Secret{","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:      \"github-webhook-secret\",","\t\t\tNamespace: r.config.Namespace,","\t\t\tLabels: map[string]string{","\t\t\t\t\"app.kubernetes.io/part-of\": \"tekton-triggers\",","\t\t\t\t\"tekton.dev/bootstrap\":      \"true\",","\t\t\t},","\t\t},","\t\tType: corev1.SecretTypeOpaque,","\t\tData: map[string][]byte{","\t\t\t\"webhook-secret\": []byte(webhookSecret),","\t\t},","\t}","","\t_, err := r.kubeClient.CoreV1().Secrets(r.config.Namespace).Create(ctx, secret, metav1.CreateOptions{})","\tif apierrors.IsAlreadyExists(err) {","\t\treturn nil","\t}","","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to create webhook secret: %w\", err)","\t}","","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0]},{"id":52,"path":"pkg/bootstrap/templates.go","lines":["/*","Copyright 2025 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package bootstrap","","import (","\t\"context\"","\t\"fmt\"","","\ttriggersclientset \"github.com/tektoncd/triggers/pkg/client/clientset/versioned\"",")","","// TemplatesManager handles creation of Trigger templates and resources","type TemplatesManager struct {","\ttriggersClient triggersclientset.Interface","\tconfig         *Config","}","","// NewTemplatesManager creates a new templates manager","func NewTemplatesManager(triggersClient triggersclientset.Interface, config *Config) *TemplatesManager {","\treturn \u0026TemplatesManager{","\t\ttriggersClient: triggersClient,","\t\tconfig:         config,","\t}","}","","// CreateTriggerResources creates Trigger resources from getting-started docs","func (t *TemplatesManager) CreateTriggerResources(ctx context.Context) error {","\treturn t.applyGettingStartedTriggers(ctx)","}","","// CreateExamples creates the Pipeline from getting-started docs","func (t *TemplatesManager) CreateExamples(ctx context.Context) error {","\treturn t.applyGettingStartedPipeline(ctx)","}","","// applyGettingStartedTriggers applies triggers.yaml from getting-started docs","func (t *TemplatesManager) applyGettingStartedTriggers(ctx context.Context) error {","\tif err := applyFileFromGitHub(\"docs/getting-started/triggers.yaml\"); err != nil {","\t\treturn fmt.Errorf(\"failed to apply triggers.yaml: %w\", err)","\t}","\treturn nil","}","","// applyGettingStartedPipeline applies pipeline.yaml from getting-started docs","func (t *TemplatesManager) applyGettingStartedPipeline(ctx context.Context) error {","\tif err := applyFileFromGitHub(\"docs/getting-started/pipeline.yaml\"); err != nil {","\t\treturn fmt.Errorf(\"failed to apply pipeline.yaml: %w\", err)","\t}","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0]},{"id":53,"path":"pkg/dynamic/custom_reconcile.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package dynamic","","import (","\t\"encoding/json\"","","\tlogger \"github.com/sirupsen/logrus\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"knative.dev/pkg/apis/duck/v1beta1\"",")","","func GetConditions(existingData *unstructured.Unstructured) (v1beta1.Conditions, interface{}, error) {","\tstatusData, ok, err := unstructured.NestedMap(existingData.Object, \"status\")","\tif !ok || err != nil {","\t\t// No status in the created object, it is weird but let's not fail","\t\tlogger.Warn(\"empty status for the created custom object\")","\t\treturn nil, nil, err","\t}","\tconditionData, ok, err := unstructured.NestedFieldCopy(statusData, \"conditions\")","\tif !ok || err != nil {","\t\t// No conditions in the created object, it is weird but let's not fail","\t\tlogger.Warn(\"empty status conditions for the created custom object\")","\t\treturn nil, nil, err","\t}","\tcMarshalledData, err := json.Marshal(conditionData)","\tif err != nil {","\t\treturn nil, nil, err","\t}","\tvar customConditions v1beta1.Conditions","\tif err = json.Unmarshal(cMarshalledData, \u0026customConditions); err != nil {","\t\treturn nil, nil, err","\t}","\treturn customConditions, statusData[\"url\"], nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,2,0]},{"id":54,"path":"pkg/dynamic/dynamic.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package dynamic","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\t\"k8s.io/client-go/tools/cache\"","\t\"knative.dev/pkg/apis/duck\"","\t\"knative.dev/pkg/controller\"",")","","type ListableTracker interface {","\tWatchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error","}","","type listableTracker struct {","\tinformerFactory duck.InformerFactory","\timpl            *controller.Impl","}","","// NewListableTracker creates a new ListableTracker, backed by a TypedInformerFactory.","func NewListableTracker(ctx context.Context, getter func(ctx context.Context) duck.InformerFactory, impl *controller.Impl) ListableTracker {","\treturn \u0026listableTracker{","\t\tinformerFactory: getter(ctx),","\t\timpl:            impl,","\t}","}","","func (t *listableTracker) WatchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error {","\treturn t.watchOnDynamicObject(ctx, gvr)","}","","func (t *listableTracker) watchOnDynamicObject(ctx context.Context, gvr schema.GroupVersionResource) error {","\tshInformer, _, err := t.informerFactory.Get(ctx, gvr)","\tif err != nil {","\t\treturn err","\t}","\t_, err = shInformer.AddEventHandler(cache.FilteringResourceEventHandler{","\t\tFilterFunc: controller.FilterController(\u0026v1beta1.EventListener{}),","\t\tHandler:    controller.HandleAll(t.impl.EnqueueControllerOf),","\t})","\treturn err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,0]},{"id":55,"path":"pkg/interceptors/bitbucket/bitbucket.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package bitbucket","","import (","\t\"context\"","\t\"net/http\"","","\tgh \"github.com/google/go-github/v31/github\"","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","\t\"google.golang.org/grpc/codes\"",")","","var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)","","type InterceptorImpl struct {","\tSecretGetter interceptors.SecretGetter","}","","func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl {","\treturn \u0026InterceptorImpl{","\t\tSecretGetter: sg,","\t}","}","","// InterceptorParams provides a webhook to intercept and pre-process events","type InterceptorParams struct {","\tSecretRef *triggersv1.SecretRef `json:\"secretRef,omitempty\"`","\t// +listType=atomic","\tEventTypes []string `json:\"eventTypes,omitempty\"`","}","","func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse {","\tp := InterceptorParams{}","\tif err := interceptors.UnmarshalParams(r.InterceptorParams, \u0026p); err != nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"failed to parse interceptor params: %v\", err)","\t}","","\theaders := interceptors.Canonical(r.Header)","","\t// Check if the event type is in the allow-list","\tif p.EventTypes != nil {","\t\tactualEvent := http.Header(r.Header).Get(\"X-Event-Key\")","\t\tisAllowed := false","\t\tfor _, allowedEvent := range p.EventTypes {","\t\t\tif actualEvent == allowedEvent {","\t\t\t\tisAllowed = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !isAllowed {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"event type %s is not allowed\", actualEvent)","\t\t}","\t}","","\t// Next validate secrets if set","\tif p.SecretRef != nil {","\t\t// Check the secret to see if it is empty","\t\tif p.SecretRef.SecretKey == \"\" {","\t\t\treturn interceptors.Fail(codes.FailedPrecondition, \"bitbucket interceptor secretRef.secretKey is empty\")","\t\t}","\t\theader := headers.Get(\"X-Hub-Signature\")","\t\tif header == \"\" {","\t\t\treturn interceptors.Fail(codes.InvalidArgument, \"no X-Hub-Signature header set\")","\t\t}","","\t\tif r.Context == nil {","\t\t\treturn interceptors.Failf(codes.InvalidArgument, \"no request context passed\")","\t\t}","","\t\tns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)","\t\tsecretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error getting secret: %v\", err)","\t\t}","","\t\tif err := gh.ValidateSignature(header, []byte(r.Body), secretToken); err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error validating signature: %s\", err.Error())","\t\t}","\t}","","\treturn \u0026triggersv1.InterceptorResponse{","\t\tContinue: true,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,1,1,0,2,2,2,1,1,0,2,2,2,0,0,2,2,2,0]},{"id":56,"path":"pkg/interceptors/cel/cel.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package cel","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"net/http\"","\t\"reflect\"","","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","","\tstructpb \"github.com/golang/protobuf/ptypes/struct\"","\t\"github.com/google/cel-go/cel\"","\t\"github.com/google/cel-go/common/decls\"","\t\"github.com/google/cel-go/common/types\"","\t\"github.com/google/cel-go/common/types/ref\"","\t\"github.com/google/cel-go/common/types/traits\"","\tcelext \"github.com/google/cel-go/ext\"","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"github.com/tidwall/sjson\"","\t\"google.golang.org/grpc/codes\"","\t\"google.golang.org/protobuf/encoding/protojson\"","\t\"google.golang.org/protobuf/proto\"",")","","var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)","","// InterceptorImpl implements a CEL based interceptor that uses CEL expressions","// against the incoming body and headers to match, if the expression returns","// a true value, then the interception is \"successful\".","type InterceptorImpl struct {","\tSecretGetter     interceptors.SecretGetter","\tCEL              *InterceptorParams","\tTriggerNamespace string","}","","var (","\tstructType = reflect.TypeOf(\u0026structpb.Value{})","\tlistType   = reflect.TypeOf(\u0026structpb.ListValue{})","\tmapType    = reflect.TypeOf(\u0026structpb.Struct{})",")","","// NewInterceptor creates a prepopulated Interceptor.","func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl {","\treturn \u0026InterceptorImpl{","\t\tSecretGetter: sg,","\t}","}","","// InterceptorParams provides a webhook to intercept and pre-process events","type InterceptorParams struct {","\tFilter string `json:\"filter,omitempty\"`","\t// +listType=atomic","\tOverlays []Overlay `json:\"overlays,omitempty\"`","}","","// Overlay provides a way to modify the request body using CEL expressions","type Overlay struct {","\tKey        string `json:\"key,omitempty\"`","\tExpression string `json:\"expression,omitempty\"`","}","","func evaluate(expr string, env *cel.Env, data map[string]interface{}) (ref.Val, error) {","\tparsed, issues := env.Parse(expr)","\tif issues != nil \u0026\u0026 issues.Err() != nil {","\t\treturn nil, fmt.Errorf(\"failed to parse expression %#v: %w\", expr, issues.Err())","\t}","","\tchecked, issues := env.Check(parsed)","\tif issues != nil \u0026\u0026 issues.Err() != nil {","\t\treturn nil, fmt.Errorf(\"expression %#v check failed: %w\", expr, issues.Err())","\t}","","\tprg, err := env.Program(checked, cel.EvalOptions(cel.OptOptimize))","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"expression %#v failed to create a Program: %w\", expr, err)","\t}","","\tout, _, err := prg.Eval(data)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"expression %#v failed to evaluate: %w\", expr, err)","\t}","\treturn out, nil","}","","func makeCelEnv(ctx context.Context, ns string, sg interceptors.SecretGetter) (*cel.Env, error) {","\tmapStrDyn := types.NewMapType(types.StringType, types.DynType)","","\treturn cel.NewEnv(","\t\tTriggers(ctx, ns, sg),","\t\tcelext.Strings(),","\t\tcelext.Encoders(),","\t\tcelext.Sets(),","\t\tcelext.Lists(),","\t\tcelext.Math(),","\t\tcel.VariableDecls(","\t\t\tdecls.NewVariable(\"body\", mapStrDyn),","\t\t\tdecls.NewVariable(\"header\", mapStrDyn),","\t\t\tdecls.NewVariable(\"extensions\", mapStrDyn),","\t\t\tdecls.NewVariable(\"requestURL\", types.StringType),","\t\t))","}","","func makeEvalContext(body []byte, h http.Header, url string, extensions map[string]interface{}) (map[string]interface{}, error) {","\tvar jsonMap map[string]interface{}","\terr := json.Unmarshal(body, \u0026jsonMap)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to parse the body as JSON: %w\", err)","\t}","\treturn map[string]interface{}{","\t\t\"body\":       jsonMap,","\t\t\"header\":     h,","\t\t\"requestURL\": url,","\t\t\"extensions\": extensions,","\t}, nil","}","","func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse {","\tp := InterceptorParams{}","\tif err := interceptors.UnmarshalParams(r.InterceptorParams, \u0026p); err != nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"failed to parse interceptor params: %v\", err)","\t}","","\tif r.Context == nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"no request context passed\")","\t}","","\tns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)","\tenv, err := makeCelEnv(ctx, ns, w.SecretGetter)","\tif err != nil {","\t\treturn interceptors.Failf(codes.Internal, \"error creating cel environment: %v\", err)","\t}","","\tvar payload = []byte(`{}`)","\tif r.Body != \"\" {","\t\tpayload = []byte(r.Body)","\t}","","\tevalContext, err := makeEvalContext(payload, r.Header, r.Context.EventURL, r.Extensions)","\tif err != nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"error making the evaluation context: %v\", err)","\t}","","\tif p.Filter != \"\" {","\t\tout, err := evaluate(p.Filter, env, evalContext)","","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.InvalidArgument, \"error evaluating cel expression: %v\", err)","\t\t}","","\t\tif out != types.True {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"expression %s did not return true\", p.Filter)","\t\t}","\t}","","\t// Empty JSON body bytes.","\t// We use []byte instead of map[string]interface{} to allow ovewriting keys using sjson.","\tvar extensions []byte","\tfor _, u := range p.Overlays {","\t\tval, err := evaluate(u.Expression, env, evalContext)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.InvalidArgument, \"error evaluating cel expression: %v\", err)","\t\t}","","\t\tvar raw interface{}","\t\tvar b []byte","","\t\tswitch val.(type) {","\t\t// this causes types.Bytes to be rendered as a Base64 string this is","\t\t// because the Go JSON Encoder encodes []bytes this way, see","\t\t// https://golang.org/pkg/encoding/json/#Marshal","\t\t//","\t\t// An alternative might be to return \" + val + \" for types.Bytes to","\t\t// simulate the JSON encoding.","\t\tcase types.String, types.Bytes:","\t\t\traw, err = val.ConvertToNative(structType)","\t\t\tif err == nil {","\t\t\t\tb, err = raw.(*structpb.Value).MarshalJSON()","\t\t\t}","\t\tcase types.Double, types.Int:","\t\t\traw, err = val.ConvertToNative(structType)","\t\t\tif err == nil {","\t\t\t\tb, err = raw.(*structpb.Value).MarshalJSON()","\t\t\t}","\t\tcase traits.Lister:","\t\t\traw, err = val.ConvertToNative(listType)","\t\t\tif err == nil {","\t\t\t\ts, err := protojson.Marshal(raw.(proto.Message))","\t\t\t\tif err == nil {","\t\t\t\t\tb = s","\t\t\t\t}","\t\t\t}","\t\tcase traits.Mapper:","\t\t\traw, err = val.ConvertToNative(mapType)","\t\t\tif err == nil {","\t\t\t\ts, err := protojson.Marshal(raw.(proto.Message))","\t\t\t\tif err == nil {","\t\t\t\t\tb = s","\t\t\t\t}","\t\t\t}","\t\tcase types.Bool:","\t\t\traw, err = val.ConvertToNative(structType)","\t\t\tif err == nil {","\t\t\t\tb, err = json.Marshal(raw.(*structpb.Value).GetBoolValue())","\t\t\t}","\t\tdefault:","\t\t\traw, err = val.ConvertToNative(reflect.TypeOf([]byte{}))","\t\t\tif err == nil {","\t\t\t\tb = raw.([]byte)","\t\t\t}","\t\t}","","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.Internal, \"failed to convert overlay result to type: %v\", err)","\t\t}","","\t\t// TODO: For backwards compatibility, consider also merging and returning the body back?","\t\tif extensions == nil {","\t\t\textensions = []byte(\"{}\")","\t\t}","\t\textensions, err = sjson.SetRawBytes(extensions, u.Key, b)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.Internal, \"failed to sjson for key '%s' to '%s': %v\", u.Key, val, err)","\t\t}","\t}","","\tif extensions == nil {","\t\treturn \u0026triggersv1.InterceptorResponse{","\t\t\tContinue: true,","\t\t}","\t}","","\textensionsMap := map[string]interface{}{}","\tif err := json.Unmarshal(extensions, \u0026extensionsMap); err != nil {","\t\treturn interceptors.Failf(codes.Internal, \"failed to unmarshal extensions into map: %v\", err)","\t}","\treturn \u0026triggersv1.InterceptorResponse{","\t\tContinue:   true,","\t\tExtensions: extensionsMap,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,0,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,1,1,0,2,2,2,1,1,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,0,0,0,0,2,2,2,2,2,2,0,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,1,1,1,1,1,0,0,2,1,1,0,0,2,2,2,2,2,1,1,0,0,2,2,2,2,2,0,2,2,1,1,2,2,2,2,0]},{"id":57,"path":"pkg/interceptors/cel/triggers.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","package cel","","import (","\t\"context\"","\t\"crypto/subtle\"","\t\"encoding/json\"","\t\"net/http\"","\t\"net/url\"","\t\"reflect\"","\t\"regexp\"","\t\"strings\"","","\t\"github.com/google/cel-go/cel\"","\t\"github.com/google/cel-go/common/types\"","\t\"github.com/google/cel-go/common/types/ref\"","\t\"github.com/google/cel-go/common/types/traits\"","\t\"github.com/google/cel-go/interpreter/functions\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","\t\"sigs.k8s.io/yaml\"","","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"",")","","// Triggers returns a cel.EnvOption to configure extended functions for","// Tekton CEL interceptor expressions.","//","// match","//","// Returns true if the specified provided header matches the provided string","// key.","//","// It is case insensitive; the header is canonicalised using the rules described","// here https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey","//","//     \u003cheader\u003e.match(\u003cstring\u003e, \u003cstring\u003e) -\u003e \u003cbool\u003e","//","// Examples:","//","//     header.match('X-Github-Event', 'push')","//","// canonical","//","// Can only be applied to the `header` key in the CEL expression context.","//","// Gets the first value associated with the given key. If there are no values","// associated with the key, returns \"\".","//","// It is case insensitive; the header is canonicalised using the rules described","// here https://golang.org/pkg/net/textproto/#CanonicalMIMEHeaderKey","//","//     \u003cheader\u003e.canonical(\u003cstring\u003e) -\u003e \u003cstring\u003e","//","// Examples:","//","//     header.canonical('X-Github-Event') // returns 'push'","//","// truncate","//","// Returns a truncated copy of the string, at the given position.","//","// If the requested length is longer than the actual length, then the string","// will be returned unchanged.","//","//     \u003cstring\u003e.truncate(\u003cint\u003e) -\u003e \u003cstring\u003e","//","// Examples:","//","//     body.request.sha.truncate(7) // returns truncated string","//","// compareSecret","//","// Returns true if the string matches the value from a Kubernetes secret with","// the provided key, secret-name, namespace combination.","//","//     \u003cstring\u003e.compareSecret(\u003cstring\u003e, \u003cstring\u003e, \u003cstring\u003e) -\u003e \u003cbool\u003e","//","// Examples:","//","//     header.canonical('X-Secret-Token').compareSecret('key', 'secret-name', 'namespace')","//","// There is also an alternative compareSecret which accepts two parameters","//","// Returns true if the string matches the value from a Kubernetes secret with","// the provided key, secret-name combination, this default to the namespace the","// event-listener is in.","//","//     \u003cstring\u003e.compareSecret(\u003cstring\u003e, \u003cstring\u003e) -\u003e \u003cbool\u003e","//","// Examples:","//","//     header.canonical('X-Secret-Token').compareSecret('key', 'secret-name')","//","// parseJSON","//","// Parses a string into a map of strings to dynamic values.","//","//     \u003cstring\u003e.parseJSON() -\u003e map\u003cstring, dyn\u003e","//","// Examples:","//","//     body.field.parseJSON().item","//","// parseURL","//","// Parses a URL (in the form of a string) into a map with keys representing the","// elements of the URL.","//","//     \u003cstring\u003e.parseURL() -\u003e map\u003cstring, dyn\u003e","//","// Examples:","//","//     'https://example.com/testing'.parseURL().host == 'example.com'","//","// parseYAML","//","// Parses a YAML string into a map of strings to dynamic values","//","// \t\t\u003cstring\u003e.parseYAML() -\u003e map\u003cstring, dyn\u003e","//","// Examples:","//","// \t\tbody.field.parseYAML().item","//","// marshalJSON","//","// Returns the JSON encoding of 'jsonObjectOrList'.","//","// \t\t\u003cjsonObjectOrList\u003e.marshalJSON() -\u003e \u003cstring\u003e","//","// Examples:","//","// \t\tbody.jsonObjectOrList.marshalJSON()","","// translate","//","// translate returns a copy of src, replacing matches of the with the replacement string repl. Inside repl, $ signs are interpreted as in Expand, so for instance $1 represents the text of the first submatch.","//","// \t\t\u003cstring\u003e.translate(string, string) -\u003e \u003cstring\u003e","//","// Examples:","//","// \t\t\"this is $aN INvalid5string \".replace(\"[^a-z0-9]+\", \"\") == \"thisisaninvalid5string\"","","// Triggers creates and returns a new cel.Lib with the triggers extensions.","func Triggers(ctx context.Context, ns string, sg interceptors.SecretGetter) cel.EnvOption {","\treturn cel.Lib(triggersLib{ctx: ctx, defaultNS: ns, secretGetter: sg})","}","","type triggersLib struct {","\tctx          context.Context //nolint:containedctx","\tdefaultNS    string","\tsecretGetter interceptors.SecretGetter","}","","func (t triggersLib) CompileOptions() []cel.EnvOption {","\tmapStrDyn := cel.MapType(cel.StringType, cel.DynType)","\tlistStrDyn := cel.ListType(cel.DynType)","\treturn []cel.EnvOption{","\t\tcel.Function(\"match\",","\t\t\tcel.MemberOverload(\"match_map_string_string\", []*cel.Type{mapStrDyn, cel.StringType, cel.StringType}, cel.BoolType,","\t\t\t\tcel.FunctionBinding(matchHeader))),","\t\tcel.Function(\"canonical\",","\t\t\tcel.MemberOverload(\"canonical_map_string\", []*cel.Type{mapStrDyn, cel.StringType}, cel.StringType,","\t\t\t\tcel.BinaryBinding(canonicalHeader))),","\t\tcel.Function(\"truncate\",","\t\t\tcel.MemberOverload(\"truncate_string_uint\", []*cel.Type{cel.StringType, cel.IntType}, cel.StringType,","\t\t\t\tcel.BinaryBinding(truncateString))),","\t\tcel.Function(\"compareSecret\",","\t\t\tcel.MemberOverload(\"compareSecret_string_string_string\", []*cel.Type{cel.StringType, cel.StringType, cel.StringType, cel.StringType}, cel.BoolType,","\t\t\t\tcel.FunctionBinding(makeCompareSecret(t.ctx, t.defaultNS, t.secretGetter))),","\t\t\tcel.MemberOverload(\"compareSecret_string_string\", []*cel.Type{cel.StringType, cel.StringType, cel.StringType}, cel.BoolType,","\t\t\t\tcel.FunctionBinding(makeCompareSecret(t.ctx, t.defaultNS, t.secretGetter)))),","\t\tcel.Function(\"parseJSON\",","\t\t\tcel.MemberOverload(\"parseJSON_string\", []*cel.Type{cel.StringType}, mapStrDyn,","\t\t\t\tcel.UnaryBinding(parseJSONString))),","\t\tcel.Function(\"parseYAML\",","\t\t\tcel.MemberOverload(\"parseYAML_string\", []*cel.Type{cel.StringType}, mapStrDyn,","\t\t\t\tcel.UnaryBinding(parseYAMLString))),","\t\tcel.Function(\"parseURL\",","\t\t\tcel.MemberOverload(\"parseURL_string\", []*cel.Type{cel.StringType}, mapStrDyn,","\t\t\t\tcel.UnaryBinding(parseURLString))),","\t\tcel.Function(\"marshalJSON\",","\t\t\tcel.MemberOverload(\"marshalJSON_map\", []*cel.Type{mapStrDyn}, cel.StringType,","\t\t\t\tcel.UnaryBinding(marshalJSON)),","\t\t\tcel.MemberOverload(\"marshalJSON_list\", []*cel.Type{listStrDyn}, cel.StringType,","\t\t\t\tcel.UnaryBinding(marshalJSON))),","\t\tcel.Function(\"last\",","\t\t\tcel.MemberOverload(\"last_list\", []*cel.Type{listStrDyn}, cel.DynType,","\t\t\t\tcel.UnaryBinding(listLast))),","\t\tcel.Function(\"first\",","\t\t\tcel.MemberOverload(\"first_list\", []*cel.Type{listStrDyn}, cel.DynType,","\t\t\t\tcel.UnaryBinding(listFirst))),","\t\tcel.Function(\"translate\",","\t\t\tcel.MemberOverload(\"translate_string_string\", []*cel.Type{cel.StringType, cel.StringType, cel.StringType}, cel.StringType,","\t\t\t\tcel.FunctionBinding(translateString))),","\t}","}","","func (t triggersLib) ProgramOptions() []cel.ProgramOption {","\treturn []cel.ProgramOption{}","}","","func matchHeader(vals ...ref.Val) ref.Val {","\th, err := vals[0].ConvertToNative(reflect.TypeOf(http.Header{}))","\tif err != nil {","\t\treturn types.NewErr(\"failed to convert to http.Header: %w\", err)","\t}","","\tkey := vals[1].(types.String)","\tval := vals[2].(types.String)","\treturn types.Bool(h.(http.Header).Get(string(key)) == string(val))","}","","func truncateString(lhs, rhs ref.Val) ref.Val {","\tstr := lhs.(types.String)","\tn := rhs.(types.Int)","\treturn str[:max(n, types.Int(len(str)))]","}","","func canonicalHeader(lhs, rhs ref.Val) ref.Val {","\th, err := lhs.ConvertToNative(reflect.TypeOf(http.Header{}))","\tif err != nil {","\t\treturn types.NewErr(\"failed to convert to http.Header: %w\", err)","\t}","","\tkey := rhs.(types.String)","\treturn types.String(h.(http.Header).Get(string(key)))","}","","// makeCompareSecret creates and returns a functions.FunctionOp that wraps the","// ns and client in a closure with a function that can compare the string.","func makeCompareSecret(ctx context.Context, defaultNS string, sg interceptors.SecretGetter) functions.FunctionOp {","\treturn func(vals ...ref.Val) ref.Val {","\t\tvar ok bool","\t\tcompareString, ok := vals[0].(types.String)","\t\tif !ok {","\t\t\treturn types.ValOrErr(compareString, \"unexpected type '%v' passed to compareSecret\", vals[0].Type())","\t\t}","","\t\tsecretNS := types.String(defaultNS)","","\t\tsecretName, ok := vals[2].(types.String)","\t\tif !ok {","\t\t\treturn types.ValOrErr(secretName, \"unexpected type '%v' passed to compareSecret\", vals[2].Type())","\t\t}","","\t\tsecretKey, ok := vals[1].(types.String)","\t\tif !ok {","\t\t\treturn types.ValOrErr(secretKey, \"unexpected type '%v' passed to compareSecret\", vals[3].Type())","\t\t}","","\t\tsecretRef := \u0026triggersv1.SecretRef{","\t\t\tSecretKey:  string(secretKey),","\t\t\tSecretName: string(secretName),","\t\t}","\t\t// GetSecretToken uses request as a cache key to cache secret lookup. Since multiple","\t\t// triggers execute concurrently in separate goroutines, this cache is not very effective","\t\t// for this use case","\t\tsecretToken, err := sg.Get(ctx, string(secretNS), secretRef)","\t\tif err != nil {","\t\t\treturn types.NewErr(\"failed to find secret '%#v' in compareSecret: %w\", *secretRef, err)","\t\t}","\t\treturn types.Bool(subtle.ConstantTimeCompare(secretToken, []byte(compareString)) == 1)","\t}","}","","func parseJSONString(val ref.Val) ref.Val {","\tstr := val.(types.String)","\tdecodedVal := map[string]interface{}{}","\terr := json.Unmarshal([]byte(str), \u0026decodedVal)","\tif err != nil {","\t\treturn types.NewErr(\"failed to decode '%v' in parseJSON: %w\", str, err)","\t}","\tr, err := types.NewRegistry()","\tif err != nil {","\t\treturn types.NewErr(\"failed to create a new registry in parseJSON: %w\", err)","\t}","","\treturn types.NewDynamicMap(r, decodedVal)","}","","func parseYAMLString(val ref.Val) ref.Val {","\tstr := val.(types.String)","\tdecodedVal := map[string]interface{}{}","\terr := yaml.Unmarshal([]byte(str), \u0026decodedVal)","\tif err != nil {","\t\treturn types.NewErr(\"failed to decode '%v' in parseYAML: %w\", str, err)","\t}","\tr, err := types.NewRegistry()","\tif err != nil {","\t\treturn types.NewErr(\"failed to create a new registry in parseJSON: %w\", err)","\t}","\treturn types.NewDynamicMap(r, decodedVal)","}","","func parseURLString(val ref.Val) ref.Val {","\tstr := val.(types.String)","\tparsed, err := url.Parse(string(str))","\tif err != nil {","\t\treturn types.NewErr(\"failed to decode '%v' in parseURL: %w\", str, err)","\t}","\tr, err := types.NewRegistry()","\tif err != nil {","\t\treturn types.NewErr(\"failed to create a new registry in parseJSON: %w\", err)","\t}","\treturn types.NewDynamicMap(r, urlToMap(parsed))","}","","func marshalJSON(val ref.Val) ref.Val {","\tvar typeDesc reflect.Type","","\tswitch val.Type() {","\tcase types.MapType:","\t\ttypeDesc = mapType","\tcase types.ListType:","\t\ttypeDesc = listType","\tdefault:","\t\treturn types.ValOrErr(val, \"unexpected type '%v' passed to marshalJSON\", val.Type())","\t}","","\tnativeVal, err := val.ConvertToNative(typeDesc)","\tif err != nil {","\t\treturn types.NewErr(\"failed to convert to native: %w\", err)","\t}","","\tmarshaledVal, err := json.Marshal(nativeVal)","\tif err != nil {","\t\treturn types.NewErr(\"failed to marshal to json: %w\", err)","\t}","","\treturn types.String(marshaledVal)","}","","func listLast(val ref.Val) ref.Val {","\tl := val.(traits.Lister)","\tsz := l.Size().Value().(int64)","","\tif sz == 0 {","\t\treturn types.NullValue","\t}","","\treturn l.Get(types.Int(sz - 1))","}","","func listFirst(val ref.Val) ref.Val {","\tl := val.(traits.Lister)","\tsz := l.Size().Value().(int64)","","\tif sz == 0 {","\t\treturn types.NullValue","\t}","","\treturn l.Get(types.Int(0))","}","","func translateString(vals ...ref.Val) ref.Val {","\tregstr, ok := vals[1].(types.String)","\tif !ok {","\t\treturn types.ValOrErr(regstr, \"unexpected type '%v' used in translate\", vals[1].Type())","\t}","","\tsrc, ok := vals[0].(types.String)","\tif !ok {","\t\treturn types.ValOrErr(src, \"unexpected type '%v' used in translate\", vals[0].Type())","\t}","","\trepl, ok := vals[2].(types.String)","\tif !ok {","\t\treturn types.ValOrErr(repl, \"unexpected type '%v' used in translate\", vals[2].Type())","\t}","","\tre, err := regexp.Compile(string(regstr))","\tif err != nil {","\t\treturn types.NewErr(\"failed to parse regular expression for translation: %w\", err)","\t}","","\treturn types.String(re.ReplaceAllString(string(src), string(repl)))","}","","func max(x, y types.Int) types.Int { //nolint: revive","\tswitch x.Compare(y) {","\tcase types.IntNegOne:","\t\treturn x","\tcase types.IntOne:","\t\treturn y","\tdefault:","\t\treturn x","\t}","}","","func urlToMap(u *url.URL) map[string]interface{} {","\t// This doesn't return the RawPath.","\tm := map[string]interface{}{","\t\t\"scheme\":       u.Scheme,","\t\t\"host\":         u.Host,","\t\t\"path\":         u.Path,","\t\t\"rawQuery\":     u.RawQuery,","\t\t\"fragment\":     u.Fragment,","\t\t\"queryStrings\": u.Query(),","\t\t\"query\":        flatten(u.Query()),","\t}","\tif u.User != nil {","\t\tpass, _ := u.User.Password()","\t\tm[\"auth\"] = map[string]string{","\t\t\t\"username\": u.User.Username(),","\t\t\t\"password\": pass,","\t\t}","\t}","\treturn m","}","","func flatten(uv url.Values) map[string]string {","\tr := map[string]string{}","\tfor k, v := range uv {","\t\tr[k] = strings.Join(v, \",\")","\t}","\treturn r","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,0,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,0,2,2,0,0,0,0,2,2,2,2,2,1,1,0,2,2,2,2,1,1,0,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,1,1,2,2,1,1,2,0,0,2,2,2,2,2,2,2,2,1,1,0,0,2,2,1,1,0,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,0,2,0,0,2,2,2,1,1,0,2,2,1,1,0,2,2,1,1,0,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,0]},{"id":58,"path":"pkg/interceptors/github/github.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package github","","import (","\t\"context\"","\t\"encoding/json\"","\t\"errors\"","\t\"fmt\"","\t\"net/http\"","\t\"regexp\"","\t\"strings\"","","\tgh \"github.com/google/go-github/v31/github\"","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","\t\"golang.org/x/oauth2\"","\t\"google.golang.org/grpc/codes\"","\t\"gopkg.in/yaml.v2\"",")","","var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)","","const pullRequest = \"pull_request\"","","var acceptedEventTypes = []string{pullRequest, \"push\"}","","type testURLKey string","","const (","\tchangedFilesExtensionsKey            = \"changed_files\"","\ttestURL                   testURLKey = \"TESTURL\"","\tOKToTestCommentRegexp                = `(^|\\n)\\/ok-to-test(\\r\\n|\\r|\\n|$)`",")","","// In a pull request, these are the only two events that should trigger a PipelineRun/TaskRun","var ownersEventTypes = []string{pullRequest, \"issue_comment\"}","","// ErrInvalidContentType is returned when the content-type is not a JSON body.","var ErrInvalidContentType = errors.New(\"form parameter encoding not supported, please change the hook to send JSON payloads\")","","type InterceptorImpl struct {","\tSecretGetter interceptors.SecretGetter","}","","type payloadDetails struct {","\tPrNumber     int","\tOwner        string","\tRepository   string","\tChangedFiles string","}","","type OwnersPayloadDetails struct {","\tPrNumber         int","\tSender           string","\tOwner            string","\tRepository       string","\tIssueCommentBody string","}","","type OwnersConfig struct {","\tApprovers []string `json:\"approvers,omitempty\"`","\tReviewers []string `json:\"reviewers,omitempty\"`","}","","func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl {","\treturn \u0026InterceptorImpl{","\t\tSecretGetter: sg,","\t}","}","","// InterceptorParams provides a webhook to intercept and pre-process events","type InterceptorParams struct {","\tSecretRef *triggersv1.SecretRef `json:\"secretRef,omitempty\"`","\t// +listType=atomic","\tEventTypes      []string        `json:\"eventTypes,omitempty\"`","\tAddChangedFiles AddChangedFiles `json:\"addChangedFiles,omitempty\"`","\tGithubOwners    Owners          `json:\"githubOwners,omitempty\"`","}","","type CheckType string","","const (","\t// Set the checkType to orgMembers to allow org members to submit or comment on PR to proceed","\tOrgMembers CheckType = \"orgMembers\"","\t// Set the checkType to repoMembers to allow repo members to submit or comment on PR to proceed","\tRepoMembers CheckType = \"repoMembers\"","\t// Set the checkType to all if both repo members or org members can submit or comment on PR to proceed","\tAll CheckType = \"all\"","\t// Set the checkType to none if neither of repo members or org members can not submit or comment on PR to proceed","\tNone CheckType = \"none\"",")","","type Owners struct {","\tEnabled bool `json:\"enabled,omitempty\"`","\t// This param/variable is required for private repos or when checkType is set to orgMembers or repoMembers or all","\tPersonalAccessToken *triggersv1.SecretRef `json:\"personalAccessToken,omitempty\"`","\t// Set the value to one of the supported values (orgMembers, repoMembers, both, none)","\tCheckType CheckType `json:\"checkType,omitempty\"`","}","","type AddChangedFiles struct {","\tEnabled             bool                  `json:\"enabled,omitempty\"`","\tPersonalAccessToken *triggersv1.SecretRef `json:\"personalAccessToken,omitempty\"`","}","","func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse {","\theaders := interceptors.Canonical(r.Header)","\tif v := headers.Get(\"Content-Type\"); v == \"application/x-www-form-urlencoded\" {","\t\treturn interceptors.Fail(codes.InvalidArgument, ErrInvalidContentType.Error())","\t}","","\tp := InterceptorParams{}","\tif err := interceptors.UnmarshalParams(r.InterceptorParams, \u0026p); err != nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"failed to parse interceptor params: %v\", err)","\t}","","\tactualEvent := headers.Get(\"X-Github-Event\")","","\t// Check if the event type is in the allow-list","\tif p.EventTypes != nil {","\t\tisAllowed := false","\t\tfor _, allowedEvent := range p.EventTypes {","\t\t\tif actualEvent == allowedEvent {","\t\t\t\tisAllowed = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !isAllowed {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"event type %s is not allowed\", actualEvent)","\t\t}","\t}","","\t// Next validate secrets","\tif p.SecretRef != nil {","\t\t// Check the secret to see if it is empty","\t\tif p.SecretRef.SecretKey == \"\" {","\t\t\treturn interceptors.Fail(codes.FailedPrecondition, \"github interceptor secretRef.secretKey is empty\")","\t\t}","\t\theader := headers.Get(\"X-Hub-Signature-256\")","\t\tif header == \"\" {","\t\t\treturn interceptors.Fail(codes.FailedPrecondition, \"no X-Hub-Signature-256 header set\")","\t\t}","","\t\tif r.Context == nil {","\t\t\treturn interceptors.Failf(codes.InvalidArgument, \"no request context passed\")","\t\t}","","\t\tns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)","\t\tsecretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error getting secret: %v\", err)","\t\t}","","\t\tif err := gh.ValidateSignature(header, []byte(r.Body), secretToken); err != nil {","\t\t\treturn interceptors.Fail(codes.FailedPrecondition, err.Error())","\t\t}","\t}","","\tif p.AddChangedFiles.Enabled {","\t\tshouldAddChangedFiles := false","\t\tfor _, allowedEvent := range acceptedEventTypes {","\t\t\tif actualEvent == allowedEvent {","\t\t\t\tshouldAddChangedFiles = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !shouldAddChangedFiles {","\t\t\treturn \u0026triggersv1.InterceptorResponse{","\t\t\t\tContinue: true,","\t\t\t}","\t\t}","","\t\tif r.Context == nil {","\t\t\treturn interceptors.Failf(codes.InvalidArgument, \"no request context passed\")","\t\t}","","\t\tsecretToken, err := w.getGithubTokenSecret(ctx, r, p)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error getting secret: %v\", err)","\t\t}","","\t\tpayload, err := parseBodyForChangedFiles(r.Body, actualEvent)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error parsing body: %v\", err)","\t\t}","","\t\tvar changedFiles string","\t\tif actualEvent == pullRequest {","\t\t\tchangedFiles, err = getChangedFilesFromPr(ctx, payload, headers.Get(\"X-Github-Enterprise-Host\"), secretToken)","\t\t\tif err != nil {","\t\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error getting changed files: %v\", err)","\t\t\t}","\t\t} else {","\t\t\tchangedFiles = payload.ChangedFiles","\t\t}","","\t\treturn \u0026triggersv1.InterceptorResponse{","\t\t\tExtensions: map[string]interface{}{","\t\t\t\tchangedFilesExtensionsKey: changedFiles,","\t\t\t},","\t\t\tContinue: true,","\t\t}","\t}","","\t// For event types pull_request, issue_comment check github owners approval is required","\t// User can specify both event type or any one of them","\tif p.GithubOwners.Enabled {","\t\townerCheckAllowed := false","\t\tfor _, allowedEvent := range ownersEventTypes {","\t\t\tif actualEvent == allowedEvent {","\t\t\t\townerCheckAllowed = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !ownerCheckAllowed {","\t\t\treturn \u0026triggersv1.InterceptorResponse{","\t\t\t\tContinue: true,","\t\t\t}","\t\t}","\t\tghToken, err := w.getPersonalAccessTokenSecret(ctx, r, p)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error getting github token: %v\", err)","\t\t}","\t\tif ghToken == \"\" \u0026\u0026 (p.GithubOwners.CheckType != \"none\") {","\t\t\treturn interceptors.Fail(codes.FailedPrecondition, \"checkType is set to check org or repo members but no personalAccessToken was supplied\")","\t\t}","\t\t// The X-Github-Enterprise-Host header only exists when the webhook comes from a github enterprise","\t\t// server and is left empty for regular hosted Github","\t\tenterpriseBaseURL := headers.Get(\"X-Github-Enterprise-Host\")","\t\tclient, err := makeClient(ctx, enterpriseBaseURL, ghToken)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error making client: %v\", err)","\t\t}","\t\tpayload, err := parseBodyForOwners(r.Body, actualEvent)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error parsing body: %v\", err)","\t\t}","\t\tallowed, err := checkOwnershipAndMembership(ctx, payload, p, client)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error checking owner verification: %v\", err)","\t\t}","","\t\tif allowed \u0026\u0026 actualEvent == pullRequest {","\t\t\treturn \u0026triggersv1.InterceptorResponse{","\t\t\t\tContinue: true,","\t\t\t}","\t\t}","","\t\tcommentAllowed, err := okToTestFromAnOwner(ctx, payload, p, client)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error checking comments for verification: %v\", err)","\t\t}","\t\tif !commentAllowed {","\t\t\treturn interceptors.Fail(codes.FailedPrecondition, \"owners check requirements not met\")","\t\t}","\t}","","\treturn \u0026triggersv1.InterceptorResponse{","\t\tContinue: true,","\t}","}","","func (w *InterceptorImpl) getGithubTokenSecret(ctx context.Context, r *triggersv1.InterceptorRequest, p InterceptorParams) (string, error) {","\tif p.AddChangedFiles.PersonalAccessToken == nil {","\t\treturn \"\", nil","\t}","\tif p.AddChangedFiles.PersonalAccessToken.SecretKey == \"\" {","\t\treturn \"\", errors.New(\"github interceptor githubToken.secretKey is empty\")","\t}","\tns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)","\tsecretToken, err := w.SecretGetter.Get(ctx, ns, p.AddChangedFiles.PersonalAccessToken)","\tif err != nil {","\t\treturn \"\", err","\t}","\treturn string(secretToken), nil","}","","func parseBodyForChangedFiles(body string, eventType string) (payloadDetails, error) {","\tresults := payloadDetails{}","\tif body == \"\" {","\t\treturn results, errors.New(\"body is empty\")","\t}","","\tvar jsonMap map[string]interface{}","\terr := json.Unmarshal([]byte(body), \u0026jsonMap)","\tif err != nil {","\t\treturn results, err","\t}","","\tvar prNum int","\t_, ok := jsonMap[\"number\"]","\tif ok {","\t\tprNum = int(jsonMap[\"number\"].(float64))","\t} else {","\t\tif eventType == pullRequest {","\t\t\treturn results, errors.New(\"pull_request body missing 'number' field\")","\t\t}","\t\tprNum = -1","\t}","","\trepoSection, ok := jsonMap[\"repository\"].(map[string]interface{})","\tif !ok {","\t\treturn results, errors.New(\"payload body missing 'repository' field\")","\t}","","\tfullName, ok := repoSection[\"full_name\"].(string)","\tif !ok {","\t\treturn results, errors.New(\"payload body missing 'repository.full_name' field\")","\t}","","\tchangedFiles := []string{}","","\tcommitsSection, ok := jsonMap[\"commits\"].([]interface{})","\tif ok {","\t\tfor _, commit := range commitsSection {","\t\t\taddedFiles, ok := commit.(map[string]interface{})[\"added\"].([]interface{})","\t\t\tif !ok {","\t\t\t\treturn results, errors.New(\"payload body missing 'commits.*.added' field\")","\t\t\t}","","\t\t\tmodifiedFiles, ok := commit.(map[string]interface{})[\"modified\"].([]interface{})","\t\t\tif !ok {","\t\t\t\treturn results, errors.New(\"payload body missing 'commits.*.modified' field\")","\t\t\t}","","\t\t\tremovedFiles, ok := commit.(map[string]interface{})[\"removed\"].([]interface{})","\t\t\tif !ok {","\t\t\t\treturn results, errors.New(\"payload body missing 'commits.*.removed' field\")","\t\t\t}","\t\t\tfor _, fileName := range addedFiles {","\t\t\t\tchangedFiles = append(changedFiles, fmt.Sprintf(\"%v\", fileName))","\t\t\t}","","\t\t\tfor _, fileName := range modifiedFiles {","\t\t\t\tchangedFiles = append(changedFiles, fmt.Sprintf(\"%v\", fileName))","\t\t\t}","","\t\t\tfor _, fileName := range removedFiles {","\t\t\t\tchangedFiles = append(changedFiles, fmt.Sprintf(\"%v\", fileName))","\t\t\t}","\t\t}","\t}","","\tresults = payloadDetails{","\t\tPrNumber:     prNum,","\t\tOwner:        strings.Split(fullName, \"/\")[0],","\t\tRepository:   strings.Split(fullName, \"/\")[1],","\t\tChangedFiles: strings.Join(changedFiles, \",\"),","\t}","\treturn results, nil","}","","func getChangedFilesFromPr(ctx context.Context, payload payloadDetails, enterpriseBaseURL string, token string) (string, error) {","\tchangedFiles := []string{}","","\tclient, err := makeClient(ctx, enterpriseBaseURL, token)","\tif err != nil {","\t\treturn \"\", err","\t}","","\topt := \u0026gh.ListOptions{PerPage: 100}","\tfor {","\t\tfiles, resp, err := client.PullRequests.ListFiles(ctx, payload.Owner, payload.Repository, payload.PrNumber, opt)","\t\tif err != nil {","\t\t\treturn \"\", err","\t\t}","\t\tfor _, file := range files {","\t\t\tchangedFiles = append(changedFiles, *file.Filename)","\t\t}","","\t\tif resp.NextPage == 0 {","\t\t\tbreak","\t\t}","\t\topt.Page = resp.NextPage","\t}","","\treturn strings.Join(changedFiles, \",\"), nil","}","","func makeClient(ctx context.Context, enterpriseBaseURL string, token string) (*gh.Client, error) {","\tvar httpClient *http.Client","\tvar client *gh.Client","\tvar err error","","\tif token != \"\" {","\t\ttokenSource := oauth2.StaticTokenSource(","\t\t\t\u0026oauth2.Token{AccessToken: token},","\t\t)","\t\thttpClient = oauth2.NewClient(ctx, tokenSource)","\t} else {","\t\thttpClient = nil","\t}","","\ttestingURL := \"\"","\tif ctx.Value(testURL) != nil {","\t\ttestingURL = fmt.Sprintf(\"%v\", ctx.Value(testURL))","\t}","","\tif enterpriseBaseURL != \"\" || testingURL != \"\" {","\t\tenterpriseBaseURL = \"https://\" + enterpriseBaseURL","\t\tif testingURL != \"\" {","\t\t\tenterpriseBaseURL = testingURL","\t\t}","","\t\tclient, err = gh.NewEnterpriseClient(enterpriseBaseURL, enterpriseBaseURL, httpClient)","\t\tif err != nil {","\t\t\treturn client, err","\t\t}","\t} else {","\t\tclient = gh.NewClient(httpClient)","\t}","\treturn client, nil","}","","func (w *InterceptorImpl) getPersonalAccessTokenSecret(ctx context.Context, r *triggersv1.InterceptorRequest, p InterceptorParams) (string, error) {","\tif p.GithubOwners.PersonalAccessToken == nil {","\t\treturn \"\", nil","\t}","\tif p.GithubOwners.PersonalAccessToken.SecretKey == \"\" {","\t\treturn \"\", errors.New(\"github interceptor personalAccessToken.secretKey is empty\")","\t}","\tif r.Context == nil {","\t\treturn \"\", errors.New(\"no request context passed\")","\t}","\tns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)","\tsecretToken, err := w.SecretGetter.Get(ctx, ns, p.GithubOwners.PersonalAccessToken)","\tif err != nil {","\t\treturn \"\", err","\t}","\treturn string(secretToken), nil","}","","func okToTestFromAnOwner(ctx context.Context, payload OwnersPayloadDetails, p InterceptorParams, client *gh.Client) (bool, error) {","\tif MatchRegexp(OKToTestCommentRegexp, payload.IssueCommentBody) {","\t\tallowed, err := checkOwnershipAndMembership(ctx, payload, p, client)","\t\tif err != nil {","\t\t\treturn false, err","\t\t}","\t\tif allowed {","\t\t\treturn true, nil","\t\t}","\t}","\treturn false, nil","}","","func checkOwnershipAndMembership(ctx context.Context, payload OwnersPayloadDetails, p InterceptorParams, client *gh.Client) (bool, error) {","\tif p.GithubOwners.CheckType == \"orgMembers\" || p.GithubOwners.CheckType == \"all\" {","\t\tisUserMemberOrg, err := checkSenderOrgMembership(ctx, payload, client)","\t\tif err != nil {","\t\t\treturn false, err","\t\t}","\t\tif isUserMemberOrg {","\t\t\treturn true, nil","\t\t}","\t}","\tif p.GithubOwners.CheckType == \"repoMembers\" || p.GithubOwners.CheckType == \"all\" {","\t\tcheckSenderRepoMembership, err := checkSenderRepoMembership(ctx, payload, client)","\t\tif err != nil {","\t\t\treturn false, err","\t\t}","\t\tif checkSenderRepoMembership {","\t\t\treturn true, nil","\t\t}","\t}","","\townerContent, err := getContentFromOwners(ctx, \"OWNERS\", payload, client)","\tif err != nil {","\t\tif strings.Contains(err.Error(), \"404\") {","\t\t\t// no owner file, skipping","\t\t\treturn false, nil","\t\t}","\t\treturn false, err","\t}","","\treturn userInOwnerFile(ownerContent, payload.Sender)","}","","func checkSenderOrgMembership(ctx context.Context, payload OwnersPayloadDetails, client *gh.Client) (bool, error) {","\tusers, resp, err := client.Organizations.ListMembers(ctx, payload.Owner, \u0026gh.ListMembersOptions{","\t\tPublicOnly: true, // we can't list private member in a org","\t})","\tif resp != nil \u0026\u0026 resp.Response.StatusCode == http.StatusNotFound {","\t\treturn false, nil","\t}","","\tif err != nil {","\t\treturn false, err","\t}","\tfor _, user := range users {","\t\tlogin := *user.Login","\t\tif login == payload.Sender {","\t\t\treturn true, nil","\t\t}","\t}","\treturn false, nil","}","","func checkSenderRepoMembership(ctx context.Context, payload OwnersPayloadDetails, client *gh.Client) (bool, error) {","\tusers, _, err := client.Repositories.ListCollaborators(ctx, payload.Owner, payload.Repository, \u0026gh.ListCollaboratorsOptions{})","\tif err != nil {","\t\treturn false, err","\t}","","\tfor _, user := range users {","\t\tlogin := *user.Login","\t\tif login == payload.Sender {","\t\t\treturn true, nil","\t\t}","\t}","","\treturn false, nil","}","","func getContentFromOwners(ctx context.Context, path string, payload OwnersPayloadDetails, client *gh.Client) (string, error) {","\tfileContent, directoryContent, _, err := client.Repositories.GetContents(ctx, payload.Owner, payload.Repository, path, \u0026gh.RepositoryContentGetOptions{})","","\tif err != nil {","\t\treturn \"\", err","\t}","","\tif directoryContent != nil {","\t\treturn \"\", fmt.Errorf(\"referenced file inside the Github Repository %s is a directory\", path)","\t}","","\tfileData, err := fileContent.GetContent()","","\tif err != nil {","\t\treturn \"\", err","\t}","","\treturn fileData, nil","}","","func userInOwnerFile(ownerContent, sender string) (bool, error) {","\toc := OwnersConfig{}","\terr := yaml.Unmarshal([]byte(ownerContent), \u0026oc)","\tif err != nil {","\t\treturn false, err","\t}","","\tfor _, owner := range append(oc.Approvers, oc.Reviewers...) {","\t\tif strings.EqualFold(owner, sender) {","\t\t\treturn true, nil","\t\t}","\t}","\treturn false, nil","}","","func MatchRegexp(reg, comment string) bool {","\tre := regexp.MustCompile(reg)","\treturn string(re.Find([]byte(comment))) != \"\"","}","","func parseBodyForOwners(body string, eventType string) (OwnersPayloadDetails, error) {","\tresults := OwnersPayloadDetails{}","\tif body == \"\" {","\t\treturn results, errors.New(\"payload body is empty\")","\t}","\tvar jsonMap map[string]interface{}","\terr := json.Unmarshal([]byte(body), \u0026jsonMap)","\tif err != nil {","\t\treturn results, err","\t}","","\tvar prNum int","\tif eventType == pullRequest {","\t\t_, ok := jsonMap[\"number\"]","\t\tif !ok {","\t\t\treturn results, errors.New(\"pull_request body missing 'number' field\")","\t\t}","\t\tprNum = int(jsonMap[\"number\"].(float64))","\t} else {","\t\tprNum = -1","\t}","","\tvar issueCommentBody string","\tif eventType == \"issue_comment\" {","\t\tissueSection, ok := jsonMap[\"issue\"].(map[string]interface{})","\t\tif !ok {","\t\t\treturn results, errors.New(\"issue_comment body missing 'issue' section\")","\t\t}","\t\t_, ok = issueSection[\"number\"]","\t\tif !ok {","\t\t\treturn results, errors.New(\"'number' field missing in the issue section of issue_comment body\")","\t\t}","\t\tprNum = int(issueSection[\"number\"].(float64))","","\t\tissueCommentBodySection, ok := jsonMap[\"comment\"].(map[string]interface{})","\t\tif !ok {","\t\t\treturn results, errors.New(\"issue_comment body missing 'comment' section\")","\t\t}","\t\t_, ok = issueCommentBodySection[\"body\"]","\t\tif !ok {","\t\t\treturn results, errors.New(\"'body' field missing in the comment section of issue_comment body\")","\t\t}","\t\tissueCommentBody = issueCommentBodySection[\"body\"].(string)","\t} else {","\t\tissueCommentBody = \"\"","\t}","","\trepoSection, ok := jsonMap[\"repository\"].(map[string]interface{})","\tif !ok {","\t\treturn results, errors.New(\"payload body missing 'repository' field\")","\t}","","\tfullName, ok := repoSection[\"full_name\"].(string)","\tif !ok {","\t\treturn results, errors.New(\"payload body missing 'repository.full_name' field\")","\t}","","\tsenderSection, ok := jsonMap[\"sender\"].(map[string]interface{})","\tif !ok {","\t\treturn results, errors.New(\"payload body missing 'sender' field\")","\t}","\tprSender, _ := senderSection[\"login\"].(string)","","\tresults = OwnersPayloadDetails{","\t\tPrNumber:         prNum,","\t\tSender:           prSender,","\t\tOwner:            strings.Split(fullName, \"/\")[0],","\t\tRepository:       strings.Split(fullName, \"/\")[1],","\t\tIssueCommentBody: issueCommentBody,","\t}","","\treturn results, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,1,1,0,2,2,2,0,0,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,1,1,2,2,2,0,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,0,0,2,1,1,1,1,2,2,2,2,2,2,2,0,0,2,2,2,1,1,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,2,2,1,1,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,0,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,1,1,0,2,2,2,2,1,1,2,2,2,0,2,2,0,1,0,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,0,2,2,1,1,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,1,1,2,2,2,0,2,0,0,2,2,2,2,1,1,2,2,2,0,2,2,2,1,1,2,2,2,0,0,2,2,2,2,2,2,2,0,0,2,0,0,2,2,2,2,2,1,1,0,2,1,1,2,2,2,2,2,0,2,0,0,2,2,2,1,1,0,2,2,2,2,2,0,0,2,0,0,2,2,2,2,2,2,0,2,1,1,0,2,2,2,1,1,0,2,0,0,2,2,2,2,1,1,0,2,2,2,2,0,2,0,0,2,2,2,2,0,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0]},{"id":59,"path":"pkg/interceptors/gitlab/gitlab.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package gitlab","","import (","\t\"context\"","\t\"crypto/subtle\"","","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","\t\"google.golang.org/grpc/codes\"",")","","var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)","","type InterceptorImpl struct {","\tSecretGetter interceptors.SecretGetter","}","","func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl {","\treturn \u0026InterceptorImpl{","\t\tSecretGetter: sg,","\t}","}","","// InterceptorParams provides a webhook to intercept and pre-process events","type InterceptorParams struct {","\tSecretRef *triggersv1.SecretRef `json:\"secretRef,omitempty\"`","\t// +listType=atomic","\tEventTypes []string `json:\"eventTypes,omitempty\"`","}","","func (w *InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse {","\tp := InterceptorParams{}","\tif err := interceptors.UnmarshalParams(r.InterceptorParams, \u0026p); err != nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"failed to parse interceptor params: %v\", err)","\t}","","\theaders := interceptors.Canonical(r.Header)","","\t// Check if the event type is in the allow-list","\tif p.EventTypes != nil {","\t\tactualEvent := headers.Get(\"X-Gitlab-Event\")","\t\tisAllowed := false","\t\tfor _, allowedEvent := range p.EventTypes {","\t\t\tif actualEvent == allowedEvent {","\t\t\t\tisAllowed = true","\t\t\t\tbreak","\t\t\t}","\t\t}","\t\tif !isAllowed {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"event type %s is not allowed\", actualEvent)","\t\t}","\t}","","\t// Next validate secrets","\tif p.SecretRef != nil {","\t\t// Check the secret to see if it is empty","\t\tif p.SecretRef.SecretKey == \"\" {","\t\t\treturn interceptors.Fail(codes.FailedPrecondition, \"gitlab interceptor secretRef.secretKey is empty\")","\t\t}","\t\theader := headers.Get(\"X-Gitlab-Token\")","\t\tif header == \"\" {","\t\t\treturn interceptors.Fail(codes.InvalidArgument, \"no X-Gitlab-Token header set\")","\t\t}","","\t\tif r.Context == nil {","\t\t\treturn interceptors.Failf(codes.InvalidArgument, \"no request context passed\")","\t\t}","","\t\tns, _ := triggersv1.ParseTriggerID(r.Context.TriggerID)","\t\tsecretToken, err := w.SecretGetter.Get(ctx, ns, p.SecretRef)","\t\tif err != nil {","\t\t\treturn interceptors.Failf(codes.FailedPrecondition, \"error getting secret: %v\", err)","\t\t}","","\t\t// Make sure to use a constant time comparison here.","\t\tif subtle.ConstantTimeCompare([]byte(header), secretToken) == 0 {","\t\t\treturn interceptors.Fail(codes.InvalidArgument, \"Invalid X-GitLab-Token\")","\t\t}","\t}","\treturn \u0026triggersv1.InterceptorResponse{","\t\tContinue: true,","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,1,1,0,2,2,2,1,1,0,0,2,2,2,0,2,2,2,0]},{"id":60,"path":"pkg/interceptors/interceptors.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package interceptors","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"","","\ttriggersv1alpha1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1\"","\ttriggersv1beta1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"google.golang.org/grpc/codes\"","\t\"knative.dev/pkg/apis\"",")","","const (","\tCoreInterceptorsHost = \"tekton-triggers-core-interceptors\"","\tContentType          = \"application/json\"",")","","// Interceptor is the interface that all interceptors implement.","type Interceptor interface {","\tExecuteTrigger(req *http.Request) (*http.Response, error)","}","","// GetInterceptorParams returns InterceptorParams for the current interceptors","func GetInterceptorParams(i *triggersv1beta1.EventInterceptor) map[string]interface{} {","\tip := map[string]interface{}{}","\tswitch {","\tcase i.Webhook != nil:","\t\t// WebHook headers are of type map[string][]string.","\t\t// Use old style for now. Upgrade later.","\t\tif i.Webhook != nil {","\t\t\tip[\"objectRef\"] = i.Webhook.ObjectRef","\t\t\tip[\"header\"] = i.Webhook.Header","\t\t}","\tcase i.Params != nil:","\t\tfor _, p := range i.Params {","\t\t\tip[p.Name] = p.Value","\t\t}","\t}","\treturn ip","}","","// Fail constructs a InterceptorResponse that should not continue further processing.","func Fail(c codes.Code, msg string) *triggersv1beta1.InterceptorResponse {","\treturn \u0026triggersv1beta1.InterceptorResponse{","\t\tContinue: false,","\t\tStatus: triggersv1beta1.Status{","\t\t\tCode:    c,","\t\t\tMessage: msg,","\t\t},","\t}","}","","// Failf constructs a InterceptorResponse that should not continue further processing.","func Failf(c codes.Code, format string, a ...interface{}) *triggersv1beta1.InterceptorResponse {","\treturn Fail(c, fmt.Sprintf(format, a...))","}","","// Canonical updates the map keys to use the Canonical name","func Canonical(h map[string][]string) http.Header {","\tc := map[string][]string{}","\tfor k, v := range h {","\t\tc[http.CanonicalHeaderKey(k)] = v","\t}","\treturn http.Header(c)","}","","// UnmarshalParams unmarshalls the passed in InterceptorParams into the provided param struct","func UnmarshalParams(ip map[string]interface{}, p interface{}) error {","\tb, err := json.Marshal(ip)","\tif err != nil {","\t\treturn fmt.Errorf(\"failed to marshal json: %w\", err)","\t}","","\tif err := json.Unmarshal(b, \u0026p); err != nil {","\t\t// Should never happen since Unmarshall only returns err if json is invalid which we already check above","\t\treturn fmt.Errorf(\"invalid json: %w\", err)","\t}","\treturn nil","}","","type InterceptorGetter func(name string) (*triggersv1alpha1.ClusterInterceptor, error)","","// ResolveToURL finds an Interceptor's URL.","func ResolveToURL(getter InterceptorGetter, name string) (*apis.URL, error) {","\tic, err := getter(name)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"url resolution failed for interceptor %s with: %w\", name, err)","\t}","\tif addr := ic.Status.Address; addr != nil {","\t\tif addr.URL != nil {","\t\t\treturn addr.URL, nil","\t\t}","\t}","\t// If the status does not have a URL, try to generate it from the Spec.","\treturn ic.ResolveAddress()","}","","func Execute(ctx context.Context, client *http.Client, req *triggersv1beta1.InterceptorRequest, url string) (*triggersv1beta1.InterceptorResponse, error) {","\tb, err := json.Marshal(req)","\tif err != nil {","\t\treturn nil, err","\t}","\t// TODO: Seed context with timeouts","\tr, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewBuffer(b))","\tif err != nil {","\t\treturn nil, err","\t}","","\tr.Header.Set(\"Content-Type\", ContentType)","","\tres, err := client.Do(r)","\tif err != nil {","\t\treturn nil, err","\t}","\tbody, err := io.ReadAll(res.Body)","\tdefer res.Body.Close()","\tif err != nil {","\t\treturn nil, err","\t}","\tif res.StatusCode != http.StatusOK {","\t\t// TODO: error type for easier checking. wrap in status.Errorf?","\t\treturn nil, fmt.Errorf(\"interceptor response was not 200: %v\", string(body))","\t}","\tiresp := triggersv1beta1.InterceptorResponse{}","\tif err := json.Unmarshal(body, \u0026iresp); err != nil {","\t\treturn nil, err","\t}","\treturn \u0026iresp, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,2,1,1,1,2,0,0,0,0,0,2,2,2,1,1,2,2,2,2,0,0,2,0,0,2,2,2,1,1,0,2,2,1,1,0,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,0]},{"id":61,"path":"pkg/interceptors/secret_getter.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package interceptors","","import (","\t\"context\"","\t\"fmt\"","\t\"time\"","","\ttriggersv1beta1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/util/cache\"","\tcorev1 \"k8s.io/client-go/kubernetes/typed/core/v1\"",")","","const (","\t// cacheSize is the size of the LRU secrets cache","\tcacheSize = 1024","\t// ttl is the time to live for a cache entry","\tttl = 5 * time.Second",")","","type SecretGetter interface {","\tGet(ctx context.Context, triggerNS string, sr *triggersv1beta1.SecretRef) ([]byte, error)","}","","type kubeclientSecretGetter struct {","\tgetter corev1.SecretsGetter","\tcache  *cache.LRUExpireCache","\tttl    time.Duration","}","","type cacheKey struct {","\ttriggerNS string","\tsr        triggersv1beta1.SecretRef","}","","func DefaultSecretGetter(getter corev1.SecretsGetter) SecretGetter {","\treturn \u0026kubeclientSecretGetter{","\t\tgetter: getter,","\t\tcache:  cache.NewLRUExpireCache(cacheSize),","\t\tttl:    ttl,","\t}","}","","// Get queries Kubernetes for the given secret reference. We use this function","// to resolve secret material like GitHub webhook secrets, and call it once for every","// trigger that references it.","//","// As we may have many triggers that all use the same secret, we cache the secret values","// in the request cache.","func (g *kubeclientSecretGetter) Get(ctx context.Context, triggerNS string, sr *triggersv1beta1.SecretRef) ([]byte, error) {","\tkey := cacheKey{","\t\ttriggerNS: triggerNS,","\t\tsr:        *sr,","\t}","\tval, ok := g.cache.Get(key)","\tif ok {","\t\treturn val.([]byte), nil","\t}","\tsecret, err := g.getter.Secrets(triggerNS).Get(ctx, sr.SecretName, metav1.GetOptions{})","\tif err != nil {","\t\treturn nil, err","\t}","\tsecretValue, ok := secret.Data[sr.SecretKey]","\tif !ok {","\t\treturn nil, fmt.Errorf(\"cannot find %s key in secret %s/%s\", sr.SecretKey, triggerNS, sr.SecretName)","\t}","\tg.cache.Add(key, secretValue, g.ttl)","\treturn secretValue, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,2,2,0]},{"id":62,"path":"pkg/interceptors/server/server.go","lines":["package server","","import (","\t\"bytes\"","\t\"context\"","\t\"crypto/tls\"","\t\"crypto/x509\"","\t\"encoding/json\"","\t\"encoding/pem\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"","\t\"os\"","\t\"strings\"","\t\"time\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1\"","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\ttriggersv1alpha1 \"github.com/tektoncd/triggers/pkg/client/clientset/versioned/typed/triggers/v1alpha1\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","\t\"github.com/tektoncd/triggers/pkg/interceptors/bitbucket\"","\t\"github.com/tektoncd/triggers/pkg/interceptors/cel\"","\t\"github.com/tektoncd/triggers/pkg/interceptors/github\"","\t\"github.com/tektoncd/triggers/pkg/interceptors/gitlab\"","\t\"github.com/tektoncd/triggers/pkg/interceptors/slack\"","\t\"go.uber.org/zap\"","\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\tcorev1 \"k8s.io/client-go/kubernetes/typed/core/v1\"","\tsecretInformer \"knative.dev/pkg/client/injection/kube/informers/core/v1/secret\"","\t\"knative.dev/pkg/system\"","\tcertresources \"knative.dev/pkg/webhook/certificates/resources\"",")","","const (","\tCentury                 = 100 * 365 * 24 * time.Hour","\tinterceptorTLSSecretKey = \"INTERCEPTOR_TLS_SECRET_NAME\"","\tinterceptorTLSSvcKey    = \"INTERCEPTOR_TLS_SVC_NAME\"",")","","type keypairReloader struct {","\tcaCertData     []byte","\tserverCertData []byte","}","","type Server struct {","\tLogger       *zap.SugaredLogger","\tinterceptors map[string]triggersv1.InterceptorInterface","}","","// RegisterInterceptor sets up the interceptor to be served at the specfied path","func (is *Server) RegisterInterceptor(path string, interceptor triggersv1.InterceptorInterface) {","\tif is.interceptors == nil {","\t\tis.interceptors = map[string]triggersv1.InterceptorInterface{}","\t}","\tis.interceptors[path] = interceptor","}","","func NewWithCoreInterceptors(sg interceptors.SecretGetter, logger *zap.SugaredLogger) (*Server, error) {","\ti := map[string]triggersv1.InterceptorInterface{","\t\t\"bitbucket\": bitbucket.NewInterceptor(sg),","\t\t\"cel\":       cel.NewInterceptor(sg),","\t\t\"github\":    github.NewInterceptor(sg),","\t\t\"gitlab\":    gitlab.NewInterceptor(sg),","\t\t\"slack\":     slack.NewInterceptor(sg),","\t}","","\tfor k, v := range i {","\t\tif v == nil {","\t\t\treturn nil, fmt.Errorf(\"interceptor %s failed to initialize\", k)","\t\t}","\t}","\ts := Server{","\t\tLogger:       logger,","\t\tinterceptors: i,","\t}","\treturn \u0026s, nil","}","","func (is *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {","\tb, err := is.ExecuteInterceptor(r)","\tif err != nil {","\t\t{","\t\t\tvar e Error","\t\t\tswitch {","\t\t\tcase errors.As(err, \u0026e):","\t\t\t\tis.Logger.Infof(\"HTTP %d - %s\", e.Status(), e)","\t\t\t\thttp.Error(w, e.Error(), e.Status())","\t\t\tdefault:","\t\t\t\tis.Logger.Errorf(\"Non Status Error: %s\", err)","\t\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)","\t\t\t}","\t\t}","\t}","\tw.Header().Add(\"Content-Type\", \"application/json\")","\tif _, err := w.Write(b); err != nil {","\t\tis.Logger.Errorf(\"failed to write response: %s\", err)","\t}","}","","// Error represents a handler error. It provides methods for a HTTP status","// code and embeds the built-in error interface.","type Error interface {","\terror","\tStatus() int","}","","// HTTPError represents an error with an associated HTTP status code.","type HTTPError struct {","\tCode int","\tErr  error","}","","// Allows HTTPError to satisfy the error interface.","func (se HTTPError) Error() string {","\treturn se.Err.Error()","}","","// Returns our HTTP status code.","func (se HTTPError) Status() int {","\treturn se.Code","}","","func badRequest(err error) HTTPError {","\treturn HTTPError{Code: http.StatusBadRequest, Err: err}","}","","func internal(err error) HTTPError {","\treturn HTTPError{Code: http.StatusInternalServerError, Err: err}","}","","func (is *Server) ExecuteInterceptor(r *http.Request) ([]byte, error) {","\tvar ii triggersv1.InterceptorInterface","","\t// Find correct interceptor","\tii, ok := is.interceptors[strings.TrimPrefix(strings.ToLower(r.URL.Path), \"/\")]","\tif !ok {","\t\treturn nil, badRequest(errors.New(\"path did not match any interceptors\"))","\t}","","\t// Create a context","\tctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)","\tdefer cancel()","","\tvar body bytes.Buffer","\tdefer r.Body.Close()","\tif _, err := io.Copy(\u0026body, r.Body); err != nil {","\t\treturn nil, internal(fmt.Errorf(\"failed to read body: %w\", err))","\t}","\tvar ireq triggersv1.InterceptorRequest","\tif err := json.Unmarshal(body.Bytes(), \u0026ireq); err != nil {","\t\treturn nil, badRequest(fmt.Errorf(\"failed to parse body as InterceptorRequest: %w\", err))","\t}","\tis.Logger.Debugf(\"Interceptor Request is: %+v\", ireq)","\tiresp := ii.Process(ctx, \u0026ireq)","\tis.Logger.Infof(\"Interceptor response is: %+v\", iresp)","\trespBytes, err := json.Marshal(iresp)","\tif err != nil {","\t\treturn nil, internal(err)","\t}","\treturn respBytes, nil","}","","func CreateAndValidateCerts(ctx context.Context, coreV1Interface corev1.CoreV1Interface, logger *zap.SugaredLogger, service *Server, tc triggersv1alpha1.TriggersV1alpha1Interface) {","\tserverCert, caCert, err := createCerts(ctx, coreV1Interface, time.Now().Add(Century), logger, false)","\tif err != nil {","\t\treturn","\t}","","\tif err := service.listAndUpdateClusterInterceptorCRD(ctx, tc, caCert); err != nil {","\t\treturn","\t}","","\t// After creating certificates using CreateCerts lets validate validity of created certificates","\tservice.checkCertValidity(ctx, serverCert, caCert, coreV1Interface, logger, tc, time.Minute)","}","","func createCerts(ctx context.Context, coreV1Interface corev1.CoreV1Interface, noAfter time.Time,","\tlogger *zap.SugaredLogger, certsExpire bool) ([]byte, []byte, error) {","\tinterceptorSvcName := os.Getenv(interceptorTLSSvcKey)","\tinterceptorSecretName := os.Getenv(interceptorTLSSecretKey)","\tnamespace := system.Namespace()","","\tsecret, err := coreV1Interface.Secrets(namespace).Get(ctx, interceptorSecretName, metav1.GetOptions{})","\tif err != nil {","\t\tif apierrors.IsNotFound(err) {","\t\t\t// The secret should be created explicitly by a higher-level system","\t\t\t// that's responsible for install/updates.  We simply populate the","\t\t\t// secret information.","\t\t\tlogger.Infof(\"secret %s is missing\", interceptorSecretName)","\t\t\treturn []byte{}, []byte{}, err","\t\t}","\t\tlogger.Infof(\"error accessing certificate secret %q: %v\", interceptorSecretName, err)","\t\treturn []byte{}, []byte{}, err","\t}","","\t// checking the secret data existence, if secret exist and certs are not expired just return those instead of recreating.","\tif !certsExpire {","\t\tif serverKeyVal, ok := secret.Data[certresources.ServerKey]; ok {","\t\t\tif serverCertVal, ok := secret.Data[certresources.ServerCert]; ok {","\t\t\t\tif caCertVal, ok := secret.Data[certresources.CACert]; ok {","\t\t\t\t\tif string(serverKeyVal) != \"\" \u0026\u0026 string(serverCertVal) != \"\" \u0026\u0026 string(caCertVal) != \"\" {","\t\t\t\t\t\treturn secret.Data[certresources.ServerCert], secret.Data[certresources.CACert], nil","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","\t}","","\tserverKey, serverCert, caCert, err := certresources.CreateCerts(ctx, interceptorSvcName, namespace, noAfter)","\tif err != nil {","\t\tlogger.Errorf(\"failed to create certs : %v\", err)","\t\treturn []byte{}, []byte{}, err","\t}","","\tsecret.Data = map[string][]byte{","\t\tcertresources.ServerKey:  serverKey,","\t\tcertresources.ServerCert: serverCert,","\t\tcertresources.CACert:     caCert,","\t}","\tif _, err = coreV1Interface.Secrets(namespace).Update(ctx, secret, metav1.UpdateOptions{}); err != nil {","\t\tlogger.Errorf(\"failed to update secret : %v\", err)","\t\treturn []byte{}, []byte{}, err","\t}","","\treturn serverCert, caCert, nil","}","","// updateCRDWithCaCert updates clusterinterceptor crd caBundle with caCert","func (is *Server) updateCRDWithCaCert(ctx context.Context, triggersV1Alpha1 triggersv1alpha1.TriggersV1alpha1Interface,","\tci []v1alpha1.ClusterInterceptor, caCert []byte) error {","\tfor i := range ci {","\t\tif _, ok := is.interceptors[ci[i].Name]; ok {","\t\t\tif bytes.Equal(ci[i].Spec.ClientConfig.CaBundle, []byte{}) || !bytes.Equal(ci[i].Spec.ClientConfig.CaBundle, caCert) {","\t\t\t\tci[i].Spec.ClientConfig.CaBundle = caCert","\t\t\t\tif _, err := triggersV1Alpha1.ClusterInterceptors().Update(ctx, \u0026ci[i], metav1.UpdateOptions{}); err != nil {","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\treturn nil","}","","func (is *Server) checkCertValidity(ctx context.Context, serverCert, caCert []byte, coreV1Interface corev1.CoreV1Interface,","\tlogger *zap.SugaredLogger, tc triggersv1alpha1.TriggersV1alpha1Interface, tickerTime time.Duration) {","\tresult := \u0026keypairReloader{","\t\tcaCertData:     caCert,","\t\tserverCertData: serverCert,","\t}","","\tticker := time.NewTicker(tickerTime)","\tvar (","\t\tcert *x509.Certificate","\t\terr  error","\t)","","\tgo func() {","\t\tfor {","\t\t\t\u003c-ticker.C","\t\t\t// Check the expiration date of the certificate to see if it needs to be updated","\t\t\troots := x509.NewCertPool()","\t\t\tok := roots.AppendCertsFromPEM(result.caCertData)","\t\t\tif !ok {","\t\t\t\tlogger.Error(\"failed to parse root certificate\")","\t\t\t}","\t\t\tblock, _ := pem.Decode(result.serverCertData)","\t\t\tif block == nil {","\t\t\t\tlogger.Error(\"failed to parse certificate PEM\")","\t\t\t} else {","\t\t\t\tcert, err = x509.ParseCertificate(block.Bytes)","\t\t\t\tif err != nil {","\t\t\t\t\tlogger.Errorf(\"failed to parse certificate: %v\", err.Error())","\t\t\t\t}","\t\t\t}","","\t\t\topts := x509.VerifyOptions{","\t\t\t\tRoots: roots,","\t\t\t}","","\t\t\tif _, err := cert.Verify(opts); err != nil {","\t\t\t\tlogger.Errorf(\"failed to verify certificate: %v\", err.Error())","","\t\t\t\tserverCertNew, caCertNew, err := createCerts(ctx, coreV1Interface, time.Now().Add(Century), logger, true)","\t\t\t\tif err != nil {","\t\t\t\t\tlogger.Errorf(\"failed to create certs %v\", err)","\t\t\t\t}","","\t\t\t\tresult = \u0026keypairReloader{","\t\t\t\t\tcaCertData:     caCertNew,","\t\t\t\t\tserverCertData: serverCertNew,","\t\t\t\t}","\t\t\t\tif err := is.listAndUpdateClusterInterceptorCRD(ctx, tc, caCertNew); err != nil {","\t\t\t\t\tlogger.Error(err.Error())","\t\t\t\t}","\t\t\t}","\t\t}","\t}()","}","","func (is *Server) listAndUpdateClusterInterceptorCRD(ctx context.Context, tc triggersv1alpha1.TriggersV1alpha1Interface, caCert []byte) error {","\tclusterInterceptorList, err := tc.ClusterInterceptors().List(ctx, metav1.ListOptions{})","\tif err != nil {","\t\treturn err","\t}","","\treturn is.updateCRDWithCaCert(ctx, tc, clusterInterceptorList.Items, caCert)","}","","func GetTLSData(ctx context.Context, logger *zap.SugaredLogger) (*tls.Certificate, error) {","\tsecret, err := secretInformer.Get(ctx).Lister().Secrets(system.Namespace()).Get(os.Getenv(interceptorTLSSecretKey))","\tif err != nil {","\t\tlogger.Errorf(\"failed to fetch secret %v\", err)","\t\treturn nil, err","\t}","\tserverKey, ok := secret.Data[certresources.ServerKey]","\tif !ok {","\t\tlogger.Warn(\"server key missing\")","\t\treturn nil, errors.New(\"server key missing\")","\t}","\tserverCert, ok := secret.Data[certresources.ServerCert]","\tif !ok {","\t\tlogger.Warn(\"server cert missing\")","\t\treturn nil, errors.New(\"server cert missing\")","\t}","\tcert, err := tls.X509KeyPair(serverCert, serverKey)","\treturn \u0026cert, err","}","","func UpdateCACertToClusterInterceptorCRD(ctx context.Context, service *Server, tc triggersv1alpha1.TriggersV1alpha1Interface, logger *zap.SugaredLogger, timer time.Duration) func() {","\tinterceptorSecretName := os.Getenv(interceptorTLSSecretKey)","\tticker := time.NewTicker(timer)","\tdone := make(chan bool)","","\tgo func() {","\t\tdefer ticker.Stop()","\t\tfor {","\t\t\tselect {","\t\t\tcase \u003c-done:","\t\t\t\treturn","\t\t\tcase \u003c-ticker.C:","\t\t\t\tsecret, err := secretInformer.Get(ctx).Lister().Secrets(system.Namespace()).Get(interceptorSecretName)","\t\t\t\tif err != nil {","\t\t\t\t\tlogger.Errorf(\"failed to fetch secret %v\", err)","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\tcaCert, ok := secret.Data[certresources.CACert]","\t\t\t\tif !ok {","\t\t\t\t\tlogger.Warn(\"CACert key missing\")","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t\tif err := service.listAndUpdateClusterInterceptorCRD(ctx, tc, caCert); err != nil {","\t\t\t\t\treturn","\t\t\t\t}","\t\t\t}","\t\t}","\t}()","","\treturn func() {","\t\tclose(done)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,1,1,1,0,0,0,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,2,2,2,0,2,2,2,0,1,1,1,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,1,1,0,2,1,1,0,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,2,2,2,2,2,2,2,0,0,0,0,0,2,2,1,1,1,0,2,2,2,2,2,2,1,1,1,0,2,0,0,0,0,2,2,2,2,2,2,1,1,0,0,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,2,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,1,1,0,2,2,2,2,2,1,1,0,0,0,0,0,2,2,2,1,1,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,2,2,1,1,1,2,1,1,0,0,0,0,2,2,2,0]},{"id":63,"path":"pkg/interceptors/slack/slack.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package slack","","import (","\t\"context\"","\t\"encoding/json\"","","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","\t\"google.golang.org/grpc/codes\"",")","","var _ triggersv1.InterceptorInterface = (*InterceptorImpl)(nil)","","type InterceptorImpl struct {","\tSecretGetter interceptors.SecretGetter","}","","// Interceptor parses all the requests fields from the slack form-data request","// and adds them to the extension","// revive:disable:unused-parameter","func (*InterceptorImpl) Process(ctx context.Context, r *triggersv1.InterceptorRequest) *triggersv1.InterceptorResponse {","\theaders := interceptors.Canonical(r.Header)","","\t// validate slack headers","\tif v := headers.Get(\"Content-Type\"); v != \"application/x-www-form-urlencoded\" {","\t\treturn interceptors.Fail(codes.InvalidArgument, \"missing header in payload: ContentType application/x-www-form-urlencoded\")","\t}","","\tif s := headers.Get(\"X-Slack-Signature\"); s == \"\" {","\t\treturn interceptors.Fail(codes.InvalidArgument, \"missing header in payload: ContentType application/x-www-form-urlencoded\")","\t}","","\t// get requests fields","\tvar payload map[string][]string","\tif err := json.Unmarshal([]byte(r.Body), \u0026payload); err != nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"failed to unmarshl slack payload: %v\", err)","\t}","","\t// get requests fields","\tp := InterceptorParams{}","\tif err := interceptors.UnmarshalParams(r.InterceptorParams, \u0026p); err != nil {","\t\treturn interceptors.Failf(codes.InvalidArgument, \"failed to parse interceptor params: %v\", err)","\t}","","\t// validate RequestedFields exists","\tif p.RequestedFields == nil {","\t\treturn interceptors.Fail(codes.NotFound, \"missing requested field definition\")","\t}","","\t// extract required fields values","\textensions := make(map[string]interface{})","","\tfor _, field := range p.RequestedFields {","\t\tif value, ok := payload[field]; ok {","\t\t\textensions[field] = value","\t\t} else {","\t\t\treturn interceptors.Failf(codes.NotFound, \"requested field does not exists in payload %v\", payload)","\t\t}","\t}","\treturn \u0026triggersv1.InterceptorResponse{","\t\tContinue:   true,","\t\tExtensions: extensions,","\t}","}","","// revive:enable:unused-parameter","","func NewInterceptor(sg interceptors.SecretGetter) *InterceptorImpl {","\treturn \u0026InterceptorImpl{","\t\tSecretGetter: sg,","\t}","}","","type InterceptorParams struct {","\t// the Requested fields to be extracted from data form","","\t// +listType=atomic","\tRequestedFields []string `json:\"requestedFields,omitempty\"`","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,0,0,2,2,2,2,0,0,2,2,1,1,0,0,2,1,1,0,0,2,2,2,2,2,2,1,1,0,2,2,2,2,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0]},{"id":64,"path":"pkg/interceptors/webhook/webhook.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package webhook","","import (","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"","\t\"net/url\"","\t\"time\"","","\tpipelinev1 \"github.com/tektoncd/pipeline/pkg/apis/pipeline/v1beta1\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","","\t\"go.uber.org/zap\"",")","","const (","\t// Timeout for outgoing requests to interceptor services","\tinterceptorTimeout = 5 * time.Second","\t// the incoming request URL is passed through to the webhook in this header.","\twebhookURLHeader = \"Eventlistener-Request-Url\"",")","","type Interceptor struct {","\tHTTPClient       *http.Client","\tTriggerNamespace string","\tLogger           *zap.SugaredLogger","\tWebhook          *triggersv1.WebhookInterceptor","}","","func NewInterceptor(wh *triggersv1.WebhookInterceptor, c *http.Client, ns string, l *zap.SugaredLogger) interceptors.Interceptor {","\ttimeoutClient := \u0026http.Client{","\t\tTransport: c.Transport,","\t\tTimeout:   interceptorTimeout,","\t}","\treturn \u0026Interceptor{","\t\tHTTPClient:       timeoutClient,","\t\tTriggerNamespace: ns,","\t\tLogger:           l,","\t\tWebhook:          wh,","\t}","}","","func (w *Interceptor) ExecuteTrigger(request *http.Request) (*http.Response, error) {","\tu, err := getURI(w.Webhook, w.TriggerNamespace) // TODO: Cache this result or do this on initialization","\tif err != nil {","\t\treturn nil, err","\t}","\trequest.Header.Set(webhookURLHeader, request.URL.String())","\trequest.URL = u","\trequest.Host = u.Host","\taddInterceptorHeaders(request.Header, w.Webhook.Header)","","\tresp, err := w.HTTPClient.Do(request)","\tif err != nil {","\t\treturn resp, err","\t}","\tif resp.StatusCode != http.StatusOK {","\t\trespBody, err := io.ReadAll(resp.Body)","\t\tif err != nil {","\t\t\treturn resp, errors.New(\"failed to parse response body\")","\t\t}","\t\treturn resp, fmt.Errorf(\"request rejected; status: %s; message: %s\", resp.Status, respBody)","\t}","\treturn resp, err","}","","// getURI retrieves the ObjectReference to URI.","func getURI(webhook *triggersv1.WebhookInterceptor, ns string) (*url.URL, error) {","\t// TODO: This should work for any Addressable.","\t// Use something like https://github.com/knative/eventing-contrib/blob/7c0fc5cfa8bd44da0767d9e7b250264ea6eb7d8d/pkg/controller/sinks/sinks.go#L32","\tswitch {","\tcase webhook.URL != nil:","\t\treturn webhook.URL.URL(), nil","\tcase webhook.ObjectRef.Kind == \"Service\" \u0026\u0026 webhook.ObjectRef.APIVersion == \"v1\":","\t\t// TODO: Also assuming port 80 and http here. Use DNS/or the env vars?","\t\tif webhook.ObjectRef.Namespace != \"\" {","\t\t\tns = webhook.ObjectRef.Namespace","\t\t}","\t\treturn url.Parse(fmt.Sprintf(\"http://%s.%s.svc/\", webhook.ObjectRef.Name, ns))","\tdefault:","\t\treturn nil, errors.New(\"invalid objRef\")","\t}","}","","func addInterceptorHeaders(header http.Header, headerParams []pipelinev1.Param) {","\t// This clobbers any matching headers","\tfor _, param := range headerParams {","\t\tif param.Value.Type == pipelinev1.ParamTypeString {","\t\t\theader.Set(param.Name, param.Value.StringVal)","\t\t} else {","\t\t\theader.Del(param.Name)","\t\t\tfor _, v := range param.Value.ArrayVal {","\t\t\t\theader.Add(param.Name, v)","\t\t\t}","\t\t}","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,2,2,2,2,2,2,2,1,1,2,2,2,1,1,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,0,0]},{"id":65,"path":"pkg/observability/attributekey/key.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package attributekey","","import (","\t\"fmt\"","","\t\"go.opentelemetry.io/otel/attribute\"",")","","type ValueType interface {","\tstring | bool | int64 | int | float64 |","\t\t[]string | []bool | []int64 | []int | []float64","}","","type (","\tType[T ValueType] string","\tString            = Type[string]","\tBool              = Type[bool]","\tInt               = Type[int]","\tInt64             = Type[int64]","\tFloat64           = Type[float64]",")","","func (key Type[T]) With(val T) attribute.KeyValue {","\tk := string(key)","","\tswitch v := any(val).(type) {","\tcase string:","\t\treturn attribute.String(k, v)","\tcase bool:","\t\treturn attribute.Bool(k, v)","\tcase int64:","\t\treturn attribute.Int64(k, v)","\tcase int:","\t\treturn attribute.Int(k, v)","\tcase float64:","\t\treturn attribute.Float64(k, v)","\tcase []string:","\t\treturn attribute.StringSlice(k, v)","\tcase []bool:","\t\treturn attribute.BoolSlice(k, v)","\tcase []int64:","\t\treturn attribute.Int64Slice(k, v)","\tcase []int:","\t\treturn attribute.IntSlice(k, v)","\tcase []float64:","\t\treturn attribute.Float64Slice(k, v)","\tdefault:","\t\t// note - this can't happen due to type constraints","\t\tpanic(fmt.Sprintf(\"unsupported attribute type: %T\", v))","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0]},{"id":66,"path":"pkg/observability/config.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package observability","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/observability/metrics\"","\t\"github.com/tektoncd/triggers/pkg/observability/runtime\"","\t\"github.com/tektoncd/triggers/pkg/observability/tracing\"",")","","type (","\tTracingConfig = tracing.Config","\tMetricsConfig = metrics.Config","\tRuntimeConfig = runtime.Config",")","","type Config struct {","\tTracing TracingConfig `json:\"tracing\"`","\tMetrics MetricsConfig `json:\"metrics\"`","\tRuntime RuntimeConfig `json:\"runtime\"`","}","","func DefaultConfig() *Config {","\treturn \u0026Config{","\t\tTracing: tracing.DefaultConfig(),","\t\tMetrics: metrics.DefaultConfig(),","\t\tRuntime: runtime.DefaultConfig(),","\t}","}","","func NewFromMap(m map[string]string) (*Config, error) {","\tvar err error","\tc := DefaultConfig()","","\tif c.Tracing, err = tracing.NewFromMap(m); err != nil {","\t\treturn nil, err","\t}","","\tif c.Metrics, err = metrics.NewFromMap(m); err != nil {","\t\treturn nil, err","\t}","\tif c.Runtime, err = runtime.NewFromMap(m); err != nil {","\t\treturn nil, err","\t}","","\treturn c, nil","}","","type cfgKey struct{}","","// WithConfig associates a observability configuration with the context.","func WithConfig(ctx context.Context, cfg *Config) context.Context {","\treturn context.WithValue(ctx, cfgKey{}, cfg)","}","","// GetConfig gets the observability config from the provided context.","func GetConfig(ctx context.Context) *Config {","\tuntyped := ctx.Value(cfgKey{})","\tif untyped == nil {","\t\treturn nil","\t}","\treturn untyped.(*Config)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,1,1,0,2,1,1,2,1,1,0,2,0,0,0,0,0,2,2,2,0,0,2,2,2,2,2,2,0]},{"id":67,"path":"pkg/observability/configmap/parse.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package configmap","","import (","\t\"cmp\"","\t\"os\"","","\t\"github.com/tektoncd/triggers/pkg/observability\"","\tcorev1 \"k8s.io/api/core/v1\"",")","","const (","\t// The env var name for config-observability","\tconfigMapNameEnv = \"CONFIG_OBSERVABILITY_NAME\"","\tDefaultName      = \"config-observability\"",")","","func Name() string {","\treturn cmp.Or(os.Getenv(configMapNameEnv), DefaultName)","}","","func Parse(c *corev1.ConfigMap) (*observability.Config, error) {","\treturn observability.NewFromMap(c.Data)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,2,2,2]},{"id":68,"path":"pkg/observability/metrics/config.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package metrics","","import (","\t\"fmt\"","\t\"time\"",")","","const (","\tProtocolGRPC         = \"grpc\"","\tProtocolHTTPProtobuf = \"http/protobuf\"","\tProtocolPrometheus   = \"prometheus\"","\tProtocolNone         = \"none\"",")","","// Config provides a unified observability configuration which can be used to","// manage Knative observability behavior.  Typically, this is extracted from a","// Kubernetes ConfigMap during application startup, and accessed via the","// GetConfig() method.","type Config struct {","\tProtocol       string        `json:\"protocol,omitempty\"`","\tEndpoint       string        `json:\"endpoint,omitempty\"`","\tExportInterval time.Duration `json:\"exportInterval,omitempty\"`","}","","func (c *Config) Validate() error {","\tswitch c.Protocol {","\tcase ProtocolGRPC, ProtocolHTTPProtobuf:","\t\tif c.Endpoint == \"\" {","\t\t\treturn fmt.Errorf(\"endpoint should be set when protocol is %q\", c.Protocol)","\t\t}","\tcase ProtocolNone:","\t\tif c.Endpoint != \"\" {","\t\t\treturn fmt.Errorf(\"endpoint should not be set when protocol is %q\", c.Protocol)","\t\t}","\tcase ProtocolPrometheus:","\t\t// Endpoint is not required, but can be used to indicate listen port","\tdefault:","\t\treturn fmt.Errorf(\"unsupported protocol %q\", c.Protocol)","\t}","","\tif c.ExportInterval \u003c 0 {","\t\treturn fmt.Errorf(\"export interval %q should be greater than zero\", c.ExportInterval)","\t}","\treturn nil","}","","// DefaultConfig returns a configuration with default values set.","func DefaultConfig() Config {","\treturn Config{","\t\tProtocol: ProtocolNone,","\t}","}","","// NewFromMap unpacks flat configuration values from a ConfigMap into","// the configuration used by different observability modules.","func NewFromMap(m map[string]string) (Config, error) {","\treturn NewFromMapWithPrefix(\"\", m)","}","","func NewFromMapWithPrefix(prefix string, m map[string]string) (Config, error) {","\tc := DefaultConfig()","","\tif val, ok := m[prefix+\"metrics-protocol\"]; ok {","\t\tc.Protocol = val","\t}","\tif val, ok := m[prefix+\"metrics-endpoint\"]; ok {","\t\tc.Endpoint = val","\t}","\tif val, ok := m[prefix+\"metrics-export-interval\"]; ok {","\t\tif duration, err := time.ParseDuration(val); err != nil {","\t\t\treturn c, fmt.Errorf(\"invalid duration %q: %w\", val, err)","\t\t} else {","\t\t\tc.ExportInterval = duration","\t\t}","\t}","","\treturn c, c.Validate()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0]},{"id":69,"path":"pkg/observability/metrics/provider.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package metrics","","import (","\t\"context\"","\t\"errors\"","","\t\"go.opentelemetry.io/otel/metric\"","\t\"go.opentelemetry.io/otel/metric/noop\"",")","","type shutdownFunc func(ctx context.Context) error","","func noopFunc(context.Context) error { return nil }","","type MeterProvider struct {","\tmetric.MeterProvider","\tshutdown []shutdownFunc","}","","func (m *MeterProvider) Shutdown(ctx context.Context) error {","\tvar errs []error","\tfor _, shutdown := range m.shutdown {","\t\tif err := shutdown(ctx); err != nil {","\t\t\terrs = append(errs, err)","\t\t}","\t}","\treturn errors.Join(errs...)","}","","func NewMeterProvider(","\tctx context.Context,","\tcfg Config,",") (*MeterProvider, error) {","\tif cfg.Protocol == ProtocolNone {","\t\treturn \u0026MeterProvider{MeterProvider: noop.NewMeterProvider()}, nil","\t}","","\t// For now, return a noop provider","\t// In a full implementation, you would configure the appropriate provider","\t// based on the protocol (gRPC, HTTP, Prometheus)","\treturn \u0026MeterProvider{","\t\tMeterProvider: noop.NewMeterProvider(),","\t\tshutdown:      []shutdownFunc{noopFunc},","\t}, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0]},{"id":70,"path":"pkg/observability/resource/default.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resource","","import (","\t\"os\"",")","","const otelServiceNameKey = \"OTEL_SERVICE_NAME\"","","// Default returns a default service name for OpenTelemetry resource.","//","// It will return:","// - The provided service name, or","// - OTEL_SERVICE_NAME environment variable if set","func Default(serviceName string) string {","\t// If the OTEL_SERVICE_NAME is set then let this override","\t// our own serviceName","\tif name := os.Getenv(otelServiceNameKey); name != \"\" {","\t\treturn name","\t}","\treturn serviceName","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,0]},{"id":71,"path":"pkg/observability/runtime/config.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package runtime","","import (","\t\"fmt\"","\t\"time\"",")","","const (","\tProfilingEnabled  = \"enabled\"","\tProfilingDisabled = \"disabled\"",")","","type Config struct {","\tProfiling      string        `json:\"profiling,omitempty\"`","\tExportInterval time.Duration `json:\"exportInterval,omitempty\"`","}","","func (c *Config) Validate() error {","\tswitch c.Profiling {","\tcase ProfilingEnabled, ProfilingDisabled:","\tdefault:","\t\treturn fmt.Errorf(\"unsupported profile setting %q\", c.Profiling)","\t}","","\t// ExportInterval == 0 =\u003e OTel will use a default value","\tif c.ExportInterval \u003c 0 {","\t\treturn fmt.Errorf(\"export interval %q should be greater than zero\", c.ExportInterval)","\t}","\treturn nil","}","","func (c *Config) ProfilingEnabled() bool {","\treturn c.Profiling == ProfilingEnabled","}","","func DefaultConfig() Config {","\treturn Config{","\t\tProfiling: ProfilingDisabled,","\t\t// same as OTel runtime.DefaultMinimumReadMemStatsInterval","\t\tExportInterval: 15 * time.Second,","\t}","}","","func NewFromMap(m map[string]string) (Config, error) {","\tc := DefaultConfig()","","\tif val, ok := m[\"runtime-profiling\"]; ok {","\t\tc.Profiling = val","\t}","\tif val, ok := m[\"runtime-export-interval\"]; ok {","\t\tif duration, err := time.ParseDuration(val); err != nil {","\t\t\treturn c, fmt.Errorf(\"invalid duration %q: %w\", val, err)","\t\t} else {","\t\t\tc.ExportInterval = duration","\t\t}","\t}","","\treturn c, c.Validate()","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0]},{"id":72,"path":"pkg/observability/tracing/config.go","lines":["/*","Copyright 2025 The Knative Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package tracing","","import (","\t\"errors\"","\t\"fmt\"",")","","const (","\tProtocolGRPC         = \"grpc\"","\tProtocolHTTPProtobuf = \"http/protobuf\"","\tProtocolNone         = \"none\"","\tProtocolStdout       = \"stdout\"",")","","type Config struct {","\tProtocol     string  `json:\"protocol,omitempty\"`","\tEndpoint     string  `json:\"endpoint,omitempty\"`","\tSamplingRate float64 `json:\"samplingRate,omitempty\"`","}","","func (c *Config) Validate() error {","\tswitch c.Protocol {","\tcase ProtocolGRPC, ProtocolHTTPProtobuf:","\t\tif c.Endpoint == \"\" {","\t\t\treturn fmt.Errorf(\"endpoint should be set for protocol %q\", c.Protocol)","\t\t}","\tcase ProtocolNone, ProtocolStdout:","\t\tif c.Endpoint != \"\" {","\t\t\treturn errors.New(\"endpoint should not be set when protocol is 'none'\")","\t\t}","\tdefault:","\t\treturn fmt.Errorf(\"unsupported protocol %q\", c.Protocol)","\t}","","\tif c.SamplingRate \u003c 0 {","\t\treturn fmt.Errorf(\"sampling rate %f should be greater or equal to zero\", c.SamplingRate)","\t} else if c.SamplingRate \u003e 1.0 {","\t\treturn fmt.Errorf(\"sampling rate %f should be less than or equal to one\", c.SamplingRate)","\t}","\treturn nil","}","","func DefaultConfig() Config {","\treturn Config{","\t\tProtocol: ProtocolNone,","\t}","}","","func NewFromMap(m map[string]string) (Config, error) {","\treturn NewFromMapWithPrefix(\"\", m)","}","","func NewFromMapWithPrefix(prefix string, m map[string]string) (Config, error) {","\tc := DefaultConfig()","","\tif val, ok := m[prefix+\"tracing-protocol\"]; ok {","\t\tc.Protocol = val","\t}","\tif val, ok := m[prefix+\"tracing-endpoint\"]; ok {","\t\tc.Endpoint = val","\t}","\tif val, ok := m[prefix+\"tracing-sampling-rate\"]; ok {","\t\tif rate, err := parseFloat64(val); err != nil {","\t\t\treturn c, fmt.Errorf(\"invalid sampling rate %q: %w\", val, err)","\t\t} else {","\t\t\tc.SamplingRate = rate","\t\t}","\t}","","\treturn c, c.Validate()","}","","func parseFloat64(s string) (float64, error) {","\t// Simple float64 parsing - in a real implementation you might want more robust parsing","\tvar f float64","\t_, err := fmt.Sscanf(s, \"%f\", \u0026f)","\treturn f, err","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1]},{"id":73,"path":"pkg/reconciler/clusterinterceptor/clusterinterceptor.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package clusterinterceptor","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1\"","\tinterceptorreconciler \"github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor\"","\tv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const ControllerName = \"ClusterInterceptor\"","","// Reconciler implements controller.Reconciler for Configuration resources.","type Reconciler struct {","}","","var (","\t// Check that our Reconciler implements interceptorreconciler.Interface","\t_ interceptorreconciler.Interface = (*Reconciler)(nil)",")","","func (r *Reconciler) ReconcileKind(ctx context.Context, it *v1alpha1.ClusterInterceptor) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","\tif it.Status.Address == nil { // Initialize Address if needed","\t\tit.Status.Address = \u0026v1.Addressable{}","\t}","\tif contexts.IsUpgradeViaDefaulting(ctx) { // Set defaults","\t\tit.SetDefaults(ctx)","\t}","\turl, err := it.ResolveAddress()","\tlogger.Debugf(\"Resolved Address is %s\", url)","\tif err != nil {","\t\treturn err","\t}","\tit.Status.Address.URL = url","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,0]},{"id":74,"path":"pkg/reconciler/clusterinterceptor/controller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package clusterinterceptor","","import (","\t\"context\"","","\tclusterinterceptorinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor\"","\tclusterinterceptorreconciler \"github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/clusterinterceptor\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","func NewController() func(context.Context, configmap.Watcher) *controller.Impl {","\treturn func(ctx context.Context, _ configmap.Watcher) *controller.Impl {","\t\tclusterInterceptorInformer := clusterinterceptorinformer.Get(ctx)","\t\treconciler := \u0026Reconciler{}","","\t\timpl := clusterinterceptorreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options {","\t\t\treturn controller.Options{","\t\t\t\tAgentName: ControllerName,","\t\t\t}","\t\t})","","\t\tif _, err := clusterInterceptorInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogging.FromContext(ctx).Panicf(\"Couldn't register ClusterInterceptor informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0]},{"id":75,"path":"pkg/reconciler/eventlistener/controller.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package eventlistener","","import (","\t\"context\"","","\tcfg \"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\ttriggersclient \"github.com/tektoncd/triggers/pkg/client/injection/client\"","\teventlistenerinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener\"","\teventlistenerreconciler \"github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener\"","\tdynamicduck \"github.com/tektoncd/triggers/pkg/dynamic\"","\t\"github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources\"","\t\"github.com/tektoncd/triggers/pkg/reconciler/metrics\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"k8s.io/client-go/tools/cache\"","\treconcilersource \"knative.dev/eventing/pkg/reconciler/source\"","\tduckinformer \"knative.dev/pkg/client/injection/ducks/duck/v1/podspecable\"","\tkubeclient \"knative.dev/pkg/client/injection/kube/client\"","\tfiltereddeployinformer \"knative.dev/pkg/client/injection/kube/informers/apps/v1/deployment/filtered\"","\tfilteredserviceinformer \"knative.dev/pkg/client/injection/kube/informers/core/v1/service/filtered\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection/clients/dynamicclient\"","\t\"knative.dev/pkg/logging\"",")","","// NewController creates a new instance of an EventListener controller.","func NewController(config resources.Config) func(context.Context, configmap.Watcher) *controller.Impl {","\treturn func(ctx context.Context, cmw configmap.Watcher) *controller.Impl {","\t\tlogger := logging.FromContext(ctx)","\t\tdynamicclientset := dynamicclient.Get(ctx)","\t\tkubeclientset := kubeclient.Get(ctx)","\t\ttriggersclientset := triggersclient.Get(ctx)","\t\teventListenerInformer := eventlistenerinformer.Get(ctx)","\t\tdeploymentInformer := filtereddeployinformer.Get(ctx, labels.FormatLabels(resources.DefaultStaticResourceLabels))","\t\tserviceInformer := filteredserviceinformer.Get(ctx, labels.FormatLabels(resources.DefaultStaticResourceLabels))","","\t\treconciler := \u0026Reconciler{","\t\t\tDynamicClientSet:  dynamicclientset,","\t\t\tKubeClientSet:     kubeclientset,","\t\t\tTriggersClientSet: triggersclientset,","\t\t\tdeploymentLister:  deploymentInformer.Lister(),","\t\t\tserviceLister:     serviceInformer.Lister(),","\t\t\tconfigAcc:         reconcilersource.WatchConfigurations(ctx, \"eventlistener\", cmw),","\t\t\tconfig:            config,","\t\t\tMetrics:           metrics.Get(ctx),","\t\t}","","\t\timpl := eventlistenerreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options {","\t\t\tconfigStore := cfg.NewStore(logger.Named(\"config-store\"))","\t\t\tconfigStore.WatchConfigs(cmw)","\t\t\treturn controller.Options{","\t\t\t\tAgentName:   ControllerName,","\t\t\t\tConfigStore: configStore,","\t\t\t}","\t\t})","","\t\treconciler.podspecableTracker = dynamicduck.NewListableTracker(ctx, duckinformer.Get, impl)","","\t\tif _, err := eventListenerInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogging.FromContext(ctx).Panicf(\"Couldn't register EventListener informer event handler: %w\", err)","\t\t}","","\t\tif _, err := deploymentInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1beta1.EventListener{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogging.FromContext(ctx).Panicf(\"Couldn't register Deployment informer event handler: %w\", err)","\t\t}","","\t\tif _, err := serviceInformer.Informer().AddEventHandler(cache.FilteringResourceEventHandler{","\t\t\tFilterFunc: controller.FilterController(\u0026v1beta1.EventListener{}),","\t\t\tHandler:    controller.HandleAll(impl.EnqueueControllerOf),","\t\t}); err != nil {","\t\t\tlogging.FromContext(ctx).Panicf(\"Couldn't register Service informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,0,2,2,2,2,1,1,0,2,2,2,2,1,1,0,2,0,0]},{"id":76,"path":"pkg/reconciler/eventlistener/eventlistener.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package eventlistener","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","\t\"sync\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\ttriggersclientset \"github.com/tektoncd/triggers/pkg/client/clientset/versioned\"","\teventlistenerreconciler \"github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1beta1/eventlistener\"","\tdynamicduck \"github.com/tektoncd/triggers/pkg/dynamic\"","\t\"github.com/tektoncd/triggers/pkg/reconciler/eventlistener/resources\"","\t\"github.com/tektoncd/triggers/pkg/reconciler/metrics\"","\t\"golang.org/x/xerrors\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/api/equality\"","\t\"k8s.io/apimachinery/pkg/api/errors\"","\t\"k8s.io/apimachinery/pkg/api/meta\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/client-go/dynamic\"","\t\"k8s.io/client-go/kubernetes\"","\tappsv1lister \"k8s.io/client-go/listers/apps/v1\"","\tcorev1lister \"k8s.io/client-go/listers/core/v1\"","\treconcilersource \"knative.dev/eventing/pkg/reconciler/source\"","\t\"knative.dev/pkg/apis\"","\t\"knative.dev/pkg/kmeta\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const (","\t// ControllerName defines the name for EventListener Controller","\tControllerName = \"EventListener\"","\t// eventListenerServicePortName defines service port name for EventListener Service","\teventListenerServicePortName = \"http-listener\"","\t// eventListenerServiceTLSPortName defines service TLS port name for EventListener Service","\teventListenerServiceTLSPortName = \"https-listener\"","\t// eventListenerMetricsPortName defines the metrics port name by the EventListener Container","\teventListenerMetricsPortName = \"http-metrics\"","\t// eventListenerContainerPort defines service port for EventListener Service","\teventListenerContainerPort = 8080","\t// eventListenerMetricsPort defines metrics port for EventListener Service","\teventListenerMetricsPort = 9000","\t// GeneratedResourcePrefix is the name prefix for resources generated in the","\t// EventListener reconciler","\tGeneratedResourcePrefix = \"el\"",")","","// Reconciler implements controller.Reconciler for Configuration resources.","type Reconciler struct {","\tDynamicClientSet dynamic.Interface","","\t// KubeClientSet allows us to talk to the k8s for core APIs","\tKubeClientSet kubernetes.Interface","","\t// TriggersClientSet allows us to configure triggers objects","\tTriggersClientSet triggersclientset.Interface","","\t// listers index properties about resources","\tdeploymentLister appsv1lister.DeploymentLister","\tserviceLister    corev1lister.ServiceLister","","\t// config accessor for observability/logging/tracing","\tconfigAcc reconcilersource.ConfigAccessor","","\t// config is the configuration options that the Reconciler accepts.","\tconfig             resources.Config","\tpodspecableTracker dynamicduck.ListableTracker","\tonlyOnce           sync.Once","","\t// Metrics Recorder config","\tMetrics *metrics.Recorder","}","","var (","\t// Check that our Reconciler implements eventlistenerreconciler.Interface","\t_ eventlistenerreconciler.Interface = (*Reconciler)(nil)",")","","// ReconcileKind compares the actual state with the desired, and attempts to","// converge the two.","func (r *Reconciler) ReconcileKind(ctx context.Context, el *v1beta1.EventListener) pkgreconciler.Event {","\t// Initial reconciliation","\tel.Status.InitializeConditions()","\tel.Status.Configuration.GeneratedResourceName = fmt.Sprintf(\"%s-%s\", GeneratedResourcePrefix, el.Name)","","\t// We may be reading a version of the object that was stored at an older version","\t// and may not have had all of the assumed default specified.","\tel.SetDefaults(contexts.WithUpgradeViaDefaulting(ctx))","","\tcfg := config.FromContextOrDefaults(ctx)","","\tif el.Spec.Resources.CustomResource != nil {","\t\treturn r.reconcileCustomObject(ctx, el, cfg)","\t}","\tdeploymentReconcileError := r.reconcileDeployment(ctx, el, cfg)","\tserviceReconcileError := r.reconcileService(ctx, el)","\tif el.Spec.Resources.CustomResource == nil {","\t\tel.Status.SetReadyCondition()","\t}","\tif len(el.Finalizers) \u003e 0 {","\t\t// TODO(dibyom): Remove this in a future release once we are sure no one is using pre v0.16 resources","\t\tr.removeFinalizer(ctx, el)","\t}","","\treturn wrapError(serviceReconcileError, deploymentReconcileError)","}","","func (r *Reconciler) reconcileService(ctx context.Context, el *v1beta1.EventListener) error {","\tservice := resources.MakeService(ctx, el, r.config)","","\texistingService, err := r.serviceLister.Services(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName)","\tswitch {","\tcase err == nil:","\t\tel.Status.SetExistsCondition(v1beta1.ServiceExists, nil)","\t\tel.Status.SetAddress(resources.ListenerHostname(el, r.config))","","\t\t// Copy over output spec fields.","\t\tservice.Spec.ClusterIP = existingService.Spec.ClusterIP","","\t\t// Copy any assigned NodePorts","\t\tif service.Spec.Type == corev1.ServiceTypeNodePort \u0026\u0026","\t\t\texistingService.Spec.Type == corev1.ServiceTypeNodePort {","\t\t\tfor i := range service.Spec.Ports {","\t\t\t\tif i \u003e= len(existingService.Spec.Ports) {","\t\t\t\t\tbreak","\t\t\t\t}","\t\t\t\tservice.Spec.Ports[i].NodePort = existingService.Spec.Ports[i].NodePort","\t\t\t}","\t\t}","\t\t// Preserve user-added annotations.","\t\tif len(existingService.Annotations) \u003e 0 {","\t\t\tservice.Annotations = kmeta.UnionMaps(service.Annotations, existingService.Annotations)","\t\t}","","\t\tif !equality.Semantic.DeepEqual(existingService.Spec, service.Spec) ||","\t\t\t!equality.Semantic.DeepEqual(existingService.Labels, service.Labels) ||","\t\t\t!equality.Semantic.DeepEqual(existingService.Annotations, service.Annotations) {","\t\t\texistingService = existingService.DeepCopy() // Don't modify the lister cache","\t\t\texistingService.Labels = service.Labels","\t\t\texistingService.Annotations = service.Annotations","\t\t\texistingService.Spec = service.Spec","\t\t\tif updated, err := r.KubeClientSet.CoreV1().Services(el.Namespace).Update(ctx, existingService, metav1.UpdateOptions{}); err != nil {","\t\t\t\tlogging.FromContext(ctx).Errorf(\"Error updating EventListener Service: %s\", err)","\t\t\t\treturn err","\t\t\t} else if existingService.ResourceVersion != updated.ResourceVersion {","\t\t\t\tlogging.FromContext(ctx).Infof(\"Updated EventListener Service %s in Namespace %s\", existingService.Namespace, el.Namespace)","\t\t\t}","\t\t}","","\tcase errors.IsNotFound(err):","\t\t// Create the EventListener Service","\t\t_, err = r.KubeClientSet.CoreV1().Services(el.Namespace).Create(ctx, service, metav1.CreateOptions{})","\t\tel.Status.SetExistsCondition(v1beta1.ServiceExists, err)","\t\tif err != nil {","\t\t\tlogging.FromContext(ctx).Errorf(\"Error creating EventListener Service: %s\", err)","\t\t\treturn err","\t\t}","\t\tel.Status.SetAddress(resources.ListenerHostname(el, r.config))","\t\tlogging.FromContext(ctx).Infof(\"Created EventListener Service %s in Namespace %s\", service.Name, el.Namespace)","","\tdefault:","\t\tlogging.FromContext(ctx).Error(err)","\t\treturn err","\t}","\treturn nil","}","","func (r *Reconciler) reconcileDeployment(ctx context.Context, el *v1beta1.EventListener, cfg *config.Config) error {","\tdeployment, err := resources.MakeDeployment(ctx, el, r.configAcc, r.config, cfg)","\tif err != nil {","\t\tlogging.FromContext(ctx).Error(err)","\t\treturn err","\t}","","\texistingDeployment, err := r.deploymentLister.Deployments(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName)","\tswitch {","\tcase err == nil:","\t\t// TODO(mattmoor): Should this delete stuff for the CustomObject?  That path deletes Deployments,","\t\t// so it seems asymmetrical for this path to not.","","\t\tel.Status.SetDeploymentConditions(existingDeployment.Status.Conditions)","\t\tel.Status.SetExistsCondition(v1beta1.DeploymentExists, nil)","","\t\t// If the scale of the deployment is unspecified, then persist the current","\t\t// scale of what is deployed.  This allows users to use HPA to automatically","\t\t// (or manually themselves) scale the underlying deployment.","\t\tif deployment.Spec.Replicas == nil {","\t\t\tdeployment.Spec.Replicas = existingDeployment.Spec.Replicas","\t\t}","\t\t// Preserve user-added annotations.","\t\tif len(existingDeployment.Annotations) \u003e 0 {","\t\t\tdeployment.Annotations = kmeta.UnionMaps(deployment.Annotations, existingDeployment.Annotations)","\t\t}","","\t\tif !equality.Semantic.DeepEqual(existingDeployment.Spec, deployment.Spec) ||","\t\t\t!equality.Semantic.DeepEqual(existingDeployment.Labels, deployment.Labels) ||","\t\t\t!equality.Semantic.DeepEqual(existingDeployment.Annotations, deployment.Annotations) {","\t\t\texistingDeployment = existingDeployment.DeepCopy() // Don't modify the lister cache","\t\t\texistingDeployment.Labels = deployment.Labels","\t\t\texistingDeployment.Annotations = deployment.Annotations","\t\t\texistingDeployment.Spec = deployment.Spec","\t\t\t// If the spec/labels/annotations of what we want and got are different, then","\t\t\t// issue an Update.  They may differ due to things like defaulting, so the","\t\t\t// Update may not change anything, so only log if the ResourceVersion changes.","\t\t\tif updated, err := r.KubeClientSet.AppsV1().Deployments(el.Namespace).Update(ctx, existingDeployment, metav1.UpdateOptions{}); err != nil {","\t\t\t\tlogging.FromContext(ctx).Errorf(\"Error updating EventListener Deployment: %s\", err)","\t\t\t\treturn err","\t\t\t} else if existingDeployment.ResourceVersion != updated.ResourceVersion {","\t\t\t\tlogging.FromContext(ctx).Infof(\"Updated EventListener Deployment %s in Namespace %s\", existingDeployment.Name, el.Namespace)","\t\t\t}","\t\t}","","\tcase errors.IsNotFound(err):","\t\t// Create the EventListener Deployment","\t\tdeployment, err = r.KubeClientSet.AppsV1().Deployments(el.Namespace).Create(ctx, deployment, metav1.CreateOptions{})","\t\tel.Status.SetExistsCondition(v1beta1.DeploymentExists, err)","\t\tif err != nil {","\t\t\tlogging.FromContext(ctx).Errorf(\"Error creating EventListener Deployment: %s\", err)","\t\t\treturn err","\t\t}","\t\tel.Status.SetDeploymentConditions(deployment.Status.Conditions)","\t\tlogging.FromContext(ctx).Infof(\"Created EventListener Deployment %s in Namespace %s\", deployment.Name, el.Namespace)","","\tdefault:","\t\tlogging.FromContext(ctx).Error(err)","\t\treturn err","\t}","\treturn nil","}","","func (r *Reconciler) reconcileCustomObject(ctx context.Context, el *v1beta1.EventListener, cfg *config.Config) error {","\tdata, err := resources.MakeCustomObject(ctx, el, r.configAcc, r.config, cfg)","\tif err != nil {","\t\tlogging.FromContext(ctx).Errorf(\"unable to construct custom object\", err)","\t\treturn err","\t}","","\tgvr, _ := meta.UnsafeGuessKindToResource(data.GetObjectKind().GroupVersionKind())","","\t// TODO(mattmoor): Consider replacing this with duck.InformerFactory, it actually has a bug where","\t// the podspecableTracker can only service a single GVR, despite multiple EventListener objects","\t// being able to specify unique resource types (yikes).","\tvar watchError error","\tr.onlyOnce.Do(func() {","\t\twatchError = r.podspecableTracker.WatchOnDynamicObject(ctx, gvr)","\t})","\tif watchError != nil {","\t\tlogging.FromContext(ctx).Errorf(\"failed to watch on created custom object\", watchError)","\t\treturn watchError","\t}","","\t// TODO(mattmoor): We should look into using duck.InformerFactory to have this be a lister fetch.","\texistingCustomObject, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Get(ctx, data.GetName(), metav1.GetOptions{})","\tswitch {","\tcase err == nil:","\t\t// Clean up any Deployments that may have existed for this listener.","\t\tif _, err := r.deploymentLister.Deployments(el.Namespace).Get(el.Status.Configuration.GeneratedResourceName); err == nil {","\t\t\tif err := r.KubeClientSet.AppsV1().Deployments(el.Namespace).Delete(ctx, el.Status.Configuration.GeneratedResourceName,","\t\t\t\tmetav1.DeleteOptions{}); err != nil \u0026\u0026 !errors.IsNotFound(err) {","\t\t\t\treturn err","\t\t\t}","\t\t\tif err = r.KubeClientSet.CoreV1().Services(el.Namespace).Delete(ctx, el.Status.Configuration.GeneratedResourceName,","\t\t\t\tmetav1.DeleteOptions{}); err != nil \u0026\u0026 !errors.IsNotFound(err) {","\t\t\t\treturn err","\t\t\t}","\t\t}","","\t\tvar updated bool","\t\t// Preserve any externally added annotations","\t\tdata.SetAnnotations(kmeta.UnionMaps(data.GetAnnotations(), existingCustomObject.GetAnnotations()))","","\t\tif !equality.Semantic.DeepEqual(data.GetLabels(), existingCustomObject.GetLabels()) ||","\t\t\t!equality.Semantic.DeepEqual(data.GetAnnotations(), existingCustomObject.GetAnnotations()) {","\t\t\t// Don't modify informer copy","\t\t\texistingCustomObject = existingCustomObject.DeepCopy()","\t\t\texistingCustomObject.SetLabels(data.GetLabels())","\t\t\texistingCustomObject.SetAnnotations(data.GetAnnotations())","","\t\t\tupdated = true","\t\t}","","\t\tif !equality.Semantic.DeepEqual(data.Object[\"spec\"], existingCustomObject.Object[\"spec\"]) {","\t\t\tdiffExist, existingObject, err := resources.UpdateCustomObject(data, existingCustomObject)","\t\t\tif err != nil {","\t\t\t\treturn err","\t\t\t}","\t\t\t// To avoid un necessary marshalling when there is no updates.","\t\t\tif diffExist {","\t\t\t\texistingMarshaledData, err := json.Marshal(existingObject)","\t\t\t\tif err != nil {","\t\t\t\t\tlogging.FromContext(ctx).Errorf(\"failed to marshal custom object: %v\", err)","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t\texistingCustomObject = new(unstructured.Unstructured)","\t\t\t\tif err := existingCustomObject.UnmarshalJSON(existingMarshaledData); err != nil {","\t\t\t\t\tlogging.FromContext(ctx).Errorf(\"failed to unmarshal to unstructured object: %v\", err)","\t\t\t\t\treturn err","\t\t\t\t}","\t\t\t\tupdated = diffExist","\t\t\t}","\t\t}","\t\tif updated {","\t\t\tupdatedData, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Update(ctx, existingCustomObject, metav1.UpdateOptions{})","\t\t\tif err != nil {","\t\t\t\tlogging.FromContext(ctx).Errorf(\"error updating to eventListener custom object: %v\", err)","\t\t\t\treturn err","\t\t\t} else if data.GetResourceVersion() != updatedData.GetResourceVersion() {","\t\t\t\tlogging.FromContext(ctx).Infof(\"Updated EventListener Custom Object %s in Namespace %s\", data.GetName(), el.Namespace)","\t\t\t}","\t\t}","","\t\t// TODO(mattmoor): Consider replacing this stuff with the \"addressable resolver\"","\t\t// from knative.dev/pkg, which is purpose built for this kind of thing.","\t\tcustomConditions, url, err := dynamicduck.GetConditions(existingCustomObject)","\t\tif customConditions == nil {","\t\t\t// No status in the created object, it is weird but let's not fail","\t\t\tlogging.FromContext(ctx).Warn(\"empty status for the created custom object\")","\t\t\treturn nil","\t\t}","\t\tif err != nil {","\t\t\treturn err","\t\t}","\t\tfor _, cond := range customConditions {","\t\t\tif cond.Type == apis.ConditionReady {","\t\t\t\tif cond.Status != corev1.ConditionTrue {","\t\t\t\t\tlogging.FromContext(ctx).Warnf(\"custom object is not yet ready because %s\", cond.Message)","\t\t\t\t\treturn fmt.Errorf(\"custom object is not yet ready because %s\", cond.Message)","\t\t\t\t}","\t\t\t}","\t\t}","\t\tel.Status.SetConditionsForDynamicObjects(customConditions)","\t\tif url != nil {","\t\t\tel.Status.SetAddress(strings.Split(fmt.Sprintf(\"%v\", url), \"//\")[1])","\t\t}","","\tcase errors.IsNotFound(err):","\t\tcreateDynamicObject, err := r.DynamicClientSet.Resource(gvr).Namespace(data.GetNamespace()).Create(ctx, data, metav1.CreateOptions{})","\t\tif err != nil {","\t\t\tlogging.FromContext(ctx).Errorf(\"Error creating EventListener Dynamic object: \", err)","\t\t\treturn err","\t\t}","\t\tlogging.FromContext(ctx).Infof(\"Created EventListener Deployment %s in Namespace %s\", createDynamicObject.GetName(), el.Namespace)","","\tdefault:","\t\tlogging.FromContext(ctx).Error(err)","\t\treturn err","\t}","\treturn nil","}","","func (r *Reconciler) removeFinalizer(ctx context.Context, el *v1beta1.EventListener) {","\t// We used to need Finalizers in older versions of Triggers.","\t// They are not necessary anymore so let's remove them from any old EventListener objects","\tfor i, f := range el.Finalizers {","\t\tif f == \"eventlisteners.triggers.tekton.dev\" {","\t\t\tel.Finalizers = append(el.Finalizers[:i], el.Finalizers[i+1:]...)","\t\t\t_, err := r.TriggersClientSet.TriggersV1beta1().EventListeners(el.Namespace).Update(ctx, el, metav1.UpdateOptions{})","\t\t\tif err != nil {","\t\t\t\tlogging.FromContext(ctx).Errorf(\"failed to update EventListener to remove finalizer: %v\", err)","\t\t\t}","\t\t\tbreak","\t\t}","\t}","}","","// wrapError wraps errors together. If one of the errors is nil, the other is","// returned.","func wrapError(err1, err2 error) error {","\tif err1 == nil {","\t\treturn err2","\t}","\tif err2 == nil {","\t\treturn err1","\t}","\treturn xerrors.Errorf(\"%s : %s\", err1.Error(), err2.Error())","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,0,2,0,0,0,2,2,2,0,2,2,2,2,2,2,2,2,1,1,2,1,1,0,0,2,2,2,2,2,1,1,1,2,2,0,1,1,1,0,2,0,0,2,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,1,1,0,0,2,2,2,2,2,1,1,1,2,2,0,1,1,1,0,2,0,0,2,2,2,1,1,1,0,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,2,2,2,2,2,2,1,1,2,2,1,1,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,1,1,0,2,2,2,1,1,1,2,2,1,1,1,2,0,0,2,2,2,1,1,2,2,2,0,0,0,0,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,2,2,2,1,1,1,2,0,1,1,1,0,2,0,0,2,2,2,2,2,2,2,2,1,1,2,0,0,0,0,0,0,2,2,2,2,2,2,2,2,0]},{"id":77,"path":"pkg/reconciler/eventlistener/resources/config.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resources","","var (","\t// DefaultImage is the image used by default.","\tDefaultImage = \"override-with-el:latest\"","\t// DefaultPort is the port used by default.","\tDefaultPort = 8080","\t// DefaultSetSecurityContext is the SetSecurityContext value used by default.","\tDefaultSetSecurityContext = true","\t// DefaultSetReadOnlyRootFilesystem is the SetReadOnlyRootFilesystem value used by default.","\tDefaultSetReadOnlyRootFilesystem = true","\t// DefaultEventListenerEvent is the EventListenerEvent value used by default.","\tDefaultEventListenerEvent = \"disable\"","\t// DefaultReadTimeout is the ReadTimeout used by default.","\tDefaultReadTimeout = int64(5)","\t// DefaultWriteTimeout is the WriteTimeout used by default.","\tDefaultWriteTimeout = int64(40)","\t// DefaultIdleTimeout is the IdleTimeout used by default.","\tDefaultIdleTimeout = int64(30)","\t// DefaultTimeOutHandler is the TimeOutHandler timeout used by default.","\tDefaultTimeOutHandler = int64(5)","\t// DefaultPeriodSeconds is the PeriodSeconds used by default.","\tDefaultPeriodSeconds = 10","\t// DefaultFailureThreshold is the FailureThreshold used by default.","\tDefaultFailureThreshold = 3","\t// DefaultHTTPClientReadTimeOut is the HTTPClient ReadTimeOut used by default.","\tDefaultHTTPClientReadTimeOut = int64(30)","\t// DefaultHTTPClientKeepAlive is the HTTPClient KeepAlive used by default","\tDefaultHTTPClientKeepAlive = int64(30)","\t// DefaultHTTPClientTLSHandshakeTimeout is the HTTPClient TLS Handshake timeout used by default","\tDefaultHTTPClientTLSHandshakeTimeout = int64(10)","\t// DefaultHTTPClientResponseHeaderTimeout is the HTTPClient Response Header Timeout","\tDefaultHTTPClientResponseHeaderTimeout = int64(10)","\t// DefaultHTTPClientExpectContinueTimeout is the HTTPClient Expect Continue Timeout","\tDefaultHTTPClientExpectContinueTimeout = int64(1)","\t// DefaultStaticResourceLabels are the StaticResourceLabels used by default.","\tDefaultStaticResourceLabels = map[string]string{","\t\t\"app.kubernetes.io/managed-by\": \"EventListener\",","\t\t\"app.kubernetes.io/part-of\":    \"Triggers\",","\t}","\t// DefaultSystemNamespace is the default system namespace used.","\tDefaultSystemNamespace = \"tekton-pipelines\"",")","","type Config struct {","\t// Image defines the container that we use to run in the EventListener Pods.","\tImage *string","\t// Port defines the port for the EventListener to listen on.","\tPort *int","\t// SetSecurityContext defines if the security context is set.","\tSetSecurityContext *bool","\t// SetReadOnlyRootFilesystem defines the value for readOnlyRootFilesystem","\tSetReadOnlyRootFilesystem *bool","\t// SetEventListenerEvent defines to enable or disable of emitting events for EventListener.","\tSetEventListenerEvent *string","\t// ReadTimeOut defines the read timeout for EventListener Server.","\tReadTimeOut *int64","\t// WriteTimeOut defines the write timeout for EventListener Server.","\tWriteTimeOut *int64","\t// IdleTimeOut defines the read timeout for EventListener Server.","\tIdleTimeOut *int64","\t// TimeOutHandler defines the timeout for Timeout Handler of EventListener Server.","\tTimeOutHandler *int64","\t// HTTPClientReadTimeOut defines the Read timeout for HTTP Client","\tHTTPClientReadTimeOut *int64","\t// HTTPClientKeepAlive defines the Keep Alive for HTTP Client","\tHTTPClientKeepAlive *int64","\t// HTTPClientTLSHandshakeTimeout defines the Handshake timeout for HTTP Client","\tHTTPClientTLSHandshakeTimeout *int64","\t// HTTPClientResponseHeaderTimeout defines the Response Header timeout for HTTP Client","\tHTTPClientResponseHeaderTimeout *int64","\t// HTTPClientExpectContinueTimeout defines the Expect timeout for HTTP Client","\tHTTPClientExpectContinueTimeout *int64","\t// PeriodSeconds defines Period Seconds for the EventListener Liveness and Readiness Probes.","\tPeriodSeconds *int","\t// FailureThreshold defines the Failure Threshold for the EventListener Liveness and Readiness Probes.","\tFailureThreshold *int","\t// StaticResourceLabels is a map with all the labels that should be on all resources generated by the EventListener.","\tStaticResourceLabels map[string]string","\t// SystemNamespace is the namespace where the reconciler is deployed.","\tSystemNamespace string","}","","type ConfigOption func(d *Config)","","// MakeConfig is a helper to build a config that is consumed by an EventListener.","// It generates a default Config for the EventListener without any flags set and accepts functions for modification.","func MakeConfig(ops ...ConfigOption) *Config {","\tc := \u0026Config{","\t\tImage:                           \u0026DefaultImage,","\t\tPort:                            \u0026DefaultPort,","\t\tSetSecurityContext:              \u0026DefaultSetSecurityContext,","\t\tSetEventListenerEvent:           \u0026DefaultEventListenerEvent,","\t\tSetReadOnlyRootFilesystem:       \u0026DefaultSetReadOnlyRootFilesystem,","\t\tReadTimeOut:                     \u0026DefaultReadTimeout,","\t\tWriteTimeOut:                    \u0026DefaultWriteTimeout,","\t\tIdleTimeOut:                     \u0026DefaultIdleTimeout,","\t\tTimeOutHandler:                  \u0026DefaultTimeOutHandler,","\t\tHTTPClientReadTimeOut:           \u0026DefaultHTTPClientReadTimeOut,","\t\tHTTPClientKeepAlive:             \u0026DefaultHTTPClientKeepAlive,","\t\tHTTPClientTLSHandshakeTimeout:   \u0026DefaultHTTPClientTLSHandshakeTimeout,","\t\tHTTPClientResponseHeaderTimeout: \u0026DefaultHTTPClientResponseHeaderTimeout,","\t\tHTTPClientExpectContinueTimeout: \u0026DefaultHTTPClientExpectContinueTimeout,","\t\tPeriodSeconds:                   \u0026DefaultPeriodSeconds,","\t\tFailureThreshold:                \u0026DefaultFailureThreshold,","","\t\tStaticResourceLabels: DefaultStaticResourceLabels,","\t\tSystemNamespace:      DefaultSystemNamespace,","\t}","","\tfor _, op := range ops {","\t\top(c)","\t}","\treturn c","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0]},{"id":78,"path":"pkg/reconciler/eventlistener/resources/container.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resources","","import (","\t\"strconv\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\treconcilersource \"knative.dev/eventing/pkg/reconciler/source\"","\t\"knative.dev/pkg/ptr\"",")","","type ContainerOption func(*corev1.Container)","","func MakeContainer(el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config, opts ...ContainerOption) corev1.Container {","\tisMultiNS := false","\tif len(el.Spec.NamespaceSelector.MatchNames) != 0 {","\t\tisMultiNS = true","\t}","\tfor _, triggerGroup := range el.Spec.TriggerGroups {","\t\tif len(triggerGroup.TriggerSelector.NamespaceSelector.MatchNames) != 0 {","\t\t\tisMultiNS = true","\t\t\tbreak","\t\t}","\t}","","\tpayloadValidation := true","\tif value, ok := el.GetAnnotations()[triggers.PayloadValidationAnnotation]; ok {","\t\tif value == \"false\" {","\t\t\tpayloadValidation = false","\t\t}","\t}","","\tev := configAcc.ToEnvVars()","","\tvar containerSecurityContext *corev1.SecurityContext","\tif el.Spec.Resources.KubernetesResource != nil {","\t\tif len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 {","\t\t\tif *c.SetSecurityContext {","\t\t\t\tcontainerSecurityContext = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].SecurityContext","\t\t\t}","\t\t}","\t}","\tif *c.SetSecurityContext \u0026\u0026 containerSecurityContext == nil {","\t\tcontainerSecurityContext = \u0026corev1.SecurityContext{","\t\t\tAllowPrivilegeEscalation: ptr.Bool(false),","\t\t\tCapabilities: \u0026corev1.Capabilities{","\t\t\t\tDrop: []corev1.Capability{\"ALL\"},","\t\t\t},","\t\t\tRunAsNonRoot: ptr.Bool(cfg.Defaults.DefaultRunAsNonRoot),","\t\t\tSeccompProfile: \u0026corev1.SeccompProfile{","\t\t\t\tType: corev1.SeccompProfileTypeRuntimeDefault,","\t\t\t},","\t\t}","","\t\tif *c.SetReadOnlyRootFilesystem {","\t\t\tcontainerSecurityContext.ReadOnlyRootFilesystem = ptr.Bool(true)","\t\t}","\t\tif !cfg.Defaults.IsDefaultRunAsUserEmpty {","\t\t\tcontainerSecurityContext.RunAsUser = ptr.Int64(cfg.Defaults.DefaultRunAsUser)","\t\t}","\t\tif !cfg.Defaults.IsDefaultRunAsGroupEmpty {","\t\t\tcontainerSecurityContext.RunAsGroup = ptr.Int64(cfg.Defaults.DefaultRunAsGroup)","\t\t}","\t}","","\tcontainer := corev1.Container{","\t\tName:  \"event-listener\",","\t\tImage: *c.Image,","\t\tPorts: []corev1.ContainerPort{{","\t\t\tContainerPort: int32(eventListenerContainerPort),","\t\t\tProtocol:      corev1.ProtocolTCP,","\t\t}},","\t\tArgs: []string{","\t\t\t\"--el-name=\" + el.Name,","\t\t\t\"--el-namespace=\" + el.Namespace,","\t\t\t\"--port=\" + strconv.Itoa(eventListenerContainerPort),","\t\t\t\"--readtimeout=\" + strconv.FormatInt(*c.ReadTimeOut, 10),","\t\t\t\"--writetimeout=\" + strconv.FormatInt(*c.WriteTimeOut, 10),","\t\t\t\"--idletimeout=\" + strconv.FormatInt(*c.IdleTimeOut, 10),","\t\t\t\"--timeouthandler=\" + strconv.FormatInt(*c.TimeOutHandler, 10),","\t\t\t\"--httpclient-readtimeout=\" + strconv.FormatInt(*c.HTTPClientReadTimeOut, 10),","\t\t\t\"--httpclient-keep-alive=\" + strconv.FormatInt(*c.HTTPClientKeepAlive, 10),","\t\t\t\"--httpclient-tlshandshaketimeout=\" + strconv.FormatInt(*c.HTTPClientTLSHandshakeTimeout, 10),","\t\t\t\"--httpclient-responseheadertimeout=\" + strconv.FormatInt(*c.HTTPClientResponseHeaderTimeout, 10),","\t\t\t\"--httpclient-expectcontinuetimeout=\" + strconv.FormatInt(*c.HTTPClientExpectContinueTimeout, 10),","\t\t\t\"--is-multi-ns=\" + strconv.FormatBool(isMultiNS),","\t\t\t\"--payload-validation=\" + strconv.FormatBool(payloadValidation),","\t\t\t\"--cloudevent-uri=\" + el.Spec.CloudEventURI,","\t\t},","\t\tEnv: append(ev, []corev1.EnvVar{{","\t\t\tName:  \"NAMESPACE\",","\t\t\tValue: el.Namespace,","\t\t}, {","\t\t\tName:  \"NAME\",","\t\t\tValue: el.Name,","\t\t}, {","\t\t\tName:  \"EL_EVENT\",","\t\t\tValue: *c.SetEventListenerEvent,","\t\t}, {","\t\t\tName:  \"K_SINK_TIMEOUT\",","\t\t\tValue: strconv.FormatInt(*c.TimeOutHandler, 10),","\t\t}}...),","\t\tSecurityContext: containerSecurityContext,","\t}","","\tfor _, opt := range opts {","\t\topt(\u0026container)","\t}","","\treturn container","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0]},{"id":79,"path":"pkg/reconciler/eventlistener/resources/custom.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resources","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"os\"","\t\"reflect\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\treconcilersource \"knative.dev/eventing/pkg/reconciler/source\"","\tduckv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/kmeta\"",")","","func MakeCustomObject(ctx context.Context, el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config) (*unstructured.Unstructured, error) {","\toriginal := \u0026duckv1.WithPod{}","\tdecoder := json.NewDecoder(bytes.NewBuffer(el.Spec.Resources.CustomResource.Raw))","\tif err := decoder.Decode(\u0026original); err != nil {","\t\treturn nil, err","\t}","","\tcustomObjectData := original.DeepCopy()","","\tnamespace := original.GetNamespace()","\t// Default the resource creation to the EventListenerNamespace if not found in the resource object","\tif namespace == \"\" {","\t\tnamespace = el.GetNamespace()","\t}","","\tcontainer := MakeContainer(el, configAcc, c, cfg, func(c *corev1.Container) {","\t\t// handle env and resources for custom object","\t\tif len(original.Spec.Template.Spec.Containers) == 1 {","\t\t\tc.Env = append(c.Env, original.Spec.Template.Spec.Containers[0].Env...)","\t\t\tc.Resources = original.Spec.Template.Spec.Containers[0].Resources","\t\t}","","\t\tc.Env = append(c.Env, corev1.EnvVar{","\t\t\tName: \"SYSTEM_NAMESPACE\",","\t\t\t// Cannot use FieldRef here because Knative Serving mask that field under feature gate","\t\t\t// https://github.com/knative/serving/blob/master/pkg/apis/config/features.go#L48","\t\t\tValue: el.Namespace,","\t\t}, corev1.EnvVar{","\t\t\t// METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint","\t\t\t// env METRICS_PROMETHEUS_PORT set by controller","\t\t\tName:  \"METRICS_PROMETHEUS_PORT\",","\t\t\tValue: os.Getenv(\"METRICS_PROMETHEUS_PORT\"),","\t\t}, corev1.EnvVar{","\t\t\t// KUBERNETES_MIN_VERSION overrides the Min version of k8s required","\t\t\tName:  \"KUBERNETES_MIN_VERSION\",","\t\t\tValue: os.Getenv(\"KUBERNETES_MIN_VERSION\"),","\t\t})","","\t\tc.ReadinessProbe = \u0026corev1.Probe{","\t\t\tProbeHandler: corev1.ProbeHandler{","\t\t\t\tHTTPGet: \u0026corev1.HTTPGetAction{","\t\t\t\t\tPath:   \"/live\",","\t\t\t\t\tScheme: corev1.URISchemeHTTP,","\t\t\t\t},","\t\t\t},","\t\t\tSuccessThreshold: 1,","\t\t}","\t})","","\tpodlabels := kmeta.UnionMaps(FilterLabels(ctx, el.Labels), GenerateLabels(el.Name, c.StaticResourceLabels))","","\tpodlabels = kmeta.UnionMaps(podlabels, customObjectData.Labels)","","\toriginal.Labels = podlabels","\toriginal.Annotations = customObjectData.Annotations","\toriginal.Spec.Template.ObjectMeta = metav1.ObjectMeta{","\t\tName:        customObjectData.Spec.Template.Name,","\t\tLabels:      customObjectData.Spec.Template.Labels,","\t\tAnnotations: customObjectData.Spec.Template.Annotations,","\t}","\toriginal.Spec.Template.Spec = corev1.PodSpec{","\t\tTolerations:               customObjectData.Spec.Template.Spec.Tolerations,","\t\tNodeSelector:              customObjectData.Spec.Template.Spec.NodeSelector,","\t\tServiceAccountName:        customObjectData.Spec.Template.Spec.ServiceAccountName,","\t\tContainers:                []corev1.Container{container},","\t\tAffinity:                  customObjectData.Spec.Template.Spec.Affinity,","\t\tTopologySpreadConstraints: customObjectData.Spec.Template.Spec.TopologySpreadConstraints,","\t}","\tmarshaledData, err := json.Marshal(original)","\tif err != nil {","\t\treturn nil, err","\t}","\tdata := new(unstructured.Unstructured)","\tif err := data.UnmarshalJSON(marshaledData); err != nil {","\t\treturn nil, err","\t}","","\tif data.GetName() == \"\" {","\t\tdata.SetName(el.Status.Configuration.GeneratedResourceName)","\t}","\tdata.SetNamespace(namespace)","\tdata.SetOwnerReferences([]metav1.OwnerReference{*kmeta.NewControllerRef(el)})","","\treturn data, nil","}","","func UpdateCustomObject(originalData, updatedCustomObject *unstructured.Unstructured) (bool, *duckv1.WithPod, error) {","\tupdated := false","\toriginalObject := \u0026duckv1.WithPod{}","\texistingObject := \u0026duckv1.WithPod{}","\tdata, e := originalData.MarshalJSON()","\tif e != nil {","\t\treturn false, nil, e","\t}","\tif e := json.Unmarshal(data, \u0026originalObject); e != nil {","\t\treturn false, nil, e","\t}","\tupdatedData, e := updatedCustomObject.MarshalJSON()","\tif e != nil {","\t\treturn false, nil, e","\t}","\tif e := json.Unmarshal(updatedData, \u0026existingObject); e != nil {","\t\treturn false, nil, e","\t}","","\t// custom resource except few spec fields from user","\t// added below checks in order to avoid unwanted updates on all spec changes.","\tif !reflect.DeepEqual(existingObject.Spec.Template.Name, originalObject.Spec.Template.Name) {","\t\texistingObject.Spec.Template.Name = originalObject.Spec.Template.Name","\t\tupdated = true","\t}","\tif !reflect.DeepEqual(existingObject.Spec.Template.Labels, originalObject.Spec.Template.Labels) {","\t\texistingObject.Spec.Template.Labels = originalObject.Spec.Template.Labels","\t\tupdated = true","\t}","\tif !reflect.DeepEqual(existingObject.Spec.Template.Annotations, originalObject.Spec.Template.Annotations) {","\t\texistingObject.Spec.Template.Annotations = originalObject.Spec.Template.Annotations","\t\tupdated = true","\t}","\tif existingObject.Spec.Template.Spec.ServiceAccountName != originalObject.Spec.Template.Spec.ServiceAccountName {","\t\texistingObject.Spec.Template.Spec.ServiceAccountName = originalObject.Spec.Template.Spec.ServiceAccountName","\t\tupdated = true","\t}","\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Tolerations, originalObject.Spec.Template.Spec.Tolerations) {","\t\texistingObject.Spec.Template.Spec.Tolerations = originalObject.Spec.Template.Spec.Tolerations","\t\tupdated = true","\t}","\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.NodeSelector, originalObject.Spec.Template.Spec.NodeSelector) {","\t\texistingObject.Spec.Template.Spec.NodeSelector = originalObject.Spec.Template.Spec.NodeSelector","\t\tupdated = true","\t}","\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Affinity, originalObject.Spec.Template.Spec.Affinity) {","\t\texistingObject.Spec.Template.Spec.Affinity = originalObject.Spec.Template.Spec.Affinity","\t\tupdated = true","\t}","\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.TopologySpreadConstraints, originalObject.Spec.Template.Spec.TopologySpreadConstraints) {","\t\texistingObject.Spec.Template.Spec.TopologySpreadConstraints = originalObject.Spec.Template.Spec.TopologySpreadConstraints","\t\tupdated = true","\t}","\tif len(existingObject.Spec.Template.Spec.Containers) == 0 ||","\t\tlen(existingObject.Spec.Template.Spec.Containers) \u003e 1 {","\t\texistingObject.Spec.Template.Spec.Containers = originalObject.Spec.Template.Spec.Containers","\t\tupdated = true","\t} else {","\t\tif existingObject.Spec.Template.Spec.Containers[0].Name != originalObject.Spec.Template.Spec.Containers[0].Name {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].Name = originalObject.Spec.Template.Spec.Containers[0].Name","\t\t\tupdated = true","\t\t}","\t\tif existingObject.Spec.Template.Spec.Containers[0].Image != originalObject.Spec.Template.Spec.Containers[0].Image {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].Image = originalObject.Spec.Template.Spec.Containers[0].Image","\t\t\tupdated = true","\t\t}","\t\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Ports, originalObject.Spec.Template.Spec.Containers[0].Ports) {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].Ports = originalObject.Spec.Template.Spec.Containers[0].Ports","\t\t\tupdated = true","\t\t}","\t\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Args, originalObject.Spec.Template.Spec.Containers[0].Args) {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].Args = originalObject.Spec.Template.Spec.Containers[0].Args","\t\t\tupdated = true","\t\t}","\t\tif existingObject.Spec.Template.Spec.Containers[0].Command != nil {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].Command = nil","\t\t\tupdated = true","\t\t}","\t\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Resources, originalObject.Spec.Template.Spec.Containers[0].Resources) {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].Resources = originalObject.Spec.Template.Spec.Containers[0].Resources","\t\t\tupdated = true","\t\t}","\t\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].Env, originalObject.Spec.Template.Spec.Containers[0].Env) {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].Env = originalObject.Spec.Template.Spec.Containers[0].Env","\t\t\tupdated = true","\t\t}","\t\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].ReadinessProbe, originalObject.Spec.Template.Spec.Containers[0].ReadinessProbe) {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].ReadinessProbe = originalObject.Spec.Template.Spec.Containers[0].ReadinessProbe","\t\t\tupdated = true","\t\t}","\t\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Containers[0].VolumeMounts, originalObject.Spec.Template.Spec.Containers[0].VolumeMounts) {","\t\t\texistingObject.Spec.Template.Spec.Containers[0].VolumeMounts = originalObject.Spec.Template.Spec.Containers[0].VolumeMounts","\t\t\tupdated = true","\t\t}","\t\tif !reflect.DeepEqual(existingObject.Spec.Template.Spec.Volumes, originalObject.Spec.Template.Spec.Volumes) {","\t\t\texistingObject.Spec.Template.Spec.Volumes = originalObject.Spec.Template.Spec.Volumes","\t\t\tupdated = true","\t\t}","\t}","","\treturn updated, existingObject, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,1,1,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,1,1,2,1,1,2,2,1,1,2,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0]},{"id":80,"path":"pkg/reconciler/eventlistener/resources/deployment.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resources","","import (","\t\"context\"","\t\"os\"","\t\"strconv\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tappsv1 \"k8s.io/api/apps/v1\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/util/intstr\"","\treconcilersource \"knative.dev/eventing/pkg/reconciler/source\"","\t\"knative.dev/pkg/kmeta\"","\t\"knative.dev/pkg/ptr\"",")","","const (","\tTriggersMetricsDomain = \"tekton.dev/triggers\"",")","","var (","\tbaseSecurityPolicy = \u0026corev1.PodSecurityContext{","\t\tRunAsNonRoot: ptr.Bool(true),","\t\tSeccompProfile: \u0026corev1.SeccompProfile{","\t\t\tType: corev1.SeccompProfileTypeRuntimeDefault,","\t\t},","\t}",")","","func getStrongerSecurityPolicy(cfg *config.Config) *corev1.PodSecurityContext {","\tsecurityContext := baseSecurityPolicy","\tif !cfg.Defaults.IsDefaultRunAsUserEmpty {","\t\tsecurityContext.RunAsUser = ptr.Int64(cfg.Defaults.DefaultRunAsUser)","\t}","","\tif !cfg.Defaults.IsDefaultRunAsGroupEmpty {","\t\tsecurityContext.RunAsGroup = ptr.Int64(cfg.Defaults.DefaultRunAsGroup)","\t}","","\tif !cfg.Defaults.IsDefaultFsGroupEmpty {","\t\tsecurityContext.FSGroup = ptr.Int64(cfg.Defaults.DefaultFSGroup)","\t}","","\treturn securityContext","}","","func MakeDeployment(ctx context.Context, el *v1beta1.EventListener, configAcc reconcilersource.ConfigAccessor, c Config, cfg *config.Config) (*appsv1.Deployment, error) {","\topt, err := addDeploymentBits(el, c)","\tif err != nil {","\t\treturn nil, err","\t}","\tcontainer := MakeContainer(el, configAcc, c, cfg, opt, addCertsForSecureConnection(c))","","\tfilteredLabels := FilterLabels(ctx, el.Labels)","","\tvar (","\t\tpodlabels                 = kmeta.UnionMaps(filteredLabels, GenerateLabels(el.Name, c.StaticResourceLabels))","\t\tserviceAccountName        = el.Spec.ServiceAccountName","\t\treplicas                  *int32","\t\tvol                       []corev1.Volume","\t\ttolerations               []corev1.Toleration","\t\tnodeSelector, annotations map[string]string","\t\taffinity                  *corev1.Affinity","\t\ttopologySpreadConstraints []corev1.TopologySpreadConstraint","\t\timagePullSecrets          []corev1.LocalObjectReference","\t)","","\tfor _, v := range container.Env {","\t\t// If TLS related env are set then mount secret volume which will be used while starting the eventlistener.","\t\tif v.Name == \"TLS_CERT\" {","\t\t\tvol = append(vol, corev1.Volume{","\t\t\t\tName: \"https-connection\",","\t\t\t\tVolumeSource: corev1.VolumeSource{","\t\t\t\t\tSecret: \u0026corev1.SecretVolumeSource{","\t\t\t\t\t\tSecretName: v.ValueFrom.SecretKeyRef.Name,","\t\t\t\t\t},","\t\t\t\t},","\t\t\t})","\t\t}","\t}","","\tvar securityContext *corev1.PodSecurityContext","\tif el.Spec.Resources.KubernetesResource != nil {","\t\tif el.Spec.Resources.KubernetesResource.Replicas != nil {","\t\t\treplicas = el.Spec.Resources.KubernetesResource.Replicas","\t\t}","\t\tif len(el.Spec.Resources.KubernetesResource.Template.Spec.Tolerations) != 0 {","\t\t\ttolerations = el.Spec.Resources.KubernetesResource.Template.Spec.Tolerations","\t\t}","\t\tif len(el.Spec.Resources.KubernetesResource.Template.Spec.NodeSelector) != 0 {","\t\t\tnodeSelector = el.Spec.Resources.KubernetesResource.Template.Spec.NodeSelector","\t\t}","\t\tif len(el.Spec.Resources.KubernetesResource.Template.Spec.ImagePullSecrets) != 0 {","\t\t\timagePullSecrets = el.Spec.Resources.KubernetesResource.Template.Spec.ImagePullSecrets","\t\t}","\t\tif el.Spec.Resources.KubernetesResource.Template.Spec.ServiceAccountName != \"\" {","\t\t\tserviceAccountName = el.Spec.Resources.KubernetesResource.Template.Spec.ServiceAccountName","\t\t}","\t\tif el.Spec.Resources.KubernetesResource.Template.Spec.Affinity != nil {","\t\t\taffinity = el.Spec.Resources.KubernetesResource.Template.Spec.Affinity","\t\t}","\t\tif len(el.Spec.Resources.KubernetesResource.Template.Spec.TopologySpreadConstraints) != 0 {","\t\t\ttopologySpreadConstraints = el.Spec.Resources.KubernetesResource.Template.Spec.TopologySpreadConstraints","\t\t}","\t\tannotations = el.Spec.Resources.KubernetesResource.Template.Annotations","\t\tpodlabels = kmeta.UnionMaps(podlabels, el.Spec.Resources.KubernetesResource.Template.Labels)","\t\tif *c.SetSecurityContext {","\t\t\tsecurityContext = el.Spec.Resources.KubernetesResource.Template.Spec.SecurityContext","\t\t}","\t}","","\tif *c.SetSecurityContext \u0026\u0026 securityContext == nil {","\t\tsecurityContext = getStrongerSecurityPolicy(cfg)","\t}","","\treturn \u0026appsv1.Deployment{","\t\tObjectMeta: ObjectMeta(el, filteredLabels, c.StaticResourceLabels),","\t\tSpec: appsv1.DeploymentSpec{","\t\t\tReplicas: replicas,","\t\t\tSelector: \u0026metav1.LabelSelector{","\t\t\t\tMatchLabels: GenerateLabels(el.Name, c.StaticResourceLabels),","\t\t\t},","\t\t\tTemplate: corev1.PodTemplateSpec{","\t\t\t\tObjectMeta: metav1.ObjectMeta{","\t\t\t\t\tLabels:      podlabels,","\t\t\t\t\tAnnotations: annotations,","\t\t\t\t},","\t\t\t\tSpec: corev1.PodSpec{","\t\t\t\t\tImagePullSecrets:          imagePullSecrets,","\t\t\t\t\tTolerations:               tolerations,","\t\t\t\t\tNodeSelector:              nodeSelector,","\t\t\t\t\tServiceAccountName:        serviceAccountName,","\t\t\t\t\tContainers:                []corev1.Container{container},","\t\t\t\t\tVolumes:                   vol,","\t\t\t\t\tSecurityContext:           securityContext,","\t\t\t\t\tAffinity:                  affinity,","\t\t\t\t\tTopologySpreadConstraints: topologySpreadConstraints,","\t\t\t\t},","\t\t\t},","\t\t},","\t}, nil","}","","// revive:disable:unused-parameter","","func addDeploymentBits(el *v1beta1.EventListener, c Config) (ContainerOption, error) {","\t// METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint","\t// env METRICS_PROMETHEUS_PORT set by controller","\tmetricsPort, err := strconv.ParseInt(os.Getenv(\"METRICS_PROMETHEUS_PORT\"), 10, 32)","\tif err != nil {","\t\treturn nil, err","\t}","","\treturn func(container *corev1.Container) {","\t\tif el.Spec.Resources.KubernetesResource != nil {","\t\t\tif len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 {","\t\t\t\tcontainer.Resources = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Resources","\t\t\t\tcontainer.Env = append(container.Env, el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env...)","\t\t\t\tcontainer.ReadinessProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].ReadinessProbe","\t\t\t\tcontainer.LivenessProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].LivenessProbe","\t\t\t\tcontainer.StartupProbe = el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].StartupProbe","\t\t\t}","\t\t}","\t\tcontainer.Ports = append(container.Ports, corev1.ContainerPort{","\t\t\tContainerPort: int32(metricsPort), //nolint: gosec","\t\t\tProtocol:      corev1.ProtocolTCP,","\t\t})","","\t\tcontainer.Env = append(container.Env, corev1.EnvVar{","\t\t\tName: \"SYSTEM_NAMESPACE\",","\t\t\tValueFrom: \u0026corev1.EnvVarSource{","\t\t\t\tFieldRef: \u0026corev1.ObjectFieldSelector{","\t\t\t\t\tAPIVersion: \"v1\",","\t\t\t\t\tFieldPath:  \"metadata.namespace\",","\t\t\t\t}},","\t\t}, corev1.EnvVar{","\t\t\t// METRICS_PROMETHEUS_PORT defines the port exposed by the EventListener metrics endpoint","\t\t\t// env METRICS_PROMETHEUS_PORT set by controller","\t\t\tName:  \"METRICS_PROMETHEUS_PORT\",","\t\t\tValue: os.Getenv(\"METRICS_PROMETHEUS_PORT\"),","\t\t}, corev1.EnvVar{","\t\t\t// KUBERNETES_MIN_VERSION overrides the min k8s version required to run EL.","\t\t\tName:  \"KUBERNETES_MIN_VERSION\",","\t\t\tValue: os.Getenv(\"KUBERNETES_MIN_VERSION\"),","\t\t})","\t}, nil","}","","func addCertsForSecureConnection(c Config) ContainerOption {","\treturn func(container *corev1.Container) {","\t\tvar elCert, elKey string","\t\tcertEnv := map[string]*corev1.EnvVarSource{}","\t\tfor i := range container.Env {","\t\t\tcertEnv[container.Env[i].Name] = container.Env[i].ValueFrom","\t\t}","\t\tvar scheme corev1.URIScheme","\t\tif v, ok := certEnv[\"TLS_CERT\"]; ok {","\t\t\telCert = \"/etc/triggers/tls/\" + v.SecretKeyRef.Key","\t\t} else {","\t\t\telCert = \"\"","\t\t}","\t\tif v, ok := certEnv[\"TLS_KEY\"]; ok {","\t\t\telKey = \"/etc/triggers/tls/\" + v.SecretKeyRef.Key","\t\t} else {","\t\t\telKey = \"\"","\t\t}","","\t\tif elCert != \"\" \u0026\u0026 elKey != \"\" {","\t\t\tscheme = corev1.URISchemeHTTPS","\t\t\tcontainer.VolumeMounts = append(container.VolumeMounts, corev1.VolumeMount{","\t\t\t\tName:      \"https-connection\",","\t\t\t\tReadOnly:  true,","\t\t\t\tMountPath: \"/etc/triggers/tls\",","\t\t\t})","\t\t} else {","\t\t\tscheme = corev1.URISchemeHTTP","\t\t}","\t\tif container.LivenessProbe == nil {","\t\t\tcontainer.LivenessProbe = \u0026corev1.Probe{","\t\t\t\tProbeHandler: corev1.ProbeHandler{","\t\t\t\t\tHTTPGet: \u0026corev1.HTTPGetAction{","\t\t\t\t\t\tPath:   \"/live\",","\t\t\t\t\t\tScheme: scheme,","\t\t\t\t\t\tPort:   intstr.FromInt(eventListenerContainerPort),","\t\t\t\t\t},","\t\t\t\t},","\t\t\t\tPeriodSeconds:    int32(*c.PeriodSeconds),    //nolint: gosec","\t\t\t\tFailureThreshold: int32(*c.FailureThreshold), //nolint: gosec","\t\t\t}","\t\t}","\t\tif container.ReadinessProbe == nil {","\t\t\tcontainer.ReadinessProbe = \u0026corev1.Probe{","\t\t\t\tProbeHandler: corev1.ProbeHandler{","\t\t\t\t\tHTTPGet: \u0026corev1.HTTPGetAction{","\t\t\t\t\t\tPath:   \"/live\",","\t\t\t\t\t\tScheme: scheme,","\t\t\t\t\t\tPort:   intstr.FromInt(eventListenerContainerPort),","\t\t\t\t\t},","\t\t\t\t},","\t\t\t\tPeriodSeconds:    int32(*c.PeriodSeconds),    //nolint: gosec","\t\t\t\tFailureThreshold: int32(*c.FailureThreshold), //nolint: gosec","\t\t\t}","\t\t}","\t\tcontainer.Args = append(container.Args, \"--tls-cert=\"+elCert, \"--tls-key=\"+elKey)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,0,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0]},{"id":81,"path":"pkg/reconciler/eventlistener/resources/meta.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resources","","import (","\t\"context\"","\t\"regexp\"","","\t\"github.com/tektoncd/triggers/pkg/apis/config\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"knative.dev/pkg/kmeta\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"",")","","// ObjectMeta generates the object meta that should be used by all","// resources generated by the EventListener reconciler","func ObjectMeta(el *v1beta1.EventListener, filteredElLabels, staticResourceLabels map[string]string) metav1.ObjectMeta {","\treturn metav1.ObjectMeta{","\t\tNamespace:       el.Namespace,","\t\tName:            el.Status.Configuration.GeneratedResourceName,","\t\tOwnerReferences: []metav1.OwnerReference{*kmeta.NewControllerRef(el)},","\t\tLabels:          kmeta.UnionMaps(filteredElLabels, GenerateLabels(el.Name, staticResourceLabels)),","\t\tAnnotations:     el.Annotations,","\t}","}","","// GenerateLabels generates the labels to be used on all generated resources.","func GenerateLabels(eventListenerName string, staticResourceLabels map[string]string) map[string]string {","\tresourceLabels := kmeta.CopyMap(staticResourceLabels)","\tresourceLabels[\"eventlistener\"] = eventListenerName","\treturn resourceLabels","}","","// FilterLabels filters label based on regex pattern defined in","// feature-flag `labels-exclusion-pattern`","func FilterLabels(ctx context.Context, labels map[string]string) map[string]string {","\tcfg := config.FromContextOrDefaults(ctx)","","\tif len(labels) == 0 || cfg.FeatureFlags.LabelsExclusionPattern == \"\" {","\t\treturn labels","\t}","","\tfilteredLabels := make(map[string]string)","\tr := regexp.MustCompile(cfg.FeatureFlags.LabelsExclusionPattern)","","\tfor key, value := range labels {","\t\tif !r.MatchString(key) {","\t\t\tfilteredLabels[key] = value","\t\t}","\t}","","\treturn filteredLabels","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,2,0]},{"id":82,"path":"pkg/reconciler/eventlistener/resources/service.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resources","","import (","\t\"context\"","\t\"fmt\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/util/intstr\"","\t\"knative.dev/pkg/network\"",")","","const (","\t// eventListenerServicePortName defines service port name for EventListener Service","\teventListenerServicePortName = \"http-listener\"","\t// eventListenerServiceTLSPortName defines service TLS port name for EventListener Service","\teventListenerServiceTLSPortName = \"https-listener\"","\t// eventListenerMetricsPortName defines the metrics port name by the EventListener Container","\teventListenerMetricsPortName = \"http-metrics\"","\t// eventListenerContainerPort defines service port for EventListener Service","\teventListenerContainerPort = 8080","\t// eventListenerMetricsPort defines metrics port for EventListener Service","\teventListenerMetricsPort = 9000",")","","var metricsPort = corev1.ServicePort{","\tName:     eventListenerMetricsPortName,","\tProtocol: corev1.ProtocolTCP,","\tPort:     int32(9000),","\tTargetPort: intstr.IntOrString{","\t\tIntVal: int32(eventListenerMetricsPort),","\t},","}","","func MakeService(ctx context.Context, el *v1beta1.EventListener, c Config) *corev1.Service {","\t// for backward compatibility with original behavior","\tvar (","\t\tserviceType corev1.ServiceType","\t\tservicePort corev1.ServicePort","\t)","\tif el.Spec.Resources.KubernetesResource != nil \u0026\u0026 el.Spec.Resources.KubernetesResource.ServiceType != \"\" {","\t\tserviceType = el.Spec.Resources.KubernetesResource.ServiceType","\t}","\tif el.Spec.Resources.KubernetesResource != nil \u0026\u0026 el.Spec.Resources.KubernetesResource.ServicePort != nil {","\t\tport := int(*el.Spec.Resources.KubernetesResource.ServicePort)","\t\tc.Port = \u0026port","\t}","","\tservicePort = ServicePort(el, c)","","\tsvc := \u0026corev1.Service{","\t\tObjectMeta: ObjectMeta(el, FilterLabels(ctx, el.Labels), c.StaticResourceLabels),","\t\tSpec: corev1.ServiceSpec{","\t\t\tSelector: GenerateLabels(el.Name, c.StaticResourceLabels),","\t\t\tType:     serviceType,","\t\t\tPorts:    []corev1.ServicePort{servicePort, metricsPort}},","\t}","","\tif el.Spec.Resources.KubernetesResource != nil \u0026\u0026 el.Spec.Resources.KubernetesResource.ServiceLoadBalancerClass != nil {","\t\tsvc.Spec.LoadBalancerClass = el.Spec.Resources.KubernetesResource.ServiceLoadBalancerClass","\t}","","\treturn svc","}","","func ServicePort(el *v1beta1.EventListener, c Config) corev1.ServicePort {","\tvar elCert, elKey string","","\tnodePort := int32(0)","\tservicePortName := eventListenerServicePortName","\tservicePort := *c.Port","","\tcertEnv := map[string]*corev1.EnvVarSource{}","\tif el.Spec.Resources.KubernetesResource != nil {","\t\tif len(el.Spec.Resources.KubernetesResource.Template.Spec.Containers) != 0 {","\t\t\tfor i := range el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env {","\t\t\t\tcertEnv[el.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env[i].Name] =","\t\t\t\t\tel.Spec.Resources.KubernetesResource.Template.Spec.Containers[0].Env[i].ValueFrom","\t\t\t}","\t\t}","\t\tif el.Spec.Resources.KubernetesResource.ServicePort != nil {","\t\t\tservicePort = int(*el.Spec.Resources.KubernetesResource.ServicePort)","\t\t\tif el.Spec.Resources.KubernetesResource.ServiceType == corev1.ServiceTypeNodePort {","\t\t\t\tnodePort = *el.Spec.Resources.KubernetesResource.ServicePort","\t\t\t}","\t\t}","\t}","","\tif v, ok := certEnv[\"TLS_CERT\"]; ok {","\t\telCert = v.SecretKeyRef.Key","\t} else {","\t\telCert = \"\"","\t}","\tif v, ok := certEnv[\"TLS_KEY\"]; ok {","\t\telKey = v.SecretKeyRef.Key","\t} else {","\t\telKey = \"\"","\t}","","\tif elCert != \"\" \u0026\u0026 elKey != \"\" {","\t\tservicePortName = eventListenerServiceTLSPortName","\t\tif *c.Port == DefaultPort {","\t\t\t// We return port 8443 if TLS is enabled and the default HTTP port is set.","\t\t\t// This effectively makes 8443 the default HTTPS port unless a user explicitly sets a different port.","\t\t\tservicePort = 8443","\t\t}","\t}","","\tsvc := corev1.ServicePort{","\t\tName:     servicePortName,","\t\tProtocol: corev1.ProtocolTCP,","\t\tPort:     int32(servicePort), //nolint: gosec","\t\tTargetPort: intstr.IntOrString{","\t\t\tIntVal: int32(eventListenerContainerPort),","\t\t},","\t\tNodePort: nodePort,","\t}","","\treturn svc","}","","// ListenerHostname returns the intended hostname for the EventListener service.","func ListenerHostname(el *v1beta1.EventListener, c Config) string {","\tsp := ServicePort(el, c)","\treturn network.GetServiceHostname(el.Status.Configuration.GeneratedResourceName, el.Namespace) + fmt.Sprintf(\":%d\", sp.Port)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2]},{"id":83,"path":"pkg/reconciler/events/event.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","package events","","import (","\tcorev1 \"k8s.io/api/core/v1\"","\t\"k8s.io/apimachinery/pkg/runtime\"","\t\"k8s.io/client-go/tools/record\"",")","","const (","\t// TriggerProcessingStartedV1 is sent for Sink Triggers when a trigger is started","\tTriggerProcessingStartedV1 = \"dev.tekton.event.triggers.started.v1\"","\t// TriggerProcessingSuccessfulV1 is sent for Sink Triggers when a trigger is successful","\tTriggerProcessingSuccessfulV1 = \"dev.tekton.event.triggers.successful.v1\"","\t// TriggerProcessingFailedEventV1 is sent for Sink Triggers when we fail to process trigger","\tTriggerProcessingFailedV1 = \"dev.tekton.event.triggers.failed.v1\"","\t// TriggerProcessingDoneV1 is sent for Sink Triggers when we are done","\t// with eventlistener handler","\tTriggerProcessingDoneV1 = \"dev.tekton.event.triggers.done.v1\"","\t// EventAccepted is sent as response for CloudEvent compliant providers","\tEventAccepted = \"dev.tekton.event.triggers.accepted.v1\"",")","","// Emit emits events for object","// Supported events are k8s events.","func Emit(recorder record.EventRecorder, eventType string, object runtime.Object, err error) {","\tsendKubernetesEvents(recorder, eventType, object, err)","}","","func sendKubernetesEvents(c record.EventRecorder, eventType string, object runtime.Object, err error) {","\tswitch err {","\tcase nil:","\t\tif eventType == TriggerProcessingFailedV1 {","\t\t\tc.Event(object, corev1.EventTypeWarning, eventType, \"\")","\t\t} else {","\t\t\tc.Event(object, corev1.EventTypeNormal, eventType, \"\")","\t\t}","\tdefault:","\t\tc.Event(object, corev1.EventTypeWarning, eventType, err.Error())","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,2,2,2,2,1,2,2,2,2,2,0,0]},{"id":84,"path":"pkg/reconciler/interceptor/controller.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package interceptor","","import (","\t\"context\"","","\tinterceptorinformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/interceptor\"","\tinterceptorreconciler \"github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor\"","\t\"knative.dev/pkg/configmap\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/logging\"",")","","func NewController() func(context.Context, configmap.Watcher) *controller.Impl {","\treturn func(ctx context.Context, _ configmap.Watcher) *controller.Impl {","\t\tinterceptorInformer := interceptorinformer.Get(ctx)","\t\treconciler := \u0026Reconciler{}","","\t\timpl := interceptorreconciler.NewImpl(ctx, reconciler, func(_ *controller.Impl) controller.Options {","\t\t\treturn controller.Options{","\t\t\t\tAgentName: ControllerName,","\t\t\t}","\t\t})","","\t\tif _, err := interceptorInformer.Informer().AddEventHandler(controller.HandleAll(impl.Enqueue)); err != nil {","\t\t\tlogging.FromContext(ctx).Panicf(\"Couldn't register Interceptor informer event handler: %w\", err)","\t\t}","","\t\treturn impl","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0]},{"id":85,"path":"pkg/reconciler/interceptor/interceptor.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","\t\thttp://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package interceptor","","import (","\t\"context\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/contexts\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers/v1alpha1\"","\tinterceptorreconciler \"github.com/tektoncd/triggers/pkg/client/injection/reconciler/triggers/v1alpha1/interceptor\"","\tv1 \"knative.dev/pkg/apis/duck/v1\"","\t\"knative.dev/pkg/logging\"","\tpkgreconciler \"knative.dev/pkg/reconciler\"",")","","const ControllerName = \"Interceptor\"","","// Reconciler implements controller.Reconciler for Configuration resources.","type Reconciler struct {","}","","var (","\t// Check that our Reconciler implements interceptorreconciler.Interface","\t_ interceptorreconciler.Interface = (*Reconciler)(nil)",")","","func (r *Reconciler) ReconcileKind(ctx context.Context, it *v1alpha1.Interceptor) pkgreconciler.Event {","\tlogger := logging.FromContext(ctx)","\tif it.Status.Address == nil { // Initialize Address if needed","\t\tit.Status.Address = \u0026v1.Addressable{}","\t}","\tif contexts.IsUpgradeViaDefaulting(ctx) { // Set defaults","\t\tit.SetDefaults(ctx)","\t}","\turl, err := it.ResolveAddress()","\tlogger.Debugf(\"Resolved Address is %s\", url)","\tif err != nil {","\t\treturn err","\t}","\tit.Status.Address.URL = url","\treturn nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,0]},{"id":86,"path":"pkg/reconciler/metrics/injection.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package metrics","","import (","\t\"context\"","","\tciInformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1alpha1/clusterinterceptor\"","\tctbInformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/clustertriggerbinding\"","\telInformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/eventlistener\"","\ttbInformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggerbinding\"","\tttInformer \"github.com/tektoncd/triggers/pkg/client/injection/informers/triggers/v1beta1/triggertemplate\"","\t\"k8s.io/client-go/rest\"","\t\"knative.dev/pkg/controller\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context { return WithClient(ctx) })","\tinjection.Default.RegisterInformer(WithInformer)","}","","// RecorderKey is used for associating the Recorder inside the context.Context.","type RecorderKey struct{}","","func WithClient(ctx context.Context) context.Context {","\trec, err := NewRecorder(ctx)","\tif err != nil {","\t\tlogging.FromContext(ctx).Errorf(\"Failed to create trigger metrics recorder %v\", err)","\t}","\treturn context.WithValue(ctx, RecorderKey{}, rec)","}","","// Get extracts the pipelinerunmetrics.Recorder from the context.","func Get(ctx context.Context) *Recorder {","\tuntyped := ctx.Value(RecorderKey{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Panic(\"Unable to fetch *metrics.Recorder from context.\")","\t}","\treturn untyped.(*Recorder)","}","","type recorderInformer struct {","\tctx     context.Context //nolint:containedctx","\tmetrics *Recorder","\tlisters","}","","// InformerKey is used for associating the Informer inside the context.Context.","type InformerKey struct{}","","func WithInformer(ctx context.Context) (context.Context, controller.Informer) {","\treturn ctx, \u0026recorderInformer{","\t\tctx:     ctx,","\t\tmetrics: Get(ctx),","\t\tlisters: listers{","\t\t\tel:  elInformer.Get(ctx).Lister(),","\t\t\tctb: ctbInformer.Get(ctx).Lister(),","\t\t\ttb:  tbInformer.Get(ctx).Lister(),","\t\t\ttt:  ttInformer.Get(ctx).Lister(),","\t\t\tci:  ciInformer.Get(ctx).Lister(),","\t\t},","\t}","}","","var _ controller.Informer = (*recorderInformer)(nil)","","func (ri *recorderInformer) Run(stopCh \u003c-chan struct{}) {","\t// Turn the stopCh into a context for reporting metrics.","\tctx, cancel := context.WithCancel(ri.ctx)","\tgo func() {","\t\t\u003c-stopCh","\t\tcancel()","\t}()","","\tgo ri.metrics.ReportCountMetrics(ctx, ri.listers)","}","","func (ri *recorderInformer) HasSynced() bool {","\treturn true","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0,2,2,2,1,1,2,0,0,0,2,2,2,1,1,2,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,1]},{"id":87,"path":"pkg/reconciler/metrics/metrics.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package metrics","","import (","\t\"context\"","\t\"sync\"","\t\"time\"","","\t\"github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1\"","\t\"github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1\"","","\t\"go.opencensus.io/stats\"","\t\"go.opencensus.io/stats/view\"","\t\"k8s.io/apimachinery/pkg/labels\"","\t\"knative.dev/pkg/logging\"","\t\"knative.dev/pkg/metrics\"",")","","var (","\telMetricsName = \"eventlistener_count\"","\telCount       = stats.Float64(elMetricsName,","\t\t\"number of eventlistener\",","\t\tstats.UnitDimensionless)","\telCountView *view.View","","\ttbMetricsName = \"triggerbinding_count\"","\ttbCount       = stats.Float64(tbMetricsName,","\t\t\"number of triggerbinding\",","\t\tstats.UnitDimensionless)","\ttbCountView *view.View","","\tctbMetricsName = \"clustertriggerbinding_count\"","\tctbCount       = stats.Float64(ctbMetricsName,","\t\t\"number of clustertriggerbinding\",","\t\tstats.UnitDimensionless)","\tctbCountView *view.View","","\tttMetricsName = \"triggertemplate_count\"","\tttCount       = stats.Float64(ttMetricsName,","\t\t\"number of triggertemplate\",","\t\tstats.UnitDimensionless)","\tttCountView *view.View","","\tciMetricsName = \"clusterinterceptor_count\"","\tciCount       = stats.Float64(ciMetricsName,","\t\t\"number of clusterinterceptor\",","\t\tstats.UnitDimensionless)","\tciCountView *view.View",")","","type listers struct {","\tel  v1beta1.EventListenerLister","\tctb v1beta1.ClusterTriggerBindingLister","\ttb  v1beta1.TriggerBindingLister","\ttt  v1beta1.TriggerTemplateLister","\tci  v1alpha1.ClusterInterceptorLister","}","","// Recorder holds information for Trigger metrics","type Recorder struct {","\tinitialized     bool","\tReportingPeriod time.Duration","}","","// We cannot register the view multiple times, so NewRecorder lazily","// initializes this singleton and returns the same recorder across any","// subsequent invocations.","var (","\tonce        sync.Once","\tr           *Recorder","\trecorderErr error //nolint:errname",")","","// revive:disable:unused-parameter","","// NewRecorder creates a new metrics recorder instance","// to log the PipelineRun related metrics","func NewRecorder(ctx context.Context) (*Recorder, error) {","\tonce.Do(func() {","\t\tr = \u0026Recorder{","\t\t\tinitialized: true,","\t\t\t// Default to reporting metrics every 60s.","\t\t\tReportingPeriod: 60 * time.Second,","\t\t}","","\t\trecorderErr = viewRegister()","\t\tif recorderErr != nil {","\t\t\tr.initialized = false","\t\t\treturn","\t\t}","\t})","","\treturn r, recorderErr","}","","func viewRegister() error {","\telCountView = \u0026view.View{","\t\tDescription: elCount.Description(),","\t\tMeasure:     elCount,","\t\tAggregation: view.LastValue(),","\t}","","\ttbCountView = \u0026view.View{","\t\tDescription: tbCount.Description(),","\t\tMeasure:     tbCount,","\t\tAggregation: view.LastValue(),","\t}","","\tctbCountView = \u0026view.View{","\t\tDescription: ctbCount.Description(),","\t\tMeasure:     ctbCount,","\t\tAggregation: view.LastValue(),","\t}","","\tttCountView = \u0026view.View{","\t\tDescription: ttCount.Description(),","\t\tMeasure:     ttCount,","\t\tAggregation: view.LastValue(),","\t}","","\tciCountView = \u0026view.View{","\t\tDescription: ciCount.Description(),","\t\tMeasure:     ciCount,","\t\tAggregation: view.LastValue(),","\t}","","\treturn view.Register(","\t\telCountView,","\t\ttbCountView,","\t\tctbCountView,","\t\tttCountView,","\t\tciCountView,","\t)","}","","func (r *Recorder) ReportCountMetrics(ctx context.Context, li listers) {","\tfor {","\t\tselect {","\t\tcase \u003c-ctx.Done():","\t\t\t// When the context is cancelled, stop reporting.","\t\t\treturn","","\t\tcase \u003c-time.After(r.ReportingPeriod):","\t\t\tr.CountMetrics(ctx, li)","\t\t}","\t}","}","","func (r *Recorder) CountMetrics(ctx context.Context, li listers) {","\tlogger := logging.FromContext(ctx)","","\tel, err := li.el.List(labels.Everything())","\tif err != nil {","\t\tlogger.Errorf(\"error reporting trigger metrics for eventlisteners: %v\", err)","\t} else {","\t\tcount := len(el)","\t\tr.countMetrics(ctx, float64(count), elCount)","\t}","\tci, err := li.ci.List(labels.Everything())","\tif err != nil {","\t\tlogger.Errorf(\"error reporting trigger metrics for clusterinterceptor: %v\", err)","\t} else {","\t\tcount := len(ci)","\t\tr.countMetrics(ctx, float64(count), ciCount)","\t}","\ttb, err := li.tb.List(labels.Everything())","\tif err != nil {","\t\tlogger.Errorf(\"error reporting trigger metrics for triggerbindings : %v\", err)","\t} else {","\t\tcount := len(tb)","\t\tr.countMetrics(ctx, float64(count), tbCount)","\t}","\tctb, err := li.ctb.List(labels.Everything())","\tif err != nil {","\t\tlogger.Errorf(\"error reporting trigger metrics for clustertriggerbindings: %v\", err)","\t} else {","\t\tcount := len(ctb)","\t\tr.countMetrics(ctx, float64(count), ctbCount)","\t}","\ttt, err := li.tt.List(labels.Everything())","\tif err != nil {","\t\tlogger.Errorf(\"error reporting trigger metrics for triggertemplates: %v\", err)","\t} else {","\t\tcount := len(tt)","\t\tr.countMetrics(ctx, float64(count), ttCount)","\t}","}","","func (r *Recorder) countMetrics(ctx context.Context, count float64, measure *stats.Float64Measure) {","\tlogger := logging.FromContext(ctx)","","\tif !r.initialized {","\t\tlogger.Errorf(\"ignoring the metrics recording for %s, failed to initialize the metrics recorder\", measure.Description())","\t}","","\tmetrics.Record(ctx, measure.M(count))","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,1,1,1,1,1,1,0,1,1,0,0,0,0,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,0,0,2,2,2,2,2,2,0,2,0]},{"id":88,"path":"pkg/resources/create.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package resources","","import (","\t\"context\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/tektoncd/triggers/pkg/apis/triggers\"","\tkerrors \"k8s.io/apimachinery/pkg/api/errors\"","","\t\"k8s.io/client-go/dynamic\"","","\t\"go.uber.org/zap\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"k8s.io/apimachinery/pkg/runtime/schema\"","\tdiscoveryclient \"k8s.io/client-go/discovery\"",")","","// findAPIResource returns the APIResource definition using the discovery client c.","func findAPIResource(apiVersion, kind string, c discoveryclient.ServerResourcesInterface) (*metav1.APIResource, error) {","\tresourceList, err := c.ServerResourcesForGroupVersion(apiVersion)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"error getting kubernetes server resources for apiVersion %s: %w\", apiVersion, err)","\t}","\tfor i := range resourceList.APIResources {","\t\tr := \u0026resourceList.APIResources[i]","\t\tif r.Kind != kind {","\t\t\tcontinue","\t\t}","","\t\t// Resolve GroupVersion from parent list to have consistent resource identifiers.","\t\tif r.Version == \"\" || r.Group == \"\" {","\t\t\tgv, err := schema.ParseGroupVersion(resourceList.GroupVersion)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"error parsing GroupVersion: %w\", err)","\t\t\t}","\t\t\tr.Group = gv.Group","\t\t\tr.Version = gv.Version","\t\t}","\t\treturn r, nil","\t}","\treturn nil, fmt.Errorf(\"error could not find resource with apiVersion %s and kind %s\", apiVersion, kind)","}","","// Create uses the kubeClient to create the resource defined in the","// TriggerResourceTemplate and returns any errors with this process","func Create(logger *zap.SugaredLogger, rt json.RawMessage, triggerName, eventID, elName, elNamespace string, c discoveryclient.ServerResourcesInterface, dc dynamic.Interface) error {","\t// Assume the TriggerResourceTemplate is valid (it has an apiVersion and Kind)","\tdata := new(unstructured.Unstructured)","\tif err := data.UnmarshalJSON(rt); err != nil {","\t\treturn fmt.Errorf(\"couldn't unmarshal json from the TriggerTemplate: %w\", err)","\t}","","\tdata, err := addLabels(data, map[string]string{","\t\ttriggers.EventListenerLabelKey: elName,","\t\ttriggers.EventIDLabelKey:       eventID,","\t\ttriggers.TriggerLabelKey:       triggerName,","\t})","\tif err != nil {","\t\treturn err","\t}","","\tnamespace := data.GetNamespace()","\t// Default the resource creation to the EventListenerNamespace if not found in the resource template","\tif namespace == \"\" {","\t\tnamespace = elNamespace","\t}","","\t// Resolve resource kind to the underlying API Resource type.","\tapiResource, err := findAPIResource(data.GetAPIVersion(), data.GetKind(), c)","\tif err != nil {","\t\treturn fmt.Errorf(\"couldn't find API resource for json: %w\", err)","\t}","","\tname := data.GetName()","\tif name == \"\" {","\t\tname = data.GetGenerateName()","\t}","\tlogger.Infof(\"Generating resource: kind: %s, name: %s\", apiResource, name)","","\tgvr := schema.GroupVersionResource{","\t\tGroup:    apiResource.Group,","\t\tVersion:  apiResource.Version,","\t\tResource: apiResource.Name,","\t}","","\tlogger.Infof(\"For event ID %q creating resource %v\", eventID, gvr)","","\tif _, err := dc.Resource(gvr).Namespace(namespace).Create(context.Background(), data, metav1.CreateOptions{}); err != nil {","\t\tif kerrors.IsUnauthorized(err) || kerrors.IsForbidden(err) {","\t\t\treturn err","\t\t}","\t\treturn fmt.Errorf(\"couldn't create resource with group version kind %q: %w\", gvr, err)","\t}","\treturn nil","}","","// addLabels adds autogenerated Tekton labels to created resources.","func addLabels(us *unstructured.Unstructured, labelsToAdd map[string]string) (*unstructured.Unstructured, error) {","\tlabels, _, err := unstructured.NestedStringMap(us.Object, \"metadata\", \"labels\")","\tif err != nil {","\t\treturn nil, err","\t}","","\tif labels == nil {","\t\tlabels = make(map[string]string)","\t}","\tfor k, v := range labelsToAdd {","\t\tl := fmt.Sprintf(\"%s/%s\", triggers.GroupName, strings.TrimLeft(k, \"/\"))","\t\tlabels[l] = v","\t}","","\tus.SetLabels(labels)","\treturn us, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,1,1,2,2,0,2,0,1,0,0,0,0,2,2,2,2,1,1,0,2,2,2,2,2,2,1,1,0,2,2,2,2,2,0,0,2,2,1,1,0,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,0,2,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,0,2,2,0]},{"id":89,"path":"pkg/sink/auth_override.go","lines":["/*","Copyright 2020 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package sink","","import (","\t\"fmt\"","","\t\"go.uber.org/zap\"","\tdiscoveryclient \"k8s.io/client-go/discovery\"","\t\"k8s.io/client-go/dynamic\"","\t\"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/rest\"",")","","// AuthOverride is an interface that constructs a discovery client for the ServerResourceInterface","// and a dynamic client for the Tekton Resources, using the token provide as the bearer token in the","// REST config used to build those client.  The other non-credential related parameters for the","// REST client used are copied from the in cluster config of the event sink.","type AuthOverride interface {","\tOverrideAuthentication(sa string,","\t\tnamespace string,","\t\tlog *zap.SugaredLogger,","\t\tdefaultDiscoveryClient discoveryclient.ServerResourcesInterface,","\t\tdefaultDynamicClient dynamic.Interface) (discoveryClient discoveryclient.ServerResourcesInterface,","\t\tdynamicClient dynamic.Interface,","\t\terr error)","}","","type DefaultAuthOverride struct {","}","","func (r DefaultAuthOverride) OverrideAuthentication(sa string,","\tnamespace string,","\tlog *zap.SugaredLogger,","\tdefaultDiscoverClient discoveryclient.ServerResourcesInterface,","\tdefaultDynamicClient dynamic.Interface) (discoveryClient discoveryclient.ServerResourcesInterface,","\tdynamicClient dynamic.Interface,","\terr error) {","\tdynamicClient = defaultDynamicClient","\tdiscoveryClient = defaultDiscoverClient","\tclusterConfig, err := rest.InClusterConfig()","\tif err != nil {","\t\tlog.Errorf(\"overrideAuthentication: problem getting in cluster config: %#v\\n\", err)","\t\treturn","\t}","\tclusterConfig.Impersonate = rest.ImpersonationConfig{","\t\tUserName: fmt.Sprintf(\"system:serviceaccount:%s:%s\", namespace, sa),","\t}","\tdynamicClient, err = dynamic.NewForConfig(clusterConfig)","\tif err != nil {","\t\tlog.Errorf(\"overrideAuthentication: problem getting dynamic client set: %#v\\n\", err)","\t\treturn","\t}","\tkubeClient, err := kubernetes.NewForConfig(clusterConfig)","\tif err != nil {","\t\tlog.Errorf(\"overrideAuthentication: problem getting kube client: %#v\\n\", err)","\t\treturn","\t}","\tdiscoveryClient = kubeClient.Discovery()","","\treturn","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":90,"path":"pkg/sink/cloudevent/cloudevent.go","lines":["/*","Copyright 2022 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package cloudevent","","import (","\t\"context\"","\t\"fmt\"","\t\"time\"","","\tcloudevents \"github.com/cloudevents/sdk-go/v2\"","\t\"go.uber.org/zap\"","","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"",")","","// CEClient matches the `Client` interface from github.com/cloudevents/sdk-go/v2/cloudevents","type CEClient cloudevents.Client","","// Resource structure defines parameters needed to send cloudEvents","type Resource struct {","\tEventID   string","\tEventType string","\tTargetURI string","\tClient    CEClient","\tLogger    *zap.SugaredLogger","\tData      []byte","\tEL        triggersv1.EventListener","}","","// SendCloudEvents is used by the EventListener to send cloud events status of","// trigger processing","func (r Resource) SendCloudEvents() {","\tlogger := r.Logger.With(zap.String(\"trigger\", r.EL.Name))","","\tevent := cloudevents.NewEvent()","\tevent.SetID(r.EventID)","\tevent.SetSubject(r.EL.Name + \" processing \" + r.EventID)","\tgvk := r.EL.GetObjectKind().GroupVersionKind()","\tsource := fmt.Sprintf(\"/apis/%s/%s/namespaces/%s/%s/%s\",","\t\tgvk.Group,","\t\tgvk.Version,","\t\tr.EL.Namespace,","\t\tgvk.Kind,","\t\tr.EL.Name)","\tevent.SetSource(source)","\tevent.SetType(r.EventType)","","\tif err := event.SetData(cloudevents.ApplicationJSON, r.Data); err != nil {","\t\tlogger.With(zap.Error(err)).Error(\"failed to set cloudevent data.\")","\t\treturn","\t}","","\t// Send the event.","\tresult := r.Client.Send(cloudevents.ContextWithTarget(cloudevents.ContextWithRetriesExponentialBackoff(context.Background(), 10*time.Millisecond, 10), r.TargetURI), event)","","\tif !cloudevents.IsACK(result) {","\t\tlogger.With(zap.Error(result)).Error(\"failed to send cloudevent.\")","\t\treturn","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,0,0,2,2,2,1,1,1,0]},{"id":91,"path":"pkg/sink/cloudevent/cloudeventclient.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package cloudevent","","import (","\t\"context\"","\t\"net/http\"","","\tcloudevents \"github.com/cloudevents/sdk-go/v2\"","\t\"k8s.io/client-go/rest\"","\t\"knative.dev/pkg/injection\"","\t\"knative.dev/pkg/logging\"",")","","func init() {","\tinjection.Default.RegisterClient(func(ctx context.Context, _ *rest.Config) context.Context {","\t\treturn withCloudEventClient(ctx)","\t})","}","","// CECKey is used to associate the CloudEventClient inside the context.Context","type CECKey struct{}","","func withCloudEventClient(ctx context.Context) context.Context {","\tlogger := logging.FromContext(ctx)","","\t// When KeepAlive is enabled the connections are not reused - see","\t// Bug https://github.com/tektoncd/pipeline/issues/3190. This causes the","\t// number of connections to keep growing, even if when we limit max idle","\t// connections in the transport.","\t// TODO(afrittoli) Re-enable keep alive and ensure connections are reused","\t// See feature https://github.com/tektoncd/pipeline/issues/3204","\tvar useOnceTransport http.RoundTripper = \u0026http.Transport{","\t\tDisableKeepAlives: true,","\t}","","\tp, err := cloudevents.NewHTTP(cloudevents.WithRoundTripper(useOnceTransport))","\tif err != nil {","\t\tlogger.Panicf(\"Error creating the cloudevents http protocol: %s\", err)","\t}","","\tcloudEventClient, err := cloudevents.NewClient(p, cloudevents.WithUUIDs(), cloudevents.WithTimeNow())","\tif err != nil {","\t\tlogger.Panicf(\"Error creating the cloudevents client: %s\", err)","\t}","","\treturn context.WithValue(ctx, CECKey{}, cloudEventClient)","}","","// Get extracts the cloudEventClient client from the context.","func Get(ctx context.Context) CEClient {","\tuntyped := ctx.Value(CECKey{})","\tif untyped == nil {","\t\tlogging.FromContext(ctx).Errorf(","\t\t\t\"Unable to fetch client from context.\")","\t\treturn nil","\t}","\treturn untyped.(CEClient)","}","","// ToContext adds the cloud events client to the context","func ToContext(ctx context.Context, cec CEClient) context.Context {","\treturn context.WithValue(ctx, CECKey{}, cec)","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1]},{"id":92,"path":"pkg/sink/initialization.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package sink","","import (","\t\"context\"","\t\"flag\"","\t\"time\"","","\ttriggersclientset \"github.com/tektoncd/triggers/pkg/client/clientset/versioned\"","\t\"github.com/tektoncd/triggers/pkg/sink/cloudevent\"","\t\"golang.org/x/xerrors\"","\tdiscoveryclient \"k8s.io/client-go/discovery\"","\tkubeclientset \"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/rest\"","\trestclient \"k8s.io/client-go/rest\"",")","","const (","\t// Flag definitions","\tname        = \"el-name\"","\telNamespace = \"el-namespace\"","\tport        = \"port\"","\tisMultiNS   = \"is-multi-ns\"",")","","var (","\tnameFlag = flag.String(\"el-name\", \"\",","\t\t\"The name of the EventListener resource for this sink.\")","\tnamespaceFlag = flag.String(\"el-namespace\", \"\",","\t\t\"The namespace of the EventListener resource for this sink.\")","\tportFlag = flag.String(\"port\", \"\",","\t\t\"The port for the EventListener sink to listen on.\")","\telReadTimeOut = flag.Int64(\"readtimeout\", 5,","\t\t\"The read timeout for EventListener Server.\")","\telWriteTimeOut = flag.Int64(\"writetimeout\", 40,","\t\t\"The write timeout for EventListener Server.\")","\telIdleTimeOut = flag.Int64(\"idletimeout\", 30,","\t\t\"The idle timeout for EventListener Server.\")","\telTimeOutHandler = flag.Int64(\"timeouthandler\", 5,","\t\t\"The timeout for Timeout Handler of EventListener Server.\")","\telHTTPClientReadTimeOut = flag.Int64(\"httpclient-readtimeout\", 30,","\t\t\"The HTTP Client read timeout for EventListener Server.\")","\telHTTPClientKeepAlive = flag.Int64(\"httpclient-keep-alive\", 30,","\t\t\"The HTTP Client read timeout for EventListener Server.\")","\telHTTPClientTLSHandshakeTimeout = flag.Int64(\"httpclient-tlshandshaketimeout\", 10,","\t\t\"The HTTP Client read timeout for EventListener Server.\")","\telHTTPClientResponseHeaderTimeout = flag.Int64(\"httpclient-responseheadertimeout\", 10,","\t\t\"The HTTP Client read timeout for EventListener Server.\")","\telHTTPClientExpectContinueTimeout = flag.Int64(\"httpclient-expectcontinuetimeout\", 1,","\t\t\"The HTTP Client read timeout for EventListener Server.\")","\tisMultiNSFlag = flag.Bool(\"is-multi-ns\", false,","\t\t\"Whether EventListener serve Multiple NS.\")","\ttlsCertFlag = flag.String(\"tls-cert\", \"\",","\t\t\"The filename for the TLS certificate.\")","\ttlsKeyFlag = flag.String(\"tls-key\", \"\",","\t\t\"The filename for the TLS key.\")","\tpayloadValidation = flag.Bool(\"payload-validation\", true,","\t\t\"Whether to disable payload validation or not.\")","\tcloudEventURI = flag.String(\"cloudevent-uri\", \"\", \"uri for cloudevent\")",")","","// Args define the arguments for Sink.","type Args struct {","\t// ElName is the EventListener name.","\tElName string","\t// ElNamespace is the EventListener namespace.","\tElNamespace string","\t// Port is the port the Sink should listen on.","\tPort string","\t// ELReadTimeOut defines the read timeout for EventListener Server","\tELReadTimeOut time.Duration","\t// ELWriteTimeOut defines the write timeout for EventListener Server","\tELWriteTimeOut time.Duration","\t// ELIdleTimeOut defines the read timeout for EventListener Server","\tELIdleTimeOut time.Duration","\t// ELTimeOutHandler defines the timeout for Timeout Handler of EventListener Server","\tELTimeOutHandler time.Duration","\t// ElHTTPClientReadTimeOut defines the Read timeout for HTTP Client","\tElHTTPClientReadTimeOut time.Duration","\t// ElHTTPClientKeepAlive defines the Keep Alive for HTTP Client","\tElHTTPClientKeepAlive time.Duration","\t// ElTLSHandshakeTimeout defines the Handshake timeout for HTTP Client","\tElHTTPClientTLSHandshakeTimeout time.Duration","\t// ElResponseHeaderTimeout defines the Response Header timeout for HTTP Client","\tElHTTPClientResponseHeaderTimeout time.Duration","\t// ElExpectContinueTimeout defines the Expect timeout for HTTP Client","\tElHTTPClientExpectContinueTimeout time.Duration","\t// IsMultiNS determines whether el functions as namespaced or clustered","\tIsMultiNS bool","\t// Key defines the filename for tls Key.","\tKey string","\t// Cert defines the filename for tls Cert.","\tCert string","\t// PayloadValidation defines whether to validate payload or not","\tPayloadValidation bool","\t// CloudEventURI refers to the location where cloudevent data need to be send","\tCloudEventURI string","}","","// Clients define the set of client dependencies Sink requires.","type Clients struct {","\tDiscoveryClient discoveryclient.DiscoveryInterface","\tRESTClient      restclient.Interface","\tTriggersClient  triggersclientset.Interface","\tK8sClient       *kubeclientset.Clientset","\tCEClient        cloudevent.CEClient","}","","// GetArgs returns the flagged Args","func GetArgs() (Args, error) {","\tflag.Parse()","\tif *nameFlag == \"\" {","\t\treturn Args{}, xerrors.Errorf(\"-%s arg not found\", name)","\t}","\tif *namespaceFlag == \"\" {","\t\treturn Args{}, xerrors.Errorf(\"-%s arg not found\", elNamespace)","\t}","\tif *portFlag == \"\" {","\t\treturn Args{}, xerrors.Errorf(\"-%s arg not found\", port)","\t}","","\treturn Args{","\t\tElName:                            *nameFlag,","\t\tElNamespace:                       *namespaceFlag,","\t\tPort:                              *portFlag,","\t\tIsMultiNS:                         *isMultiNSFlag,","\t\tPayloadValidation:                 *payloadValidation,","\t\tELReadTimeOut:                     time.Duration(*elReadTimeOut),","\t\tELWriteTimeOut:                    time.Duration(*elWriteTimeOut),","\t\tELIdleTimeOut:                     time.Duration(*elIdleTimeOut),","\t\tELTimeOutHandler:                  time.Duration(*elTimeOutHandler),","\t\tElHTTPClientReadTimeOut:           time.Duration(*elHTTPClientReadTimeOut),","\t\tElHTTPClientKeepAlive:             time.Duration(*elHTTPClientKeepAlive),","\t\tElHTTPClientTLSHandshakeTimeout:   time.Duration(*elHTTPClientTLSHandshakeTimeout),","\t\tElHTTPClientResponseHeaderTimeout: time.Duration(*elHTTPClientResponseHeaderTimeout),","\t\tElHTTPClientExpectContinueTimeout: time.Duration(*elHTTPClientExpectContinueTimeout),","\t\tCert:                              *tlsCertFlag,","\t\tKey:                               *tlsKeyFlag,","\t\tCloudEventURI:                     *cloudEventURI,","\t}, nil","}","","// ConfigureClients returns the kubernetes and triggers clientsets","func ConfigureClients(ctx context.Context, clusterConfig *rest.Config) (Clients, error) {","\tkubeClient, err := kubeclientset.NewForConfig(clusterConfig)","\tif err != nil {","\t\treturn Clients{}, xerrors.Errorf(\"Failed to create KubeClient: %s\", err)","\t}","\ttriggersClient, err := triggersclientset.NewForConfig(clusterConfig)","\tif err != nil {","\t\treturn Clients{}, xerrors.Errorf(\"Failed to create TriggersClient: %s\", err)","\t}","\tceClient := cloudevent.Get(ctx)","\treturn Clients{","\t\tDiscoveryClient: kubeClient.Discovery(),","\t\tRESTClient:      kubeClient.RESTClient(),","\t\tTriggersClient:  triggersClient,","\t\tK8sClient:       kubeClient,","\t\tCEClient:        ceClient,","\t}, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]},{"id":93,"path":"pkg/sink/metrics.go","lines":["package sink","","import (","\t\"context\"","\t\"encoding/json\"","\t\"log\"","\t\"net/http\"","\t\"time\"","","\t\"go.opencensus.io/stats\"","\t\"go.opencensus.io/stats/view\"","\t\"go.opencensus.io/tag\"","\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"","\t\"knative.dev/pkg/metrics\"",")","","var (","\telDuration = stats.Float64(","\t\t\"http_duration_seconds\",","\t\t\"The eventlistener HTTP request duration\",","\t\tstats.UnitDimensionless)","\telDistribution = view.Distribution(metrics.BucketsNBy10(0.001, 5)...)","\teventRcdCount  = stats.Float64(\"event_received_count\",","\t\t\"number of events received by sink\",","\t\tstats.UnitDimensionless)","\ttriggeredResources = stats.Int64(\"triggered_resources\", \"Count of the number of triggered eventlistener resources\", stats.UnitDimensionless)",")","","const (","\tfailTag    = \"failed\"","\tsuccessTag = \"succeeded\"",")","","// NewRecorder creates a new metrics recorder instance","// to log the TaskRun related metrics","func NewRecorder() (*Recorder, error) {","\tr := \u0026Recorder{","\t\tinitialized: true,","","\t\t// Default to reporting metrics every 30s.","\t\tReportingPeriod: 30 * time.Second,","\t}","","\tstatus, err := tag.NewKey(\"status\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.status = status","\tkind, err := tag.NewKey(\"kind\")","\tif err != nil {","\t\treturn nil, err","\t}","\tr.kind = kind","","\terr = view.Register(","\t\t\u0026view.View{","\t\t\tDescription: elDuration.Description(),","\t\t\tMeasure:     elDuration,","\t\t\tAggregation: elDistribution,","\t\t},","\t\t\u0026view.View{","\t\t\tDescription: triggeredResources.Description(),","\t\t\tMeasure:     triggeredResources,","\t\t\tAggregation: view.Count(),","\t\t\tTagKeys:     []tag.Key{r.kind},","\t\t},","\t\t\u0026view.View{","\t\t\tDescription: eventRcdCount.Description(),","\t\t\tMeasure:     eventRcdCount,","\t\t\tAggregation: view.Count(),","\t\t\tTagKeys:     []tag.Key{r.status},","\t\t},","\t)","\tif err != nil {","\t\tlog.Fatalf(\"unable to register eventlistener metrics: %s\", err)","\t}","\treturn r, nil","}","","func (s *Sink) NewMetricsRecorderInterceptor() MetricsInterceptor {","\treturn func(w http.ResponseWriter, r *http.Request, next http.HandlerFunc) {","\t\trecorder := \u0026StatusRecorder{","\t\t\tResponseWriter: w,","\t\t\tStatus:         200,","\t\t}","\t\tstartTime := time.Now()","\t\tdefer func() {","\t\t\tendTime := time.Now()","\t\t\telapsed := endTime.Sub(startTime)","\t\t\t// Log the consumed time","\t\t\tgo s.recordDurationMetrics(recorder, elapsed)","\t\t}()","\t\tnext(recorder, r)","\t}","}","","func (s *Sink) recordDurationMetrics(w *StatusRecorder, elapsed time.Duration) {","\tduration := elapsed.Seconds()","\ts.Logger.Debugw(\"event listener request completed\", \"status\", w.Status, \"duration\", duration)","\tctx, err := tag.New(","\t\tcontext.Background(),","\t)","","\tif err != nil {","\t\ts.Logger.Warnf(\"failed to create tag for http metric request: %w\", err)","\t\treturn","\t}","","\tmetrics.Record(ctx, elDuration.M(duration))","}","","func (s *Sink) recordCountMetrics(status string) {","\ts.Logger.Debugw(\"event listener request\", \"status\", status)","\tctx, err := tag.New(","\t\tcontext.Background(),","\t\ttag.Insert(s.Recorder.status, status),","\t)","","\tif err != nil {","\t\ts.Logger.Warnf(\"failed to create tag for metric event_received_count: %w\", err)","\t\treturn","\t}","","\tmetrics.Record(ctx, eventRcdCount.M(1))","}","","func (s *Sink) recordResourceCreation(resources []json.RawMessage) {","\tfor _, rt := range resources {","\t\t// Assume the TriggerResourceTemplate is valid (it has an apiVersion and Kind)","\t\tdata := new(unstructured.Unstructured)","\t\tif err := data.UnmarshalJSON(rt); err != nil {","\t\t\ts.Logger.Warnf(\"couldn't unmarshal json from the TriggerTemplate: %v\", err)","\t\t\tcontinue","\t\t}","\t\tctx, err := tag.New(context.Background(), tag.Insert(s.Recorder.kind, data.GetKind()))","\t\tif err != nil {","\t\t\ts.Logger.Warnf(\"failed to create tag for resource creation: %w\", err)","\t\t\tcontinue","\t\t}","","\t\tmetrics.Record(ctx, triggeredResources.M(1))","\t}","}","","type Recorder struct {","\tinitialized bool","","\tstatus tag.Key","\tkind   tag.Key","","\tReportingPeriod time.Duration","}","","type StatusRecorder struct {","\thttp.ResponseWriter","\tStatus int","}","","func (r *StatusRecorder) WriteHeader(status int) {","\tr.Status = status","\tr.ResponseWriter.WriteHeader(status)","}","","// MetricsInterceptor intercepts an HTTP handler invocation, it is passed both response writer and request","// which after interception can be passed onto the handler function.","type MetricsInterceptor func(http.ResponseWriter, *http.Request, http.HandlerFunc)","","// MetricsHandlerFunc builds on top of http.Handler, and exposes API to intercept with MetricsInterceptor.","// This allows building complex long chains without complicated struct manipulation","type MetricsHandler struct {","\tHandler http.Handler","}","","// Intercept returns back a continuation that will call the handler func to intercept","// the continuation call.","func (cont *MetricsHandler) Intercept(mw MetricsInterceptor) http.HandlerFunc {","\treturn func(writer http.ResponseWriter, request *http.Request) {","\t\tmw(writer, request, cont.Handler.ServeHTTP)","\t}","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,1,1,1,0,2,0,0,2,2,2,2,2,2,2,2,1,1,1,0,2,0,0,2,2,2,2,2,1,1,0,2,2,1,1,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,0]},{"id":94,"path":"pkg/sink/sink.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package sink","","import (","\t\"bytes\"","\t\"context\"","\t\"encoding/json\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"","\tnet \"net/url\"","\t\"os\"","\t\"sync\"","","\tcloudevents \"github.com/cloudevents/sdk-go/v2\"","\t\"github.com/cloudevents/sdk-go/v2/binding\"","\tcehttp \"github.com/cloudevents/sdk-go/v2/protocol/http\"","\t\"github.com/tektoncd/triggers/pkg/apis/triggers\"","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\ttriggersclientset \"github.com/tektoncd/triggers/pkg/client/clientset/versioned\"","\tlistersv1alpha1 \"github.com/tektoncd/triggers/pkg/client/listers/triggers/v1alpha1\"","\tlisters \"github.com/tektoncd/triggers/pkg/client/listers/triggers/v1beta1\"","\t\"github.com/tektoncd/triggers/pkg/interceptors\"","\t\"github.com/tektoncd/triggers/pkg/interceptors/webhook\"","\t\"github.com/tektoncd/triggers/pkg/reconciler/events\"","\t\"github.com/tektoncd/triggers/pkg/resources\"","\t\"github.com/tektoncd/triggers/pkg/sink/cloudevent\"","\t\"github.com/tektoncd/triggers/pkg/template\"","\t\"github.com/tidwall/sjson\"","\t\"go.uber.org/zap\"","\tcorev1 \"k8s.io/api/core/v1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","\t\"k8s.io/apimachinery/pkg/labels\"","\tdiscoveryclient \"k8s.io/client-go/discovery\"","\t\"k8s.io/client-go/dynamic\"","\t\"k8s.io/client-go/kubernetes\"","\t\"k8s.io/client-go/tools/record\"","\t\"knative.dev/pkg/apis\"","\tv1 \"knative.dev/pkg/apis/duck/v1\"",")","","// Sink defines the sink resource for processing incoming events for the","// EventListener.","type Sink struct {","\tKubeClientSet          kubernetes.Interface","\tTriggersClient         triggersclientset.Interface","\tDiscoveryClient        discoveryclient.ServerResourcesInterface","\tDynamicClient          dynamic.Interface","\tHTTPClient             *http.Client","\tCEClient               cloudevent.CEClient","\tEventListenerName      string","\tEventListenerNamespace string","\tLogger                 *zap.SugaredLogger","\tRecorder               *Recorder","\tAuth                   AuthOverride","\tPayloadValidation      bool","\tCloudEventURI          string","\t// WGProcessTriggers keeps track of triggers or triggerGroups currently being processed","\t// Currently only used in tests to wait for all triggers to finish processing","\tWGProcessTriggers *sync.WaitGroup","\tEventRecorder     record.EventRecorder","","\t// listers index properties about resources","\tEventListenerLister         listers.EventListenerLister","\tTriggerLister               listers.TriggerLister","\tTriggerBindingLister        listers.TriggerBindingLister","\tClusterTriggerBindingLister listers.ClusterTriggerBindingLister","\tTriggerTemplateLister       listers.TriggerTemplateLister","\tClusterInterceptorLister    listersv1alpha1.ClusterInterceptorLister","\tInterceptorLister           listersv1alpha1.InterceptorLister","}","","// Response defines the HTTP body that the Sink responds to events with.","type Response struct {","\t// EventListener is the name of the eventListener.","\t// Deprecated: use EventListenerUID instead.","\tEventListener string `json:\"eventListener\"`","\t// Namespace is the namespace that the eventListener is running in.","\t// Deprecated: use EventListenerUID instead.","\tNamespace string `json:\"namespace,omitempty\"`","\t// EventListenerUID is the UID of the EventListener","\tEventListenerUID string `json:\"eventListenerUID\"`","\t// EventID is a uniqueID that gets assigned to each incoming request","\tEventID string `json:\"eventID,omitempty\"`","\t// ErrorMessage gives message about Error which occurs during event processing","\tErrorMessage string `json:\"errorMessage,omitempty\"`","}","","func (r Sink) emitEvents(recorder record.EventRecorder, el *triggersv1.EventListener, eventType string, err error) {","\tif os.Getenv(\"EL_EVENT\") == \"enable\" {","\t\tevents.Emit(recorder, eventType, el, err)","\t}","}","","// HandleEvent processes an incoming HTTP event for the event listener.","func (r Sink) HandleEvent(response http.ResponseWriter, request *http.Request) {","\tlog := r.Logger.With(","\t\tzap.String(\"eventlistener\", r.EventListenerName),","\t\tzap.String(\"namespace\", r.EventListenerNamespace),","\t)","\teventID := template.UUID()","\tlog = log.With(zap.String(triggers.EventIDLabelKey, eventID))","","\telTemp := triggersv1.EventListener{","\t\tTypeMeta: metav1.TypeMeta{","\t\t\tKind:       \"EventListener\",","\t\t\tAPIVersion: \"v1beta1\",","\t\t},","\t\tObjectMeta: metav1.ObjectMeta{","\t\t\tName:      r.EventListenerName,","\t\t\tNamespace: r.EventListenerNamespace,","\t\t},","\t\tSpec: triggersv1.EventListenerSpec{","\t\t\tResources: triggersv1.Resources{","\t\t\t\tKubernetesResource: \u0026triggersv1.KubernetesResource{","\t\t\t\t\tWithPodSpec: v1.WithPodSpec{","\t\t\t\t\t\tTemplate: v1.PodSpecable{","\t\t\t\t\t\t\tSpec: corev1.PodSpec{","\t\t\t\t\t\t\t\tContainers: []corev1.Container{{","\t\t\t\t\t\t\t\t\t// enabled by default for temporary EL","\t\t\t\t\t\t\t\t\tEnv: []corev1.EnvVar{{","\t\t\t\t\t\t\t\t\t\tName:  \"EL_EVENT\",","\t\t\t\t\t\t\t\t\t\tValue: \"true\",","\t\t\t\t\t\t\t\t\t}},","\t\t\t\t\t\t\t\t}},","\t\t\t\t\t\t\t},","\t\t\t\t\t\t},","\t\t\t\t\t},","\t\t\t\t},","\t\t\t},","\t\t},","\t}","","\tr.emitEvents(r.EventRecorder, \u0026elTemp, events.TriggerProcessingStartedV1, nil)","\tr.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingStartedV1)","","\tevent, err := io.ReadAll(request.Body)","\tif err != nil {","\t\tlog.Errorf(\"Error reading event body: %s\", err)","\t\tr.recordCountMetrics(failTag)","\t\tresponse.WriteHeader(http.StatusInternalServerError)","\t\tr.emitEvents(r.EventRecorder, \u0026elTemp, events.TriggerProcessingFailedV1, err)","\t\tr.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingFailedV1)","\t\treturn","\t}","","\tel, err := r.EventListenerLister.EventListeners(r.EventListenerNamespace).Get(r.EventListenerName)","\tif err != nil {","\t\tlog.Errorf(\"Error getting EventListener %s in Namespace %s: %s\", r.EventListenerName, r.EventListenerNamespace, err)","\t\tr.recordCountMetrics(failTag)","\t\tresponse.WriteHeader(http.StatusInternalServerError)","\t\tr.emitEvents(r.EventRecorder, \u0026elTemp, events.TriggerProcessingFailedV1, err)","\t\tr.sendCloudEvents(request.Header, elTemp, eventID, events.TriggerProcessingFailedV1)","\t\treturn","\t}","","\telUID := string(el.GetUID())","\tlog = log.With(zap.String(\"eventlistenerUID\", elUID))","","\tlog = log.With(zap.String(triggers.EventIDLabelKey, eventID))","\tlog.Debugf(\"handling event with path %s, payload: %s and header: %v\", request.URL.Path, string(event), request.Header)","\ttrItems, err := r.selectTriggers(el.Spec.NamespaceSelector, el.Spec.LabelSelector)","\tif err != nil {","\t\tr.Logger.Errorf(\"unable to select configured mergedTriggers: %s\", err)","\t\tresponse.WriteHeader(http.StatusInternalServerError)","\t\tr.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)","\t\tr.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)","\t\treturn","\t}","","\t// Process any ungroupedTriggers","\tmergedTriggers, err := r.merge(el.Spec.Triggers, trItems)","\tif err != nil {","\t\tlog.Errorf(\"error merging triggers: %s\", err)","\t\tresponse.WriteHeader(http.StatusInternalServerError)","\t\tr.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)","\t\tr.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)","\t\treturn","\t}","\tr.WGProcessTriggers.Add(len(mergedTriggers))","\tfor _, t := range mergedTriggers {","\t\tgo func(t triggersv1.Trigger) {","\t\t\tdefer r.WGProcessTriggers.Done()","\t\t\tlocalRequest := request.Clone(request.Context())","\t\t\temptyExtensions := make(map[string]interface{})","\t\t\tr.processTrigger(t, el, localRequest, event, eventID, log, emptyExtensions)","\t\t}(*t)","\t}","","\t// Process grouped triggers","\tfor _, group := range el.Spec.TriggerGroups {","\t\tr.WGProcessTriggers.Add(1)","\t\tgo func(g triggersv1.EventListenerTriggerGroup) {","\t\t\tdefer r.WGProcessTriggers.Done()","\t\t\tlocalRequest := request.Clone(request.Context())","\t\t\tr.processTriggerGroups(g, el, localRequest, event, eventID, log, r.WGProcessTriggers)","\t\t}(group)","\t}","","\tr.recordCountMetrics(successTag)","","\tbody := Response{","\t\tEventListener:    r.EventListenerName,","\t\tEventListenerUID: elUID,","\t\tNamespace:        r.EventListenerNamespace,","\t\tEventID:          eventID,","\t}","","\tmsg := cehttp.NewMessageFromHttpRequest(request)","\tif encoding := msg.ReadEncoding(); encoding == binding.EncodingUnknown {","\t\tresponse.WriteHeader(http.StatusAccepted)","\t\tresponse.Header().Set(\"Content-Type\", \"application/json\")","\t\tif err := json.NewEncoder(response).Encode(body); err != nil {","\t\t\tlog.Errorf(\"failed to write back sink response: %v\", err)","\t\t\tr.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)","\t\t\tr.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)","\t\t}","\t} else {","\t\tresponseEvent := cloudevents.NewEvent()","\t\tresponseEvent.SetID(eventID)","\t\tresponseEvent.SetType(events.EventAccepted)","\t\tresponseEvent.SetSubject(r.EventListenerNamespace + \".\" + r.EventListenerName + \" accepted \" + eventID)","\t\tresponseEvent.SetSource(r.EventListenerName) // We need to change this like in SendCloudEvents","","\t\t_ = responseEvent.SetData(cloudevents.ApplicationJSON, body)","","\t\teventResponse := binding.ToMessage(\u0026responseEvent)","\t\tdefer func() {","\t\t\tif err := eventResponse.Finish(nil); err != nil {","\t\t\t\tlog.Errorf(\"failed to close cloud event sink response: %v\", err)","\t\t\t}","\t\t}()","","\t\tif err := cehttp.WriteResponseWriter(request.Context(), eventResponse, http.StatusAccepted, response); err != nil {","\t\t\tlog.Errorf(\"failed to write back cloud event sink response: %v\", err)","\t\t\tr.emitEvents(r.EventRecorder, el, events.TriggerProcessingFailedV1, err)","\t\t\tr.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingFailedV1)","\t\t}","\t}","\tr.emitEvents(r.EventRecorder, el, events.TriggerProcessingDoneV1, nil)","\tr.sendCloudEvents(nil, *el, eventID, events.TriggerProcessingDoneV1)","}","","func (r Sink) sendCloudEvents(headers http.Header, el triggersv1.EventListener, eventID, eventType string) {","\tdata, err := json.Marshal(headers)","\tif err != nil {","\t\tr.Logger.Errorf(\"Error marshaling request Headers to json: %s\", err)","\t\treturn","\t}","","\t// If no cloudEventURI, then don't try to sendCloudEvents","\tif r.CloudEventURI == \"\" {","\t\treturn","\t}","","\tresource := cloudevent.Resource{","\t\tEventID:   eventID,","\t\tEventType: eventType,","\t\tTargetURI: r.CloudEventURI,","\t\tClient:    r.CEClient,","\t\tLogger:    r.Logger,","\t\tData:      data,","\t\tEL:        el,","\t}","","\tgo resource.SendCloudEvents()","}","","func (r Sink) merge(et []triggersv1.EventListenerTrigger, trItems []*triggersv1.Trigger) ([]*triggersv1.Trigger, error) {","\ttriggers := trItems","\tfor _, t := range et {","\t\tswitch {","\t\tcase t.Template == nil \u0026\u0026 t.TriggerRef != \"\":","\t\t\ttrig, err := r.TriggerLister.Triggers(r.EventListenerNamespace).Get(t.TriggerRef)","\t\t\tif err != nil {","\t\t\t\tr.Logger.Errorf(\"Error getting Trigger %s in Namespace %s: %s\", t.TriggerRef, r.EventListenerNamespace, err)","\t\t\t\tcontinue","\t\t\t}","\t\t\ttriggers = append(triggers, trig)","\t\tcase t.Template != nil:","\t\t\ttriggers = append(triggers, \u0026triggersv1.Trigger{","\t\t\t\tObjectMeta: metav1.ObjectMeta{","\t\t\t\t\tName:      t.Name,","\t\t\t\t\tNamespace: r.EventListenerNamespace},","\t\t\t\tSpec: triggersv1.TriggerSpec{","\t\t\t\t\tServiceAccountName: t.ServiceAccountName,","\t\t\t\t\tBindings:           t.Bindings,","\t\t\t\t\tTemplate:           *t.Template,","\t\t\t\t\tInterceptors:       t.Interceptors,","\t\t\t\t},","\t\t\t})","\t\tdefault:","\t\t\treturn nil, errors.New(\"EventListenerTrigger not defined\")","\t\t}","\t}","\treturn triggers, nil","}","","func (r Sink) processTriggerGroups(g triggersv1.EventListenerTriggerGroup, el *triggersv1.EventListener, request *http.Request, event []byte, eventID string, eventLog *zap.SugaredLogger, wg *sync.WaitGroup) {","\tlog := eventLog.With(zap.String(triggers.TriggerGroupLabelKey, g.Name))","","\textensions := map[string]interface{}{}","\tpayload, header, resp, err := r.ExecuteInterceptors(g.Interceptors, request, event, log, eventID, fmt.Sprintf(\"namespaces/%s/triggerGroups/%s\", r.EventListenerNamespace, g.Name), r.EventListenerNamespace, extensions)","\tif err != nil {","\t\tlog.Error(err)","\t\treturn","\t}","\tif resp != nil {","\t\tif resp.Extensions != nil {","\t\t\tfor k, v := range resp.Extensions {","\t\t\t\textensions[k] = v","\t\t\t}","\t\t}","\t\tif !resp.Continue {","\t\t\teventLog.Debugf(\"interceptor stopped trigger processing: %v\", resp.Status.Err())","\t\t\treturn","\t\t}","\t}","","\ttrItems, err := r.selectTriggers(g.TriggerSelector.NamespaceSelector, g.TriggerSelector.LabelSelector)","\tif err != nil {","\t\treturn","\t}","","\t// Create a new HTTP request that contains the body and header from any interceptors in the TriggerGroup","\t// This request will be passed on to the triggers in this group","\ttriggerReq := request.Clone(request.Context())","\ttriggerReq.Header = header","\ttriggerReq.Body = io.NopCloser(bytes.NewBuffer(payload))","","\twg.Add(len(trItems))","\tfor _, t := range trItems {","\t\tgo func(t triggersv1.Trigger) {","\t\t\tdefer wg.Done()","\t\t\t// TODO(dibyom): We might be able to get away with only cloning if necessary","\t\t\t// i.e. if there are interceptors and iff those interceptors will modify the body/header (i.e. webhook)","\t\t\tlocalRequest := triggerReq.Clone(triggerReq.Context())","\t\t\tr.processTrigger(t, el, localRequest, event, eventID, log, extensions)","\t\t}(*t)","\t}","}","","func (r Sink) selectTriggers(namespaceSelector triggersv1.NamespaceSelector, labelSelector *metav1.LabelSelector) ([]*triggersv1.Trigger, error) {","\tvar trItems []*triggersv1.Trigger","\tvar err error","\ttargetLabels := labels.Everything()","\tif labelSelector != nil {","\t\ttargetLabels, err = metav1.LabelSelectorAsSelector(labelSelector)","\t\tif err != nil {","\t\t\tr.Logger.Errorf(\"failed to create label selector: %v\", err)","\t\t\treturn nil, err","\t\t}","\t}","\tvar triggerFunc func() ([]*triggersv1.Trigger, error)","\tswitch {","\tcase len(namespaceSelector.MatchNames) == 1 \u0026\u0026 namespaceSelector.MatchNames[0] == \"*\":","\t\ttriggerFunc = func() ([]*triggersv1.Trigger, error) {","\t\t\treturn r.TriggerLister.List(targetLabels)","\t\t}","\tcase len(namespaceSelector.MatchNames) != 0:","\t\ttriggerFunc = func() ([]*triggersv1.Trigger, error) {","\t\t\tvar trList []*triggersv1.Trigger","\t\t\tfor _, v := range namespaceSelector.MatchNames {","\t\t\t\ttrNsList, err := r.TriggerLister.Triggers(v).List(targetLabels)","\t\t\t\tif err != nil {","\t\t\t\t\treturn nil, err","\t\t\t\t}","\t\t\t\ttrList = append(trList, trNsList...)","\t\t\t}","\t\t\treturn trList, nil","\t\t}","\tcase len(namespaceSelector.MatchNames) == 0:","\t\tif labelSelector != nil {","\t\t\ttriggerFunc = func() ([]*triggersv1.Trigger, error) {","\t\t\t\treturn r.TriggerLister.Triggers(r.EventListenerNamespace).List(targetLabels)","\t\t\t}","\t\t}","\t}","\tif triggerFunc == nil {","\t\treturn trItems, nil","\t}","\ttrList, err := triggerFunc()","\tif err != nil {","\t\tr.Logger.Errorf(\"Error getting Triggers: %v\", err)","\t\treturn nil, err","\t}","\ttrItems = append(trItems, trList...)","","\treturn trItems, nil","}","","func (r Sink) processTrigger(t triggersv1.Trigger, el *triggersv1.EventListener, request *http.Request, event []byte, eventID string, eventLog *zap.SugaredLogger, extensions map[string]interface{}) {","\tlog := eventLog.With(zap.String(triggers.TriggerLabelKey, t.Name))","","\tfinalPayload, header, iresp, err := r.ExecuteTriggerInterceptors(t, request, event, log, eventID, extensions)","\tif err != nil {","\t\tlog.Error(err)","\t\treturn","\t}","","\tif iresp != nil {","\t\tif !iresp.Continue {","\t\t\tlog.Debugf(\"interceptor stopped trigger processing: %v\", iresp.Status.Err())","\t\t\treturn","\t\t}","\t}","","\trt, err := template.ResolveTrigger(t,","\t\tr.TriggerBindingLister.TriggerBindings(t.Namespace).Get,","\t\tr.ClusterTriggerBindingLister.Get,","\t\tr.TriggerTemplateLister.TriggerTemplates(t.Namespace).Get)","\tif err != nil {","\t\tlog.Error(err)","\t\treturn","\t}","\tif iresp != nil \u0026\u0026 iresp.Extensions != nil {","\t\textensions = iresp.Extensions","\t}","\tparams, err := template.ResolveParams(rt, finalPayload, header, extensions, template.NewTriggerContext(eventID))","\tif err != nil {","\t\tlog.Error(err)","\t\treturn","\t}","","\tlog.Infof(\"ResolvedParams : %+v\", params)","\tresources := template.ResolveResources(rt.TriggerTemplate, params)","","\tif err := r.CreateResources(t.Namespace, t.Spec.ServiceAccountName, resources, t.Name, eventID, log); err != nil {","\t\tlog.Error(err)","\t\treturn","\t}","\tgo r.recordResourceCreation(resources)","\tr.emitEvents(r.EventRecorder, el, events.TriggerProcessingSuccessfulV1, nil)","\tr.sendCloudEvents(request.Header, *el, eventID, events.TriggerProcessingSuccessfulV1)","}","","func (r Sink) ExecuteTriggerInterceptors(t triggersv1.Trigger, in *http.Request, event []byte, log *zap.SugaredLogger, eventID string, extensions map[string]interface{}) ([]byte, http.Header, *triggersv1.InterceptorResponse, error) {","\treturn r.ExecuteInterceptors(t.Spec.Interceptors, in, event, log, eventID, fmt.Sprintf(\"namespaces/%s/triggers/%s\", t.Namespace, t.Name), t.Namespace, extensions)","}","","// ExecuteInterceptor executes all interceptors for the Trigger and returns back the body, header, and InterceptorResponse to use.","// When TEP-0022 is fully implemented, this function will only return the InterceptorResponse and error.","func (r Sink) ExecuteInterceptors(trInt []*triggersv1.TriggerInterceptor, in *http.Request, event []byte, log *zap.SugaredLogger, eventID string, triggerID string, namespace string, extensions map[string]interface{}) ([]byte, http.Header, *triggersv1.InterceptorResponse, error) {","\tif len(trInt) == 0 {","\t\treturn event, in.Header, nil, nil","\t}","","\t// request is the request sent to the interceptors in the chain. Each interceptor can set the InterceptorParams field","\t// or add to the Extensions","\trequest := triggersv1.InterceptorRequest{","\t\tBody:       string(event),","\t\tHeader:     in.Header.Clone(),","\t\tExtensions: make(map[string]interface{}),","\t\tContext: \u0026triggersv1.TriggerContext{","\t\t\tEventURL: in.URL.String(),","\t\t\tEventID:  eventID,","\t\t\t// t.Name might not be fully accurate until we get rid of triggers inlined within EventListener","\t\t\tTriggerID: triggerID,","\t\t},","\t}","\tfor k, v := range extensions {","\t\trequest.Extensions[k] = v","\t}","","\t// check if string is urlencoded","\t// Parse the query string into a map","\tparsedQuery, _ := net.ParseQuery(request.Body)","","\t// parse form-data payload","\tif v := in.Header.Get(\"Content-Type\"); v == \"application/x-www-form-urlencoded\" \u0026\u0026 len(parsedQuery) \u003e 1 {","\t\t// Convert the map into a JSON string","\t\tjsonString, err := json.Marshal(parsedQuery)","\t\tif err != nil {","\t\t\tlog.Errorf(\"Error converting map to JSON:\", err)","\t\t\treturn nil, nil, nil, err","\t\t}","\t\trequest.Body = string(jsonString)","\t}","\t// request is the request sent to the interceptors in the chain. Each interceptor can set the InterceptorParams field","\t// or add to the Extensions","","\tfor _, i := range trInt {","\t\tif i.Webhook != nil { // Old style interceptor","\t\t\tbody, err := extendBodyWithExtensions([]byte(request.Body), request.Extensions)","\t\t\tif err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"could not merge extensions with body: %w\", err)","\t\t\t}","\t\t\treq := \u0026http.Request{","\t\t\t\tMethod: http.MethodPost,","\t\t\t\tHeader: request.Header,","\t\t\t\tURL:    in.URL,","\t\t\t\tBody:   io.NopCloser(bytes.NewBuffer(body)),","\t\t\t}","\t\t\tinterceptor := webhook.NewInterceptor(i.Webhook, r.HTTPClient, namespace, log)","\t\t\tres, err := interceptor.ExecuteTrigger(req)","\t\t\tif err != nil {","\t\t\t\treturn nil, nil, nil, err","\t\t\t}","","\t\t\tpayload, err := io.ReadAll(res.Body)","\t\t\tif err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"error reading webhook interceptor response body: %w\", err)","\t\t\t}","\t\t\tdefer res.Body.Close()","\t\t\t// Set the next request to be the output of the last response to enable","\t\t\t// request chaining.","\t\t\trequest.Header = res.Header.Clone()","\t\t\trequest.Body = string(payload)","\t\t\tcontinue","\t\t}","\t\trequest.InterceptorParams = interceptors.GetInterceptorParams(i)","","\t\tvar url *apis.URL","\t\tif i.Ref.Kind == triggersv1.ClusterInterceptorKind {","\t\t\tic, err := r.ClusterInterceptorLister.Get(i.GetName())","\t\t\tif err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"url resolution failed for interceptor %s with: %w\", i.GetName(), err)","\t\t\t}","\t\t\tif ic.Status.Address != nil \u0026\u0026 ic.Status.Address.URL != nil {","\t\t\t\turl = ic.Status.Address.URL","\t\t\t} else if url, err = ic.ResolveAddress(); err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"url resolution failed for interceptor %s with: %w\", i.GetName(), err)","\t\t\t}","\t\t\tif err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"could not resolve clusterinterceptor URL: %w\", err)","\t\t\t}","\t\t} else if i.Ref.Kind == triggersv1.NamespacedInterceptorKind {","\t\t\tif r.InterceptorLister == nil {","\t\t\t\tr.Logger.Debugf(\"nil lister\")","\t\t\t}","\t\t\tic, err := r.InterceptorLister.Interceptors(r.EventListenerNamespace).Get(i.GetName())","\t\t\tif err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"url resolution failed for interceptor %s with: %w\", i.GetName(), err)","\t\t\t}","\t\t\tif addr := ic.Status.Address; addr != nil \u0026\u0026 addr.URL != nil {","\t\t\t\turl = addr.URL","\t\t\t} else if url, err = ic.ResolveAddress(); err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"url resolution failed for interceptor %s with: %w\", i.GetName(), err)","\t\t\t}","\t\t\tif err != nil {","\t\t\t\treturn nil, nil, nil, fmt.Errorf(\"could not resolve nameSpacedinterceptor URL: %w\", err)","\t\t\t}","\t\t}","","\t\tinterceptorResponse, err := interceptors.Execute(context.Background(), r.HTTPClient, \u0026request, url.String())","\t\tif err != nil {","\t\t\treturn nil, nil, nil, err","\t\t}","\t\tif !interceptorResponse.Continue {","\t\t\treturn nil, nil, interceptorResponse, nil","\t\t}","","\t\tif interceptorResponse.Extensions != nil {","\t\t\t// Merge any extensions and pass it on to the next request in the chain","\t\t\tfor k, v := range interceptorResponse.Extensions {","\t\t\t\trequest.Extensions[k] = v","\t\t\t}","\t\t}","","\t\t// Clear interceptorParams for the next interceptor in chain","\t\trequest.InterceptorParams = map[string]interface{}{}","\t}","","\treturn []byte(request.Body), request.Header, \u0026triggersv1.InterceptorResponse{","\t\tContinue:   true,","\t\tExtensions: request.Extensions,","\t}, nil","}","","func (r Sink) CreateResources(triggerNS, sa string, res []json.RawMessage, triggerName, eventID string, log *zap.SugaredLogger) error {","\tdiscoveryClient := r.DiscoveryClient","\tdynamicClient := r.DynamicClient","\tvar err error","\tif len(sa) \u003e 0 {","\t\t// So at start up the discovery and dynamic clients are created using the in cluster config","\t\t// of this pod (i.e. using the credentials of the serviceaccount associated with the EventListener)","","\t\t// However, we also have a ServiceAccountName reference with each EventListenerTrigger to allow","\t\t// for more fine grained authorization control around the resources we create below.","\t\tdiscoveryClient, dynamicClient, err = r.Auth.OverrideAuthentication(sa, triggerNS, log, r.DiscoveryClient, r.DynamicClient)","\t\tif err != nil {","\t\t\tlog.Errorf(\"problem cloning rest config: %#v\", err)","\t\t\treturn err","\t\t}","\t}","","\tfor _, rr := range res {","\t\tif err := resources.Create(r.Logger, rr, triggerName, eventID, r.EventListenerName, triggerNS, discoveryClient, dynamicClient); err != nil {","\t\t\tlog.Errorf(\"problem creating obj: %#v\", err)","\t\t\treturn err","\t\t}","\t}","\treturn nil","}","","// extendBodyWithExtensions merges the extensions into the given body.","func extendBodyWithExtensions(body []byte, extensions map[string]interface{}) ([]byte, error) {","\tfor k, v := range extensions {","\t\tvb, err := json.Marshal(v)","\t\tif err != nil {","\t\t\treturn nil, fmt.Errorf(\"failed to marshal value to JSON: %w\", err)","\t\t}","\t\tbody, err = sjson.SetRawBytes(body, \"extensions.\"+k, vb)","\t\tif err != nil {","\t\t\treturn nil, fmt.Errorf(\"failed to sjson extensions to body: %w\", err)","\t\t}","\t}","","\treturn body, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,1,1,1,1,1,1,0,0,2,2,1,1,1,1,1,1,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,1,1,1,1,0,2,2,0,0,2,2,2,1,1,1,0,0,2,2,2,0,1,1,1,1,1,1,1,1,1,1,1,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,0,0,2,0,0,2,2,2,2,2,2,1,1,1,2,2,2,2,2,0,2,1,1,1,0,0,2,2,1,1,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,1,1,1,0,2,2,1,1,1,1,2,2,2,2,2,2,1,1,2,0,2,0,2,2,2,2,2,0,0,2,2,2,2,2,1,1,1,2,2,2,0,0,2,2,2,2,2,1,1,1,0,2,2,1,1,1,0,0,2,2,2,2,2,1,1,1,2,2,2,2,2,1,1,1,0,2,2,2,2,1,1,1,2,2,2,0,0,2,2,2,0,0,0,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,0,2,2,2,2,1,1,1,1,1,1,1,0,0,0,0,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,1,1,2,2,2,2,2,2,0,2,2,2,2,2,2,1,1,2,1,2,1,1,2,1,1,2,2,1,1,2,2,1,1,2,1,2,1,1,2,1,1,0,0,2,2,1,1,2,2,2,0,2,2,2,2,2,0,0,0,2,0,0,2,2,2,2,0,0,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,0,0,2,2,1,1,1,0,2,0,0,0,2,2,2,2,1,1,2,2,1,1,0,0,2,0]},{"id":95,"path":"pkg/sink/validate_payload.go","lines":["/*","Copyright 2021 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package sink","","import (","\t\"bytes\"","\t\"encoding/json\"","\t\"fmt\"","\t\"io\"","\t\"net/http\"",")","","func (r Sink) IsValidPayload(eventHandler http.Handler) http.Handler {","\treturn http.HandlerFunc(func(response http.ResponseWriter, request *http.Request) {","\t\tpayload, err := io.ReadAll(request.Body)","\t\trequest.Body = io.NopCloser(bytes.NewBuffer(payload))","\t\tif err != nil {","\t\t\tr.recordCountMetrics(failTag)","\t\t\tr.Logger.Errorf(\"Error reading event body: %s\", err)","\t\t\tresponse.WriteHeader(http.StatusInternalServerError)","\t\t\treturn","\t\t}","\t\tif r.PayloadValidation {","\t\t\tvar event map[string]interface{}","\t\t\tif err := json.Unmarshal(payload, \u0026event); err != nil {","\t\t\t\terrMsg := fmt.Sprintf(\"Invalid event body format : %s\", err)","\t\t\t\tr.recordCountMetrics(failTag)","\t\t\t\tr.Logger.Error(errMsg)","\t\t\t\tresponse.WriteHeader(http.StatusBadRequest)","\t\t\t\tresponse.Header().Set(\"Content-Type\", \"application/json\")","\t\t\t\tbody := Response{","\t\t\t\t\tEventListener: r.EventListenerName,","\t\t\t\t\tNamespace:     r.EventListenerNamespace,","\t\t\t\t\tErrorMessage:  errMsg,","\t\t\t\t}","\t\t\t\tif err := json.NewEncoder(response).Encode(body); err != nil {","\t\t\t\t\tr.Logger.Errorf(\"failed to write back sink response: %v\", err)","\t\t\t\t}","\t\t\t\treturn","\t\t\t}","\t\t}","\t\teventHandler.ServeHTTP(response, request)","\t})","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,0,0,2,0,0]},{"id":96,"path":"pkg/system/system.go","lines":["package system","","import \"os\"","","const (","\tDefaultNamespace      = \"tekton-pipelines\"","\tSystemNamespaceEnvVar = \"SYSTEM_NAMESPACE\"",")","","// GetNamespace holds the K8s namespace where our system components run.","func GetNamespace() string {","\tsystemNamespace := os.Getenv(SystemNamespaceEnvVar)","\tif systemNamespace == \"\" {","\t\treturn DefaultNamespace","\t}","\treturn systemNamespace","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0]},{"id":97,"path":"pkg/template/event.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package template","","import (","\t\"encoding/json\"","\t\"fmt\"","\t\"net/http\"","\t\"strings\"","","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"","","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"",")","","const (","\t// OldEscapeAnnotation is used to determine whether or not a TriggerTemplate","\t// should retain the old \"replace quotes with backslack quote\" behaviour","\t// when templating in params.","\t//","\t// This can be removed when this functionality is no-longer needed.","\tOldEscapeAnnotation = \"triggers.tekton.dev/old-escape-quotes\"",")","","type TriggerContext struct {","\tEventID string `json:\"eventID\"`","}","","func NewTriggerContext(eventID string) TriggerContext {","\treturn TriggerContext{EventID: eventID}","}","","// ResolveParams takes given triggerbindings and produces the resulting","// resource params.","func ResolveParams(rt ResolvedTrigger, body []byte, header http.Header, extensions map[string]interface{}, triggerContext TriggerContext) ([]triggersv1.Param, error) {","\tvar ttParams []triggersv1.ParamSpec","\tif rt.TriggerTemplate != nil {","\t\tttParams = rt.TriggerTemplate.Spec.Params","\t}","","\tout, err := applyEventValuesToParams(rt.BindingParams, body, header, extensions, ttParams, triggerContext)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to ApplyEventValuesToParams: %w\", err)","\t}","","\treturn out, nil","}","","// ResolveResources resolves a templated resource by replacing params with their values.","func ResolveResources(template *triggersv1.TriggerTemplate, params []triggersv1.Param) []json.RawMessage {","\tresources := make([]json.RawMessage, len(template.Spec.ResourceTemplates))","\tuid := UUID()","","\toldEscape := metav1.HasAnnotation(template.ObjectMeta, OldEscapeAnnotation)","","\tfor i := range template.Spec.ResourceTemplates {","\t\tresources[i] = applyParamsToResourceTemplate(params, template.Spec.ResourceTemplates[i].RawExtension.Raw, oldEscape)","\t\tresources[i] = applyUIDToResourceTemplate(resources[i], uid)","\t}","\treturn resources","}","","// event represents a HTTP event that Triggers processes","type event struct {","\tHeader     map[string]string      `json:\"header\"`","\tBody       interface{}            `json:\"body\"`","\tExtensions map[string]interface{} `json:\"extensions\"`","\tContext    TriggerContext         `json:\"context\"`","}","","// newEvent returns a new Event from HTTP headers and body","func newEvent(body []byte, headers http.Header, extensions map[string]interface{}, triggerContext TriggerContext) (*event, error) {","\tvar data interface{}","\tif len(body) \u003e 0 {","\t\tif err := json.Unmarshal(body, \u0026data); err != nil {","\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal request body: %w\", err)","\t\t}","\t}","\tjoinedHeaders := make(map[string]string, len(headers))","\tfor k, v := range headers {","\t\tjoinedHeaders[k] = strings.Join(v, \",\")","\t}","","\treturn \u0026event{","\t\tHeader:     joinedHeaders,","\t\tBody:       data,","\t\tExtensions: extensions,","\t\tContext:    triggerContext,","\t}, nil","}","","// applyEventValuesToParams returns a slice of Params with the JSONPath variables replaced","// with values from the event body, headers, and extensions.","func applyEventValuesToParams(params []triggersv1.Param, body []byte, header http.Header, extensions map[string]interface{},","\tdefaults []triggersv1.ParamSpec,","\ttriggerContext TriggerContext) ([]triggersv1.Param, error) {","\tevent, err := newEvent(body, header, extensions, triggerContext)","\tif err != nil {","\t\treturn nil, fmt.Errorf(\"failed to marshal event: %w\", err)","\t}","","\tallParamsMap := map[string]string{}","\tfor _, paramSpec := range defaults {","\t\tif paramSpec.Default != nil {","\t\t\tallParamsMap[paramSpec.Name] = *paramSpec.Default","\t\t}","\t}","","\tfor _, p := range params {","\t\tpValue := p.Value","\t\t// Find all expressions wrapped in $() from the value","\t\texpressions, originals := findTektonExpressions(pValue)","\t\tfor i, expr := range expressions {","\t\t\tval, err := parseJSONPath(event, expr)","\t\t\tif defaults != nil \u0026\u0026 err != nil {","\t\t\t\t// if the header or body was not supplied or was malformed, go with a default if it exists","\t\t\t\tv, ok := allParamsMap[p.Name]","\t\t\t\tif ok {","\t\t\t\t\tval = v","\t\t\t\t\terr = nil","\t\t\t\t}","\t\t\t}","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"failed to replace JSONPath value for param %s: %s: %w\", p.Name, p.Value, err)","\t\t\t}","\t\t\tpValue = strings.ReplaceAll(pValue, originals[i], val)","\t\t}","\t\tallParamsMap[p.Name] = pValue","\t}","\treturn convertParamMapToArray(allParamsMap), nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,2,2,2,2,2,0,2,2,2,2,0,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,0,2,2,2,2,0,2,2,2,2,2,2,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,2,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,2,2,0,2,0,2,0]},{"id":98,"path":"pkg/template/jsonpath.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package template","","import (","\t\"bytes\"","\t\"encoding/json\"","\t\"errors\"","\t\"fmt\"","\t\"io\"","\t\"net/textproto\"","\t\"reflect\"","\t\"regexp\"","\t\"strings\"","","\t\"k8s.io/client-go/util/jsonpath\"",")","","var (","\t// tektonVar captures strings that are enclosed in $()","\ttektonVar = regexp.MustCompile(`\\$\\(?([^\\)]+)\\)`)","","\t// jsonRegexp is a regular expression for JSONPath expressions","\t// with or without the enclosing {} and the leading . inside the curly","\t// braces e.g.  'a.b' or '.a.b' or '{a.b}' or '{.a.b}'","\tjsonRegexp = regexp.MustCompile(`^\\{\\.?([^{}]+)\\}$|^\\.?([^{}]+)$`)",")","","// parseJSONPath extracts a subset of the given JSON input","// using the provided JSONPath expression.","func parseJSONPath(input interface{}, expr string) (string, error) {","\tj := jsonpath.New(\"\").AllowMissingKeys(false)","\tbuf := new(bytes.Buffer)","","\t// First turn the expression into fully valid JSONPath","\texpr, err := tektonJSONPathExpression(expr)","\tif err != nil {","\t\treturn \"\", err","\t}","","\tif err := j.Parse(expr); err != nil {","\t\treturn \"\", err","\t}","","\tfullResults, err := j.FindResults(input)","\tif err != nil {","\t\treturn \"\", err","\t}","","\tfor _, r := range fullResults {","\t\tif err := printResults(buf, r); err != nil {","\t\t\treturn \"\", err","\t\t}","\t}","","\treturn buf.String(), nil","}","","// PrintResults writes the results into writer","func printResults(wr io.Writer, values []reflect.Value) error {","\tresults, err := getResults(values)","\tif err != nil {","\t\treturn fmt.Errorf(\"error getting values for jsonpath results: %w\", err)","\t}","","\tif _, err := wr.Write(results); err != nil {","\t\treturn err","\t}","\treturn nil","}","","func getResults(values []reflect.Value) ([]byte, error) {","\tif len(values) == 1 {","\t\tv := values[0]","\t\tt := reflect.TypeOf(v.Interface())","\t\tswitch {","\t\tcase t == nil:","\t\t\treturn []byte(\"null\"), nil","\t\tcase t.Kind() == reflect.String:","\t\t\tb, err := json.Marshal(v.Interface())","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"unable to marshal string value %v: %w\", v, err)","\t\t\t}","\t\t\t// A valid json string is surrounded by quotation marks; we are using this function to","\t\t\t// create a representation of the json value that can be embedded in a CRD definition and","\t\t\t// we want to leave it up to the user if they want the surrounding quotation marks or not.","\t\t\treturn b[1 : len(b)-1], nil","\t\tdefault:","\t\t\treturn json.Marshal(v.Interface())","\t\t}","\t}","","\t// More than one result - we need to return a JSON array response","\tresults := []interface{}{}","\tfor _, r := range values {","\t\tt := reflect.TypeOf(r.Interface())","\t\tif t == nil {","\t\t\tresults = append(results, nil)","\t\t} else {","\t\t\t// No special case for string here unlike above since its going to be part of a JSON array","\t\t\tresults = append(results, r.Interface())","\t\t}","\t}","\treturn json.Marshal(results)","}","","// tektonJSONPathExpression returns a valid JSONPath expression. It accepts","// a \"RelaxedJSONPath\" expression that is wrapped in the Tekton variable","// interpolation syntax i.e. $(). RelaxedJSONPath expressions can optionally","// omit the leading curly braces '{}' and '.'","func tektonJSONPathExpression(expr string) (string, error) {","\tif !isTektonExpr(expr) {","\t\treturn \"\", errors.New(\"expression not wrapped in $()\")","\t}","\tunwrapped := strings.TrimSuffix(strings.TrimPrefix(expr, \"$(\"), \")\")","\treturn relaxedJSONPathExpression(unwrapped)","}","","// RelaxedJSONPathExpression attempts to be flexible with JSONPath expressions, it accepts:","//   - metadata.name (no leading '.' or curly braces '{...}'","//   - {metadata.name} (no leading '.')","//   - .metadata.name (no curly braces '{...}')","//   - {.metadata.name} (complete expression)","//","// And transforms them all into a valid jsonpath expression:","//","//\t{.metadata.name}","//","// This function has been copied as-is from","// https://github.com/kubernetes/kubectl/blob/c273777957bd657233cf867892fb061a6498dab8/pkg/cmd/get/customcolumn.go#L47","func relaxedJSONPathExpression(pathExpression string) (string, error) {","\tif len(pathExpression) == 0 {","\t\treturn pathExpression, nil","\t}","\tsubmatches := jsonRegexp.FindStringSubmatch(pathExpression)","\tif submatches == nil {","\t\treturn \"\", errors.New(\"unexpected path string, expected a 'name1.name2' or '.name1.name2' or '{name1.name2}' or '{.name1.name2}'\")","\t}","\tif len(submatches) != 3 {","\t\treturn \"\", fmt.Errorf(\"unexpected submatch list: %v\", submatches)","\t}","\tvar fieldSpec string","\tif len(submatches[1]) != 0 {","\t\tfieldSpec = submatches[1]","\t} else {","\t\tfieldSpec = submatches[2]","\t}","\treturn fmt.Sprintf(\"{.%s}\", fieldSpec), nil","}","","// IsTektonExpr returns true if the expr is wrapped in $()","func isTektonExpr(expr string) bool {","\treturn tektonVar.MatchString(expr)","}","","// findTektonExpressions searches for and returns a slice of","// all substrings that are wrapped in $()","// substring with \"header.\" is converted with CanonicalMIMEHeaderKey in the first array","// the second array has the original substrings","func findTektonExpressions(in string) ([]string, []string) {","\tresults := []string{}","\toriginals := []string{}","","\t// No expressions to return","\tif !strings.Contains(in, \"$(\") {","\t\treturn results, originals","\t}","\t// Splits string on $( to find potential Tekton expressions","\tmaybeExpressions := strings.Split(in, \"$(\")","\tfor _, e := range maybeExpressions[1:] { // Split always returns at least one element","\t\t// Iterate until we find the first unbalanced )","\t\tnumOpenBrackets := 0","\t\tfor i, ch := range e {","\t\t\tswitch ch {","\t\t\tcase '(':","\t\t\t\tnumOpenBrackets++","\t\t\tcase ')':","\t\t\t\tnumOpenBrackets--","\t\t\t\tif numOpenBrackets \u003c 0 {","\t\t\t\t\traw := e[:i]","\t\t\t\t\toriginals = append(originals, fmt.Sprintf(\"$(%s)\", raw))","\t\t\t\t\tif strings.Index(raw, \"header.\") == 0 {","\t\t\t\t\t\traw = \"header.\" + textproto.CanonicalMIMEHeaderKey(raw[len(\"header.\"):])","\t\t\t\t\t}","\t\t\t\t\tresults = append(results, fmt.Sprintf(\"$(%s)\", raw))","\t\t\t\t}","\t\t\tdefault:","\t\t\t\tcontinue","\t\t\t}","\t\t\tif numOpenBrackets \u003c 0 {","\t\t\t\tbreak","\t\t\t}","\t\t}","\t}","\treturn results, originals","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,0,2,2,2,2,0,2,2,1,1,0,0,2,0,0,0,2,2,2,1,1,0,2,1,1,2,0,0,2,2,2,2,2,2,2,2,2,2,1,1,0,0,0,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,0,2,0,0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,0,0,0,2,2,2,0,0,0,0,0,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,2,2,0,0,0,2,0]},{"id":99,"path":"pkg/template/resource.go","lines":["/*","Copyright 2019 The Tekton Authors","","Licensed under the Apache License, Version 2.0 (the \"License\");","you may not use this file except in compliance with the License.","You may obtain a copy of the License at","","    http://www.apache.org/licenses/LICENSE-2.0","","Unless required by applicable law or agreed to in writing, software","distributed under the License is distributed on an \"AS IS\" BASIS,","WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.","See the License for the specific language governing permissions and","limitations under the License.","*/","","package template","","import (","\t\"bytes\"","\t\"encoding/json\"","\t\"fmt\"","\t\"strings\"","","\t\"github.com/google/uuid\"","\ttriggersv1 \"github.com/tektoncd/triggers/pkg/apis/triggers/v1beta1\"","\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",")","","// uidMatch determines the uid variable within the resource template","var uidMatch = []byte(`$(uid)`)","","// ResolvedTrigger contains the dereferenced TriggerBindings and","// TriggerTemplate after resolving the k8s ObjectRef.","type ResolvedTrigger struct {","\tTriggerBindings        []*triggersv1.TriggerBinding","\tClusterTriggerBindings []*triggersv1.ClusterTriggerBinding","\tTriggerTemplate        *triggersv1.TriggerTemplate","\tBindingParams          []triggersv1.Param","}","","type getTriggerBinding func(name string) (*triggersv1.TriggerBinding, error)","type getTriggerTemplate func(name string) (*triggersv1.TriggerTemplate, error)","type getClusterTriggerBinding func(name string) (*triggersv1.ClusterTriggerBinding, error)","","// ResolveTrigger takes in a trigger containing object refs to bindings and","// templates and resolves them to their underlying values.","func ResolveTrigger(trigger triggersv1.Trigger, getTB getTriggerBinding, getCTB getClusterTriggerBinding, getTT getTriggerTemplate) (ResolvedTrigger, error) {","\tbp, err := resolveBindingsToParams(trigger.Spec.Bindings, getTB, getCTB)","\tif err != nil {","\t\treturn ResolvedTrigger{}, fmt.Errorf(\"failed to resolve bindings: %w\", err)","\t}","","\tvar resolvedTT *triggersv1.TriggerTemplate","\tif trigger.Spec.Template.Spec != nil {","\t\tresolvedTT = \u0026triggersv1.TriggerTemplate{","\t\t\tObjectMeta: metav1.ObjectMeta{}, // Unused. TODO: Just return Specs from here.","\t\t\tSpec:       *trigger.Spec.Template.Spec,","\t\t}","\t} else {","\t\tvar ttName string","\t\tif trigger.Spec.Template.Ref != nil {","\t\t\tttName = *trigger.Spec.Template.Ref","\t\t}","\t\tresolvedTT, err = getTT(ttName)","\t\tif err != nil {","\t\t\treturn ResolvedTrigger{}, fmt.Errorf(\"error getting TriggerTemplate %s: %w\", ttName, err)","\t\t}","\t}","","\treturn ResolvedTrigger{TriggerTemplate: resolvedTT, BindingParams: bp}, nil","}","","// resolveBindingsToParams takes in both embedded bindings and references and returns a list of resolved Param values.ResolveBindingsToParams","func resolveBindingsToParams(bindings []*triggersv1.TriggerSpecBinding, getTB getTriggerBinding, getCTB getClusterTriggerBinding) ([]triggersv1.Param, error) {","\tbindingParams := []triggersv1.Param{}","\tfor _, b := range bindings {","\t\tswitch {","\t\tcase b.Name != \"\" \u0026\u0026 b.Value != nil:","\t\t\tbindingParams = append(bindingParams, triggersv1.Param{","\t\t\t\tName:  b.Name,","\t\t\t\tValue: *b.Value,","\t\t\t})","","\t\tcase b.Ref != \"\" \u0026\u0026 b.Kind == triggersv1.ClusterTriggerBindingKind:","\t\t\tctb, err := getCTB(b.Ref)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"error getting ClusterTriggerBinding %s: %w\", b.Name, err)","\t\t\t}","\t\t\tbindingParams = append(bindingParams, ctb.Spec.Params...)","","\t\tcase b.Ref != \"\": // if no kind is set, assume NamespacedTriggerBinding","\t\t\ttb, err := getTB(b.Ref)","\t\t\tif err != nil {","\t\t\t\treturn nil, fmt.Errorf(\"error getting TriggerBinding %s: %w\", b.Name, err)","\t\t\t}","\t\t\tbindingParams = append(bindingParams, tb.Spec.Params...)","\t\tdefault:","\t\t\treturn nil, fmt.Errorf(\"invalid binding: %v\", b)","\t\t}","\t}","","\t// Check for duplicate params","\tseen := make(map[string]bool, len(bindingParams))","\tfor _, p := range bindingParams {","\t\tif seen[p.Name] {","\t\t\treturn nil, fmt.Errorf(\"duplicate param name: %s\", p.Name)","\t\t}","\t\tseen[p.Name] = true","\t}","\treturn bindingParams, nil","}","","// escapeTektonVariables escapes Tekton variable syntax in parameter values","// to prevent them from being interpreted as actual variable references.","// It replaces $( with $$( which tells Tekton to treat it as literal text.","func escapeTektonVariables(value string) string {","\t// Escape $( to $$( to prevent Tekton from interpreting it as a variable reference","\t// This handles patterns like $(tasks.xxx), $(params.xxx), $(results.xxx), etc.","\treturn strings.ReplaceAll(value, \"$(\", \"$$(\")","}","","// applyParamsToResourceTemplate returns the TriggerResourceTemplate with the","// param values substituted for all matching param variables in the template","func applyParamsToResourceTemplate(params []triggersv1.Param, rt json.RawMessage, oldEscape bool) json.RawMessage {","\t// Assume the params are valid","\tfor _, param := range params {","\t\trt = applyParamToResourceTemplate(param, rt, oldEscape)","\t}","\treturn rt","}","","// applyParamToResourceTemplate returns the TriggerResourceTemplate with the","// param value substituted for all matching param variables in the template","func applyParamToResourceTemplate(param triggersv1.Param, rt json.RawMessage, oldEscape bool) json.RawMessage {","\t// Assume the param is valid","\tparamVariable := fmt.Sprintf(\"$(tt.params.%s)\", param.Name)","\t// Escape quotes so that JSON strings can be appended to regular strings.","\t// See #257 for discussion on this behavior.","\tparamValue := param.Value","\tif oldEscape {","\t\tparamValue = strings.ReplaceAll(paramValue, `\"`, `\\\"`)","\t}","\t// Escape Tekton variable syntax to prevent validation errors","\t// when parameter values contain literal $(tasks.*) or similar patterns","\tparamValue = escapeTektonVariables(paramValue)","\treturn bytes.ReplaceAll(rt, []byte(paramVariable), []byte(paramValue))","}","","// UUID generates a Universally Unique IDentifier following RFC 4122.","var UUID = func() string { return uuid.New().String() }","","// applyUIDToResourceTemplate returns the TriggerResourceTemplate after uid replacement","// The same uid should be used per trigger to properly address resources throughout the TriggerTemplate.","func applyUIDToResourceTemplate(rt json.RawMessage, uid string) json.RawMessage {","\treturn bytes.ReplaceAll(rt, uidMatch, []byte(uid))","}","","func convertParamMapToArray(paramMap map[string]string) []triggersv1.Param {","\tparams := []triggersv1.Param{}","\tfor name, value := range paramMap {","\t\tparams = append(params, triggersv1.Param{Name: name, Value: value})","\t}","\treturn params","}","","// mergeBindingParams merges params across multiple bindings.","func mergeBindingParams(bindings []*triggersv1.TriggerBinding, clusterbindings []*triggersv1.ClusterTriggerBinding) ([]triggersv1.Param, error) {","\tparams := []triggersv1.Param{}","\tfor _, b := range bindings {","\t\tparams = append(params, b.Spec.Params...)","\t}","\tfor _, cb := range clusterbindings {","\t\tparams = append(params, cb.Spec.Params...)","\t}","\tseen := make(map[string]bool, len(params))","\tfor _, p := range params {","\t\tif seen[p.Name] {","\t\t\treturn nil, fmt.Errorf(\"duplicate param name: %s\", p.Name)","\t\t}","\t\tseen[p.Name] = true","\t}","\treturn params, nil","}"],"coverage":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,2,2,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,0,2,0,0,0,2,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,0,2,0,0,0,0,0,2,2,2,2,2,0,0,0,2,2,2,2,2,2,0,0,0,0,2,2,2,2,2,2,2,2,2,0,0,2,2,0,0,0,2,0,0,0,2,2,2,0,2,2,2,2,2,2,0,0,0,2,2,2,2,2,2,2,2,2,2,2,2,2,2,0,2,0]}],"tree":{"name":".","type":"dir","children":[{"name":"examples","type":"dir","children":[{"name":"v1alpha1","type":"dir","children":[{"name":"webhook-interceptors","type":"dir","children":[{"name":"main.go","type":"file","fileId":0}]}]}]},{"name":"pkg","type":"dir","children":[{"name":"adapter","type":"dir","children":[{"name":"adapter.go","type":"file","fileId":1}]},{"name":"apis","type":"dir","children":[{"name":"config","type":"dir","children":[{"name":"default.go","type":"file","fileId":2},{"name":"feature_flags.go","type":"file","fileId":3},{"name":"store.go","type":"file","fileId":4}]},{"name":"triggers","type":"dir","children":[{"name":"contexts","type":"dir","children":[{"name":"contexts.go","type":"file","fileId":5}]},{"name":"v1alpha1","type":"dir","children":[{"name":"cluster_interceptor_defaults.go","type":"file","fileId":6},{"name":"cluster_interceptor_types.go","type":"file","fileId":7},{"name":"cluster_interceptor_validation.go","type":"file","fileId":8},{"name":"cluster_trigger_binding_defaults.go","type":"file","fileId":9},{"name":"cluster_trigger_binding_types.go","type":"file","fileId":10},{"name":"cluster_trigger_binding_validation.go","type":"file","fileId":11},{"name":"event_listener_defaults.go","type":"file","fileId":12},{"name":"event_listener_types.go","type":"file","fileId":13},{"name":"event_listener_validation.go","type":"file","fileId":14},{"name":"interceptor_defaults.go","type":"file","fileId":15},{"name":"interceptor_types.go","type":"file","fileId":16},{"name":"interceptor_validation.go","type":"file","fileId":17},{"name":"register.go","type":"file","fileId":18},{"name":"trigger_binding_defaults.go","type":"file","fileId":19},{"name":"trigger_binding_types.go","type":"file","fileId":20},{"name":"trigger_binding_validation.go","type":"file","fileId":21},{"name":"trigger_defaults.go","type":"file","fileId":22},{"name":"trigger_template_defaults.go","type":"file","fileId":23},{"name":"trigger_template_validation.go","type":"file","fileId":24},{"name":"trigger_types.go","type":"file","fileId":25},{"name":"trigger_types_convert.go","type":"file","fileId":26},{"name":"trigger_validation.go","type":"file","fileId":27}]},{"name":"v1beta1","type":"dir","children":[{"name":"cluster_trigger_binding_defaults.go","type":"file","fileId":28},{"name":"cluster_trigger_binding_types.go","type":"file","fileId":29},{"name":"cluster_trigger_binding_validation.go","type":"file","fileId":30},{"name":"event_listener_defaults.go","type":"file","fileId":31},{"name":"event_listener_types.go","type":"file","fileId":32},{"name":"event_listener_validation.go","type":"file","fileId":33},{"name":"interceptor_types.go","type":"file","fileId":34},{"name":"register.go","type":"file","fileId":35},{"name":"trigger_binding_defaults.go","type":"file","fileId":36},{"name":"trigger_binding_types.go","type":"file","fileId":37},{"name":"trigger_binding_validation.go","type":"file","fileId":38},{"name":"trigger_defaults.go","type":"file","fileId":39},{"name":"trigger_template_defaults.go","type":"file","fileId":40},{"name":"trigger_template_validation.go","type":"file","fileId":41},{"name":"trigger_types.go","type":"file","fileId":42},{"name":"trigger_types_convert.go","type":"file","fileId":43},{"name":"trigger_validation.go","type":"file","fileId":44},{"name":"version_validation.go","type":"file","fileId":45}]},{"name":"validation.go","type":"file","fileId":46}]}]},{"name":"bootstrap","type":"dir","children":[{"name":"bootstrap.go","type":"file","fileId":47},{"name":"file_helper.go","type":"file","fileId":48},{"name":"github.go","type":"file","fileId":49},{"name":"installer.go","type":"file","fileId":50},{"name":"rbac.go","type":"file","fileId":51},{"name":"templates.go","type":"file","fileId":52}]},{"name":"dynamic","type":"dir","children":[{"name":"custom_reconcile.go","type":"file","fileId":53},{"name":"dynamic.go","type":"file","fileId":54}]},{"name":"interceptors","type":"dir","children":[{"name":"bitbucket","type":"dir","children":[{"name":"bitbucket.go","type":"file","fileId":55}]},{"name":"cel","type":"dir","children":[{"name":"cel.go","type":"file","fileId":56},{"name":"triggers.go","type":"file","fileId":57}]},{"name":"github","type":"dir","children":[{"name":"github.go","type":"file","fileId":58}]},{"name":"gitlab","type":"dir","children":[{"name":"gitlab.go","type":"file","fileId":59}]},{"name":"server","type":"dir","children":[{"name":"server.go","type":"file","fileId":62}]},{"name":"slack","type":"dir","children":[{"name":"slack.go","type":"file","fileId":63}]},{"name":"webhook","type":"dir","children":[{"name":"webhook.go","type":"file","fileId":64}]},{"name":"interceptors.go","type":"file","fileId":60},{"name":"secret_getter.go","type":"file","fileId":61}]},{"name":"observability","type":"dir","children":[{"name":"attributekey","type":"dir","children":[{"name":"key.go","type":"file","fileId":65}]},{"name":"configmap","type":"dir","children":[{"name":"parse.go","type":"file","fileId":67}]},{"name":"metrics","type":"dir","children":[{"name":"config.go","type":"file","fileId":68},{"name":"provider.go","type":"file","fileId":69}]},{"name":"resource","type":"dir","children":[{"name":"default.go","type":"file","fileId":70}]},{"name":"runtime","type":"dir","children":[{"name":"config.go","type":"file","fileId":71}]},{"name":"tracing","type":"dir","children":[{"name":"config.go","type":"file","fileId":72}]},{"name":"config.go","type":"file","fileId":66}]},{"name":"reconciler","type":"dir","children":[{"name":"clusterinterceptor","type":"dir","children":[{"name":"clusterinterceptor.go","type":"file","fileId":73},{"name":"controller.go","type":"file","fileId":74}]},{"name":"eventlistener","type":"dir","children":[{"name":"resources","type":"dir","children":[{"name":"config.go","type":"file","fileId":77},{"name":"container.go","type":"file","fileId":78},{"name":"custom.go","type":"file","fileId":79},{"name":"deployment.go","type":"file","fileId":80},{"name":"meta.go","type":"file","fileId":81},{"name":"service.go","type":"file","fileId":82}]},{"name":"controller.go","type":"file","fileId":75},{"name":"eventlistener.go","type":"file","fileId":76}]},{"name":"events","type":"dir","children":[{"name":"event.go","type":"file","fileId":83}]},{"name":"interceptor","type":"dir","children":[{"name":"controller.go","type":"file","fileId":84},{"name":"interceptor.go","type":"file","fileId":85}]},{"name":"metrics","type":"dir","children":[{"name":"injection.go","type":"file","fileId":86},{"name":"metrics.go","type":"file","fileId":87}]}]},{"name":"resources","type":"dir","children":[{"name":"create.go","type":"file","fileId":88}]},{"name":"sink","type":"dir","children":[{"name":"cloudevent","type":"dir","children":[{"name":"cloudevent.go","type":"file","fileId":90},{"name":"cloudeventclient.go","type":"file","fileId":91}]},{"name":"auth_override.go","type":"file","fileId":89},{"name":"initialization.go","type":"file","fileId":92},{"name":"metrics.go","type":"file","fileId":93},{"name":"sink.go","type":"file","fileId":94},{"name":"validate_payload.go","type":"file","fileId":95}]},{"name":"system","type":"dir","children":[{"name":"system.go","type":"file","fileId":96}]},{"name":"template","type":"dir","children":[{"name":"event.go","type":"file","fileId":97},{"name":"jsonpath.go","type":"file","fileId":98},{"name":"resource.go","type":"file","fileId":99}]}]}]},"summary":{"totalLines":6083,"coveredLines":4495,"percent":73.89445997040934}};
    </script>
    <script>
      window.COVERAGE_CONFIG = {"syntaxEnabled":true};
    </script>
    <script>
      (function() {
  'use strict';

  const data = window.COVERAGE_DATA;
  const config = window.COVERAGE_CONFIG || { syntaxEnabled: true };

  // State
  let currentFileId = null;
  let searchQuery = '';
  let contentSearchQuery = '';
  let matches = [];
  let currentMatchIndex = -1;
  let expandedDirs = new Set();
  let syntaxHighlightEnabled = config.syntaxEnabled;
  let sortMode = 'name'; // 'name' or 'coverage'
  let anchorLine = null;        // First line clicked (anchor for shift-select)
  let selectedRange = null;     // { start: N, end: M } or null

  // DOM elements
  const fileTree = document.getElementById('file-tree');
  const viewport = document.getElementById('viewport');
  const filePath = document.getElementById('file-path');
  const summary = document.getElementById('summary');
  const searchInput = document.getElementById('search-input');
  const contentSearch = document.getElementById('content-search');
  const matchInfo = document.getElementById('match-info');
  const prevMatch = document.getElementById('prev-match');
  const nextMatch = document.getElementById('next-match');
  const themeToggle = document.getElementById('theme-toggle');
  const syntaxToggle = document.getElementById('syntax-toggle');
  const helpModal = document.getElementById('help-modal');
  const closeHelp = document.getElementById('close-help');
  const helpToggle = document.getElementById('help-toggle');

  // Coverage cache: fileId -> percentage
  let coverageCache = new Map();

  function initCoverageCache() {
    data.files.forEach((file, idx) => {
      coverageCache.set(idx, calculateFileCoverage(idx));
    });
  }

  function calculateFileCoverage(fileId) {
    const file = data.files[fileId];
    let totalStatements = 0;
    let coveredStatements = 0;

    file.coverage.forEach(cov => {
      if (cov > 0) totalStatements++;
      if (cov === 2) coveredStatements++;
    });

    return totalStatements === 0 ? 0 : (coveredStatements / totalStatements) * 100;
  }

  function calculateDirectoryCoverage(node) {
    if (node.type === 'file') {
      return coverageCache.get(node.fileId) || 0;
    }

    let totalCoverage = 0;
    let fileCount = 0;

    node.children?.forEach(child => {
      const childCov = calculateDirectoryCoverage(child);
      totalCoverage += childCov;
      fileCount++;
    });

    return fileCount === 0 ? 0 : totalCoverage / fileCount;
  }

  function sortTreeNodes(node, mode) {
    if (!node.children || node.children.length === 0) return node;

    // Deep copy to avoid mutating original
    const sorted = { ...node };
    sorted.children = [...node.children].map(child => sortTreeNodes(child, mode));

    // Sort children
    sorted.children.sort((a, b) => {
      // Directories always first
      if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;

      if (mode === 'coverage') {
        const aCov = calculateDirectoryCoverage(a);
        const bCov = calculateDirectoryCoverage(b);
        console.log('Sorting:', a.name, '('+aCov.toFixed(1)+'%) vs', b.name, '('+bCov.toFixed(1)+'%)', '=', bCov - aCov);
        // Descending: high coverage first
        return aCov !== bCov ? bCov - aCov : a.name.localeCompare(b.name);
      }

      return a.name.localeCompare(b.name);
    });

    return sorted;
  }

  // Initialize
  function init() {
    initCoverageCache();
    loadSortPreference();
    renderSummary();
    renderTree();
    setupEventListeners();
    loadTheme();
    loadSyntaxPreference();

    // Check for deep link hash first, otherwise select first file
    if (!navigateToHash() && data.files.length > 0) {
      selectFile(0);
    }

    // Listen for hash changes (browser back/forward)
    window.addEventListener('hashchange', navigateToHash);
  }

  // Deep linking: parse URL hash
  function parseHash() {
    const hash = window.location.hash.slice(1);
    if (!hash) return null;

    const match = hash.match(/^file-(\d+)(?::line-(\d+)(?:-(\d+))?)?$/);
    if (!match) return null;

    return {
      fileId: parseInt(match[1], 10),
      lineStart: match[2] ? parseInt(match[2], 10) : null,
      lineEnd: match[3] ? parseInt(match[3], 10) : null
    };
  }

  // Deep linking: navigate to hash location
  function navigateToHash() {
    const target = parseHash();
    if (!target) return false;

    if (target.fileId < 0 || target.fileId >= data.files.length) return false;

    selectFile(target.fileId);

    if (target.lineStart) {
      requestAnimationFrame(() => {
        const lineEnd = target.lineEnd || target.lineStart;
        anchorLine = target.lineStart;
        selectedRange = { start: target.lineStart, end: lineEnd };
        selectLineRange(target.lineStart, lineEnd);
        scrollToLine(target.lineStart);
      });
    }

    return true;
  }

  // Deep linking: scroll to and highlight a line
  function scrollToLine(lineNum) {
    const lineEl = document.querySelector('.code-line[data-line="' + lineNum + '"]');
    if (!lineEl) return;

    lineEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  // Clear all selected lines
  function clearLineSelection() {
    document.querySelectorAll('.code-line.selected-line').forEach(el => {
      el.classList.remove('selected-line');
    });
  }

  // Select a range of lines (inclusive)
  function selectLineRange(start, end) {
    clearLineSelection();
    const minLine = Math.min(start, end);
    const maxLine = Math.max(start, end);
    for (let i = minLine; i <= maxLine; i++) {
      const lineEl = document.querySelector('.code-line[data-line="' + i + '"]');
      if (lineEl) {
        lineEl.classList.add('selected-line');
      }
    }
  }

  // Deep linking: update URL hash
  function updateHash(fileId, lineStart, lineEnd) {
    let hash = 'file-' + fileId;
    if (lineStart) {
      hash += ':line-' + lineStart;
      if (lineEnd && lineEnd !== lineStart) {
        // Normalise so start < end
        const minLine = Math.min(lineStart, lineEnd);
        const maxLine = Math.max(lineStart, lineEnd);
        hash = 'file-' + fileId + ':line-' + minLine + '-' + maxLine;
      }
    }
    history.replaceState(null, '', '#' + hash);
  }

  function renderSummary() {
    // Build summary safely using DOM methods
    summary.textContent = '';
    const span = document.createElement('span');
    span.className = 'percent';
    span.textContent = data.summary.percent.toFixed(1) + '%';
    summary.appendChild(span);
    summary.appendChild(document.createTextNode(
      ' coverage (' + data.summary.coveredLines + '/' + data.summary.totalLines + ' lines)'
    ));
  }

  function renderTree() {
    fileTree.textContent = '';
    // Auto-expand all top-level directories
    if (data.tree.children && data.tree.children.length > 0) {
      data.tree.children.forEach(child => {
        if (child.type === 'dir') {
          expandedDirs.add(getNodePath(child, 0));
        }
      });
    }
    const sortedTree = sortTreeNodes(data.tree, sortMode);
    renderNode(sortedTree, fileTree, 0);
  }

  function renderNode(node, container, depth) {
    if (node.name === '.' && node.type === 'dir') {
      // Root node, render children directly
      node.children.forEach(child => renderNode(child, container, depth));
      return;
    }

    const nodeEl = document.createElement('div');
    nodeEl.className = 'tree-node';
    nodeEl.dataset.name = node.name.toLowerCase();

    const item = document.createElement('div');
    item.className = 'tree-item';
    item.style.setProperty('--depth', depth);

    const icon = document.createElement('span');
    icon.className = 'icon';

    const name = document.createElement('span');
    name.className = 'name';
    name.textContent = node.name;

    if (node.type === 'dir') {
      const dirPath = getNodePath(node, depth);
      icon.textContent = expandedDirs.has(dirPath) ? '\u25BC' : '\u25B6';
      if (expandedDirs.has(dirPath)) {
        nodeEl.classList.add('expanded');
      }

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleDir(nodeEl, dirPath, icon);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to all directories
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);

      if (node.children && node.children.length > 0) {
        const children = document.createElement('div');
        children.className = 'tree-children';
        node.children.forEach(child => renderNode(child, children, depth + 1));
        nodeEl.appendChild(children);
      }
    } else {
      icon.textContent = '\uD83D\uDCC4';
      nodeEl.dataset.fileId = node.fileId;

      item.addEventListener('click', (e) => {
        e.stopPropagation();
        selectFile(node.fileId);
      });

      item.appendChild(icon);
      item.appendChild(name);

      // Add coverage badge to files
      const badge = document.createElement('span');
      badge.className = 'coverage-badge';
      badge.textContent = calculateDirectoryCoverage(node).toFixed(1) + '%';
      item.appendChild(badge);

      nodeEl.appendChild(item);
    }

    container.appendChild(nodeEl);
  }

  function getNodePath(node, depth) {
    return node.name + '_' + depth;
  }

  function toggleDir(nodeEl, path, icon) {
    if (nodeEl.classList.contains('expanded')) {
      nodeEl.classList.remove('expanded');
      expandedDirs.delete(path);
      icon.textContent = '\u25B6';
    } else {
      nodeEl.classList.add('expanded');
      expandedDirs.add(path);
      icon.textContent = '\u25BC';
    }
  }

  function selectFile(fileId) {
    currentFileId = fileId;
    matches = [];
    currentMatchIndex = -1;
    matchInfo.textContent = '';
    contentSearch.value = '';
    contentSearchQuery = '';
    anchorLine = null;
    selectedRange = null;

    // Update selection in tree
    document.querySelectorAll('.tree-item.selected').forEach(el => {
      el.classList.remove('selected');
    });
    const selected = document.querySelector('[data-file-id="' + fileId + '"] .tree-item');
    if (selected) {
      selected.classList.add('selected');
    }

    const file = data.files[fileId];
    if (!file) return;

    filePath.textContent = file.path;
    renderCode(file);

    // Update URL hash for deep linking
    updateHash(fileId, null);
  }

  function renderCode(file) {
    viewport.textContent = '';

    if (!file.lines || file.lines.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty-state';
      const iconDiv = document.createElement('div');
      iconDiv.className = 'icon';
      iconDiv.textContent = '\uD83D\uDCED';
      const textDiv = document.createElement('div');
      textDiv.textContent = 'No content';
      empty.appendChild(iconDiv);
      empty.appendChild(textDiv);
      viewport.appendChild(empty);
      return;
    }

    const container = document.createElement('div');
    container.className = 'code-container';

    file.lines.forEach((line, idx) => {
      const lineEl = document.createElement('div');
      lineEl.className = 'code-line';
      lineEl.dataset.line = idx + 1;

      const cov = file.coverage[idx];
      if (cov === 2) {
        lineEl.classList.add('covered');
      } else if (cov === 1) {
        lineEl.classList.add('uncovered');
      }

      const gutter = document.createElement('div');
      gutter.className = 'gutter';

      const lineNum = document.createElement('div');
      lineNum.className = 'line-number';
      lineNum.textContent = idx + 1;
      lineNum.title = 'Click to select line, Shift+Click for range';

      // Add click handler for line number deep linking
      const lineNumber = idx + 1;
      lineNum.addEventListener('click', (e) => {
        e.stopPropagation();

        if (e.shiftKey && anchorLine !== null) {
          // Shift-click: select range from anchor to clicked line
          const start = Math.min(anchorLine, lineNumber);
          const end = Math.max(anchorLine, lineNumber);
          selectedRange = { start: start, end: end };
          selectLineRange(start, end);
          updateHash(currentFileId, start, end);
        } else {
          // Regular click: set anchor and select single line
          anchorLine = lineNumber;
          selectedRange = { start: lineNumber, end: lineNumber };
          selectLineRange(lineNumber, lineNumber);
          updateHash(currentFileId, lineNumber, null);
        }
      });

      const content = document.createElement('div');
      content.className = 'line-content';
      content.textContent = line || ' ';

      lineEl.appendChild(gutter);
      lineEl.appendChild(lineNum);
      lineEl.appendChild(content);
      container.appendChild(lineEl);
    });

    viewport.appendChild(container);

    // Apply syntax highlighting after rendering if enabled
    if (syntaxHighlightEnabled) {
      applySyntaxHighlighting();
    }
  }

  function setupEventListeners() {
    // File search
    let searchTimeout;
    searchInput.addEventListener('input', (e) => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        searchQuery = e.target.value.toLowerCase();
        filterTree();
      }, 300);
    });

    // Content search
    let contentTimeout;
    contentSearch.addEventListener('input', (e) => {
      clearTimeout(contentTimeout);
      contentTimeout = setTimeout(() => {
        contentSearchQuery = e.target.value;
        searchInFile();
      }, 300);
    });

    contentSearch.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        if (e.shiftKey) {
          goToPrevMatch();
        } else {
          goToNextMatch();
        }
      }
    });

    prevMatch.addEventListener('click', goToPrevMatch);
    nextMatch.addEventListener('click', goToNextMatch);

    // Theme toggle
    themeToggle.addEventListener('click', toggleTheme);

    // Syntax toggle
    syntaxToggle.addEventListener('click', toggleSyntax);

    // Sort controls
    const sortButtons = document.querySelectorAll('.sort-btn');
    console.log('Found', sortButtons.length, 'sort buttons');
    sortButtons.forEach(btn => {
      console.log('Attaching click handler to button:', btn.dataset.sort);
      btn.addEventListener('click', () => {
        console.log('Sort button clicked:', btn.dataset.sort);
        changeSortMode(btn.dataset.sort);
      });
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f' && currentFileId !== null) {
        e.preventDefault();
        contentSearch.focus();
      }
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        searchInput.focus();
      }
      // Help modal
      if (e.key === '?' && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        showHelp();
      }
      if (e.key === 'Escape') {
        // Exit search if focused
        if (document.activeElement === searchInput) {
          searchInput.value = '';
          searchQuery = '';
          filterTree();
          searchInput.blur();
          viewport.focus();
          return;
        }
        if (document.activeElement === contentSearch) {
          contentSearch.value = '';
          contentSearchQuery = '';
          matchInfo.textContent = '';
          matches = [];
          currentMatchIndex = -1;
          if (currentFileId !== null) {
            renderCode(data.files[currentFileId]);
          }
          contentSearch.blur();
          viewport.focus();
          return;
        }
        hideHelp();
      }
    });

    closeHelp.addEventListener('click', hideHelp);
    helpToggle.addEventListener('click', showHelp);
    helpModal.addEventListener('click', (e) => {
      if (e.target === helpModal) hideHelp();
    });
  }

  function filterTree() {
    const nodes = document.querySelectorAll('.tree-node');

    if (!searchQuery) {
      nodes.forEach(n => n.classList.remove('hidden'));
      return;
    }

    nodes.forEach(node => {
      const name = node.dataset.name || '';
      const fileId = node.dataset.fileId;

      if (fileId !== undefined) {
        const file = data.files[parseInt(fileId)];
        const matchesQuery = file && file.path.toLowerCase().includes(searchQuery);
        node.classList.toggle('hidden', !matchesQuery);
      } else {
        const hasVisibleChild = Array.from(node.querySelectorAll('[data-file-id]')).some(f => {
          const fid = parseInt(f.dataset.fileId);
          const file = data.files[fid];
          return file && file.path.toLowerCase().includes(searchQuery);
        });
        node.classList.toggle('hidden', !hasVisibleChild);
        if (hasVisibleChild && searchQuery) {
          node.classList.add('expanded');
          const icon = node.querySelector('.icon');
          if (icon && icon.textContent === '\u25B6') {
            icon.textContent = '\u25BC';
          }
        }
      }
    });
  }

  function searchInFile() {
    matches = [];
    currentMatchIndex = -1;

    // Re-render code to clear highlights
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }

    if (!contentSearchQuery || currentFileId === null) {
      matchInfo.textContent = '';
      return;
    }

    const file = data.files[currentFileId];
    if (!file) return;

    const query = contentSearchQuery.toLowerCase();

    file.lines.forEach((line, idx) => {
      const text = line || '';
      const lowerText = text.toLowerCase();
      let pos = 0;
      let matchIndex;

      while ((matchIndex = lowerText.indexOf(query, pos)) !== -1) {
        matches.push({ line: idx, start: matchIndex, length: query.length });
        pos = matchIndex + 1;
      }
    });

    if (matches.length > 0) {
      highlightMatches();
      currentMatchIndex = 0;
      scrollToMatch(0);
      updateMatchInfo();
    } else {
      matchInfo.textContent = 'No matches';
    }
  }

  function highlightMatches() {
    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    // Group matches by line
    const matchesByLine = {};
    matches.forEach((m, idx) => {
      if (!matchesByLine[m.line]) matchesByLine[m.line] = [];
      matchesByLine[m.line].push({ ...m, idx });
    });

    Object.keys(matchesByLine).forEach(lineIdx => {
      const lineEl = lineEls[parseInt(lineIdx)];
      if (!lineEl) return;

      const content = lineEl.querySelector('.line-content');
      if (!content) return;

      const text = file.lines[parseInt(lineIdx)] || '';
      const lineMatches = matchesByLine[lineIdx].sort((a, b) => a.start - b.start);

      // Build content using DOM nodes for safety
      content.textContent = '';
      let lastEnd = 0;

      lineMatches.forEach(m => {
        // Text before match
        if (m.start > lastEnd) {
          content.appendChild(document.createTextNode(text.substring(lastEnd, m.start)));
        }
        // Match span
        const span = document.createElement('span');
        span.className = 'match-highlight';
        span.dataset.matchIdx = m.idx;
        span.textContent = text.substring(m.start, m.start + m.length);
        content.appendChild(span);
        lastEnd = m.start + m.length;
      });

      // Text after last match
      if (lastEnd < text.length) {
        content.appendChild(document.createTextNode(text.substring(lastEnd)));
      }

      // Handle empty line
      if (content.childNodes.length === 0) {
        content.textContent = ' ';
      }
    });
  }

  function scrollToMatch(idx) {
    document.querySelectorAll('.current-match').forEach(el => {
      el.classList.remove('current-match');
    });

    const matchEl = document.querySelector('[data-match-idx="' + idx + '"]');
    if (matchEl) {
      matchEl.classList.add('current-match');
      matchEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function updateMatchInfo() {
    if (matches.length === 0) {
      matchInfo.textContent = 'No matches';
    } else {
      matchInfo.textContent = (currentMatchIndex + 1) + '/' + matches.length;
    }
  }

  function goToNextMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex + 1) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function goToPrevMatch() {
    if (matches.length === 0) return;
    currentMatchIndex = (currentMatchIndex - 1 + matches.length) % matches.length;
    scrollToMatch(currentMatchIndex);
    updateMatchInfo();
  }

  function toggleTheme() {
    const body = document.body;
    const current = body.dataset.theme;
    const next = current === 'dark' ? 'light' : 'dark';
    body.dataset.theme = next;
    localStorage.setItem('coverage-theme', next);
  }

  function loadTheme() {
    const saved = localStorage.getItem('coverage-theme');
    if (saved) {
      document.body.dataset.theme = saved;
    }
  }

  function applySyntaxHighlighting() {
    if (!syntaxHighlightEnabled || currentFileId === null) return;
    if (typeof hljs === 'undefined') return;

    const file = data.files[currentFileId];
    if (!file) return;

    const lineEls = document.querySelectorAll('.code-line');

    lineEls.forEach((lineEl, idx) => {
      const cov = file.coverage[idx];
      // Only highlight lines with no coverage info
      if (cov !== 0) return;

      const content = lineEl.querySelector('.line-content');
      if (!content || !content.textContent.trim()) return;

      const text = content.textContent;

      // Use hljs.highlight() which returns result object
      const result = hljs.highlight(text, { language: 'go' });

      // Parse the highlighted HTML safely using DOMParser
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + result.value + '</div>', 'text/html');
      const wrapper = doc.body.firstChild;

      // Clear and append parsed nodes
      content.textContent = '';
      while (wrapper.firstChild) {
        content.appendChild(wrapper.firstChild);
      }
    });
  }

  function toggleSyntax() {
    syntaxHighlightEnabled = !syntaxHighlightEnabled;
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
    localStorage.setItem('coverage-syntax', syntaxHighlightEnabled ? 'on' : 'off');

    // Re-render current file
    if (currentFileId !== null) {
      const file = data.files[currentFileId];
      if (file) {
        renderCode(file);
      }
    }
  }

  function loadSyntaxPreference() {
    const saved = localStorage.getItem('coverage-syntax');
    if (saved !== null) {
      // User preference overrides default
      syntaxHighlightEnabled = saved === 'on';
    }
    // Update button state
    syntaxToggle.classList.toggle('active', syntaxHighlightEnabled);
  }

  function changeSortMode(mode) {
    if (sortMode === mode) return;

    console.log('Changing sort mode from', sortMode, 'to', mode);
    sortMode = mode;
    localStorage.setItem('coverage-sort-mode', mode);

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === mode);
    });

    // Re-render tree
    renderTree();
  }

  function loadSortPreference() {
    const saved = localStorage.getItem('coverage-sort-mode');
    if (saved && (saved === 'name' || saved === 'coverage')) {
      sortMode = saved;
    }

    // Update button states
    document.querySelectorAll('.sort-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.sort === sortMode);
    });
  }

  function showHelp() {
    helpModal.classList.remove('hidden');
  }

  function hideHelp() {
    helpModal.classList.add('hidden');
  }

  // Start the app
  init();
})();

    </script>
  </body>
</html>
